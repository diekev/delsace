Faitures
--------
- utilisation de caractères unicodes UTF-8 dans les sources
- impression dans la sortie standard via printf
- contrôle de flux via si/sinon
- boucle avec plage
- boucle sans plage
- déclaration et manipulation de variable
- déclaration de structure
- déclaration et appel de fonctions
- nommage explicit des paramètres des fonctions f(a=0);
- règle de définition unique : deux structures ou deux fonctions ou deux variables ne peuvent avoir le même nom
- inférence de type
- concaténation des chaînes littérales connues lors de la compilation via l'opérateur '+'
- constant folding
- manipulation de structure
- manipulation de tableaux
- transtypage entre types simples


À faire
-------
- transtypage entre types complexes
- transtypage automatique des valeurs littérales dans les expressions ou autre
---- littérale + littérale -> littérale  # OK
---- type + littérale      -> type       # À FAIRE (OK pour Z32, R64)
---- littérale + type      -> type       # À FAIRE (OK pour Z32, R64)
---- caractere + entier    -> caractère  # À FAIRE
---- entier + caractere    -> caractère  # À FAIRE
---- chaîne + caractere    -> chaîne     # À FAIRE
---- caractere + chaîne    -> chaîne     # À FAIRE
- initialisation de tableaux dans la déclaration
- initialisation de structures dans la déclaration
- fonctions variadiques
- fonctions gabarit/génériques avec contrats/concepts
- structures gabarit/génériques
- association/switch
- type chaîne caractère par défaut
- type nombre réel sur 16-bit
- nommage et typage explicite des énums pour éviter les problèmes de transtypage ou autre
- déréférencement de pointeur (via 'mémoire')
- types spéciaux pour chaînes de caractères et caractère simple
- stack canaries
- initialisation explicite des membres des structures lors de leur définition


À faire (tests)
---------------
- test caractère simple (assignation + modification)
- test opérateurs simple
- test mélanges types/nombres littéraux
- test @var[0]
- test chaine littérale, déclaration, assignement de pointeur et tableau


Idées
-----
- opérateur 'chaîne' pour retourner une chaîne de caractère contenant ce qu'il y a entre ses parenthèses : par exemple chaîne(a) -> "a"
- mot clés pour le nom du fichier courant, la ligne, la colonne, et le temps où la ligne a été rencontré pour la première foix (__fichier__, __ligne__, __colonne__, __temps__)
- réflection, données sur les structures lors de la compilation
- sérialisation automatique des structures, notamment pour l'impression
- utilisation de propriétés pour appeler un code avant ou après une fonction à chaque qu'elle est appelée (comme ctor/dtor en C++)
- mot clé pour déférer l'exécution d'un bloc lors du retour d'une fonction
- multiple valeurs de retour, notamment en remplacement des exceptions
- héritage/polymorphisme par enlignage de structures dans d'autres
- surcharges des opérateurs
- déclarations de nouveaux types par alias d'un type connu (comme typedef en C/C++, mais avec typage strict) (mot-clé 'entredit', pour empêcher qu'un opérateur soit hérité)
- surcharge de fonctions
- fonction membres de structures similaire à Python avec 'self' explicit, ou appel explicit en passant l'objet en premier paramètre
- vérification automatique des limites des tableaux (peut-être interdiction de passer des pointeurs, et passage uniquement de tableaux)
- passer uniquement par référence, ou utilisation d'un mot-clé spécifique pour dire qu'un paramètre peut-être nul
- mot-clés pour des tests unitaires, avec maintenance des fonctions auxilliaires des tests par le compileur
- mot-clés pour des tests fuzzés, avec maintenance des fonctions auxilliaires des tests par le compileur
- mot-clés pour un mutli-threading par système de tâches concurrentes, avec maintenance des fonctions auxilliaires par le compileur
- transformer les messages d'erreur en tutoriaux


Sécurité/évitement des bugs
---------------------------
- les variables sont constantes par défaut
- les variables doivent être initialisées lors de leur déclaration
- aucune conversion n'est implicite (sauf pour les valeurs littérales)
- les contrôles de flux doivent avoir des valeurs booléennes explicit
- l'opérateur booléen d'inversion '!' ne peut prendre qu'une valeur booléenne
- les portées doivent être explicitement entourées de { } pour éviter que des expressions ne devant qu'être exécutées dans un contrôle de flux ne soient pas exécutées en dehors.
- l'opérateur d'assignemet '=' ne retourne pas de valeur pour éviter toute confusion avec '==' (peut-être à réviser puisque il n'a pas de conversion implicite vers des valeurs booléennes)
- les ombrages de variables sont interdites, toutes les variables dans une portée ne peuvent avoir le nom d'une variable déjà déclarée dans une portée parente
- variables globales non constante interdites


Néologismes
-----------
- faiture   : feature
- entredit  : interdit
- enligner  : inline
- compileur : compilateur


Anglicisme
----------
- fuzzing/fuzzées
- constant folding
- stack canaries
- multi-threading (moulthreadage)
