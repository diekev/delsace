Faitures
--------
- utilisation de caractères unicodes UTF-8 dans les sources
- impression dans la sortie standard via printf
- contrôle de flux via si/sinon
- boucle avec plage
- boucle sans plage
- déclaration et manipulation de variable
- déclaration de structure
- déclaration et appel de fonctions
- nommage explicit des paramètres des fonctions f(a=0);
- règle de définition unique : deux structures ou deux fonctions ou deux variables ne peuvent avoir le même nom
- inférence de type
- concaténation des chaînes littérales connues lors de la compilation via l'opérateur '+'
- constant folding
- manipulation de structure
- manipulation de tableaux
- transtypage entre types simples
- déclaration de fonctions externes pour lier des fichiers objets
- déclaration de fonctions variadiques externes
- fonctions variadiques sur un type donnée
- utilisation des fonctions de la bibliothèque standard de C
- utilisation de modules pour séparer le code en composant
- manipulation de pointeurs vers fonction
- initialisation de tableaux dans la déclaration
- initialisation de structures dans la déclaration
- nommage et typage explicite des énums pour éviter les problèmes de transtypage ou autre
- déréférencement de pointeur (via 'mémoire')
- initialisation explicite des membres des structures lors de leur définition
- type chaîne caractère par défaut
- modules
- introspection
- mot clé pour déférer l'exécution d'un bloc lors du retour d'une fonction
- type 'octet' pour ne pas confondre avec un 'char'
- type de tableau par défaut, le compilateur s'occupant de préserver la taille du tableau pour faire des vérifications en place
- loge/déloge/reloge pour les loyers dynamics de mémoire
- association/switch


À faire
-------
- transtypage entre types complexes
- transtypage automatique des valeurs littérales dans les expressions ou autre
---- littérale + littérale -> littérale  # OK
---- type + littérale      -> type       # À FAIRE (OK pour Z32, R64)
---- littérale + type      -> type       # À FAIRE (OK pour Z32, R64)
---- caractere + entier    -> caractère  # À FAIRE
---- entier + caractere    -> caractère  # À FAIRE
---- chaîne + caractere    -> chaîne     # À FAIRE
---- caractere + chaîne    -> chaîne     # À FAIRE
- fonctions gabarit/génériques avec contrats/concepts
- structures gabarit/génériques
- type nombre réel sur 16-bit
- types spéciaux pour chaînes de caractères et caractère simple
- stack canaries
- modules
---- préfixe les structures et les énumérations du nom du module
---- stocke les données des fonctions par module
---- ne charge les modules que s'il n'ont pas déjà été chargés
- réusinage du système de vérification sémantique du code notamment pour dédupliquer ce code et prendre en compte l'analyse de fonctions dans des modules externes dont nous ne pouvons savoir le type avant l'analyse sémantique
- unification du code d'accès au membre avec 'de' et '.'


À faire (tests)
---------------
- test caractère simple (assignation + modification)
- test opérateurs simple
- test mélanges types/nombres littéraux
- test @var[0]
- test chaine littérale, déclaration, assignement de pointeur et tableau
- test énumération
- test initialisation de structures lors des déclarations


Bugs (coulisse LLVM)
--------------------
- crash lors de la compilation de boucle contenant un 'arrête' après des blocs si/sinon
- passer un tableau à un paramètre de type pointeur ne semble pas prendre l'ardresse du tableau (@tableau[0])
- addition de pointeur ne retourne pas forcément de pointeur ? (Les opérateurs doivent être mieux gérer)


Idées
-----
- opérateur 'chaîne' pour retourner une chaîne de caractère contenant ce qu'il y a entre ses parenthèses : par exemple chaîne(a) -> "a"
- mot clés pour le nom du fichier courant, la ligne, la colonne, et le temps où la ligne a été rencontré pour la première foix (__fichier__, __ligne__, __colonne__, __temps__)
- utilisation de propriétés pour appeler un code avant ou après une fonction à chaque qu'elle est appelée (comme ctor/dtor en C++)
- multiple valeurs de retour, notamment pour gérer les erreurs sans passer par des exceptions (on pourrait transformer les fonction pour avoir les valeurs retournées en paramètres pointés x = foo() -> foo(&x))
- héritage/polymorphisme par enlignage de structures dans d'autres
- surcharges des opérateurs
- déclarations de nouveaux types par alias d'un type connu (comme typedef en C/C++, mais avec typage strict) (mot-clé 'entredit', pour empêcher qu'un opérateur soit hérité)
- surcharge de fonctions
- fonction membres de structures similaire à Python avec 'self' explicit, ou appel explicit en passant l'objet en premier paramètre
- vérification automatique des limites des tableaux (peut-être interdiction de passer des pointeurs, et passage uniquement de tableaux)
- passer uniquement par référence, ou utilisation d'un mot-clé spécifique pour dire qu'un paramètre peut-être nul
- mot-clés pour des tests unitaires, avec maintenance des fonctions auxilliaires des tests par le compileur
- mot-clés pour des tests fuzzés, avec maintenance des fonctions auxilliaires des tests par le compileur
- mot-clés pour un mutli-threading par système de tâches concurrentes, avec maintenance des fonctions auxilliaires par le compileur
- transformer les messages d'erreur en tutoriaux
- valeur par défaut des arguments
- plusieurs valeurs de retour, avec nom et valeur par défaut
- contexte (modifiable par l'utilisateur) implicit passé en paramètre de toutes les fonctions internes pour pouvoir faciliter la gestion de la mémoire et d'autres données du programme
- compte de la mémoire utilisée avec rapport en fin d'exécution du programme sur ce qui a utilisé le plus de mémoire, et s'il y a fuite de mémoire


Sécurité/évitement des bugs
---------------------------
- les variables sont constantes par défaut
- les variables doivent être initialisées lors de leur déclaration
- aucune conversion n'est implicite (sauf pour les valeurs littérales)
- les contrôles de flux doivent avoir des valeurs booléennes explicit
- l'opérateur booléen d'inversion '!' ne peut prendre qu'une valeur booléenne
- les portées doivent être explicitement entourées de { } pour éviter que des expressions ne devant qu'être exécutées dans un contrôle de flux ne soient pas exécutées en dehors.
- l'opérateur d'assignemet '=' ne retourne pas de valeur pour éviter toute confusion avec '==' (peut-être à réviser puisque il n'a pas de conversion implicite vers des valeurs booléennes)
- les ombrages de variables sont interdites, toutes les variables dans une portée ne peuvent avoir le nom d'une variable déjà déclarée dans une portée parente
- variables globales non constante interdites


Néologismes
-----------
- faiture   : feature
- entredit  : interdit
- enligner  : inline
- compileur : compilateur


Anglicisme
----------
- fuzzing/fuzzées
- constant folding
- stack canaries
- multi-threading (moulthreadage)
