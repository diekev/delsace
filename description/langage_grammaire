importe std.flux

classe gabarit(T) Noeud {
	T posx = 0;
	T posy = 0;

	constructeur() = défaut;

	destructeur() = défaut;

	fonction compile()
	{
		posx = 0;
		posy = 0;
	}
}

classe vecteur2 {
    e8 x;
    e8 y;

    construction()
    {
        x = 0;
        y = 0;
    }

    construction(e8 vx, e8 vy)
    {
        x = vx;
        y = vy;
    }

    destruction()

    vecteur2 opération+()
}

# converti les méthodes en 'nom_méthode' + '_' + 'nom_classe'

soit vec = vecteur2();  # converti en soit vec = construction_vecteur2();

enum {
	OUVERT,
	FERME,
}

fonction ajoute(d32 x, d32 y) -> d32
{
	retourne x + y;
}

classe Fichier {
	fonction ouvre();

	fonction ferme();

	fonction état();
}

fonction foo(chemin)
{
	Fichier fichier(chemin);

	ouvre(fichier);

	si état(fichier) != OUVERT {
		retourne faux;
	}

	retourne vrai;

sortie:
	ferme(fichier);

échec:
	ferme(fichier);
}

fonction gabarit(E, V) trouve(E premier, E dernier, V valeur)
{
	boucle premier...dernier {
		if *premier == valeur {
			arrête;
		}
	}
	sinon {
		retourne premier;
	}

	retourne dernier;
}

iter = trouve(début(graphe), fin(graphe), noeud);

Noeud noeud;

Manière d'accès de noeud::posy
posy de noeud = posy de noeud + 5;

# Manière d'appel de Noeud::compile()
compile(noeud);

boucle ... {
	si condition {
		arrête;
	}
}
sinon {
}

fonction decoupe(chaine *s, e32 pattern) -> chaine
{
    chaine temp;

    boucle 0...longueur(s) comme c {
        if c == pattern {
            soit temp2 = temp;
            temp = "";
            retiens temp2;
        }

        temp += c;
    }
}

fonction principale()
{
    boucle decoupe("Le temps est moche", ' ') comme mot {
        imprime("%s", mot);
    }
}

fonction xyz()
{
    # ID_POUR
    # ID_CHAINE
    # ID_DANS
    # expr
    pour mot dans decoupe("", "") {
        imprime("%s", mot);
    }
    sinon {

    }

    boucle {
        arrête;
        continue;
    }
    sinon {

    }

    pour index dans 0...10 {

    }
    sinon {

    }
}

fonction lanceuse(entier32 constant compte_argument, phrase arguments[])
{
	retourne 0;
}

types :
c8  # utf-8
c16 # utf-16
c32 # utf-32

e8
e16
e32
e64

d16
d32
d64

bool

rien

déclaration variable :
soit          chaine                      egale expr ;
soit          chaine point_double    type egale expr ;
soit          chaine point_double  * type egale expr ;
soit          chaine point_double [] type egale expr ;
soit variable chaine                      egale expr ;
soit variable chaine point_double    type egale expr ;
soit variable chaine point_double  * type egale expr ;
soit variable chaine point_double [] type egale expr ;

soit          p        = 0;
soit          p :  e32 = 0;
soit          p : *e32 = nul;
soit variable p        = 0;
soit variable p :  e32 = 0;
soit variable p : *e32 = nul; # pointeur vers un entier
soit v = 0;
soit variable ptr = @v;  # pointeur variable vers un entier

soit variable mémoire_vidéo : *e8 = 0x80;

assignation variable :
chaine egale expr ;

p = 1;

appele_fonction ;
chaine(expr...);

déclaration fonction :
fonction chaine ( paramètres... )                   { ... }
fonction chaine ( paramètres... ) point_double type { ... }

déclation paramètres fonction :
chaine :   type
chaine : * type

déclaration structure :

structure chaine { déclaration variable }

structure Image {
	*type   chaine;
	[6]type chaine;

	données      : *rien;
	hauteur      : e64;
	largeur      : e64;
	composant    : e8;
	type_données : e8;
}

déclaration pointeur     : *type
déréférencement pointeur : *chaine
recherche addresse       : @chaine

déclaration référence : &type

déclaration tableau : [N]type
déréférencement tableau : chaine[n]
recherche addresse : @chaine

conversion de type :

transtype<type>(chaine);

fonction impression_chaine(où : *e8, chaine : *e8)
{
	boucle {
		si *chaine == 0 {
			arrête;
		}

		*où++ = *chaine++;
	}
}

fonction impression_entier(où : *e8, valeur : e32)
{
	soit variable temp = valeur;

	if temp < 0 {
		*où++ = '-';
		temp = -temp;
	}

	if temp > 1_000_000_000 {
		*où++ = '0' + temp / 1_000_000_000;
		temp = temp % 1_000_000_000;
	}

	if temp > 100_000_000 {
		*où++ = '0' + temp / 100_000_000;
		temp = temp % 100_000_000;
	}

	if temp > 10_000_000 {
		*où++ = '0' + temp / 10_000_000;
		temp = temp % 10_000_000;
	}

	if temp > 1_000_000 {
		*où++ = '0' + temp / 1_000_000;
		temp = temp % 1_000_000;
	}

	if temp > 100_000 {
		*où++ = '0' + temp / 100_000;
		temp = temp % 100_000;
	}

	if temp > 10_000 {
		*où++ = '0' + temp / 10_000;
		temp = temp % 10_000;
	}

	if temp > 1_000 {
		*où++ = '0' + temp / 1_000;
		temp = temp % 1_000;
	}

	if temp > 100 {
		*où++ = '0' + temp / 100;
		temp = temp % 100;
	}

	if temp > 10 {
		*où++ = '0' + temp / 10;
		temp = temp % 10;
	}

	*où++ = '0' + temp;
}

Mots-clés :
arrête
associe
boucle
classe
constant
constructeur
de
destructeur
défaut
enum
exprime
échec
faux
fonction
gabarit
imprime
importe
opérateur
si
sinon
soit
sortie
vrai

opérateurs :
...
==
!=
<=
>=
->
<
>
=
!
+
-
++
--
*
/
%
&
&&
|
||
[]
^
(
)
{
}
"
'
;
:

types :
entier8 | e8
entier16 | e16
entier32 | e32
entier64 | e64
entier8ns | e8ns
entier16ns | e16ns
entier32ns | e32ns
entier64ns | e64ns
décimal32 | d32
décimal64 | d64
phrase/chaîne
booléen

programme:
	fonction | enum | classe | importation

fonction:
	id_fonction chaine ( liste_parametre ) { expressions }

enum:
	enum { chaine [= valeur[,]] ... };

classe:
	id_classe chaine { expressions | fonction }

chaine:

liste_parametre:
	parametre [, liste_parametre]

parametre:
	id_type chaine

expressions:
	declaration | assignement | appel

declaration:
	id_type chaine = expression_d;

assignement:
	chaine = expression_d;

appel:
	chaine(liste_param);
