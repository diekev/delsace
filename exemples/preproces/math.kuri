# Ligne de license ou commentaire

#!importe "constantes.kuri"

fonction abs(valeur : e32) : e32
{
	retourne (valeur < 0) ? -valeur : valeur;
}

# floor, plancher
fonction arrondi_inf(x : T)
{
	retourne x;
}

# ceil, plafonner
fonction arrondi_sup(x : T)
{
	retourne x;
}

# ABI des fonctions gabarits : nom_fonction + _ + type de chaque param
# pour T = e8, on a min_e8e8
# pour T = d64, on a min_d64d64
fonction gabarit(type T) min(v1 : T, v2 : T) : T
{
	if (v1 < v2) {
		retourne v1;
	}

	retourne v2;
}

fonction gabarit(type T) max(v1 : T, v2 : T) : T
{
	if (v1 > v2) {
		retourne v1;
	}

	retourne v2;
}

fonction gabarit(type T) restreint(v : T, v1 : T, v2 : T) : T
{
	if (v < v1) {
		retourne v1;
	}

	if (v > v2) {
		retourne v2;
	}

	retourne v;
}

# Les nans ne sont pas égaux à eux-mêmes.
fonction est_nan(v : d64) : bool
{
	retourne (v != v);
}

fonction est_fini(v : d64) : bool
{
	retourne false;
}

fonction est_infini(v : d64) : bool
{
	retourne !est_fini(v);
}

# https://www.codeproject.com/Articles/69941/Best-Square-Root-Method-Algorithm-Function-Precisi
# http://www.netlib.org/fdlibm/e_sqrt.c
# https://stackoverflow.com/questions/3581528/how-is-the-square-root-function-implemented
fonction racine_carré(valeur : d64) : d64
{
	soit x = *transtype<*e64>(@valeur);
	soit i = (1 << 29) + (x >> 1) - (1 << 22);
	retourne *transtype<*d64>(i);
}

fonction exponientielle(valeur : d64) : d64
{
	retourne valeur;
}

fonction logarithme(valeur : d64) : d64
{
	retourne valeur;
}

fonction racine_cubique(valeur : d64) : d64
{
	retourne valeur;
}

fonction sinus(valeur : d64) : d64
{
	retourne valeur;
}

fonction cosinus(valeur : d64) : d64
{
	retourne valeur;
}

fonction sincos(valeur : d64) : d64
{
	retourne valeur;
}

fonction tangente(valeur : d64) : d64
{
	retourne valeur;
}

fonction cotangente(valeur : d64) : d64
{
	retourne valeur;
}

fonction arccos(valeur : d64) : d64
{
	retourne valeur;
}

fonction arcsin(valeur : d64) : d64
{
	retourne valeur;
}

fonction gabarit(type N) puissance(b : N, e : N) : N
{
	retourne b ** e;
}

fonction max(a : r32, b : r32) : r32
{
	si a > b {
		retourne a;
	}

	retourne b;
}

fonction min(a : r32, b : r32) : r32
{
	si a > b {
		retourne b;
	}

	retourne a;
}

fonction restreint(a : r32, min : r32, max : r32) : r32
{
	si a < min {
		retourne min;
	}

	si a > max {
		retourne max;
	}

	retourne a;
}
