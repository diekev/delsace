# Fonctions de manipulation de chaines.

# Retourne vrai si les deux chaines données sont égales.
fonc compare_chaines(ch1 : chaine, ch2 : chaine) : bool
{
    si taille de ch1 != taille de ch2 {
        retourne faux;
    }

    soit taille = taille de ch1;
	soit début : z64 = 0;

    pour i dans début...(taille - 1) {
        si ch1[i] != ch2[i] {
            retourne faux;
        }
    }

    retourne vrai;
}

# Retourne une chaine correspondant à l'enchainement de toutes les chaines
# spécifiées. La chaine retournée a été logé et doit être délogée par
# l'appelante.
fonc enchaine(chns : ...chaine) : chaine
{
    dyn taille = 0;

    pour chn dans chns {
	    taille += taille de chn;
    }

    dyn res = loge chaine(taille);
    dyn coureur = 0;
    
    pour chn dans chns {
	    pour v dans chn {
		    res[coureur] = v;
            coureur += 1;
        }
    }

    retourne res;
}

# Retourne la taille d'une chaine C, c'est à dire nul-terminé.
fonc taille_chaine_c(ch : *z8) : z64
{
    dyn index : z64 = 0;

    tantque ch[index] != '\0' {
        index += 1;
    }

    retourne index;
}

fonc construit_chaine(ptr : *z8, taille : z64) : chaine
{
    dyn ret : chaine;
	pointeur de ret = ptr;
	taille de ret = taille;
	retourne ret;
}

# Converti une chaine C, c'est à dire nul-terminé, en une chaine native.
fonc converti_chaine_c(chaine_c : *z8) : chaine
{
    retourne construit_chaine(chaine_c, taille_chaine_c(chaine_c));
}

# execute une fonction pour chaque ligne du texte d'entrée
fonc pour_chaque_ligne(texte : chaine, donnees : eini, rappel : fonc(chaine, eini)rien) : rien
{
    dyn taille_chaine : z64 = 0;
	dyn début_chaine : z64 = 0;

    pour c, i dans texte {
	    taille_chaine += 1;

        si c == '\n' {
		    dyn ligne : chaine;
			taille de ligne = taille_chaine;
			pointeur de ligne = @texte[début_chaine];

            rappel(ligne, donnees);

            début_chaine = transtype(i + 1 : z64);
			taille_chaine = 0;
		}
	}

    # La dernière ligne n'a pas de retour...
	si taille_chaine != 0 {
	    dyn ligne : chaine;
		taille de ligne = taille_chaine;
		pointeur de ligne = @texte[début_chaine];

        rappel(ligne, donnees);
	}
}

fonc est_vide(chn : chaine) : bool
{
    retourne taille de chn == 0;
}

fonc trouve_caractère(chn : chaine, carac : z8, pos : z64) : z64
{
    soit début = pos;
	soit fin   = taille de chn;

    pour i dans début ... fin - 1 {
	    si chn[i] == carac {
		    retourne i;
		}
	}

    retourne transtype(-1 : z64);
}

fonc découpe(texte : chaine, sep : z8) : chaine
{
    dyn taille_mot : z64 = 0;
	dyn début_mot : z64 = 0;
	dyn mot : chaine;

    pour c, i dans texte {
	    si c == sep {
		    pointeur de mot = @texte[début_mot];
			taille de mot = taille_mot;

            retiens mot;

            début_mot = transtype(i + 1 : z64);
			taille_mot = 0;
			continue;
		}

        taille_mot += 1;
	}

    si taille_mot != 0 {
	    pointeur de mot = @texte[début_mot];
		taille de mot = taille_mot;

        retiens mot;
	}
}
