# Bibliothèque d'introspection.
# NOTE : les accents ont été enlevé sur les noms à cause de la coulisse C.

importe "chaine"

énum id_info : z32 {
    ENTIER    = 0,
	REEL      = 1,
	BOOLEEN   = 2,
	CHAINE    = 3,
	POINTEUR  = 4,
	STRUCTURE = 5,
	FONCTION  = 6,
	TABLEAU   = 7,
	EINI      = 8,
	RIEN      = 9,
	ENUM      = 10,
}

structure InfoType {
    id : id_info;
}

structure InfoTypeEntier {
    id : id_info; # employant InfoType
	est_signe : bool;
	taille_en_octet : n32;
}

structure InfoTypeReel {
    id : id_info; # employant InfoType
	taille_en_octet : n32;
}

structure InfoTypePointeur {
    id : id_info; # employant InfoType
	type_pointe : *InfoType;
}

structure InfoTypeTableau {
    id : id_info; # employant InfoType
	type_pointe : *InfoType;
}

structure InfoTypeMembreStructure {
	nom : chaîne;
	id : *InfoType;
	decalage : z64; # décalage en octets dans la structure
	#drapeaux : n32;
}

structure InfoTypeStructure {
    id : id_info; # employant InfoType
	nom : chaîne;
	membres : []InfoTypeMembreStructure;
}

structure InfoTypeFonction {
    id : id_info; # employant InfoType
	type_retour : *InfoType;
	type_arguments : []*InfoType;
}

structure InfoTypeEnum {
    id : id_info; # employant InfoType
	nom : chaîne;
	valeurs : []z32; # À FAIRE typage selon énum
	noms : []chaîne;
}

fonction possede_membre(arg : eini, nom : chaîne) : bool
{
    soit info = info de arg;

    si id de info de arg != STRUCTURE de id_info {
        retourne faux;
    }

    soit info_arg = transtype(info : *InfoTypeStructure); 
    
    soit membres = membres de info_arg;

    pour membre dans membres {
        si compare_chaines(nom de membre, nom) {
            retourne vrai;
        }
    }

    retourne faux;
}
