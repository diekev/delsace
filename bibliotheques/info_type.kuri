# Bibliothèque d'introspection.
# NOTE : les accents ont été enlevé sur les noms à cause de la coulisse C.

importe "chaine"

énum {
	TYPE_ENTIER    = 0,
	TYPE_REEL      = 1,
	TYPE_BOOLEEN   = 2,
	TYPE_CHAINE    = 3,
	TYPE_POINTEUR  = 4,
	TYPE_STRUCTURE = 5,
	TYPE_FONCTION  = 6,
	TYPE_TABLEAU   = 7,
	TYPE_EINI      = 8,
	TYPE_RIEN      = 9,
}

structure InfoType {
	id : n32;
}

structure InfoTypeEntier {
	id : n32; # employant InfoType
	est_signe : bool;
	taille_en_octet : n32;
}

structure InfoTypeReel {
	id : n32; # employant InfoType
	taille_en_octet : n32;
}

structure InfoTypePointeur {
	id : n32; # employant InfoType
	type_pointe : *InfoType;
}

structure InfoTypeTableau {
	id : n32; # employant InfoType
	type_pointe : *InfoType;
}

structure InfoTypeMembreStructure {
	nom : chaîne;
	id : *InfoType;
	decalage : z64; # décalage en octets dans la structure
	#drapeaux : n32;
}

structure InfoTypeStructure {
	id : n32; # employant InfoType
	nom : chaîne;
	membres : []InfoTypeMembreStructure;
}

structure InfoTypeFonction {
	id : n32; # employant InfoType
	type_retour : *InfoType;
	type_arguments : []*InfoType;
}

fonction possede_membre(arg : eini, nom : chaîne) : bool
{
    soit info = info de arg;

    si id de info de arg != TYPE_STRUCTURE {
        retourne faux;
    }

    soit info_arg = transtype(info : *InfoTypeStructure); 
    
    soit membres = membres de info_arg;

    pour membre dans membres {
        si compare_chaines(nom de membre, nom) {
            retourne vrai;
        }
    }

    retourne faux;
}
