# Bibliothèque de structures de données.
# Les structures utilisent des pointeurs vers 'rien', et la taille des données
# en octet pour avoir un semblant de généricité.

importe "memoire"

#################################################################

# Une pile où les premiers éléments ajoutés sont les derniers retirés.

structure pile {
    taille_elem : z64;
    taille : z64;
    capacite : z64;
	tampon : chaine;
}

fonction cree_pile(taille_elem : z64) : *pile
{
    dyn p = loge pile;
    taille_elem de p = taille_elem;
    retourne p;
}

fonction decree_pile(dyn p : *pile) : rien
{
    taille_elem de p = 0;
    taille de p = 0;
    capacite de p = 0;
    déloge tampon de p;
    déloge p;
}

fonction empile(dyn p : *pile, d : *rien) : rien
{
    si taille de p == capacite de p {
        # À FAIRE : le logement de tableau requiers un nombre entier, et non une expression
		dyn tabl_tmp = loge chaine((taille de p + 1) * taille_elem de p);

        copie_mem(tampon de p, tabl_tmp, (taille de p) * taille_elem de p);

        déloge tampon de p;
		tampon de p = tabl_tmp;

        capacite de p += 1;
    }

    soit ptr = @pointeur[taille de p * taille_elem de p] de tampon de p;
	copie_mem_nonsur(d, ptr, taille_elem de p);

    taille de p += 1;
}

fonction est_vide(p : *pile) : bool
{
    retourne taille de p == 0;
}

fonction depile(dyn p : *pile, d : *rien) : rien
{
    si est_vide(p) {
        retourne;
    }

    si d != nul {
        soit ptr = @pointeur[(taille de p - 1) * taille_elem de p] de tampon de p;
		copie_mem_nonsur(ptr, d, taille_elem de p);
    }

    taille de p -= 1;
}

#################################################################

# Une file où les premiers éléments ajoutés sont les premiers retirés.

structure file {
    taille_elem : z64;
    taille : z64;
    capacite : z64;
	tampon : chaine;
}

fonction cree_file(taille_elem : z64) : *file
{
    dyn q = loge file;
    taille_elem de q = taille_elem;
    retourne q;
}

fonction decree_file(dyn q : *file) : rien
{
    taille_elem de q = 0;
    taille de q = 0;
    capacite de q = 0;
    déloge tampon de q;
    déloge q;
}

fonction enfile(dyn q : *file, d : *rien) : rien
{
    si taille de q == capacite de q {
        # À FAIRE : le logement de tableau requiers un nombre entier, et non une expression
		dyn tabl_tmp = loge chaine((taille de q + 1) * taille_elem de q);

        copie_mem(tampon de q, tabl_tmp, (taille de q) * taille_elem de q);

        déloge tampon de q;
        tampon de q = tabl_tmp;

        capacite de q += 1;
    }

    soit ptr = @pointeur[taille de q * taille_elem de q] de tampon de q;
	copie_mem_nonsur(d, ptr, taille_elem de q);

    taille de q += 1;
}

fonction file_est_vide(q : *file) : bool
{
    retourne taille de q == 0;
}

fonction defile(dyn q : *file, d : *rien) : rien
{
    si file_est_vide(q) {
        retourne;
    }

    si d != nul {
        soit ptr = @pointeur[0] de tampon de q;
		copie_mem_nonsur(ptr, d, taille_elem de q);
    }

    # réajuste la file en décalant les données

    si taille de q > 1 {
        soit ptr_dst = @pointeur[0] de tampon de q;
        soit ptr_src = @pointeur[taille_elem de q] de tampon de q;
        copie_mem_nonsur(ptr_src, ptr_dst, taille_elem de q * (taille de q - 1));
    }

    taille de q -= 1;
}

#################################################################

# Une tableau où les données sont stockées de manière séquentielle.

structure tableau {
    taille_elem : z64;
    taille : z64;
    capacite : z64;
	tampon : chaine;
}

fonction cree_tableau(taille_elem : z64) : *tableau
{
    dyn t = loge tableau;
    taille_elem de t = taille_elem;
    retourne t;
}

fonction decree_tableau(dyn t : *tableau) : rien
{
    taille_elem de t = 0;
    taille de t = 0;
    capacite de t = 0;
    déloge tampon de t;
    déloge t;
}

fonction pousse_tableau(dyn t : *tableau, d : *rien) : rien
{
    si taille de t == capacite de t {
        # À FAIRE : le logement de tableau requiers un nombre entier, et non une expression
		dyn tabl_tmp = loge chaine((taille de t + 1) * taille_elem de t);

        copie_mem(tampon de t, tabl_tmp, (taille de t) * taille_elem de t);

        déloge tampon de t;
		tampon de t = tabl_tmp;

        capacite de t += 1;
    }

    soit ptr = @pointeur[taille de t * taille_elem de t] de tampon de t;
	copie_mem_nonsur(d, ptr, taille_elem de t);

    taille de t += 1;
}

fonction tableau_est_vide(t : *tableau) : bool
{
    retourne taille de t == 0;
}

fonction debut_tableau(t : *tableau) : *rien
{
    si tableau_est_vide(t) {
        retourne nul;
    }

    soit ptr = @pointeur[0] de tampon de t;
    retourne transtype(ptr : *rien);
}

fonction fin_tableau(t : *tableau) : *rien
{
    si tableau_est_vide(t) {
        retourne nul;
    }

    # NOTE : contrairement à C++, nous ne retournons pas un pointeur après la fin,
    # mais la fin elle-même car les boucles utilisant des plages vont jusqu'au dernier
    # élément (<=)
    soit ptr = @pointeur[(taille de t - 1) * taille_elem de t] de tampon de t;
    retourne transtype(ptr : *rien);
}
