# Bibliothèque de structures de données.
# Les structures utilisent des pointeurs vers 'rien', et la taille des données
# en octet pour avoir un semblant de généricité.

importe "memoire"

#################################################################

# Une pile où les premiers éléments ajoutés sont les derniers retirés.

structure pile {
    taille_elem : z64;
    taille : z64;
	capacité : z64;
	tampon : chaine;
}

fonc crée_pile(taille_elem : z64) : *pile
{
    dyn p = loge pile;
    taille_elem de p = taille_elem;
    retourne p;
}

fonc decrée_pile(dyn p : *pile) : rien
{
    taille_elem de p = 0;
    taille de p = 0;
	capacité de p = 0;
    déloge tampon de p;
    déloge p;
}

fonc empile(dyn p : *pile, d : *rien) : rien
{
    si taille de p == capacité de p {
        # À FAIRE : le logement de tableau requiers un nombre entier, et non une expression
		reloge tampon de p : chaine((taille de p + 1) * taille_elem de p);
		capacité de p += 1;
    }

    soit ptr = @tampon[taille de p * taille_elem de p] de p;
	copie_mem_nonsur(d, ptr, taille_elem de p);

    taille de p += 1;
}

fonc est_vide(p : *pile) : bool
{
    retourne taille de p == 0;
}

fonc dépile(dyn p : *pile, d : *rien) : rien
{
    si est_vide(p) {
        retourne;
    }

    si d != nul {
	    soit ptr = @tampon[(taille de p - 1) * taille_elem de p] de p;
		copie_mem_nonsur(ptr, d, taille_elem de p);
    }

    taille de p -= 1;
}

#################################################################

# Une file où les premiers éléments ajoutés sont les premiers retirés.

structure file {
    taille_elem : z64;
    taille : z64;
	capacité : z64;
	tampon : chaine;
}

fonc crée_file(taille_elem : z64) : *file
{
    dyn q = loge file;
    taille_elem de q = taille_elem;
    retourne q;
}

fonc decrée_file(dyn q : *file) : rien
{
    taille_elem de q = 0;
    taille de q = 0;
	capacité de q = 0;
    déloge tampon de q;
    déloge q;
}

fonc enfile(dyn q : *file, d : *rien) : rien
{
    si taille de q == capacité de q {
        # À FAIRE : le logement de tableau requiers un nombre entier, et non une expression
		reloge tampon de q : chaine((taille de q + 1) * taille_elem de q);
		capacité de q += 1;
    }

    soit ptr = @tampon[taille de q * taille_elem de q] de q;
	copie_mem_nonsur(d, ptr, taille_elem de q);

    taille de q += 1;
}

fonc est_vide(q : *file) : bool
{
    retourne taille de q == 0;
}

fonc défile(dyn q : *file, d : *rien) : rien
{
    si est_vide(q) {
        retourne;
    }

    si d != nul {
	    soit ptr = @tampon[0] de q;
		copie_mem_nonsur(ptr, d, taille_elem de q);
    }

    # réajuste la file en décalant les données

    si taille de q > 1 {
	    soit ptr_dst = @tampon[0] de q;
		soit ptr_src = @tampon[taille_elem de q] de q;
        copie_mem_nonsur(ptr_src, ptr_dst, taille_elem de q * (taille de q - 1));
    }

    taille de q -= 1;
}

#################################################################

# Une tableau où les données sont stockées de manière séquentielle.

structure tableau {
    taille_elem : z64;
    taille : z64;
	capacité : z64;
	tampon : chaine;
}

fonc crée_tableau(taille_elem : z64) : *tableau
{
    dyn t = loge tableau;
    taille_elem de t = taille_elem;
    retourne t;
}

fonc decrée_tableau(dyn t : *tableau) : rien
{
    taille_elem de t = 0;
    taille de t = 0;
	capacité de t = 0;
    déloge tampon de t;
    déloge t;
}

fonc pousse_tableau(dyn t : *tableau, d : *rien) : rien
{
    si taille de t == capacité de t {
        # À FAIRE : le logement de tableau requiers un nombre entier, et non une expression
		reloge tampon de t : chaine((taille de t + 1) * taille_elem de t);
		capacité de t += 1;
    }

    soit ptr = @tampon[taille de t * taille_elem de t] de t;
	copie_mem_nonsur(d, ptr, taille_elem de t);

    taille de t += 1;
}

fonc est_vide(t : *tableau) : bool
{
    retourne taille de t == 0;
}

fonc début_tableau(t : *tableau) : *rien
{
    si est_vide(t) {
        retourne nul;
    }

    soit ptr = @tampon[0] de t;
    retourne transtype(ptr : *rien);
}

fonc fin_tableau(t : *tableau) : *rien
{
    si est_vide(t) {
        retourne nul;
    }

    # NOTE : contrairement à C++, nous ne retournons pas un pointeur après la fin,
    # mais la fin elle-même car les boucles utilisant des plages vont jusqu'au dernier
    # élément (<=)
	soit ptr = @tampon[(taille de t - 1) * taille_elem de t] de t;
    retourne transtype(ptr : *rien);
}
