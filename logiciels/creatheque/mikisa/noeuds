#######
TRADUIT
num
vieux_min
vieux_max
nouveau_min
nouveau_max

retourne un nombre entre nouveau_min et nouveau_max qui est relatif à num dans la plage entre vieux_min et vieux_max.
si la valeur est hors de vieux_min et vieux_max il sera restreint à la nouvelle plage

if (vieux_min > vieux_max)
    tmp = vieux_min - restreint(num, vieux_max, vieux_min)
else
    tmp = restreint(num, vieux_min, vieux_max)

tmp = (tmp - vieux_min) / (vieux_max - vieux_min)
retourne nouveau_min + tmp*(nouveau_max - nouveau_min)

#########
TRADUIT01:
num
nouveau_min
nouveau_max

retourne un nombre entre nouveau_min et nouveau_max qui est relatif à num dans la plage entre 0 et 1.
si la valeur est hors de 0 et 1 il sera restreint à la nouvelle plage

tmp = restreint(num, 0.0, 1.0)
retourne nouveau_min + tmp * (nouveau_max - nouveau_min)

TRADUIT(num, 0.0, 1.0, nouveau_min, nouveau_max)

#########
TRADUIT11:
num
nouveau_min
nouveau_max

retourne un nombre entre nouveau_min et nouveau_max qui est relatif à num dans la plage entre -1 et 1.
si la valeur est hors de -1 et 1 il sera restreint à la nouvelle plage

tmp = restreint(num, -1.0, 1.0)
tmp = (tmp - (-1.0)) / (1.0 - (-1.0))
retourne nouveau_min + tmp * (nouveau_max - nouveau_min)

TRADUIT(num, -1.0, 1.0, nouveau_min, nouveau_max)

#########
TRADUIT10:
num
nouveau_min
nouveau_max

retourne un nombre entre nouveau_min et nouveau_max qui est relatif à num dans la plage entre 1 et 0.
si la valeur est hors de 1 et 0 il sera restreint à la nouvelle plage

tmp = restreint(num, 0.0, 1.0)
tmp = (tmp - 1.0) / (0.0 - 1.0)
retourne nouveau_min + tmp * (nouveau_max - nouveau_min)

TRADUIT(num, 1.0, 0.0, nouveau_min, nouveau_max)

#######
DÉGRADÉ

selon les coordonnées x, y et l'angle de rotation, qu'elle est la position relative [0, 1) dans le dégradé

angle 0, direction G->D

position :  cos(t) * x + sin(t) * y, t = 0

angle 90, direction B->H

position : cos(t) * x + sin(t) * y, t = 0

angle 180, direction D->G

position : 1.0 - x

angle 270, direction H->B

position : 1.0 - y
