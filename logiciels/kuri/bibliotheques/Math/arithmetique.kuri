// À FAIRE : implémente les fonctions suivantes avec notre langage

#inclus "math.h"
#bib "m"

sqrt :: fonc externe (v: r64) -> r64
cos :: fonc externe (a : r64) -> r64
sin :: fonc externe (a : r64) -> r64
tan :: fonc externe (a : r64) -> r64
acos :: fonc externe (a : r64) -> r64
asin :: fonc externe (a : r64) -> r64
atan :: fonc externe (a : r64) -> r64
atan2 :: fonc externe (a : r64, b: r64) -> r64

// À FAIRE : certaines fonctions ne de sens que pour les nombres relatifs ou réels

#enligne abs :: fonc(a : $T) -> $T
{
	retourne si a < 0 { -a } sinon { a }
}

#enligne min :: fonc(a : $T, b : $T) -> $T
{
	retourne si a < b { a } sinon { b }
}

min :: fonc(args : ...$T) -> $T
{
	dyn vmin := args[0]

	pour v, index dans 1 ... args.taille - 1 {
		vmin = min(vmin, v)
	}

	retourne vmin
}

#enligne max :: fonc(a : $T, b : $T) -> $T
{
	retourne si a > b { a } sinon { b }
}

max :: fonc(args : ...$T) -> $T
{
	dyn vmax := args[0]

	pour v, index dans 1 ... args.taille - 1 {
		vmax = max(vmin, v)
	}

	retourne vmax
}

#enligne restreint :: fonc(dyn x : *$T, min : $T, max : $T) -> rien
{
    si mémoire(x) <= min {
        mémoire(x) = min;
    }
    si mémoire(x) >= max {
        mémoire(x) = max;
    }
}

// Trouve le plus grand commun diviseur selon l'algorithme d'Euclide
pgcd :: fonc(a : z32, b : z32) -> z32
{
	dyn x := a
	dyn y := b

	tantque y > 1 {
		x = y
		y = x % y
	}

	retourne x
}

// Trouve le plus petit commun multiple
ppmc :: fonc(a : z32, b : z32) -> z32
{
	si a == 0 || b == 0 {
		retourne 0
	}

	retourne abs(a * b) / pgcd(a, b)
}
