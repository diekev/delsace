charge "vecteur"

Mat4r :: struct {
    m : [4][4]r32
}

construit_mat4r :: fonc () -> Mat4r
{
    dyn mat : Mat4r

    pour i dans 0 ... 3 {
        pour j dans 0 ... 3 {
            mat.m[i][j] = 0.0
        }
    }

    retourne mat
}

construit_identité_mat4r :: fonc () -> Mat4r
{
    dyn mat := construit_mat4r()

    pour i dans 0 ... 3 {
        mat.m[i][i] = 1.0
    }

    retourne mat
}

matrice_projection :: fonc (
    champs_de_vue : r32,
    largeur: r32,
    hauteur: r32,
    plan_proche: r32,
    plan_éloigné: r32) -> Mat4r
{
    ratio_aspect := hauteur / largeur
    champs_de_vue_rad := 1.0 / transtype(tan(champs_de_vue * 0.5 / 180.0 * 3.14159): r32)

    dyn mat := construit_mat4r()

    mat.m[0][0] = ratio_aspect * champs_de_vue_rad
    mat.m[1][1] = champs_de_vue_rad
    mat.m[2][2] = plan_éloigné / (plan_éloigné - plan_proche)
    mat.m[3][2] = (-plan_éloigné * plan_proche) / (plan_éloigné - plan_proche)
    mat.m[2][3] = 1.0
    mat.m[3][3] = 0.0

    retourne mat
}

// retourne l'inverse d'une matrice qui n'a pas d'échelle
// utile pour les matrices de projection
inverse_matrice_sans_échelle :: fonc (mat: *Mat4r) -> Mat4r
{
    dyn résultat := construit_identité_mat4r()

    pour i dans 0 ... 2 {
        pour j dans 0 ... 2 {
            résultat.m[i][j] = mat.m[j][i]
        }
    }

    résultat.m[3][0] = -mat.m[3][0]
    résultat.m[3][1] = -mat.m[3][1]
    résultat.m[3][2] = -mat.m[3][2]

    retourne résultat
}

matrice_de_visé :: fonc (pos: *Vec3r, cible: *Vec3r, haut: *Vec3r) -> Mat4r
{
    dyn dir_avant := soustrait(mémoire(cible), mémoire(pos))
    dir_avant = normalise(@dir_avant)

    a := multiplie(dir_avant, produit_scalaire(mémoire(haut), dir_avant))
    dyn dir_haut := soustrait(mémoire(haut), a)
    dir_haut = normalise(@dir_haut)

    dir_droite := produit_vectoriel(@dir_haut, @dir_avant)

    dyn résultat : Mat4r

    résultat.m[0][0] = dir_droite.x
    résultat.m[0][1] = dir_droite.y
    résultat.m[0][2] = dir_droite.z
    résultat.m[0][3] = 0.0

    résultat.m[1][0] = dir_haut.x
    résultat.m[1][1] = dir_haut.y
    résultat.m[1][2] = dir_haut.z
    résultat.m[1][3] = 0.0

    résultat.m[2][0] = dir_avant.x
    résultat.m[2][1] = dir_avant.y
    résultat.m[2][2] = dir_avant.z
    résultat.m[2][3] = 0.0

    résultat.m[3][0] = pos.x
    résultat.m[3][1] = pos.y
    résultat.m[3][2] = pos.z
    résultat.m[3][3] = 1.0

    retourne résultat
}

matrice_rotation_x :: fonc (theta: r32) -> Mat4r
{
    dyn résultat := construit_mat4r()

    résultat.m[0][0] = 1.0
    résultat.m[1][1] = transtype(cos(theta): r32)
    résultat.m[1][2] = transtype(sin(theta): r32)
    résultat.m[2][1] = transtype(-sin(theta): r32)
    résultat.m[2][2] = transtype(cos(theta): r32)
    résultat.m[3][3] = 1.0

    retourne résultat
}

matrice_rotation_y :: fonc (theta: r32) -> Mat4r
{
    dyn résultat := construit_mat4r()

    résultat.m[0][0] = transtype(cos(theta): r32)
    résultat.m[0][2] = transtype(sin(theta): r32)
    résultat.m[2][0] = transtype(-sin(theta): r32)
    résultat.m[1][1] = 1.0
    résultat.m[2][2] = transtype(cos(theta): r32)
    résultat.m[3][3] = 1.0

    retourne résultat
}

matrice_rotation_z :: fonc (theta: r32) -> Mat4r
{
    dyn résultat := construit_mat4r()

    résultat.m[0][0] = transtype(cos(theta): r32)
    résultat.m[0][1] = transtype(sin(theta): r32)
    résultat.m[1][0] = transtype(-sin(theta): r32)
    résultat.m[1][1] = transtype(cos(theta): r32)
    résultat.m[2][2] = 1.0
    résultat.m[3][3] = 1.0

    retourne résultat
}

matrice_translation :: fonc (x := 0.0, y := 0.0, z := 0.0) -> Mat4r
{
    dyn résultat := construit_identité_mat4r()

    résultat.m[3][0] = x
    résultat.m[3][1] = y
    résultat.m[3][2] = z

    retourne résultat
}

matrice_translation :: fonc (v : Vec3r) -> Mat4r
{
    retourne matrice_translation(v.x, v.y, v.z)
}

matrice_échelle :: fonc (x := 0.0, y := 0.0, z := 0.0) -> Mat4r
{
    dyn résultat := construit_identité_mat4r()

    résultat.m[0][0] = x
    résultat.m[1][1] = y
    résultat.m[2][2] = z

    retourne résultat
}

matrice_échelle :: fonc (v : Vec3r) -> Mat4r
{
    retourne matrice_échelle(v.x, v.y, v.z)
}

multiplie :: fonc (m1: Mat4r, m2: Mat4r) -> Mat4r
{
    dyn résultat : Mat4r

    pour i dans 0 ... 3 {
        pour j dans 0 ... 3 {
            dyn valeur := 0.0

            pour k dans 0 ... 3 {
                valeur += m1.m[i][k] * m2.m[k][j]
            }

            résultat.m[i][j] = valeur
        }
    }

    retourne résultat
}

transforme :: fonc (mat: Mat4r, vec: Vec3r) -> Vec3r
{
    dyn rés : Vec3r

    rés.x = vec.x * mat.m[0][0] + vec.y * mat.m[1][0] + vec.z * mat.m[2][0] + mat.m[3][0]
    rés.y = vec.x * mat.m[0][1] + vec.y * mat.m[1][1] + vec.z * mat.m[2][1] + mat.m[3][1]
    rés.z = vec.x * mat.m[0][2] + vec.y * mat.m[1][2] + vec.z * mat.m[2][2] + mat.m[3][2]

    w := vec.x * mat.m[0][3] + vec.y * mat.m[1][3] + vec.z * mat.m[2][3] + mat.m[3][3]

    si w != 0.0 {
        rés.x /= w
        rés.y /= w
        rés.z /= w
    }

    retourne rés
}
