# Bibliothèque de manipulation de la mémoire contenue dans des tampon
# Ces fonctions sont leurs pendantes de celles de la bibliothèque standard de C
# (memcmp, memcpy, memmove, memchr), à la différence que nous utilisons des
# tableaux d'octets pour s'assurer que nous ne dépassons jamais les limites des
# blocs de mémoires à manipuler.

#!nulctx fonc comp_mem_ordre(a : []octet, b : []octet, taille : z64) -> z32
{
    si a.taille < taille {
		retourne -1
	}

    si b.taille < taille {
		retourne 1
	}

    pour i dans transtype(0 : z64)...taille - 1 {
		v := a[i] - b[i]

        si v != transtype(0: octet) {
			retourne transtype(v : z32)
		}
	}

	retourne 0
}

#!nulctx fonc comp_mem(a : []octet, b : []octet, taille : z64) -> bool
{
    si a.taille < taille {
		retourne faux
	}

    si b.taille < taille {
		retourne faux
	}

    si a.taille != b.taille {
		retourne faux
	}

    pour i dans transtype(0 : z64)...taille - 1 {
	    si a[i] != b[i] {
			retourne faux
		}
	}

	retourne vrai
}

#!nulctx fonc copie_mem_nonsur(src : *octet, dyn dst : *octet, taille : z64) -> rien
{
    pour i dans transtype(0 : z64)...taille - 1 {
		dst[i] = src[i]
	}
}

# Copie 'taille' octets depuis la source vers la destination
# La copie se fait comme si un tampon intermédiaire a été utilisé,
# permettant à la source et à la destination de se surposer.
#!nulctx fonc copie_mem(src : []octet, dyn dst : []octet, taille : z64) -> rien
{
    si src.taille < taille {
		retourne
	}

    si dst.taille < taille {
		retourne
	}

    # vérifie si surposition

	ptr_deb_src := @src[0]
	ptr_fin_src := @src[src.taille - 1]
	ptr_deb_dst := @dst[0]

    # src |---------------|
	# dst       |---------------|
	# Copie à partir de la fin.
	si ptr_deb_src <= ptr_deb_dst <= ptr_fin_src {
	    pour i dans transtype(0 : z64)...taille - 1 {
			idx := taille - i - 1
			dst[idx] = src[idx]
		}
	}
	sinon {
	    pour i dans transtype(0 : z64)...taille - 1 {
			dst[i] = src[i]
		}
	}
}

# Similaire à copie_mem. La bibliothèque C possède memcpy et memmove, la
# différence étant que memcpy ne peut recevoir de blocs se surposant, alors que
# memmove peut  mais aucune vérification n'est faite dans memcpy, menant à des
# vulnérabilités ! Nous faisons une vérification dans notre version 'copie_mem'.
# Cette fonction est plus ici pour avoir une symétrie avec la bibliothèque C
# qu'autre chose.
#!nulctx fonc bouge_mem(source : []octet, dyn destination : []octet, taille : z64) -> rien
{
	copie_mem(source, destination, taille)
}

# À FAIRE : considération pour la surposition de blocs.
#!nulctx fonc echange_mem(a : []octet, b : []octet) -> rien
{
	dyn tmp : [128]octet

	dyn taille := a.taille

    si a.taille > b.taille {
	   taille = b.taille
	}

	dyn debut := 0

    tantque debut < taille {
		dyn source := @a[debut]
		dyn destination := @tmp[0]

		dyn taille_tmp := taille - debut

        si taille_tmp > 128 {
		    taille_tmp = 128
		}

		copie_mem_nonsur(src=source, dst=destination, taille=taille_tmp)

		source = @b[debut]
		destination = @a[debut]

		copie_mem_nonsur(src=source, dst=destination, taille=taille_tmp)

		source = @tmp[0]
		destination = @b[debut]

		copie_mem_nonsur(src=source, dst=destination, taille=taille_tmp)

		debut += 128
	}
}

#!nulctx fonc init_mem(dyn destination : []octet, valeur : z8, taille : z64) -> rien
{
	dyn t := taille
	si destination.taille < taille {
		t = destination.taille
	}

    pour o, idx dans destination {
		# À FAIRE: référence...
		destination[idx] = transtype(valeur : octet)
	}
}

#!nulctx fonc cherche_mem(source : []octet, valeur : z8, taille : z64) -> []octet
{
	dyn t := taille
	si source.taille < taille {
		t = source.taille
	}

	dyn ret : []octet
	ret.pointeur = nul
	ret.taille = 0

    pour i dans transtype(0 : z64)...t - 1 {
	    si source[i] == transtype(valeur : octet) {
			ret.pointeur = @source[i]
			ret.taille = t - i
			arrête
		}
	}

	retourne ret
}
