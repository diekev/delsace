# Bibliothèque de manipulation de la mémoire contenue dans des tampon
# Ces fonctions sont leurs pendantes de celles de la bibliothèque standard de C
# (memcmp, memcpy, memmove, memchr), à la différence que nous utilisons des
# tableaux d'octets pour s'assurer que nous ne dépassons jamais les limites des
# blocs de mémoires à manipuler.

#!nulctx fonc comp_mem_ordre(a : []octet, b : []octet, taille : z64) : z32
{
    si taille de a < taille {
		retourne -1
	}

    si taille de b < taille {
		retourne 1
	}

    pour i dans transtype(0 : z64)...taille - 1 {
		soit v = a[i] - b[i]

        si v != 0 {
			retourne transtype(v : z32)
		}
	}

	retourne 0
}

#!nulctx fonc comp_mem(a : []octet, b : []octet, taille : z64) : bool
{
    si taille de a < taille {
		retourne faux
	}

    si taille de b < taille {
		retourne faux
	}

    si taille de a != taille de b {
		retourne faux
	}

    pour i dans transtype(0 : z64)...taille - 1 {
	    si a[i] != b[i] {
			retourne faux
		}
	}

	retourne vrai
}

#!nulctx fonc copie_mem_nonsur(src : *octet, dyn dst : *octet, taille : z64) : rien
{
    pour i dans transtype(0 : z64)...taille - 1 {
		dst[i] = src[i]
	}
}

# Copie 'taille' octets depuis la source vers la destination
# La copie se fait comme si un tampon intermédiaire a été utilisé,
# permettant à la source et à la destination de se surposer.
#!nulctx fonc copie_mem(src : []octet, dyn dst : []octet, taille : z64) : rien
{
    si taille de src < taille {
		retourne
	}

    si taille de dst < taille {
		retourne
	}

    # vérifie si surposition

	ptr_deb_src = @src[0]
	ptr_fin_src = @src[taille de src - 1]
	ptr_deb_dst = @dst[0]

    # src |---------------|
	# dst       |---------------|
	# Copie à partir de la fin.
	si ptr_deb_src <= ptr_deb_dst <= ptr_fin_src {
	    pour i dans transtype(0 : z64)...taille - 1 {
			idx = taille - i - 1
			dst[idx] = src[idx]
		}
	}
	sinon {
	    pour i dans transtype(0 : z64)...taille - 1 {
			dst[i] = src[i]
		}
	}
}

# Similaire à copie_mem. La bibliothèque C possède memcpy et memmove, la
# différence étant que memcpy ne peut recevoir de blocs se surposant, alors que
# memmove peut  mais aucune vérification n'est faite dans memcpy, menant à des
# vulnérabilités ! Nous faisons une vérification dans notre version 'copie_mem'.
# Cette fonction est plus ici pour avoir une symétrie avec la bibliothèque C
# qu'autre chose.
#!nulctx fonc bouge_mem(source : []octet, dyn destination : []octet, taille : z64) : rien
{
	copie_mem(source, destination, taille)
}

# À FAIRE : considération pour la surposition de blocs.
#!nulctx fonc echange_mem(a : []octet, b : []octet) : rien
{
	dyn tmp : [128]octet

	dyn taille = taille de a

    si taille de a > taille de b {
	   taille = taille de b
	}

	dyn debut = 0

    tantque debut < taille {
		dyn source = @a[debut]
		dyn destination = @tmp[0]

		dyn taille_tmp = transtype(taille - debut : z64)

        si taille_tmp > 128 {
		    taille_tmp = 128
		}

		copie_mem_nonsur(src=source, dst=destination, taille=taille_tmp)

		source = @b[debut]
		destination = @a[debut]

		copie_mem_nonsur(src=source, dst=destination, taille=taille_tmp)

		source = @tmp[0]
		destination = @b[debut]

		copie_mem_nonsur(src=source, dst=destination, taille=taille_tmp)

		debut += 128
	}
}

#!nulctx fonc init_mem(dyn destination : []octet, valeur : z8, taille : z64) : rien
{
	dyn t = taille
	si taille de destination < taille {
		t = transtype(taille de destination : z64)
	}

    pour o dans destination {
		o = transtype(valeur : octet)
	}
}

#!nulctx fonc cherche_mem(source : []octet, valeur : z8, taille : z64) : []octet
{
	dyn t = taille
	si taille de source < taille {
		t = transtype(taille de source : z64)
	}

	dyn ret : []octet
	pointeur de ret = nul
	taille de ret = 0

    pour i dans transtype(0 : z64)...t - 1 {
	    si source[i] == valeur {
			pointeur de ret = @source[i]
			taille de ret = transtype(t - i : n64)
			arrête
		}
	}

	retourne ret
}
