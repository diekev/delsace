# Bibliothèque d'introspection.

charge "chaine"

énum id_info : z32 {
    ENTIER    = 0,
	RÉEL      = 1,
	BOOLÉEN   = 2,
	CHAINE    = 3,
	POINTEUR  = 4,
	STRUCTURE = 5,
	FONCTION  = 6,
	TABLEAU   = 7,
	EINI      = 8,
	RIEN      = 9,
	ÉNUM      = 10,
}

struct InfoType {
	id : id_info
}

struct InfoTypeEntier {
	id : id_info # employant InfoType
	est_signé : bool
	taille_en_octet : n32
}

struct InfoTypeRéel {
	id : id_info # employant InfoType
	taille_en_octet : n32
}

struct InfoTypePointeur {
	id : id_info # employant InfoType
	type_pointé : *InfoType
	est_référence : bool
}

struct InfoTypeTableau {
	id : id_info # employant InfoType
	type_pointé : *InfoType
}

struct InfoTypeMembreStructure {
	nom : chaine
	id : *InfoType
	décalage : z64 # décalage en octets dans la structure
	#drapeaux : n32
}

struct InfoTypeStructure {
	id : id_info # employant InfoType
	nom : chaine
	membres : []InfoTypeMembreStructure
}

struct InfoTypeFonction {
	id : id_info # employant InfoType
	types_entrée : []*InfoType
	types_sortie : []*InfoType
	est_coroutine : bool
}

struct InfoTypeÉnum {
	id : id_info # employant InfoType
	nom : chaine
	valeurs : []z32 # À FAIRE typage selon énum
	noms : []chaine
}

fonc possède_membre(arg : eini, nom : chaine) : bool
{
	info = info de arg

    si id de info != STRUCTURE de id_info {
		retourne faux
	}

	soit info_arg = transtype(info : *InfoTypeStructure)

	soit membres = membres de info_arg

    pour membre dans membres {
        si compare_chaines(nom de membre, nom) {
			retourne vrai
        }
    }

	retourne faux
}

corout membres(arg : eini) : chaine
{
	info = info de arg

    si id de info != STRUCTURE de id_info {
		retourne
	}

	info_arg = transtype(info : *InfoTypeStructure)

	membres = membres de info_arg

    pour membre dans membres {
		retiens nom de membre
	}
}
