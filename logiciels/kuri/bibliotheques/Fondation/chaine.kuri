// Fonctions de manipulation de chaines.

charge "memoire"

// À FAIRE: ceci ne fonctionnera pas pour les chaines statiques, connues lors de la compilation
pousse :: fonc (dyn chn: *chaine, c: z8) -> rien
{
	dyn tmp := mémoire(chn)

	taille := chn.taille
	reloge tmp: chaine(taille + 1)
	tmp[taille] = c

	mémoire(chn) = tmp
}

inverse :: fonc (dyn chn: *chaine) -> rien
{
    dyn chn_tmp := mémoire(chn)

	taille := chn.taille / 2

	pour i dans transtype(0: z64) ... taille - 1 {
		tmp := chn_tmp[i]
		chn_tmp[i] = chn_tmp[chn.taille - i - 1]
		chn_tmp[chn.taille - i - 1] = tmp
	}

    mémoire(chn) = chn_tmp
}

copie_chaine :: fonc (chn: chaine) -> chaine
{
	dyn nchn := loge chaine(chn.taille)
	copie_mem_nonsur(src = chn.pointeur, dst = nchn.pointeur, taille = chn.taille)
	retourne nchn
}

// Retourne la taille d'une chaine C, c'est à dire nul-terminé.
#nulctx taille_chaine_c :: fonc(ch : *z8) -> z64
{
	dyn index : z64 := 0

    tantque ch[index] != '\0' {
		index += 1
    }

	retourne index
}

#nulctx construit_chaine :: fonc(ptr : *z8, taille : z64) -> chaine
{
	dyn ret : chaine
	ret.pointeur = ptr
	ret.taille = taille
	retourne ret
}

// Converti une chaine C, c'est à dire nul-terminé, en une chaine native.
#nulctx converti_chaine_c :: fonc(chaine_c : *z8) -> chaine
{
	retourne construit_chaine(chaine_c, taille_chaine_c(chaine_c))
}

// Copie le contenue de la chn native dans un tampon afin de pouvoir la terminer
// par un '\0' et l'utiliser dans les fonctions C. Le tampon est alloué dans le
// stockage temporaire, et n'a pas besoin d'être déloger manuellement.
chaine_c_temp :: fonc(chn: chaine) -> *z8
{
    dyn tampon := logement_temp(chn.taille + 1)
    copie_mem_nonsur(src = chn.pointeur, dst = tampon, taille = chn.taille)
    tampon[chn.taille] = transtype('\0': octet)

    retourne transtype(tampon: *z8)
}

// execute une fonction pour chaque ligne du texte d'entrée
pour_chaque_ligne :: fonc(texte : chaine, donnees : eini, rappel : fonc(chaine, eini)rien) -> rien
{
	dyn taille_chaine : z64 = 0
	dyn début_chaine : z64 = 0

    pour c, i dans texte {
		taille_chaine += 1

        si c == '\n' {
			ligne := construit_chaine(@texte[début_chaine], taille_chaine)
			rappel(ligne, donnees)

			début_chaine = transtype(i + 1 : z64)
			taille_chaine = 0
		}
	}

    // La dernière ligne n'a pas de retour...
	si taille_chaine != 0 {
		ligne := construit_chaine(@texte[début_chaine], taille_chaine)
		rappel(ligne, donnees)
	}
}

est_vide :: fonc(chn : chaine) -> bool
{
	retourne chn.taille == 0
}

trouve_caractère :: fonc(chn : chaine, carac : z8, pos : z64) -> z64
{
	début := pos
	fin   := chn.taille

    pour i dans début ... fin - 1 {
	    si chn[i] == carac {
			retourne i
		}
	}

	retourne transtype(-1 : z64)
}

découpe :: corout(texte : chaine, sep : z8) -> chaine
{
	dyn taille_mot : z64 = 0
	dyn début_mot : z64 = 0
	dyn mot : chaine

    pour c, i dans texte {
	    si c == sep {
			retiens construit_chaine(@texte[début_mot], taille_mot)

			début_mot = transtype(i + 1 : z64)
			taille_mot = 0
			continue
		}

		taille_mot += 1
	}

    si taille_mot != 0 {
		retiens construit_chaine(@texte[début_mot], taille_mot)
	}
}

// Converti une chaine, par exemple "5005", en un nombre entier
// La fonction présume que la chaine est entièrement composée de caractères numériques
extrait_nombre_entier :: fonc(chn : chaine) -> z64
{
    dyn résultat : z64 := 0

	pour c dans chn {
        résultat = résultat * 10 + transtype(c - '0' : z64)
    }

	retourne résultat
}

// Converti une chaine, par exemple "500.5", en un nombre réel
// La fonction présume que la chaine est entièrement composée de caractères numériques et d'un point
extrait_nombre_réel :: fonc(chn : chaine) -> r64
{
    dyn résultat : r64 = 0.0
	dyn mult : r64 = 1.0
	dyn point_trouvé := faux

	pour c dans chn {
		si c == '.' {
			point_trouvé = vrai
			continue
		}

		si point_trouvé {
			mult *= 0.1
        	résultat += transtype(c - '0' : r64) * mult
		}
		sinon {
        	résultat = résultat * 10.0 + transtype(c - '0' : r64)
		}
    }

	retourne résultat
}

est_espace_blanc :: fonc(c : z8) -> bool
{
    retourne c == ' ' || c == '\n' || c == '\t' || c == '\v' || c == '\r' || c == '\f'
}

est_nombre_binaire :: fonc(c : z8) -> bool
{
    retourne c == '0' || c == '1'
}

est_nombre_décimal :: fonc(c : z8) -> bool
{
    retourne '0' <= c <= '9'
}

est_nombre_octal :: fonc(c : z8) -> bool
{
    retourne '0' <= c <= '7'
}

est_nombre_hexadécimal :: fonc(c : z8) -> bool
{
    retourne ('0' <= c <= '9') || ('a' <= c <= 'f') || ('A' <= c <= 'F')
}

en_majuscule :: fonc(c: z8) -> z8
{
	si 'a' <= c <= 'z' {
		retourne c - 'a' + 'A'
	}

	retourne c
}

en_minuscule :: fonc(c: z8) -> z8
{
	si 'A' <= c <= 'Z' {
		retourne c - 'A' + 'a'
	}

	retourne c
}

en_majuscule :: fonc(dyn chn : chaine) -> chaine
{
	pour c dans chn {
		c = en_majuscule(c)
	}

	retourne chn
}

en_minuscule :: fonc(dyn chn : chaine) -> chaine
{
	pour c dans chn {
		c = en_majuscule(c)
	}

	retourne chn
}
