// Bibliothèque de flux, d'impression dans stdout.

importe GlibC

//###################################################################################

// Algorithme d'impression de nombre décimaux sur 32-bits tiré de
// https://randomascii.wordpress.com/2012/03/08/float-precisionfrom-zero-to-100-digits-2/

décalage_mot := 32

// This class represents a very limited high-precision number with 'count' 32-bit
// unsigned elements. */
// template <size_t count>
haute_précision :: struct {
	// type type_valeur n32
	// type type_produit n64

	// The individual 'digits' (32-bit unsigned integers actually) that */
	// make up the number. The most-significant digit is in m_data[0]. */
	données : [5]n32

	// Il y a un bug dans la génération de code C où on génére des variables temporaires
	// avec le type [N]Type mais C ne peut pas initialisé une telle variable avec un
	// tableau comme Kuri, donc pour l'instant nous utilisons un pointeur pour accéder
	// au tableau de données.
	pointeur : *n32
}

construit_nombre_haute_précision :: fonc() -> haute_précision
{
	dyn n : haute_précision

	pour i dans 0 ... 4 {
		n.données[i] = transtype(0 : n32)
	}

	n.pointeur = @n.données[0]

	retourne n
}

// Insert the bits from value into m_data, shifted in from the bottom (least
// significant end) by the specified number of bits. A shift of zero or less
// means that none of the bits will be shifted in. A shift of one means that
// the high bit of value will be in the bottom of the last element of m_data -
// the least significant bit. A shift of kWordShift means that value will be
// in the least significant element of m_data, and so on.
insert_low_bits :: fonc(
	dyn n : &haute_précision,
	valeur : n32,
	quantité_décalage : z32) -> rien
{
	si quantité_décalage <= 0 {
		retourne
	}

	sub_shift := transtype(quantité_décalage & (décalage_mot - 1): n32)
	big_shift := transtype(quantité_décalage / décalage_mot: n32)
	result := transtype(valeur : n64) << sub_shift
	result_low := transtype(result : n32)
	result_high := result >> transtype(décalage_mot : n64)

	// Use an unsigned type so that negative numbers will become large,
	// which makes the range checking below simpler. */
	count := transtype(5: n32)
	high_index := count - transtype(1: n32) - big_shift;

	// Write the results to the data array. If the index is too large then
	// that means that the data was shifted off the edge. */
	si high_index < count {
		n.pointeur[high_index] |= result_high;
	}

	si high_index + transtype(1: n32) < count {
		n.pointeur[high_index + transtype(1: n32)] |= result_low;
	}
}

// Insert the bits from value into m_data, shifted in from the top (most
// significant end) by the specified number of bits. A shift of zero or less
// means that none of the bits will be shifted in. A shift of one means that
// the low bit of value will be in the top of the first element of m_data -
// the most significant bit. A shift of kWordShift means that value will be
// in the most significant element of m_data, and so on.
insert_top_bits :: fonc(
	dyn n : &haute_précision,
	valeur : n32,
	quantité_décalage : z32) -> rien
{
	count := 5
	insert_low_bits(n, valeur, (count + 1) * décalage_mot - quantité_décalage);
}

// Return true if all elements of m_data are zero.
is_zero :: fonc(n : &haute_précision) -> bool
{
	pour i dans 0 ... 4 {
		si n.pointeur[i] != transtype(0 : n32) {
			retourne faux
		}
	}

	retourne vrai
}

// Divide by div and return the remainder, from 0 to div-1.
remainder :: fonc(dyn n : &haute_précision, divisor : n32) -> n32
{
	dyn remain := transtype(0 : n32)

	// Standard long-division algorithm.
	pour i dans 0 ... 4 {
		dividend := (transtype(remain : n64) << transtype(décalage_mot: n64)) + n.pointeur[i]
		result := dividend / divisor
		remain = transtype(dividend % divisor : n32)
		n.pointeur[i] = transtype(result : n32)
	}

	retourne remain
}

// Multiply by mul and return the overflow, from 0 to mul - 1
overflow :: fonc(dyn n : &haute_précision, mul : n32) -> n32
{
	dyn over := transtype(0 : n32)

	pour j dans 0 ... 4 {
		i := 4 - j

		result := transtype(mul : n64) * n.pointeur[i] + over;

		// Put the bottom bits of the results back.
		n.pointeur[i] = transtype(result : n32)
		over = transtype(result >> transtype(décalage_mot: n64) : n32)
	}

	retourne over;
}

// ------------------------------------------------------------

Enchaineuse :: struct {
    résultat : chaine
    taille : z64
}

crée_enchaineuse :: fonc() -> Enchaineuse
{
    dyn enchaineuse : Enchaineuse
    retourne enchaineuse
}

détruit :: fonc(dyn enchaineuse : &Enchaineuse) -> rien
{
	déloge enchaineuse.résultat
	enchaineuse.taille = 0
}

réserve :: fonc(dyn enchaineuse : &Enchaineuse, taille : z64) -> rien
{
	si taille < 0 {
		// Erreur ?
		retourne
	}

	si taille <= enchaineuse.résultat.taille {
		retourne
	}

	reloge enchaineuse.résultat : chaine(taille)
}

appends :: fonc(dyn enchaineuse : &Enchaineuse, chn : chaine) -> rien
{
	src := chn.pointeur
	dst := @enchaineuse.résultat[enchaineuse.taille]
	taille := chn.taille

    copie_mem_nonsur(src=src, dst=dst, taille=taille)
    enchaineuse.taille += taille
}

pousse :: fonc(dyn enchaineuse : &Enchaineuse, lettre : z8) -> rien
{
	ancienne_taille := enchaineuse.taille
	nouvelle_taille := ancienne_taille + 1
	enchaineuse.réserve(nouvelle_taille)
	enchaineuse.résultat[enchaineuse.taille] = lettre
	enchaineuse.taille += 1
}

pousse :: fonc(dyn enchaineuse : &Enchaineuse, chn : chaine) -> rien
{
	si chn.taille == 0 {
		retourne
	}

	nouvelle_taille := enchaineuse.taille + chn.taille
	enchaineuse.réserve(nouvelle_taille)
	enchaineuse.appends(chn)
}

pousse :: fonc(dyn enchaineuse : &Enchaineuse, chns : ...chaine) -> rien
{
	dyn taille : z64

	pour chn dans chns {
		taille += chn.taille
	}

	enchaineuse.réserve(enchaineuse.taille + taille)

	pour chn dans chns {
		enchaineuse.appends(chn)
	}
}

pousse :: fonc(dyn enchaineuse : &Enchaineuse, args: ...eini) -> rien
{
	pour arg dans args {
		imprime_valeur(enchaineuse, arg.pointeur, arg.info, faux)
	}
}

// Retourne une chaine correspondant à l'enchainement de toutes les chaines
// spécifiées. La chaine retournée a été logé et doit être délogée par
// l'appelante.
enchaine :: fonc(chns : ...chaine) -> chaine
{
	dyn enchaineuse : Enchaineuse
	dyn taille : z64

	// À FAIRE : trouve comment passer des arguments variadiques à
	// d'autres fonctions
	pour chn dans chns {
		taille += chn.taille
	}

	enchaineuse.réserve(taille)

	pour chn dans chns {
		enchaineuse.appends(chn)
	}

	retourne enchaineuse.résultat
}

//###################################################################################

NombreDécimal :: union nonsûr {
	i : z32
	f : r32
}

construit_nombre_décimal :: fonc(f : r32) -> NombreDécimal
{
	retourne NombreDécimal{ f = f }
}

// Extraction portable des composants
est_négatif :: fonc(n : &NombreDécimal) -> bool
{
	retourne (n.i >> 31) != 0
}

mantisse_crue :: fonc(n : &NombreDécimal) -> z32
{
	retourne n.i & ((1 << 23) - 1)
}

exposant_cru :: fonc(n : &NombreDécimal) -> z32
{
	retourne (n.i >> 23) & 0xFF
}

// Imprime le nombre décimal en utilisant un nombre entier de haute précision afin de
// mieux cerner la valeur exacte du décimal.
// À FAIRE : il y a un bug où les données du haute_précision sont corrompues quand on les
// passe à une fonction il semblerait.
imprime_nombre_décimal_haute_précision :: fonc(dyn enchaineuse : &Enchaineuse, f : r32) -> rien
{
	// Mets le nombre dans notre union magique afin d'extraire les composants
	num := construit_nombre_décimal(f)

	// Défini le caractère pour le signe
	si num.est_négatif() {
		enchaineuse.pousse('-')
	}

	// Vérifie si NaN ou infinité
	si num.exposant_cru() == 255 {
		// Vérifie si infinité
		si num.mantisse_crue() == 0 {
			enchaineuse.pousse("inf")
			retourne
		}

		// Sinon nous avons un NaN. On pourrait imprimer la valeur crue de la mantisse.
		enchaineuse.pousse("nan")
		retourne
	}

	// Ajustement pour le biais de l'exposant.
	dyn valeur_exposant := num.exposant_cru() - 127

	// Ajoute celui impliqué à la mantisse.
	dyn valeur_mantisse := (1 << 23) + num.mantisse_crue()

	// Cas spécial pour les dénormales - pas de valeur spéciale d'exposant et pas d'impliquée
	si num.exposant_cru() == 0 {
		valeur_exposant = -126
		valeur_mantisse = num.mantisse_crue()
	}

	// Le premier bit de la mantisse a une valeur implicite de 1 et ceci peut
	// être décalé de 127 positions vers la gauche, donc de 125 bits vers la gauche
	// du point binaire, ou 4 mots pour la part entière.
	dyn part_entière := construit_nombre_haute_précision() // haute_précision<4>

	// Quand notre valeur_exposant est 0 (un nombre entre 1.0 et 2.0),
	// nous avons une mantisse de 24 bits et la valeur implicite du bit le plus haut
	// est 1. Nous devons donc décaler 9 bits depuis le bas afin d'avoir le 24ème bit
	// dans la position du 1 dans portion entière, ajoutant le décalage de l'exposant.
	part_entière.insert_low_bits(
		transtype(valeur_mantisse : n32),
		9 + valeur_exposant : n32)

	// Perfome toujours au moins une itération, afin d'avoir un zéro au début.
	répète {
		remainder := part_entière.remainder(transtype(10 : n32))
		enchaineuse.pousse('0' + transtype(remainder : z8))
	} tantque !part_entière.is_zero()

	// À FAIRE : réordonne les chiffres.
	// std::reverse(result.begin(), result.end());

	// Ajout le point décimal.
	enchaineuse.pousse('.')

	// Nous avons une mantisse de 23-bits à droite du point binaire et ceci
	// peut être décalé de 126 positions vers la droite, donc 149 bits, ou
	// 5 mots de 32-bits.
	dyn frac := construit_nombre_haute_précision() // haute_précision<5>

	// Quand valeur_exposant est zéro nous voulons décaler 23 bits de mantisse dans
	// la part fractionnelle.
	frac.insert_top_bits(transtype(valeur_mantisse : n32), 23 - valeur_exposant);

	tantque !frac.is_zero() {
		overflow := frac.overflow(transtype(10 : n32))
		enchaineuse.pousse('0' + transtype(overflow : z8))
	}
}

//###################################################################################

imprime_valeur_entier_naturel :: fonc(
	dyn enchaineuse : &Enchaineuse,
	dyn valeur : n64) -> rien
{
	si valeur == transtype(0: n64) {
		enchaineuse.pousse("0")
		retourne
	}

	chiffres := "0123456789"

	dyn résultat : [20]z8
	dyn taille_résultat := 0

	tantque valeur != transtype(0: n64) {
		chiffre := valeur % transtype(10: n64)
		résultat[taille_résultat] = chiffres[chiffre]
		valeur /= transtype(10: n64)
		taille_résultat += 1
	}

	pour i dans 0 ... taille_résultat {
		enchaineuse.pousse(résultat[taille_résultat - i])
	}
}

imprime_valeur_entier_relatif :: fonc(
	dyn enchaineuse : &Enchaineuse,
	dyn valeur : z64) -> rien
{
	si valeur == 0 {
		enchaineuse.pousse("0")
		retourne
	}

	si valeur < 0 {
		enchaineuse.pousse("-")
		valeur = -valeur
	}

	chiffres := "0123456789"

	dyn résultat : [20]z8
	dyn taille_résultat := 0

	tantque valeur != 0 {
		chiffre := valeur % 10
		résultat[taille_résultat] = chiffres[chiffre]
		valeur /= 10
		taille_résultat += 1
	}

	pour i dans 0 ... taille_résultat - 1 {
		enchaineuse.pousse(résultat[taille_résultat - i - 1])
	}
}

imprime_valeur_entière :: fonc(
	dyn enchaineuse : &Enchaineuse,
	pointeur : *z8,
	info : *InfoTypeEntier) -> rien
{
	si info.est_signé {
		dyn x : z64

		si info.taille_en_octet == transtype(1: n32) {
			x = mémoire(transtype(pointeur : *z8))
		}
		sinon si info.taille_en_octet == transtype(2: n32) {
			x = mémoire(transtype(pointeur : *z16))
		}
		sinon si info.taille_en_octet == transtype(4: n32) {
			x = mémoire(transtype(pointeur : *z32))
		}
		sinon si info.taille_en_octet == transtype(8: n32) {
			x = mémoire(transtype(pointeur : *z64))
		}

		imprime_valeur_entier_relatif(enchaineuse, x)
	}
	sinon {
		dyn x : n64

		si info.taille_en_octet == transtype(1: n32) {
			x = mémoire(transtype(pointeur : *n8))
		}
		sinon si info.taille_en_octet == transtype(2: n32) {
			x = mémoire(transtype(pointeur : *n16))
		}
		sinon si info.taille_en_octet == transtype(4: n32) {
			x = mémoire(transtype(pointeur : *n32))
		}
		sinon si info.taille_en_octet == transtype(8: n32) {
			x = mémoire(transtype(pointeur : *n64))
		}

		imprime_valeur_entier_naturel(enchaineuse, x)
	}
}

imprime_nombre_décimal :: fonc(dyn enchaineuse : &Enchaineuse, f : r32) -> rien
{
	// Mets le nombre dans notre union magique afin d'extraire les composants
	num := construit_nombre_décimal(f)

	// Défini le caractère pour le signe
	si num.est_négatif() {
		enchaineuse.pousse('-')
	}

	// Vérifie si NaN ou infinité
	si num.exposant_cru() == 255 {
		// Vérifie si infinité
		si num.mantisse_crue() == 0 {
			enchaineuse.pousse("inf")
			retourne
		}

		// Sinon nous avons un NaN. On pourrait imprimer la valeur crue de la mantisse.
		enchaineuse.pousse("nan")
		retourne
	}

	si f == 0.0 {
		enchaineuse.pousse("0.0")
		retourne
	}

	dyn x := f

	si f < 0.0 {
		x = -x
	}

	dyn part_entière := transtype(x : z64)

	imprime_valeur_entier_relatif(enchaineuse, part_entière)

	enchaineuse.pousse('.')

	dyn frac := x - transtype(part_entière : r32)

	chiffres := "0123456789"

	répète {
		frac *= 10.0
		chiffre := transtype(frac : z64)

		enchaineuse.pousse(chiffres[chiffre])

		frac = frac - transtype(chiffre : r32)
	} tantque frac < 1.0 && frac != 0.0
}

imprime_pointeur :: fonc(
	dyn enchaineuse : &Enchaineuse,
	pointeur : *rien) -> rien
{
    si pointeur == nul {
        enchaineuse.pousse("(nul)")
        retourne
    }

    valeur := transtype(pointeur : n64)

    enchaineuse.pousse("0x")

    chiffres_hex := "0123456789ABCDEF"

    dyn décalage := transtype(60 : n64)

    pour i dans 0 ... 15 {
        chiffre := (valeur >> décalage) & transtype(0x0F : n64)
        enchaineuse.pousse(chiffres_hex[chiffre])
        décalage -= transtype(4 : n64)
    }
}

imprime_valeur :: fonc(
	dyn enchaineuse : &Enchaineuse,
	pointeur : *z8,
	info : *InfoType,
	échappe_chn : bool) -> rien
{
    discr info.id {
		OCTET {
			x := mémoire(transtype(pointeur : *octet))
            chiffres_hex := "0123456789ABCDEF"

			dyn chiffre := (x >> transtype(4 : octet)) & transtype(0x0F : octet)
			enchaineuse.pousse(chiffres_hex[chiffre])

			chiffre = x & transtype(0x0F : octet)
			enchaineuse.pousse(chiffres_hex[chiffre])
		}
		ENTIER {
			info_arg := transtype(info : *InfoTypeEntier)
            imprime_valeur_entière(enchaineuse, pointeur, info_arg)
		}
		RÉEL {
			dyn y : r32

            si info.taille_en_octet == transtype(2: n32) {
				x := mémoire(transtype(pointeur : *r16))
				y = x
			}
			sinon si info.taille_en_octet == transtype(4: n32) {
				y = mémoire(transtype(pointeur : *r32))
			}
			sinon si info.taille_en_octet == transtype(8: n32) {
				x := mémoire(transtype(pointeur : *r64))
				y = transtype(x : r32)
			}

			imprime_nombre_décimal(enchaineuse, y)
		}
		BOOLÉEN {
			x := mémoire(transtype(pointeur : *bool))

            si x {
				enchaineuse.pousse("vrai")
			}
			sinon {
				enchaineuse.pousse("faux")
			}
		}
		CHAINE {
			x := mémoire(transtype(pointeur : *chaine))

            si échappe_chn {
				enchaineuse.pousse('"')
			}

			enchaineuse.pousse(x)

            si échappe_chn {
				enchaineuse.pousse('"')
			}
		}
		STRUCTURE {
			info_arg := transtype(info : *InfoTypeStructure)

            enchaineuse.pousse(info_arg.nom)
            enchaineuse.pousse(" {")

            pour membre, idx dans info_arg.membres {
				nom := membre.nom
                décalage := membre.décalage
				id := membre.id

                si idx != 0 {
                    enchaineuse.pousse(',')
                }

                enchaineuse.pousse(nom)
                enchaineuse.pousse(" = ")

				imprime_valeur(enchaineuse, pointeur + décalage, id, vrai)
			}

            enchaineuse.pousse(" }")
		}
		POINTEUR {
			info_arg := transtype(info : *InfoTypePointeur)

		    // Ne pas oublier qu'il y a un niveau d'indirection.
			x := mémoire(transtype(pointeur : **z8))

			si info_arg.est_référence {
				imprime_valeur(enchaineuse, x, info_arg.type_pointé, vrai)
			}
			sinon {
            	imprime_pointeur(enchaineuse, x)
			}
		}
		FONCTION {
		    // Ne pas oublier qu'il y a un niveau d'indirection.
			x := mémoire(transtype(pointeur : **z8))
            imprime_pointeur(enchaineuse, x)
		}
		EINI {
			x := mémoire(transtype(pointeur : *eini))

            enchaineuse.pousse("eini { ptr = ")
            imprime_pointeur(enchaineuse, x.pointeur)
            enchaineuse.pousse(", info = ")
            imprime_pointeur(enchaineuse, x.info)
            enchaineuse.pousse(" }")
		}
		RIEN {
            enchaineuse.pousse("rien")
		}
		TABLEAU {
			info_arg := transtype(info : *InfoTypeTableau)

            décalage := transtype(info_arg.type_pointé.taille_en_octet: z32)

			dyn max_élément := 5

            enchaineuse.pousse("[")

            si info_arg.est_tableau_fixe {
				si info_arg.taille_fixe < max_élément {
					max_élément = info_arg.taille_fixe
				}

                pour i dans 0 ... max_élément - 1 {
                    si i != 0 {
                        enchaineuse.pousse(',')
                    }

                    imprime_valeur(enchaineuse, pointeur + décalage * i, info_arg.type_pointé, vrai)
                }

				si info_arg.taille_fixe > max_élément {
            		enchaineuse.pousse(", ...")
				}
            }
            sinon {
                x := mémoire(transtype(pointeur: *[]z8))

				si x.taille < max_élément {
					max_élément = transtype(x.taille: z32)
				}

                pour i dans 0 ... max_élément - 1 {
                    si i != 0 {
                        enchaineuse.pousse(',')
                    }

                    imprime_valeur(enchaineuse, x.pointeur + décalage * i, info_arg.type_pointé, vrai)
                }

				si x.taille > max_élément {
            		enchaineuse.pousse(", ...")
				}
            }

            enchaineuse.pousse("]")
		}
		ÉNUM {
			info_arg := transtype(info : *InfoTypeÉnum)

			// À FAIRE : typage selon énum
			valeur := mémoire(transtype(pointeur : *z32))
			noms := info_arg.noms

			si info_arg.est_drapeau {
				dyn valeur_trouvée := faux

				pour v, i dans info_arg.valeurs {
					si (v & valeur) != 0 {
						si valeur_trouvée {
							enchaineuse.pousse(" | ")
						}

						enchaineuse.pousse(noms[i])
						valeur_trouvée = vrai
					}
				}

				si !valeur_trouvée {
					enchaineuse.pousse("0")
				}
			}
			sinon {
				pour v, i dans info_arg.valeurs {
					si v == valeur {
						enchaineuse.pousse(noms[i])
						arrête
					}
				}
			}
		}
	}
}

imprime :: fonc(format: chaine, args: ...eini) -> rien
{
    chn := imprime_chaine(format, ...args)
	write(std_out, chn.pointeur, chn.taille)
	déloge chn
}

imprime_chaine :: fonc (format: chaine, args: ...eini) -> chaine
{
    dyn enchaineuse := crée_enchaineuse()

	dyn index := 0

	pour c dans format {
		si c == '%' && index < args.taille {
			arg := args[index]
			imprime_valeur(enchaineuse, arg.pointeur, arg.info, faux)
			index += 1
		}
		sinon {
			enchaineuse.pousse(c)
		}
	}

	retourne enchaineuse.résultat
}

imprime_sans_format :: fonc(args : ...eini) -> rien
{
    dyn enchaineuse := crée_enchaineuse()
    diffère { détruit(enchaineuse); }

    pour arg dans args {
		imprime_valeur(enchaineuse, arg.pointeur, arg.info, faux)
    }

	write(std_out, enchaineuse.résultat.pointeur, enchaineuse.résultat.taille)
}

imprime_sans_format_err :: fonc(args : ...eini) -> rien
{
    dyn enchaineuse := crée_enchaineuse()
    diffère { détruit(enchaineuse); }

    pour arg dans args {
		imprime_valeur(enchaineuse, arg.pointeur, arg.info, faux)
    }

	write(std_out, enchaineuse.résultat.pointeur, enchaineuse.résultat.taille)
}
