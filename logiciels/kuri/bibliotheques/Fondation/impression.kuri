// Bibliothèque de flux, d'impression dans stdout.

importe GlibC
importe Numérique

//###################################################################################

Enchaineuse :: struct {
    résultat : chaine
    taille : z64
}

crée_enchaineuse :: fonc() -> Enchaineuse
{
    dyn enchaineuse : Enchaineuse
    retourne enchaineuse
}

détruit :: fonc(dyn enchaineuse : &Enchaineuse) -> rien
{
	déloge enchaineuse.résultat
	enchaineuse.taille = 0
}

réserve :: fonc(dyn enchaineuse : &Enchaineuse, taille : z64) -> rien
{
	si taille < 0 {
		// Erreur ?
		retourne
	}

	si taille <= enchaineuse.résultat.taille {
		retourne
	}

	reloge enchaineuse.résultat : chaine(taille)
}

appends :: fonc(dyn enchaineuse : &Enchaineuse, chn : chaine) -> rien
{
	src := chn.pointeur
	dst := @enchaineuse.résultat[enchaineuse.taille]
	taille := chn.taille

    copie_mem_nonsur(src=src, dst=dst, taille=taille)
    enchaineuse.taille += taille
}

pousse :: fonc(dyn enchaineuse : &Enchaineuse, lettre : z8) -> rien
{
	ancienne_taille := enchaineuse.taille
	nouvelle_taille := ancienne_taille + 1
	enchaineuse.réserve(nouvelle_taille)
	enchaineuse.résultat[enchaineuse.taille] = lettre
	enchaineuse.taille += 1
}

pousse :: fonc(dyn enchaineuse : &Enchaineuse, chn : chaine) -> rien
{
	si chn.taille == 0 {
		retourne
	}

	nouvelle_taille := enchaineuse.taille + chn.taille
	enchaineuse.réserve(nouvelle_taille)
	enchaineuse.appends(chn)
}

pousse :: fonc(dyn enchaineuse : &Enchaineuse, chns : ...chaine) -> rien
{
	dyn taille : z64

	pour chn dans chns {
		taille += chn.taille
	}

	enchaineuse.réserve(enchaineuse.taille + taille)

	pour chn dans chns {
		enchaineuse.appends(chn)
	}
}

pousse :: fonc(dyn enchaineuse : &Enchaineuse, args: ...eini) -> rien
{
	pour arg dans args {
		imprime_valeur(enchaineuse, arg.pointeur, arg.info, faux)
	}
}

// Retourne une chaine correspondant à l'enchainement de toutes les chaines
// spécifiées. La chaine retournée a été logé et doit être délogée par
// l'appelante.
enchaine :: fonc(chns : ...chaine) -> chaine
{
	dyn enchaineuse : Enchaineuse
	enchaineuse.pousse(...chns)
	retourne enchaineuse.résultat
}

//###################################################################################

// Imprime le nombre décimal en utilisant un nombre entier de haute précision afin de
// mieux cerner la valeur exacte du décimal.
// https://randomascii.wordpress.com/2012/03/08/float-precisionfrom-zero-to-100-digits-2/
imprime_nombre_décimal_haute_précision :: fonc(dyn enchaineuse : &Enchaineuse, f : r32) -> rien
{
	// Mets le nombre dans notre union magique afin d'extraire les composants
	num := construit_entier_ou_décimal(f)

	// Défini le caractère pour le signe
	si num.est_négatif() {
		enchaineuse.pousse('-')
	}

	// Vérifie si NaN ou infinité
	si num.exposant_cru() == 255 {
		// Vérifie si infinité
		si num.mantisse_crue() == 0 {
			enchaineuse.pousse("inf")
			retourne
		}

		// Sinon nous avons un NaN. On pourrait imprimer la valeur crue de la mantisse.
		enchaineuse.pousse("nan")
		retourne
	}

	// Ajustement pour le biais de l'exposant.
	dyn valeur_exposant := num.exposant_cru() - 127

	// Ajoute celui implicit à la mantisse.
	dyn valeur_mantisse := (1 << 23) + num.mantisse_crue()

	// Cas spécial pour les dénormales - pas de valeur spéciale d'exposant et pas d'impliquée
	si num.exposant_cru() == 0 {
		valeur_exposant = -126
		valeur_mantisse = num.mantisse_crue()
	}

	// Le premier bit de la mantisse a une valeur implicite de 1 et ceci peut
	// être décalé de 127 positions vers la gauche, donc de 125 bits vers la gauche
	// du point binaire, ou 4 mots pour la part entière.
	dyn part_entière := construit_nombre_haute_précision() // haute_précision<4>

	// Quand notre valeur_exposant est 0 (un nombre entre 1.0 et 2.0),
	// nous avons une mantisse de 24 bits et la valeur implicite du bit le plus haut
	// est 1. Nous devons donc décaler 9 bits depuis le bas afin d'avoir le 24ème bit
	// dans la position du 1 dans portion entière, ajoutant le décalage de l'exposant.
	insère_bits_du_bas(
		@part_entière,
		transtype(valeur_mantisse : n32),
		9 + valeur_exposant)

	dyn chn_part_entière : chaine

	// Perfome toujours au moins une itération, afin d'avoir un zéro au début.
	répète {
		reste := reste_de_la_division(@part_entière, transtype(10 : n32))
		pousse(@chn_part_entière, '0' + transtype(reste : z8))
	} tantque !est_zéro(@part_entière)

	inverse(@chn_part_entière)
	enchaineuse.pousse(chn_part_entière)
	déloge chn_part_entière

	// Ajout le point décimal.
	enchaineuse.pousse('.')

	// Nous avons une mantisse de 23-bits à droite du point binaire et ceci
	// peut être décalé de 126 positions vers la droite, donc 149 bits, ou
	// 5 mots de 32-bits.
	dyn frac := construit_nombre_haute_précision() // haute_précision<5>

	// Quand valeur_exposant est zéro nous voulons décaler 23 bits de mantisse dans
	// la part fractionnelle.
	insère_bits_du_haut(@frac, transtype(valeur_mantisse : n32), 23 - valeur_exposant);

	// Perfome toujours au moins une itération, afin d'avoir un zéro au début.
	répète {
		surplus := surplus_de_la_multiplication(@frac, transtype(10 : n32))
		enchaineuse.pousse('0' + transtype(surplus : z8))
	} tantque !est_zéro(@frac)
}

//###################################################################################

imprime_valeur_entier_naturel :: fonc(
	dyn enchaineuse : &Enchaineuse,
	dyn valeur : n64) -> rien
{
	si valeur == transtype(0: n64) {
		enchaineuse.pousse("0")
		retourne
	}

	chiffres := "0123456789"

	dyn résultat : [20]z8
	dyn taille_résultat := 0

	tantque valeur != transtype(0: n64) {
		chiffre := valeur % transtype(10: n64)
		résultat[taille_résultat] = chiffres[chiffre]
		valeur /= transtype(10: n64)
		taille_résultat += 1
	}

	pour i dans 0 ... taille_résultat {
		enchaineuse.pousse(résultat[taille_résultat - i])
	}
}

imprime_valeur_entier_relatif :: fonc(
	dyn enchaineuse : &Enchaineuse,
	dyn valeur : z64) -> rien
{
	si valeur == 0 {
		enchaineuse.pousse("0")
		retourne
	}

	si valeur < 0 {
		enchaineuse.pousse("-")
		valeur = -valeur
	}

	chiffres := "0123456789"

	dyn résultat : [20]z8
	dyn taille_résultat := 0

	tantque valeur != 0 {
		chiffre := valeur % 10
		résultat[taille_résultat] = chiffres[chiffre]
		valeur /= 10
		taille_résultat += 1
	}

	pour i dans 0 ... taille_résultat - 1 {
		enchaineuse.pousse(résultat[taille_résultat - i - 1])
	}
}

imprime_valeur_entière :: fonc(
	dyn enchaineuse : &Enchaineuse,
	pointeur : *z8,
	info : *InfoTypeEntier) -> rien
{
	si info.est_signé {
		dyn x : z64

		si info.taille_en_octet == transtype(1: n32) {
			x = mémoire(transtype(pointeur : *z8))
		}
		sinon si info.taille_en_octet == transtype(2: n32) {
			x = mémoire(transtype(pointeur : *z16))
		}
		sinon si info.taille_en_octet == transtype(4: n32) {
			x = mémoire(transtype(pointeur : *z32))
		}
		sinon si info.taille_en_octet == transtype(8: n32) {
			x = mémoire(transtype(pointeur : *z64))
		}

		imprime_valeur_entier_relatif(enchaineuse, x)
	}
	sinon {
		dyn x : n64

		si info.taille_en_octet == transtype(1: n32) {
			x = mémoire(transtype(pointeur : *n8))
		}
		sinon si info.taille_en_octet == transtype(2: n32) {
			x = mémoire(transtype(pointeur : *n16))
		}
		sinon si info.taille_en_octet == transtype(4: n32) {
			x = mémoire(transtype(pointeur : *n32))
		}
		sinon si info.taille_en_octet == transtype(8: n32) {
			x = mémoire(transtype(pointeur : *n64))
		}

		imprime_valeur_entier_naturel(enchaineuse, x)
	}
}

imprime_nombre_décimal :: fonc(dyn enchaineuse : &Enchaineuse, f : r32) -> rien
{
	// Mets le nombre dans notre union magique afin d'extraire les composants
	num := construit_entier_ou_décimal(f)

	// Défini le caractère pour le signe
	si num.est_négatif() {
		enchaineuse.pousse('-')
	}

	// Vérifie si NaN ou infinité
	si num.exposant_cru() == 255 {
		// Vérifie si infinité
		si num.mantisse_crue() == 0 {
			enchaineuse.pousse("inf")
			retourne
		}

		// Sinon nous avons un NaN. On pourrait imprimer la valeur crue de la mantisse.
		enchaineuse.pousse("nan")
		retourne
	}

	si f == 0.0 {
		enchaineuse.pousse("0.0")
		retourne
	}

	dyn x := f

	si f < 0.0 {
		x = -x
	}

	dyn part_entière := transtype(x : z64)

	imprime_valeur_entier_relatif(enchaineuse, part_entière)

	enchaineuse.pousse('.')

	dyn frac := x - transtype(part_entière : r32)

	chiffres := "0123456789"

	répète {
		frac *= 10.0
		chiffre := transtype(frac : z64)

		enchaineuse.pousse(chiffres[chiffre])

		frac = frac - transtype(chiffre : r32)
	} tantque frac < 1.0 && frac != 0.0
}

imprime_pointeur :: fonc(
	dyn enchaineuse : &Enchaineuse,
	pointeur : *rien) -> rien
{
    si pointeur == nul {
        enchaineuse.pousse("(nul)")
        retourne
    }

    valeur := transtype(pointeur : n64)

    enchaineuse.pousse("0x")

    chiffres_hex := "0123456789ABCDEF"

    dyn décalage := transtype(60 : n64)

    pour i dans 0 ... 15 {
        chiffre := (valeur >> décalage) & transtype(0x0F : n64)
        enchaineuse.pousse(chiffres_hex[chiffre])
        décalage -= transtype(4 : n64)
    }
}

imprime_valeur :: fonc(
	dyn enchaineuse : &Enchaineuse,
	pointeur : *z8,
	info : *InfoType,
	échappe_chn : bool) -> rien
{
    discr info.id {
		OCTET {
			x := mémoire(transtype(pointeur : *octet))
            chiffres_hex := "0123456789ABCDEF"

			dyn chiffre := (x >> transtype(4 : octet)) & transtype(0x0F : octet)
			enchaineuse.pousse(chiffres_hex[chiffre])

			chiffre = x & transtype(0x0F : octet)
			enchaineuse.pousse(chiffres_hex[chiffre])
		}
		ENTIER {
			info_arg := transtype(info : *InfoTypeEntier)
            imprime_valeur_entière(enchaineuse, pointeur, info_arg)
		}
		RÉEL {
			dyn y : r32

            si info.taille_en_octet == transtype(2: n32) {
				x := mémoire(transtype(pointeur : *r16))
				y = x
			}
			sinon si info.taille_en_octet == transtype(4: n32) {
				y = mémoire(transtype(pointeur : *r32))
			}
			sinon si info.taille_en_octet == transtype(8: n32) {
				x := mémoire(transtype(pointeur : *r64))
				y = transtype(x : r32)
			}

			imprime_nombre_décimal(enchaineuse, y)
		}
		BOOLÉEN {
			x := mémoire(transtype(pointeur : *bool))

            si x {
				enchaineuse.pousse("vrai")
			}
			sinon {
				enchaineuse.pousse("faux")
			}
		}
		CHAINE {
			x := mémoire(transtype(pointeur : *chaine))

            si échappe_chn {
				enchaineuse.pousse('"')
			}

			enchaineuse.pousse(x)

            si échappe_chn {
				enchaineuse.pousse('"')
			}
		}
		STRUCTURE {
			info_arg := transtype(info : *InfoTypeStructure)

            enchaineuse.pousse(info_arg.nom)
            enchaineuse.pousse(" {")

            pour membre, idx dans info_arg.membres {
				nom := membre.nom
                décalage := membre.décalage
				id := membre.id

                si idx != 0 {
                    enchaineuse.pousse(',')
                }

                enchaineuse.pousse(nom)
                enchaineuse.pousse(" = ")

				imprime_valeur(enchaineuse, pointeur + décalage, id, vrai)
			}

            enchaineuse.pousse(" }")
		}
		POINTEUR {
			info_arg := transtype(info : *InfoTypePointeur)

		    // Ne pas oublier qu'il y a un niveau d'indirection.
			x := mémoire(transtype(pointeur : **z8))

			si info_arg.est_référence {
				imprime_valeur(enchaineuse, x, info_arg.type_pointé, vrai)
			}
			sinon {
            	imprime_pointeur(enchaineuse, x)
			}
		}
		FONCTION {
		    // Ne pas oublier qu'il y a un niveau d'indirection.
			x := mémoire(transtype(pointeur : **z8))
            imprime_pointeur(enchaineuse, x)
		}
		EINI {
			x := mémoire(transtype(pointeur : *eini))

            enchaineuse.pousse("eini { ptr = ")
            imprime_pointeur(enchaineuse, x.pointeur)
            enchaineuse.pousse(", info = ")
            imprime_pointeur(enchaineuse, x.info)
            enchaineuse.pousse(" }")
		}
		RIEN {
            enchaineuse.pousse("rien")
		}
		TABLEAU {
			info_arg := transtype(info : *InfoTypeTableau)

            décalage := transtype(info_arg.type_pointé.taille_en_octet: z32)

			dyn max_élément := 5

            enchaineuse.pousse("[")

            si info_arg.est_tableau_fixe {
				si info_arg.taille_fixe < max_élément {
					max_élément = info_arg.taille_fixe
				}

                pour i dans 0 ... max_élément - 1 {
                    si i != 0 {
                        enchaineuse.pousse(',')
                    }

                    imprime_valeur(enchaineuse, pointeur + décalage * i, info_arg.type_pointé, vrai)
                }

				si info_arg.taille_fixe > max_élément {
            		enchaineuse.pousse(", ...")
				}
            }
            sinon {
                x := mémoire(transtype(pointeur: *[]z8))

				si x.taille < max_élément {
					max_élément = transtype(x.taille: z32)
				}

                pour i dans 0 ... max_élément - 1 {
                    si i != 0 {
                        enchaineuse.pousse(',')
                    }

                    imprime_valeur(enchaineuse, x.pointeur + décalage * i, info_arg.type_pointé, vrai)
                }

				si x.taille > max_élément {
            		enchaineuse.pousse(", ...")
				}
            }

            enchaineuse.pousse("]")
		}
		ÉNUM {
			info_arg := transtype(info : *InfoTypeÉnum)

			// À FAIRE : typage selon énum
			valeur := mémoire(transtype(pointeur : *z32))
			noms := info_arg.noms

			si info_arg.est_drapeau {
				dyn valeur_trouvée := faux

				pour v, i dans info_arg.valeurs {
					si (v & valeur) != 0 {
						si valeur_trouvée {
							enchaineuse.pousse(" | ")
						}

						enchaineuse.pousse(noms[i])
						valeur_trouvée = vrai
					}
				}

				si !valeur_trouvée {
					enchaineuse.pousse("0")
				}
			}
			sinon {
				pour v, i dans info_arg.valeurs {
					si v == valeur {
						enchaineuse.pousse(noms[i])
						arrête
					}
				}
			}
		}
	}
}

imprime :: fonc(format: chaine, args: ...eini) -> rien
{
    chn := imprime_chaine(format, ...args)
	write(std_out, chn.pointeur, chn.taille)
	déloge chn
}

imprime_chaine :: fonc (format: chaine, args: ...eini) -> chaine
{
    dyn enchaineuse := crée_enchaineuse()

	dyn index := 0

	pour c dans format {
		si c == '%' && index < args.taille {
			arg := args[index]
			imprime_valeur(enchaineuse, arg.pointeur, arg.info, faux)
			index += 1
		}
		sinon {
			enchaineuse.pousse(c)
		}
	}

	retourne enchaineuse.résultat
}

imprime_sans_format :: fonc(args : ...eini) -> rien
{
    dyn enchaineuse := crée_enchaineuse()
    diffère { détruit(enchaineuse); }

    pour arg dans args {
		imprime_valeur(enchaineuse, arg.pointeur, arg.info, faux)
    }

	write(std_out, enchaineuse.résultat.pointeur, enchaineuse.résultat.taille)
}

imprime_sans_format_err :: fonc(args : ...eini) -> rien
{
    dyn enchaineuse := crée_enchaineuse()
    diffère { détruit(enchaineuse); }

    pour arg dans args {
		imprime_valeur(enchaineuse, arg.pointeur, arg.info, faux)
    }

	write(std_out, enchaineuse.résultat.pointeur, enchaineuse.résultat.taille)
}
