// Bibliothèque de flux, d'impression dans stdout.

importe GlibC
importe Numérique

//###################################################################################

TamponEnchaineuse :: struct {
    données : [16384]z8
    occupé  : z32
    suivant : *TamponEnchaineuse
}

Enchaineuse :: struct {
    tampon : TamponEnchaineuse
    tampon_courant : *TamponEnchaineuse
}

initialise_enchaineuse :: fonc (dyn enchaineuse : *Enchaineuse) -> rien
{
    enchaineuse.tampon_courant = @enchaineuse.tampon
    enchaineuse.tampon_courant.occupé = 0
    enchaineuse.tampon_courant.suivant = nul
}

taille_chaine :: fonc (dyn enchaineuse: *Enchaineuse) -> z64
{
    dyn taille : z64 = 0
    dyn tampon_courant := @enchaineuse.tampon

    tantque tampon_courant != nul {
        taille += tampon_courant.occupé
        tampon_courant = tampon_courant.suivant
    }

    retourne taille
}

chaine_depuis_enchaineuse :: fonc (enchaineuse: *Enchaineuse) -> chaine
{
    taille := taille_chaine(enchaineuse)

	si taille == 0 {
		retourne copie_chaine("")
	}

    chn := loge chaine(taille)

    dyn tampon_courant := @enchaineuse.tampon

    dyn curseur : z64 = 0

    tantque tampon_courant != nul {
        taille_tampon := tampon_courant.occupé
        src := @tampon_courant.données[0]
        dst := @chn[curseur]

        copie_mem_nonsur(src = src, dst = dst, taille = taille_tampon)

        tampon_courant = tampon_courant.suivant
        curseur += taille_tampon
    }

    retourne chn
}

détruit_tampons :: fonc (enchaineuse: *Enchaineuse) -> rien
{
    // le premier tampon n'est pas alloué dynamiquement
    dyn tampon_courant := enchaineuse.tampon.suivant

    tantque tampon_courant != nul {
        suivant := tampon_courant.suivant
        déloge tampon_courant
        tampon_courant = suivant
    }
}

imprime_dans_enchaineuse :: fonc (dyn enchaineuse: *Enchaineuse, format: chaine, args: ...eini) -> rien
{
    dyn index := 0

	pour c dans format {
		si c == '%' && index < args.taille {
			arg := args[index]
			imprime_valeur(enchaineuse, arg.pointeur, arg.info, faux)
			index += 1
		}
		sinon {
			ajoute_au_tampon(enchaineuse, c)
		}
	}
}

ajoute_tampon :: fonc (dyn enchaineuse: *Enchaineuse) -> *TamponEnchaineuse
{
    dyn tampon := enchaineuse.tampon_courant

	dyn nouveau_tampon := loge TamponEnchaineuse
    nouveau_tampon.occupé = 0
	nouveau_tampon.suivant = nul

	tampon.suivant = nouveau_tampon
	enchaineuse.tampon_courant = nouveau_tampon

	retourne nouveau_tampon
}

ajoute_au_tampon :: fonc (dyn enchaineuse: *Enchaineuse, c: z8) -> rien
{
    dyn tampon := enchaineuse.tampon_courant

    si tampon.occupé == 16384 {
		tampon = ajoute_tampon(enchaineuse)
		tampon.données[0] = c
		tampon.occupé = 1
	}
	sinon {
		tampon.données[tampon.occupé] = c
		tampon.occupé += 1
	}
}

ajoute_au_tampon :: fonc (dyn enchaineuse: *Enchaineuse, chn: chaine) -> rien
{
	si chn.taille == 0 {
		retourne
	}

    dyn tampon := enchaineuse.tampon_courant

    si (tampon.occupé + chn.taille) > 16384 {
        dyn taille := 16384 - tampon.occupé
        dyn src := chn.pointeur
        dyn dst := @tampon.données[tampon.occupé]
        tampon.occupé += taille

        copie_mem_nonsur(src = src, dst = dst, taille = taille)

        tampon = ajoute_tampon(enchaineuse)

        delta := chn.taille - taille

        src = @chn[chn.taille - delta]
        dst = @tampon.données[0]
        taille = transtype(chn.taille - taille: z32)

        copie_mem_nonsur(src = src, dst = dst, taille = taille)

        tampon.occupé += delta
    }
    sinon {
        src := chn.pointeur
        dst := @tampon.données[tampon.occupé]
        taille := chn.taille

        copie_mem_nonsur(src = src, dst = dst, taille = taille)

        tampon.occupé += chn.taille
    }
}

ajoute_au_tampon :: fonc (dyn enchaineuse : *Enchaineuse, chns: ...chaine) -> rien
{
	pour chn dans chns {
		ajoute_au_tampon(enchaineuse, chn)
	}
}

ajoute_au_tampon :: fonc (dyn enchaineuse: *Enchaineuse, args: ...eini) -> rien
{
	pour arg dans args {
		imprime_valeur(enchaineuse, arg.pointeur, arg.info, faux)
	}
}

// Retourne une chaine correspondant à l'enchainement de toutes les chaines
// spécifiées. La chaine retournée a été logé et doit être délogée par
// l'appelante.
enchaine :: fonc(chns : ...chaine) -> chaine
{
	dyn enchaineuse : Enchaineuse
	initialise_enchaineuse(@enchaineuse)
	diffère { détruit_tampons(@enchaineuse) }
	ajoute_au_tampon(@enchaineuse, ...chns)
	retourne chaine_depuis_enchaineuse(@enchaineuse)
}

//###################################################################################

// Imprime le nombre décimal en utilisant un nombre entier de haute précision afin de
// mieux cerner la valeur exacte du décimal.
// https://randomascii.wordpress.com/2012/03/08/float-precisionfrom-zero-to-100-digits-2/
imprime_nombre_décimal_haute_précision :: fonc(dyn enchaineuse : *Enchaineuse, f : r32) -> rien
{
	// Mets le nombre dans notre union magique afin d'extraire les composants
	num := construit_entier_ou_décimal(f)

	// Défini le caractère pour le signe
	si num.est_négatif() {
		ajoute_au_tampon(enchaineuse, '-')
	}

	// Vérifie si NaN ou infinité
	si num.exposant_cru() == 255 {
		// Vérifie si infinité
		si num.mantisse_crue() == 0 {
			ajoute_au_tampon(enchaineuse, "inf")
			retourne
		}

		// Sinon nous avons un NaN. On pourrait imprimer la valeur crue de la mantisse.
		ajoute_au_tampon(enchaineuse, "nan")
		retourne
	}

	// Ajustement pour le biais de l'exposant.
	dyn valeur_exposant := num.exposant_cru() - 127

	// Ajoute celui implicit à la mantisse.
	dyn valeur_mantisse := (1 << 23) + num.mantisse_crue()

	// Cas spécial pour les dénormales - pas de valeur spéciale d'exposant et pas d'impliquée
	si num.exposant_cru() == 0 {
		valeur_exposant = -126
		valeur_mantisse = num.mantisse_crue()
	}

	// Le premier bit de la mantisse a une valeur implicite de 1 et ceci peut
	// être décalé de 127 positions vers la gauche, donc de 125 bits vers la gauche
	// du point binaire, ou 4 mots pour la part entière.
	dyn part_entière := construit_nombre_haute_précision() // haute_précision<4>

	// Quand notre valeur_exposant est 0 (un nombre entre 1.0 et 2.0),
	// nous avons une mantisse de 24 bits et la valeur implicite du bit le plus haut
	// est 1. Nous devons donc décaler 9 bits depuis le bas afin d'avoir le 24ème bit
	// dans la position du 1 dans portion entière, ajoutant le décalage de l'exposant.
	insère_bits_du_bas(
		@part_entière,
		transtype(valeur_mantisse : n32),
		9 + valeur_exposant)

	dyn chn_part_entière : chaine

	// Perfome toujours au moins une itération, afin d'avoir un zéro au début.
	répète {
		reste := reste_de_la_division(@part_entière, transtype(10 : n32))
		pousse(@chn_part_entière, '0' + transtype(reste : z8))
	} tantque !est_zéro(@part_entière)

	inverse(@chn_part_entière)
	ajoute_au_tampon(enchaineuse, chn_part_entière)
	déloge chn_part_entière

	// Ajout le point décimal.
	ajoute_au_tampon(enchaineuse, '.')

	// Nous avons une mantisse de 23-bits à droite du point binaire et ceci
	// peut être décalé de 126 positions vers la droite, donc 149 bits, ou
	// 5 mots de 32-bits.
	dyn frac := construit_nombre_haute_précision() // haute_précision<5>

	// Quand valeur_exposant est zéro nous voulons décaler 23 bits de mantisse dans
	// la part fractionnelle.
	insère_bits_du_haut(@frac, transtype(valeur_mantisse : n32), 23 - valeur_exposant);

	// Perfome toujours au moins une itération, afin d'avoir un zéro au début.
	répète {
		surplus := surplus_de_la_multiplication(@frac, transtype(10 : n32))
		ajoute_au_tampon(enchaineuse, '0' + transtype(surplus : z8))
	} tantque !est_zéro(@frac)
}

//###################################################################################

imprime_valeur_entier_naturel :: fonc(
	dyn enchaineuse : *Enchaineuse,
	dyn valeur : n64) -> rien
{
	si valeur == transtype(0: n64) {
		ajoute_au_tampon(enchaineuse, "0")
		retourne
	}

	chiffres := "0123456789"

	dyn résultat : [20]z8
	dyn taille_résultat := 0

	tantque valeur != transtype(0: n64) {
		chiffre := valeur % transtype(10: n64)
		résultat[taille_résultat] = chiffres[chiffre]
		valeur /= transtype(10: n64)
		taille_résultat += 1
	}

	pour i dans 0 ... taille_résultat {
		ajoute_au_tampon(enchaineuse, résultat[taille_résultat - i])
	}
}

imprime_valeur_entier_relatif :: fonc(
	dyn enchaineuse : *Enchaineuse,
	dyn valeur : z64) -> rien
{
	si valeur == 0 {
		ajoute_au_tampon(enchaineuse, "0")
		retourne
	}

	si valeur < 0 {
		ajoute_au_tampon(enchaineuse, "-")
		valeur = -valeur
	}

	chiffres := "0123456789"

	dyn résultat : [20]z8
	dyn taille_résultat := 0

	tantque valeur != 0 {
		chiffre := valeur % 10
		résultat[taille_résultat] = chiffres[chiffre]
		valeur /= 10
		taille_résultat += 1
	}

	pour i dans 0 ... taille_résultat - 1 {
		ajoute_au_tampon(enchaineuse, résultat[taille_résultat - i - 1])
	}
}

imprime_valeur_entière :: fonc(
	dyn enchaineuse : *Enchaineuse,
	pointeur : *z8,
	info : *InfoTypeEntier) -> rien
{
	si info.est_signé {
		dyn x : z64

		si info.taille_en_octet == transtype(1: n32) {
			x = mémoire(transtype(pointeur : *z8))
		}
		sinon si info.taille_en_octet == transtype(2: n32) {
			x = mémoire(transtype(pointeur : *z16))
		}
		sinon si info.taille_en_octet == transtype(4: n32) {
			x = mémoire(transtype(pointeur : *z32))
		}
		sinon si info.taille_en_octet == transtype(8: n32) {
			x = mémoire(transtype(pointeur : *z64))
		}

		imprime_valeur_entier_relatif(enchaineuse, x)
	}
	sinon {
		dyn x : n64

		si info.taille_en_octet == transtype(1: n32) {
			x = mémoire(transtype(pointeur : *n8))
		}
		sinon si info.taille_en_octet == transtype(2: n32) {
			x = mémoire(transtype(pointeur : *n16))
		}
		sinon si info.taille_en_octet == transtype(4: n32) {
			x = mémoire(transtype(pointeur : *n32))
		}
		sinon si info.taille_en_octet == transtype(8: n32) {
			x = mémoire(transtype(pointeur : *n64))
		}

		imprime_valeur_entier_naturel(enchaineuse, x)
	}
}

imprime_nombre_décimal :: fonc(dyn enchaineuse : *Enchaineuse, f : r32) -> rien
{
	// Mets le nombre dans notre union magique afin d'extraire les composants
	num := construit_entier_ou_décimal(f)

	// Défini le caractère pour le signe
	si num.est_négatif() {
		ajoute_au_tampon(enchaineuse, '-')
	}

	// Vérifie si NaN ou infinité
	si num.exposant_cru() == 255 {
		// Vérifie si infinité
		si num.mantisse_crue() == 0 {
			ajoute_au_tampon(enchaineuse, "inf")
			retourne
		}

		// Sinon nous avons un NaN. On pourrait imprimer la valeur crue de la mantisse.
		ajoute_au_tampon(enchaineuse, "nan")
		retourne
	}

	si f == 0.0 {
		ajoute_au_tampon(enchaineuse, "0.0")
		retourne
	}

	dyn x := f

	si f < 0.0 {
		x = -x
	}

	dyn part_entière := transtype(x : z64)

	imprime_valeur_entier_relatif(enchaineuse, part_entière)

	ajoute_au_tampon(enchaineuse, '.')

	dyn frac := x - transtype(part_entière : r32)

	chiffres := "0123456789"

	répète {
		frac *= 10.0
		chiffre := transtype(frac : z64)

		ajoute_au_tampon(enchaineuse, chiffres[chiffre])

		frac = frac - transtype(chiffre : r32)
	} tantque frac < 1.0 && frac != 0.0
}

imprime_pointeur :: fonc(
	dyn enchaineuse : *Enchaineuse,
	pointeur : *rien) -> rien
{
    si pointeur == nul {
        ajoute_au_tampon(enchaineuse, "(nul)")
        retourne
    }

    valeur := transtype(pointeur : n64)

    ajoute_au_tampon(enchaineuse, "0x")

    chiffres_hex := "0123456789ABCDEF"

    dyn décalage := transtype(60 : n64)

    pour i dans 0 ... 15 {
        chiffre := (valeur >> décalage) & transtype(0x0F : n64)
        ajoute_au_tampon(enchaineuse, chiffres_hex[chiffre])
        décalage -= transtype(4 : n64)
    }
}

imprime_valeur :: fonc(
	dyn enchaineuse : *Enchaineuse,
	pointeur : *z8,
	info : *InfoType,
	échappe_chn : bool) -> rien
{
    discr info.id {
		OCTET {
			x := mémoire(transtype(pointeur : *octet))
            chiffres_hex := "0123456789ABCDEF"

			dyn chiffre := (x >> transtype(4 : octet)) & transtype(0x0F : octet)
			ajoute_au_tampon(enchaineuse, chiffres_hex[chiffre])

			chiffre = x & transtype(0x0F : octet)
			ajoute_au_tampon(enchaineuse, chiffres_hex[chiffre])
		}
		ENTIER {
			info_arg := transtype(info : *InfoTypeEntier)
            imprime_valeur_entière(enchaineuse, pointeur, info_arg)
		}
		RÉEL {
			dyn y : r32

            si info.taille_en_octet == transtype(2: n32) {
				x := mémoire(transtype(pointeur : *r16))
				y = x
			}
			sinon si info.taille_en_octet == transtype(4: n32) {
				y = mémoire(transtype(pointeur : *r32))
			}
			sinon si info.taille_en_octet == transtype(8: n32) {
				x := mémoire(transtype(pointeur : *r64))
				y = transtype(x : r32)
			}

			imprime_nombre_décimal(enchaineuse, y)
		}
		BOOLÉEN {
			x := mémoire(transtype(pointeur : *bool))

            si x {
				ajoute_au_tampon(enchaineuse, "vrai")
			}
			sinon {
				ajoute_au_tampon(enchaineuse, "faux")
			}
		}
		CHAINE {
			x := mémoire(transtype(pointeur : *chaine))

            si échappe_chn {
				ajoute_au_tampon(enchaineuse, '"')
			}

			ajoute_au_tampon(enchaineuse, x)

            si échappe_chn {
				ajoute_au_tampon(enchaineuse, '"')
			}
		}
		STRUCTURE {
			info_arg := transtype(info : *InfoTypeStructure)

            ajoute_au_tampon(enchaineuse, info_arg.nom)
            ajoute_au_tampon(enchaineuse, " {")

            pour membre, idx dans info_arg.membres {
				nom := membre.nom
                décalage := membre.décalage
				id := membre.id

                si idx != 0 {
                    ajoute_au_tampon(enchaineuse, ',')
                }

                ajoute_au_tampon(enchaineuse, nom)
                ajoute_au_tampon(enchaineuse, " = ")

				imprime_valeur(enchaineuse, pointeur + décalage, id, vrai)
			}

            ajoute_au_tampon(enchaineuse, " }")
		}
		POINTEUR {
			info_arg := transtype(info : *InfoTypePointeur)

		    // Ne pas oublier qu'il y a un niveau d'indirection.
			x := mémoire(transtype(pointeur : **z8))

			si info_arg.est_référence {
				imprime_valeur(enchaineuse, x, info_arg.type_pointé, vrai)
			}
			sinon {
            	imprime_pointeur(enchaineuse, x)
			}
		}
		FONCTION {
		    // Ne pas oublier qu'il y a un niveau d'indirection.
			x := mémoire(transtype(pointeur : **z8))
            imprime_pointeur(enchaineuse, x)
		}
		EINI {
			x := mémoire(transtype(pointeur : *eini))

            ajoute_au_tampon(enchaineuse, "eini { ptr = ")
            imprime_pointeur(enchaineuse, x.pointeur)
            ajoute_au_tampon(enchaineuse, ", info = ")
            imprime_pointeur(enchaineuse, x.info)
            ajoute_au_tampon(enchaineuse, " }")
		}
		RIEN {
            ajoute_au_tampon(enchaineuse, "rien")
		}
		TABLEAU {
			info_arg := transtype(info : *InfoTypeTableau)

            décalage := transtype(info_arg.type_pointé.taille_en_octet: z32)

			dyn max_élément := 5

            ajoute_au_tampon(enchaineuse, "[")

            si info_arg.est_tableau_fixe {
				si info_arg.taille_fixe < max_élément {
					max_élément = info_arg.taille_fixe
				}

                pour i dans 0 ... max_élément - 1 {
                    si i != 0 {
                        ajoute_au_tampon(enchaineuse, ',')
                    }

                    imprime_valeur(enchaineuse, pointeur + décalage * i, info_arg.type_pointé, vrai)
                }

				si info_arg.taille_fixe > max_élément {
            		ajoute_au_tampon(enchaineuse, ", ...")
				}
            }
            sinon {
                x := mémoire(transtype(pointeur: *[]z8))

				si x.taille < max_élément {
					max_élément = transtype(x.taille: z32)
				}

                pour i dans 0 ... max_élément - 1 {
                    si i != 0 {
                        ajoute_au_tampon(enchaineuse, ',')
                    }

                    imprime_valeur(enchaineuse, x.pointeur + décalage * i, info_arg.type_pointé, vrai)
                }

				si x.taille > max_élément {
            		ajoute_au_tampon(enchaineuse, ", ...")
				}
            }

            ajoute_au_tampon(enchaineuse, "]")
		}
		ÉNUM {
			info_arg := transtype(info : *InfoTypeÉnum)

			// À FAIRE : typage selon énum
			valeur := mémoire(transtype(pointeur : *z32))
			noms := info_arg.noms

			si info_arg.est_drapeau {
				dyn valeur_trouvée := faux

				pour v, i dans info_arg.valeurs {
					si (v & valeur) != 0 {
						si valeur_trouvée {
							ajoute_au_tampon(enchaineuse, " | ")
						}

						ajoute_au_tampon(enchaineuse, noms[i])
						valeur_trouvée = vrai
					}
				}

				si !valeur_trouvée {
					ajoute_au_tampon(enchaineuse, "0")
				}
			}
			sinon {
				pour v, i dans info_arg.valeurs {
					si v == valeur {
						ajoute_au_tampon(enchaineuse, noms[i])
						arrête
					}
				}
			}
		}
	}
}

imprime :: fonc(format: chaine, args: ...eini) -> rien
{
    chn := imprime_chaine(format, ...args)
	write(std_out, chn.pointeur, chn.taille)
	déloge chn
}

imprime_chaine :: fonc (format: chaine, args: ...eini) -> chaine
{
    enchaineuse : Enchaineuse
	initialise_enchaineuse(@enchaineuse)
	diffère { détruit_tampons(@enchaineuse) }

	imprime_dans_enchaineuse(@enchaineuse, format, ...args)
	retourne chaine_depuis_enchaineuse(@enchaineuse)
}

imprime_sans_format :: fonc(args : ...eini) -> rien
{
    enchaineuse : Enchaineuse
	initialise_enchaineuse(@enchaineuse)
    diffère { détruit_tampons(@enchaineuse); }

    pour arg dans args {
		imprime_valeur(@enchaineuse, arg.pointeur, arg.info, faux)
    }

	résultat := chaine_depuis_enchaineuse(@enchaineuse)
	write(std_out, résultat.pointeur, résultat.taille)
	déloge résultat
}

imprime_sans_format_err :: fonc(args : ...eini) -> rien
{
    enchaineuse : Enchaineuse
	initialise_enchaineuse(@enchaineuse)
	diffère { détruit_tampons(@enchaineuse); }

    pour arg dans args {
		imprime_valeur(@enchaineuse, arg.pointeur, arg.info, faux)
    }

	résultat := chaine_depuis_enchaineuse(@enchaineuse)
	write(std_err, résultat.pointeur, résultat.taille)
	déloge résultat
}

imprime_log :: fonc (mode: ModeLogage, ident: chaine, format: chaine, args: ...eini) -> rien
{
	message := imprime_chaine(format, ...args)

	// À FAIRE (compilateur, bug dans la génération de code C)
	log := contexte.logueur
    log(message, ident, mode, contexte.données_logueur)
	déloge message
}
