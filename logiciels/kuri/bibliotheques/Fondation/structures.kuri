# Bibliothèque de structures de données.
# Les structures utilisent des pointeurs vers 'rien', et la taille des données
# en octet pour avoir un semblant de généricité.

charge "memoire"

#################################################################

# Une pile où les premiers éléments ajoutés sont les derniers retirés.

struct pile {
	taille_elem : z64
	taille : z64
	capacité : z64
	tampon : []octet
}

fonc crée_pile(taille_elem : z64) : *pile
{
	dyn p = loge pile
	taille_elem de p = taille_elem
	retourne p
}

fonc decrée_pile(dyn p : *pile) : rien
{
	taille_elem de p = 0
	taille de p = 0
	capacité de p = 0
	déloge tampon de p
	déloge p
}

fonc empile(dyn p : *pile, d : *rien) : rien
{
    si taille de p == capacité de p {
		reloge tampon de p : [(taille de p + 1) * taille_elem de p]octet
		capacité de p += 1
    }

	soit ptr = @p.tampon[taille de p * taille_elem de p]
	copie_mem_nonsur(d, ptr, taille_elem de p)

	taille de p += 1
}

fonc est_vide(p : *pile) : bool
{
	retourne taille de p == 0
}

fonc dépile(dyn p : *pile, d : *rien) : rien
{
    si est_vide(p) {
		retourne
    }

    si d != nul {
		soit ptr = @p.tampon[(taille de p - 1) * taille_elem de p]
		copie_mem_nonsur(ptr, d, taille_elem de p)
    }

	taille de p -= 1
}

#################################################################

# Une file où les premiers éléments ajoutés sont les premiers retirés.

struct file {
	taille_elem : z64
	taille : z64
	capacité : z64
	tampon : []octet
}

fonc crée_file(taille_elem : z64) : *file
{
	dyn q = loge file
	taille_elem de q = taille_elem
	retourne q
}

fonc decrée_file(dyn q : *file) : rien
{
	taille_elem de q = 0
	taille de q = 0
	capacité de q = 0
	déloge tampon de q
	déloge q
}

fonc enfile(dyn q : *file, d : *rien) : rien
{
    si taille de q == capacité de q {
		reloge tampon de q : [(taille de q + 1) * taille_elem de q]octet
		capacité de q += 1
    }

	soit ptr = @q.tampon[taille de q * taille_elem de q]
	copie_mem_nonsur(d, ptr, taille_elem de q)

	taille de q += 1
}

fonc est_vide(q : *file) : bool
{
	retourne taille de q == 0
}

fonc défile(dyn q : *file, d : *rien) : rien
{
    si est_vide(q) {
		retourne
    }

    si d != nul {
		soit ptr = @q.tampon[0]
		copie_mem_nonsur(ptr, d, taille_elem de q)
    }

    # réajuste la file en décalant les données

    si taille de q > 1 {
		soit ptr_dst = @q.tampon[0]
		soit ptr_src = @q.tampon[taille_elem de q]
		copie_mem_nonsur(ptr_src, ptr_dst, taille_elem de q * (taille de q - 1))
    }

	taille de q -= 1
}

#################################################################

# Une tableau où les données sont stockées de manière séquentielle.

struct tableau {
	taille_elem : z64
	taille : z64
	capacité : z64
	tampon : []octet
}

fonc crée_tableau(taille_elem : z64) : *tableau
{
	dyn t = loge tableau
	taille_elem de t = taille_elem
	retourne t
}

fonc decrée_tableau(dyn t : *tableau) : rien
{
	taille_elem de t = 0
	taille de t = 0
	capacité de t = 0
	déloge tampon de t
	déloge t
}

fonc pousse_tableau(dyn t : *tableau, d : *rien) : rien
{
    si taille de t == capacité de t {
		reloge tampon de t : [(taille de t + 1) * taille_elem de t]octet
		capacité de t += 1
    }

	soit ptr = @t.tampon[taille de t * taille_elem de t]
	copie_mem_nonsur(d, ptr, taille_elem de t)

	taille de t += 1
}

fonc est_vide(t : *tableau) : bool
{
	retourne taille de t == 0
}

fonc début_tableau(t : *tableau) : *rien
{
    si est_vide(t) {
		retourne nul
    }

	soit ptr = @t.tampon[0]
	retourne transtype(ptr : *rien)
}

fonc fin_tableau(t : *tableau) : *rien
{
    si est_vide(t) {
		retourne nul
    }

    # NOTE : contrairement à C++, nous ne retournons pas un pointeur après la fin,
    # mais la fin elle-même car les boucles utilisant des plages vont jusqu'au dernier
    # élément (<=)
	soit ptr = @t.tampon[(taille de t - 1) * taille_elem de t]
	retourne transtype(ptr : *rien)
}
