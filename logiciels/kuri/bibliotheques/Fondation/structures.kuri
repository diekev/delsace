// Bibliothèque de structures de données.
// Les structures utilisent des pointeurs vers 'rien', et la taille des données
// en octet pour avoir un semblant de généricité.

charge "memoire"

//################################################################

// Une pile où les premiers éléments ajoutés sont les derniers retirés.

struct pile {
	taille_elem : z64
	taille : z64
	capacité : z64
	tampon : []octet
}

fonc crée_pile(taille_elem : z64) -> *pile
{
	dyn p := loge pile
	p.taille_elem = taille_elem
	retourne p
}

fonc decrée_pile(dyn p : *pile) -> rien
{
	p.taille_elem = 0
	p.taille = 0
	p.capacité = 0
	déloge p.tampon
	déloge p
}

fonc empile(dyn p : *pile, d : *rien) -> rien
{
    si p.taille == p.capacité {
		reloge p.tampon : [(p.taille + 1) * p.taille_elem]octet
		p.capacité += 1
    }

	ptr := @p.tampon[p.taille * p.taille_elem]
	copie_mem_nonsur(d, ptr, p.taille_elem)

	p.taille += 1
}

fonc est_vide(p : *pile) -> bool
{
	retourne p.taille == 0
}

fonc dépile(dyn p : *pile, d : *rien) -> rien
{
    si est_vide(p) {
		retourne
    }

    si d != nul {
		ptr := @p.tampon[(p.taille - 1) * p.taille_elem]
		copie_mem_nonsur(ptr, d, p.taille_elem)
    }

	p.taille -= 1
}

//################################################################

// Une file où les premiers éléments ajoutés sont les premiers retirés.

struct file {
	taille_elem : z64
	taille : z64
	capacité : z64
	tampon : []octet
}

fonc crée_file(taille_elem : z64) -> *file
{
	dyn q := loge file
	q.taille_elem = taille_elem
	retourne q
}

fonc decrée_file(dyn q : *file) -> rien
{
	q.taille_elem = 0
	q.taille = 0
	q.capacité = 0
	déloge q.tampon
	déloge q
}

fonc enfile(dyn q : *file, d : *rien) -> rien
{
    si q.taille == q.capacité {
		reloge q.tampon : [(q.taille + 1) * q.taille_elem]octet
		q.capacité += 1
    }

	ptr := @q.tampon[q.taille * q.taille_elem]
	copie_mem_nonsur(d, ptr, q.taille_elem)

	q.taille += 1
}

fonc est_vide(q : *file) -> bool
{
	retourne q.taille == 0
}

fonc défile(dyn q : *file, d : *rien) -> rien
{
    si est_vide(q) {
		retourne
    }

    si d != nul {
		ptr := @q.tampon[0]
		copie_mem_nonsur(ptr, d, q.taille_elem)
    }

    // réajuste la file en décalant les données

    si q.taille > 1 {
		ptr_dst := @q.tampon[0]
		ptr_src := @q.tampon[q.taille_elem]
		copie_mem_nonsur(ptr_src, ptr_dst, q.taille_elem * (q.taille - 1))
    }

	q.taille -= 1
}

//################################################################

// Une tableau où les données sont stockées de manière séquentielle.

struct tableau {
	taille_elem : z64
	taille : z64
	capacité : z64
	tampon : []octet
}

fonc crée_tableau(taille_elem : z64) -> *tableau
{
	dyn t := loge tableau
	t.taille_elem = taille_elem
	retourne t
}

fonc decrée_tableau(dyn t : *tableau) -> rien
{
	t.taille_elem = 0
	t.taille = 0
	t.capacité = 0
	déloge t.tampon
	déloge t
}

fonc pousse_tableau(dyn t : *tableau, d : *rien) -> rien
{
    si t.taille == t.capacité {
		reloge t.tampon : [(t.taille + 1) * t.taille_elem]octet
		t.capacité += 1
    }

	ptr := @t.tampon[t.taille * t.taille_elem]
	copie_mem_nonsur(d, ptr, t.taille_elem)

	t.taille += 1
}

fonc est_vide(t : *tableau) -> bool
{
	retourne t.taille == 0
}

fonc début_tableau(t : *tableau) -> *rien
{
    si est_vide(t) {
		retourne nul
    }

	ptr := @t.tampon[0]
	retourne transtype(ptr : *rien)
}

fonc fin_tableau(t : *tableau) -> *rien
{
    si est_vide(t) {
		retourne nul
    }

    // NOTE : contrairement à C++, nous ne retournons pas un pointeur après la fin,
    // mais la fin elle-même car les boucles utilisant des plages vont jusqu'au dernier
    // élément (<=)
	ptr := @t.tampon[(t.taille - 1) * t.taille_elem]
	retourne transtype(ptr : *rien)
}
