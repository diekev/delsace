//###############################################################################
// Implémentation d'une table de hachage chaine -> chaine
// Voir aussi, comme inspiration :
// https://en.wikipedia.org/wiki/Open_addressing

charge "chaine"
charge "impression"

struct NoeudTableHachage {
    clé : chaine
    valeur : chaine
    suivant : *NoeudTableHachage
}

struct TableHachage {
    alvéoles : []*NoeudTableHachage
}

fonc crée_table_hachage() -> *TableHachage
{
    dyn table := loge TableHachage
    table.alvéoles = loge [10000]*NoeudTableHachage

    pour i dans 0 ... 9999 {
        table.alvéoles[i] = nul
    }

    retourne table
}

fonc décrée_table_hachage(table : *TableHachage) -> rien
{
    pour noeud dans table.alvéoles {
        dyn n := noeud;

        tantque n != nul {
            dyn ns := n.suivant
            déloge n
            n = ns
        }
    }

    déloge table.alvéoles
    déloge table
}

fonc crée_noeud(clé : chaine, valeur : chaine) -> *NoeudTableHachage
{
    dyn n := loge NoeudTableHachage
    n.clé = clé
    n.valeur = valeur
    n.suivant = nul
    retourne n
}

fonc calcule_empreinte(chn : chaine) -> n64
{
    dyn empreinte := transtype(5381 : n64)

    pour c dans chn {
        empreinte = ((empreinte << transtype(5 : n64)) + empreinte) + transtype(c : n64)
    }

	retourne empreinte
}

fonc insère(dyn table : *TableHachage, clé : chaine, valeur : chaine) -> rien
{
    empreinte := calcule_empreinte(clé) % transtype(10000 : n64)

    dyn alvéole := table.alvéoles[empreinte]

    si alvéole == nul {
        table.alvéoles[empreinte] = crée_noeud(clé, valeur)
        retourne
    }

    boucle {
        si alvéole.suivant == nul {
            alvéole.suivant = crée_noeud(clé, valeur)
            arrête
        }

        alvéole = alvéole.suivant
    }
}

fonc trouve(table : *TableHachage, clé : chaine) -> *NoeudTableHachage
{
    empreinte := calcule_empreinte(clé) % transtype(10000 : n64)

    dyn alvéole := table.alvéoles[empreinte]

    si alvéole == nul {
        retourne nul
    }

    boucle {
        si alvéole.clé == clé {
            retourne alvéole
        }

        si alvéole.suivant == nul {
            arrête
        }

        alvéole = alvéole.suivant
    }

    retourne nul
}

fonc cherche_noeud(table : *TableHachage, clé : chaine) -> rien
{
    n := trouve(table, clé)

    si n == nul {
        imprime_sans_format("Impossible de trouver le noeud dans la table !\n")
    }
    sinon {
        imprime_sans_format("Trouvé noeud, valeur : ", n.valeur, "\n")
    }
}

corout chaque_noeud(table : *TableHachage) -> *NoeudTableHachage
{
    pour alvéole dans table.alvéoles {
        dyn n := alvéole

        tantque n != nul {
            retiens n
            n = n.suivant
        }
    }
}
