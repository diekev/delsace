################################################################################

#!inclus "dirent.h"
#!inclus "sys/stat.h"
#!inclus "fcntl.h"
#!inclus "unistd.h"

fonc externe open(chemin : *z8, drapeaux : z32) : z32
fonc externe close(fd : z32) : rien
fonc externe read(fd : z32, tampon : *z8, taille : n64) : z64
fonc externe write(fd : z32, tampon : *z8, taille : z64) : z32
fonc externe stat(chemin : *z8, buf : *rien) : z32

fonc externe getcwd(ptr : *z8, taille : z64) : rien
fonc externe chdir(ptr : *z8) : rien

fonc externe rename(orig : *z8, dest : *z8) : z32;
fonc externe remove(chemin : *z8) : z32;

# Ceci sont des macros
fonc externe S_ISREG(mode : n32) : bool
fonc externe S_ISDIR(mode : n32) : bool
fonc externe S_IFSOCK(mode : n32) : bool
fonc externe S_IFLNK(mode : n32) : bool
fonc externe S_IFBLK(mode : n32) : bool
fonc externe S_IFCHR(mode : n32) : bool
fonc externe S_IFIFO(mode : n32) : bool

# Version 64-bit de la structure 'stat' de "sys/stat.h"
struct externe stat {
    st_dev : n64         # ID of device containing file
	st_ino : n64         # inode number
	st_nlink : n64     # number of hard links
	st_mode : n32       # protection
	st_uid : n32         # user ID of owner
	st_gid : n32         # group ID of owner
	__pad0 : n32         # padding pour la version 64-bit
	st_rdev : n64        # device ID (if special file)
	st_size : z64        # total size, in bytes
	st_blksize : z64 # blocksize for file system I/O
	st_blocks : z64
	st_atime : z64      # time of last access
	st_mtime : z64      # time of last modification
	st_ctime : z64      # time of last status change
}

struct externe DIR;

struct externe dirent {
    d_ino : n64
    d_off : n64
    d_reclen : n16
    d_type : n8
    d_name : *z8
};

# duplique un énum
soit _DT_UNKNOWN = 0
soit _DT_FIFO = 1
soit _DT_CHR = 2
soit _DT_DIR = 4
soit _DT_BLK = 6
soit _DT_REG = 8
soit _DT_LNK = 10
soit _DT_SOCK = 12
soit _DT_WHT = 14

# open/fnctl
soit MODE_ACCÈS       =      0003
soit LECTURE_SEULE    =        00
soit ÉCRITURE_SEULE   =        01
soit LECTURE_ÉCRITURE =        02
soit CREATION         =      0100
soit EXCLUSION        =      0200
soit NOCTTY           =      0400
soit TRONCAGE         =     01000
soit APPEND           =     02000
soit NONBLOCK         =     04000
soit NDELAY           =     04000
soit SYNC             =  04010000
soit FSYNC            =  04010000
soit ASYNC            =    020000
soit LARGEFILE        =   0100000
soit DIRECTORY	      =   0200000
soit NOFOLLOW	      =   0400000
soit CLOEXEC          =  02000000
soit DIRECT	          =    040000
soit NOATIME          =  01000000
soit PATH             = 010000000
soit DSYNC	          =    010000
soit TMPFILE          = (020000000 | 0200000)

fonc externe opendir(chemin : *z8) : *DIR
fonc externe closedir(d : *DIR) : z32
fonc externe readdir(d : *DIR) : *dirent

################################################################################

importe "chaine"
importe "flux"
importe "memoire"

struct CheminFichier {
    chn : chaine
}

fonc construit_chemin(chn : chaine) : CheminFichier
{
    chemin = CheminFichier{ chn = chn }
    retourne chemin
}

struct Fichier {
    chemin : CheminFichier
    fd : z32
}

fonc obtiens_stmode(chemin : &CheminFichier) : n32
{
    dyn tampon : [1024]z8
	ptr_chemin = copie_chaine_c_tampon(tampon, chemin.chn)

	dyn st : stat
	soit ok = stat(ptr_chemin, @st)

	si ok == -1 {
		retourne -1
	}

	retourne st.st_mode
}

fonc fichier_existe(chemin : &CheminFichier) : bool
{
    retourne obtiens_stmode(chemin) != -1
}

fonc est_dossier(chemin : &CheminFichier) : bool
{
    mode = obtiens_stmode(chemin)

	si mode == -1 {
		retourne faux
	}

    retourne S_ISDIR(mode)
}

fonc est_fichier_régulier(chemin : &CheminFichier) : bool
{
    mode = obtiens_stmode(chemin)

	si mode == -1 {
		retourne faux
	}

    retourne S_ISREG(mode)
}

fonc est_prise(chemin : &CheminFichier) : bool
{
    mode = obtiens_stmode(chemin)

	si mode == -1 {
		retourne faux
	}

    retourne S_IFSOCK(mode)
}

fonc est_lien_symbolique(chemin : &CheminFichier) : bool
{
    mode = obtiens_stmode(chemin)

	si mode == -1 {
		retourne faux
	}

    retourne S_IFLNK(mode)
}

fonc est_fichier_périphérique(chemin : &CheminFichier) : bool
{
    mode = obtiens_stmode(chemin)

	si mode == -1 {
		retourne faux
	}

    retourne S_IFBLK(mode)
}

fonc est_fichier_caractère(chemin : &CheminFichier) : bool
{
    mode = obtiens_stmode(chemin)

	si mode == -1 {
		retourne faux
	}

    retourne S_IFCHR(mode)
}

fonc est_pipe(chemin : &CheminFichier) : bool
{
    mode = obtiens_stmode(chemin)

	si mode == -1 {
		retourne faux
	}

    retourne S_IFIFO(mode)
}

fonc ouvre_fichier(chemin : &CheminFichier) : z32
{
	si !fichier_existe(chemin) {
		retourne -1
	}

	dyn tampon : [1024]z8
	ptr_chemin = copie_chaine_c_tampon(tampon, chemin.chn)

	retourne open(ptr_chemin, LECTURE_SEULE)
}

fonc ouvre_fichier_ecriture(chemin : &CheminFichier) : z32
{
	dyn tampon : [1024]z8
	ptr_chemin = copie_chaine_c_tampon(tampon, chemin.chn)

	retourne open(ptr_chemin, CREATION | ÉCRITURE_SEULE)
}

fonc ferme_fichier(desc : z32) : rien
{
	si desc != -1 {
		close(desc)
	}
}

fonc contenu_fichier_binaire(chemin : &CheminFichier) : []octet
{
    dyn contenu : []octet

    dyn ret : chaine

	soit fd = ouvre_fichier(chemin)
	diffère { ferme_fichier(fd) }

	si fd == -1 {
		retourne contenu
	}

	dyn tampon : [1024]z8

    boucle {
	    # À FAIRE : prend pointeur automatiquement
		dyn lu = read(fd, @tampon[0], 1024)

		si lu == 0 {
			arrête
		}

		si lu == -1 {
			# À FAIRE : erreur
			déloge ret
			arrête
		}

		soit taille_courante = taille de ret

		reloge contenu : [taille de ret + lu]octet

		dyn src = @tampon[0]
		dyn dst = @contenu[taille_courante]

		copie_mem_nonsur(src=src, dst=dst, taille=lu)
	}

    retourne contenu
}

fonc contenu_fichier_texte(chemin : &CheminFichier) : chaine
{
    contenu = contenu_fichier_binaire(chemin)
    dyn chn : chaine;

    nonsûr {
        # À FAIRE : prépasse pour les accès membres
        ptr = contenu.pointeur
        chn.pointeur = transtype(ptr : *z8)
        # À FAIRE : cohérence des types de taille
        taille = contenu.taille
        chn.taille = transtype(taille : z64)
    }

    retourne chn
}

fonc écris_fichier(fd : z32, contenu : chaine) : rien
{
    write(fd, contenu.pointeur, contenu.taille)
}

fonc ouvre_dossier(chemin : &CheminFichier) : *DIR
{
    dyn tampon : [1024]z8
	ptr_chemin = copie_chaine_c_tampon(tampon, chemin.chn)

    retourne opendir(ptr_chemin)
}

fonc chemin_pour_dirname(dir : *dirent) : CheminFichier
{
    taille = taille_chaine_c(dir.d_name)
    chn = construit_chaine(dir.d_name, taille)

    retourne construit_chemin(chn)
}

corout chaque_chemin(chemin : &CheminFichier) : CheminFichier
{
    si !est_dossier(chemin) {
        retourne
    }

    dyn d = ouvre_dossier(chemin)

    si d == nul {
        retourne
    }

    boucle {
        dir = readdir(d)

        si dir == nul {
            arrête
        }

        retiens chemin_pour_dirname(dir)
    }

    closedir(d)
}

################################################################################

# File spécialisé pour les DIR.
struct FileDir {
	taille : z64
	capacité : z64
	tampon : []*DIR
}

fonc crée_file_dir() : *FileDir
{
	dyn q = loge FileDir
	retourne q
}

fonc decrée_file(dyn q : *FileDir) : rien
{
	taille de q = 0
	capacité de q = 0
	déloge tampon de q
	déloge q
}

fonc enfile(dyn q : *FileDir, d : *DIR) : rien
{
    si taille de q == capacité de q {
		reloge tampon de q : [(taille de q + 1)]*DIR
		capacité de q += 1
    }

	q.tampon[taille de q] = d
	taille de q += 1
}

fonc est_vide(q : *FileDir) : bool
{
	retourne taille de q == 0
}

fonc défile(dyn q : *FileDir) : *DIR
{
    si est_vide(q) {
		retourne nul
    }

    ret = q.tampon[0]
	taille de q -= 1

    pour i dans 1 ... transtype(taille de q - 1 : z32) {
        q.tampon[i - 1] = q.tampon[i]
    }

    retourne ret
}

################################################################################

fonc enfile_dossier(file : *FileDir, dir : *dirent) : rien
{
    chm = chemin_pour_dirname(dir)

    si compare_chaines(chm.chn, ".") {
        retourne
    }

    si compare_chaines(chm.chn, "..") {
        retourne
    }

    nd = ouvre_dossier(chm)

    si nd == nul {
        retourne
    }

    #imprime("enfile ", nd, '\n')
    enfile(file, nd)
}

# À FAIRE : il y a un crash, il semblerait que des dossiers soit ajoutés en double dans la file
corout chaque_chemin_récursif(chemin : &CheminFichier) : CheminFichier
{
    si !est_dossier(chemin) {
        imprime("Le chemin n'est pas un dossier")
        retourne
    }

    dyn d = ouvre_dossier(chemin)

    si d == nul {
        retourne
    }

    file = crée_file_dir()

    enfile(file, d)

    tantque !est_vide(file) {
        d = défile(file)

        si d == nul {
            arrête
        }

        #imprime("défile ", d, " (", taille de file, ")", '\n')

        boucle {
            dir = readdir(d)

            si dir == nul {
                #imprime("fin dossier\n")
                arrête
            }

            si dir.d_type == _DT_DIR {
                enfile_dossier(file, dir)
            }

            retiens chemin_pour_dirname(dir)
        }

        closedir(d)
    }

    decrée_file(file)
}

################################################################################

fonc chemin_courant() : CheminFichier
{
    dyn ret = loge chaine(1024)
    getcwd(ret.pointeur, ret.taille)
    retourne construit_chemin(ret)
}

fonc chemin_courant(chemin : CheminFichier) : rien
{
    dyn tampon : [1024]z8
	ptr_chemin = copie_chaine_c_tampon(tampon, chemin.chn)
    chdir(ptr_chemin)
}

# À FAIRE : créer fichier, dossier (récurisevement), mettre à la corbeille, trouver le chemin vers HOME/TMP, copier, opérations sur les chemins

################################################################################

fonc renomme(orig : &CheminFichier, dest : &CheminFichier) : z32
{
    dyn tampon_orig : [1024]z8
	ptr_chemin_orig = copie_chaine_c_tampon(tampon_orig, orig.chn)

    dyn tampon_dest : [1024]z8
	ptr_chemin_dest = copie_chaine_c_tampon(tampon_dest, dest.chn)

	retourne rename(ptr_chemin_orig, ptr_chemin_dest)
}

fonc supprime(chm : &CheminFichier) : z32
{
    dyn tampon : [1024]z8
	ptr_chemin = copie_chaine_c_tampon(tampon, chm.chn)
    retourne remove(ptr_chemin)
}

