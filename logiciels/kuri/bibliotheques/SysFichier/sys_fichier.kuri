importe Fondation
importe GlibC

CheminFichier :: struct {
    chn : chaine
}

construit_chemin :: fonc(chn : chaine) -> CheminFichier
{
    chemin := CheminFichier{ chn = chn }
    retourne chemin
}

Fichier :: struct {
    chemin : CheminFichier
    fd : z32
}

obtiens_stmode :: fonc(chemin : &CheminFichier) -> n32
{
    dyn tampon : [1024]z8
	ptr_chemin := copie_chaine_c_tampon(tampon, chemin.chn)

	dyn st : stat
	ok := stat(ptr_chemin, @st)

	si ok == -1 {
		retourne transtype(0xffffffff: n32)
	}

	retourne st.st_mode
}

fichier_existe :: fonc(chemin : &CheminFichier) -> bool
{
    retourne obtiens_stmode(chemin) != transtype(0xffffffff: n32)
}

est_dossier :: fonc(chemin : &CheminFichier) -> bool
{
    mode := obtiens_stmode(chemin)

	si mode == transtype(0xffffffff: n32) {
		retourne faux
	}

    retourne S_ISDIR(mode)
}

est_fichier_régulier :: fonc(chemin : &CheminFichier) -> bool
{
    mode := obtiens_stmode(chemin)

	si mode == transtype(0xffffffff: n32) {
		retourne faux
	}

    retourne S_ISREG(mode)
}

est_prise :: fonc(chemin : &CheminFichier) -> bool
{
    mode := obtiens_stmode(chemin)

	si mode == transtype(0xffffffff: n32) {
		retourne faux
	}

    retourne S_IFSOCK(mode)
}

est_lien_symbolique :: fonc(chemin : &CheminFichier) -> bool
{
    mode := obtiens_stmode(chemin)

	si mode == transtype(0xffffffff: n32) {
		retourne faux
	}

    retourne S_IFLNK(mode)
}

est_fichier_périphérique :: fonc(chemin : &CheminFichier) -> bool
{
    mode := obtiens_stmode(chemin)

	si mode == transtype(0xffffffff: n32) {
		retourne faux
	}

    retourne S_IFBLK(mode)
}

est_fichier_caractère :: fonc(chemin : &CheminFichier) -> bool
{
    mode := obtiens_stmode(chemin)

	si mode == transtype(0xffffffff: n32) {
		retourne faux
	}

    retourne S_IFCHR(mode)
}

est_pipe :: fonc(chemin : &CheminFichier) -> bool
{
    mode := obtiens_stmode(chemin)

	si mode == transtype(0xffffffff: n32) {
		retourne faux
	}

    retourne S_IFIFO(mode)
}

ouvre_fichier :: fonc(chemin : &CheminFichier) -> z32
{
	si !fichier_existe(chemin) {
		retourne -1
	}

	dyn tampon : [1024]z8
	ptr_chemin := copie_chaine_c_tampon(tampon, chemin.chn)

	retourne open(ptr_chemin, LECTURE_SEULE)
}

ouvre_fichier_ecriture :: fonc(chemin : &CheminFichier) -> z32
{
	dyn tampon : [1024]z8
	ptr_chemin := copie_chaine_c_tampon(tampon, chemin.chn)

	retourne open(ptr_chemin, CREATION | ÉCRITURE_SEULE, 0o777)
}

ferme_fichier :: fonc(desc : z32) -> rien
{
	si desc != -1 {
		close(desc)
	}
}

contenu_fichier_binaire :: fonc(chemin : &CheminFichier) -> []octet
{
    dyn contenu : []octet

	fd := ouvre_fichier(chemin)
	diffère { ferme_fichier(fd) }

	si fd == -1 {
		retourne contenu
	}

	dyn tampon : [1024]z8

    boucle {
	    // À FAIRE : prend pointeur automatiquement
		dyn lu := read(fd, @tampon[0], transtype(1024: n64))

		si lu == 0 {
			arrête
		}

		si lu == -1 {
			// À FAIRE : erreur
			déloge contenu
			arrête
		}

		taille_courante := contenu.taille

		reloge contenu : [taille_courante + lu]octet

		dyn src := @tampon[0]
		dyn dst := @contenu[taille_courante]

		copie_mem_nonsur(src=src, dst=dst, taille=lu)
	}

    retourne contenu
}

contenu_fichier_texte :: fonc(chemin : &CheminFichier) -> chaine
{
    contenu := contenu_fichier_binaire(chemin)
    dyn chn : chaine;

    nonsûr {
        chn.pointeur = transtype(contenu.pointeur : *z8)
        chn.taille = contenu.taille
    }

    retourne chn
}

écris_fichier :: fonc(fd : z32, contenu : chaine) -> rien
{
    write(fd, contenu.pointeur, contenu.taille)
}

ouvre_dossier :: fonc(chemin : &CheminFichier) -> *DIR
{
    dyn tampon : [1024]z8
	ptr_chemin := copie_chaine_c_tampon(tampon, chemin.chn)

    retourne opendir(ptr_chemin)
}

chemin_pour_dirname :: fonc(dir : *dirent) -> CheminFichier
{
    taille := taille_chaine_c(dir.d_name)
    chn := construit_chaine(dir.d_name, taille)

    retourne construit_chemin(chn)
}

chaque_chemin :: corout(chemin : &CheminFichier) -> CheminFichier
{
    si !est_dossier(chemin) {
        retourne
    }

    dyn d := ouvre_dossier(chemin)

    si d == nul {
        retourne
    }

    boucle {
        dir := readdir(d)

        si dir == nul {
            arrête
        }

        retiens chemin_pour_dirname(dir)
    }

    closedir(d)
}

//###############################################################################

// File spécialisé pour les DIR.
FileDir :: struct {
	taille : z64
	capacité : z64
	tampon : []*DIR
}

crée_file_dir :: fonc() -> *FileDir
{
	dyn q := loge FileDir
	retourne q
}

decrée_file :: fonc(dyn q : *FileDir) -> rien
{
	q.taille = 0
	q.capacité = 0
	déloge q.tampon
	déloge q
}

enfile :: fonc(dyn q : *FileDir, d : *DIR) -> rien
{
    si q.taille == q.capacité {
		reloge q.tampon : [(q.taille + 1)]*DIR
		q.capacité += 1
    }

	q.tampon[q.taille] = d
	q.taille += 1
}

est_vide :: fonc(q : *FileDir) -> bool
{
	retourne q.taille == 0
}

défile :: fonc(dyn q : *FileDir) -> *DIR
{
    si est_vide(q) {
		retourne nul
    }

    ret := q.tampon[0]
	q.taille -= 1

    pour i dans 1 ... transtype(q.taille - 1 : z32) {
        q.tampon[i - 1] = q.tampon[i]
    }

    retourne ret
}

//###############################################################################

enfile_dossier :: fonc(file : *FileDir, dir : *dirent, chemin : &CheminFichier) -> rien
{
    dyn chm := chemin_pour_dirname(dir)

    si chm.chn == "." {
        retourne
    }

    si chm.chn == ".." {
        retourne
    }

    // Trouve le chemin absolu.
    dyn chn : chaine
    diffère { déloge chn; }

    si chemin.chn[chemin.chn.taille - 1] != '/' {
        chn = enchaine(chemin.chn, "/", chm.chn)
    }
    sinon {
        chn = enchaine(chemin.chn, chm.chn)
    }

    chm.chn = chn

    nd := ouvre_dossier(chm)

    si nd == nul {
        retourne
    }

    enfile(file, nd)
}

chaque_chemin_récursif :: corout(chemin : &CheminFichier) -> CheminFichier
{
    si !est_dossier(chemin) {
        imprime_sans_format("Le chemin n'est pas un dossier")
        retourne
    }

    dyn d := ouvre_dossier(chemin)

    si d == nul {
        retourne
    }

    file := crée_file_dir()

    enfile(file, d)

    tantque !est_vide(file) {
        d := défile(file)

        boucle {
            dir := readdir(d)

            si dir == nul {
                arrête
            }

            si dir.d_type == _DT_DIR {
                enfile_dossier(file, dir, chemin)
            }

            retiens chemin_pour_dirname(dir)
        }

        closedir(d)
    }

    decrée_file(file)
}

//###############################################################################

chemin_courant :: fonc() -> CheminFichier
{
    dyn ret := loge chaine(1024)
    getcwd(ret.pointeur, ret.taille)
    retourne construit_chemin(ret)
}

chemin_courant :: fonc(chemin : CheminFichier) -> rien
{
    dyn tampon : [1024]z8
	ptr_chemin := copie_chaine_c_tampon(tampon, chemin.chn)
    chdir(ptr_chemin)
}

// À FAIRE : créer fichier, dossier (récurisevement), mettre à la corbeille, trouver le chemin vers HOME/TMP, copier, opérations sur les chemins

//###############################################################################

renomme :: fonc(orig : &CheminFichier, dest : &CheminFichier) -> z32
{
    dyn tampon_orig : [1024]z8
	ptr_chemin_orig := copie_chaine_c_tampon(tampon_orig, orig.chn)

    dyn tampon_dest : [1024]z8
	ptr_chemin_dest := copie_chaine_c_tampon(tampon_dest, dest.chn)

	retourne rename(ptr_chemin_orig, ptr_chemin_dest)
}

supprime :: fonc(chm : &CheminFichier) -> z32
{
    dyn tampon : [1024]z8
	ptr_chemin := copie_chaine_c_tampon(tampon, chm.chn)
    retourne remove(ptr_chemin)
}

