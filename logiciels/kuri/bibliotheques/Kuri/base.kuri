charge "infos_types"

// Ce fichier est utiliser pour définir des variables et fonctions de
// bases (« connus par le compilateur ») que tous les modules doivent importer.
// Ceci nous évite d'avoir à manuellement spécifier ces choses dans le
// code du compilateur.
// Par contre, ce fichier ne devrait pas pouvoir être modifié par les
// utilisateurs du langage.

// Tenant trace de la mémoire utilisée par le programme, cette variable est
// augmentée par le compilateur à chaque instruction « loge » ou « reloge »,
// et diminuée à chaque « déloge ».
dyn __VG_memoire_utilisee__ : z64 = 0

// Contient trace de la quantité maximale de mémoire consomée.
dyn __VG_memoire_consommee__ : z64 = 0

// Contient le nombre de fois que « loge » et « reloge » ont été appelés.
dyn __VG_nombre_allocations__ : z64 = 0

// Contient le nombre de fois que « reloge » a été appelé.
dyn __VG_nombre_reallocations__ : z64 = 0

// Contient le nombre de fois que « déloge » a été appelé.
dyn __VG_nombre_deallocations__ : z64 = 0

ModeAllocatrice :: énum z32 {
    ALLOUE
    RÉALLOUE
    DÉSALLOUE
}

malloc :: fonc externe (taille : z64) -> *rien
realloc :: fonc externe (ptr : *rien, taille : z64) -> *rien
free :: fonc externe (ptr : *rien) -> rien

allocatrice_défaut :: fonc(
    mode : ModeAllocatrice,
    nouvelle_taille : z64,
    ancienne_taille : z64,
    ancien_pointeur : *rien,
    données : *rien,
    info : *InfoType) -> *rien
{
    discr mode {
        ALLOUE {
            // À FAIRE: crash lors de l'exécution quand ce code est activé
            //nonsûr {
            //    __VG_memoire_utilisee__ = __VG_memoire_utilisee__ + nouvelle_taille

            //    si __VG_memoire_consommee__ < __VG_memoire_utilisee__ {
            //        __VG_memoire_consommee__ = __VG_memoire_utilisee__
            //    }

            //    __VG_nombre_allocations__ = __VG_nombre_allocations__ + 1
            //}

            retourne malloc(nouvelle_taille)
        }
        RÉALLOUE {
            // À FAIRE: crash lors de l'exécution quand ce code est activé
            //nonsûr {
            //    __VG_memoire_utilisee__ = __VG_memoire_utilisee__ + nouvelle_taille - ancienne_taille

            //    si __VG_memoire_consommee__ < __VG_memoire_utilisee__ {
            //        __VG_memoire_consommee__ = __VG_memoire_utilisee__
            //    }

            //    __VG_nombre_allocations__ = __VG_nombre_allocations__ + 1
            //    __VG_nombre_reallocations__ = __VG_nombre_allocations__ + 1
            //}

            retourne realloc(ancien_pointeur, nouvelle_taille)
        }
        DÉSALLOUE {
            // À FAIRE: crash lors de l'exécution quand ce code est activé
            //nonsûr {
            //    __VG_memoire_utilisee__ = __VG_memoire_utilisee__ - ancienne_taille
            //    __VG_nombre_deallocations__ = __VG_nombre_allocations__ + 1
            //}

            free(ancien_pointeur)
            retourne nul
        }
    }

    retourne nul
}

// Le StockageTemporaire est un stockage mis en place par le compilateur, qui réserve
// une certaine taille dans l'exécutable où mettre des données temporaire.
// À FAIRE : option de compilation pour définir la taille du stockage temporaire
// on attendra que la métoprogrammation soit ici pour passer les options par celle-ci
StockageTemporaire :: struct {
    données : *octet
    taille : z32
    occupé : z32
    occupation_maximale : z32
}

// Structure passée implicitement à toutes les fonctions non marquées par #!nulctx.
// À FAIRE : permettre aux utilisateurs du langage d'ajouter des variables dans
// cette structure.
ContexteProgramme :: struct {
    allocatrice := allocatrice_défaut
    données_allocatrice : *rien = nul

    stockage_temporaire : *StockageTemporaire
}

// ----------------------------
// Implémentation des fonctions du stockage temporaire

obtiens_marque_stockage_temporaire :: fonc () -> z32
{
    retourne contexte.stockage_temporaire.occupé
}

set_marque_stockage_temporaire :: fonc (marque: z32) -> rien
{
    // À FAIRE(assert)
    // assert(marque >= 0)
    // assert(marque < contexte.stockage_temporaire.taille)
    contexte.stockage_temporaire.occupé = marque
}

réinitialise_stockage_temporaire :: fonc () -> rien
{
    set_marque_stockage_temporaire(0)
    contexte.stockage_temporaire.occupation_maximale = 0
}

alloc_stockage_temporaire :: fonc (dyn alloc: *StockageTemporaire, nouvelle_taille: z64) -> *rien
{
    si alloc.occupé + nouvelle_taille > alloc.taille {
        // À FAIRE : utilisation de l'allocatrice par défaut
        retourne nul
    }

    ptr := alloc.données + alloc.occupé
    alloc.occupé += nouvelle_taille

    si alloc.occupé > alloc.occupation_maximale {
        alloc.occupation_maximale = alloc.occupé
    }

    retourne ptr
}

__stockage_temporaire :: fonc(
    mode : ModeAllocatrice,
    nouvelle_taille : z64,
    ancienne_taille : z64,
    ancien_pointeur : *rien,
    données : *rien,
    info : *InfoType) -> *rien
{
    dyn alloc := contexte.stockage_temporaire

    discr mode {
        ALLOUE {
            retourne alloc_stockage_temporaire(alloc, nouvelle_taille)
        }
        RÉALLOUE {
            ptr := transtype(ancien_pointeur: *octet)

            si ptr == nul {
                retourne alloc_stockage_temporaire(alloc, nouvelle_taille)
            }

            delta := nouvelle_taille - ancienne_taille

            // À FAIRE
            // Nous ne pouvons réallouer que si le pointeur fut le dernier alloué...
            /*
            dyn n := ancienne_taille

            si ptr + n != alloc.ptr {
                retourne nul
            }

            // ... et qu'il y a suffisament de place pour delta

            n = delta  // arrondis_pour_aligner(delta, 8)

            d := transtype(alloc.ptr: z64)
            f := transtype(alloc.début + alloc.données.taille: z64)

            si n > (f - d) {
                retourne nul
            }

		    alloc.ptr += n
            */

            alloc.occupé += delta

            si alloc.occupé > alloc.occupation_maximale {
                alloc.occupation_maximale = alloc.occupé
            }

            retourne ancien_pointeur
        }
        DÉSALLOUE {
            // À FAIRE
            alloc.occupé -= ancienne_taille
            retourne nul
        }
    }

    retourne nul
}

// fonction de convénience pour loge un tampon dans le stockage temporaire
// principalement utilisé pour loger des chaines avec une terminaison nulle
// afin de pouvoir les passer aux fonctions de C
logement_temp :: fonc(taille: z64) -> *octet
{
    dyn nouveau_contexte := contexte
    nouveau_contexte.allocatrice = __stockage_temporaire

    dyn ptr : *octet

    pousse_contexte nouveau_contexte {
        tmp := loge [taille]octet
        ptr = tmp.pointeur
    }

    retourne ptr
}

// Fonction pour accéder à la variable __VG_memoire_utilisee__.
mémoire_utilisée :: fonc() -> z64
{
    retourne __VG_memoire_utilisee__
}

// Fonction pour accéder à la variable __VG_memoire_utilisee__.
mémoire_consommée :: fonc() -> z64
{
    retourne __VG_memoire_consommee__
}

// Fonction pour accéder à la variable __VG_nombre_allocations__.
nombre_allocations :: fonc() -> z64
{
    retourne __VG_nombre_allocations__
}

// Fonction pour accéder à la variable __VG_nombre_reallocations__.
nombre_réallocations :: fonc() -> z64
{
    retourne __VG_nombre_reallocations__
}

// Fonction pour accéder à la variable __VG_nombre_deallocations__.
nombre_déallocations :: fonc() -> z64
{
    retourne __VG_nombre_deallocations__
}

// Fonctions de bases pour les opérateurs de comparaisons de chaines
sont_chaines_égales :: fonc(chn1: chaine, chn2: chaine) -> bool
{
    si chn1.taille != chn2.taille {
		retourne faux
    }

	taille := chn1.taille
	début : z64 = 0

    pour i dans début...(taille - 1) {
        si chn1[i] != chn2[i] {
			retourne faux
        }
    }

	retourne vrai
}

sont_chaines_inégales :: fonc(chn1: chaine, chn2: chaine) -> bool
{
    retourne !sont_chaines_égales(chn1, chn2)
}

// Fonctions basiques pour les tableaux

tableau_ajoute :: fonc (dyn tabl: *[]$T, valeur: $T) -> rien
{
    dyn tmp := mémoire(tabl)

    taille := tmp.taille
    reloge tmp: [taille + 1]$T
    tmp[taille] = valeur

    mémoire(tabl) = tmp
}

tableau_réserve :: fonc(dyn tabl: *[]$T, taille: z64) -> rien
{
    si taille <= tabl.taille {
        retourne
    }

	dyn tmp := mémoire(tabl)

	reloge tmp : [taille]$T

	mémoire(tabl) = tmp
}

tableau_copie :: fonc(dyn tabl: []$T) -> []$T
{
	dyn tmp := loge [tabl.taille]$T
    copie_mem_nonsur(src = tabl.pointeur, dst = tabl.pointeur, taille = tabl.taille * transtype(taille_de(z64): z64))
    retourne tmp
}

tableau_insère :: fonc(dyn tabl: *[]$T, index: z32, valeur: $T) -> rien
{
	dyn tmp := mémoire(tabl)
	tmp[index] = valeur
	mémoire(tabl) = tmp
}

tableau_supprime :: fonc(dyn tabl: *[]$T, index: z32) -> rien
{
	si index < 0 || index >= tabl.taille {
		retourne
	}

	dyn tmp := mémoire(tabl)

	taille := tabl.taille

	pour i dans transtype(index: z64) ... taille - 2 {
		tmp[i] = tmp[i + 1]
	}

	reloge tmp : [taille - 1]$T

	mémoire(tabl) = tmp
}
