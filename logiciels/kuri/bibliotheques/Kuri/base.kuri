charge "infos_types"

malloc :: fonc externe (taille : z64) -> *rien
realloc :: fonc externe (ptr : *rien, taille : z64) -> *rien
free :: fonc externe (ptr : *rien) -> rien

// Ce fichier est utiliser pour définir des variables et fonctions de
// bases (« connus par le compilateur ») que tous les modules doivent importer.
// Ceci nous évite d'avoir à manuellement spécifier ces choses dans le
// code du compilateur.
// Par contre, ce fichier ne devrait pas pouvoir être modifié par les
// utilisateurs du langage.

// --------------------------

// Position dans le code source. Quand cette structure est instantiée, le
// compilateur remplis les membres de cette structure avec les valeurs
// correspondantes de la position du lexème dans le fichier où se fait ladite
// construction.
PositionCodeSource :: struct {
    // le nom du fichier où se trouve l'objet
    fichier : chaine
    // le nom de la fonction où se trouve l'objet, vide si variable globale
    fonction : chaine
    // la ligne où se trouve l'objet
    ligne : z32
    // la colonne où se trouve l'objet
    colonne : z32
}

// --------------------------

ModeAllocatrice :: énum z32 {
    ALLOUE
    RÉALLOUE
    DÉSALLOUE
}

BaseAllocatrice :: struct {
    nombre_allocations : z64 = 0
    nombre_réallocations : z64 = 0
    nombre_désallocations : z64 = 0
    mémoire_utilisée : z64 = 0
    pic_de_mémoire : z64 = 0

    // pour pouvoir déterminer quelle type d'allocatrice nous avons
    infos : *InfoTypeStructure = nul

    allocatrice_parente : *BaseAllocatrice = nul
    allocatrice_secours : *BaseAllocatrice = nul
}

initialise_base_allocatrice :: fonc (dyn base : *BaseAllocatrice) -> rien
{
    base.nombre_allocations = 0
    base.nombre_réallocations = 0
    base.nombre_désallocations = 0
    base.mémoire_utilisée = 0
    base.pic_de_mémoire = 0
    base.infos = info_de(mémoire(base))
    base.allocatrice_parente = nul
    base.allocatrice_secours = nul
}

allocatrice_défaut :: fonc(
    mode : ModeAllocatrice,
    nouvelle_taille : z64,
    ancienne_taille : z64,
    ancien_pointeur : *rien,
    dyn données : *BaseAllocatrice,
    info : *InfoType,
    pos : PositionCodeSource) -> *rien
{
    discr mode {
        ALLOUE {
            données.mémoire_utilisée += nouvelle_taille
            données.nombre_allocations += 1

            si données.pic_de_mémoire < données.mémoire_utilisée {
                données.pic_de_mémoire = données.mémoire_utilisée
            }

            retourne malloc(nouvelle_taille)
        }
        RÉALLOUE {
            données.mémoire_utilisée += nouvelle_taille - ancienne_taille
            données.nombre_allocations += 1
            données.nombre_réallocations += 1

            si données.pic_de_mémoire < données.mémoire_utilisée {
                données.pic_de_mémoire = données.mémoire_utilisée
            }

            retourne realloc(ancien_pointeur, nouvelle_taille)
        }
        DÉSALLOUE {
            données.mémoire_utilisée -= ancienne_taille
            données.nombre_désallocations += 1

            free(ancien_pointeur)
            retourne nul
        }
    }

    retourne nul
}

/*
// À FAIRE : considère remplacer loge, déloge, et reloge avec ces fonctions
// À FAIRE : type dépendant (gabarits, il faudra que les types deviennent citoyens de première classe)
// À FAIER : infos types
alloue :: fonc(nouvelle_taille: z64) -> *rien
{
    retourne contexte.allocatrice(
        ModeAllocatrice.ALLOUE,
        nouvelle_taille,
        0,
        nul,
        contexte.données_allocatrice,
        nul)
}

réalloue :: fonc (pointeur: *rien, ancienne_taille: z64, nouvelle_taille: z64) -> *rien
{
    retourne contexte.allocatrice(
        ModeAllocatrice.RÉALLOUE,
        nouvelle_taille,
        ancienne_taille,
        pointeur,
        contexte.données_allocatrice,
        nul)
}

désalloue :: fonc (pointeur: *rien, ancienne_taille: z64) -> *rien
{
    retourne contexte.allocatrice(
        ModeAllocatrice.DÉSALLOUE,
        0,
        ancienne_taille,
        pointeur,
        contexte.données_allocatrice,
        nul)
}

// alloue_avec pour changer l'allocatrice
// alloue_tableau, alloue_chaine, etc.
*/

// ----------------------------

ModeLogage :: énum z32 {
    AUCUN
    MINIMAL
    JOURNALIER
    VERBEUX
}

// ----------------------------

// Le StockageTemporaire est un stockage mis en place par le compilateur, qui réserve
// une certaine taille dans l'exécutable où mettre des données temporaire.
// À FAIRE : option de compilation pour définir la taille du stockage temporaire
// on attendra que la métoprogrammation soit ici pour passer les options par celle-ci
StockageTemporaire :: struct {
    données : *octet
    taille : z32
    occupé : z32
    occupation_maximale : z32
}

// Structure passée implicitement à toutes les fonctions non marquées par #!nulctx.
// À FAIRE : permettre aux utilisateurs du langage d'ajouter des variables dans
// cette structure.
ContexteProgramme :: struct {
    allocatrice := allocatrice_défaut
    données_allocatrice : *BaseAllocatrice = nul

    logueur := __logueur_défaut
    données_logueur : *rien = nul

    stockage_temporaire : *StockageTemporaire
}

__logueur_défaut :: fonc (message: chaine, ident: chaine, mode: ModeLogage, données: *rien) -> rien {}

// ----------------------------

// Fonctions de convénience pour accéder aux données sur les allocations
// de l'allocatrice courante du contexte
#enligne mémoire_utilisée :: fonc() -> z64
{
    retourne contexte.données_allocatrice.mémoire_utilisée
}

#enligne pic_de_mémoire :: fonc() -> z64
{
    retourne contexte.données_allocatrice.pic_de_mémoire
}

#enligne nombre_allocations :: fonc() -> z64
{
    retourne contexte.données_allocatrice.nombre_allocations
}

#enligne nombre_réallocations :: fonc() -> z64
{
    retourne contexte.données_allocatrice.nombre_réallocations
}

#enligne nombre_désallocations :: fonc() -> z64
{
    retourne contexte.données_allocatrice.nombre_désallocations
}

// ----------------------------
// Implémentation des fonctions du stockage temporaire

obtiens_marque_stockage_temporaire :: fonc () -> z32
{
    retourne contexte.stockage_temporaire.occupé
}

set_marque_stockage_temporaire :: fonc (marque: z32) -> rien
{
    assert(marque >= 0)
    assert(marque < contexte.stockage_temporaire.taille)
    contexte.stockage_temporaire.occupé = marque
}

réinitialise_stockage_temporaire :: fonc () -> rien
{
    set_marque_stockage_temporaire(0)
    contexte.stockage_temporaire.occupation_maximale = 0
}

alloc_stockage_temporaire :: fonc (dyn alloc: *StockageTemporaire, nouvelle_taille: z64) -> *rien
{
    si alloc.occupé + nouvelle_taille > alloc.taille {
        // À FAIRE : utilisation de l'allocatrice par défaut
        retourne nul
    }

    ptr := alloc.données + alloc.occupé
    alloc.occupé += nouvelle_taille

    si alloc.occupé > alloc.occupation_maximale {
        alloc.occupation_maximale = alloc.occupé
    }

    retourne ptr
}

__stockage_temporaire :: fonc(
    mode : ModeAllocatrice,
    nouvelle_taille : z64,
    ancienne_taille : z64,
    ancien_pointeur : *rien,
    données : *BaseAllocatrice,
    info : *InfoType,
    pos : PositionCodeSource) -> *rien
{
    dyn alloc := transtype(contexte.stockage_temporaire: *StockageTemporaire)

    discr mode {
        ALLOUE {
            retourne alloc_stockage_temporaire(alloc, nouvelle_taille)
        }
        RÉALLOUE {
            ptr := transtype(ancien_pointeur: *octet)

            si ptr == nul {
                retourne alloc_stockage_temporaire(alloc, nouvelle_taille)
            }

            delta := nouvelle_taille - ancienne_taille

            // À FAIRE
            // Nous ne pouvons réallouer que si le pointeur fut le dernier alloué...
            /*
            dyn n := ancienne_taille

            si ptr + n != alloc.ptr {
                retourne nul
            }

            // ... et qu'il y a suffisament de place pour delta

            n = delta  // arrondis_pour_aligner(delta, 8)

            d := transtype(alloc.ptr: z64)
            f := transtype(alloc.début + alloc.données.taille: z64)

            si n > (f - d) {
                retourne nul
            }

		    alloc.ptr += n
            */

            alloc.occupé += delta

            si alloc.occupé > alloc.occupation_maximale {
                alloc.occupation_maximale = alloc.occupé
            }

            retourne ancien_pointeur
        }
        DÉSALLOUE {
            // À FAIRE
            alloc.occupé -= ancienne_taille
            retourne nul
        }
    }

    retourne nul
}

// fonction de convénience pour loge un tampon dans le stockage temporaire
// principalement utilisé pour loger des chaines avec une terminaison nulle
// afin de pouvoir les passer aux fonctions de C
logement_temp :: fonc(taille: z64) -> *octet
{
    dyn nouveau_contexte := contexte
    nouveau_contexte.allocatrice = __stockage_temporaire

    dyn ptr : *octet

    pousse_contexte nouveau_contexte {
        tmp := loge [taille]octet
        ptr = tmp.pointeur
    }

    retourne ptr
}

// -----------------------------

// Fonctions de bases pour les opérateurs de comparaisons de chaines
sont_chaines_égales :: fonc(chn1: chaine, chn2: chaine) -> bool
{
    si chn1.taille != chn2.taille {
		retourne faux
    }

	taille := chn1.taille
	début : z64 = 0

    pour i dans début...(taille - 1) {
        si chn1[i] != chn2[i] {
			retourne faux
        }
    }

	retourne vrai
}

sont_chaines_inégales :: fonc(chn1: chaine, chn2: chaine) -> bool
{
    retourne !sont_chaines_égales(chn1, chn2)
}

// Fonctions basiques pour les tableaux

tableau_ajoute :: fonc (dyn tabl: *[]$T, valeur: $T) -> rien
{
    dyn tmp := mémoire(tabl)

    taille := tmp.taille
    reloge tmp: [taille + 1]$T
    tmp[taille] = valeur

    mémoire(tabl) = tmp
}

tableau_réserve :: fonc(dyn tabl: *[]$T, taille: z64) -> rien
{
    si taille <= tabl.taille {
        retourne
    }

	dyn tmp := mémoire(tabl)

	reloge tmp : [taille]$T

	mémoire(tabl) = tmp
}

tableau_copie :: fonc(dyn tabl: []$T) -> []$T
{
	dyn tmp := loge [tabl.taille]$T
    copie_mem_nonsur(src = tabl.pointeur, dst = tabl.pointeur, taille = tabl.taille * transtype(taille_de(z64): z64))
    retourne tmp
}

tableau_insère :: fonc(dyn tabl: *[]$T, index: z32, valeur: $T) -> rien
{
	dyn tmp := mémoire(tabl)
	tmp[index] = valeur
	mémoire(tabl) = tmp
}

tableau_supprime :: fonc(dyn tabl: *[]$T, index: z32) -> rien
{
	si index < 0 || index >= tabl.taille {
		retourne
	}

	dyn tmp := mémoire(tabl)

	taille := tabl.taille

	pour i dans transtype(index: z64) ... taille - 2 {
		tmp[i] = tmp[i + 1]
	}

	reloge tmp : [taille - 1]$T

	mémoire(tabl) = tmp
}
