Faitures
--------
- utilisation de caractères unicodes UTF-8 dans les sources
- possibilité d'appeler des fonctions C (comme printf, ou les appels système) et de bibliothèques partagées (.so)
- contrôle de flux via boucles et conditions
- fonctions variadiques typées
- possibilité de nommer les paramètres des fonctions lors des appels (p.e. f(a=0, b=5) au lieu de f(0, 5))
- règle de définition unique : deux structures ou deux fonctions ayant les mêmes paramètres ou deux variables ne peuvent avoir le même nom
- inférence de type
- type de tableaux et de chaine connus par le compilateur
- vérification de l'accès hors des bornes des chaines et tableaux
- transtypage entre types simples
- système de modules pour séparer le code en composants
- manipulation de pointeurs vers fonction
- initialisation de tableaux dans une déclaration
- initialisation de structures dans une déclaration
- nommage et typage explicite des énums pour éviter les problèmes de transtypage ou autre
- déréférencement de pointeur (via 'mémoire')
- initialisation explicite des membres des structures lors de leur définition
- système d'introspection/de réflexion
- mot clé pour différer l'exécution d'un bloc lors du retour d'une fonction
- type 'octet' pour ne pas confondre avec un 'char'
- allocations dynamiques de mémoire via les mots-clés loge/déloge/reloge
- accès à la mémoire actuellement allouée
- association/switch
- surcharge de fonction avec des types différents
- générateurs/coroutines permettant de reprendre une fonction là où l'on s'est arrêté comme le yield de Python
- plusieurs valeur de retour
- point-virgule implicite (à la fin des expressions)
- surcharge d'opérateurs
- fonctions gabarits/polymorphiques
- valeur par défaut des paramètres de fonctions
- héritage de structures via un système d'emploiement


À faire
-------
- transtypage entre types complexes
- transtypage automatique des valeurs littérales dans les expressions ou autre
---- littérale + littérale -> littérale  # OK
---- type + littérale      -> type       # À FAIRE (OK pour Z32, R64)
---- littérale + type      -> type       # À FAIRE (OK pour Z32, R64)
---- caractere + entier    -> caractère  # À FAIRE
---- entier + caractere    -> caractère  # À FAIRE
---- chaîne + caractere    -> chaîne     # À FAIRE
---- caractere + chaîne    -> chaîne     # À FAIRE
- stack canaries (coulisse LLVM)
- coroutines en dehours de boucles
- évite l'initialisation via "---"
- interpreteur pour calculer le code au niveau de l'émission de code (exécuter dans le compileur, voir JAI, pour les bibliothèques externes -> chargement du .so/.dll)
- ajoute accès membre pour les types (==> déplacer structures dans les modules)
- ajout d'une option pour controler la génération du code d'introspection/réflexion (il faut alors également exclure les einis)
- conversion automatique des types en unions et extraction automatique des valeurs des unions
- infos types pour les unions
- surcharge d'opérateurs, considération pour '='
- surcharge transtypage
	opér [type] (arg) : [type]
- réusinage des tests
- avoir une gestion de la correctitude de constance
- gabarits (maintenir une table de symboles afin de désambiguer a < b (comparaison), et a<b> (paramètres)
- empl (vérifier tous les cas)
- évaluation arbitraire du code (en cours)
- initialisation des objets : évite d'initialiser plusieurs fois le même membre
- alias de types
- opérateurs implicites
	<= implicite si > ou (< et ==) est défini
	>= implicite si < ou (> et ==) est défini
	== implicite si != est défini
	!= implicite si == est défini
- validation des types des énums, et typages plus libre (énum de chaines, de structures, etc.)
- ajout d'un mot-clé pour les types ?
- ajout d'un type pour les retours de fonctions (ou tuple, R-uple ?)
- ajout d'un type pour les caractères (« rune »), avec une gestion correcte des chaines UTF-8
- finir la coulisse LLVM, avec la métaprogrammation
- types comme valeurs
- corriger les bugs
- ajout d'un noeud syntaxique pour les imports (simplifiant la recherche de symboles dans les expressions de type A.B.C)
- déplacer les directives sur les fonctions après leurs types de retours :
	- #enligne ma_fonction :: #nulctx fonc () -> rien
	devient
	- ma_fonction :: fonc () -> rien #enligne #nulctx
- correction du typages des énumérations en C qui clashent avec les types entiers


À faire (tests)
---------------
- test caractère simple (assignation + modification)
- test opérateurs simple
- test mélanges types/nombres littéraux
- test @var[0]
- test chaine littérale, déclaration, assignement de pointeur et tableau
- test énumération
- test initialisation de structures lors des déclarations
- test surcharge de fonction
- test coroutine
- test valeurs de retours multiples


Bugs (coulisse LLVM)
--------------------
- crash lors de la compilation de boucle contenant un 'arrête' après des blocs si/sinon
- passer un tableau à un paramètre de type pointeur ne semble pas prendre l'ardresse du tableau (@tableau[0])
- addition de pointeur ne retourne pas forcément de pointeur ? (Les opérateurs doivent être mieux gérer)


Idées
-----
- mot clés pour le nom du fichier courant, la ligne, la colonne, et le temps où la ligne a été rencontré pour la première foix (__fichier__, __ligne__, __colonne__, __temps__)
- opérateur 'chaîne' pour retourner une chaîne de caractère contenant ce qu'il y a entre ses parenthèses : par exemple chaîne(a) -> "a"
- utilisation de propriétés pour appeler un code avant ou après une fonction à chaque qu'elle est appelée (comme ctor/dtor en C++, ou les gestionnaires de contextes en Python avec "with")
- héritage/polymorphisme par enlignage de structures dans d'autres
- fonction membres de structures similaire à Python avec 'self' explicit, ou appel explicit en passant l'objet en premier paramètre
- passer uniquement par référence, ou utilisation d'un mot-clé spécifique pour dire qu'un paramètre peut-être nul
- mot-clés pour des tests unitaires, avec maintenance des fonctions auxilliaires des tests par le compileur
- mot-clés pour des tests fuzzés, avec maintenance des fonctions auxilliaires des tests par le compileur
- mot-clés pour un mutli-threading par système de tâches concurrentes, avec maintenance des fonctions auxilliaires par le compileur
- transformer les messages d'erreur en tutoriaux
- ajout de nom et valeur par défaut au type de retour
- constructeurs/destructeurs via mot-clés et pointeurs de fonction
- concaténation des chaînes littérales connues lors de la compilation via l'opérateur '+'
- opérateurs prenant des listes :
	a += (c, d, e, f, g, h, i, j)

	équivalent à

	a += b + c + d + e + f + g

	si a == (c, d, e, f, g, h, i, j) {

	}

	équivalent à

	si a == c || a == d || a == e ... {

	}

	comment pour a && c


déréférencement *
prend adresse &a
pointeur *z32

transtypage :

transtype(x: z16)
x comme z16

x en z16

a = x.a comme z16 + 8
a = b + c en z16

précédence
-- plus faible que + - * /
-- plus élévée que .

expr unaire : a
    expr binaire : +
        expr binaire : comme
            réf var : x
            réf type : z16
        expr : 8

nombres littéraux :
-- définis la taille minimale naturel et relative
---- v < 128 => z8
---- v < 256 => n8, z16
---- v < 65536 => n16, z32, etc....

lit + var
var + lit
lit + lit


Zones d'ombres
--------------
- concurrence, moultfilage


Sécurité/évitement des bugs
---------------------------
- les variables sont constantes par défaut
- les variables sont initialisées à zéro lors de leur déclaration
- aucune conversion n'est implicite (sauf pour les valeurs littérales, quand cela est sensé, z32 -> z64)
- les contrôles de flux doivent avoir des valeurs booléennes explicit
- l'opérateur booléen d'inversion '!' ne peut prendre qu'une valeur booléenne
- les portées doivent être explicitement entourées de { } pour éviter que des expressions ne devant qu'être exécutées dans un contrôle de flux ne soient pas exécutées en dehors.
- l'opérateur d'assignemet '=' ne retourne pas de valeur pour éviter toute confusion avec '==' (peut-être à réviser puisque il n'a pas de conversion implicite vers des valeurs booléennes)
- les ombrages de variables sont interdites, toutes les variables dans une portée ne peuvent avoir le nom d'une variable déjà déclarée dans une portée parente
- blocs explicites : impossible de ne pas avoir un bloc afin de mieux définir ce qui se trouve dans un bloc
- accès aléatoire via des index protégé
- conservation de la taille des tableaux et des chaines (contrairement à C qui les jette et utilise un pointeur nul pour définir la fin)
- souvenir du membre actif des unions


Néologismes
-----------
- faiture   : feature
- entredit  : interdit
- enligner  : inline
- compileur : compilateur
- moultfilage : multithreading


Anglicisme
----------
- fuzzing/fuzzées
- constant folding
- stack canaries


// optimisations (avant la génération de code) :
// -- supression de code mort
// -- débouclement (tableau fixes, plages connues)
// -- évaluation d'expressions constantes

/: évaluation des conditions


motifs :

!= || != => toujours vraie, avertissement

&& || => ambigüe, avertissement

|| && => idem


avoir un système de détermination de contraintes pour les fonctions polymorphiques
