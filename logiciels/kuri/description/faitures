Faitures
--------
- utilisation de caractères unicodes UTF-8 dans les sources
- possibilité d'appeler des fonctions C (comme printf, ou les appels système) et de bibliothèques partagées (.so)
- contrôle de flux via boucles et conditions
- fonctions variadiques typées
- possibilité de nommer les paramètres des fonctions lors des appels (p.e. f(a=0, b=5) au lieu de f(0, 5))
- règle de définition unique : deux structures ou deux fonctions ayant les mêmes paramètres ou deux variables ne peuvent avoir le même nom
- inférence de type
- type de tableaux et de chaine connus par le compilateur
- vérification de l'accès hors des bornes des chaines et tableaux
- transtypage entre types simples
- système de modules pour séparer le code en composants
- manipulation de pointeurs vers fonction
- initialisation de tableaux dans une déclaration
- initialisation de structures dans une déclaration
- nommage et typage explicite des énums pour éviter les problèmes de transtypage ou autre
- déréférencement de pointeur (via 'mémoire')
- initialisation explicite des membres des structures lors de leur définition
- système d'introspection/de réflexion
- mot clé pour différer l'exécution d'un bloc lors du retour d'une fonction
- type 'octet' pour ne pas confondre avec un 'char'
- allocations dynamiques de mémoire via les mots-clés loge/déloge/reloge
- accès à la mémoire actuellement allouée
- association/switch
- surcharge de fonction avec des types différents
- générateurs/coroutines permettant de reprendre une fonction là où l'on s'est arrêté comme le yield de Python
- plusieurs valeur de retour
- point-virgule implicite (à la fin des expressions)
- surcharge d'opérateurs
- fonctions gabarits/polymorphiques
- valeur par défaut des paramètres de fonctions
- héritage de structures via un système d'emploi
- évite l'initialisation via "---"
- conversion automatique des types en unions et extraction automatique des valeurs des unions


À faire
-------
- transtypage entre types complexes
- transtypage automatique des valeurs littérales dans les expressions ou autre
---- littérale + littérale -> littérale  # OK
---- type + littérale      -> type       # À FAIRE (OK pour Z32, R64)
---- littérale + type      -> type       # À FAIRE (OK pour Z32, R64)
---- caractere + entier    -> caractère  # À FAIRE
---- entier + caractere    -> caractère  # À FAIRE
---- chaîne + caractere    -> chaîne     # À FAIRE
---- caractere + chaîne    -> chaîne     # À FAIRE
- stack canaries (coulisse LLVM)
- coroutines en dehours de boucles
- interpreteur pour calculer le code au niveau de l'émission de code (exécuter dans le compileur, voir JAI, pour les bibliothèques externes -> chargement du .so/.dll)
- ajoute accès membre pour les types (==> déplacer structures dans les modules)
- ajout d'une option pour controler la génération du code d'introspection/réflexion (il faut alors également exclure les einis)
- infos types pour les unions
- surcharge d'opérateurs, considération pour '='
- surcharge transtypage
	opér [type] (arg) : [type]
- avoir une gestion de la correctitude de constance
- structures gabarits
- empl (vérifier tous les cas)
- évaluation arbitraire du code (en cours)
- alias de types
- opérateurs implicites
	<= implicite si > ou (< et ==) est défini
	>= implicite si < ou (> et ==) est défini
	== implicite si != est défini
	!= implicite si == est défini
- validation des types des énums, et typages plus libre (énum de chaines, de structures, etc.)
- ajout d'un type pour les retours de fonctions (ou tuple, R-uple ?)
- ajout d'un type pour les caractères (« rune »), avec une gestion correcte des chaines UTF-8
- finir la coulisse LLVM, avec la métaprogrammation
- types comme valeurs
- corriger les bugs
- ajout d'un noeud syntaxique pour les imports (simplifiant la recherche de symboles dans les expressions de type A.B.C)
- avoir un « runtime » par machine cible où nous implémentons les fonctions ou instructions n'étant pas disponible sur celle-ci (voir Zig)
- asm enligné
- pouvoir accéder aux pointeurs des tableaux fixes (@a[0]) via a.pointeur
- instructions SIMD
- déplace le contexte du processus principale dans une variable globale afin de pouvoir l'utiliser via pousse_contexte dans des fonctions marquées #nulctx via pousse_contexte
- ajout de « init_de » pour accéder à la fonction d'initialisation d'une structure
- avoir une meilleure sécurité de type pour les einis, via discr et un transtypage automatique
discr e {
    ENTIER {
        // que faire pour la taille en octet
    }
    STRUCTURE {
        // ??
    }
}
le compilateur doit savoir le type lors de la compilation, peut-être avoir des outils avec la métaprogrammation et le polymorphisme

- transtypage automatique les unions vers le type discriminée :
discr u {
    z32 { u += 5 }
    r32 { u += 6.7 }
    ...
}

- renomme InfoType -> DescType, id_info -> Genre{Info|Desc} ?
- ajout d'une table de types accessible depuis les programmes
- amélioration boucle pour :
-- obtenir un pointeur via : pour * ...
-- inverse la direction via : pour inverse ...
-- controle la condition finale via : pour <= ...
-- itération sur plusieurs variables de même type
---- pour chn1, chn2 { ... }, la variable implicite sera un type produit accédé via it.N où N est un nombre
- tranche de tableaux et de chaine via : x[ D ... F ]
- utilisation d'un fichier "module.kuri" pour définir le contenu d'un module, les fichiers à charger
- nettoyage des modules
--- déplace table_hachage de "Fondation"
--- ajout d'un module pour l'interface avec la compilatrice
--- déplace "boutisme" dans un module "Ordinateur"

À faire (tests)
---------------
- test caractère simple (assignation + modification)
- test opérateurs simple
- test mélanges types/nombres littéraux
- test @var[0]
- test chaine littérale, déclaration, assignement de pointeur et tableau
- test énumération
- test initialisation de structures lors des déclarations
- test surcharge de fonction
- test coroutine
- test valeurs de retours multiples


Idées
-----
- opérateur 'chaîne' pour retourner une chaîne de caractère contenant ce qu'il y a entre ses parenthèses : par exemple chaîne(a) -> "a"
- utilisation de propriétés pour appeler un code avant ou après une fonction à chaque qu'elle est appelée (comme ctor/dtor en C++, ou les gestionnaires de contextes en Python avec "with")
- héritage/polymorphisme par enlignage de structures dans d'autres
- fonction membres de structures similaire à Python avec 'self' explicit, ou appel explicit en passant l'objet en premier paramètre
- passer uniquement par référence, ou utilisation d'un mot-clé spécifique pour dire qu'un paramètre peut-être nul
- mot-clés pour des tests unitaires, avec maintenance des fonctions auxilliaires des tests par le compileur
- mot-clés pour des tests fuzzés, avec maintenance des fonctions auxilliaires des tests par le compileur
- mot-clés pour un mutli-threading par système de tâches concurrentes, avec maintenance des fonctions auxilliaires par le compileur
- transformer les messages d'erreur en tutoriaux
- ajout de nom et valeur par défaut au type de retour
- constructeurs/destructeurs via mot-clés et pointeurs de fonction
- concaténation des chaînes littérales connues lors de la compilation via l'opérateur '+'
- opérateurs prenant des listes :
	a += (c, d, e, f, g, h, i, j)

	équivalent à

	a += b + c + d + e + f + g

	si a == (c, d, e, f, g, h, i, j) {

	}

	équivalent à

	si a == c || a == d || a == e ... {

	}

	comment pour a && c


déréférencement *
prend adresse &a
pointeur *z32

nombres littéraux :
-- définis la taille minimale naturel et relative
---- v < 128 => z8
---- v < 256 => n8, z16
---- v < 65536 => n16, z32, etc....

lit + var
var + lit
lit + lit


Zones d'ombres
--------------
- concurrence, moultfilage


Sécurité/évitement des bugs
---------------------------
- les variables sont initialisées à zéro lors de leur déclaration
- aucune conversion n'est implicite (sauf pour les valeurs littérales, quand cela est sensé, z32 -> z64)
- les contrôles de flux doivent avoir des valeurs booléennes explicites
- l'opérateur booléen d'inversion '!' ne peut prendre qu'une valeur booléenne
- les portées doivent être explicitement entourées de { } pour éviter que des expressions ne devant qu'être exécutées dans un contrôle de flux ne soient pas exécutées en dehors.
- l'opérateur d'assignemet '=' ne retourne pas de valeur pour éviter toute confusion avec '==' (peut-être à réviser puisque il n'a pas de conversion implicite vers des valeurs booléennes)
- les ombrages de variables sont interdites, toutes les variables dans une portée ne peuvent avoir le nom d'une variable déjà déclarée dans une portée parente
- blocs explicites : impossible de ne pas avoir un bloc afin de mieux définir ce qui se trouve dans un bloc
- accès aléatoire via des index protégé
- conservation de la taille des tableaux et des chaines (contrairement à C qui les jette et utilise un pointeur nul pour définir la fin)
- souvenir du membre actif des unions


Néologismes
-----------
- faiture   : feature
- entredit  : interdit
- enligner  : inline
- compileur : compilateur
- moultfilage : multithreading


Anglicisme
----------
- fuzzing/fuzzées
- constant folding
- stack canaries


// optimisations (avant la génération de code) :
// -- supression de code mort
// -- débouclement (tableau fixes, plages connues)
// -- évaluation d'expressions constantes

/: évaluation des conditions


motifs :

!= || != => toujours vraie, avertissement

&& || => ambigüe, avertissement

|| && => idem


avoir un système de détermination de contraintes pour les fonctions polymorphiques
