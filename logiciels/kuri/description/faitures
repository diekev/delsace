Faitures
--------
- utilisation de caractères unicodes UTF-8 dans les sources
- possibilité d'appeler des fonctions C (comme printf, ou les appels système) et de bibliothèques partagées (.so)
- contrôle de flux via boucles et conditions
- fonctions variadiques typées
- possibilité de nommer les paramètres des fonctions lors des appels (p.e. f(a=0, b=5) au lieu de f(0, 5))
- règle de définition unique : deux structures ou deux fonctions ayant les mêmes paramètres ou deux variables ne peuvent avoir le même nom
- inférence de type
- type de tableaux et de chaine connus par le compilateur
- vérification de l'accès hors des bornes des chaines et tableaux
- transtypage entre types simples
- système de modules pour séparer le code en composants
- manipulation de pointeurs vers fonction
- initialisation de tableaux dans une déclaration
- initialisation de structures dans une déclaration
- nommage et typage explicite des énums pour éviter les problèmes de transtypage ou autre
- déréférencement de pointeur (via 'mémoire')
- initialisation explicite des membres des structures lors de leur définition
- système d'introspection/de réflexion
- mot clé pour différer l'exécution d'un bloc lors du retour d'une fonction
- type 'octet' pour ne pas confondre avec un 'char'
- allocations dynamiques de mémoire via les mots-clés loge/déloge/reloge
- accès à la mémoire actuellement allouée
- association/switch
- surcharge de fonction avec des types différents
- générateurs/coroutines permettant de reprendre une fonction là où l'on s'est arrêté comme le yield de Python
- plusieurs valeur de retour
- point-virgule implicite (à la fin des expressions)


À faire
-------
- transtypage entre types complexes
- transtypage automatique des valeurs littérales dans les expressions ou autre
---- littérale + littérale -> littérale  # OK
---- type + littérale      -> type       # À FAIRE (OK pour Z32, R64)
---- littérale + type      -> type       # À FAIRE (OK pour Z32, R64)
---- caractere + entier    -> caractère  # À FAIRE
---- entier + caractere    -> caractère  # À FAIRE
---- chaîne + caractere    -> chaîne     # À FAIRE
---- caractere + chaîne    -> chaîne     # À FAIRE
- fonctions et structures gabarit/génériques avec contrats/concepts
- type nombre réel sur 16-bit (en cours)
- types spéciaux pour chaînes de caractères et caractère simple
- stack canaries (coulisse LLVM)
- préfixe les structures et les énumérations du nom du module
- réusinage du système de vérification sémantique du code notamment pour dédupliquer ce code et prendre en compte l'analyse de fonctions dans des modules externes dont nous ne pouvons savoir le type avant l'analyse sémantique
- coroutines en dehours de boucles
- variables employées
- évite l'initialisation via "---"
- amélioration de la validation et la génération de code pour les initialisations des structures
- surcharge d'opérateur
- interpreteur pour calculer le code au niveau de l'émission de code (exécuter dans le compileur, voir JAI, pour les bibliothèques externes -> chargement du .so/.dll)
- suppression ':'
- ajoute accès membre pour les types (==> déplacer structures dans les modules)
- analyseuse_grammaire -> suppression des vérifications redondantes
- unions -> info type, tiens trace de l'état à chaque modification, décalage au sein de la structure
- ajout d'une option pour controler la génération du code d'introspection/réflexion (il faut alors également exclure les einis)
- amélioration du système de vérification des opérateurs
- surcharge d'opérateurs
- surcharge de transtypage/transtypage personnalisé entre type
- conversion automatique des types en unions et extraction automatique des valeurs des unions
- infos types pour les unions
- tenir trace du nombre d'allocations et de réallocations


À faire (tests)
---------------
- test caractère simple (assignation + modification)
- test opérateurs simple
- test mélanges types/nombres littéraux
- test @var[0]
- test chaine littérale, déclaration, assignement de pointeur et tableau
- test énumération
- test initialisation de structures lors des déclarations
- test surcharge de fonction
- test coroutine
- test valeurs de retours multiples


Bugs
----
- expressions dans les opérateurs [] non converties correctement depuis le réusinage de la coulisse C


Bugs (coulisse LLVM)
--------------------
- crash lors de la compilation de boucle contenant un 'arrête' après des blocs si/sinon
- passer un tableau à un paramètre de type pointeur ne semble pas prendre l'ardresse du tableau (@tableau[0])
- addition de pointeur ne retourne pas forcément de pointeur ? (Les opérateurs doivent être mieux gérer)


Idées
-----
- opérateur 'chaîne' pour retourner une chaîne de caractère contenant ce qu'il y a entre ses parenthèses : par exemple chaîne(a) -> "a"
- mot clés pour le nom du fichier courant, la ligne, la colonne, et le temps où la ligne a été rencontré pour la première foix (__fichier__, __ligne__, __colonne__, __temps__)
- utilisation de propriétés pour appeler un code avant ou après une fonction à chaque qu'elle est appelée (comme ctor/dtor en C++)
- multiple valeurs de retour, notamment pour gérer les erreurs sans passer par des exceptions (on pourrait transformer les fonction pour avoir les valeurs retournées en paramètres pointés x = foo() -> foo(&x))
- héritage/polymorphisme par enlignage de structures dans d'autres
- surcharges des opérateurs
- déclarations de nouveaux types par alias d'un type connu (comme typedef en C/C++, mais avec typage strict) (mot-clé 'entredit', pour empêcher qu'un opérateur soit hérité)
- surcharge de fonctions
- fonction membres de structures similaire à Python avec 'self' explicit, ou appel explicit en passant l'objet en premier paramètre
- vérification automatique des limites des tableaux (peut-être interdiction de passer des pointeurs, et passage uniquement de tableaux)
- passer uniquement par référence, ou utilisation d'un mot-clé spécifique pour dire qu'un paramètre peut-être nul
- mot-clés pour des tests unitaires, avec maintenance des fonctions auxilliaires des tests par le compileur
- mot-clés pour des tests fuzzés, avec maintenance des fonctions auxilliaires des tests par le compileur
- mot-clés pour un mutli-threading par système de tâches concurrentes, avec maintenance des fonctions auxilliaires par le compileur
- transformer les messages d'erreur en tutoriaux
- valeur par défaut des arguments
- ajout de nom et valeur par défaut au type de retour
- contexte (modifiable par l'utilisateur) implicit passé en paramètre de toutes les fonctions internes pour pouvoir faciliter la gestion de la mémoire et d'autres données du programme
- compte de la mémoire utilisée avec rapport en fin d'exécution du programme sur ce qui a utilisé le plus de mémoire, et s'il y a fuite de mémoire
- constructeurs/destructeurs via mot-clés et pointeurs de fonction
- concaténation des chaînes littérales connues lors de la compilation via l'opérateur '+'


Zones d'ombres
--------------
- gestion des modules et espaces de noms
- gabarits
- héritage
- introspection lors de la compilation
- concurrence, moultfilage


Sécurité/évitement des bugs
---------------------------
- les variables sont constantes par défaut
- les variables sont initialisées à zéro lors de leur déclaration
- aucune conversion n'est implicite (sauf pour les valeurs littérales, quand cela est sensé, z32 -> z64)
- les contrôles de flux doivent avoir des valeurs booléennes explicit
- l'opérateur booléen d'inversion '!' ne peut prendre qu'une valeur booléenne
- les portées doivent être explicitement entourées de { } pour éviter que des expressions ne devant qu'être exécutées dans un contrôle de flux ne soient pas exécutées en dehors.
- l'opérateur d'assignemet '=' ne retourne pas de valeur pour éviter toute confusion avec '==' (peut-être à réviser puisque il n'a pas de conversion implicite vers des valeurs booléennes)
- les ombrages de variables sont interdites, toutes les variables dans une portée ne peuvent avoir le nom d'une variable déjà déclarée dans une portée parente
- blocs explicites : impossible de ne pas avoir un bloc afin de mieux définir ce qui se trouve dans un bloc
- accès aléatoire via des index protégé
- conservation de la taille des tableaux et des chaines (contrairement à C qui les jette et utilise un pointeur nul pour définir la fin)


Néologismes
-----------
- faiture   : feature
- entredit  : interdit
- enligner  : inline
- compileur : compilateur
- moultfilage : multithreading


Anglicisme
----------
- fuzzing/fuzzées
- constant folding
- stack canaries
