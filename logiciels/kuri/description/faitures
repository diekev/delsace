Faitures
--------
- utilisation de caractères unicodes UTF-8 dans les sources
- possibilité d'appeler des fonctions C (comme printf, ou les appels système) et de bibliothèques partagées (.so)
- contrôle de flux via boucles et conditions
- fonctions variadiques typées
- possibilité de nommer les paramètres des fonctions lors des appels (p.e. f(a=0, b=5) au lieu de f(0, 5))
- règle de définition unique : deux structures ou deux fonctions ayant les mêmes paramètres ou deux variables ne peuvent avoir le même nom
- inférence de type
- type de tableaux et de chaine connus par le compilateur
- vérification de l'accès hors des bornes des chaines et tableaux
- transtypage entre types simples
- système de modules pour séparer le code en composants
- manipulation de pointeurs vers fonction
- initialisation de tableaux dans une déclaration
- initialisation de structures dans une déclaration
- nommage et typage explicite des énums pour éviter les problèmes de transtypage ou autre
- déréférencement de pointeur (via 'mémoire')
- initialisation explicite des membres des structures lors de leur définition
- système d'introspection/de réflexion
- mot clé pour différer l'exécution d'un bloc lors du retour d'une fonction
- type 'octet' pour ne pas confondre avec un 'char'
- allocations dynamiques de mémoire via les mots-clés loge/déloge/reloge
- accès à la mémoire actuellement allouée
- association/switch
- surcharge de fonction avec des types différents
- générateurs/coroutines permettant de reprendre une fonction là où l'on s'est arrêté comme le yield de Python
- plusieurs valeur de retour
- point-virgule implicite (à la fin des expressions)


À faire
-------
- transtypage entre types complexes
- transtypage automatique des valeurs littérales dans les expressions ou autre
---- littérale + littérale -> littérale  # OK
---- type + littérale      -> type       # À FAIRE (OK pour Z32, R64)
---- littérale + type      -> type       # À FAIRE (OK pour Z32, R64)
---- caractere + entier    -> caractère  # À FAIRE
---- entier + caractere    -> caractère  # À FAIRE
---- chaîne + caractere    -> chaîne     # À FAIRE
---- caractere + chaîne    -> chaîne     # À FAIRE
- types spécial pour caractère simple
- stack canaries (coulisse LLVM)
- réusinage du système de vérification sémantique du code notamment pour dédupliquer ce code et prendre en compte l'analyse de fonctions dans des modules externes dont nous ne pouvons savoir le type avant l'analyse sémantique
- coroutines en dehours de boucles
- évite l'initialisation via "---"
- interpreteur pour calculer le code au niveau de l'émission de code (exécuter dans le compileur, voir JAI, pour les bibliothèques externes -> chargement du .so/.dll)
- suppression ':'
- ajoute accès membre pour les types (==> déplacer structures dans les modules)
- analyseuse_grammaire -> suppression des vérifications redondantes
- ajout d'une option pour controler la génération du code d'introspection/réflexion (il faut alors également exclure les einis)
- conversion automatique des types en unions et extraction automatique des valeurs des unions
- infos types pour les unions
- à faire : urgent
-- surcharge d'opérateurs (simple)
	syntaxe : opér [opérateur] (args..) : [type]
	opérateurs composés avec = sont implicites
	+
	-
	+ unaire
	- unaire
	=
	/
	*
	%
	&
	&&
	|
	||
	^
	<<
	>>
	== (!= implicite)
	< (<= implicite si == ou (> et ==) est défini)
	> (>= implicite si == ou (< et ==) est défini)
	!
	~
-- surcharge transtypage
	opér [type] (arg) : [type]
-- réusinage des tests
-- avoir une meilleur gestion de la correctitude de constance, il est possible de passer une variable constante à un fonction la modifiant
- à faire : moins urgent
-- gabarits (maintenir une table de symboles afin de désambiguer a < b (comparaison), et a<b> (paramètres)
-- empl (vérifier tous les cas)
-- évaluation arbitraire du code
-- initialisation des objets : évite d'initialiser plusieurs fois le même membre
-- alias de types
-- opérateurs implicites
-- validation des types des énums, et typages plus libre (énum de chaines, de structures, etc.)


À faire (tests)
---------------
- test caractère simple (assignation + modification)
- test opérateurs simple
- test mélanges types/nombres littéraux
- test @var[0]
- test chaine littérale, déclaration, assignement de pointeur et tableau
- test énumération
- test initialisation de structures lors des déclarations
- test surcharge de fonction
- test coroutine
- test valeurs de retours multiples


Bugs (coulisse LLVM)
--------------------
- crash lors de la compilation de boucle contenant un 'arrête' après des blocs si/sinon
- passer un tableau à un paramètre de type pointeur ne semble pas prendre l'ardresse du tableau (@tableau[0])
- addition de pointeur ne retourne pas forcément de pointeur ? (Les opérateurs doivent être mieux gérer)


Idées
-----
- mot clés pour le nom du fichier courant, la ligne, la colonne, et le temps où la ligne a été rencontré pour la première foix (__fichier__, __ligne__, __colonne__, __temps__)
- opérateur 'chaîne' pour retourner une chaîne de caractère contenant ce qu'il y a entre ses parenthèses : par exemple chaîne(a) -> "a"
- utilisation de propriétés pour appeler un code avant ou après une fonction à chaque qu'elle est appelée (comme ctor/dtor en C++, ou les gestionnaires de contextes en Python avec "with")
- héritage/polymorphisme par enlignage de structures dans d'autres
- fonction membres de structures similaire à Python avec 'self' explicit, ou appel explicit en passant l'objet en premier paramètre
- passer uniquement par référence, ou utilisation d'un mot-clé spécifique pour dire qu'un paramètre peut-être nul
- mot-clés pour des tests unitaires, avec maintenance des fonctions auxilliaires des tests par le compileur
- mot-clés pour des tests fuzzés, avec maintenance des fonctions auxilliaires des tests par le compileur
- mot-clés pour un mutli-threading par système de tâches concurrentes, avec maintenance des fonctions auxilliaires par le compileur
- transformer les messages d'erreur en tutoriaux
- valeur par défaut des arguments
- ajout de nom et valeur par défaut au type de retour
- constructeurs/destructeurs via mot-clés et pointeurs de fonction
- concaténation des chaînes littérales connues lors de la compilation via l'opérateur '+'
- opérateurs prenant des listes :
	a += (c, d, e, f, g, h, i, j)

	équivalent à

	a += b + c + d + e + f + g

	si a == (c, d, e, f, g, h, i, j) {

	}

	équivalent à

	si a == c || a == d || a == e ... {

	}

	comment pour a && c


Zones d'ombres
--------------
- gestion des modules et espaces de noms
- gabarits
- héritage
- introspection lors de la compilation
- concurrence, moultfilage


Sécurité/évitement des bugs
---------------------------
- les variables sont constantes par défaut
- les variables sont initialisées à zéro lors de leur déclaration
- aucune conversion n'est implicite (sauf pour les valeurs littérales, quand cela est sensé, z32 -> z64)
- les contrôles de flux doivent avoir des valeurs booléennes explicit
- l'opérateur booléen d'inversion '!' ne peut prendre qu'une valeur booléenne
- les portées doivent être explicitement entourées de { } pour éviter que des expressions ne devant qu'être exécutées dans un contrôle de flux ne soient pas exécutées en dehors.
- l'opérateur d'assignemet '=' ne retourne pas de valeur pour éviter toute confusion avec '==' (peut-être à réviser puisque il n'a pas de conversion implicite vers des valeurs booléennes)
- les ombrages de variables sont interdites, toutes les variables dans une portée ne peuvent avoir le nom d'une variable déjà déclarée dans une portée parente
- blocs explicites : impossible de ne pas avoir un bloc afin de mieux définir ce qui se trouve dans un bloc
- accès aléatoire via des index protégé
- conservation de la taille des tableaux et des chaines (contrairement à C qui les jette et utilise un pointeur nul pour définir la fin)
- souvenir du membre actif des unions


Néologismes
-----------
- faiture   : feature
- entredit  : interdit
- enligner  : inline
- compileur : compilateur
- moultfilage : multithreading


Anglicisme
----------
- fuzzing/fuzzées
- constant folding
- stack canaries
