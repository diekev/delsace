
// --------------------------- Contexte Implicite

utilisation d'une référence pour passer le contexte entre les fonctions, nous devrons correctement gérer les références dans ce cas

utilisation d'une variable globale pour le contexte du thread principale
    -- mention À FAIRE dans test_moultfilage.kuri
    -- mention À FAIRE dans Jeu/application.kuri "imprime n'a pas de contexte"

ajout de l'information de présence de contexte aux blocs afin de pouvoir définir si nous avons un contexte ou non

    fonction_sans_contexte :: fonc () #nulctx
    {
        contexte := __contexte_principal

        pousse_contexte contexte {
            fonction_avec_contexte()  // erreur de compilation
        }
    }

    pour les initialisation de structures, il nous faudra savoir là où la structure est initialisé si nous avons un contexte si une fonction utilisée dans l'initialisation requiers un tel contexte


// --------------------------- Fonctions

directive #procédure_d_appel pour trouver la surcharge d'une fonction
    a := #procédure_d_appel ma_fonction(5)  // renvoie le pointeur sur ma_fonction(z32)

passe un type à une fonction pour instantier automatiquement une valeur temporaire dont on ne se soucie pas de la valeur

    au lieu de :
    v : MonType
    fonction(v)

    faire :
    fonction(MonType)


// --------------------------- Polymorphie / Monophismisation

pouvoir instantier une fonction polymorphique lorsqu'on la passe à une autre

    ajoute :: fonc (a: $T, b : $T) -> $T
    {
        retourne a + b
    }

    fais_le :: fonc (a : z32, b : z32, f : fonc (z32, z32)(z32)) -> z32
    {
        retourne f(a, b)
    }

    fais_le(0, 5, ajoute) // ceci détecte que ajoute est une fonction polymorphique et l'instantie pour le bon type

lambdas

    x => x.nom // crée une fonction foo :: (x: $T) -> chaine { retourne x.nom }


avoir un système de détermination de contraintes pour les fonctions polymorphiques

    ajoute :: fonc (a: $T/TypeOuInterface) // force T à être un dérivé de TypeOuInterface
        comment faire pour contraindre sur des types scalaires (entier ou réél)

supporte les structures polymorphiques / gabarits

De Jorjala/attribut.kuri
// À FAIRE : définir une bonne interface pour accéder aux valeurs sans gabarits
//
// Idée tirée de JAI :
//
// déclaration d'un type gabarit    => x : $T
// déclaration d'une valeur gabarit => $x : T
// La valeur gabarit est l'équivalent des valeurs littérales des templates en C++
// template <int N>, mais en plus flexible
//
// Une instruction #bake sers à instantier les fonctions selon les valeurs gabarits
// par exemple (avec notre syntaxe)
//
// fonc nouveau_tableau_fixe($N : Type_de_N, x : $Type_du_tableau) : [N]$Type_du_tableau
// crée_tableau_dix_éléments = #cuis nouveau_tableau_fixe($N = 10)
//
// On peut alors appeler : crée_tableau_dix_éléments(z32) pour créer un [10]z32
//
// Pour les attributs nous pourrions avoir un système similaire
//
// fonc valeur(attr : *Attribut, index : z64, $Type_de_valeur : Type, $T : TypeAttribut)
//
// valeur_z32 = #cuis valeur(Type_de_valeur = z32, T = TypeAttribut.Z32)
// valeur_r32 = #cuis valeur(Type_de_valeur = r32, T = TypeAttribut.R32)
// ....
//
// Ceci pourrait aisément remplacer le combo template + macro utilisé en C++

currying
    #cuis_constantes ma_fonction(T = z32)  // crée une nouvelle fonction ou le paramètre polymorphique T est remplacé par le type z32
    #cuis_valeurs    ma_fonction(x = 5)  // crée une nouvelle fonction ou le paramètre x est remplacé par la constante 5


// --------------------------- Métaprogrammation

crée une IPA pour les métaprogramme afin de simplifier leurs créations et exécution
    MachineVirtuelle::lance_métaprogramme

exécute plusieurs métaprogrammes à la fois
    système similaire à celui des systèmes d'exploitation (exécute le métaprogramme pendant X nanosecondes et passe au suivant)
    ou alors plusieurs tacheronnes
    dans tous les cas, il faudra n'exécuter qu'un seul métaprogramme à la fois pour ne pas modifier les globales

permet de modifier la valeur des globales via les métaprogrammes, la génération de code final devra pendre les valeurs se trouvant dans le code binaire
    complexe

directive #exécute dans les fonctions
    UnitéCompilation::attend_sur_métaprogramme(métaprogramme)
    tiré le résultat et son type
    le métaprogramme devra avoir des constantes comme entrée

vérifie que les entrées des métaprogrammes soit des constantes

directive #corps_texte pour définir le corps d'une fonction via un texte

    principale :: fonc () -> z32
    #corps_texte {
        retourne "retourne 0"
    }

- pouvoir changer le contenu d'une fonction (par exemple pour profiler l'exécutable)

- proprement définir ce qu'on doit faire si un métaprogramme demande un message alors qu'il n'a pas commencer à les intercepter

- défini une bonne sémantique pour compilatrice_commence_interception
    - dit à la compilatrice qu'un espace de travail devient le défaut ?
    - que l'on écoute des messages ? chaque espace de travail aura sa propre file de messages et la compilatrice mettra tous les messages dans celle-ci
        peut-on ne pas avoir les messages d'autres espaces ?
    => mise en place du métaprogramme ayant fait l'appel comme étant celui qui est le métaprogramme controlant la compilation, il aura l'exclusivité sur la prise en charge des messages (la compilatrice attendra que les message de pasage et de typage soit gérés avant de continuer, etc.)

- système de test unitaires

- avoir une manière de définir le module où nous ajoutons une chaine ou un fichier à la compilation


// --------------------------- Opérateurs

considère la surchage pour '='

opérateurs implicites
	<= implicite si > ou (< et ==) est défini
	>= implicite si < ou (> et ==) est défini
	== implicite si != est défini
	!= implicite si == est défini

considère un opérateur pour convertir entre des types

    opérateur Type :: fonc (a: AutreType) -> Type


TableOpérateur {
    opérateurs_unaires = ...;
    opérateurs_binaires = ...;
}

type->table_opérateur

Opérateurs implicites :
- pour les structures, si triviale -> hérite des différents opérateurs
- le faire de manière fainéante, quand requis, que faire si un autre module les définis ?
- création de l'opérateur en lui créant un arbre syntaxique

- pour les comparaisons de nombres réels, il faut savoir comment ordonnées
---- définis un epsilon lors de la compilation ? ULP ?

- opérateurs commutatif, le noter dans la génération de code


// --------------------------- Bas Fruitage

ajout d'une propriété "pointeur" aux tableaux fixes pour obtenir le pointeur vers le premier élément (au lien de @x[0])

ajout d'une propriété "capacité" aux chaines

ajout de tranches pour les tableaux et les chaines

    chn1 := "une chaine"
    chn2 := chn1[ 4 ... chn.taille - 1 ] // nous donne "chaine"


// --------------------------- Types

ajout de types produits (tuples) avec accès par x.0, x.1, etc...

avoir un bon système d'alias de type, avec sûreté de typage, pour ne avoir à déclarer des structures ne contenant qu'un seul membre

    AdresseEmail :: struct {
        chn: chaine
    }

    AdresseEmail :: #alias chaine

typage un peu libre des énumérations

    ExtensionImageSupportée :: chaine {
        JPEG :: "jpeg"
        EXR  :: "exr"
    }

    peut-être pourrions nous reprendre les énums de Rust pour les unions nonsûres
    mais une énumération est sensé être un ensemble de constantes

évite de nommer les membres des unions sûres

    Union :: struct {
        Type1
        Type2
        Type3
    }

constructions de la table de types
    requiers d'avoir des fonctions d'initialisations pour tous les types

ajout d'un type pour les caractères, au lieu de z8 ou n32 (peut se faire via un alias, mais les chaines seraient brisées)

charge/données personnalisées pour les erreurs afin de transmettre plus de détails à la fonction appelante

erreur générique pouvant passer des erreurs de fonction à fonction

avoir une gestion de la correctitude de constance

investigue l'utilisation des types entiers, des représentations binaires et des opérations
    https://stackoverflow.com/questions/13224273/difference-between-signed-and-unsigned-on-bitwise-operations

passe en revue les arithmétiques de pointeurs

amélioration du typage des expressions de tableaux constants
    plusieurs problèmes de l'approche courrante
    - le premier élément défini le type du tableau ce qui fait échoué les tableaux mélangeant des constantes de nombre et de caractère (voir Noyau)
    - les nombres constants sont définis comme z32, nous ne pouvons avoir un tableau de n32 par exemple avec uniquement des constantes
        -- mention À FAIRE dans HTML/Autres/parse_entite.kuri

normalisation de tous les types pour supprimer les unions et les entiers constants de la RI
    -- mention À FAIRE dans Internet/module.kuri

déclaration d'énum, de structures, et d'unions anonymes :
    énum {
        X
        Y
        Z
    }

    struct {
        x, y, z
    }

    également dans les expressions des types :
        a : struct { x, y, z }  // il faudra définir comment initialisé via une expression
        b : énum ...

// --------------------------- Discriminations

avoir une meilleure sécurité de type pour les einis, via discr et un transtypage automatique

    discr e {
        ENTIER {
            // que faire pour la taille en octet
        }
        STRUCTURE {
            // ??
        }
    }

    le compilateur doit savoir le type lors de la compilation, peut-être avoir des outils avec la métaprogrammation et le polymorphisme

transtypage automatique les unions vers le type discriminée :

    discr u {
        z32 { u += 5 }
        r32 { u += 6.7 }
        ...
    }

possibilité d'avoir des appels de fonctions où le premier argument est celui discriminé

    discr chn {
        commence_par("abc") {  } // équivalent à commence_par(chn, "abc")
        finie_par("xyz") { }     // équivalent à finie_par(chn, "xyz")
    }

avoir un bon système d'appariement de motif :

    discr a {
        b | c {	} // équivalent à (a == b || b == c)
        etc.
    }

    utilisation de '_' comme caractère générique pouvant être n'importe quelle valeur


// --------------------------- Boucles

- amélioration boucle pour :
-- obtenir un pointeur via : pour * ...
-- inverse la direction via : pour inverse ...
-- controle la condition finale via : pour <= ...
-- itération sur plusieurs variables de même type
---- pour chn1, chn2 { ... }, la variable implicite sera un type produit accédé via it.N où N est un nombre



// --------------------------- Modules / Espaces de Noms

utilisation d'un fichier "module.kuri" pour définir le contenu d'un module, les fichiers à charger

emploie des énums "empl MonÉnum", pour directement accéder aux valeurs

// Garde trace des espaces de noms, mais permet l'utilisation des membres via empl

importe Fondation
empl Fondation

ou

empl importe Fondation

renomme un import
F :: importe Fondation


// --------------------------- Interfaces / Traits

MonInterface :: entreface {
    x :: fonc ()...
}

définis MonInterface pour X {
    x :: fonc ()
}

peut-être devrions-nous forcer l'utilisation de "définis" pour toutes les fonctions afin de simplifier la recherche de fonctions par syntaxe uniforme ?
voir Rust


// --------------------------- Optimisations / Génération de Code

force l'enlignage des fonctions via un mot-clé, peut être fait durant le typage ?

a := enligne ajoute(5, 6)


// --------------------------- Analyse Statique

!= || != => toujours vraie, avertissement

&& || => ambigüe, avertissement

|| && => idem

nombres littéraux :
-- définis la taille minimale naturel et relative
---- v < 128 => z8
---- v < 256 => n8, z16
---- v < 65536 => n16, z32, etc....


// --------------------------- Environnemnt / Autres

avoir un « runtime » par machine cible où nous implémentons les fonctions ou instructions n'étant pas disponible sur celle-ci (voir Zig)

asm enligné

instructions SIMD

directive #externe : argument définissant la bibliothèque où trouver le symbole
- libc :: #bibiliothèque_externe "c"
- write :: fonc (...) -> z32 #externe libc

génère des statitiques pour chaque espace de travail si demandé, au lieu de statistiques pour toute la compilation
    -- imprime quand même la durée de compilation à la fin?


considération des assertions statiques lors de la compilation de plusieurs espaces de travail
    elles seront éxecutées pour chaque espace
    vraiment un espace de travail ne définit que ce que l'exécutable final contiendra, et il nous le faut pour les versions 32-bit
    peut-être qu'un espace devra pouvoir partager le code avec les autres
    un espace peut avoir un type contexte différent des autres... => stocke le type contexte dans l'espace, mais le code partagé ne pourra pas l'utiliser...


implémente la directive #si pour la compilation sélective
    commence par avoir des condtions définies par la compilatrice (LINUX, WINDOWS, MACOS, 32BITS, 64BITS, ...)
    utilisation de constantes globales ou locales, et des expressions pouvant être exécutées


- générateurs/coroutines permettant de reprendre une fonction là où l'on s'est arrêté comme le yield de Python
- stack canaries (coulisse LLVM)
- coroutines en dehors de boucles
- renomme InfoType -> DescType, id_info -> Genre{Info|Desc} ?
- diffère_err pour différer un bloc si une erreur est retournée
- possibilité de déclarer une variable dans une condition (si a := foo() { ... })

- appel les fonctions d'initialisation pour les constructions de structure si un membre est une structure
- généralisation de l'utilisation de temporaires pour simplifier la génération de la RI, supprimant les cas spéciaux
-- paramètres des appels
- optimisations de l'accès aux membres des blocs (table de hachage avec tableau continu, en cours)
- pouvoir passer des expressions à exécuter à la ligne de commande (kuri -exec "..." fichier.kuri)
- nettoie la génération de code de création de contexte pour la fonction principale pour utiliser le noeud de la création de contexte du module Kuri
- pouvoir utiliser un #! en début de fichier pour utiliser les programmes comme des scripts (cela compilera et exécutera l'exécutable ou alors juste les métaprogrammes, #! n'est pas cohérent sur toutes les plateformes...)
- pouvoir renommer les symboles d'un import pour une utilisation locale (importe Fondation ma_fonction_de_renommage) ?
- ajout des arbres aplatis aux noeuds codes déclarations
- documentation des instructions via kuri --manuel|-m inst
- type les expressions constantes (a :: 0x1) lors du parsage ?
- supprime les arbres aplatis et utilise un autre algorithme pour stopper/arrêter la compilation ?
    perte de l'arbre aplatis dans le code utilisateur

- ajout de noeud pour les valeurs des énumérations si ceux-ci ne sont pas explicitement déclarés (pour permettre les emplois d'énumérations)
- ajout des informations de positions dans le code source pour la RI
- utilise un noeud de déclaration de variable quand nous parsons une variable (a : z32) au lieu de modifier l'expression à la fin (nous permettant de supprimer expression_type du noeud de base)
- vérifie les appels superflux à empile_valeur (expr appel, transforme valeur)
- considère supprimer noeud_expression_appel::noeud_déclaration_appel (surécris appele?)
- transforme l'arbre syntaxique pour simplifier la validation sémantique ou la génération de RI (p.e. : remplace les boucles par des boucles pour) ?
---- a += 1 -> a = a + 1
---- a + b, où + est un opérateur surchargé -> appel(a, b)
---- -a, où - est un opérateur surchargé -> appel(a)


À faire (architecture)
----------------------
- préparsage pour construire une table de symbole (la table ne sera pas nécessaire si nous parsons uniquement les fonctions lors des appels ou des directives d'exécution)
- utilisation de plusieurs tacheronnes (en cours)
- génération de code sur plusieurs threads (LLVM -> un module par thread + liaison finale de tous les modules)
- réduction des allocations
- déplace la génération de la fonction main dans une unité de compilation
- parser les expressions se finissant par une virgule (f(x,)) ; peut simplifier la métaprogrammation

À faire (32-bits)
-----------------
- version des biblithèques sur 32-bit (définir une convention de nommage)
- proprement définir les types (taille des entiers et des pointeurs)


Idées
-----
- opérateur 'chaîne' pour retourner une chaîne de caractère contenant ce qu'il y a entre ses parenthèses : par exemple chaîne(a) -> "a"
- utilisation de propriétés pour appeler un code avant ou après une fonction à chaque qu'elle est appelée (comme ctor/dtor en C++, ou les gestionnaires de contextes en Python avec "with")
- fonction membres de structures similaire à Python avec 'self' explicit, ou appel explicit en passant l'objet en premier paramètre
- passer uniquement par référence, ou utilisation d'un mot-clé spécifique pour dire qu'un paramètre peut-être nul
- mot-clés pour un mutli-threading par système de tâches concurrentes, avec maintenance des fonctions auxilliaires par le compileur
- transformer les messages d'erreur en tutoriaux
- ajout de nom et valeur par défaut au type de retour
- constructeurs/destructeurs via mot-clés et pointeurs de fonction
- concaténation des chaînes littérales connues lors de la compilation via l'opérateur '+'
- opérateurs prenant des listes :
	a += (c, d, e, f, g, h, i, j)

	équivalent à

	a += b + c + d + e + f + g

	si a == (c, d, e, f, g, h, i, j) {

	}

	équivalent à

	si a == c || a == d || a == e ... {

	}

	comment pour a && c

lit + var
var + lit
lit + lit

- controler la génération d'exécutable depuis les métaprogrammes

Zones d'ombres
--------------
- concurrence, moultfilage


// optimisations (avant la génération de code) :
// -- supression de code mort
// -- débouclement (tableau fixes, plages connues)
// -- évaluation d'expressions constantes

/: évaluation des conditions



À faire (tests)
---------------
- test caractère simple (assignation + modification)
- test opérateurs simple
- test mélanges types/nombres littéraux
- test @var[0]
- test chaine littérale, déclaration, assignement de pointeur et tableau
- test énumération
- test initialisation de structures lors des déclarations
- test surcharge de fonction
- test coroutine
- test valeurs de retours multiples

-- débogueur pour la machine virtuelle
-- langage pour les optimisations (remplacement d'instructions)

struct ApparieAtome {
    Règle
    Variable

    ApparieAtome *operande1;
    ApparieAtome *operande2;
};


(stocke a (ajt (charge a) 1)) -> (inc a)
(stocke a (sst (charge a) 1)) -> (dec a)
(mul a 2) -> (ajt a a)

/* a ^ b ^ a -> b */
(xor a (xor a b)) -> b

/* (a ^ b) | a */
(or (xor a b) a) -> (or a b)


auto apparie_variable_a = ...;
auto apperie_entier = cree_appariement(EST_ENTIER_CONSTANT, 1);
auto apparie_charge = cree_appariement(EST_CHARGE, apparie_variable_a);
auto apparie_ajoute = cree_appariement(EST_AJOUTE, apparie_charge, apparie_entier);
auto apparie_stocke = cree_appariement(EST_STOCKE, apparie_variable_a);

bool apparie(Appariement *appariement, Atome *atome)
{
    switch(appariement->genre) {
        case EST_STOCKE:
        {
            if (!atome->est_stocke()) {
                return false;
            }

            if (!apparie(appariement->operande1, atome->comme_stocke()->ou)) {
                return false;
            }

            if (!apparie(appariement->operande2, atome->comme_stocke()->valeur)) {
                return false;
            }

            break;
        }
        case EST_AJOUTE:
        {
            if (!atome->est_op_ajoute()) {
                return false;
            }

            if (!apparie(appariement->operande1, atome->comme_op_ajoute()->valeur_gauche)) {
                return false;
            }

            if (!apparie(appariement->operande2, atome->comme_op_ajoute()->valeur_droite)) {
                return false;
            }
        }
    }

    return true;
}
