
// --------------------------- Contexte Implicite

utilisation d'une référence pour passer le contexte entre les fonctions, nous devrons correctement gérer les références dans ce cas

utilisation d'une variable globale pour le contexte du thread principale

ajout de l'information de présence de contexte aux blocs afin de pouvoir définir si nous avons un contexte ou non

    fonction_sans_contexte :: fonc () #nulctx
    {
        contexte := __contexte_principal

        pousse_contexte contexte {
            fonction_avec_contexte()  // erreur de compilation
        }
    }

    pour les initialisation de structures, il nous faudra savoir là où la structure est initialisé si nous avons un contexte si une fonction utilisée dans l'initialisation requiers un tel contexte


// --------------------------- Fonctions

réétablir le retour de plusieurs valeurs

directive #procédure_d_appel pour trouver la surcharge d'une fonction
    a := #procédure_d_appel ma_fonction(5)  // renvoie le pointeur sur ma_fonction(z32)


// --------------------------- Polymorphie / Monophismisation

pouvoir instantier une fonction polymorphique lorsqu'on la passe à une autre

    ajoute :: fonc (a: $T, b : $T) -> $T
    {
        retourne a + b
    }

    fais_le :: fonc (a : z32, b : z32, f : fonc (z32, z32)(z32)) -> z32
    {
        retourne f(a, b)
    }

    fais_le(0, 5, ajoute) // ceci détecte que ajoute est une fonction polymorphique et l'instantie pour le bon type

lambdas

    x => x.nom // crée une fonction foo :: (x: $T) -> chaine { retourne x.nom }


avoir un système de détermination de contraintes pour les fonctions polymorphiques

    ajoute :: fonc (a: $T/TypeOuInterface) // force T à être un dérivé de TypeOuInterface
        comment faire pour contraindre sur des types scalaires (entier ou réél)

supporte les structures polymorphiques / gabarits

De Jorjala/attribut.kuri
// À FAIRE : définir une bonne interface pour accéder aux valeurs sans gabarits
//
// Idée tirée de JAI :
//
// déclaration d'un type gabarit    => x : $T
// déclaration d'une valeur gabarit => $x : T
// La valeur gabarit est l'équivalent des valeurs littérales des templates en C++
// template <int N>, mais en plus flexible
//
// Une instruction #bake sers à instantier les fonctions selon les valeurs gabarits
// par exemple (avec notre syntaxe)
//
// fonc nouveau_tableau_fixe($N : Type_de_N, x : $Type_du_tableau) : [N]$Type_du_tableau
// crée_tableau_dix_éléments = #cuis nouveau_tableau_fixe($N = 10)
//
// On peut alors appeler : crée_tableau_dix_éléments(z32) pour créer un [10]z32
//
// Pour les attributs nous pourrions avoir un système similaire
//
// fonc valeur(attr : *Attribut, index : z64, $Type_de_valeur : Type, $T : TypeAttribut)
//
// valeur_z32 = #cuis valeur(Type_de_valeur = z32, T = TypeAttribut.Z32)
// valeur_r32 = #cuis valeur(Type_de_valeur = r32, T = TypeAttribut.R32)
// ....
//
// Ceci pourrait aisément remplacer le combo template + macro utilisé en C++

currying
    #cuis_constantes ma_fonction(T = z32)  // crée une nouvelle fonction ou le paramètre polymorphique T est remplacé par le type z32
    #cuis_valeurs    ma_fonction(x = 5)  // crée une nouvelle fonction ou le paramètre x est remplacé par la constante 5


// --------------------------- Métaprogramme

crée une IPA pour les métaprogramme afin de simplifier leurs créations et exécution
    MachineVirtuelle::lance_métaprogramme

exécute plusieurs métaprogrammes à la fois
    système similaire à celui des systèmes d'exploitation (exécute le métaprogramme pendant X nanosecondes et passe au suivant)
    ou alors plusieurs tacheronnes
    dans tous les cas, il faudra n'exécuter qu'un seul métaprogramme à la fois pour ne pas modifier les globales

permet de modifier la valeur des globales via les métaprogrammes, la génération de code final devra pendre les valeurs se trouvant dans le code binaire
    complexe

directive #exécute dans les fonctions
    UnitéCompilation::attend_sur_métaprogramme(métaprogramme)
    tiré le résultat et son type
    le métaprogramme devra avoir des constantes comme entrée

vérifie que les entrées des métaprogrammes soit des constantes

directive #corps_texte pour définir le corps d'une fonction via un texte

    principale :: fonc () -> z32
    #corps_texte {
        retourne "retourne 0"
    }

// --------------------------- Opérateurs

considère la surchage pour '='

opérateurs implicites
	<= implicite si > ou (< et ==) est défini
	>= implicite si < ou (> et ==) est défini
	== implicite si != est défini
	!= implicite si == est défini

considère un opérateur pour convertir entre des types

    opérateur Type :: fonc (a: AutreType) -> Type


// --------------------------- Bas Fruitage

ajout d'une propriété "compte" aux énums pour trouver le nombre d'éléments de ceux-ci (remplacé par une constante)

ajout d'une propriété "pointeur" aux tableaux fixes pour obtenir le pointeur vers le premier élément (au lien de @x[0])

ajout de tranches pour les tableaux et les chaines

    chn1 := "une chaine"
    chn2 := chn1[ 4 ... chn.taille - 1 ] // nous donne "chaine"


// --------------------------- Types

ajout de types produits (tuples) avec accès par x.0, x.1, etc...

avoir un bon système d'alias de type, avec sûreté de typage, pour ne avoir à déclarer des structures ne contenant qu'un seul membre

    AdresseEmail :: struct {
        chn: chaine
    }

    AdresseEmail :: #alias chaine

typage un peu libre des énumérations

    ExtensionImageSupportée :: chaine {
        JPEG :: "jpeg"
        EXR  :: "exr"
    }

    peut-être pourrions nous reprendre les énums de Rust pour les unions nonsûres
    mais une énumération est sensé être un ensemble de constantes

évite de nommer les membres des unions sûres

    Union :: struct {
        Type1
        Type2
        Type3
    }

constructions de la table de types
    requiers d'avoir des fonctions d'initialisations pour tous les types

ajout d'un type pour les retours des fonctions, uniquement utilisé en interne pour simplifier la validation de typage ?

ajout d'un type pour les caractères, au lieu de z8 ou n32 (peut se faire via un alias, mais les chaines seraient brisées)

charge/données personnalisées pour les erreurs afin de transmettre plus de détails à la fonction appelante

erreur générique pouvant passer des erreurs de fonction à fonction

avoir une gestion de la correctitude de constance

utilise un type entier naturel pour les énums drapeaux, et vérifie que le type soit naturel si précisé par l'utilisateur


// --------------------------- Discriminations

avoir une meilleure sécurité de type pour les einis, via discr et un transtypage automatique

    discr e {
        ENTIER {
            // que faire pour la taille en octet
        }
        STRUCTURE {
            // ??
        }
    }

    le compilateur doit savoir le type lors de la compilation, peut-être avoir des outils avec la métaprogrammation et le polymorphisme

transtypage automatique les unions vers le type discriminée :

    discr u {
        z32 { u += 5 }
        r32 { u += 6.7 }
        ...
    }

possibilité d'avoir des appels de fonctions où le premier argument est celui discriminé

    discr chn {
        commence_par("abc") {  } // équivalent à commence_par(chn, "abc")
        finie_par("xyz") { }     // équivalent à finie_par(chn, "xyz")
    }

avoir un bon système d'appariement de motif :

    discr a {
        b | c {	} // équivalent à (a == b || b == c)
        etc.
    }

    utilisation de '_' comme caractère générique pouvant être n'importe quelle valeur


// --------------------------- Boucles

- amélioration boucle pour :
-- obtenir un pointeur via : pour * ...
-- inverse la direction via : pour inverse ...
-- controle la condition finale via : pour <= ...
-- itération sur plusieurs variables de même type
---- pour chn1, chn2 { ... }, la variable implicite sera un type produit accédé via it.N où N est un nombre



// --------------------------- Modules / Espaces de Noms

utilisation d'un fichier "module.kuri" pour définir le contenu d'un module, les fichiers à charger

emploie des énums "empl MonÉnum", pour directement accéder aux valeurs

// Garde trace des espaces de noms, mais permet l'utilisation des membres via empl

importe Fondation
empl Fondation

ou

empl importe Fondation

renomme un import
F :: importe Fondation


// --------------------------- Interfaces / Traits

MonInterface :: entreface {
    x :: fonc ()...
}

définis MonInterface pour X {
    x :: fonc ()
}

peut-être devrions-nous forcer l'utilisation de "définis" pour toutes les fonctions afin de simplifier la recherche de fonctions par syntaxe uniforme ?
voir Rust


// --------------------------- Optimisations / Génération de Code

force l'enlignage des fonctions via un mot-clé, peut être fait durant le typage ?

a := enligne ajoute(5, 6)


// --------------------------- Analyse Statique

!= || != => toujours vraie, avertissement

&& || => ambigüe, avertissement

|| && => idem

nombres littéraux :
-- définis la taille minimale naturel et relative
---- v < 128 => z8
---- v < 256 => n8, z16
---- v < 65536 => n16, z32, etc....


// --------------------------- Environnemnt / Autres

avoir un « runtime » par machine cible où nous implémentons les fonctions ou instructions n'étant pas disponible sur celle-ci (voir Zig)

asm enligné

instructions SIMD


- générateurs/coroutines permettant de reprendre une fonction là où l'on s'est arrêté comme le yield de Python
- stack canaries (coulisse LLVM)
- coroutines en dehors de boucles
- ajout d'une option pour controler la génération du code d'introspection/réflexion (il faut alors également exclure les einis)
-
- ajout d'un noeud syntaxique pour les imports (simplifiant la recherche de symboles dans les expressions de type A.B.C)
- renomme InfoType -> DescType, id_info -> Genre{Info|Desc} ?
- diffère_err pour différer un bloc si une erreur est retournée
- possibilité de déclarer une variable dans une condition (si a := foo() { ... })

- appel les fonctions d'initialisation pour les constructions de structure si un membre est une structure
- généralisation de l'utilisation de temporaires pour simplifier la génération de la RI, supprimant les cas spéciaux
-- paramètres des appels
- système de test unitaires
- normalisation de tous les types pour supprimer les unions et les entiers constants de la RI
- optimisations de l'accès aux membres des blocs (table de hachage avec tableau continu, en cours)
- pouvoir passer des expressions à exécuter à la ligne de commande (kuri -exec "..." fichier.kuri)
- considère parser les expressions se terminant par une virgule (p.e. f(x, ))
- ajout d'une fonction d'interface compilatrice pour rapporter une erreur depuis les métaprogrammes
- proprement définir ce qu'on doit faire si un métaprogramme demande un message alors qu'il n'a pas commencer à les intercepter
- nettoie la génération de code de création de contexte pour la fonction principale pour utiliser le noeud de la création de contexte du module Kuri
- avoir une manière de définir le module où nous ajoutons une chaine ou un fichier à la compilation
- utilisation de fonctions définies dans la compilatrice pour remplacer malloc, realloc, et free lors de l'exécution des métaprogrammes
- pouvoir utiliser un #! en début de fichier pour utiliser les programmes comme des scripts (cela compilera et exécutera l'exécutable ou alors juste les métaprogrammes, #! n'est pas cohérent sur toutes les plateformes...)


À faire (architecture)
----------------------
- préparsage pour construire une table de symbole (la table ne sera pas nécessaire si nous parsons uniquement les fonctions lors des appels ou des directives d'exécution)
- utilisation de plusieurs tacheronnes (en cours)
- génération de code sur plusieurs threads (LLVM -> un module par thread + liaison finale de tous les modules)
- réduction des allocations
- déplace la génération de la fonction main dans une unité de compilation


À faire (32-bits)
-----------------
- version des biblithèques sur 32-bit (définir une convention de nommage)
- proprement définir les types (taille des entiers et des pointeurs)


Idées
-----
- opérateur 'chaîne' pour retourner une chaîne de caractère contenant ce qu'il y a entre ses parenthèses : par exemple chaîne(a) -> "a"
- utilisation de propriétés pour appeler un code avant ou après une fonction à chaque qu'elle est appelée (comme ctor/dtor en C++, ou les gestionnaires de contextes en Python avec "with")
- fonction membres de structures similaire à Python avec 'self' explicit, ou appel explicit en passant l'objet en premier paramètre
- passer uniquement par référence, ou utilisation d'un mot-clé spécifique pour dire qu'un paramètre peut-être nul
- mot-clés pour un mutli-threading par système de tâches concurrentes, avec maintenance des fonctions auxilliaires par le compileur
- transformer les messages d'erreur en tutoriaux
- ajout de nom et valeur par défaut au type de retour
- constructeurs/destructeurs via mot-clés et pointeurs de fonction
- concaténation des chaînes littérales connues lors de la compilation via l'opérateur '+'
- opérateurs prenant des listes :
	a += (c, d, e, f, g, h, i, j)

	équivalent à

	a += b + c + d + e + f + g

	si a == (c, d, e, f, g, h, i, j) {

	}

	équivalent à

	si a == c || a == d || a == e ... {

	}

	comment pour a && c


déréférencement *
prend adresse &a
pointeur *z32

lit + var
var + lit
lit + lit

- controler la génération d'exécutable depuis les métaprogrammes

Zones d'ombres
--------------
- concurrence, moultfilage


// optimisations (avant la génération de code) :
// -- supression de code mort
// -- débouclement (tableau fixes, plages connues)
// -- évaluation d'expressions constantes

/: évaluation des conditions



À faire (tests)
---------------
- test caractère simple (assignation + modification)
- test opérateurs simple
- test mélanges types/nombres littéraux
- test @var[0]
- test chaine littérale, déclaration, assignement de pointeur et tableau
- test énumération
- test initialisation de structures lors des déclarations
- test surcharge de fonction
- test coroutine
- test valeurs de retours multiples
