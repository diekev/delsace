Étude pour supprimer les points virgules, enlever le superflux pour aérer le langage.

Les points virgules sont utilisés pour délimités les expressions dans le corps d'une fonction.

Mais certaines expressions sont délimités par d'autres caractères, comme un crochet fermant (`acces_tableau[expr]`), une accolade ouvrante (`si expr {`), ou encore une virgule ou parenthèse fermante (`appel(expr, expr)`).

Ces cas spéciaux font que l'analyse grammaticale du langage ne peut définir avec certitude un seul point de sortie de l'analyse d'expressions, et des comparaisons redondantes sont alors performées.

Qui plus est, nous devons prendre en compte les expressions malformées (`a = b c`).

On pourrait simplifier cette analyse en supprimant le point virgule, et en définissant non pas ce qui termine une expression, mais ce qui en commence, en se basant sur la bienforme d'une expression : on examine l'expression jusqu'à ce qu'elle soit malformée, le point de malforme constituant le début d'une nouvelle expression.

Ceci implique d'avoir une absolue non-ambiguité dans la grammaire et la syntaxe du langage. Les quelques ambiguités substiantes devront mené à des erreurs de compilations.

fin expression :
	soit
	retourne
	si
	{
	]
	,
	...
	) (si dans transtype, ou appel fonction)


arrête expression si

chaine   chaine  // x = a + b y = b + c
                 //          ^

littéral chaine  // x = a + 5 y = c + d
                 //          ^

chaine littéral  // erreur ? une littéral ne peut être assignée mais x = a + b 0 + ptr = a + c // ok

) chaine         // a = appel() b = c
                 //            ^

] chaine         // a = membre[0] b = c
                 //              ^

problème :
	appel de fonction, si l'expression contient un appel et est malformée, l'appel
	sera considérer comme étant une autre expression sans erreur de compilation

	soit a = 1 printf("")

	solution : interdire l'appel de fonction dont la valeur de retour n'est pas utilisé

problème :
	la prise d'adresse

	soit a = @b @c # voulait @b == @c

	solution : vérifier que si le dernier morceau était un opérateur
	solution : interdire une expression droite dont la valeur n'est pas utilisée

problème :
	instance de gabarits avec type

	soit a = mon_garbarit(b, c, d)(z32, r32, n32)

	on ne peut dire avec certitude que le deuxième groupe de paramètres est un ensemble de type pour le garbarit

	solution :
		soit a = mon_gabarit(b : z32, c : r32, d : n32)

problème :
	instance de gabarits sans type

	fonction gabarit(D : z32) bruit_perlin() : r32
	{
		...
	}

	bruit_perlin()(D = 0)

	solution possible :
		Un tel gabarit est principalement là pour créer des fonctions spéciales, ou plutôt des fonctions dont le corps est spécialisé, ce qui force le compilateur à devoir déduire la bonne fonction selon les paramètres. On pourrait avoir des paramètres strictement constants, et forcer le compilateur à vérifier la constance des arguments passés lors de l'appel. Il faudrait que le compilateur puisse également propager la valeur lors de l'instantiation de la fonction.

		fonction bruit_perlin(constante D : z32) : z32 # force le compilateur à vérifier que D est une constante présent lors de la compilation, et instantie la fonction pour la valeur du paramètre

