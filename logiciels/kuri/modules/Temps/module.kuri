importe Fondation
importe GlibC

Instantané :: struct {
    seconde: z64
    nanoseconde: z64
}

// Retourne le temps monotonic du système
maintenant :: fonc () -> Instantané
{
    t : timespec
    // @erreur
    _ := clock_gettime(CLOCK_MONOTONIC_COARSE, *t)

    inst : Instantané
    inst.seconde = t.tv_sec
    inst.nanoseconde = t.tv_nsec

    retourne inst
}

// Retourne le temps monotonic du système
maintenant_précis :: fonc () -> Instantané
{
    t : timespec
    // @erreur
    _ := clock_gettime(CLOCK_MONOTONIC, *t)

    inst : Instantané
    inst.seconde = t.tv_sec
    inst.nanoseconde = t.tv_nsec

    retourne inst
}

millisecondes :: fonc (inst: Instantané) -> z64
{
    retourne inst.seconde * 1_000 + inst.nanoseconde / 1_000_000
}

microsecondes :: fonc (inst: Instantané) -> z64
{
    retourne inst.seconde * 1_000_000 + inst.nanoseconde / 1_000
}

nanosecondes :: fonc (inst: Instantané) -> z64
{
    retourne inst.seconde * 1_000_000_000 + inst.nanoseconde
}

temps_écoulé_secondes :: fonc (inst: Instantané) -> z64
{
    m := maintenant().seconde
    retourne m - inst.seconde
}

temps_écoulé_microsecondes :: fonc (inst: Instantané) -> z64
{
    m := maintenant_précis().microsecondes()
    retourne m - microsecondes(inst)
}

TempsSystème :: struct {
    seconde: z64
    nanoseconde: z64
}

maintenant_système :: fonc () -> TempsSystème
{
    t : timespec
    // @erreur
    _ := clock_gettime(CLOCK_REALTIME_COARSE, *t)

    temps : TempsSystème
    temps.seconde = t.tv_sec
    temps.nanoseconde = t.tv_nsec

    retourne temps
}

maintenant_système_précis :: fonc () -> TempsSystème
{
    t : timespec
    // @erreur
    _ := clock_gettime(CLOCK_REALTIME, *t)

    temps : TempsSystème
    temps.seconde = t.tv_sec
    temps.nanoseconde = t.tv_nsec

    retourne temps
}

millisecondes :: fonc (temps: TempsSystème) -> z64
{
    retourne temps.seconde * 1_000 + temps.nanoseconde / 1_000_000
}

secondes_par_an :: fonc () -> z32
{
    retourne 31_556_952
}

Date :: struct {
    année : z32
    mois : z32
    jour : z32
    jour_semaine : z32

    heure : z32
    minute : z32
    seconde : z32
}

est_année_bissextile :: fonc (année: z64) -> bool
{
    si (année % 100 == 0) {
        si (année % 400 == 0) {
            retourne vrai
        }

        retourne faux
    }

    retourne (année % 4 == 0)
}

hui_système :: fonc () -> Date
{
    inst := maintenant_système();

    seconde := inst.seconde % 60
    minutes := (inst.seconde / 60) % 60
    heures  := (inst.seconde / 3600) % 24

    années := (inst.seconde / secondes_par_an())

    jours_par_mois := [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

    si est_année_bissextile(années) {
        jours_par_mois[1] = 29
    }

    secondes_mois := (inst.seconde - (années * secondes_par_an()))
    secondes_écoulées_mois := 0
    mois := 0

    pour j dans jours_par_mois {
        si secondes_mois < (28 * 24 * 60 * 60) {
            arrête
        }

        secondes_écoulées_mois += j * 24 * 60 * 60
        secondes_mois -= j * 24 * 60 * 60
        mois += 1
    }

    jours := (inst.seconde - (années * secondes_par_an()) - (secondes_écoulées_mois)) / (24 * 60 * 60)

    // On soustrait 3 car Epoch UTC commence un jeudi (4ème jour, index 3)
    jour_semaine := ((inst.seconde / (3600 * 24)) - 3) % 7

    date : Date
    date.jour = jours comme z32
    date.mois = mois
    date.année = années comme z32 + 1970
    date.heure = heures comme z32
    date.minute = minutes comme z32
    date.seconde = seconde comme z32
    date.jour_semaine = jour_semaine comme z32

    retourne date
}

/*
  formattage date :
    - A : année
    - M : mois
    - J : jour
    - h : heure
    - m : minute
    - s : seconde
*/
formatte :: fonc (date: &Date, format: chaine) -> chaine
{
    i : z64 = 0

    enchaineuse : Enchaineuse
    initialise_enchaineuse(*enchaineuse)

    tantque i < format.taille {
        si format[i] == '%' {
            i += 1

            c := format[i]

            discr c {
                'A' {
                    ajoute_au_tampon(*enchaineuse, date.année)
                }
                'M' {
                    ajoute_au_tampon(*enchaineuse, date.mois + 1)
                }
                'J' {
                    ajoute_au_tampon(*enchaineuse, date.jour)
                }
                'h' {
                    ajoute_au_tampon(*enchaineuse, date.heure)
                }
                'm' {
                    ajoute_au_tampon(*enchaineuse, date.minute)
                }
                's' {
                    ajoute_au_tampon(*enchaineuse, date.seconde)
                }
                sinon {
                    continue
                }
            }

            i += 1
            continue
        }

        chn := construit_chaine(*format[i], 1)
        ajoute_au_tampon(*enchaineuse, chn)

        i += 1
    }

    retourne chaine_depuis_enchaineuse(*enchaineuse)
}

parse_date :: fonc (chaine_date: chaine, format: chaine) -> Date
{
    résultat : Date

    si chaine_date.taille != format.taille {
        retourne résultat
    }


    pour format {
        c := chaine_date[index_it]

        discr it {
            'A' {
                résultat.année *= 10
                résultat.année += (c - '0') comme z32
            }
            'M' {
                résultat.mois *= 10
                résultat.mois += (c - '0') comme z32
            }
            'J' {
                résultat.jour *= 10
                résultat.jour += (c - '0') comme z32
            }
            'h' {
                résultat.heure *= 10
                résultat.heure += (c - '0') comme z32
            }
            'm' {
                résultat.minute *= 10
                résultat.minute += (c - '0') comme z32
            }
            's' {
                résultat.seconde *= 10
                résultat.seconde += (c - '0') comme z32
            }
            sinon {
                continue
            }
        }
    }

    résultat.mois -= 1

    retourne résultat
}

// ---------------------------------------------------
// Tests

importe Compilatrice

#test {
    date := parse_date("2020/11/22 6:37:20", "AAAA/MM/JJ h:mm:ss")

    compilatrice_vérifie_égalité(date.jour, 22)
    compilatrice_vérifie_égalité(date.mois, 10)
    compilatrice_vérifie_égalité(date.année, 2020)
    compilatrice_vérifie_égalité(date.heure, 6)
    compilatrice_vérifie_égalité(date.minute, 37)
    compilatrice_vérifie_égalité(date.seconde, 20)
}

// À FAIRE(langage) : crash dans la génération des types de fonctions pour le métaprogramme quand nous avons des instructions déloge
#test {
    date := parse_date("2020/11/22 6:37:20", "AAAA/MM/JJ h:mm:ss")

    résultat := date.formatte("%h:%m:%s")
    compilatrice_vérifie_égalité(résultat, "6:37:20")
    // déloge résultat

    résultat = date.formatte("%J/%M/%A")
    compilatrice_vérifie_égalité(résultat, "22/11/2020")
    // déloge résultat

    résultat = date.formatte("%J/%M/%A %h:%m:%s")
    compilatrice_vérifie_égalité(résultat, "22/11/2020 6:37:20")
    // déloge résultat

    résultat = date.formatte("%h:%m:%s %J/%M/%A")
    compilatrice_vérifie_égalité(résultat, "6:37:20 22/11/2020")
    // déloge résultat
}
