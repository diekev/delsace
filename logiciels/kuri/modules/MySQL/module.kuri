importe Fondation
importe JSON
importe Introspection

ConfigurationMySQL :: struct {
	// @note : l'hôte doit être une adresse IP
	hôte : chaine
	utilisateur : chaine
	mot_de_passe : chaine
	base_de_données : chaine
}

ErreurPiloteMySQL :: erreur {
	XXX
}

PiloteMySQL :: struct {
	config: ConfigurationMySQL
	fonctions_parsage : []FonctionParsage
}

ConnexionMySQL :: struct {
	mysql : MYSQL
}

ferme_connexion :: fonc (connexion: *ConnexionMySQL) -> rien
{
	mysql_close(*connexion.mysql)
}

ErreurConnexionMySQL :: erreur {
	MémoireInsuffisante
	MauvaiseConnexion
}

RésultatConnexionMySQL :: union {
	e: ErreurConnexionMySQL
	c: ConnexionMySQL
}

crée_pilote_mysql :: fonc (fichier_config: chaine) -> PiloteMySQL | ErreurPiloteMySQL
{
	succès, config := parse_struct_depuis_fichier_json(fichier_config, ConfigurationMySQL)

	si !succès {
		imprime_log("[MySQL]", "impossible de parser la configuration\n")
		retourne ErreurPiloteMySQL.XXX
	}

	pilote : PiloteMySQL
	pilote.config = config
	initalise_types_base(*pilote.fonctions_parsage)

	retourne pilote
}

ajoute_fonction_parsage :: fonc (pilote: &PiloteMySQL, info: *InfoType, rappel: fonc(chaine, []octet)(bool))
{
	ajoute_fonction(*pilote.fonctions_parsage, info, rappel)
}

/* Retourne les noms des tables dans la base de données du pilote. */
requiers_tables_mysql :: fonc (pilote: *PiloteMySQL) -> []chaine
{
	résultat : []chaine

	connexion := tente crée_connexion(pilote) piège err {
		retourne résultat
	}

	diffère { ferme_connexion(*connexion) }

	curseur := exécute(*connexion, "SHOW TABLES")

	tantque ligne_suivante(*curseur) != nul {
		pour i dans 0 ... curseur.nombre_colonne - 1 {
			chn := colonne_suivante(*curseur)
			tableau_ajoute(*résultat, chn)
		}
	}

	retourne résultat
}

crée_connexion :: fonc (pilote: *PiloteMySQL) -> RésultatConnexionMySQL
{
	mysql : MYSQL
	handler := mysql_init(*mysql)

	_ := mysql_set_character_set(*mysql, "utf8".pointeur)

    // handler ne peut être nul que si le paramètre passé à mysql_init est nul, auquel cas une allocation aura lieu
    si handler == nul {
        imprime_log("[MySQL]", "impossible d'allouer de la mémoire pour l'initialisation de MySQL !\n")
        retourne ErreurConnexionMySQL.MémoireInsuffisante
    }

	marque := obtiens_marque_stockage_temporaire()
	diffère { set_marque_stockage_temporaire(marque) }

	hôte := chaine_c_temp(pilote.config.hôte)
	utilisateur := chaine_c_temp(pilote.config.utilisateur)
	mot_de_passe := chaine_c_temp(pilote.config.mot_de_passe)
	base_de_données := chaine_c_temp(pilote.config.base_de_données)

	c := mysql_real_connect(*mysql, hôte, utilisateur, mot_de_passe, base_de_données, 0, nul, 0);

	si (c == nul) {
		e := mysql_error(*mysql)
		chn := converti_chaine_c(e)
		imprime_log("[MySQL]", "erreur lors de la connexion : %\n", chn);
		retourne ErreurConnexionMySQL.MauvaiseConnexion
	}

	connexion : ConnexionMySQL
	connexion.mysql = mysql

	retourne connexion
}

CurseurRésultat :: struct {
	résultat : *MYSQL_RES

	longueurs : *n64
	ligne : **z8

	nombre_résultat : n64
	nombre_colonne : n32
	index_colonne : n32
}

détruit_curseur :: fonc (curseur : *CurseurRésultat) -> rien
{
	mysql_free_result(curseur.résultat)
}

// À FAIRE : erreur
exécute :: fonc (connexion: *ConnexionMySQL, chaine_requête: chaine) -> CurseurRésultat
{
	curseur : CurseurRésultat

	requête := chaine_c_temp(chaine_requête)
	succès := mysql_query(*connexion.mysql, requête)

	imprime_log("[MySQL]", "exécution de la requête : %\n", chaine_requête)

	si succès != 0 {
		e := mysql_error(*connexion.mysql)

		si e != nul {
			chn := converti_chaine_c(e)
			imprime_log("[MySQL]", "Une erreur est survenue lors de la requête : % !\n", chn)
		}

		retourne curseur
	}

	résultat := mysql_store_result(*connexion.mysql)

	si résultat == nul {
		/* ces types de requête ne retournent aucune donnée */
		saufsi commence_par(chaine_requête, "INSERT", "UPDATE") {
			e := mysql_error(*connexion.mysql)

			si e != nul {
				chn := converti_chaine_c(e)
				imprime_log("[MySQL]", "Une erreur est survenue lors du stockage du résultat : % !\n", chn)
			}
		}

		retourne curseur
	}

	nombre_résultat := mysql_num_rows(résultat)
	nombre_champs := mysql_num_fields(résultat);

	curseur.résultat = résultat
	curseur.nombre_colonne = nombre_champs
	curseur.nombre_résultat = nombre_résultat

	retourne curseur
}

ligne_suivante :: fonc (curseur: *CurseurRésultat) -> **z8
{
	si curseur.résultat == nul {
		retourne nul
	}

	ligne := mysql_fetch_row(curseur.résultat)

	curseur.index_colonne = 0
	curseur.ligne = ligne
	curseur.longueurs = mysql_fetch_lengths(curseur.résultat)

	retourne ligne
}

colonne_suivante :: fonc (curseur: *CurseurRésultat) -> chaine
{
	chn := construit_chaine(curseur.ligne[curseur.index_colonne], curseur.longueurs[curseur.index_colonne] comme z64)
	curseur.index_colonne += 1
	retourne chn
}

accède_table :: fonc (pilote: *PiloteMySQL, nom: chaine) -> TableMySQL
{
	table : TableMySQL
	table.nom = nom
	table.pilote = pilote
	retourne table
}

TableMySQL :: struct {
	nom : chaine
	pilote : *PiloteMySQL
}

trouve_info_membres_pour_colonnes :: fonc (agent: chaine, info: *InfoTypeStructure, colonnes: ...chaine) -> []*InfoTypeMembreStructure
{
	infos_membres : []*InfoTypeMembreStructure

	/* vérifie que le type possède les noms des colonnes */
	pour colonnes {
		pour membre dans info.membres {
			si membre.nom == it {
				tableau_ajoute(*infos_membres, membre)
				arrête
			}
		}
		sansarrêt {
			imprime_log(agent, "le type ne possède pas la colonne % !\n", it)
			déloge(infos_membres)
			retourne infos_membres
		}
	}

	retourne infos_membres
}

sélectionne :: fonc (table: &TableMySQL, $T: type_de_données, colonnes: ...chaine) -> []T
{
	#assert info_de(T).id == id_info.STRUCTURE

	résultat : []T
	info := info_de(T)

	// À FAIRE : vérifie que la table possède les noms des colonnes

	infos_membres := trouve_info_membres_pour_colonnes("[MySQL.sélection]", info, ...colonnes)

	saufsi infos_membres {
		imprime_log("[MySQL]", "colonne(s) manquante(s) pour la sélection\n")
		retourne résultat
	}

	diffère { déloge(infos_membres) }

	/* construit la chaine de la requête */
	enchaineuse : Enchaineuse
	initialise_enchaineuse(*enchaineuse)

	ajoute_au_tampon(*enchaineuse, "SELECT ")

	virgule := ""
	pour colonnes {
		ajoute_au_tampon(*enchaineuse, virgule, it)
		virgule = ", "
	}

	ajoute_au_tampon(*enchaineuse, " FROM ", table.nom, "")

	requête := chaine_depuis_enchaineuse(*enchaineuse)
	diffère { déloge(requête) }

	/* tente de nous connecté à la base de données */
	connexion := tente crée_connexion(table.pilote) piège err {
		retourne résultat
	}
	diffère { ferme_connexion(*connexion) }

	/* exécute la requête et construit le résultat */
	curseur := exécute(*connexion, requête)
	diffère { détruit_curseur(*curseur) }

	si (curseur.nombre_colonne comme z64) != colonnes.taille {
		retourne résultat
	}

	tantque ligne_suivante(*curseur) != nul {
		valeur : T

		eini_valeur : eini = valeur

		pour i dans 0 ... curseur.nombre_colonne - 1 {
			membre := infos_membres[i]

			valeur_membre : eini = ---
			valeur_membre.pointeur = eini_valeur.pointeur + membre.décalage
			valeur_membre.info = membre.id

			fonction := trouve_fonction_pour_type(table.pilote.fonctions_parsage, membre.id)

			saufsi fonction {
				déloge(résultat)
				retourne résultat
			}

			chn := colonne_suivante(*curseur)

			tampon : []octet
			tampon.pointeur = valeur_membre.pointeur comme *z8
			tampon.taille = membre.id.taille_en_octet comme z64

			saufsi fonction.rappel(chn, tampon) {
				déloge(résultat)
				retourne résultat
			}
		}

		tableau_ajoute(*résultat, valeur)
	}

	retourne résultat
}

insère :: fonc (table: &TableMySQL, valeur: $T, colonnes: ...chaine) -> bool
{
	#assert info_de(T).id == id_info.STRUCTURE

	info := info_de(T)

	// À FAIRE : vérifie que la table possède les noms des colonnes

	infos_membres := trouve_info_membres_pour_colonnes("[MySQL.sélection]", info, ...colonnes)

	saufsi infos_membres {
		imprime_log("[MySQL]", "colonne(s) manquante(s) pour la sélection\n")
		retourne faux
	}

	diffère { déloge(infos_membres) }

	enchaineuse : Enchaineuse
	initialise_enchaineuse(*enchaineuse)

	ajoute_au_tampon(*enchaineuse, "INSERT INTO ", table.nom)

	virgule := " ("
	pour colonnes {
		ajoute_au_tampon(*enchaineuse, virgule, it)
		virgule = ", "
	}

	ajoute_au_tampon(*enchaineuse, ") VALUES ")

	virgule = " ("
	pour membre dans infos_membres {
		valeur_membre : eini = ---
		valeur_membre.pointeur = *valeur comme *z8 + membre.décalage
		valeur_membre.info = membre.id

		ajoute_au_tampon(*enchaineuse, virgule)
		imprime_valeur(*enchaineuse, valeur_membre, vrai)
		virgule = ", "
	}

	ajoute_au_tampon(*enchaineuse, ")")

	requête := chaine_depuis_enchaineuse(*enchaineuse)
	diffère { déloge(requête) }

	/* tente de nous connecté à la base de données */
	connexion := tente crée_connexion(table.pilote) piège err {
		retourne faux
	}
	diffère { ferme_connexion(*connexion) }

	/* exécute la requête */
	curseur := exécute(*connexion, requête)
	diffère { détruit_curseur(*curseur) }

	retourne vrai
}
