importe Fondation

/* Génération du code Kuri à partir des données du module. */

/* Retourne vrai si le type peut avoir des accesseurs ou mutateurs. */
type_supporte_getset :: fonc (type: *TypePython) -> bool
{
    si type.confidentialité == ConfidentialitéType.OPAQUE {
        retourne faux
    }

    si type.drapeaux.TYPE_EST_ÉNUM || type.drapeaux.TYPE_EST_TABLEAU || type.drapeaux.TYPE_EST_ITÉRATEUR {
        retourne faux
    }

    si type.membres.taille == 0 {
        /* Inutile de générer du code pour types n'ayant pas de membres. */
        retourne faux
    }

    retourne vrai
}

/* Génère les méthodes pour accéder et muter les membres du type. Retourne la globales où les méthodes sont initialisés. */
génère_méthodes_getset_pour_type :: fonc (enchaineuse: *Enchaineuse, type: *TypePython) -> chaine
{
    saufsi type_supporte_getset(type) {
        retourne copie_chaine("")
    }

    /* Déclare les fonctions get/set. */
    pour type.membres {
        type_membre := it.type
        // get : fonc (*PyObject, *rien)(*PyObject)

        enchaineuse.ajoute_au_tampon("get_", type.nom_sauf, "_", it.nom, " :: fonc (instance: *PyObject, closure: *rien@inutilisée) -> *PyObject\n")
        enchaineuse.ajoute_au_tampon("{\n")
        enchaineuse.ajoute_au_tampon("    notre_instance := (instance comme *", type.nom_sauf, "PourPython).notre_instance\n")

        si (type_membre.drapeaux & DrapeauxType.TYPE_EST_UNION) != 0 {
            enchaineuse.ajoute_au_tampon("    discr notre_instance {\n")
            enchaineuse.ajoute_au_tampon("        ", it.nom, " {\n")
            enchaineuse.ajoute_au_tampon("            membre := notre_instance.", it.nom, "\n")
            enchaineuse.ajoute_au_tampon("            retourne ", type_membre.fonctions.pour_construction, "(membre)\n")
            enchaineuse.ajoute_au_tampon("        }\n")
            enchaineuse.ajoute_au_tampon("        sinon {\n")
            enchaineuse.ajoute_au_tampon("            retourne python_retourne_rien()\n")
            enchaineuse.ajoute_au_tampon("        }\n")
            enchaineuse.ajoute_au_tampon("    }\n")
        }
        sinon {
            enchaineuse.ajoute_au_tampon("    membre := notre_instance.", it.nom, "\n")
            enchaineuse.ajoute_au_tampon("    retourne ", type_membre.fonctions.pour_construction, "(membre)\n")
        }
        enchaineuse.ajoute_au_tampon("}\n")

        si it.confidentialité == ConfidentialitéType.MUTABLE {
            // set : fonc (*PyObject, *PyObject, *rien)(z32)
            // retourne 0 pour un succès
            // retourne -1 pour une erreur
            enchaineuse.ajoute_au_tampon("set_", type.nom_sauf, "_", it.nom, " :: fonc (instance: *PyObject, valeur: *PyObject, closure: *rien@inutilisée) -> z32\n")
            enchaineuse.ajoute_au_tampon("{\n")

            enchaineuse.ajoute_au_tampon("    si ", type_membre.fonctions.pour_discrimination, "(valeur) {\n")
            enchaineuse.ajoute_au_tampon("    notre_instance := *(instance comme *", type.nom_sauf, "PourPython).notre_instance\n")
            si it.type.drapeaux.TYPE_EST_ÉNUM {
                enchaineuse.ajoute_au_tampon("    si PyUnicode_Check(valeur) {\n")
                enchaineuse.ajoute_au_tampon("        notre_instance.", it.nom, " = ", type_membre.fonctions.pour_valeur_unicode_enum, "(valeur, info_de(", it.type.nom, ")) comme ", it.type.nom, "\n")
                enchaineuse.ajoute_au_tampon("    }\n")
                enchaineuse.ajoute_au_tampon("    sinon {\n")
                enchaineuse.ajoute_au_tampon("        notre_instance.", it.nom, " = ", type_membre.fonctions.pour_extraction_valeur, "(valeur).notre_instance\n")
                enchaineuse.ajoute_au_tampon("    }\n")
            }
            sinon si it.type.est_basique {
                enchaineuse.ajoute_au_tampon("    notre_instance.", it.nom, " = ", type_membre.fonctions.pour_extraction_valeur, "(valeur)\n")
            }
            sinon {
                enchaineuse.ajoute_au_tampon("    notre_instance.", it.nom, " = ", type_membre.fonctions.pour_extraction_valeur, "(valeur).notre_instance\n")
            }
            enchaineuse.ajoute_au_tampon("    retourne 0\n")
            enchaineuse.ajoute_au_tampon("    }\n")

            si it.type.drapeaux.TYPE_EST_ÉNUM {
assigne_énum_depuis_chaine := «
    si PyUnicode_Check(valeur) {
        valeur_chaine := PyUnicode_AsChaine(valeur)
        retourne Py_AssigneChaineÉnum((instance comme *%PourPython).notre_instance.%, valeur_chaine)
    }
»
                enchaineuse.imprime_dans_enchaineuse(assigne_énum_depuis_chaine, type.nom_sauf, it.nom)
            }

            enchaineuse.ajoute_au_tampon("    retourne PyErr_MauvaisTypeAssignement(valeur, \"", it.type.nom , "\")\n")
            enchaineuse.ajoute_au_tampon("}\n")
        }
    }

    nom_globale := enchaine("getset_", type.nom_sauf)

    /* Déclare la globale, nous devons ajouter un élément supplémentaire à la fin. */
    enchaineuse.imprime_dans_enchaineuse("% := [\n", nom_globale)

    pour type.membres {
        enchaineuse.imprime_dans_enchaineuse("    PyGetSetDef(name = crée_chaine_c(\"%\"), ", it.nom)
        enchaineuse.imprime_dans_enchaineuse("get = get_%_%, ", type.nom_sauf, it.nom)
        si it.confidentialité == ConfidentialitéType.MUTABLE {
            enchaineuse.imprime_dans_enchaineuse("set = set_%_%, ", type.nom_sauf, it.nom)
        }
        sinon {
            enchaineuse.ajoute_au_tampon("set = nul, ")
        }
        enchaineuse.imprime_dans_enchaineuse("doc = ChaineC(nul), ")
        enchaineuse.imprime_dans_enchaineuse("closure = nul),\n")
    }
    enchaineuse.imprime_dans_enchaineuse("    PyGetSetDef(name = ChaineC(nul), get = nul, set = nul, doc = ChaineC(nul), closure = nul)\n")
    enchaineuse.ajoute_au_tampon("]\n")

    retourne nom_globale
}

/* Retourne vrai si le type peut avoir être accéder via objet["clé"]. */
type_supporte_mapping :: fonc (type: *TypePython) -> bool
{
    /* Pour le moment la logique est la même que pour les accesseurs/mutateurs. */
    retourne type_supporte_getset(type)
}

génère_globale_as_mapping :: fonc (enchaineuse: *Enchaineuse, type: *TypePython) -> chaine
{
    saufsi type_supporte_mapping(type) {
        retourne copie_chaine("")
    }

    /* Génère la fonction pour PyMappingMethods.mp_length. */
    nom_fonction_mp_length := enchaine("mp_length_pour_", type.nom_sauf)
    diffère déloge(nom_fonction_mp_length)

    enchaineuse.ajoute_au_tampon(nom_fonction_mp_length, " :: fonc (self: *PyObject @inutilisée) -> Py_ssize_t\n")
    enchaineuse.imprime_dans_enchaineuse("{\nretourne %\n}\n", type.membres.taille)

    /* Génère la fonction pour PyMappingMethods.mp_subscript. */
    nom_fonction_mp_subscript := enchaine("mp_subscript_pour_", type.nom_sauf)
    diffère déloge(nom_fonction_mp_subscript)

    enchaineuse.ajoute_au_tampon(nom_fonction_mp_subscript, " :: fonc (self: *PyObject, key: *PyObject) -> *PyObject\n")
    enchaineuse.ajoute_au_tampon("{\n    nom_membre := PyUnicode_AsChaine(key)\n")

    possède_membre_mutable := faux

    pour type.membres {
        enchaineuse.ajoute_au_tampon("    si nom_membre == \"", it.nom ,"\" {\n")
        enchaineuse.ajoute_au_tampon("         retourne get_", type.nom_sauf,"_", it.nom, "(self, nul)\n")
        enchaineuse.ajoute_au_tampon("    }\n")

        si it.confidentialité == ConfidentialitéType.MUTABLE {
            possède_membre_mutable = vrai
        }
    }

    enchaineuse.ajoute_au_tampon("     retourne PyErr_CléInconnue(self, nom_membre)\n")
    enchaineuse.ajoute_au_tampon("}\n")

    /* Génère la fonction pour PyMappingMethods.mp_ass_subscript. */
    nom_fonction_mp_ass_subscript := "nul"
    diffère si nom_fonction_mp_ass_subscript != "nul" { déloge(nom_fonction_mp_ass_subscript) }

    si possède_membre_mutable {
        nom_fonction_mp_ass_subscript = enchaine("mp_ass_subscript_pour_", type.nom)

        enchaineuse.ajoute_au_tampon(nom_fonction_mp_ass_subscript, " :: fonc (self: *PyObject, key: *PyObject, v: *PyObject) -> z32\n")
        enchaineuse.ajoute_au_tampon("{\n    nom_membre := PyUnicode_AsChaine(key)\n")
        enchaineuse.ajoute_au_tampon("    si v == nul {\n")
        enchaineuse.ajoute_au_tampon("        retourne PyErr_AttributNonSupprimable(self, nom_membre)\n")
        enchaineuse.ajoute_au_tampon("    }\n")

        pour type.membres {
            enchaineuse.ajoute_au_tampon("    si nom_membre == \"", it.nom ,"\" {\n")
            si it.confidentialité == ConfidentialitéType.MUTABLE {
                enchaineuse.ajoute_au_tampon("         retourne set_", type.nom_sauf,"_", it.nom, "(self, v, nul)\n")
            }
            sinon {
                enchaineuse.ajoute_au_tampon("         retourne PyErr_AttributNonMutable(self, nom_membre)\n")
            }
            enchaineuse.ajoute_au_tampon("    }\n")
        }
        enchaineuse.ajoute_au_tampon("     _ := PyErr_CléInconnue(self, nom_membre)\n retourne -1\n")
        enchaineuse.ajoute_au_tampon("}\n")
    }

    /* Génère la globale. */
    nom_globale := enchaine("py_mapping_methods_pour_", type.nom_sauf)

    enchaineuse.ajoute_au_tampon(nom_globale, " := PyMappingMethods (", nom_fonction_mp_length, ", ", nom_fonction_mp_subscript,", ", nom_fonction_mp_ass_subscript, ")\n")

    retourne nom_globale
}

génère_fonction_new :: fonc (enchaineuse: *Enchaineuse, type: *TypePython) -> chaine
{
    méthode := type.new

    saufsi méthode.nom {
        retourne copie_chaine("")
    }

    nom_fonction_new := enchaine("new_", type.nom_sauf)

    args_inutilisés := ""
    saufsi méthode.paramètres_entrée {
        args_inutilisés = " @inutilisée"
    }

    enchaineuse.ajoute_au_tampon(nom_fonction_new, " :: fonc (subtype: *PyTypeObject, args: *PyObject", args_inutilisés, ", kwds: *PyObject @inutilisée) -> *PyObject\n")
    enchaineuse.ajoute_au_tampon("{\n")

    /* Parse les arguments. */
    génère_parsage_args_tuple(enchaineuse, méthode, "nul")

    /* Appel la fonction d'initialisation. */
    génère_conversion_args_vers_kuri(enchaineuse, méthode)

    si type.drapeaux.TOUJOURS_COMME_POINTEUR {
        enchaineuse.ajoute_au_tampon("    résultat := loge(", type.nom, ")\n")
        enchaineuse.ajoute_au_tampon("    succès := ")
        génère_appel_méthode_kuri(enchaineuse, méthode, "résultat")
    }
    sinon {
        enchaineuse.ajoute_au_tampon("    résultat :", type.nom, "\n")
        enchaineuse.ajoute_au_tampon("    succès := ")
        génère_appel_méthode_kuri(enchaineuse, méthode, "*résultat")
    }

    enchaineuse.ajoute_au_tampon("    saufsi succès {\n")
    enchaineuse.ajoute_au_tampon("        retourne nul\n")
    enchaineuse.ajoute_au_tampon("    }\n")

    /* Crée un objet python correspondant, et retourne. */
    enchaineuse.ajoute_au_tampon("    objet_résultat := subtype.tp_alloc(subtype, 0) comme *", type.nom_sauf, "PourPython\n")
    enchaineuse.ajoute_au_tampon("    objet_résultat.notre_instance = résultat\n")
    enchaineuse.ajoute_au_tampon("    retourne objet_résultat\n")
    enchaineuse.ajoute_au_tampon("}\n")

    retourne nom_fonction_new
}

génère_fonction_str :: fonc (enchaineuse: *Enchaineuse, type: *TypePython) -> chaine
{
    méthode := type.str

    saufsi méthode.nom || type.drapeaux.TYPE_EST_ÉNUM {
        retourne copie_chaine("")
    }

    nom_fonction_str := enchaine("str_", type.nom_sauf)

    // doit retourner un PyUnicodeObject
    enchaineuse.ajoute_au_tampon(nom_fonction_str, ":: fonc (self: *PyObject) -> *PyObject\n")
    enchaineuse.ajoute_au_tampon("{\n")
    enchaineuse.ajoute_au_tampon("    notre_instance := ", type.fonctions.pour_extraction_valeur, "(self).notre_instance\n")
    si type.drapeaux.TYPE_EST_ÉNUM {
        enchaineuse.ajoute_au_tampon("    info_énum := info_de(", type.nom, ")\n")
        enchaineuse.ajoute_au_tampon("    résultat := donne_nom_énum_pour_valeur(info_énum, notre_instance comme z32)\n")
    }
    sinon {
        enchaineuse.ajoute_au_tampon("    résultat := ", méthode.nom, "(*notre_instance)\n")
    }
    enchaineuse.ajoute_au_tampon("    retourne PyUnicode_FromChaine(résultat)\n")
    enchaineuse.ajoute_au_tampon("}\n")

    retourne nom_fonction_str
}

/* https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_hash */
génère_fonction_hash :: fonc (enchaineuse: *Enchaineuse, type: *TypePython) -> chaine
{
    méthode := type.hash

    si méthode.nom {
        nom_fonction_hash := enchaine("hash_", type.nom_sauf)

        enchaineuse.ajoute_au_tampon(nom_fonction_hash, ":: fonc (self: *PyObject) -> Py_hash_t\n")
        enchaineuse.ajoute_au_tampon("{\n")
        enchaineuse.ajoute_au_tampon("    notre_instance := ", type.fonctions.pour_extraction_valeur, "(self).notre_instance\n")
        enchaineuse.ajoute_au_tampon("    résultat := ", méthode.nom, "(*notre_instance)\n")
        enchaineuse.ajoute_au_tampon("    retourne résultat\n")
        enchaineuse.ajoute_au_tampon("}\n")

        retourne nom_fonction_hash
    }

    /* Pour les énums, nous retournons simplement la valeur, qui est sensée être unique. */
    si type.drapeaux.TYPE_EST_ÉNUM {
        nom_fonction_hash := enchaine("hash_", type.nom_sauf)

        enchaineuse.ajoute_au_tampon(nom_fonction_hash, ":: fonc (self: *PyObject) -> Py_hash_t\n")
        enchaineuse.ajoute_au_tampon("{\n")
        enchaineuse.ajoute_au_tampon("    notre_instance := ", type.fonctions.pour_extraction_valeur, "(self).notre_instance\n")
        enchaineuse.ajoute_au_tampon("    retourne notre_instance comme z32\n") // À FAIRE : type sous-jacent vers Py_hash_t
        enchaineuse.ajoute_au_tampon("}\n")

        retourne nom_fonction_hash
    }

    /* Pour les types étant toujours stockés par adresse, nous pouvons utilisé l'adresse comme empreinte. */
    si type.drapeaux.TOUJOURS_COMME_POINTEUR {
        nom_fonction_hash := enchaine("hash_", type.nom_sauf)

        enchaineuse.ajoute_au_tampon(nom_fonction_hash, ":: fonc (self: *PyObject) -> Py_hash_t\n")
        enchaineuse.ajoute_au_tampon("{\n")
        enchaineuse.ajoute_au_tampon("    notre_instance := ", type.fonctions.pour_extraction_valeur, "(self).notre_instance\n")
        enchaineuse.ajoute_au_tampon("    retourne notre_instance comme z64\n")
        enchaineuse.ajoute_au_tampon("}\n")

        retourne nom_fonction_hash
    }

    /* PyObject_HashNotImplemented doit être utilisé afin de pouvoir bloquer l'héritage
     * de la fonction de hachage des parents, et permet d'utiliser correctement
     * isinstance(o, collections.Hashable).
     */
    retourne copie_chaine("PyObject_HashNotImplemented")
}

/* https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_richcompare */
génère_fonction_richcompare :: fonc (enchaineuse: *Enchaineuse, type: *TypePython) -> chaine
{
    saufsi type.drapeaux.TYPE_EST_ÉNUM {
        retourne copie_chaine("")
    }

    nom_fonction_richcompare := enchaine("richcompare_", type.nom_sauf)

compare_énum_avec_chaine := «
    si PyUnicode_Check(other) {
        valeur_chaine := PyUnicode_AsChaine(other)
        valeur_énum := Py%_As%(self).notre_instance
        retourne Py_compare_énum_chaine(valeur_énum, op, valeur_chaine)
    }
»

compare_énum_avec_énum := «
    si Py%_Check(other) {
        valeur1 := Py%_As%(self).notre_instance
        valeur2 := Py%_As%(other).notre_instance
        retourne Py_compare_énum_énum(valeur1, op, valeur2)
    }
»

    enchaineuse.ajoute_au_tampon(nom_fonction_richcompare, ":: fonc (self: *PyObject, other: *PyObject, op: z32) -> *PyObject\n")
    enchaineuse.ajoute_au_tampon("{\n")

    enchaineuse.imprime_dans_enchaineuse(compare_énum_avec_chaine, type.nom_sauf, type.nom_sauf)
    enchaineuse.imprime_dans_enchaineuse(compare_énum_avec_énum, type.nom_sauf, type.nom_sauf, type.nom_sauf, type.nom_sauf, type.nom_sauf)

    enchaineuse.ajoute_au_tampon("    retourne PyErr_ComparaisonImpossible(other, \"", type.nom, "\")\n")
    enchaineuse.ajoute_au_tampon("}\n")

    retourne nom_fonction_richcompare
}

génère_fonction_repr :: fonc (enchaineuse: *Enchaineuse, type: *TypePython) -> chaine
{
    méthode := type.repr

    saufsi méthode.nom {
        retourne copie_chaine("")
    }

    nom_fonction_repr := enchaine("repr_", type.nom_sauf)

    // doit retourner un PyUnicodeObject
    enchaineuse.ajoute_au_tampon(nom_fonction_repr, ":: fonc (self: *PyObject) -> *PyObject\n")
    enchaineuse.ajoute_au_tampon("{\n")
    enchaineuse.ajoute_au_tampon("    notre_instance := ", type.fonctions.pour_extraction_valeur, "(self).notre_instance\n")
    enchaineuse.ajoute_au_tampon("    résultat := ", méthode.nom, "(*notre_instance)\n")
    enchaineuse.ajoute_au_tampon("    résultat = enchaine(\"", type.nom, "('\", résultat, \"')\")\n")
    enchaineuse.ajoute_au_tampon("    retourne PyUnicode_FromChaine(résultat)\n")
    enchaineuse.ajoute_au_tampon("}\n")

    retourne nom_fonction_repr
}

génère_fonctions_protocole_tampons :: fonc (enchaineuse: *Enchaineuse, type: *TypePython)
{
    enchaineuse.ajoute_au_tampon("remplis_champs_requis_py_buffer_pour_", type.nom_globale_type, ":: fonc (self: *BasePyBuffer, view: *Py_buffer)\n")
    enchaineuse.ajoute_au_tampon("{\n")
    enchaineuse.ajoute_au_tampon("    notre_instance := ", type.fonctions.pour_extraction_valeur, "(self).notre_instance\n")
    enchaineuse.ajoute_au_tampon("    remplis_champs_requis_py_buffer_générique(view, notre_instance)\n")
    enchaineuse.ajoute_au_tampon("}\n")
}

génère_fonctions_protocole_séquences :: fonc (enchaineuse: *Enchaineuse, type: *TypePython)
{
    enchaineuse.ajoute_au_tampon("PySequenceMethodsPour", type.nom_sauf, ": PySequenceMethods\n")

    /* sq_length */
    enchaineuse.ajoute_au_tampon("sq_length_pour_", type.nom_sauf, " :: fonc (self: *PyObject) -> Py_ssize_t\n")
    enchaineuse.ajoute_au_tampon("{\n")
    enchaineuse.ajoute_au_tampon("    notre_instance := ", type.fonctions.pour_extraction_valeur, "(self).notre_instance\n")
    enchaineuse.ajoute_au_tampon("    retourne notre_instance.taille\n")
    enchaineuse.ajoute_au_tampon("}\n")

    /* sq_item */
    enchaineuse.ajoute_au_tampon("sq_item_pour_", type.nom_sauf, " :: fonc (self: *PyObject, index: Py_ssize_t) -> *PyObject\n")
    enchaineuse.ajoute_au_tampon("{\n")
    enchaineuse.ajoute_au_tampon("    notre_instance := ", type.fonctions.pour_extraction_valeur, "(self).notre_instance\n")
    // À FAIRE : erreur dépassement limites ?
    sous_type := type.type_élément
    enchaineuse.ajoute_au_tampon("    retourne ", sous_type.fonctions.pour_construction, "(notre_instance[index])\n")
    enchaineuse.ajoute_au_tampon("}\n")

    /* init */
    enchaineuse.ajoute_au_tampon("init_PySequenceMethodsPour", type.nom_sauf, " :: fonc () -> *PySequenceMethods\n")
    enchaineuse.ajoute_au_tampon("{\n")
    enchaineuse.ajoute_au_tampon("    init_de(PySequenceMethods)(*PySequenceMethodsPour", type.nom_sauf, ")\n")
    /* À FAIRE : pour le moment nous n'implémentons que sq_item et sq_length. */
    enchaineuse.ajoute_au_tampon("    PySequenceMethodsPour", type.nom_sauf, ".sq_item = sq_item_pour_", type.nom_sauf, "\n")
    enchaineuse.ajoute_au_tampon("    PySequenceMethodsPour", type.nom_sauf, ".sq_length = sq_length_pour_", type.nom_sauf, "\n")
    enchaineuse.ajoute_au_tampon("    retourne *PySequenceMethodsPour", type.nom_sauf, "\n")
    enchaineuse.ajoute_au_tampon("}\n")
}

génère_déclaration_type_python :: fonc (enchaineuse: *Enchaineuse, module: &ModulePython, type: *TypePython)
{
    /* Déclaration de la structure associée, dérivée de PyObject.
     * Pour une structure appelée « Structure », la version Python s'appelera « StructurePourPython ». */
    enchaineuse.ajoute_au_tampon(type.nom_sauf, "PourPython :: struct {\n")
    si type.drapeaux.TYPE_EST_TABLEAU {
        enchaineuse.ajoute_au_tampon("    empl base_py_buffer: BasePyBuffer\n")
    }
    sinon {
        enchaineuse.ajoute_au_tampon("    empl base_py_object: PyObject\n")
    }
    symbole_pointeur := ""
    si type.drapeaux.TOUJOURS_COMME_POINTEUR {
        symbole_pointeur = "*"
    }
    si type.drapeaux.TYPE_EST_ITÉRATEUR {
        enchaineuse.ajoute_au_tampon("    notre_instance: ", type.type_itéré.nom_type_kuri, "\n")
        enchaineuse.ajoute_au_tampon("    index_courant: z64\n")
    }
    sinon {
        enchaineuse.ajoute_au_tampon("    notre_instance: ", symbole_pointeur, type.nom_type_kuri, "\n")
    }
    enchaineuse.ajoute_au_tampon("}\n")

    /* Déclaration des FonctionsTypePython. */
    génère_déclaration_fonctions_pour_python(enchaineuse, type, symbole_pointeur)

    /*
        À FAIRE : méthodes types
            __init__ pour les membres mutables

            NomDuType.tp_flags = Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE;

     */

    si type.méthodes {
        pour type.méthodes {
            génère_interface_fonction(enchaineuse, it, type)
        }
        nom_tableau := enchaine("méthodes_", type.nom_sauf)
        diffère déloge(nom_tableau)
        génère_tableaux_méthodes(enchaineuse, type.méthodes, nom_tableau)
    }

    globale_getset := génère_méthodes_getset_pour_type(enchaineuse, type)
    diffère déloge(globale_getset)

    /* Afin de supporter les expressions de type : o[key] = v */
    globale_as_mapping := génère_globale_as_mapping(enchaineuse, type)
    diffère déloge(globale_as_mapping)

    fonction_new := génère_fonction_new(enchaineuse, type)
    diffère déloge(fonction_new)

    // À FAIRE __init__
    // fonction_init := génère_fonction_init(enchaineuse, type)
    // diffère déloge(fonction_init)

    fonction_str := génère_fonction_str(enchaineuse, type)
    diffère déloge(fonction_str)

    fonction_repr := génère_fonction_repr(enchaineuse, type)
    diffère déloge(fonction_repr)

    fonction_richcompare := génère_fonction_richcompare(enchaineuse, type)
    diffère déloge(fonction_richcompare)

    fonction_itérateur := génère_fonction_pour_créer_itérateur(enchaineuse, type)
    diffère déloge(fonction_itérateur)

    fonction_itérateur_next := génère_fonction_itérateur_next(enchaineuse, type)
    diffère déloge(fonction_itérateur_next)

    fonction_hash := génère_fonction_hash(enchaineuse, type)
    diffère déloge(fonction_hash)

    si type.drapeaux.TYPE_EST_TABLEAU {
        génère_fonctions_protocole_tampons(enchaineuse, type)
        génère_fonctions_protocole_séquences(enchaineuse, type)
    }

    /* Déclaration de la globale qui servira pour contenir les données sur le type Python.
     * Cet objet s'appel « TypeStructurePourPython ». */
    nom_globale_type := type.nom_globale_type
    enchaineuse.ajoute_au_tampon(nom_globale_type, ":= PyTypeObject(\n")

    /* Le nom requis pour Python, qui est de forme <module>.<nom>. */
    tp_name := enchaine(module.nom, ".", type.nom_sauf)
    diffère déloge(tp_name)

    enchaineuse.ajoute_au_tampon("    ob_refcnt = 1,\n")
    enchaineuse.ajoute_au_tampon("    ob_size = 0,\n")
    enchaineuse.ajoute_au_tampon("    tp_basicsize = taille_de(", type.nom_sauf, "PourPython) comme Py_ssize_t,\n")
    enchaineuse.ajoute_au_tampon("    tp_name = crée_chaine_c(\"", tp_name, "\"),\n")
    enchaineuse.ajoute_au_tampon("    tp_flags = 1 << 10 | 1 << 18,\n")

    si type.méthodes {
        enchaineuse.ajoute_au_tampon("    tp_methods = *méthodes_", type.nom_sauf, "[0],\n")
    }

    si fonction_new {
        enchaineuse.ajoute_au_tampon("    tp_new = ", fonction_new, ",\n")
    }

    si fonction_str {
        enchaineuse.ajoute_au_tampon("    tp_str = ", fonction_str, ",\n")
    }

    si fonction_repr {
        enchaineuse.ajoute_au_tampon("    tp_repr = ", fonction_repr, ",\n")
    }

    si fonction_richcompare {
        enchaineuse.ajoute_au_tampon("    tp_richcompare = ", fonction_richcompare, ",\n")
    }

    si fonction_itérateur {
        enchaineuse.ajoute_au_tampon("    tp_iter = ", fonction_itérateur, ",\n")
    }

    si fonction_itérateur_next {
        enchaineuse.ajoute_au_tampon("    tp_iter = iter_pour_type_itérateur,\n")
        enchaineuse.ajoute_au_tampon("    tp_iternext = ", fonction_itérateur_next, ",\n")
    }

    si globale_getset {
        enchaineuse.ajoute_au_tampon("    tp_getset = *", globale_getset, "[0],\n")
    }

    si type.base {
        enchaineuse.ajoute_au_tampon("    tp_base = *", type.base.nom_globale_type, ",\n")
    }
    sinon {
        enchaineuse.ajoute_au_tampon("    tp_base = *PyBaseObject_Type,\n")
    }

    si globale_as_mapping {
        enchaineuse.ajoute_au_tampon("    tp_as_mapping = *", globale_as_mapping, ",\n")
    }

    si type.drapeaux.TYPE_EST_TABLEAU {
        enchaineuse.ajoute_au_tampon("    tp_as_buffer = protocol_tampon_défaut(),\n")
        enchaineuse.ajoute_au_tampon("    tp_as_sequence = init_PySequenceMethodsPour", type.nom_sauf, "(),\n")
    }

    enchaineuse.ajoute_au_tampon("    tp_hash = ", fonction_hash, ")\n")
}

génère_déclaration_fonctions_pour_python :: fonc (enchaineuse: *Enchaineuse, type: *TypePython, symbole_pointeur: chaine)
{
    enchaineuse.ajoute_au_tampon(type.fonctions.pour_extraction_valeur, " :: fonc (self: *PyObject) -> *", type.nom_sauf, "PourPython\n")
    enchaineuse.ajoute_au_tampon("{\n")
    enchaineuse.ajoute_au_tampon("    retourne self comme *", type.nom_sauf, "PourPython\n")
    enchaineuse.ajoute_au_tampon("}\n")

    si type.drapeaux.TYPE_EST_ITÉRATEUR {
        /* Les autres fonctions ne sont pas disponibles pour les itérateurs. */
        retourne
    }

    enchaineuse.ajoute_au_tampon(type.fonctions.pour_discrimination, " :: fonc (self: *PyObject) -> bool\n")
    enchaineuse.ajoute_au_tampon("{\n")
    enchaineuse.ajoute_au_tampon("    si PyObject_TypeCheck(self, *", type.nom_globale_type, ") {\n")
    enchaineuse.ajoute_au_tampon("        retourne vrai\n")
    enchaineuse.ajoute_au_tampon("    }\n")
    si type.drapeaux.TYPE_EST_ÉNUM {
        enchaineuse.ajoute_au_tampon("    si PyUnicodeEnum_Check(self, info_de(", type.nom, ")) {\n")
        enchaineuse.ajoute_au_tampon("        retourne vrai;\n")
        enchaineuse.ajoute_au_tampon("    }\n")
    }
    si type.drapeaux.TOUJOURS_COMME_POINTEUR {
        enchaineuse.ajoute_au_tampon("    si self == Py_None {\n")
        enchaineuse.ajoute_au_tampon("        retourne vrai;\n")
        enchaineuse.ajoute_au_tampon("    }\n")
    }
    enchaineuse.ajoute_au_tampon("    retourne faux\n")
    enchaineuse.ajoute_au_tampon("}\n")
    enchaineuse.ajoute_au_tampon(type.fonctions.pour_construction, " :: fonc (valeur: ", symbole_pointeur, type.nom_type_kuri, ") -> *", type.nom_sauf, "PourPython\n")
    enchaineuse.ajoute_au_tampon("{\n")

    si type.drapeaux.TOUJOURS_COMME_POINTEUR {
        enchaineuse.ajoute_au_tampon("    saufsi valeur {\n")
        enchaineuse.ajoute_au_tampon("        retourne python_retourne_rien() comme *", type.nom_sauf, "PourPython\n")
        enchaineuse.ajoute_au_tampon("    }\n")
    }

    si type.drapeaux.REQUIERS_RAFINAGE {
        enchaineuse.ajoute_au_tampon("    ob_type := rafine_type_", type.nom_sauf, "(valeur)\n")
        enchaineuse.ajoute_au_tampon("    résultat := ob_type.tp_alloc(ob_type, 1) comme *", type.nom_sauf, "PourPython\n")
        enchaineuse.ajoute_au_tampon("    résultat.ob_type = ob_type\n")
    }
    sinon {
        enchaineuse.ajoute_au_tampon("    résultat := ", type.nom_globale_type, ".tp_alloc(*", type.nom_globale_type, ", 1) comme *", type.nom_sauf, "PourPython\n")
    }

    enchaineuse.ajoute_au_tampon("    résultat.notre_instance = valeur\n")
    si type.drapeaux.TYPE_EST_TABLEAU {
        enchaineuse.ajoute_au_tampon("    résultat.exports = 0\n")
        enchaineuse.ajoute_au_tampon("    résultat.remplis_champs_requis_py_buffer = remplis_champs_requis_py_buffer_pour_", type.nom_globale_type, "\n")
    }
    enchaineuse.ajoute_au_tampon("    retourne résultat\n")
    enchaineuse.ajoute_au_tampon("}\n")
}

type_supporte_itération :: fonc (type: *TypePython) -> bool
{
    si type.type_itérateur {
        retourne vrai
    }

    si type_supporte_mapping(type) {
        /* Les types pouvant être "mappés" ont des itérateurs afin de pouvoir
         * supporter, par exemple, les expressions types 'if x in y'.
         * Ceci n'est pas supporté pour les unions. */
        retourne type.drapeaux.TYPE_EST_UNION == faux
    }

    retourne faux
}

génère_fonction_pour_créer_itérateur :: fonc (enchaineuse: *Enchaineuse, type: *TypePython) -> chaine
{
    saufsi type_supporte_itération(type) {
        retourne copie_chaine("")
    }

    nom_fonction := enchaine("itérateur_pour_", type.nom_sauf)

    corps_fonction_pour_type_itérateur := «
    type_itérateur := *%
    py_itérateur_ := type_itérateur.tp_alloc(type_itérateur, 1)
    py_itérateur := %(py_itérateur_)
    py_itérateur.notre_instance = %(ob).notre_instance
    py_itérateur.index_courant = 0
    retourne py_itérateur comme *PyObject
    »

    corps_fonction_pour_info_type := «
    retourne itérateur_pour_infos_type(info_de(%))
    »

    inutilisée := ""
    saufsi type.type_itérateur {
        inutilisée = " @inutilisée"
    }

    enchaineuse.ajoute_au_tampon(nom_fonction, " :: fonc (ob: *PyObject", inutilisée, ") -> *PyObject\n")
    enchaineuse.ajoute_au_tampon("{\n")
    si type.type_itérateur {
        enchaineuse.imprime_dans_enchaineuse(corps_fonction_pour_type_itérateur, type.type_itérateur.nom_globale_type, type.type_itérateur.fonctions.pour_extraction_valeur, type.fonctions.pour_extraction_valeur)
    }
    sinon {
        enchaineuse.imprime_dans_enchaineuse(corps_fonction_pour_info_type, type.nom_type_kuri)
    }
    enchaineuse.ajoute_au_tampon("}\n")

    retourne nom_fonction
}

génère_fonction_itérateur_next :: fonc (enchaineuse: *Enchaineuse, type: *TypePython) -> chaine
{
    saufsi type.drapeaux.TYPE_EST_ITÉRATEUR {
        retourne copie_chaine("")
    }

    nom_fonction := enchaine("itérateur_pour_next_", type.nom_sauf)

    corps_fonction := «
    py_self := %(self)

    si py_self.index_courant >= py_self.notre_instance.taille {
        retourne nul
    }

    valeur_courante := py_self.notre_instance[py_self.index_courant]

    py_valeur_courante := %(valeur_courante)

    py_self.index_courant += 1
    retourne py_valeur_courante
    »

    enchaineuse.ajoute_au_tampon(nom_fonction, " :: fonc (self: *PyObject) -> *PyObject\n")
    enchaineuse.ajoute_au_tampon("{\n")
    enchaineuse.imprime_dans_enchaineuse(corps_fonction, type.fonctions.pour_extraction_valeur, type.type_itéré.type_élément.fonctions.pour_construction)
    enchaineuse.ajoute_au_tampon("}\n")

    retourne nom_fonction
}

/* Extrait les paramètres des arguments passés à la fonction. Pour le moment ces arguments
 * ont des types conforment à Python. Le nom des arguments doit être "args". */
génère_parsage_args_tuple :: fonc (enchaineuse: *Enchaineuse, méthode: &MéthodePython, valeur_retour: chaine)
{
    saufsi méthode.paramètres_entrée {
        retourne
    }

    pour méthode.paramètres_entrée {
        enchaineuse.imprime_dans_enchaineuse("    pyobject_%: *PyObject\n", it.nom)
    }

    enchaineuse.ajoute_au_tampon("    chn_objets := crée_chaine_c(\"")
    pour méthode.paramètres_entrée {
        enchaineuse.ajoute_au_tampon("O")
    }
    enchaineuse.ajoute_au_tampon("\")\n")
    enchaineuse.ajoute_au_tampon("diffère détruit_chaine_c(chn_objets)\n")

    enchaineuse.ajoute_au_tampon("    saufsi PyArg_ParseTuple(args, chn_objets")
    virgule := ", "
    pour méthode.paramètres_entrée {
        enchaineuse.ajoute_au_tampon(virgule, "*pyobject_", it.nom)
    }
    enchaineuse.ajoute_au_tampon(") {\n")
    enchaineuse.ajoute_au_tampon("        retourne ", valeur_retour, "\n")
    enchaineuse.ajoute_au_tampon("    }\n")

    /* Vérifie que les types sont ceux attendus. */
    pour méthode.paramètres_entrée {
        chn_erreur := imprime_chaine("Mauvais type pour l'argument % ! Attendu : %, obtenu : ", it.nom, it.type.nom)
        diffère déloge(chn_erreur)

        enchaineuse.ajoute_au_tampon("    saufsi ", it.type.fonctions.pour_discrimination, "(pyobject_", it.nom, ") {\n")
        enchaineuse.ajoute_au_tampon("        retourne PyErr_MauvaisTypeArgument(pyobject_", it.nom, ", \"", it.nom, "\", \"", it.type.nom, "\")\n")
        enchaineuse.ajoute_au_tampon("    }\n")
    }
}

/* Convertis les paramètres de fonction vers des objets de type Kuri natif (les types du programme). */
génère_conversion_args_vers_kuri :: fonc (enchaineuse: *Enchaineuse, méthode: &MéthodePython)
{
    chaine_pour_extraction_énum := «
    % : %
    si PyUnicode_Check(pyobject_%) {
        % = %(pyobject_%, info_de(%)) comme %
    }
    sinon {
        % = %(pyobject_%).notre_instance
    }
    »

    pour méthode.paramètres_entrée {
        si it.type.drapeaux.TYPE_EST_ÉNUM {
            enchaineuse.imprime_dans_enchaineuse(chaine_pour_extraction_énum, it.nom, it.type.nom, it.nom, it.nom, it.type.fonctions.pour_valeur_unicode_enum, it.nom, it.type.nom_sauf, it.type.nom_sauf, it.nom, it.type.fonctions.pour_extraction_valeur, it.nom)
            continue
        }
        enchaineuse.ajoute_au_tampon("    ", it.nom, " := ", it.type.fonctions.pour_extraction_valeur, "(pyobject_", it.nom, ")\n")
    }
}

// Génère l'expression d'appel pour le code Kuri de la méthode. La fonction appelante doit gérer la potentielle valeur de retour (nom, assignation, etc.).
génère_appel_méthode_kuri :: fonc (enchaineuse: *Enchaineuse, méthode: &MéthodePython, premier_paramètre_implicite: chaine = "")
{
    enchaineuse.ajoute_au_tampon(méthode.nom)
    virgule := "("
    si premier_paramètre_implicite  {
        enchaineuse.ajoute_au_tampon(virgule, premier_paramètre_implicite)
        virgule = ", "
    }
    sinon saufsi méthode.paramètres_entrée {
        enchaineuse.ajoute_au_tampon(virgule)
    }
    pour méthode.paramètres_entrée {
        enchaineuse.ajoute_au_tampon(virgule)
        si it.param_originel_est_pointeur && it.type.drapeaux.TOUJOURS_COMME_POINTEUR == faux {
            enchaineuse.ajoute_au_tampon("*")
        }
        enchaineuse.ajoute_au_tampon(it.nom)
        saufsi it.type.est_basique || it.type.drapeaux.TYPE_EST_ÉNUM {
            enchaineuse.ajoute_au_tampon(".notre_instance")
        }
        virgule = ", "
    }
    enchaineuse.ajoute_au_tampon(")\n")
}

génère_interface_fonction :: fonc (enchaineuse: *Enchaineuse, méthode: MéthodePython, self: *TypePython = nul)
{
    // À FAIRE : initialisation des variables globales de kuri

    /* self, pour les méthodes de module, c'est la méthode, pour le reste, c'est l'objet */
    self_inutilisé := ""
    saufsi self {
        self_inutilisé = " @inutilisée"
    }
    args_inutilisés := ""
    saufsi méthode.paramètres_entrée {
        args_inutilisés = " @inutilisée"
    }

    enchaineuse.imprime_dans_enchaineuse("% :: fonc (self: *PyObject%, args: *PyObject%) -> *PyObject\n", méthode.nom_enveloppe, self_inutilisé, args_inutilisés)
    enchaineuse.ajoute_au_tampon("{\n")

    génère_parsage_args_tuple(enchaineuse, méthode, "nul")
    génère_conversion_args_vers_kuri(enchaineuse, méthode)

    si self {
        enchaineuse.ajoute_au_tampon("    self_kuri := ", self.fonctions.pour_extraction_valeur, "(self)\n")
    }

    /* Appel la fonction. */
    possède_retour := !méthode.ne_retourne_rien()

    enchaineuse.ajoute_au_tampon("    ")
    si possède_retour {
        enchaineuse.ajoute_au_tampon("résultat := ")
    }

    arg_implicite := ""
    si self {
        si self.drapeaux.TOUJOURS_COMME_POINTEUR {
            arg_implicite = "self_kuri.notre_instance"
        }
        sinon {
            arg_implicite = "*self_kuri.notre_instance"
        }
    }

    génère_appel_méthode_kuri(enchaineuse, méthode, arg_implicite)

    si possède_retour {
        type_sortie := méthode.paramètres_sortie[0].type
        enchaineuse.ajoute_au_tampon("    retourne ", type_sortie.fonctions.pour_construction, "(résultat)\n")
    }
    sinon {
        enchaineuse.ajoute_au_tampon("    retourne python_retourne_rien()\n")
    }

    enchaineuse.ajoute_au_tampon("}\n")
}

génère_tableaux_méthodes :: fonc (enchaineuse: *Enchaineuse, méthodes: [..]MéthodePython, nom_tableau: chaine)
{
    /* Déclare le tableau de méthodes. Il y a une méthode supplémentaire nulle comme sentinelle. */
    enchaineuse.imprime_dans_enchaineuse("% := [\n", nom_tableau)

    pour méthodes {
        drapeaux_méthode := si it.paramètres_entrée {
            "METH_VARARGS"
        }
        sinon {
            "METH_NOARGS"
        }

        enchaineuse.imprime_dans_enchaineuse("    PyMethodDef(ml_name = crée_chaine_c(\"%\"), ml_meth = %, ml_flag = %, ml_doc = ChaineC(nul)),\n", it.nom, it.nom_enveloppe, drapeaux_méthode)
    }

    /* Sentinelle */
    enchaineuse.imprime_dans_enchaineuse("    PyMethodDef(ml_name = ChaineC(nul), ml_meth = nul, ml_flag = 0, ml_doc = ChaineC(nul))\n")
    enchaineuse.ajoute_au_tampon("]\n")
}

ajoute_type_à_la_liste :: fonc (enchaineuse: *Enchaineuse, type: *TypePython)
{
    si type.code_pour_init_module_fut_généré {
        retourne
    }

    si type.base {
        ajoute_type_à_la_liste(enchaineuse, type.base)
    }

    enchaineuse.ajoute_au_tampon("        DonnéesAjoutType(*", type.nom_globale_type, ", ChaineC(\"", type.nom, "\\0\".pointeur)),\n")
    type.code_pour_init_module_fut_généré = vrai
}

génère_initialisation_module :: fonc (enchaineuse: *Enchaineuse, module: &ModulePython, types: [..]*TypePython)
{
    génère_tableaux_méthodes(enchaineuse, module.méthodes, "méthodes_du_module")

    /* Déclaration de la globale pour la définition du module. */
    enchaineuse.ajoute_au_tampon("définition_module := PyModuleDef(\n")

    enchaineuse.imprime_dans_enchaineuse("    m_name = crée_chaine_c(\"%\"),\n", module.nom)
    enchaineuse.ajoute_au_tampon("    m_doc = ChaineC(nul),\n")
    enchaineuse.ajoute_au_tampon("    m_size = -1,\n")
    enchaineuse.ajoute_au_tampon("    m_methods = *méthodes_du_module[0],\n")
    enchaineuse.ajoute_au_tampon("    m_slots = nul,\n")
    enchaineuse.ajoute_au_tampon("    m_traverse = nul,\n")
    enchaineuse.ajoute_au_tampon("    m_clear = nul,\n")
    enchaineuse.ajoute_au_tampon("    m_free = nul)\n")

    /* La fonction d'initialisation du module doit avoir la signature : PyInit_nom_module :: fonc () -> *PyObject */
    enchaineuse.imprime_dans_enchaineuse("PyInit_% :: fonc () -> *PyObject #racine #sansbroyage #sanstrace #exporte\n", module.nom)
    enchaineuse.ajoute_au_tampon("{\n")
    enchaineuse.ajoute_au_tampon("    module_pyobject := PyModule_Create2(*définition_module, PYTHON_API_VERSION)\n")

    pour module.constantes_nombre_entier {
        enchaineuse.imprime_dans_enchaineuse("    si PyModule_AddIntConstant(module_pyobject, crée_chaine_c(\"%\"), %) == -1 {\n", it.nom, it.valeur)
        enchaineuse.ajoute_au_tampon("        retourne python_retourne_rien()\n")
        enchaineuse.ajoute_au_tampon("    }\n")
    }

    pour module.constantes_chaine {
        enchaineuse.imprime_dans_enchaineuse("    si PyModule_AddStringConstant(module_pyobject, crée_chaine_c(\"%\"), crée_chaine_c(\"%\")) == -1 {\n", it.nom, it.valeur)
        enchaineuse.ajoute_au_tampon("        retourne python_retourne_rien()\n")
        enchaineuse.ajoute_au_tampon("    }\n")
    }

    /* Rassemble les types dans l'ordre. */
    itérateur_info_type_est_requis := faux
    enchaineuse.ajoute_au_tampon("    tous_les_types := [\n")
    pour types {
        si it.est_basique {
            continue
        }
        si type_supporte_itération(it) && !it.type_itérateur {
            itérateur_info_type_est_requis = vrai
        }
        ajoute_type_à_la_liste(enchaineuse, it)
    }
    /* Type itérateur info type. */
    si itérateur_info_type_est_requis {
        enchaineuse.ajoute_au_tampon("         DonnéesAjoutType(*PyTypeItérateurPourInfoType, ChaineC(\"ItérateurPourInfoType\0\".pointeur)),\n")
    }
    /* Sentinelle pour simplifier la génération de code pour les virgules. */
    enchaineuse.ajoute_au_tampon("         DonnéesAjoutType(nul, ChaineC(nul))\n")
    enchaineuse.ajoute_au_tampon("    ]\n")

    enchaineuse.ajoute_au_tampon("    retourne Py_AjouteTypesAuModule(module_pyobject, tous_les_types)\n")
    enchaineuse.ajoute_au_tampon("}\n")
}
