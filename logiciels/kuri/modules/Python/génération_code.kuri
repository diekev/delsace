importe Fondation

/* Génération du code Kuri à partir des données du module. */

/* Chaine de caractère pour le type Kuri utilisé dans l'IPA C de Python. */
chaine_pour_genre_type_python :: fonc (type: GenreTypePython) -> chaine
{
    discr type {
        LONG {
            retourne "z32"
        }
        DOUBLE {
            retourne "r64"
        }
        CHAINE {
            retourne "*z8"
        }
        RIEN,
        OBJET,
        POINTEUR_QUELCONQUE {
            retourne "*PyObject"
        }
    }

    retourne "invalide"
}

/* Retourne le format à utiliser pour PyArg_ParseTuple selon le type. */
format_extraction_genre_type_python :: fonc (type: GenreTypePython) -> chaine
{
    discr type {
        LONG {
            retourne "i"
        }
        DOUBLE {
            retourne "d"
        }
        CHAINE {
            retourne "s"
        }
        RIEN,
        OBJET,
        POINTEUR_QUELCONQUE {
            retourne "O"
        }
    }

    retourne "invalide"
}

protège_type_python :: fonc (enchaineuse: *Enchaineuse, variable: chaine, genre: GenreTypePython)
{
    discr genre {
        LONG {
            enchaineuse.ajoute_au_tampon("    saufsi PyLong_Check(", variable, ") {\n")
        }
        DOUBLE {
            enchaineuse.ajoute_au_tampon("    saufsi PyFloat_Check(", variable, ") {\n")
        }
        CHAINE {
            enchaineuse.ajoute_au_tampon("    saufsi PyUnicode_Check(", variable, ") {\n")
        }
        RIEN,
        OBJET,
        POINTEUR_QUELCONQUE {
            // À FAIRE
        }
    }
}

construit_type_python :: fonc (enchaineuse: *Enchaineuse, variable: chaine, genre: GenreTypePython)
{
    discr genre {
        LONG {
            enchaineuse.ajoute_au_tampon("PyLong_FromLong(", variable, ")")
        }
        DOUBLE {
            enchaineuse.ajoute_au_tampon("PyFloat_FromDouble(", variable, ")")
        }
        CHAINE {
            enchaineuse.ajoute_au_tampon("PyUnicode_DepuisChaine(", variable, ")")
        }
        RIEN {
            enchaineuse.ajoute_au_tampon("pythong_retourne_rien()")
        }
        OBJET,
        POINTEUR_QUELCONQUE {
            // À FAIRE
        }
    }
}

extrait_valeur_type_python :: fonc (enchaineuse: *Enchaineuse, variable: chaine, genre: GenreTypePython)
{
    discr genre {
        LONG {
            enchaineuse.ajoute_au_tampon("PyLong_AsLong(", variable, ")")
        }
        DOUBLE {
            enchaineuse.ajoute_au_tampon("PyFloat_AsDouble(", variable, ")")
        }
        CHAINE {
            enchaineuse.ajoute_au_tampon("python_extrait_chaine(", variable, ")")
        }
        RIEN {
        }
        OBJET,
        POINTEUR_QUELCONQUE {
            // À FAIRE
        }
    }
}

/* Génère les méthodes pour accéder et muter les membres du type. Retourne la globales où les méthodes sont initialisés. */
génère_méthodes_getset_pour_type :: fonc (enchaineuse: *Enchaineuse, type: &TypePython) -> chaine
{
    si type.confidentialité == ConfidentialitéType.OPAQUE {
        retourne copie_chaine("")
    }

    nombre_de_membres := type.type_kuri.membres.taille

    /* Déclare les fonctions get/set. */
    pour type.type_kuri.membres {
        genre_type_python_membre := genre_type_python_pour_info_type(it.id)

        // get : fonc (*PyObject, *rien)(*PyObject)

        enchaineuse.ajoute_au_tampon("get_", type.nom, "_", it.nom, " :: fonc (instance: *PyObject, closure: *rien@inutilisée) -> *PyObject #nulctx\n")
        enchaineuse.ajoute_au_tampon("{\n")
        enchaineuse.ajoute_au_tampon("    notre_instance := (instance comme *", type.nom, "PourPython).notre_instance\n")
        enchaineuse.ajoute_au_tampon("    membre := notre_instance.", it.nom, "\n")
        enchaineuse.ajoute_au_tampon("    retourne ")
        construit_type_python(enchaineuse, "membre", genre_type_python_membre)
        enchaineuse.ajoute_au_tampon("\n")
        enchaineuse.ajoute_au_tampon("}\n")

        si type.confidentialité == ConfidentialitéType.MUTABLE {
            // set : fonc (*PyObject, *PyObject, *rien)(z32)
            // retourne 0 pour un succès
            // retourne -1 pour une erreur
            enchaineuse.ajoute_au_tampon("get_", type.nom, "_", it.nom, " :: fonc (instance: *PyObject, valeur: *PyObject, closure: *rien@inutilisée) -> z32 #nulctx\n")
            enchaineuse.ajoute_au_tampon("{\n")

            protège_type_python(enchaineuse, "valeur", genre_type_python_membre)
            // À FAIRE : erreur -> attendu un objet de type "type attendu", obtenu un "type reçu"
            enchaineuse.ajoute_au_tampon("        retourne -1\n")
            enchaineuse.ajoute_au_tampon("    }\n")

            enchaineuse.ajoute_au_tampon("    notre_instance := *(instance comme *", type.nom, "PourPython).notre_instance\n")

            enchaineuse.ajoute_au_tampon("    notre_instance.", it.nom, " = ")
            extrait_valeur_type_python(enchaineuse, "valeur", genre_type_python_membre)
            enchaineuse.ajoute_au_tampon("    retourne 0\n")
            enchaineuse.ajoute_au_tampon("}\n")
        }
    }

    nom_globale := enchaine("getset_", type.nom)

    /* Déclare la globale, nous devons un élément supplémentaire à la fin. */
    enchaineuse.imprime_dans_enchaineuse("%: [%]PyGetSetDef\n", nom_globale, nombre_de_membres + 1)

    /* Défini la fonction d'initialisation de la globale */
    enchaineuse.ajoute_au_tampon("initialise_", nom_globale, " :: fonc ()\n")
    enchaineuse.ajoute_au_tampon("{\n")
    pour type.type_kuri.membres {
        enchaineuse.imprime_dans_enchaineuse("    %[%].name = crée_chaine_c(\"%\")\n", nom_globale, index_it, it.nom)
        enchaineuse.imprime_dans_enchaineuse("    %[%].get = get_%_%\n", nom_globale, index_it, type.nom, it.nom)
        si type.confidentialité == ConfidentialitéType.MUTABLE {
            enchaineuse.imprime_dans_enchaineuse("    %[%].set = set_%_%\n", nom_globale, index_it, type.nom, it.nom)
        }
        sinon {
            enchaineuse.imprime_dans_enchaineuse("    %[%].set = nul\n", nom_globale, index_it, type.nom, it.nom)
        }
        enchaineuse.imprime_dans_enchaineuse("    %[%].doc = ChaineC(nul)\n", nom_globale, index_it, it.nom)
        enchaineuse.imprime_dans_enchaineuse("    %[%].closure = nul\n", nom_globale, index_it, it.nom)
    }
    enchaineuse.imprime_dans_enchaineuse("    %[%].name = ChaineC(nul)\n", nom_globale, nombre_de_membres)
    enchaineuse.imprime_dans_enchaineuse("    %[%].get = nul\n", nom_globale, nombre_de_membres)
    enchaineuse.imprime_dans_enchaineuse("    %[%].set = nul\n", nom_globale, nombre_de_membres)
    enchaineuse.imprime_dans_enchaineuse("    %[%].doc = ChaineC(nul)\n", nom_globale, nombre_de_membres)
    enchaineuse.imprime_dans_enchaineuse("    %[%].closure = nul\n", nom_globale, nombre_de_membres)
    enchaineuse.ajoute_au_tampon("}\n")

    retourne nom_globale
}

génère_fonction_new :: fonc (enchaineuse: *Enchaineuse, type: &TypePython) -> chaine
{
    méthode := type.new

    saufsi méthode.nom {
        retourne copie_chaine("")
    }

    nom_fonction_new := enchaine("new_", type.nom)

    enchaineuse.ajoute_au_tampon(nom_fonction_new, " :: fonc (subtype: *PyTypeObject, args: *PyObject, kwds: *PyObject @inutilisée) -> *PyObject #nulctx\n")
    enchaineuse.ajoute_au_tampon("pousse_contexte __contexte_fil_principal {\n")

    /* Parse les arguments. */
    génère_parsage_args_tuple(enchaineuse, méthode, "nul")

    /* Appel la fonction d'initialisation. */
    génère_conversion_args_vers_kuri(enchaineuse, méthode)

    enchaineuse.ajoute_au_tampon("    résultat :", type.nom, "\n")
    enchaineuse.ajoute_au_tampon("    succès := ")
    génère_appel_méthode_kuri(enchaineuse, méthode, "*résultat")

    enchaineuse.ajoute_au_tampon("    saufsi succès {\n")
    enchaineuse.ajoute_au_tampon("        retourne nul\n")
    enchaineuse.ajoute_au_tampon("    }\n")

    /* Crée un objet python correspondant, et retourne. */
    enchaineuse.ajoute_au_tampon("    objet_résultat := subtype.tp_alloc(subtype, 1) comme *", type.nom, "PourPython\n")
    enchaineuse.ajoute_au_tampon("    objet_résultat.notre_instance = résultat\n")
    enchaineuse.ajoute_au_tampon("    retourne objet_résultat\n")
    enchaineuse.ajoute_au_tampon("}\n")

    retourne nom_fonction_new
}

génère_fonction_str :: fonc (enchaineuse: *Enchaineuse, type: &TypePython) -> chaine
{
    méthode := type.str

    saufsi méthode.nom {
        retourne copie_chaine("")
    }

    nom_fonction_str := enchaine("str_", type.nom)

    // doit retourner un PyUnicodeObject
    enchaineuse.ajoute_au_tampon(nom_fonction_str, ":: fonc (self: *PyObject) -> *PyObject #nulctx\n")
    enchaineuse.ajoute_au_tampon("pousse_contexte __contexte_fil_principal {\n")
    enchaineuse.ajoute_au_tampon("    notre_instance := (self comme *", type.nom, "PourPython).notre_instance\n")
    enchaineuse.ajoute_au_tampon("    résultat := ", méthode.nom, "(*notre_instance)\n")
    enchaineuse.ajoute_au_tampon("    retourne PyUnicode_DepuisChaine(résultat)\n")
    enchaineuse.ajoute_au_tampon("}\n")

    retourne nom_fonction_str
}

génère_fonction_repr :: fonc (enchaineuse: *Enchaineuse, type: &TypePython) -> chaine
{
    méthode := type.repr

    saufsi méthode.nom {
        retourne copie_chaine("")
    }

    nom_fonction_repr := enchaine("repr_", type.nom)

    // doit retourner un PyUnicodeObject
    enchaineuse.ajoute_au_tampon(nom_fonction_repr, ":: fonc (self: *PyObject) -> *PyObject #nulctx\n")
    enchaineuse.ajoute_au_tampon("pousse_contexte __contexte_fil_principal {\n")
    enchaineuse.ajoute_au_tampon("    notre_instance := (self comme *", type.nom, "PourPython).notre_instance\n")
    enchaineuse.ajoute_au_tampon("    résultat := ", méthode.nom, "(*notre_instance)\n")
    enchaineuse.ajoute_au_tampon("    résultat = enchaine(\"", type.nom, "('\", résultat, \"')\")\n")
    enchaineuse.ajoute_au_tampon("    retourne PyUnicode_DepuisChaine(résultat)\n")
    enchaineuse.ajoute_au_tampon("}\n")

    retourne nom_fonction_repr
}

génère_déclaration_type_python :: fonc (enchaineuse: *Enchaineuse, module: &ModulePython, type: &TypePython)
{
    /* Déclaration de la structure associée, dérivée de PyObject.
     * Pour une structure appelée « Structure », la version Python s'appelera « StructurePourPython ». */
    enchaineuse.ajoute_au_tampon(type.nom, "PourPython :: struct {\n")
    enchaineuse.ajoute_au_tampon("    empl base: PyObject\n")
    enchaineuse.ajoute_au_tampon("    notre_instance: ", type.nom, "\n")
    enchaineuse.ajoute_au_tampon("}\n")

    /* Déclaration de la globale qui servira pour contenir les données sur le type Python.
     * Cet objet s'appel « TypeStructurePourPython ». */
    nom_globale_type := enchaine("Type", type.nom, "PourPython")
    type.nom_globale_type = nom_globale_type
    enchaineuse.ajoute_au_tampon(nom_globale_type, ": PyTypeObject\n")

    /*
        À FAIRE : méthodes types
            __init__ pour les membres mutables
            méthodes diverses

            NomDuType.tp_flags = Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE;

     */

    globale_getset := génère_méthodes_getset_pour_type(enchaineuse, type)
    diffère déloge(globale_getset)

    fonction_new := génère_fonction_new(enchaineuse, type)
    diffère déloge(fonction_new)

    // À FAIRE __init__
    // fonction_init := génère_fonction_init(enchaineuse, type)
    // diffère déloge(fonction_init)

    fonction_str := génère_fonction_str(enchaineuse, type)
    diffère déloge(fonction_str)

    fonction_repr := génère_fonction_repr(enchaineuse, type)
    diffère déloge(fonction_repr)

    /* Définition de la fonction d'initialisation de la globale pour le type Python. */
    enchaineuse.ajoute_au_tampon("initialise_", nom_globale_type, " :: fonc () -> bool #nulctx\n")
    enchaineuse.ajoute_au_tampon("pousse_contexte __contexte_fil_principal {\n")

    /* Le nom requis pour Python, qui est de forme <module>.<nom>. */
    tp_name := enchaine(module.nom, ".", type.nom)
    diffère déloge(tp_name)

    enchaineuse.ajoute_au_tampon("    init_de(PyTypeObject)(*", nom_globale_type, ")\n")
    enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".ob_refcnt = 1\n")
    enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".ob_size = 0\n")
    enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".tp_basicsize = taille_de(", type.nom, ") comme Py_ssize_t\n")
    enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".tp_base = *PyBaseObject_Type\n")
    enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".tp_name = crée_chaine_c(\"", tp_name, "\")\n")
    enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".tp_flags = 1 << 10 | 1 << 18\n")

    si fonction_new {
        enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".tp_new = ", fonction_new, "\n")
    }

    si fonction_str {
        enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".tp_str = ", fonction_str, "\n")
    }

    si fonction_repr {
        enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".tp_repr = ", fonction_repr, "\n")
    }

    si globale_getset {
        enchaineuse.ajoute_au_tampon("    initialise_getset_", type.nom, "()\n")
        enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".tp_getset = *", globale_getset, "[0]\n")
    }

    enchaineuse.ajoute_au_tampon("    retourne PyType_Ready(*", nom_globale_type, ") != -1\n")
    enchaineuse.ajoute_au_tampon("}\n")
}

/* Extrait les paramètres des arguments passés à la fonction. Pour le moment ces arguments
 * ont des types conforment à Python. Le nom des arguments doit être "args". */
génère_parsage_args_tuple :: fonc (enchaineuse: *Enchaineuse, méthode: &MéthodePython, valeur_retour: chaine)
{
    saufsi méthode.paramètres_entrée {
        retourne
    }

    pour méthode.paramètres_entrée {
        chaine_type_python := chaine_pour_genre_type_python(it.type)
        enchaineuse.imprime_dans_enchaineuse("    pyobject_%: %\n", it.nom, chaine_type_python)
    }

    enchaineuse.ajoute_au_tampon("    saufsi PyArg_ParseTuple(args, crée_chaine_c(\"")
    pour méthode.paramètres_entrée {
        enchaineuse.ajoute_au_tampon(format_extraction_genre_type_python(it.type))
    }
    enchaineuse.ajoute_au_tampon("\")")
    virgule := ", "
    pour méthode.paramètres_entrée {
        enchaineuse.ajoute_au_tampon(virgule, "*pyobject_", it.nom)
    }
    enchaineuse.ajoute_au_tampon(") {\n")
    enchaineuse.ajoute_au_tampon("        retourne ", valeur_retour, "\n")
    enchaineuse.ajoute_au_tampon("    }\n")
}

/* Convertis les paramètres de fonction vers des objets de type Kuri natif (les types du programme). */
génère_conversion_args_vers_kuri :: fonc (enchaineuse: *Enchaineuse, méthode: &MéthodePython)
{
    saufsi méthode.paramètres_entrée {
        retourne
    }

    // À FAIRE : convertis les types python
    pour méthode.paramètres_entrée {
        enchaineuse.imprime_dans_enchaineuse("    %: ", it.nom)
        imprime_type(enchaineuse, it.type_kuri)

        si it.type == GenreTypePython.CHAINE {
            enchaineuse.ajoute_au_tampon(" = convertis_chaine_c(ChaineC(pyobject_", it.nom, "))\n")
        }
        sinon {
            enchaineuse.ajoute_au_tampon(" = pyobject_", it.nom, "\n")
        }
    }
}

// Génère l'expression d'appel pour le code Kuri de la méthode. La fonction appelante doit gérer la potentielle valeur de retour (nom, assignation, etc.).
génère_appel_méthode_kuri :: fonc (enchaineuse: *Enchaineuse, méthode: &MéthodePython, premier_paramètre_implicite: chaine = "")
{
    enchaineuse.ajoute_au_tampon(méthode.nom)
    virgule := "("
    si premier_paramètre_implicite  {
        enchaineuse.ajoute_au_tampon(virgule, premier_paramètre_implicite)
        virgule = ", "
    }
    sinon saufsi méthode.paramètres_entrée {
        enchaineuse.ajoute_au_tampon(virgule)
    }
    pour méthode.paramètres_entrée {
        enchaineuse.ajoute_au_tampon(virgule, it.nom)
        virgule = ", "
    }
    enchaineuse.ajoute_au_tampon(")\n")
}

génère_interface_fonction :: fonc (enchaineuse: *Enchaineuse, méthode: MéthodePython)
{
    // À FAIRE : conversion de type paramètres
    // À FAIRE : initialisation des variables globales de kuri

    // À FAIRE : self, pour les méthodes de module, c'est la méthode, pour le reste, c'est l'objet
    self_inutilisé := "@inutilisée"
    args_inutilisés := ""
    saufsi méthode.paramètres_entrée {
        args_inutilisés = "@inutilisée"
    }

    enchaineuse.imprime_dans_enchaineuse("enveloppe_python_% :: fonc (self: *PyObject%, args: *PyObject%) -> *PyObject #nulctx\n", méthode.nom, self_inutilisé, args_inutilisés)
    enchaineuse.ajoute_au_tampon("pousse_contexte __contexte_fil_principal {\n")

    génère_parsage_args_tuple(enchaineuse, méthode, "nul")
    génère_conversion_args_vers_kuri(enchaineuse, méthode)

    /* Appel la fonction. */
    possède_retour := !méthode.ne_retourne_rien()

    enchaineuse.ajoute_au_tampon("    ")
    si possède_retour {
        enchaineuse.ajoute_au_tampon("résultat := ")
    }

    génère_appel_méthode_kuri(enchaineuse, méthode)

    si possède_retour {
        enchaineuse.ajoute_au_tampon("    retourne PyLong_FromLong(résultat)\n")
    }
    sinon {
        enchaineuse.ajoute_au_tampon("    retourne python_retourne_rien()\n")
    }

    enchaineuse.ajoute_au_tampon("}\n")
}

génère_initialisation_module :: fonc (enchaineuse: *Enchaineuse, module: &ModulePython)
{
    /* Déclare le tableau de méthodes. Il y a une méthode supplémentaire nulle comme sentinelle. */
    enchaineuse.imprime_dans_enchaineuse("méthodes_du_module : [%]PyMethodDef\n", module.méthodes.taille + 1)

    /* Fonction d'initialisation pour les méthodes. */
    enchaineuse.ajoute_au_tampon("initialise_méthodes :: fonc () #nulctx\n")
    enchaineuse.ajoute_au_tampon("pousse_contexte __contexte_fil_principal {\n")

    pour module.méthodes {
        enchaineuse.imprime_dans_enchaineuse("    méthodes_du_module[%].ml_name = crée_chaine_c(\"%\")\n", index_it, it.nom)
        enchaineuse.imprime_dans_enchaineuse("    méthodes_du_module[%].ml_meth = enveloppe_python_%\n", index_it, it.nom)

        drapeaux_méthode := ""
        si it.paramètres_entrée {
            drapeaux_méthode = "METH_VARARGS"
        }
        sinon {
            drapeaux_méthode = "METH_NOARGS"
        }

        enchaineuse.imprime_dans_enchaineuse("    méthodes_du_module[%].ml_flag = %\n", index_it, drapeaux_méthode)
        enchaineuse.imprime_dans_enchaineuse("    méthodes_du_module[%].ml_doc = ChaineC(nul)\n", index_it)
    }

    /* Sentienelle */
    index_it_ := module.méthodes.taille
    enchaineuse.imprime_dans_enchaineuse("    méthodes_du_module[%].ml_name = ChaineC(nul)\n", index_it_)
    enchaineuse.imprime_dans_enchaineuse("    méthodes_du_module[%].ml_meth = nul\n", index_it_)
    enchaineuse.imprime_dans_enchaineuse("    méthodes_du_module[%].ml_flag = 0\n", index_it_)
    enchaineuse.imprime_dans_enchaineuse("    méthodes_du_module[%].ml_doc = ChaineC(nul)\n", index_it_)

    enchaineuse.ajoute_au_tampon("}\n")

    /* Déclaration de la globale pour la définition du module. */
    enchaineuse.ajoute_au_tampon("définition_module: PyModuleDef\n")

    /* Fonction d'initialisation pour la définition du module. */
    enchaineuse.ajoute_au_tampon("initialise_définition_module :: fonc () #nulctx\n")
    enchaineuse.ajoute_au_tampon("pousse_contexte __contexte_fil_principal {\n")
    enchaineuse.imprime_dans_enchaineuse("    définition_module.m_name = crée_chaine_c(\"%\")\n", module.nom)
    enchaineuse.ajoute_au_tampon("    définition_module.m_doc = ChaineC(nul)\n")
    enchaineuse.ajoute_au_tampon("    définition_module.m_size = -1\n")
    enchaineuse.ajoute_au_tampon("    définition_module.m_methods = *méthodes_du_module[0]\n")
    enchaineuse.ajoute_au_tampon("    définition_module.m_slots = nul\n")
    enchaineuse.ajoute_au_tampon("    définition_module.m_traverse = nul\n")
    enchaineuse.ajoute_au_tampon("    définition_module.m_clear = nul\n")
    enchaineuse.ajoute_au_tampon("    définition_module.m_free = nul\n")
    enchaineuse.ajoute_au_tampon("}\n")

    /* La fonction d'initialisation du module doit avoir la signature : PyInit_nom_module :: fonc () -> *PyObject */
    enchaineuse.imprime_dans_enchaineuse("PyInit_% :: fonc () -> *PyObject #nulctx #racine #sansbroyage\n", module.nom)
    enchaineuse.ajoute_au_tampon("{\n")

    /* Nous devons tout d'abord initialiser le contexte. */
    code_initialisation_contexte := «
    init_de(ContexteProgramme)(*__contexte_fil_principal)
    info_trace_appel := InfoFonctionTraceAppel(nom = "PyInit", fichier = "", adresse = nul)
    trace_appel := TraceAppel(info_fonction = *info_trace_appel)

    base_allocatrice : BaseAllocatrice
    stockage_temporaire : StockageTemporaire = ---

    __initialise_contexte_extra(*__contexte_fil_principal, *trace_appel, *base_allocatrice, *stockage_temporaire)»

    enchaineuse.ajoute_au_tampon(code_initialisation_contexte, "\n")

    // À FAIRE : supprimer ceci quand les globales seront proprement initialisées
    enchaineuse.ajoute_au_tampon("    Py_None = *_Py_NoneStruct\n")
    enchaineuse.ajoute_au_tampon("    Py_True = *_Py_TrueStruct\n")
    enchaineuse.ajoute_au_tampon("    Py_False = *_Py_FalseStruct\n")
    enchaineuse.ajoute_au_tampon("    initialise_méthodes()\n")
    enchaineuse.ajoute_au_tampon("    initialise_définition_module()\n")

    enchaineuse.ajoute_au_tampon("    module_pyobject := PyModule_Create2(*définition_module, PYTHON_API_VERSION)\n")

    pour module.constantes_nombre_entier {
        enchaineuse.imprime_dans_enchaineuse("    si PyModule_AddIntConstant(module_pyobject, crée_chaine_c(\"%\"), %) == -1 {\n", it.nom, it.valeur)
        enchaineuse.ajoute_au_tampon("        retourne python_retourne_rien()\n")
        enchaineuse.ajoute_au_tampon("    }\n")
    }

    pour module.constantes_chaine {
        enchaineuse.imprime_dans_enchaineuse("    si PyModule_AddStringConstant(module_pyobject, crée_chaine_c(\"%\"), crée_chaine_c(\"%\")) == -1 {\n", it.nom, it.valeur)
        enchaineuse.ajoute_au_tampon("        retourne python_retourne_rien()\n")
        enchaineuse.ajoute_au_tampon("    }\n")
    }

    pour module.types {
        enchaineuse.ajoute_au_tampon("    saufsi initialise_", it.nom_globale_type, "() {\n")
        enchaineuse.ajoute_au_tampon("        Py_DECREF(module_pyobject)\n")
        enchaineuse.ajoute_au_tampon("        retourne python_retourne_rien()\n")
        enchaineuse.ajoute_au_tampon("    }\n")
        enchaineuse.ajoute_au_tampon("    Py_INCREF(*", it.nom_globale_type, ")\n")
        // crée_chaine_c requiers un contexte
        enchaineuse.ajoute_au_tampon("    PyModule_AddObject(module_pyobject, ChaineC(\"", it.nom, "\\0\".pointeur), *", it.nom_globale_type, ")\n")
    }

    enchaineuse.ajoute_au_tampon("    retourne module_pyobject\n")
    enchaineuse.ajoute_au_tampon("}\n")
}
