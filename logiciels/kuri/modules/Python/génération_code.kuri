importe Fondation

/* Génération du code Kuri à partir des données du module. */

/* Génère les méthodes pour accéder et muter les membres du type. Retourne la globales où les méthodes sont initialisés. */
génère_méthodes_getset_pour_type :: fonc (enchaineuse: *Enchaineuse, type: *TypePython) -> chaine
{
    si type.confidentialité == ConfidentialitéType.OPAQUE {
        retourne copie_chaine("")
    }

    nombre_de_membres := type.membres.taille

    /* Déclare les fonctions get/set. */
    pour type.membres {
        type_membre := it.type
        // get : fonc (*PyObject, *rien)(*PyObject)

        enchaineuse.ajoute_au_tampon("get_", type.nom, "_", it.nom, " :: fonc (instance: *PyObject, closure: *rien@inutilisée) -> *PyObject\n")
        enchaineuse.ajoute_au_tampon("{\n")
        enchaineuse.ajoute_au_tampon("    notre_instance := (instance comme *", type.nom, "PourPython).notre_instance\n")

        si (type.drapeaux & DrapeauxType.TYPE_EST_UNION) != 0 {
            enchaineuse.ajoute_au_tampon("    discr notre_instance {\n")
            enchaineuse.ajoute_au_tampon("        ", it.nom, " {\n")
            enchaineuse.ajoute_au_tampon("            membre := notre_instance.", it.nom, "\n")
            enchaineuse.ajoute_au_tampon("            retourne ", type_membre.fonctions.pour_construction, "(membre)\n")
            enchaineuse.ajoute_au_tampon("        }\n")
            enchaineuse.ajoute_au_tampon("        sinon {\n")
            enchaineuse.ajoute_au_tampon("            retourne python_retourne_rien()\n")
            enchaineuse.ajoute_au_tampon("        }\n")
            enchaineuse.ajoute_au_tampon("    }\n")
        }
        sinon {
            enchaineuse.ajoute_au_tampon("    membre := notre_instance.", it.nom, "\n")
            enchaineuse.ajoute_au_tampon("    retourne ", type_membre.fonctions.pour_construction, "(membre)\n")
        }
        enchaineuse.ajoute_au_tampon("}\n")

        si it.confidentialité == ConfidentialitéType.MUTABLE {
            // set : fonc (*PyObject, *PyObject, *rien)(z32)
            // retourne 0 pour un succès
            // retourne -1 pour une erreur
            enchaineuse.ajoute_au_tampon("set_", type.nom, "_", it.nom, " :: fonc (instance: *PyObject, valeur: *PyObject, closure: *rien@inutilisée) -> z32\n")
            enchaineuse.ajoute_au_tampon("{\n")

            enchaineuse.ajoute_au_tampon("    si ", type_membre.fonctions.pour_discrimination, "(valeur) {\n")
            enchaineuse.ajoute_au_tampon("    notre_instance := *(instance comme *", type.nom, "PourPython).notre_instance\n")
            si it.type.est_basique {
                enchaineuse.ajoute_au_tampon("    notre_instance.", it.nom, " = ", type_membre.fonctions.pour_extraction_valeur, "(valeur)\n")
            }
            sinon {
                enchaineuse.ajoute_au_tampon("    notre_instance.", it.nom, " = ", type_membre.fonctions.pour_extraction_valeur, "(valeur).notre_instance\n")
            }
            enchaineuse.ajoute_au_tampon("    retourne 0\n")
            enchaineuse.ajoute_au_tampon("    }\n")

            si it.type.drapeaux.TYPE_EST_ÉNUM {
                assigne_énum_depuis_chaine := «
                    si PyUnicode_Check(valeur) {
                        valeur_chaine := PyUnicode_AsChaine(valeur)
                        infos := info_de(%)

                        pour infos.noms {
                            si it == valeur_chaine {
                                (instance comme *%PourPython).notre_instance.% = infos.valeurs[index_it] comme %
                                retourne 0
                            }
                        }

                        PyErr_SetObject(PyExc_ValueError, PyUnicode_FromChaine("Valeur invalide pour l'énumération"))
                        retourne -1
                    }
                »
                enchaineuse.imprime_dans_enchaineuse(assigne_énum_depuis_chaine, it.type.nom, type.nom, it.nom, it.type.nom)
            }

            chn_erreur := imprime_chaine("Ne peut assigner un objet de type % avec un objet de type", it.type.nom)
            diffère déloge(chn_erreur)

            enchaineuse.ajoute_au_tampon("    chn_type := PyType_ChaineNom(valeur)\n")
            enchaineuse.ajoute_au_tampon("    chn_erreur := enchaine(\"", chn_erreur, "\", chn_type, \" !\")\n")
            enchaineuse.ajoute_au_tampon("    PyErr_SetObject(PyExc_TypeError, PyUnicode_FromChaine(chn_erreur))\n")
            enchaineuse.ajoute_au_tampon("    retourne -1\n")
            enchaineuse.ajoute_au_tampon("}\n")
        }
    }

    nom_globale := enchaine("getset_", type.nom)

    /* Déclare la globale, nous devons un élément supplémentaire à la fin. */
    enchaineuse.imprime_dans_enchaineuse("%: [%]PyGetSetDef\n", nom_globale, nombre_de_membres + 1)

    /* Défini la fonction d'initialisation de la globale */
    enchaineuse.ajoute_au_tampon("initialise_", nom_globale, " :: fonc ()\n")
    enchaineuse.ajoute_au_tampon("{\n")
    pour type.membres {
        enchaineuse.imprime_dans_enchaineuse("    %[%].name = crée_chaine_c(\"%\")\n", nom_globale, index_it, it.nom)
        enchaineuse.imprime_dans_enchaineuse("    %[%].get = get_%_%\n", nom_globale, index_it, type.nom, it.nom)
        si it.confidentialité == ConfidentialitéType.MUTABLE {
            enchaineuse.imprime_dans_enchaineuse("    %[%].set = set_%_%\n", nom_globale, index_it, type.nom, it.nom)
        }
        sinon {
            enchaineuse.imprime_dans_enchaineuse("    %[%].set = nul\n", nom_globale, index_it, type.nom, it.nom)
        }
        enchaineuse.imprime_dans_enchaineuse("    %[%].doc = ChaineC(nul)\n", nom_globale, index_it, it.nom)
        enchaineuse.imprime_dans_enchaineuse("    %[%].closure = nul\n", nom_globale, index_it, it.nom)
    }
    enchaineuse.imprime_dans_enchaineuse("    %[%].name = ChaineC(nul)\n", nom_globale, nombre_de_membres)
    enchaineuse.imprime_dans_enchaineuse("    %[%].get = nul\n", nom_globale, nombre_de_membres)
    enchaineuse.imprime_dans_enchaineuse("    %[%].set = nul\n", nom_globale, nombre_de_membres)
    enchaineuse.imprime_dans_enchaineuse("    %[%].doc = ChaineC(nul)\n", nom_globale, nombre_de_membres)
    enchaineuse.imprime_dans_enchaineuse("    %[%].closure = nul\n", nom_globale, nombre_de_membres)
    enchaineuse.ajoute_au_tampon("}\n")

    retourne nom_globale
}

génère_fonction_new :: fonc (enchaineuse: *Enchaineuse, type: *TypePython) -> chaine
{
    méthode := type.new

    saufsi méthode.nom {
        retourne copie_chaine("")
    }

    nom_fonction_new := enchaine("new_", type.nom)

    args_inutilisés := ""
    saufsi méthode.paramètres_entrée {
        args_inutilisés = " @inutilisée"
    }

    enchaineuse.ajoute_au_tampon(nom_fonction_new, " :: fonc (subtype: *PyTypeObject, args: *PyObject", args_inutilisés, ", kwds: *PyObject @inutilisée) -> *PyObject\n")
    enchaineuse.ajoute_au_tampon("{\n")

    /* Parse les arguments. */
    génère_parsage_args_tuple(enchaineuse, méthode, "nul")

    /* Appel la fonction d'initialisation. */
    génère_conversion_args_vers_kuri(enchaineuse, méthode)

    si type.drapeaux.TOUJOURS_COMME_POINTEUR {
        enchaineuse.ajoute_au_tampon("    résultat := loge(", type.nom, ")\n")
        enchaineuse.ajoute_au_tampon("    succès := ")
        génère_appel_méthode_kuri(enchaineuse, méthode, "résultat")
    }
    sinon {
        enchaineuse.ajoute_au_tampon("    résultat :", type.nom, "\n")
        enchaineuse.ajoute_au_tampon("    succès := ")
        génère_appel_méthode_kuri(enchaineuse, méthode, "*résultat")
    }

    enchaineuse.ajoute_au_tampon("    saufsi succès {\n")
    enchaineuse.ajoute_au_tampon("        retourne nul\n")
    enchaineuse.ajoute_au_tampon("    }\n")

    /* Crée un objet python correspondant, et retourne. */
    enchaineuse.ajoute_au_tampon("    objet_résultat := subtype.tp_alloc(subtype, 0) comme *", type.nom, "PourPython\n")
    enchaineuse.ajoute_au_tampon("    objet_résultat.notre_instance = résultat\n")
    enchaineuse.ajoute_au_tampon("    retourne objet_résultat\n")
    enchaineuse.ajoute_au_tampon("}\n")

    retourne nom_fonction_new
}

génère_fonction_str :: fonc (enchaineuse: *Enchaineuse, type: *TypePython) -> chaine
{
    méthode := type.str

    saufsi méthode.nom || type.drapeaux.TYPE_EST_ÉNUM {
        retourne copie_chaine("")
    }

    nom_fonction_str := enchaine("str_", type.nom)

    // doit retourner un PyUnicodeObject
    enchaineuse.ajoute_au_tampon(nom_fonction_str, ":: fonc (self: *PyObject) -> *PyObject\n")
    enchaineuse.ajoute_au_tampon("{\n")
    enchaineuse.ajoute_au_tampon("    notre_instance := ", type.fonctions.pour_extraction_valeur, "(self).notre_instance\n")
    si type.drapeaux.TYPE_EST_ÉNUM {
        enchaineuse.ajoute_au_tampon("    info_énum := info_de(", type.nom, ")\n")
        enchaineuse.ajoute_au_tampon("    résultat := info_énum.noms[notre_instance comme z32]\n")
    }
    sinon {
        enchaineuse.ajoute_au_tampon("    résultat := ", méthode.nom, "(*notre_instance)\n")
    }
    enchaineuse.ajoute_au_tampon("    retourne PyUnicode_FromChaine(résultat)\n")
    enchaineuse.ajoute_au_tampon("}\n")

    retourne nom_fonction_str
}

/* https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_hash */
génère_fonction_hash :: fonc (enchaineuse: *Enchaineuse, type: *TypePython) -> chaine
{
    méthode := type.hash

    si méthode.nom {
        nom_fonction_hash := enchaine("hash_", type.nom)

        enchaineuse.ajoute_au_tampon(nom_fonction_hash, ":: fonc (self: *PyObject) -> Py_hash_t\n")
        enchaineuse.ajoute_au_tampon("{\n")
        enchaineuse.ajoute_au_tampon("    notre_instance := ", type.fonctions.pour_extraction_valeur, "(self).notre_instance\n")
        enchaineuse.ajoute_au_tampon("    résultat := ", méthode.nom, "(*notre_instance)\n")
        enchaineuse.ajoute_au_tampon("    retourne résultat\n")
        enchaineuse.ajoute_au_tampon("}\n")

        retourne nom_fonction_hash
    }

    /* Pour les énums, nous retournons simplement la valeur, qui est sensée être unique. */
    si type.drapeaux.TYPE_EST_ÉNUM {
        nom_fonction_hash := enchaine("hash_", type.nom)

        enchaineuse.ajoute_au_tampon(nom_fonction_hash, ":: fonc (self: *PyObject) -> Py_hash_t\n")
        enchaineuse.ajoute_au_tampon("{\n")
        enchaineuse.ajoute_au_tampon("    notre_instance := ", type.fonctions.pour_extraction_valeur, "(self).notre_instance\n")
        enchaineuse.ajoute_au_tampon("    info_énum := info_de(", type.nom, ")\n")
        enchaineuse.ajoute_au_tampon("    résultat := info_énum.valeurs[notre_instance comme z32]\n")
        enchaineuse.ajoute_au_tampon("    retourne résultat\n")
        enchaineuse.ajoute_au_tampon("}\n")

        retourne nom_fonction_hash
    }

    /* Pour les types étant toujours stockés par adresse, nous pouvons utilisé l'adresse comme empreinte. */
    si type.drapeaux.TOUJOURS_COMME_POINTEUR {
        nom_fonction_hash := enchaine("hash_", type.nom)

        enchaineuse.ajoute_au_tampon(nom_fonction_hash, ":: fonc (self: *PyObject) -> Py_hash_t\n")
        enchaineuse.ajoute_au_tampon("{\n")
        enchaineuse.ajoute_au_tampon("    notre_instance := ", type.fonctions.pour_extraction_valeur, "(self).notre_instance\n")
        enchaineuse.ajoute_au_tampon("    retourne notre_instance comme z64\n")
        enchaineuse.ajoute_au_tampon("}\n")

        retourne nom_fonction_hash
    }

    /* PyObject_HashNotImplemented doit être utilisé afin de pouvoir bloquer l'héritage
     * de la fonction de hachage des parents, et permet d'utiliser correctement
     * isinstance(o, collections.Hashable).
     */
    retourne copie_chaine("PyObject_HashNotImplemented")
}

/* https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_richcompare */
génère_fonction_richcompare :: fonc (enchaineuse: *Enchaineuse, type: *TypePython) -> chaine
{
    saufsi type.drapeaux.TYPE_EST_ÉNUM {
        retourne copie_chaine("")
    }

    nom_fonction_richcompare := enchaine("richcompare_", type.nom)

    compare_énum_avec_chaine := «
    si PyUnicode_Check(other) {
        valeur_chaine := PyUnicode_AsChaine(other)
        valeur_énum := Py%_As%(self).notre_instance

        infos := info_de(%)
        valeur_énum_comme_chaine := infos.noms[valeur_énum comme z32]

        si op == Py_EQ {
            si valeur_chaine == valeur_énum_comme_chaine {
                retourne Py_NewRef(Py_True)
            }
            retourne Py_NewRef(Py_False)
        }

        si op == Py_NE {
            si valeur_chaine != valeur_énum_comme_chaine {
                retourne Py_NewRef(Py_True)
            }
            retourne Py_NewRef(Py_False)
        }

        retourne Py_NewRef(Py_NotImplemented)
    }
    »

    compare_énum_avec_énum := «
    si Py%_Check(other) {
        valeur1 := Py%_As%(self).notre_instance
        valeur2 := Py%_As%(other).notre_instance

        si op == Py_EQ {
            si valeur1 == valeur2 {
                retourne Py_NewRef(Py_True)
            }
            retourne Py_NewRef(Py_False)
        }

        si op == Py_NE {
            si valeur1 != valeur2 {
                retourne Py_NewRef(Py_True)
            }
            retourne Py_NewRef(Py_False)
        }

        retourne Py_NewRef(Py_NotImplemented)
    }
    »

    enchaineuse.ajoute_au_tampon(nom_fonction_richcompare, ":: fonc (self: *PyObject, other: *PyObject, op: z32) -> *PyObject\n")
    enchaineuse.ajoute_au_tampon("{\n")

    enchaineuse.imprime_dans_enchaineuse(compare_énum_avec_chaine, type.nom, type.nom, type.nom)
    enchaineuse.imprime_dans_enchaineuse(compare_énum_avec_énum, type.nom, type.nom, type.nom, type.nom, type.nom)

    chn_erreur := imprime_chaine("Ne peut comparer un objet de type % avec un objet de type", type.nom)
    diffère déloge(chn_erreur)

    enchaineuse.ajoute_au_tampon("    chn_type := PyType_ChaineNom(other)\n")
    enchaineuse.ajoute_au_tampon("    chn_erreur := enchaine(\"", chn_erreur, "\", chn_type, \" !\")\n")
    enchaineuse.ajoute_au_tampon("    PyErr_SetObject(PyExc_TypeError, PyUnicode_FromChaine(chn_erreur))\n")
    enchaineuse.ajoute_au_tampon("    retourne nul\n")
    enchaineuse.ajoute_au_tampon("}\n")

    retourne nom_fonction_richcompare
}

génère_fonction_repr :: fonc (enchaineuse: *Enchaineuse, type: *TypePython) -> chaine
{
    méthode := type.repr

    saufsi méthode.nom {
        retourne copie_chaine("")
    }

    nom_fonction_repr := enchaine("repr_", type.nom)

    // doit retourner un PyUnicodeObject
    enchaineuse.ajoute_au_tampon(nom_fonction_repr, ":: fonc (self: *PyObject) -> *PyObject\n")
    enchaineuse.ajoute_au_tampon("{\n")
    enchaineuse.ajoute_au_tampon("    notre_instance := ", type.fonctions.pour_extraction_valeur, "(self).notre_instance\n")
    enchaineuse.ajoute_au_tampon("    résultat := ", méthode.nom, "(*notre_instance)\n")
    enchaineuse.ajoute_au_tampon("    résultat = enchaine(\"", type.nom, "('\", résultat, \"')\")\n")
    enchaineuse.ajoute_au_tampon("    retourne PyUnicode_FromChaine(résultat)\n")
    enchaineuse.ajoute_au_tampon("}\n")

    retourne nom_fonction_repr
}

génère_déclaration_type_python :: fonc (enchaineuse: *Enchaineuse, module: &ModulePython, type: *TypePython)
{
    /* Déclaration de la structure associée, dérivée de PyObject.
     * Pour une structure appelée « Structure », la version Python s'appelera « StructurePourPython ». */
    enchaineuse.ajoute_au_tampon(type.nom, "PourPython :: struct {\n")
    enchaineuse.ajoute_au_tampon("    empl base: PyObject\n")
    symbole_pointeur := ""
    si type.drapeaux.TOUJOURS_COMME_POINTEUR {
        symbole_pointeur = "*"
    }
    si type.drapeaux.TYPE_EST_ITÉRATEUR {
        enchaineuse.ajoute_au_tampon("    notre_instance: ", type.type_itéré.nom_type_kuri, "\n")
        enchaineuse.ajoute_au_tampon("    index_courant: z64\n")
    }
    sinon {
        enchaineuse.ajoute_au_tampon("    notre_instance: ", symbole_pointeur, type.nom_type_kuri, "\n")
    }
    enchaineuse.ajoute_au_tampon("}\n")

    /* Déclaration de la globale qui servira pour contenir les données sur le type Python.
     * Cet objet s'appel « TypeStructurePourPython ». */
    nom_globale_type := type.nom_globale_type
    enchaineuse.ajoute_au_tampon(nom_globale_type, ": PyTypeObject\n")

    /* Déclaration des FonctionsTypePython. */
    génère_déclaration_fonctions_pour_python(enchaineuse, type, symbole_pointeur)

    /*
        À FAIRE : méthodes types
            __init__ pour les membres mutables

            NomDuType.tp_flags = Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE;

     */

    si type.méthodes {
        pour type.méthodes {
            génère_interface_fonction(enchaineuse, it, type)
        }
        nom_tableau := enchaine("méthodes_", type.nom)
        diffère déloge(nom_tableau)
        génère_tableaux_méthodes(enchaineuse, type.méthodes, nom_tableau)
    }

    globale_getset := génère_méthodes_getset_pour_type(enchaineuse, type)
    diffère déloge(globale_getset)

    fonction_new := génère_fonction_new(enchaineuse, type)
    diffère déloge(fonction_new)

    // À FAIRE __init__
    // fonction_init := génère_fonction_init(enchaineuse, type)
    // diffère déloge(fonction_init)

    fonction_str := génère_fonction_str(enchaineuse, type)
    diffère déloge(fonction_str)

    fonction_repr := génère_fonction_repr(enchaineuse, type)
    diffère déloge(fonction_repr)

    fonction_richcompare := génère_fonction_richcompare(enchaineuse, type)
    diffère déloge(fonction_richcompare)

    fonction_itérateur := génère_fonction_pour_créer_itérateur(enchaineuse, type)
    diffère déloge(fonction_itérateur)

    fonction_itérateur_next := génère_fonction_itérateur_next(enchaineuse, type)
    diffère déloge(fonction_itérateur_next)

    fonction_hash := génère_fonction_hash(enchaineuse, type)
    diffère déloge(fonction_hash)

    /* Définition de la fonction d'initialisation de la globale pour le type Python. */
    enchaineuse.ajoute_au_tampon("initialise_", nom_globale_type, " :: fonc () -> bool\n")
    enchaineuse.ajoute_au_tampon("{\n")

    /* Le nom requis pour Python, qui est de forme <module>.<nom>. */
    tp_name := enchaine(module.nom, ".", type.nom)
    diffère déloge(tp_name)

    enchaineuse.ajoute_au_tampon("    init_de(PyTypeObject)(*", nom_globale_type, ")\n")
    enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".ob_refcnt = 1\n")
    enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".ob_size = 0\n")
    enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".tp_basicsize = taille_de(", type.nom, "PourPython) comme Py_ssize_t\n")
    enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".tp_name = crée_chaine_c(\"", tp_name, "\")\n")
    enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".tp_flags = 1 << 10 | 1 << 18\n")

    si type.méthodes {
        enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".tp_methods = *méthodes_", type.nom, "[0]\n")
    }

    si fonction_new {
        enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".tp_new = ", fonction_new, "\n")
    }

    si fonction_str {
        enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".tp_str = ", fonction_str, "\n")
    }

    si fonction_repr {
        enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".tp_repr = ", fonction_repr, "\n")
    }

    si fonction_richcompare {
        enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".tp_richcompare = ", fonction_richcompare, "\n")
    }

    si fonction_itérateur {
        enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".tp_iter = ", fonction_itérateur, "\n")
    }

    si fonction_itérateur_next {
        enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".tp_iternext = ", fonction_itérateur_next, "\n")
    }

    si globale_getset {
        enchaineuse.ajoute_au_tampon("    initialise_getset_", type.nom, "()\n")
        enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".tp_getset = *", globale_getset, "[0]\n")
    }

    si type.base {
        enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".tp_base = *", type.base.nom_globale_type, "\n")
    }
    sinon {
        enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".tp_base = *PyBaseObject_Type\n")
    }

    enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".tp_hash = ", fonction_hash, "\n")

    enchaineuse.ajoute_au_tampon("    retourne PyType_Ready(*", nom_globale_type, ") != -1\n")
    enchaineuse.ajoute_au_tampon("}\n")
}

génère_déclaration_fonctions_pour_python :: fonc (enchaineuse: *Enchaineuse, type: *TypePython, symbole_pointeur: chaine)
{
    enchaineuse.ajoute_au_tampon(type.fonctions.pour_extraction_valeur, " :: fonc (self: *PyObject) -> *", type.nom, "PourPython\n")
    enchaineuse.ajoute_au_tampon("{\n")
    enchaineuse.ajoute_au_tampon("    retourne self comme *", type.nom, "PourPython\n")
    enchaineuse.ajoute_au_tampon("}\n")

    si type.drapeaux.TYPE_EST_ITÉRATEUR {
        /* Les autres fonctions ne sont pas disponibles pour les itérateurs. */
        retourne
    }

    enchaineuse.ajoute_au_tampon(type.fonctions.pour_discrimination, " :: fonc (self: *PyObject) -> bool\n")
    enchaineuse.ajoute_au_tampon("{\n")
    enchaineuse.ajoute_au_tampon("    si PyObject_TypeCheck(self, *", type.nom_globale_type, ") {\n")
    enchaineuse.ajoute_au_tampon("        retourne vrai\n")
    enchaineuse.ajoute_au_tampon("    }\n")
    si type.drapeaux.TYPE_EST_ÉNUM {
        enchaineuse.ajoute_au_tampon("    si PyUnicodeEnum_Check(self, info_de(", type.nom, ")) {\n")
        enchaineuse.ajoute_au_tampon("        retourne vrai;\n")
        enchaineuse.ajoute_au_tampon("    }\n")
    }
    si type.drapeaux.TOUJOURS_COMME_POINTEUR {
        enchaineuse.ajoute_au_tampon("    si self == Py_None {\n")
        enchaineuse.ajoute_au_tampon("        retourne vrai;\n")
        enchaineuse.ajoute_au_tampon("    }\n")
    }
    enchaineuse.ajoute_au_tampon("    retourne faux\n")
    enchaineuse.ajoute_au_tampon("}\n")
    enchaineuse.ajoute_au_tampon(type.fonctions.pour_construction, " :: fonc (valeur: ", symbole_pointeur, type.nom_type_kuri, ") -> *", type.nom, "PourPython\n")
    enchaineuse.ajoute_au_tampon("{\n")

    si type.drapeaux.TOUJOURS_COMME_POINTEUR {
        enchaineuse.ajoute_au_tampon("    saufsi valeur {\n")
        enchaineuse.ajoute_au_tampon("        retourne python_retourne_rien() comme *", type.nom, "PourPython\n")
        enchaineuse.ajoute_au_tampon("    }\n")
    }

    si type.drapeaux.REQUIERS_RAFINAGE {
        enchaineuse.ajoute_au_tampon("    ob_type := rafine_type_", type.nom, "(valeur)\n")
        enchaineuse.ajoute_au_tampon("    résultat := ob_type.tp_alloc(ob_type, 1) comme *", type.nom, "PourPython\n")
        enchaineuse.ajoute_au_tampon("    résultat.ob_type = ob_type\n")
    }
    sinon {
        enchaineuse.ajoute_au_tampon("    résultat := ", type.nom_globale_type, ".tp_alloc(*", type.nom_globale_type, ", 1) comme *", type.nom, "PourPython\n")
    }

    enchaineuse.ajoute_au_tampon("    résultat.notre_instance = valeur\n")
    enchaineuse.ajoute_au_tampon("    retourne résultat\n")
    enchaineuse.ajoute_au_tampon("}\n")
}


génère_fonction_pour_créer_itérateur :: fonc (enchaineuse: *Enchaineuse, type: *TypePython) -> chaine
{
    saufsi type.type_itérateur {
        retourne copie_chaine("")
    }

    nom_fonction := enchaine("itérateur_pour_", type.nom)

    corps_fonction := «
    type_itérateur := *%
    py_itérateur_ := type_itérateur.tp_alloc(type_itérateur, 1)
    py_itérateur := %(py_itérateur_)
    py_itérateur.notre_instance = %(ob).notre_instance
    py_itérateur.index_courant = 0
    retourne py_itérateur comme *PyObject
    »

    enchaineuse.ajoute_au_tampon(nom_fonction, " :: fonc (ob: *PyObject) -> *PyObject\n")
    enchaineuse.ajoute_au_tampon("{\n")
    enchaineuse.imprime_dans_enchaineuse(corps_fonction, type.type_itérateur.nom_globale_type, type.type_itérateur.fonctions.pour_extraction_valeur, type.fonctions.pour_extraction_valeur)
    enchaineuse.ajoute_au_tampon("}\n")

    retourne nom_fonction
}

génère_fonction_itérateur_next :: fonc (enchaineuse: *Enchaineuse, type: *TypePython) -> chaine
{
    saufsi type.drapeaux.TYPE_EST_ITÉRATEUR {
        retourne copie_chaine("")
    }

    nom_fonction := enchaine("itérateur_pour_next_", type.nom)

    corps_fonction := «
    py_self := %(self)

    si py_self.index_courant >= py_self.notre_instance.taille {
        retourne nul
    }

    valeur_courante := py_self.notre_instance[py_self.index_courant]

    py_valeur_courante := %(valeur_courante)

    py_self.index_courant += 1
    retourne py_valeur_courante
    »

    enchaineuse.ajoute_au_tampon(nom_fonction, " :: fonc (self: *PyObject) -> *PyObject\n")
    enchaineuse.ajoute_au_tampon("{\n")
    enchaineuse.imprime_dans_enchaineuse(corps_fonction, type.fonctions.pour_extraction_valeur, type.type_itéré.type_élément.fonctions.pour_construction)
    enchaineuse.ajoute_au_tampon("}\n")

    retourne nom_fonction
}

/* Extrait les paramètres des arguments passés à la fonction. Pour le moment ces arguments
 * ont des types conforment à Python. Le nom des arguments doit être "args". */
génère_parsage_args_tuple :: fonc (enchaineuse: *Enchaineuse, méthode: &MéthodePython, valeur_retour: chaine)
{
    saufsi méthode.paramètres_entrée {
        retourne
    }

    pour méthode.paramètres_entrée {
        enchaineuse.imprime_dans_enchaineuse("    pyobject_%: *PyObject\n", it.nom)
    }

    enchaineuse.ajoute_au_tampon("    saufsi PyArg_ParseTuple(args, crée_chaine_c(\"")
    pour méthode.paramètres_entrée {
        enchaineuse.ajoute_au_tampon("O")
    }
    enchaineuse.ajoute_au_tampon("\")")
    virgule := ", "
    pour méthode.paramètres_entrée {
        enchaineuse.ajoute_au_tampon(virgule, "*pyobject_", it.nom)
    }
    enchaineuse.ajoute_au_tampon(") {\n")
    enchaineuse.ajoute_au_tampon("        retourne ", valeur_retour, "\n")
    enchaineuse.ajoute_au_tampon("    }\n")

    /* Vérifie que les types sont ceux attendus. */
    pour méthode.paramètres_entrée {
        chn_erreur := imprime_chaine("Mauvais type pour l'argument % ! Attendu : %, obtenu : ", it.nom, it.type.nom)
        diffère déloge(chn_erreur)

        enchaineuse.ajoute_au_tampon("    saufsi ", it.type.fonctions.pour_discrimination, "(pyobject_", it.nom, ") {\n")
        enchaineuse.ajoute_au_tampon("        chn_type := PyType_ChaineNom(pyobject_", it.nom, ")\n")
        enchaineuse.ajoute_au_tampon("        chn_erreur := enchaine(\"", chn_erreur, "\", chn_type, \" !\")\n")
        enchaineuse.ajoute_au_tampon("        PyErr_SetObject(PyExc_TypeError, PyUnicode_FromChaine(chn_erreur))\n")
        enchaineuse.ajoute_au_tampon("        déloge(chn_type); déloge(chn_erreur)\n")
        enchaineuse.ajoute_au_tampon("        retourne ", valeur_retour, "\n")
        enchaineuse.ajoute_au_tampon("    }\n")
    }
}

/* Convertis les paramètres de fonction vers des objets de type Kuri natif (les types du programme). */
génère_conversion_args_vers_kuri :: fonc (enchaineuse: *Enchaineuse, méthode: &MéthodePython)
{
    chaine_pour_extraction_énum := «
    % : %
    si PyUnicode_Check(pyobject_%) {
        % = PyUnicodeEnum_Value(pyobject_%, info_de(%)) comme %
    }
    sinon {
        % = %(pyobject_%).notre_instance
    }
    »

    pour méthode.paramètres_entrée {
        si it.type.drapeaux.TYPE_EST_ÉNUM {
            enchaineuse.imprime_dans_enchaineuse(chaine_pour_extraction_énum, it.nom, it.type.nom, it.nom, it.nom, it.nom, it.type.nom, it.type.nom, it.nom, it.type.fonctions.pour_extraction_valeur, it.nom)
            continue
        }
        enchaineuse.ajoute_au_tampon("    ", it.nom, " := ", it.type.fonctions.pour_extraction_valeur, "(pyobject_", it.nom, ")\n")
    }
}

// Génère l'expression d'appel pour le code Kuri de la méthode. La fonction appelante doit gérer la potentielle valeur de retour (nom, assignation, etc.).
génère_appel_méthode_kuri :: fonc (enchaineuse: *Enchaineuse, méthode: &MéthodePython, premier_paramètre_implicite: chaine = "")
{
    enchaineuse.ajoute_au_tampon(méthode.nom)
    virgule := "("
    si premier_paramètre_implicite  {
        enchaineuse.ajoute_au_tampon(virgule, premier_paramètre_implicite)
        virgule = ", "
    }
    sinon saufsi méthode.paramètres_entrée {
        enchaineuse.ajoute_au_tampon(virgule)
    }
    pour méthode.paramètres_entrée {
        enchaineuse.ajoute_au_tampon(virgule)
        si it.param_originel_est_pointeur && it.type.drapeaux.TOUJOURS_COMME_POINTEUR == faux {
            enchaineuse.ajoute_au_tampon("*")
        }
        enchaineuse.ajoute_au_tampon(it.nom)
        saufsi it.type.est_basique || it.type.drapeaux.TYPE_EST_ÉNUM {
            enchaineuse.ajoute_au_tampon(".notre_instance")
        }
        virgule = ", "
    }
    enchaineuse.ajoute_au_tampon(")\n")
}

génère_interface_fonction :: fonc (enchaineuse: *Enchaineuse, méthode: MéthodePython, self: *TypePython = nul)
{
    // À FAIRE : initialisation des variables globales de kuri

    /* self, pour les méthodes de module, c'est la méthode, pour le reste, c'est l'objet */
    self_inutilisé := ""
    saufsi self {
        self_inutilisé = " @inutilisée"
    }
    args_inutilisés := ""
    saufsi méthode.paramètres_entrée {
        args_inutilisés = " @inutilisée"
    }

    enchaineuse.imprime_dans_enchaineuse("% :: fonc (self: *PyObject%, args: *PyObject%) -> *PyObject\n", méthode.nom_enveloppe, self_inutilisé, args_inutilisés)
    enchaineuse.ajoute_au_tampon("{\n")

    génère_parsage_args_tuple(enchaineuse, méthode, "nul")
    génère_conversion_args_vers_kuri(enchaineuse, méthode)

    si self {
        enchaineuse.ajoute_au_tampon("    self_kuri := ", self.fonctions.pour_extraction_valeur, "(self)\n")
    }

    /* Appel la fonction. */
    possède_retour := !méthode.ne_retourne_rien()

    enchaineuse.ajoute_au_tampon("    ")
    si possède_retour {
        enchaineuse.ajoute_au_tampon("résultat := ")
    }

    arg_implicite := ""
    si self {
        si self.drapeaux.TOUJOURS_COMME_POINTEUR {
            arg_implicite = "self_kuri.notre_instance"
        }
        sinon {
            arg_implicite = "*self_kuri.notre_instance"
        }
    }

    génère_appel_méthode_kuri(enchaineuse, méthode, arg_implicite)

    si possède_retour {
        type_sortie := méthode.paramètres_sortie[0].type
        enchaineuse.ajoute_au_tampon("    retourne ", type_sortie.fonctions.pour_construction, "(résultat)\n")
    }
    sinon {
        enchaineuse.ajoute_au_tampon("    retourne python_retourne_rien()\n")
    }

    enchaineuse.ajoute_au_tampon("}\n")
}

génère_tableaux_méthodes :: fonc (enchaineuse: *Enchaineuse, méthodes: []MéthodePython, nom_tableau: chaine)
{
    /* Déclare le tableau de méthodes. Il y a une méthode supplémentaire nulle comme sentinelle. */
    enchaineuse.imprime_dans_enchaineuse("% : [%]PyMethodDef\n", nom_tableau, méthodes.taille + 1)

    /* Fonction d'initialisation pour les méthodes. */
    enchaineuse.imprime_dans_enchaineuse("initialise_% :: fonc ()\n", nom_tableau)
    enchaineuse.ajoute_au_tampon("{\n")

    pour méthodes {
        enchaineuse.imprime_dans_enchaineuse("    %[%].ml_name = crée_chaine_c(\"%\")\n", nom_tableau, index_it, it.nom)
        enchaineuse.imprime_dans_enchaineuse("    %[%].ml_meth = %\n", nom_tableau, index_it, it.nom_enveloppe)

        drapeaux_méthode := ""
        si it.paramètres_entrée {
            drapeaux_méthode = "METH_VARARGS"
        }
        sinon {
            drapeaux_méthode = "METH_NOARGS"
        }

        enchaineuse.imprime_dans_enchaineuse("    %[%].ml_flag = %\n", nom_tableau, index_it, drapeaux_méthode)
        enchaineuse.imprime_dans_enchaineuse("    %[%].ml_doc = ChaineC(nul)\n", nom_tableau, index_it)
    }

    /* Sentienelle */
    index_it_ := méthodes.taille
    enchaineuse.imprime_dans_enchaineuse("    %[%].ml_name = ChaineC(nul)\n", nom_tableau, index_it_)
    enchaineuse.imprime_dans_enchaineuse("    %[%].ml_meth = nul\n", nom_tableau, index_it_)
    enchaineuse.imprime_dans_enchaineuse("    %[%].ml_flag = 0\n", nom_tableau, index_it_)
    enchaineuse.imprime_dans_enchaineuse("    %[%].ml_doc = ChaineC(nul)\n", nom_tableau, index_it_)

    enchaineuse.ajoute_au_tampon("}\n")
}

génère_initialisation_type :: fonc (enchaineuse: *Enchaineuse, type: *TypePython)
{
    si type.code_pour_init_module_fut_généré {
        retourne
    }

    si type.base {
        génère_initialisation_type(enchaineuse, type.base)
    }

    enchaineuse.ajoute_au_tampon("    saufsi initialise_", type.nom_globale_type, "() {\n")
    enchaineuse.ajoute_au_tampon("        Py_DECREF(module_pyobject)\n")
    enchaineuse.ajoute_au_tampon("        retourne python_retourne_rien()\n")
    enchaineuse.ajoute_au_tampon("    }\n")
    type.code_pour_init_module_fut_généré = vrai
}

génère_initialisation_module :: fonc (enchaineuse: *Enchaineuse, module: &ModulePython, types: []*TypePython)
{
    génère_tableaux_méthodes(enchaineuse, module.méthodes, "méthodes_du_module")

    /* Déclaration de la globale pour la définition du module. */
    enchaineuse.ajoute_au_tampon("définition_module: PyModuleDef\n")

    /* Fonction d'initialisation pour la définition du module. */
    enchaineuse.ajoute_au_tampon("initialise_définition_module :: fonc ()\n")
    enchaineuse.ajoute_au_tampon("{\n")
    enchaineuse.imprime_dans_enchaineuse("    définition_module.m_name = crée_chaine_c(\"%\")\n", module.nom)
    enchaineuse.ajoute_au_tampon("    définition_module.m_doc = ChaineC(nul)\n")
    enchaineuse.ajoute_au_tampon("    définition_module.m_size = -1\n")
    enchaineuse.ajoute_au_tampon("    définition_module.m_methods = *méthodes_du_module[0]\n")
    enchaineuse.ajoute_au_tampon("    définition_module.m_slots = nul\n")
    enchaineuse.ajoute_au_tampon("    définition_module.m_traverse = nul\n")
    enchaineuse.ajoute_au_tampon("    définition_module.m_clear = nul\n")
    enchaineuse.ajoute_au_tampon("    définition_module.m_free = nul\n")
    enchaineuse.ajoute_au_tampon("}\n")

    /* Globales nécessaires pour Kuri. */
    enchaineuse.ajoute_au_tampon("PY__info_trace_appel : InfoFonctionTraceAppel = ---\n")
    enchaineuse.ajoute_au_tampon("PY__trace_appel : TraceAppel = ---\n")
    enchaineuse.ajoute_au_tampon("PY__base_allocatrice : BaseAllocatrice = ---\n")
    enchaineuse.ajoute_au_tampon("PY__stockage_temporaire : StockageTemporaire = ---\n")

    /* La fonction d'initialisation du module doit avoir la signature : PyInit_nom_module :: fonc () -> *PyObject */
    enchaineuse.imprime_dans_enchaineuse("PyInit_% :: fonc () -> *PyObject #racine #sansbroyage #sanstrace\n", module.nom)
    enchaineuse.ajoute_au_tampon("{\n")

    /* Nous devons tout d'abord initialiser le contexte. */
    code_initialisation_contexte := «
    init_de(ContexteProgramme)(*__contexte_fil_principal)
    PY__info_trace_appel = InfoFonctionTraceAppel(nom = "PyInit", fichier = "", adresse = nul)
    PY__trace_appel = TraceAppel(info_fonction = *PY__info_trace_appel)
    PY__base_allocatrice = BaseAllocatrice()
    __initialise_contexte_extra(*__contexte_fil_principal, *PY__trace_appel, *PY__base_allocatrice, *PY__stockage_temporaire)»

    enchaineuse.ajoute_au_tampon(code_initialisation_contexte, "\n")

    // À FAIRE : supprimer ceci quand les globales seront proprement initialisées
    enchaineuse.ajoute_au_tampon("    Py_None = *_Py_NoneStruct\n")
    enchaineuse.ajoute_au_tampon("    Py_True = *_Py_TrueStruct\n")
    enchaineuse.ajoute_au_tampon("    Py_False = *_Py_FalseStruct\n")
    enchaineuse.ajoute_au_tampon("    Py_NotImplemented = *_Py_NotImplementedStruct\n")
    enchaineuse.ajoute_au_tampon("    initialise_méthodes_du_module()\n")
    enchaineuse.ajoute_au_tampon("    initialise_définition_module()\n")

    pour types {
        si it.méthodes {
            enchaineuse.ajoute_au_tampon("    initialise_méthodes_", it.nom,"()\n")
        }
    }

    enchaineuse.ajoute_au_tampon("    module_pyobject := PyModule_Create2(*définition_module, PYTHON_API_VERSION)\n")

    pour module.constantes_nombre_entier {
        enchaineuse.imprime_dans_enchaineuse("    si PyModule_AddIntConstant(module_pyobject, crée_chaine_c(\"%\"), %) == -1 {\n", it.nom, it.valeur)
        enchaineuse.ajoute_au_tampon("        retourne python_retourne_rien()\n")
        enchaineuse.ajoute_au_tampon("    }\n")
    }

    pour module.constantes_chaine {
        enchaineuse.imprime_dans_enchaineuse("    si PyModule_AddStringConstant(module_pyobject, crée_chaine_c(\"%\"), crée_chaine_c(\"%\")) == -1 {\n", it.nom, it.valeur)
        enchaineuse.ajoute_au_tampon("        retourne python_retourne_rien()\n")
        enchaineuse.ajoute_au_tampon("    }\n")
    }

    /* Initialisation des types. */
    pour types {
        si it.est_basique {
            continue
        }
        génère_initialisation_type(enchaineuse, it)
    }

    /* Après que tous les types furent initialisés, ajoutons-les au module.
     * Nous faisons cela séparement afin que le Py_DECREF utilisé en cas d'erreur
     * d'initialisation détruise correctement le module (jusqu'ici son compte
     * de référence est de 1, il sera incrémenté pour chaque type).
     */
    pour types {
        si it.est_basique {
            continue
        }

        enchaineuse.ajoute_au_tampon("    Py_INCREF(*", it.nom_globale_type, ")\n")
        // crée_chaine_c requiers un contexte
        enchaineuse.ajoute_au_tampon("    PyModule_AddObject(module_pyobject, ChaineC(\"", it.nom, "\\0\".pointeur), *", it.nom_globale_type, ")\n")
    }

    enchaineuse.ajoute_au_tampon("    retourne module_pyobject\n")
    enchaineuse.ajoute_au_tampon("}\n")
}
