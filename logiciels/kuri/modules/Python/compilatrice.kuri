importe Compilatrice
importe Fondation

/* Compilatrice pour un module Python. */

/* Les diffèrentes erreurs de compilation possibles. */
CodeErreurCompilationPython :: énum {
    ANNOTATION_INVALIDE
    FONCTION_INIT_REQUIERS_STRUCTURE
    FONCTION_NEW_REQUIERS_STRUCTURE
    FONCTION_REPR_REQUIERS_STRUCTURE
    FONCTION_STR_REQUIERS_STRUCTURE
    TYPE_ENTRÉE_REPR
    TYPE_ENTRÉE_STR
    TYPE_RETOUR_INIT
    TYPE_RETOUR_NEW
    TYPE_RETOUR_REPR
    TYPE_RETOUR_STR
    TYPE_INCONNU_DE_PYTHON
    TROP_D_ANNOTATIONS
}

chaine_méthode_python_pour_code_erreur :: fonc (code_erreur: CodeErreurCompilationPython) -> chaine
{
    discr code_erreur {
        FONCTION_NEW_REQUIERS_STRUCTURE,
        TYPE_RETOUR_NEW {
            retourne "new"
        }
        FONCTION_INIT_REQUIERS_STRUCTURE,
        TYPE_RETOUR_INIT {
            retourne "__init__"
        }
        FONCTION_STR_REQUIERS_STRUCTURE,
        TYPE_ENTRÉE_STR,
        TYPE_RETOUR_STR {
            retourne "__str__"
        }
        FONCTION_REPR_REQUIERS_STRUCTURE,
        TYPE_ENTRÉE_REPR,
        TYPE_RETOUR_REPR {
            retourne "__repr__"
        }
        sinon {
            retourne ""
        }
    }
}

ContexteErreurPython :: struct {
    fonction: *NoeudCodeEntêteFonction
    type_inconnu: *InfoType
}

rapporte_erreur :: fonc (code_erreur: CodeErreurCompilationPython, ctx: ContexteErreurPython)
{
    enchaineuse: Enchaineuse
    initialise_enchaineuse(*enchaineuse)

    discr code_erreur {
        FONCTION_NEW_REQUIERS_STRUCTURE,
        FONCTION_INIT_REQUIERS_STRUCTURE,
        FONCTION_REPR_REQUIERS_STRUCTURE,
        FONCTION_STR_REQUIERS_STRUCTURE {
            nom_méthode := chaine_méthode_python_pour_code_erreur(code_erreur)
            imprime_dans_enchaineuse(*enchaineuse, "La fonction « % » pour un type accessible via Python requiers un pointeur de structure ou d'union comme premier paramètre.\n", nom_méthode)

            type := type_premier_paramètre(ctx.fonction)
            si type == nul {
                ajoute_au_tampon(*enchaineuse, "Or, la fonction n'a pas de paramètres.")
            }
            sinon {
                ajoute_au_tampon(*enchaineuse, "Or, le type du premier paramètre est « ")
                imprime_type(*enchaineuse, type)
                ajoute_au_tampon(*enchaineuse, " ».\n")
            }
        }
        TYPE_ENTRÉE_STR,
        TYPE_ENTRÉE_REPR {
            nom_méthode := chaine_méthode_python_pour_code_erreur(code_erreur)
            imprime_dans_enchaineuse(*enchaineuse, "La fonction « % » pour un type accessible via Python ne doit prendre qu'un seul paramètre.\n", nom_méthode)
        }
        TYPE_RETOUR_NEW,
        TYPE_RETOUR_INIT {
            nom_méthode := chaine_méthode_python_pour_code_erreur(code_erreur)
            imprime_dans_enchaineuse(*enchaineuse, "La fonction « % » pour un type accessible via Python doit retourner une valeur unique de type « bool ».\n", nom_méthode)
        }
        TYPE_RETOUR_STR,
        TYPE_RETOUR_REPR {
            nom_méthode := chaine_méthode_python_pour_code_erreur(code_erreur)
            imprime_dans_enchaineuse(*enchaineuse, "La fonction « % » pour un type accessible via Python doit retourner une valeur unique de type « chaine ».\n", nom_méthode)
        }
        TYPE_INCONNU_DE_PYTHON {
            ajoute_au_tampon(*enchaineuse, "Un type requis pour la compilation du module Python n'est pas connu : ")
            imprime_type(*enchaineuse, ctx.type_inconnu)
            ajoute_au_tampon(*enchaineuse, "\n")
            ajoute_au_tampon(*enchaineuse, "Veuillez vous assurer que le type fut ajouté au module.\n")
        }
        ANNOTATION_INVALIDE {
            ajoute_au_tampon(*enchaineuse, "Une fonction fut annotée pour Python, mais la valeur de l'annotation est invalide.\n")
        }
        TROP_D_ANNOTATIONS {
            ajoute_au_tampon(*enchaineuse, "La fonction possède plus d'une annotation « @Python »")
        }
    }

    message := chaine_depuis_enchaineuse(*enchaineuse)
    diffère déloge(message)
    compilatrice_rapporte_erreur(ctx.fonction, message)
}

/* Discrimination des annotations @Python pouvant se trouver sur des fonctions. */

AnnotationPython :: énum {
    NON_TROUVÉE
    INVALIDE
    TROUVÉE_SANS_PARAMÈTRE
    MULTIPLES_ANNOTATIONS
    POUR_STR
    POUR_REPR
    /* La sémantique entre __init__ et new diffère : new devrait être
     * pour les types qui n'ont que des membres immutables, alors que
     * __init__ devrait être que pour les types ayant des membres
     * mutables. */
    POUR_INIT
    POUR_NEW
}

/* Retourne la valeur de l'énumération correspondant à une chaine de
 * caractère, qui doit se trouver après l'annotation @Python. */
annotation_python_pour_chaine :: fonc (chn: chaine) -> AnnotationPython
{
    si chn == "str" {
        retourne AnnotationPython.POUR_STR
    }

    si chn == "repr" {
        retourne AnnotationPython.POUR_REPR
    }

    si chn == "init" {
        retourne AnnotationPython.POUR_INIT
    }

    si chn == "new" {
        retourne AnnotationPython.POUR_NEW
    }

    si chn == "" {
        retourne AnnotationPython.TROUVÉE_SANS_PARAMÈTRE
    }

    retourne AnnotationPython.INVALIDE
}

/* Retourne la valeur de l'énumération correspondant à l'annotation, ou
 * le manque d'annotation, @Python de la fonction */
annotation_pour_python :: fonc (entête: *NoeudCodeEntêteFonction) -> AnnotationPython
{
    annotation_trouvée := AnnotationPython.NON_TROUVÉE

    pour entête.annotations {
        si it.nom != "Python" {
            continue
        }

        si annotation_trouvée != AnnotationPython.NON_TROUVÉE {
            retourne AnnotationPython.MULTIPLES_ANNOTATIONS
        }

        annotation_trouvée = annotation_python_pour_chaine(it.valeur)

        si annotation_trouvée == AnnotationPython.INVALIDE {
            arrête
        }
    }

    retourne annotation_trouvée
}

// ---------------------------------------------------

/* À FAIRE : les structures contenant des pointeurs ne pourront stocker la valeur extraite...
 */
SystèmeType :: struct {
    types: []*TypePython
}

ajoute_type :: fonc (système: &SystèmeType, info: *InfoType, drapeaux: DrapeauxType)
{
    type := convertis_vers_type_python(système, info)
    type.drapeaux |= drapeaux
}

crée_type_python_pour :: fonc (système: &SystèmeType, info: *InfoType, nom: chaine) -> *TypePython
{
    type_python := loge(TypePython)
    type_python.nom = nom
    type_python.type_kuri = info
    tableau_ajoute(*système.types, type_python)
    retourne type_python
}

trouve_type :: fonc (système: &SystèmeType, info: *InfoType) -> *TypePython
{
    pour système.types {
        si it.type_kuri == info {
            retourne it
        }
    }

    retourne nul
}

convertis_vers_type_python :: fonc (système: &SystèmeType, info: *InfoType) -> *TypePython
{
    type_python := système.trouve_type(info)
    si type_python {
        retourne type_python
    }

    discr info.id {
        ENTIER {
            type_python = système.crée_type_python_pour(info, "z32")
            type_python.est_basique = vrai
            init_fonctions_type_entier(type_python.fonctions)
        }
        RÉEL {
            type_python = système.crée_type_python_pour(info, "r64")
            type_python.est_basique = vrai
            init_fonctions_type_réel(type_python.fonctions)
        }
        BOOLÉEN {
            /* Pour le formattage, et l'extraction, les booléens sont des nombres entiers. */
            type_python = système.crée_type_python_pour(info, "z32")
            type_python.est_basique = vrai
            init_fonctions_type_bool(type_python.fonctions)
        }
        OCTET {
            type_python = système.crée_type_python_pour(info, "z32")
            type_python.est_basique = vrai
            init_fonctions_type_entier(type_python.fonctions)
        }
        CHAINE {
            type_python = système.crée_type_python_pour(info, "*z8")
            type_python.est_basique = vrai
            init_fonctions_type_chaine(type_python.fonctions)
        }
        STRUCTURE {
            info_struct := info comme *InfoTypeStructure
            type_python = système.crée_type_python_pour(info, info_struct.nom)
            init_fonctions_type_structure(type_python.fonctions, info_struct.nom)

            pour info_struct.membres {
                confidentialité := confidentialité_pour_annotation(it.annotations)

                si confidentialité == ConfidentialitéType.OPAQUE {
                    continue
                }

                membre : MembreType
                membre.nom = it.nom
                membre.confidentialité = confidentialité
                membre.type = système.convertis_vers_type_python(it.id)

                tableau_ajoute(*type_python.membres, membre)
            }
        }
        UNION {
            info_union := info comme *InfoTypeUnion
            type_python = système.crée_type_python_pour(info, info_union.nom)
            init_fonctions_type_structure(type_python.fonctions, info_union.nom)
            type_python.drapeaux.TYPE_EST_UNION = vrai

            pour info_union.membres {
                confidentialité := confidentialité_pour_annotation(it.annotations)

                si confidentialité == ConfidentialitéType.OPAQUE {
                    continue
                }

                membre : MembreType
                membre.nom = it.nom
                membre.confidentialité = confidentialité
                membre.type = système.convertis_vers_type_python(it.id)

                tableau_ajoute(*type_python.membres, membre)
            }
        }
        POINTEUR {
            info_pointeur := info comme *InfoTypePointeur
            type_python = convertis_vers_type_python(système, info_pointeur.type_pointé)
        }
        FONCTION {
            // non supporté pour le moment
        }
        OPAQUE {
            // non supporté pour le moment
        }
        TABLEAU {
            // non supporté pour le moment
        }
        RIEN {
            // non supporté pour le moment
        }
        TYPE_DE_DONNÉES {
            // non supporté pour le moment
        }
        ÉNUM {
            // non supporté pour le moment
        }
        EINI {
            // non supporté pour le moment
        }
    }

    retourne type_python
}

// ---------------------------------------------------

/* Compilatrice, et logique de compilation (validation, parsage) des fonctions et types Kuri vers Python. */

CompilatriceModulePython :: struct {
    module: ModulePython

    système_type: SystèmeType

    /* Les modules kuri qu'il faudra importer dans le code généré.
     * À FAIRE : les infos-types n'ont pas d'information pour les modules.
     */
    modules_kuri_à_importer: []chaine
}

crée_compilatrice_pour_un_module :: fonc (nom_module: chaine) -> CompilatriceModulePython
{
    compilatrice: CompilatriceModulePython
    compilatrice.module.nom = nom_module
    retourne compilatrice
}

/* Ajout d'un module à la liste des modules Kuri à importer dans le code généré. */
ajoute_module_kuri :: fonc (compilatrice: &CompilatriceModulePython, nom_module: chaine)
{
    saufsi nom_module {
        /* Il est possible d'avoir une fonction ou un type du module par
         * défaut de compilation, qui n'a pas de nom. Le code généré sera
         * ajouté au module défaut, donc il n'y aura pas d'erreurs de
         * compilation si ce module n'est pas importé. */
        retourne
    }

    pour compilatrice.modules_kuri_à_importer {
        si it == nom_module {
            retourne
        }
    }

    tableau_ajoute(*compilatrice.modules_kuri_à_importer, nom_module)
}

ajoute_type :: fonc (compilatrice: &CompilatriceModulePython, type_kuri: *InfoType, drapeaux: DrapeauxType = DrapeauxType.zéro)
{
    compilatrice.système_type.ajoute_type(type_kuri, drapeaux)
}

ajoute_fonction_si_annotée :: fonc (compilatrice: &CompilatriceModulePython, fonction: *NoeudCodeEntêteFonction)
{
    annotation_python := annotation_pour_python(fonction)

    discr annotation_python {
        NON_TROUVÉE {
            retourne
        }
        MULTIPLES_ANNOTATIONS {
            rapporte_erreur(CodeErreurCompilationPython.TROP_D_ANNOTATIONS, ContexteErreurPython(fonction))
        }
        INVALIDE {
            rapporte_erreur(CodeErreurCompilationPython.ANNOTATION_INVALIDE, ContexteErreurPython(fonction))
        }
        TROUVÉE_SANS_PARAMÈTRE {
            ajoute_fonction_sans_annotation(compilatrice, fonction)
        }
        POUR_INIT {
            ajoute_fonction_type(compilatrice, CodeErreurCompilationPython.FONCTION_INIT_REQUIERS_STRUCTURE, fonction)
        }
        POUR_NEW {
            ajoute_fonction_type(compilatrice, CodeErreurCompilationPython.FONCTION_NEW_REQUIERS_STRUCTURE, fonction)
        }
        POUR_REPR {
            ajoute_fonction_type(compilatrice, CodeErreurCompilationPython.FONCTION_REPR_REQUIERS_STRUCTURE, fonction)
        }
        POUR_STR {
            ajoute_fonction_type(compilatrice, CodeErreurCompilationPython.FONCTION_STR_REQUIERS_STRUCTURE, fonction)
        }
    }
}

ajoute_fonction_sans_annotation :: fonc (compilatrice: &CompilatriceModulePython, fonction: *NoeudCodeEntêteFonction)
{
    ajoute_module_kuri(compilatrice, compilatrice_module_pour_code(fonction))
    compilatrice.module.ajoute_fonction(compilatrice.système_type, fonction)
}

/* Ajoute une fonction clé pour un type (__init__, __repr__, etc.).
 * NOTE: le CodeErreurCompilationPython est simplement pour discriminer
 * la fonction, mais aussi pour rapporter une erreur. */
ajoute_fonction_type :: fonc (compilatrice: &CompilatriceModulePython, code_erreur: CodeErreurCompilationPython, fonction: *NoeudCodeEntêteFonction)
{
    type_paramètre := type_premier_paramètre(fonction)
    type_structure := est_pointeur_de_structure_ou_union(type_paramètre)

    si type_structure == nul {
        rapporte_erreur(code_erreur, ContexteErreurPython(fonction))
        retourne
    }

    type_python := compilatrice.système_type.trouve_type(type_structure)
    saufsi type_python {
        rapporte_erreur(CodeErreurCompilationPython.TYPE_INCONNU_DE_PYTHON, ContexteErreurPython(fonction, type_structure))
        retourne
    }

    si code_erreur == CodeErreurCompilationPython.FONCTION_INIT_REQUIERS_STRUCTURE {
        saufsi fonction_ne_retourne_que(fonction, info_de(bool)) {
            rapporte_erreur(CodeErreurCompilationPython.TYPE_RETOUR_INIT, ContexteErreurPython(fonction))
            retourne
        }

        type_python.ajoute_méthode_init(compilatrice.système_type, fonction)
    }
    sinon si code_erreur == CodeErreurCompilationPython.FONCTION_NEW_REQUIERS_STRUCTURE {
        saufsi fonction_ne_retourne_que(fonction, info_de(bool)) {
            rapporte_erreur(CodeErreurCompilationPython.TYPE_RETOUR_NEW, ContexteErreurPython(fonction))
            retourne
        }

        type_python.ajoute_méthode_new(compilatrice.système_type, fonction)
    }
    sinon si code_erreur == CodeErreurCompilationPython.FONCTION_REPR_REQUIERS_STRUCTURE {
        saufsi fonction_n_a_qu_un_seul_paramètre(fonction) {
            rapporte_erreur(CodeErreurCompilationPython.TYPE_ENTRÉE_REPR, ContexteErreurPython(fonction))
            retourne
        }

        saufsi fonction_ne_retourne_que(fonction, info_de(chaine)) {
            rapporte_erreur(CodeErreurCompilationPython.TYPE_RETOUR_REPR, ContexteErreurPython(fonction))
            retourne
        }

        type_python.ajoute_méthode_repr(compilatrice.système_type, fonction)
    }
    sinon si code_erreur == CodeErreurCompilationPython.FONCTION_STR_REQUIERS_STRUCTURE {
        saufsi fonction_n_a_qu_un_seul_paramètre(fonction) {
            rapporte_erreur(CodeErreurCompilationPython.TYPE_ENTRÉE_STR, ContexteErreurPython(fonction))
            retourne
        }

        saufsi fonction_ne_retourne_que(fonction, info_de(chaine)) {
            rapporte_erreur(CodeErreurCompilationPython.TYPE_RETOUR_STR, ContexteErreurPython(fonction))
            retourne
        }

        type_python.ajoute_méthode_str(compilatrice.système_type, fonction)
    }

    ajoute_module_kuri(compilatrice, compilatrice_module_pour_code(fonction))
}

génère_interface_python :: fonc (compilatrice: &CompilatriceModulePython) -> chaine
{
    enchaineuse : Enchaineuse
    initialise_enchaineuse(*enchaineuse)
    diffère détruit_tampons(*enchaineuse)

    ajoute_au_tampon(*enchaineuse, "importe GlibC\n") // Pour ChaineC
    ajoute_au_tampon(*enchaineuse, "importe Fondation\n")
    ajoute_au_tampon(*enchaineuse, "importe Python\n")

    pour compilatrice.modules_kuri_à_importer {
        ajoute_au_tampon(*enchaineuse, "importe ", it, "\n")
    }

    module := compilatrice.module

    pour compilatrice.système_type.types {
        si it.est_basique {
            continue
        }

        génère_déclaration_type_python(*enchaineuse, module, it)
    }

    pour module.méthodes {
        génère_interface_fonction(*enchaineuse, it)
    }

    génère_initialisation_module(*enchaineuse, module, compilatrice.système_type.types)
    retourne chaine_depuis_enchaineuse(*enchaineuse)
}

génère_code :: fonc (compilatrice: &CompilatriceModulePython, espace: *EspaceDeTravail)
{
    source := compilatrice.génère_interface_python()
    diffère déloge(source)
    ajoute_chaine_à_la_compilation(espace, source)
}
