// Interface pour la bibliothèque du langage Python permettant de définir des modules.

importe Chaine
importe Fondation
importe Math

libpython :: #bibliothèque "python3.10"

Py_ssize_t :: z64
Py_hash_t :: Py_ssize_t

// #if PYLONG_BITS_IN_DIGIT == 30
digit :: n32

PyAsyncMethods :: struct #externe
PyNumberMethods :: struct #externe

/* https://docs.python.org/3/c-api/typeobj.html#mapping-structs */
PyMappingMethods :: struct #externe {
    mp_length: fonc(*PyObject)(Py_ssize_t)
    mp_subscript: fonc(*PyObject, *PyObject)(*PyObject)
    mp_ass_subscript: fonc(*PyObject, *PyObject, *PyObject)(z32)
}

PyMemberDef :: struct #externe

PyGetSetDef :: struct #externe {
    name: ChaineC
    get: fonc(*PyObject, *rien)(*PyObject)
    set: fonc(*PyObject, *PyObject, *rien)(z32)
    doc: ChaineC
    closure: *rien
}

_typeobject :: PyTypeObject

PyTypeObject :: struct #externe {
    empl base_var_object: PyVarObject

    tp_name: ChaineC /* For printing, in format "<module>.<name>" */

    /* For allocation */
    tp_basicsize: Py_ssize_t
    tp_itemsize: Py_ssize_t

    /* Methods to implement standard operations */

    tp_dealloc: *rien // À FAIRE: pointeur de fonction
    tp_vectorcall_offset: Py_ssize_t
    tp_getattr: *rien // À FAIRE: pointeur de fonction
    tp_setattr: *rien // À FAIRE: pointeur de fonction

    tp_as_async: *PyAsyncMethods /* formerly known as tp_compare (Python 2)
                                    or tp_reserved (Python 3) */
    tp_repr: fonc(*PyObject)(*PyObject)

    /* Method suites for standard classes */

    tp_as_number: *PyNumberMethods
    tp_as_sequence: *PySequenceMethods
    tp_as_mapping: *PyMappingMethods

    /* More standard operations (here for binary compatibility) */

    tp_hash: fonc(*PyObject)(Py_hash_t)
    tp_call: *rien // À FAIRE: pointeur de fonction ternaryfunc
    tp_str: fonc(*PyObject)(*PyObject)
    tp_getattro: *rien // À FAIRE: pointeur de fonction getattrofunc
    tp_setattro: *rien // À FAIRE: pointeur de fonction setattrofunc

    /* Functions to access object as input/output buffer */
    tp_as_buffer: *PyBufferProcs

    /* Flags to define presence of optional/expanded features */
    tp_flags: n64

    tp_doc: ChaineC /* Documentation string */

    /* Assigned meaning in release 2.0 */
    /* call function for all accessible objects */
    tp_traverse: *rien // À FAIRE: pointeur de fonction traverseproc

    /* delete references to contained objects */
    tp_clear: *rien // À FAIRE: pointeur de fonction inquiry

    /* Assigned meaning in release 2.1 */
    /* rich comparisons */
    tp_richcompare: fonc(*PyObject,*PyObject,z32)(*PyObject)

    /* weak reference enabler */
    tp_weaklistoffset: Py_ssize_t

    /* Iterators */
    tp_iter: fonc(*PyObject)(*PyObject)
    tp_iternext: fonc(*PyObject)(*PyObject)

    /* Attribute descriptor and subclassing stuff */
    tp_methods: *PyMethodDef
    tp_members: *PyMemberDef
    tp_getset: *PyGetSetDef
    tp_base: *_typeobject
    tp_dict: *PyObject
    tp_descr_get: *rien // À FAIRE: pointeur de descrgetfunc
    tp_descr_set: *rien // À FAIRE: pointeur de descrsetfunc
    tp_dictoffset: Py_ssize_t
    tp_init: *rien // À FAIRE: pointeur de fonctioninitproc
    tp_alloc: fonc (*PyTypeObject, Py_ssize_t)(*PyObject)
    tp_new: fonc (*PyTypeObject, *PyObject, *PyObject)(*PyObject) // PyObject *tp_new(PyTypeObject *subtype, PyObject *args, PyObject *kwds);
    tp_free: *rien // À FAIRE: pointeur de fonctionfreefunc /* Low-level free-memory routine */
    tp_is_gc: *rien // À FAIRE: pointeur de fonctioninquiry /* For PyObject_IS_GC */
    tp_bases: *PyGetSetDef
    tp_mro: *PyGetSetDef /* method resolution order */
    tp_cache: *PyGetSetDef
    tp_subclasses: *PyGetSetDef
    tp_weaklist: *PyGetSetDef
    tp_del: *rien // À FAIRE: pointeur de fonctiondestructor

    /* Type attribute cache version tag. Added in version 2.6 */
    tp_version_tag: n32

    tp_finalize: *rien // À FAIRE: pointeur de fonctiondestructor
    tp_vectorcall: *rien // À FAIRE: pointeur de fonctionvectorcallfunc
}

/*
Type flags (tp_flags)

These flags are used to change expected features and behavior for a
particular type.

Arbitration of the flag bit positions will need to be coordinated among
all extension writers who publicly release their extensions (this will
be fewer than you might expect!).

Most flags were removed as of Python 3.0 to make room for new flags.  (Some
flags are not for backwards compatibility but to indicate the presence of an
optional feature; these flags remain of course.)

Type definitions should use Py_TPFLAGS_DEFAULT for their tp_flags value.

Code can use PyType_HasFeature(type_ob, flag_value) to test whether the
given type object has a specified feature.
*/

/* Set if the type object is dynamically allocated */
Py_TPFLAGS_HEAPTYPE : n64 : 1 << 9

/* Set if the type allows subclassing */
Py_TPFLAGS_BASETYPE : n64 : 1 << 10

/* Set if the type implements the vectorcall protocol (PEP 590) */
// #ifndef Py_LIMITED_API
Py_TPFLAGS_HAVE_VECTORCALL : n64 : 1 << 11

/* Set if the type is 'ready' -- fully initialized */
Py_TPFLAGS_READY : n64 : 1 << 12

/* Set while the type is being 'readied', to prevent recursive ready calls */
Py_TPFLAGS_READYING : n64 : 1 << 13

/* Objects support garbage collection (see objimpl.h) */
Py_TPFLAGS_HAVE_GC : n64 : 1 << 14

/* These two bits are preserved for Stackless Python, next after this is 17 */
// #ifdef STACKLESS
// Py_TPFLAGS_HAVE_STACKLESS_EXTENSION : n64 : 3 << 15
Py_TPFLAGS_HAVE_STACKLESS_EXTENSION : n64 : 0

/* Objects behave like an unbound method */
Py_TPFLAGS_METHOD_DESCRIPTOR : n64 : 1  << 17

/* Objects support type attribute cache */
Py_TPFLAGS_HAVE_VERSION_TAG : n64 : 1  << 18
Py_TPFLAGS_VALID_VERSION_TAG : n64 : 1  << 19

/* Type is abstract and cannot be instantiated */
Py_TPFLAGS_IS_ABSTRACT : n64 : 1  << 20

/* These flags are used to determine if a type is a subclass. */
Py_TPFLAGS_LONG_SUBCLASS : n64 : 1  << 24
Py_TPFLAGS_LIST_SUBCLASS : n64 : 1  << 25
Py_TPFLAGS_TUPLE_SUBCLASS : n64 : 1  << 26
Py_TPFLAGS_BYTES_SUBCLASS : n64 : 1  << 27
Py_TPFLAGS_UNICODE_SUBCLASS : n64 : 1  << 28
Py_TPFLAGS_DICT_SUBCLASS : n64 : 1  << 29
Py_TPFLAGS_BASE_EXC_SUBCLASS : n64 : 1  << 30
Py_TPFLAGS_TYPE_SUBCLASS : n64 : 1  << 31

Py_TPFLAGS_DEFAULT :: Py_TPFLAGS_HAVE_STACKLESS_EXTENSION | Py_TPFLAGS_HAVE_VERSION_TAG

/* NOTE: The following flags reuse lower bits (removed as part of the
 * Python 3.0 transition). */

/* The following flag is kept for compatibility. Starting with 3.8,
 * binary compatibility of C extensions across feature releases of
 * Python is not supported anymore, except when using the stable ABI.
 */

/* Type structure has tp_finalize member (3.4) */
Py_TPFLAGS_HAVE_FINALIZE : n64 : 1 << 0

/* Déclaration du "object" dont les classes Python hérite par défaut. */
PyBaseObject_Type: PyTypeObject #externe libpython

PyType_Ready :: fonc (type: *PyTypeObject) -> z32 #externe libpython

PyObject :: struct #externe {
    ob_refcnt: z64
    ob_type: *PyTypeObject
}

PyVarObject :: struct {
    empl base_object: PyObject
    ob_size: Py_ssize_t /* Number of items in variable part */
}

PyMethodDef :: struct {
    ml_name : ChaineC
    ml_meth : fonc(*PyObject, *PyObject)(*PyObject)
    ml_flag: z32
    ml_doc : ChaineC
}

PyModuleDef_Base :: struct {
  ob_base: PyObject
  m_init: fonc (rien)(*PyObject)
  m_index: z64
  m_copy: *PyObject
}

PyModuleDef_Slot :: struct #externe

PyModuleDef :: struct {
    m_base: PyModuleDef_Base
    m_name: ChaineC
    m_doc: ChaineC
    m_size: z64
    m_methods: *PyMethodDef
    m_slots: *PyModuleDef_Slot
    m_traverse: fonc(*PyObject, *rien, *rien)(z32) // le premier *rien est une fonction "visitproc"
    m_clear: fonc(*PyObject)(z32)
    m_free: fonc(*rien)(rien)
}

/* Flag passed to newmethodobject */
/* METH_OLDARGS  0x0000   -- unsupported now */
METH_VARARGS  :: 0x0001
METH_KEYWORDS :: 0x0002
/* METH_NOARGS and METH_O must not be combined with the flags above. */
METH_NOARGS   :: 0x0004
METH_O        :: 0x0008

/* METH_CLASS and METH_STATIC are a little different; these control
   the construction of methods for a class.  These cannot be used for
   functions in modules. */
METH_CLASS    :: 0x0010
// #ifndef Py_LIMITED_API
METH_STATIC   :: 0x0020

/* METH_COEXIST allows a method to be entered even though a slot has
   already filled the entry.  When defined, the flag allows a separate
   method, "__contains__" for example, to coexist with a defined
   slot like sq_contains. */

METH_COEXIST   :: 0x0040
METH_FASTCALL  :: 0x0080

/* This bit is preserved for Stackless Python */
// #ifdef PYTHON_STACKLESS
METH_STACKLESS :: 0x0100

/* METH_METHOD means the function stores an
 * additional reference to the class that defines it;
 * both self and class are passed to it.
 * It uses PyCMethodObject instead of PyCFunctionObject.
 * May not be combined with METH_NOARGS, METH_O, METH_CLASS or METH_STATIC.
 */

//#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000
METH_METHOD :: 0x0200

PYTHON_API_VERSION :: 1013

_Py_NoneStruct : PyObject #externe libpython
Py_None : *PyObject = *_Py_NoneStruct

python_retourne_rien :: fonc () -> *PyObject
{
    Py_INCREF(Py_None)
    retourne Py_None
}

PyBool_Type : PyTypeObject #externe libpython

_longobject :: struct {
    ob_base: PyVarObject
    ob_digit: [1]digit;
}

_Py_FalseStruct: PyObject #externe libpython // À FAIRE _longobject
Py_False : *PyObject = *_Py_FalseStruct

python_retourne_faux :: fonc () -> *PyObject
{
    Py_INCREF(Py_False)
    retourne Py_False
}

_Py_TrueStruct : PyObject #externe libpython // À FAIRE _longobject
Py_True : *PyObject = *_Py_TrueStruct

python_retourne_true :: fonc () -> *PyObject
{
    Py_INCREF(Py_True)
    retourne Py_True
}

PyArg_ParseTuple :: fonc (args: *PyObject, format: ChaineC,  r_ob: ...) -> z32 #externe libpython

_Py_NotImplementedStruct : PyObject #externe libpython
Py_NotImplemented : *PyObject = *_Py_NotImplementedStruct

// ---------------------------------------------------
// Références

_Py_Dealloc :: fonc (ob: *PyObject) #externe libpython

Py_INCREF :: fonc (ob: *PyObject)
{
    ob.ob_refcnt += 1
}

Py_XINCREF :: fonc (ob: *PyObject)
{
    si ob {
        Py_INCREF(ob)
    }
}

Py_DECREF :: fonc (ob: *PyObject)
{
    ob.ob_refcnt -= 1
    si ob.ob_refcnt == 0 {
        _Py_Dealloc(ob)
    }
}

Py_XDECREF :: fonc (ob: *PyObject)
{
    saufsi ob {
        retourne
    }

    Py_DECREF(ob)
}

Py_NewRef :: fonc (ob: *PyObject) -> *PyObject
{
    Py_INCREF(ob)
    retourne ob
}

Py_XNewRef :: fonc (ob: *PyObject) -> *PyObject
{
    Py_XINCREF(ob)
    retourne ob
}

// ---------------------------------------------------
/* Rich comparison opcodes */
Py_LT :: 0
Py_LE :: 1
Py_EQ :: 2
Py_NE :: 3
Py_GT :: 4
Py_GE :: 5

// ---------------------------------------------------
// Module

PyModule_Create2 :: fonc (module_def: *PyModuleDef, apiver: z32) -> *PyObject #externe libpython

PyModule_AddObject :: fonc (module: *PyObject, name: ChaineC, value: *PyObject) #externe libpython
PyModule_AddIntConstant :: fonc (module: *PyObject, name: ChaineC, value: z64) -> z32 #externe libpython
PyModule_AddStringConstant :: fonc (module: *PyObject, name: ChaineC, value: ChaineC) -> z32 #externe libpython

// ---------------------------------------------------
// Objet

PyType_IsSubtype :: fonc (type1: *PyTypeObject, type2: *PyTypeObject) -> z32 #externe libpython

PyType_HasFeature :: fonc (type: *PyTypeObject, feature: n64) -> bool #enligne
{
    flags := type.tp_flags
    retourne (flags & feature) != 0
}

PyType_FastSubclass :: fonc (type: *PyTypeObject, feature: n64) -> bool #enligne
{
    retourne PyType_HasFeature(type, feature)
}

_Py_IS_TYPE :: fonc (ob: *PyObject, type: *PyTypeObject) -> bool
{
    retourne ob.ob_type == type
}

PyObject_TypeCheck :: fonc (ob: *PyObject, type: *PyTypeObject) -> bool
{
    retourne _Py_IS_TYPE(ob, type) || (PyType_IsSubtype(ob.ob_type, type) != 0)
}

PyObject_HashNotImplemented :: fonc (o: *PyObject) -> Py_hash_t #externe libpython

// ---------------------------------------------------
// Objet Bool

PyBool_Check :: fonc (ob: *PyObject) -> bool
{
    retourne PyObject_TypeCheck(ob, *PyBool_Type)
}

PyBool_AsBool :: fonc (ob: *PyObject) -> bool
{
    retourne ob == Py_True
}

PyBool_FromBool :: fonc (valeur: bool) -> *PyObject
{
    si valeur {
        retourne python_retourne_true()
    }
    retourne python_retourne_faux()
}

// ---------------------------------------------------
// Objet Entier/Long

PyLong_Check :: fonc (ob: *PyObject) -> bool
{
    retourne PyType_FastSubclass(ob.ob_type, Py_TPFLAGS_LONG_SUBCLASS)
}

PyLong_FromLong :: fonc (l: z64) -> *PyObject #externe libpython
PyLong_AsLong :: fonc (ob: *PyObject) -> z64 #externe libpython

PyLong_AsZ8 :: fonc (ob: *PyObject) -> z8
{
    retourne PyLong_AsLong(ob) comme z8
}

PyLong_AsZ16 :: fonc (ob: *PyObject) -> z16
{
    retourne PyLong_AsLong(ob) comme z16
}

PyLong_AsZ32 :: fonc (ob: *PyObject) -> z32
{
    retourne PyLong_AsLong(ob) comme z32
}

PyLong_AsN8 :: fonc (ob: *PyObject) -> n8
{
    retourne PyLong_AsLong(ob) comme n8
}

PyLong_AsN16 :: fonc (ob: *PyObject) -> n16
{
    retourne PyLong_AsLong(ob) comme n16
}

PyLong_AsN32 :: fonc (ob: *PyObject) -> n32
{
    retourne PyLong_AsLong(ob) comme n32
}

PyLong_AsN64 :: fonc (ob: *PyObject) -> n64
{
    retourne PyLong_AsLong(ob) comme n64
}

PyLong_FromN8 :: fonc (l: n8) -> *PyObject
{
    retourne PyLong_FromLong(l comme z64)
}

PyLong_FromN16 :: fonc (l: n16) -> *PyObject
{
    retourne PyLong_FromLong(l comme z64)
}

PyLong_FromN32 :: fonc (l: n32) -> *PyObject
{
    retourne PyLong_FromLong(l comme z64)
}

PyLong_FromN64 :: fonc (l: n64) -> *PyObject
{
    retourne PyLong_FromLong(l comme z64)
}

// ---------------------------------------------------
// Objet Réel/Double

PyFloat_Type : PyTypeObject #externe libpython

PyFloat_Check :: fonc (ob: *PyObject) -> bool
{
    retourne PyObject_TypeCheck(ob, *PyFloat_Type)
}

PyFloat_FromDouble :: fonc (l: r64) -> *PyObject #externe libpython
PyFloat_AsDouble :: fonc (ob: *PyObject) -> r64 #externe libpython

PyFloat_AsR32 :: fonc (ob: *PyObject) -> r32
{
    retourne PyFloat_AsDouble(ob) comme r32
}

PyFloat_AsR16 :: fonc (ob: *PyObject) -> r16
{
    retourne PyFloat_AsDouble(ob) comme r16
}

// ---------------------------------------------------
// Objet Unicode

PyUnicode_Type : PyTypeObject #externe libpython

PyUnicode_Check :: fonc (ob: *PyObject) -> bool
{
    retourne PyType_FastSubclass(ob.ob_type, Py_TPFLAGS_UNICODE_SUBCLASS)
}

PyUnicode_CheckExact :: fonc (ob: *PyObject) -> bool
{
    retourne PyObject_TypeCheck(ob, *PyUnicode_Type)
}

PyUnicode_FromStringAndSize :: fonc (str: *z8, taille: Py_ssize_t) -> *PyObject #externe libpython
PyUnicode_AsUTF8AndSize :: fonc (unicode: *PyObject, size: *Py_ssize_t) -> *z8 #externe libpython

PyUnicode_AsChaine :: fonc (unicode: *PyObject) -> chaine
{
    résultat : chaine = ---
    résultat.pointeur = PyUnicode_AsUTF8AndSize(unicode, *résultat.taille)
    retourne résultat
}

PyUnicode_FromChaine :: fonc (chn: chaine) -> *PyObject
{
    retourne PyUnicode_FromStringAndSize(chn.pointeur, chn.taille)
}

// ---------------------------------------------------
// Sequence Protocol

lenfunc :: fonc (*PyObject)(Py_ssize_t)
binaryfunc :: fonc (*PyObject, *PyObject)(*PyObject)
ssizeargfunc :: fonc (*PyObject, Py_ssize_t)(*PyObject)
ssizeobjargproc :: fonc (*PyObject, Py_ssize_t)(z32)
objobjproc :: fonc (*PyObject, *PyObject)(z32)

PySequenceMethods :: struct {
    sq_length: lenfunc
    sq_concat: binaryfunc
    sq_repeat: ssizeargfunc
    sq_item: ssizeargfunc
    was_sq_slice: *rien
    sq_ass_item: ssizeobjargproc
    was_sq_ass_slice: *rien
    sq_contains: objobjproc

    sq_inplace_concat: binaryfunc
    sq_inplace_repeat: ssizeargfunc
}

// ---------------------------------------------------
// Buffer Interface

Py_buffer :: struct {
    buf: *rien
    obj: *PyObject        /* owned reference */
    len: Py_ssize_t
    itemsize: Py_ssize_t  /* This is Py_ssize_t so it can be
                             pointed to by strides in simple case.*/
    readonly: z32
    ndim: z32
    format: *z8
    shape: *Py_ssize_t
    strides: *Py_ssize_t
    suboffsets: *Py_ssize_t
    internal: *rien
}

getbufferproc :: fonc (*PyObject, *Py_buffer, z32)(z32)
releasebufferproc :: fonc (*PyObject, *Py_buffer)(rien)

PyBufferProcs :: struct {
    bf_getbuffer: getbufferproc
    bf_releasebuffer: releasebufferproc
}

vectorcallfunc :: fonc (/* callable */*PyObject, /* args */ **PyObject, /* nargsf */ n64, /* kwnames */ *PyObject)(*PyObject)

/* Maximum number of dimensions */
PyBUF_MAX_NDIM :: 64

/* Flags for getting buffers */
PyBUF_SIMPLE :: 0
PyBUF_WRITABLE :: 0x0001
/*  we used to include an E, backwards compatible alias  */
PyBUF_WRITEABLE :: PyBUF_WRITABLE
PyBUF_FORMAT :: 0x0004
PyBUF_ND :: 0x0008
PyBUF_STRIDES :: (0x0010 | PyBUF_ND)
PyBUF_C_CONTIGUOUS :: (0x0020 | PyBUF_STRIDES)
PyBUF_F_CONTIGUOUS :: (0x0040 | PyBUF_STRIDES)
PyBUF_ANY_CONTIGUOUS :: (0x0080 | PyBUF_STRIDES)
PyBUF_INDIRECT :: (0x0100 | PyBUF_STRIDES)

PyBUF_CONTIG :: (PyBUF_ND | PyBUF_WRITABLE)
PyBUF_CONTIG_RO :: (PyBUF_ND)

PyBUF_STRIDED :: (PyBUF_STRIDES | PyBUF_WRITABLE)
PyBUF_STRIDED_RO :: (PyBUF_STRIDES)

PyBUF_RECORDS :: (PyBUF_STRIDES | PyBUF_WRITABLE | PyBUF_FORMAT)
PyBUF_RECORDS_RO :: (PyBUF_STRIDES | PyBUF_FORMAT)

PyBUF_FULL :: (PyBUF_INDIRECT | PyBUF_WRITABLE | PyBUF_FORMAT)
PyBUF_FULL_RO :: (PyBUF_INDIRECT | PyBUF_FORMAT)

PyBUF_READ  :: 0x100
PyBUF_WRITE :: 0x200

// ---------------------------------------------------
// Fonctions pour générer les itérateurs pour infos types.
// Ces itérateurs retournent les noms des membres accessibles
// via Python.

/* Objet Python pour un itérateur sur InfoType */
PyItérateurInfoType :: struct {
    empl base: PyObject
    infos: *InfoTypeStructure
    index_courant: z64
}

/* Type objet Python pour un itérateur sur InfoType. */
PyTypeItérateurPourInfoType := PyTypeObject(
    ob_refcnt = 1,
    ob_size = 0,
    tp_basicsize = taille_de(PyItérateurInfoType) comme Py_ssize_t,
    tp_name = crée_chaine_c("kuri.ItérateurPourInfoType"),
    tp_flags = Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_VERSION_TAG,
    tp_iter = iter_pour_type_itérateur,
    tp_iternext = iternext_pour_itérateur_infos_type,
    tp_base = *PyBaseObject_Type,
    tp_hash = PyObject_HashNotImplemented
)

/* Retourne vrai si le membre est accessible via Python, et donc dont le nom
 * peut être retourné via l'itérateur. */
membre_est_accessible_via_itération :: fonc (membre: *InfoTypeMembreStructure) -> bool
{
    si possède_annotation(membre, "accessible") {
        retourne vrai
    }

    si possède_annotation(membre, "mutable") {
        retourne vrai
    }

    retourne faux
}

/* Les itérateurs peuvent définir un PyTypeObject.tp_iter, et dans ce cas doivent
 * retourner l'instance de l'itérateur.
 * Cette fonction est utilisée pour initialise PyTypeObject.tp_iter pour tous les
 * les types itérateurs, pas seulement PyTypeItérateurPourInfoType.
 * Cette fonction correspond à PyTypeObject.tp_iter.
 * https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_iter */
iter_pour_type_itérateur :: fonc (self: *PyObject) -> *PyObject
{
    retourne self
}

/* Retourne le nom du prochain membre de la structure, ou nul si l'itérateur est
 * exhausté.
 * Cette fonction correspond à PyTypeObject.tp_iternext.
 * https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_iternext */
iternext_pour_itérateur_infos_type :: fonc (self: *PyObject) -> *PyObject
{
    py_self := self comme *PyItérateurInfoType

    index_courant := py_self.index_courant
    infos := py_self.infos

    pour index_courant ... infos.membres.taille - 1 {
        info_membre := infos.membres[it]
        saufsi membre_est_accessible_via_itération(info_membre) {
            continue
        }
        py_self.index_courant = it + 1
        retourne PyUnicode_FromChaine(info_membre.nom)
    }

    retourne nul
}

/* Retourne un PyItérateurInfoType pour les infos données. */
itérateur_pour_infos_type :: fonc (infos: *InfoTypeStructure) -> *PyObject
{
    type_itérateur := *PyTypeItérateurPourInfoType
    py_itérateur_ := type_itérateur.tp_alloc(type_itérateur, 1)
    py_itérateur := py_itérateur_ comme *PyItérateurInfoType
    py_itérateur.infos = infos
    py_itérateur.index_courant = 0
    retourne py_itérateur comme *PyObject
}

// ---------------------------------------------------
// Fonctions pour générer les interfaces de tampons

/* Structure de base pour les objets supportant le protocol de tampon. */
BasePyBuffer :: struct {
    empl base: PyObject

    /* Nombre de fois que le tampon fut exporté. */
    exports: z32

    remplis_champs_requis_py_buffer: fonc (*BasePyBuffer, *Py_buffer)(rien)
}

/* Détermine la chaine de formattage pour un type de données, selon
 * https://docs.python.org/3/library/struct.html#struct-format-strings
 * Les chaines retournées doivent être nul-terminées.
 */
format_tampon_pour_info_type :: fonc (info: *InfoType) -> chaine
{
    discr info.id {
        ENTIER {
            info_entier := info comme *InfoTypeEntier
            si info_entier.est_signé {
                si info_entier.taille_en_octet == 1 {
                    retourne "b\0"
                }

                si info_entier.taille_en_octet == 2 {
                    retourne "h\0"
                }

                si info_entier.taille_en_octet == 4 {
                    retourne "i\0"
                }

                si info_entier.taille_en_octet == 8 {
                    retourne "l\0"
                }
            }
            sinon {
                si info_entier.taille_en_octet == 1 {
                    retourne "B\0"
                }

                si info_entier.taille_en_octet == 2 {
                    retourne "H\0"
                }

                si info_entier.taille_en_octet == 4 {
                    retourne "I\0"
                }

                si info_entier.taille_en_octet == 8 {
                    retourne "L\0"
                }
            }
        }
        RÉEL {
            si info.taille_en_octet == 2 {
                retourne "e\0"
            }

            si info.taille_en_octet == 4 {
                retourne "f\0"
            }

            si info.taille_en_octet == 8 {
                retourne "d\0"
            }
        }
        BOOLÉEN,
        OCTET {
            retourne "b\0"
        }
        TYPE_DE_DONNÉES {
            retourne "L\0"
        }
        UNION {
            // À FAIRE
        }
        STRUCTURE {
            info_struct := info comme *InfoTypeStructure

            si info_struct.membres.taille == 0 {
                retourne "b\0"
            }

            type_premier_membre := info_struct.membres[0].id
            pour info_struct.membres {
                si type_premier_membre != it.id {
                    arrête
                }
            }
            sansarrêt {
                /* Si tous les membres ont le même type (p.e. nous avons un vecteur),
                 * utilisons le format du type partagé par tous les membres. */
                retourne format_tampon_pour_info_type(type_premier_membre)
            }

            /* Sinon, retourne le formattage pour des octets. */
            retourne "b\0"
        }
        ÉNUM {
            info_énum := info comme *InfoTypeÉnum
            retourne format_tampon_pour_info_type(info_énum.type_sous_jacent)
        }
        OPAQUE {
            opaque := info comme *InfoTypeOpaque
            retourne format_tampon_pour_info_type(opaque.type_opacifié)
        }
        TABLEAU {
            tableau := info comme *InfoTypeTableau
            retourne format_tampon_pour_info_type(tableau.type_pointé)
        }
        TABLEAU_FIXE {
            tableau := info comme *InfoTypeTableauFixe
            retourne format_tampon_pour_info_type(tableau.type_pointé)
        }
        TRANCHE {
            tranche := info comme *InfoTypeTranche
            retourne format_tampon_pour_info_type(tranche.type_élément)
        }
        CHAINE,
        RIEN,
        EINI,
        VARIADIQUE {
            // À FAIRE
        }
        FONCTION,
        POINTEUR {
            retourne "P\0"
        }
    }

    /* Retourne des octets par défaut. */
    retourne "B\0"
}

remplis_champs_requis_py_buffer_générique :: fonc (view: *Py_buffer, tableau: [..]$T)
{
    view.buf = tableau.pointeur
    view.itemsize = taille_de(T) comme Py_ssize_t
    view.len = (tableau.taille comme n32 * taille_de(T)) comme Py_ssize_t
    view.format = format_tampon_pour_info_type(info_de(T)).pointeur

    // À FAIRE : tableau de tableau
    view.ndim = 1
    view.shape = loge(Py_ssize_t)
    mémoire(view.shape) = tableau.taille

    view.strides = loge(Py_ssize_t)
    mémoire(view.strides) = taille_de(T) comme Py_ssize_t

    view.suboffsets = loge(Py_ssize_t)
    mémoire(view.suboffsets) = 0
}

erreur_export_tampon :: fonc (view: *Py_buffer, message: chaine) -> z32
{
    view.obj = nul
    PyErr_SetObject(PyExc_BufferError, PyUnicode_FromChaine(message))
    retourne -1
}

possède_drapeau :: fonc (drapeaux: n64, valeur: n64) -> bool
{
    retourne (drapeaux & valeur) != 0
}

/* https://docs.python.org/3/c-api/typeobj.html#c.PyBufferProcs.bf_getbuffer */
impl_get_buffer_proc :: fonc (exporter: *PyObject, view: *Py_buffer, flags: z32) -> z32
{
    objet_tampon := exporter comme *BasePyBuffer

    /* 1. Check if the request can be met. If not, raise PyExc_BufferError, set view->obj to NULL and return -1. */
    view.readonly = 1
    si possède_drapeau(flags comme n64, PyBUF_WRITABLE comme n64) {
        retourne erreur_export_tampon(view, "Impossible d'exporter le tampon pour une écriture")
    }

    /* 2. Fill in the requested fields. */
    objet_tampon.remplis_champs_requis_py_buffer(objet_tampon, view)

    saufsi possède_drapeau(flags comme n64, PyBUF_FORMAT comme n64) {
        view.format = nul
    }

    /* 3. Increment an internal counter for the number of exports. */
    objet_tampon.exports += 1

    /* 4. Set view->obj to exporter and increment view->obj. */
    view.obj = exporter
    Py_INCREF(view.obj)

    /* 5. Return 0. */
    retourne 0
}

impl_release_buffer_proc :: fonc (exporter: *PyObject, view: *Py_buffer)
{
    objet_tampon := exporter comme *BasePyBuffer
    objet_tampon.exports -= 1

    si objet_tampon.exports == 0 {
        déloge(view.shape)
        déloge(view.strides)
        déloge(view.suboffsets)
    }
}

/* Globale pour les fonctions fonctions génériques de protocol de tampon. */
Py_BufferProtocol_Défaut : PyBufferProcs

protocol_tampon_défaut :: fonc () -> *PyBufferProcs
{
    Py_BufferProtocol_Défaut.bf_getbuffer = impl_get_buffer_proc
    Py_BufferProtocol_Défaut.bf_releasebuffer = impl_release_buffer_proc
    retourne *Py_BufferProtocol_Défaut
}

// ---------------------------------------------------
// Utilitaires

PyType_ChaineNom :: fonc (obj: *PyObject) -> chaine
{
    retourne convertis_chaine_c(obj.ob_type.tp_name)
}

PyUnicodeEnum_Check :: fonc (object: *PyObject, info: *InfoTypeÉnum) -> bool
{
    saufsi PyUnicode_Check(object) {
        retourne faux
    }

    chn := PyUnicode_AsChaine(object)

    pour info.noms {
        si it == chn {
            retourne vrai
        }
    }

    retourne faux
}

PyUnicodeEnum_Value :: fonc (object: *PyObject, info: *InfoTypeÉnum) -> z32
{
    chn := PyUnicode_AsChaine(object)
    valeur, trouvée := donne_valeur_énum_pour_nom(info, chn)
    si trouvée {
        retourne valeur
    }
    retourne 0
}

PyUnicodeEnum_Value_z8 :: fonc (object: *PyObject, info: *InfoTypeÉnum) -> z8
{
    retourne PyUnicodeEnum_Value(object, info) comme z8
}

PyUnicodeEnum_Value_z16 :: fonc (object: *PyObject, info: *InfoTypeÉnum) -> z16
{
    retourne PyUnicodeEnum_Value(object, info) comme z16
}

PyUnicodeEnum_Value_z32 :: fonc (object: *PyObject, info: *InfoTypeÉnum) -> z32
{
    retourne PyUnicodeEnum_Value(object, info)
}

PyUnicodeEnum_Value_z64 :: fonc (object: *PyObject, info: *InfoTypeÉnum) -> z64
{
    retourne PyUnicodeEnum_Value(object, info) comme z64
}

PyUnicodeEnum_Value_n8 :: fonc (object: *PyObject, info: *InfoTypeÉnum) -> n8
{
    retourne PyUnicodeEnum_Value(object, info) comme n8
}

PyUnicodeEnum_Value_n16 :: fonc (object: *PyObject, info: *InfoTypeÉnum) -> n16
{
    retourne PyUnicodeEnum_Value(object, info) comme n16
}

PyUnicodeEnum_Value_n32 :: fonc (object: *PyObject, info: *InfoTypeÉnum) -> n32
{
    retourne PyUnicodeEnum_Value(object, info) comme n32
}

PyUnicodeEnum_Value_n64 :: fonc (object: *PyObject, info: *InfoTypeÉnum) -> n64
{
    retourne PyUnicodeEnum_Value(object, info) comme n64
}

fonction_PyUnicodeEnum_Value_pour_info :: fonc (info_énum: *InfoTypeÉnum) -> chaine
{
    info := info_énum.type_sous_jacent

    si info == info_de(z8) {
        retourne "PyUnicodeEnum_Value_z8"
    }
    si info == info_de(z16) {
        retourne "PyUnicodeEnum_Value_z16"
    }
    si info == info_de(z32) {
        retourne "PyUnicodeEnum_Value_z32"
    }
    si info == info_de(z64) {
        retourne "PyUnicodeEnum_Value_z64"
    }
    si info == info_de(n8) {
        retourne "PyUnicodeEnum_Value_n8"
    }
    si info == info_de(n16) {
        retourne "PyUnicodeEnum_Value_n16"
    }
    si info == info_de(n32) {
        retourne "PyUnicodeEnum_Value_n32"
    }
    si info == info_de(n64) {
        retourne "PyUnicodeEnum_Value_n64"
    }
    retourne "PyUnicodeEnum_Value"
}

// ---------------------------------------------------
// Exceptions

PyExc_BaseException: *PyObject #externe libpython
PyExc_Exception: *PyObject #externe libpython
PyExc_ArithmeticError: *PyObject #externe libpython
PyExc_AssertionError: *PyObject #externe libpython
PyExc_AttributeError: *PyObject #externe libpython
PyExc_BlockingIOError: *PyObject #externe libpython
PyExc_BrokenPipeError: *PyObject #externe libpython
PyExc_BufferError: *PyObject #externe libpython
PyExc_ChildProcessError: *PyObject #externe libpython
PyExc_ConnectionAbortedError: *PyObject #externe libpython
PyExc_ConnectionError: *PyObject #externe libpython
PyExc_ConnectionRefusedError: *PyObject #externe libpython
PyExc_ConnectionResetError: *PyObject #externe libpython
PyExc_EOFError: *PyObject #externe libpython
PyExc_FileExistsError: *PyObject #externe libpython
PyExc_FileNotFoundError: *PyObject #externe libpython
PyExc_FloatingPointError: *PyObject #externe libpython
PyExc_GeneratorExit: *PyObject #externe libpython
PyExc_ImportError: *PyObject #externe libpython
PyExc_IndentationError: *PyObject #externe libpython
PyExc_IndexError: *PyObject #externe libpython
PyExc_InterruptedError: *PyObject #externe libpython
PyExc_IsADirectoryError: *PyObject #externe libpython
PyExc_KeyError: *PyObject #externe libpython
PyExc_KeyboardInterrupt: *PyObject #externe libpython
PyExc_LookupError: *PyObject #externe libpython
PyExc_MemoryError: *PyObject #externe libpython
PyExc_ModuleNotFoundError: *PyObject #externe libpython
PyExc_NameError: *PyObject #externe libpython
PyExc_NotADirectoryError: *PyObject #externe libpython
PyExc_NotImplementedError: *PyObject #externe libpython
PyExc_OSError: *PyObject #externe libpython
PyExc_OverflowError: *PyObject #externe libpython
PyExc_PermissionError: *PyObject #externe libpython
PyExc_ProcessLookupError: *PyObject #externe libpython
PyExc_RecursionError: *PyObject #externe libpython
PyExc_ReferenceError: *PyObject #externe libpython
PyExc_RuntimeError: *PyObject #externe libpython
PyExc_StopAsyncIteration: *PyObject #externe libpython
PyExc_StopIteration: *PyObject #externe libpython
PyExc_SyntaxError: *PyObject #externe libpython
PyExc_SystemError: *PyObject #externe libpython
PyExc_SystemExit: *PyObject #externe libpython
PyExc_TabError: *PyObject #externe libpython
PyExc_TimeoutError: *PyObject #externe libpython
PyExc_TypeError: *PyObject #externe libpython
PyExc_UnboundLocalError: *PyObject #externe libpython
PyExc_UnicodeDecodeError: *PyObject #externe libpython
PyExc_UnicodeEncodeError: *PyObject #externe libpython
PyExc_UnicodeError: *PyObject #externe libpython
PyExc_UnicodeTranslateError: *PyObject #externe libpython
PyExc_ValueError: *PyObject #externe libpython
PyExc_ZeroDivisionError: *PyObject #externe libpython

PyErr_SetObject :: fonc (exception: *PyObject, value: *PyObject) #externe libpython

/* Fonctions d'erreur pour le code généré. */

/* Erreur si le type d'un argument d'un appel de fonction n'est pas le bon. */
PyErr_MauvaisTypeArgument :: fonc (argument: *PyObject, nom_argument_attendu: chaine, type_argument_attendu: chaine) -> *PyObject
{
    chn_type := PyType_ChaineNom(argument)
    chn_erreur := enchaine("Mauvais type pour l'argument « ", nom_argument_attendu, " » ! Attendu : ", type_argument_attendu, ", obtenu : ", chn_type, " !")
    PyErr_SetObject(PyExc_TypeError, PyUnicode_FromChaine(chn_erreur))
    déloge(chn_type)
    déloge(chn_erreur)
    retourne nul
}

/* Erreur si nous ne pouvons comparer deux valeurs de deux types différents. */
PyErr_ComparaisonImpossible :: fonc (opérande: *PyObject, type_autre_opérande: chaine) -> *PyObject
{
    chn_type := PyType_ChaineNom(opérande)
    chn_erreur := enchaine("Ne peut comparer un objet de type ", type_autre_opérande, " avec un objet de type", chn_type, " !")
    PyErr_SetObject(PyExc_TypeError, PyUnicode_FromChaine(chn_erreur))
    déloge(chn_type)
    déloge(chn_erreur)
    retourne nul
}

/* Erreur si une valeur assignée n'a pas un type compatible avec celui de la variable. */
PyErr_MauvaisTypeAssignement :: fonc (valeur: *PyObject, type_variable: chaine) -> z32
{
    chn_type := PyType_ChaineNom(valeur)
    chn_erreur := enchaine("Ne peut assigner un objet de type '", chn_type, "' à un objet de type '", type_variable, "'")
    PyErr_SetObject(PyExc_TypeError, PyUnicode_FromChaine(chn_erreur))
    déloge(chn_type)
    déloge(chn_erreur)
    retourne -1
}

/* Erreur si un objet n'a pas de membre du nom de la clé, pour l'accès via o[clé]. */
PyErr_CléInconnue :: fonc (objet: *PyObject, clé: chaine) -> *PyObject
{
    chn_type := PyType_ChaineNom(objet)
    chn_erreur := enchaine("Attribut '", clé, "' inconnue pour l'objet de type ", chn_type)
    PyErr_SetObject(PyExc_KeyError, PyUnicode_FromChaine(chn_erreur))
    déloge(chn_type)
    déloge(chn_erreur)
    retourne nul
}

/* Erreur si l'attribut n'est pas mutable, pour l'assignation via o[clé] = v. */
PyErr_AttributNonMutable :: fonc (objet: *PyObject, clé: chaine) -> z32
{
    chn_type := PyType_ChaineNom(objet)
    chn_erreur := enchaine("Attribut '", clé, "' de '", chn_type, "' n'est pas écrivable")
    PyErr_SetObject(PyExc_AttributeError, PyUnicode_FromChaine(chn_erreur))
    déloge(chn_type)
    déloge(chn_erreur)
    retourne -1
}

/* Erreur si l'on tente du supprimé un attribut, par exemple via del o[clé]. */
PyErr_AttributNonSupprimable :: fonc (objet: *PyObject, clé: chaine) -> z32
{
    chn_type := PyType_ChaineNom(objet)
    chn_erreur := enchaine("Attribut '", clé, "' de '", chn_type, "' n'est pas supprimable")
    PyErr_SetObject(PyExc_AttributeError, PyUnicode_FromChaine(chn_erreur))
    déloge(chn_type)
    déloge(chn_erreur)
    retourne -1
}

/* Fonctions de comparaison d'énum pour le code généré. */

Py_compare_énum_énum :: fonc (valeur1: $T, op: z32, valeur2: T) -> *PyObject
{
    si op == Py_EQ {
        si valeur1 == valeur2 {
            retourne Py_NewRef(Py_True)
        }
        retourne Py_NewRef(Py_False)
    }

    si op == Py_NE {
        si valeur1 != valeur2 {
            retourne Py_NewRef(Py_True)
        }
        retourne Py_NewRef(Py_False)
    }

    retourne Py_NewRef(Py_NotImplemented)
}

Py_compare_énum_chaine :: fonc (valeur_énum: $T, op: z32, valeur_chaine: chaine) -> *PyObject
{
    infos := info_de(T)
    valeur_énum_comme_chaine := donne_nom_énum_pour_valeur(infos, valeur_énum comme z32)

    si op == Py_EQ {
        si valeur_chaine == valeur_énum_comme_chaine {
            retourne Py_NewRef(Py_True)
        }
        retourne Py_NewRef(Py_False)
    }

    si op == Py_NE {
        si valeur_chaine != valeur_énum_comme_chaine {
            retourne Py_NewRef(Py_True)
        }
        retourne Py_NewRef(Py_False)
    }

    retourne Py_NewRef(Py_NotImplemented)
}

/* Auxilliaire pour assigner une chaine à un énum. */

Py_AssigneChaineÉnum :: fonc (valeur_énum: &$T, valeur_chaine: chaine) -> z32
{
    infos := info_de(T)
    valeur, trouvée := donne_valeur_énum_pour_nom(infos, valeur_chaine)
    si trouvée {
        valeur_énum = valeur comme T
        retourne 0
    }

    PyErr_SetObject(PyExc_ValueError, PyUnicode_FromChaine("Valeur invalide pour l'énumération"))
    retourne -1
}

/* Auxilliaire pour ajouter les types au module lors de l'initialisation. */

DonnéesAjoutType :: struct {
    type: *PyTypeObject
    nom: ChaineC
}

Py_AjouteTypesAuModule :: fonc (module: *PyObject, types: []DonnéesAjoutType) -> *PyObject
{
    /* Initialisation des types. */
    pour types {
        saufsi it.type {
            continue
        }

        si PyType_Ready(it.type) == -1 {
            Py_DECREF(module)
            retourne python_retourne_rien()
        }
    }

    /* Après que tous les types furent initialisés, ajoutons-les au module.
     * Nous faisons cela séparement afin que le Py_DECREF utilisé en cas d'erreur
     * d'initialisation détruise correctement le module (jusqu'ici son compte
     * de référence est de 1, il sera incrémenté pour chaque type).
     */
    pour types {
        saufsi it.type {
            continue
        }

        Py_INCREF(it.type)
        PyModule_AddObject(module, it.nom, it.type)
    }

    retourne module
}

/* ------------------------------------------------------------------------- */
/** \nom Initialisation
 * \{ */

Py_Initialize :: fonc () -> rien #externe libpython

Py_InitializeEx :: fonc (initsigs: z32) -> rien #externe libpython

Py_FinalizeEx :: fonc () -> z32 #externe libpython

/** } */

/* ------------------------------------------------------------------------- */
/** \nom Exécution de code.
 * \{ */

PyCompilerFlags :: struct {
    cf_flag: z32
    cf_feature_version: z32
}

PyRun_SimpleString :: fonc (command: ChaineC) -> z32 #externe libpython

PyRun_SimpleStringFlags :: fonc (command: ChaineC, flags: *PyCompilerFlags) -> z32 #externe libpython

PyRun_String :: fonc (str: ChaineC, start: z32, globals: *PyObject, locals: *PyObject) -> *PyObject #externe libpython

PyRun_StringFlags :: fonc (str: ChaineC, start: z32, globals: *PyObject, locals: *PyObject, flags: *PyCompilerFlags) -> *PyObject #externe libpython

Py_CompileString :: fonc (str: ChaineC, filename: ChaineC, start: z32) -> *PyObject #externe libpython

Py_CompileStringFlags :: fonc (str: ChaineC, filename: ChaineC, start: z32, flags: *PyCompilerFlags) -> *PyObject #externe libpython

Py_CompileStringObject :: fonc (str: ChaineC, filename: *PyObject, start: z32, flags: *PyCompilerFlags, optimize: z32) -> *PyObject #externe libpython

Py_CompileStringExFlags :: fonc (str: ChaineC, filename: ChaineC, start: z32, flags: *PyCompilerFlags, optimize: z32) -> *PyObject #externe libpython

PyEval_EvalCode :: fonc (co: *PyObject, globals: *PyObject, locals: *PyObject) -> *PyObject #externe libpython

PyEval_EvalCodeEx :: fonc (co: *PyObject, globals: *PyObject, locals: *PyObject, args: **PyObject, argcount: z32, kws: **PyObject, kwcount: z32, defs: **PyObject, defcount: z32, kwdefs: *PyObject, closure: *PyObject) -> *PyObject #externe libpython

/* The start symbol from the Python grammar for isolated expressions;
 * for use with Py_CompileString(). */
Py_eval_input : z32 #externe libpython

/* The start symbol from the Python grammar for sequences of statements as read
 * from a file or other source; for use with Py_CompileString(). This is the
 * symbol to use when compiling arbitrarily long Python source code. */
Py_file_input : z32 #externe libpython

/* The start symbol from the Python grammar for a single statement;
 * for use with Py_CompileString(). This is the symbol used for the interactive
 * interpreter loop. */
Py_single_input : z32 #externe libpython

/** } */

/* ------------------------------------------------------------------------- */
/** \nom Enveloppes.
 * \{ */

PyRun_SimpleString :: fonc (command: chaine) -> bool
{
    command_c := crée_chaine_c(command)
    diffère détruit_chaine_c(command_c)

    retourne PyRun_SimpleString(command_c) == 0
}

PyEval_EvalCodeEx :: fonc (co: *PyObject, globals: *PyObject, locals: *PyObject, args: [..]*PyObject, kws: [..]*PyObject, defs: [..]*PyObject, kwdefs: *PyObject, closure: *PyObject) -> *PyObject
{
    retourne PyEval_EvalCodeEx(co, globals, locals, args.pointeur, args.taille comme z32, kws.pointeur, kws.taille comme z32, defs.pointeur, defs.taille comme z32)
}

/** } */

/* ------------------------------------------------------------------------- */
/** \nom GIL
 * \{ */

PyGILState_STATE :: énum {
    PyGILState_LOCKED :: 0
    PyGILState_UNLOCKED :: 1
}

PyGILState_Ensure :: fonc () -> PyGILState_STATE #externe libpython

PyGILState_Release :: fonc (state: PyGILState_STATE) -> z32 #externe libpython

/** } */

/* ------------------------------------------------------------------------- */
/** \nom Object
 * https://docs.python.org/3/c-api/object.html
 * \{ */

PyObject_Str :: fonc (o: *PyObject) -> *PyObject #externe libpython

imprime_object :: fonc (o: *PyObject) -> chaine
{
    str := PyObject_Str(o)
    diffère Py_DECREF(str)

    retourne PyUnicode_AsChaine(str)
}

PyObject_GetAttr :: fonc (o: *PyObject, attr_name: *PyObject) -> *PyObject #externe libpython

PyObject_GetAttrString :: fonc (o: *PyObject, attr_name: ChaineC) -> *PyObject #externe libpython

donne_attribut :: fonc (o: *PyObject, nom_attribut: chaine) -> *PyObject
{
    nom_attribut_c := crée_chaine_c(nom_attribut)
    diffère détruit_chaine_c(nom_attribut_c)

    retourne PyObject_GetAttrString(o, nom_attribut_c)
}

/* Ces deux fonctions implémente `len(o)`. Retourne -1 si erreur. */
PyObject_Size :: fonc (o: *PyObject) -> Py_ssize_t #externe libpython
PyObject_Length :: fonc (o: *PyObject) -> Py_ssize_t #externe libpython

/** } */

/* ------------------------------------------------------------------------- */
/** \nom Modules
 * \{ */

PyModule_GetDict :: fonc (module: *PyObject) -> *PyObject #externe libpython

/** } */

/* ------------------------------------------------------------------------- */
/** \nom Import Module.
 * \{ */

PyImport_ImportModule :: fonc (name: ChaineC) -> *PyObject #externe libpython

importe_module :: fonc (name: chaine) -> *PyObject
{
    chn_c := crée_chaine_c(name)
    diffère détruit_chaine_c(chn_c)

    retourne PyImport_ImportModule(chn_c)
}

/** } */

/* ------------------------------------------------------------------------- */
/** \nom Erreurs.
 * \{ */

PyErr_PrintEx :: fonc (set_sys_last_vars: z32) -> rien #externe libpython

PyErr_Print :: fonc ()
{
    PyErr_PrintEx(1)
}

/** } */

/* ------------------------------------------------------------------------- */
/** \nom Protocol Appel
 * https://docs.python.org/3/c-api/call.html
 * \{ */

PyObject_CallMethod :: fonc (obj: *PyObject, name: ChaineC, format: ChaineC, args: ...) -> *PyObject #externe libpython

PyObject_CallMethodObjArgs :: fonc (obj: *PyObject, name: *PyObject,  args: ...) -> *PyObject #externe libpython

/** } */

/* ------------------------------------------------------------------------- */
/** \nom List Object
 * https://docs.python.org/3/c-api/list.html
 * \{ */

PyList_New :: fonc (len: Py_ssize_t) -> *PyObject #externe libpython

PyList_SetItem :: fonc (list: *PyObject, index: Py_ssize_t, item: *PyObject) -> z32 #externe libpython

/** } */

/* ------------------------------------------------------------------------- */
/** \nom Set Object
 * \{ */

/* Crée un `set` (`set(o)`) depuis un objet itérable.
 * TypeError si l'objet n'est pas itérable. */
PySet_New :: fonc (iterable: *PyObject) -> *PyObject #externe libpython

/** } */
