// Interface pour la bibliothèque du langage Python permettant de définir des modules.

importe Chaine
importe Fondation
importe Math

libpython :: #bibliothèque "python3.10"

Py_ssize_t :: z64
Py_hash_t :: Py_ssize_t

// #if PYLONG_BITS_IN_DIGIT == 30
digit :: n32

PyAsyncMethods :: struct #externe
PyNumberMethods :: struct #externe
PyMappingMethods :: struct #externe
PyMemberDef :: struct #externe

PyGetSetDef :: struct #externe {
    name: ChaineC
    get: fonc(*PyObject, *rien)(*PyObject)
    set: fonc(*PyObject, *PyObject, *rien)(z32)
    doc: ChaineC
    closure: *rien
}

_typeobject :: PyTypeObject

PyTypeObject :: struct #externe {
    empl ob_base: PyVarObject

    tp_name: ChaineC /* For printing, in format "<module>.<name>" */

    /* For allocation */
    tp_basicsize: Py_ssize_t
    tp_itemsize: Py_ssize_t

    /* Methods to implement standard operations */

    tp_dealloc: *rien // À FAIRE: pointeur de fonction
    tp_vectorcall_offset: Py_ssize_t
    tp_getattr: *rien // À FAIRE: pointeur de fonction
    tp_setattr: *rien // À FAIRE: pointeur de fonction

    tp_as_async: *PyAsyncMethods /* formerly known as tp_compare (Python 2)
                                    or tp_reserved (Python 3) */
    tp_repr: fonc(*PyObject)(*PyObject)

    /* Method suites for standard classes */

    tp_as_number: *PyNumberMethods
    tp_as_sequence: *PySequenceMethods
    tp_as_mapping: *PyMappingMethods

    /* More standard operations (here for binary compatibility) */

    tp_hash: fonc(*PyObject)(Py_hash_t)
    tp_call: *rien // À FAIRE: pointeur de fonction ternaryfunc
    tp_str: fonc(*PyObject)(*PyObject)
    tp_getattro: *rien // À FAIRE: pointeur de fonction getattrofunc
    tp_setattro: *rien // À FAIRE: pointeur de fonction setattrofunc

    /* Functions to access object as input/output buffer */
    tp_as_buffer: *PyBufferProcs

    /* Flags to define presence of optional/expanded features */
    tp_flags: n64

    tp_doc: ChaineC /* Documentation string */

    /* Assigned meaning in release 2.0 */
    /* call function for all accessible objects */
    tp_traverse: *rien // À FAIRE: pointeur de fonction traverseproc

    /* delete references to contained objects */
    tp_clear: *rien // À FAIRE: pointeur de fonction inquiry

    /* Assigned meaning in release 2.1 */
    /* rich comparisons */
    tp_richcompare: fonc(*PyObject,*PyObject,z32)(*PyObject)

    /* weak reference enabler */
    tp_weaklistoffset: Py_ssize_t

    /* Iterators */
    tp_iter: fonc(*PyObject)(*PyObject)
    tp_iternext: fonc(*PyObject)(*PyObject)

    /* Attribute descriptor and subclassing stuff */
    tp_methods: *PyMethodDef
    tp_members: *PyMemberDef
    tp_getset: *PyGetSetDef
    tp_base: *_typeobject
    tp_dict: *PyObject
    tp_descr_get: *rien // À FAIRE: pointeur de descrgetfunc
    tp_descr_set: *rien // À FAIRE: pointeur de descrsetfunc
    tp_dictoffset: Py_ssize_t
    tp_init: *rien // À FAIRE: pointeur de fonctioninitproc
    tp_alloc: fonc (*PyTypeObject, Py_ssize_t)(*PyObject)
    tp_new: fonc (*PyTypeObject, *PyObject, *PyObject)(*PyObject) // PyObject *tp_new(PyTypeObject *subtype, PyObject *args, PyObject *kwds);
    tp_free: *rien // À FAIRE: pointeur de fonctionfreefunc /* Low-level free-memory routine */
    tp_is_gc: *rien // À FAIRE: pointeur de fonctioninquiry /* For PyObject_IS_GC */
    tp_bases: *PyGetSetDef
    tp_mro: *PyGetSetDef /* method resolution order */
    tp_cache: *PyGetSetDef
    tp_subclasses: *PyGetSetDef
    tp_weaklist: *PyGetSetDef
    tp_del: *rien // À FAIRE: pointeur de fonctiondestructor

    /* Type attribute cache version tag. Added in version 2.6 */
    tp_version_tag: n32

    tp_finalize: *rien // À FAIRE: pointeur de fonctiondestructor
    tp_vectorcall: *rien // À FAIRE: pointeur de fonctionvectorcallfunc
}

/*
Type flags (tp_flags)

These flags are used to change expected features and behavior for a
particular type.

Arbitration of the flag bit positions will need to be coordinated among
all extension writers who publicly release their extensions (this will
be fewer than you might expect!).

Most flags were removed as of Python 3.0 to make room for new flags.  (Some
flags are not for backwards compatibility but to indicate the presence of an
optional feature; these flags remain of course.)

Type definitions should use Py_TPFLAGS_DEFAULT for their tp_flags value.

Code can use PyType_HasFeature(type_ob, flag_value) to test whether the
given type object has a specified feature.
*/

/* Set if the type object is dynamically allocated */
Py_TPFLAGS_HEAPTYPE : n64 : 1 << 9

/* Set if the type allows subclassing */
Py_TPFLAGS_BASETYPE : n64 : 1 << 10

/* Set if the type implements the vectorcall protocol (PEP 590) */
// #ifndef Py_LIMITED_API
Py_TPFLAGS_HAVE_VECTORCALL : n64 : 1 << 11

/* Set if the type is 'ready' -- fully initialized */
Py_TPFLAGS_READY : n64 : 1 << 12

/* Set while the type is being 'readied', to prevent recursive ready calls */
Py_TPFLAGS_READYING : n64 : 1 << 13

/* Objects support garbage collection (see objimpl.h) */
Py_TPFLAGS_HAVE_GC : n64 : 1 << 14

/* These two bits are preserved for Stackless Python, next after this is 17 */
// #ifdef STACKLESS
// Py_TPFLAGS_HAVE_STACKLESS_EXTENSION : n64 : 3 << 15
Py_TPFLAGS_HAVE_STACKLESS_EXTENSION : n64 : 0

/* Objects behave like an unbound method */
Py_TPFLAGS_METHOD_DESCRIPTOR : n64 : 1  << 17

/* Objects support type attribute cache */
Py_TPFLAGS_HAVE_VERSION_TAG : n64 : 1  << 18
Py_TPFLAGS_VALID_VERSION_TAG : n64 : 1  << 19

/* Type is abstract and cannot be instantiated */
Py_TPFLAGS_IS_ABSTRACT : n64 : 1  << 20

/* These flags are used to determine if a type is a subclass. */
Py_TPFLAGS_LONG_SUBCLASS : n64 : 1  << 24
Py_TPFLAGS_LIST_SUBCLASS : n64 : 1  << 25
Py_TPFLAGS_TUPLE_SUBCLASS : n64 : 1  << 26
Py_TPFLAGS_BYTES_SUBCLASS : n64 : 1  << 27
Py_TPFLAGS_UNICODE_SUBCLASS : n64 : 1  << 28
Py_TPFLAGS_DICT_SUBCLASS : n64 : 1  << 29
Py_TPFLAGS_BASE_EXC_SUBCLASS : n64 : 1  << 30
Py_TPFLAGS_TYPE_SUBCLASS : n64 : 1  << 31

Py_TPFLAGS_DEFAULT :: Py_TPFLAGS_HAVE_STACKLESS_EXTENSION | Py_TPFLAGS_HAVE_VERSION_TAG

/* NOTE: The following flags reuse lower bits (removed as part of the
 * Python 3.0 transition). */

/* The following flag is kept for compatibility. Starting with 3.8,
 * binary compatibility of C extensions across feature releases of
 * Python is not supported anymore, except when using the stable ABI.
 */

/* Type structure has tp_finalize member (3.4) */
Py_TPFLAGS_HAVE_FINALIZE : n64 : 1 << 0

/* Déclaration du "object" dont les classes Python hérite par défaut. */
externe PyBaseObject_Type: PyTypeObject

PyType_Ready :: fonc (type: *PyTypeObject) -> z32 #externe libpython

PyObject :: struct #externe {
    ob_refcnt: z64
    ob_type: *PyTypeObject
}

PyVarObject :: struct {
    empl ob_base: PyObject
    ob_size: Py_ssize_t /* Number of items in variable part */
}

PyMethodDef :: struct {
    ml_name : ChaineC
    ml_meth : fonc(*PyObject, *PyObject)(*PyObject)
    ml_flag: z32
    ml_doc : ChaineC
}

PyModuleDef_Base :: struct {
  ob_base: PyObject
  m_init: fonc (rien)(*PyObject)
  m_index: z64
  m_copy: *PyObject
}

PyModuleDef_Slot :: struct #externe

PyModuleDef :: struct {
    m_base: PyModuleDef_Base
    m_name: ChaineC
    m_doc: ChaineC
    m_size: z64
    m_methods: *PyMethodDef
    m_slots: *PyModuleDef_Slot
    m_traverse: fonc(*PyObject, *rien, *rien)(z32) // le premier *rien est une fonction "visitproc"
    m_clear: fonc(*PyObject)(z32)
    m_free: fonc(*rien)(rien)
}

/* Flag passed to newmethodobject */
/* METH_OLDARGS  0x0000   -- unsupported now */
METH_VARARGS  :: 0x0001
METH_KEYWORDS :: 0x0002
/* METH_NOARGS and METH_O must not be combined with the flags above. */
METH_NOARGS   :: 0x0004
METH_O        :: 0x0008

/* METH_CLASS and METH_STATIC are a little different; these control
   the construction of methods for a class.  These cannot be used for
   functions in modules. */
METH_CLASS    :: 0x0010
// #ifndef Py_LIMITED_API
METH_STATIC   :: 0x0020

/* METH_COEXIST allows a method to be entered even though a slot has
   already filled the entry.  When defined, the flag allows a separate
   method, "__contains__" for example, to coexist with a defined
   slot like sq_contains. */

METH_COEXIST   :: 0x0040
METH_FASTCALL  :: 0x0080

/* This bit is preserved for Stackless Python */
// #ifdef PYTHON_STACKLESS
METH_STACKLESS :: 0x0100

/* METH_METHOD means the function stores an
 * additional reference to the class that defines it;
 * both self and class are passed to it.
 * It uses PyCMethodObject instead of PyCFunctionObject.
 * May not be combined with METH_NOARGS, METH_O, METH_CLASS or METH_STATIC.
 */

//#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000
METH_METHOD 0x0200

PYTHON_API_VERSION :: 1013

externe _Py_NoneStruct : PyObject
Py_None : *PyObject = *_Py_NoneStruct

python_retourne_rien :: fonc () -> *PyObject
{
    Py_INCREF(Py_None)
    retourne Py_None
}

externe PyBool_Type : PyTypeObject

_longobject :: struct {
    ob_base: PyVarObject
    ob_digit: [1]digit;
}

externe _Py_FalseStruct: PyObject // À FAIRE _longobject
Py_False : *PyObject = *_Py_FalseStruct

python_retourne_faux :: fonc () -> *PyObject
{
    Py_INCREF(Py_False)
    retourne Py_False
}

externe _Py_TrueStruct : PyObject // À FAIRE _longobject
Py_True : *PyObject = *_Py_TrueStruct

python_retourne_true :: fonc () -> *PyObject
{
    Py_INCREF(Py_True)
    retourne Py_True
}

PyArg_ParseTuple :: fonc (args: *PyObject, format: ChaineC,  r_ob: ...) -> z32 #externe libpython

externe _Py_NotImplementedStruct : PyObject
Py_NotImplemented : *PyObject = *_Py_NotImplementedStruct

// ---------------------------------------------------
// Références

_Py_Dealloc :: fonc (ob: *PyObject) #externe libpython

Py_INCREF :: fonc (ob: *PyObject)
{
    ob.ob_refcnt += 1
}

Py_XINCREF :: fonc (ob: *PyObject)
{
    si ob {
        Py_INCREF(ob)
    }
}

Py_DECREF :: fonc (ob: *PyObject)
{
    ob.ob_refcnt -= 1
    si ob.ob_refcnt == 0 {
        _Py_Dealloc(ob)
    }
}

Py_XDECREF :: fonc (ob: *PyObject)
{
    saufsi ob {
        retourne
    }

    Py_DECREF(ob)
}

Py_NewRef :: fonc (ob: *PyObject) -> *PyObject
{
    Py_INCREF(ob)
    retourne ob
}

Py_XNewRef :: fonc (ob: *PyObject) -> *PyObject
{
    Py_XINCREF(ob)
    retourne ob
}

// ---------------------------------------------------
/* Rich comparison opcodes */
Py_LT :: 0
Py_LE :: 1
Py_EQ :: 2
Py_NE :: 3
Py_GT :: 4
Py_GE :: 5

// ---------------------------------------------------
// Module

PyModule_Create2 :: fonc (module_def: *PyModuleDef, apiver: z32) -> *PyObject #externe libpython

PyModule_AddObject :: fonc (module: *PyObject, name: ChaineC, value: *PyObject) #externe libpython
PyModule_AddIntConstant :: fonc (module: *PyObject, name: ChaineC, value: z64) -> z32 #externe libpython
PyModule_AddStringConstant :: fonc (module: *PyObject, name: ChaineC, value: ChaineC) -> z32 #externe libpython

// ---------------------------------------------------
// Objet

PyType_IsSubtype :: fonc (type1: *PyTypeObject, type2: *PyTypeObject) -> z32 #externe libpython

PyType_HasFeature :: fonc (type: *PyTypeObject, feature: n64) -> bool #enligne
{
    flags := type.tp_flags
    retourne (flags & feature) != 0
}

PyType_FastSubclass :: fonc (type: *PyTypeObject, feature: n64) -> bool #enligne
{
    retourne PyType_HasFeature(type, feature)
}

_Py_IS_TYPE :: fonc (ob: *PyObject, type: *PyTypeObject) -> bool
{
    retourne ob.ob_type == type
}

PyObject_TypeCheck :: fonc (ob: *PyObject, type: *PyTypeObject) -> bool
{
    retourne _Py_IS_TYPE(ob, type) || (PyType_IsSubtype(ob.ob_type, type) != 0)
}

PyObject_HashNotImplemented :: fonc (o: *PyObject) -> Py_hash_t #externe libpython

// ---------------------------------------------------
// Objet Bool

PyBool_Check :: fonc (ob: *PyObject) -> bool
{
    retourne PyObject_TypeCheck(ob, *PyBool_Type)
}

PyBool_AsBool :: fonc (ob: *PyObject) -> bool
{
    retourne ob == Py_True
}

PyBool_FromBool :: fonc (valeur: bool) -> *PyObject
{
    si valeur {
        retourne python_retourne_true()
    }
    retourne python_retourne_faux()
}

// ---------------------------------------------------
// Objet Entier/Long

PyLong_Check :: fonc (ob: *PyObject) -> bool
{
    retourne PyType_FastSubclass(ob.ob_type, Py_TPFLAGS_LONG_SUBCLASS)
}

PyLong_FromLong :: fonc (l: z64) -> *PyObject #externe libpython
PyLong_AsLong :: fonc (ob: *PyObject) -> z64 #externe libpython

PyLong_AsZ8 :: fonc (ob: *PyObject) -> z8
{
    retourne PyLong_AsLong(ob) comme z8
}

PyLong_AsZ16 :: fonc (ob: *PyObject) -> z16
{
    retourne PyLong_AsLong(ob) comme z16
}

PyLong_AsZ32 :: fonc (ob: *PyObject) -> z32
{
    retourne PyLong_AsLong(ob) comme z32
}

PyLong_AsN8 :: fonc (ob: *PyObject) -> n8
{
    retourne PyLong_AsLong(ob) comme n8
}

PyLong_AsN16 :: fonc (ob: *PyObject) -> n16
{
    retourne PyLong_AsLong(ob) comme n16
}

PyLong_AsN32 :: fonc (ob: *PyObject) -> n32
{
    retourne PyLong_AsLong(ob) comme n32
}

PyLong_AsN64 :: fonc (ob: *PyObject) -> n64
{
    retourne PyLong_AsLong(ob) comme n64
}

PyLong_FromN8 :: fonc (l: n8) -> *PyObject
{
    retourne PyLong_FromLong(l comme z64)
}

PyLong_FromN16 :: fonc (l: n16) -> *PyObject
{
    retourne PyLong_FromLong(l comme z64)
}

PyLong_FromN32 :: fonc (l: n32) -> *PyObject
{
    retourne PyLong_FromLong(l comme z64)
}

PyLong_FromN64 :: fonc (l: n64) -> *PyObject
{
    retourne PyLong_FromLong(l comme z64)
}

// ---------------------------------------------------
// Objet Réel/Double

externe PyFloat_Type : PyTypeObject

PyFloat_Check :: fonc (ob: *PyObject) -> bool
{
    retourne PyObject_TypeCheck(ob, *PyFloat_Type)
}

PyFloat_FromDouble :: fonc (l: r64) -> *PyObject #externe libpython
PyFloat_AsDouble :: fonc (ob: *PyObject) -> r64 #externe libpython

PyFloat_AsR32 :: fonc (ob: *PyObject) -> r32
{
    retourne PyFloat_AsDouble(ob) comme r32
}

PyFloat_AsR16 :: fonc (ob: *PyObject) -> r16
{
    retourne PyFloat_AsDouble(ob) comme r16
}

// ---------------------------------------------------
// Objet Unicode

externe PyUnicode_Type : PyTypeObject

PyUnicode_Check :: fonc (ob: *PyObject) -> bool
{
    retourne PyType_FastSubclass(ob.ob_type, Py_TPFLAGS_UNICODE_SUBCLASS)
}

PyUnicode_CheckExact :: fonc (ob: *PyObject) -> bool
{
    retourne PyObject_TypeCheck(ob, *PyUnicode_Type)
}

PyUnicode_FromStringAndSize :: fonc (str: *z8, taille: Py_ssize_t) -> *PyObject #externe libpython
PyUnicode_AsUTF8AndSize :: fonc (unicode: *PyObject, size: *Py_ssize_t) -> *z8 #externe libpython

PyUnicode_AsChaine :: fonc (unicode: *PyObject) -> chaine
{
    résultat : chaine = ---
    résultat.pointeur = PyUnicode_AsUTF8AndSize(unicode, *résultat.taille)
    retourne résultat
}

PyUnicode_FromChaine :: fonc (chn: chaine) -> *PyObject
{
    retourne PyUnicode_FromStringAndSize(chn.pointeur, chn.taille)
}

// ---------------------------------------------------
// Sequence Protocol

lenfunc :: fonc (*PyObject)(Py_ssize_t)
binaryfunc :: fonc (*PyObject, *PyObject)(*PyObject)
ssizeargfunc :: fonc (*PyObject, Py_ssize_t)(*PyObject)
ssizeobjargproc :: fonc (*PyObject, Py_ssize_t)(z32)
objobjproc :: fonc (*PyObject, *PyObject)(z32)

PySequenceMethods :: struct {
    sq_length: lenfunc
    sq_concat: binaryfunc
    sq_repeat: ssizeargfunc
    sq_item: ssizeargfunc
    was_sq_slice: *rien
    sq_ass_item: ssizeobjargproc
    was_sq_ass_slice: *rien
    sq_contains: objobjproc

    sq_inplace_concat: binaryfunc
    sq_inplace_repeat: ssizeargfunc
}

// ---------------------------------------------------
// Buffer Interface

Py_buffer :: struct {
    buf: *rien
    obj: *PyObject        /* owned reference */
    len: Py_ssize_t
    itemsize: Py_ssize_t  /* This is Py_ssize_t so it can be
                             pointed to by strides in simple case.*/
    readonly: z32
    ndim: z32
    format: *z8
    shape: *Py_ssize_t
    strides: *Py_ssize_t
    suboffsets: *Py_ssize_t
    internal: *rien
}

getbufferproc :: fonc (*PyObject, *Py_buffer, z32)(z32)
releasebufferproc :: fonc (*PyObject, *Py_buffer)(rien)

PyBufferProcs :: struct {
    bf_getbuffer: getbufferproc
    bf_releasebuffer: releasebufferproc
}

vectorcallfunc :: fonc (/* callable */*PyObject, /* args */ **PyObject, /* nargsf */ n64, /* kwnames */ *PyObject)(*PyObject)

/* Maximum number of dimensions */
PyBUF_MAX_NDIM :: 64

/* Flags for getting buffers */
PyBUF_SIMPLE :: 0
PyBUF_WRITABLE :: 0x0001
/*  we used to include an E, backwards compatible alias  */
PyBUF_WRITEABLE :: PyBUF_WRITABLE
PyBUF_FORMAT :: 0x0004
PyBUF_ND :: 0x0008
PyBUF_STRIDES :: (0x0010 | PyBUF_ND)
PyBUF_C_CONTIGUOUS :: (0x0020 | PyBUF_STRIDES)
PyBUF_F_CONTIGUOUS :: (0x0040 | PyBUF_STRIDES)
PyBUF_ANY_CONTIGUOUS :: (0x0080 | PyBUF_STRIDES)
PyBUF_INDIRECT :: (0x0100 | PyBUF_STRIDES)

PyBUF_CONTIG :: (PyBUF_ND | PyBUF_WRITABLE)
PyBUF_CONTIG_RO :: (PyBUF_ND)

PyBUF_STRIDED :: (PyBUF_STRIDES | PyBUF_WRITABLE)
PyBUF_STRIDED_RO :: (PyBUF_STRIDES)

PyBUF_RECORDS :: (PyBUF_STRIDES | PyBUF_WRITABLE | PyBUF_FORMAT)
PyBUF_RECORDS_RO :: (PyBUF_STRIDES | PyBUF_FORMAT)

PyBUF_FULL :: (PyBUF_INDIRECT | PyBUF_WRITABLE | PyBUF_FORMAT)
PyBUF_FULL_RO :: (PyBUF_INDIRECT | PyBUF_FORMAT)

PyBUF_READ  :: 0x100
PyBUF_WRITE :: 0x200

// ---------------------------------------------------
// Fonctions pour générer les interfaces de tampons

/* Structure de base pour les objets supportant le protocol de tampon. */
BasePyBuffer :: struct {
    empl base: PyObject

    /* Nombre de fois que le tampon fut exporté. */
    exports: z32

    remplis_champs_requis_py_buffer: fonc (*BasePyBuffer, *Py_buffer)(rien)
}

/* Détermine la chaine de formattage pour un type de données, selon
 * https://docs.python.org/3/library/struct.html#struct-format-strings
 * Les chaines retournées doivent être nul-terminées.
 */
format_tampon_pour_info_type :: fonc (info: *InfoType) -> chaine
{
    discr info.id {
        ENTIER {
            info_entier := info comme *InfoTypeEntier
            si info_entier.est_signé {
                si info_entier.taille_en_octet == 1 {
                    retourne "b\0"
                }

                si info_entier.taille_en_octet == 2 {
                    retourne "h\0"
                }

                si info_entier.taille_en_octet == 4 {
                    retourne "i\0"
                }

                si info_entier.taille_en_octet == 8 {
                    retourne "l\0"
                }
            }
            sinon {
                si info_entier.taille_en_octet == 1 {
                    retourne "B\0"
                }

                si info_entier.taille_en_octet == 2 {
                    retourne "H\0"
                }

                si info_entier.taille_en_octet == 4 {
                    retourne "I\0"
                }

                si info_entier.taille_en_octet == 8 {
                    retourne "L\0"
                }
            }
        }
        RÉEL {
            si info.taille_en_octet == 2 {
                retourne "e\0"
            }

            si info.taille_en_octet == 4 {
                retourne "f\0"
            }

            si info.taille_en_octet == 8 {
                retourne "d\0"
            }
        }
        BOOLÉEN,
        OCTET {
            retourne "b\0"
        }
        TYPE_DE_DONNÉES {
            retourne "L\0"
        }
        UNION {
            // À FAIRE
        }
        STRUCTURE {
            info_struct := info comme *InfoTypeStructure

            si info_struct.membres.taille == 0 {
                retourne "b\0"
            }

            type_premier_membre := info_struct.membres[0].id
            pour info_struct.membres {
                si type_premier_membre != it.id {
                    arrête
                }
            }
            sansarrêt {
                /* Si tous les membres ont le même type (p.e. nous avons un vecteur),
                 * utilisons le format du type partagé par tous les membres. */
                retourne format_tampon_pour_info_type(type_premier_membre)
            }

            /* Sinon, retourne le formattage pour des octets. */
            retourne "b\0"
        }
        ÉNUM {
            info_énum := info comme *InfoTypeÉnum
            retourne format_tampon_pour_info_type(info_énum.type_sous_jacent)
        }
        OPAQUE {
            opaque := info comme *InfoTypeOpaque
            retourne format_tampon_pour_info_type(opaque.type_opacifié)
        }
        TABLEAU {
            tableau := info comme *InfoTypeTableau
            retourne format_tampon_pour_info_type(tableau.type_pointé)
        }
        CHAINE,
        RIEN,
        EINI {
            // À FAIRE
        }
        FONCTION,
        POINTEUR {
            retourne "P\0"
        }
    }

    /* Retourne des octets par défaut. */
    retourne "B\0"
}

remplis_champs_requis_py_buffer_générique :: fonc (view: *Py_buffer, tableau: []$T)
{
    view.buf = tableau.pointeur
    view.itemsize = taille_de(T) comme Py_ssize_t
    view.len = (tableau.taille comme n32 * taille_de(T)) comme Py_ssize_t
    view.format = format_tampon_pour_info_type(info_de(T)).pointeur

    // À FAIRE : tableau de tableau
    view.ndim = 1
    view.shape = loge(Py_ssize_t)
    mémoire(view.shape) = tableau.taille

    view.strides = loge(Py_ssize_t)
    mémoire(view.strides) = taille_de(T) comme Py_ssize_t

    view.suboffsets = loge(Py_ssize_t)
    mémoire(view.suboffsets) = 0
}

erreur_export_tampon :: fonc (view: *Py_buffer, message: chaine) -> z32
{
    view.obj = nul
    PyErr_SetObject(PyExc_BufferError, PyUnicode_FromChaine(message))
    retourne -1
}

possède_drapeau :: fonc (drapeaux: n64, valeur: n64) -> bool
{
    retourne (drapeaux & valeur) != 0
}

/* https://docs.python.org/3/c-api/typeobj.html#c.PyBufferProcs.bf_getbuffer */
impl_get_buffer_proc :: fonc (exporter: *PyObject, view: *Py_buffer, flags: z32) -> z32
{
    objet_tampon := exporter comme *BasePyBuffer

    /* 1. Check if the request can be met. If not, raise PyExc_BufferError, set view->obj to NULL and return -1. */
    view.readonly = 1
    si possède_drapeau(flags comme n64, PyBUF_WRITABLE comme n64) {
        retourne erreur_export_tampon(view, "Impossible d'exporter le tampon pour une écriture")
    }

    /* 2. Fill in the requested fields. */
    objet_tampon.remplis_champs_requis_py_buffer(objet_tampon, view)

    saufsi possède_drapeau(flags comme n64, PyBUF_FORMAT comme n64) {
        view.format = nul
    }

    /* 3. Increment an internal counter for the number of exports. */
    objet_tampon.exports += 1

    /* 4. Set view->obj to exporter and increment view->obj. */
    view.obj = exporter
    Py_INCREF(view.obj)

    /* 5. Return 0. */
    retourne 0
}

impl_release_buffer_proc :: fonc (exporter: *PyObject, view: *Py_buffer)
{
    objet_tampon := exporter comme *BasePyBuffer
    objet_tampon.exports -= 1

    si objet_tampon.exports == 0 {
        déloge(view.shape)
        déloge(view.strides)
        déloge(view.suboffsets)
    }
}

/* Globale pour les fonctions fonctions génériques de protocol de tampon. */
Py_BufferProtocol_Défaut : PyBufferProcs

protocol_tampon_défaut :: fonc () -> *PyBufferProcs
{
    Py_BufferProtocol_Défaut.bf_getbuffer = impl_get_buffer_proc
    Py_BufferProtocol_Défaut.bf_releasebuffer = impl_release_buffer_proc
    retourne *Py_BufferProtocol_Défaut
}

// ---------------------------------------------------
// Utilitaires

PyType_ChaineNom :: fonc (obj: *PyObject) -> chaine
{
    retourne convertis_chaine_c(obj.ob_type.tp_name)
}

PyUnicodeEnum_Check :: fonc (object: *PyObject, info: *InfoTypeÉnum) -> bool
{
    saufsi PyUnicode_Check(object) {
        retourne faux
    }

    chn := PyUnicode_AsChaine(object)

    pour info.noms {
        si it == chn {
            retourne vrai
        }
    }

    retourne faux
}

PyUnicodeEnum_Value :: fonc (object: *PyObject, info: *InfoTypeÉnum) -> z32
{
    chn := PyUnicode_AsChaine(object)

    pour info.noms {
        si it == chn {
            retourne info.valeurs[index_it]
        }
    }

    retourne 0
}

PyUnicodeEnum_Value_z8 :: fonc (object: *PyObject, info: *InfoTypeÉnum) -> z8
{
    retourne PyUnicodeEnum_Value(object, info) comme z8
}

PyUnicodeEnum_Value_z16 :: fonc (object: *PyObject, info: *InfoTypeÉnum) -> z16
{
    retourne PyUnicodeEnum_Value(object, info) comme z16
}

PyUnicodeEnum_Value_z32 :: fonc (object: *PyObject, info: *InfoTypeÉnum) -> z32
{
    retourne PyUnicodeEnum_Value(object, info)
}

PyUnicodeEnum_Value_z64 :: fonc (object: *PyObject, info: *InfoTypeÉnum) -> z64
{
    retourne PyUnicodeEnum_Value(object, info) comme z64
}

PyUnicodeEnum_Value_n8 :: fonc (object: *PyObject, info: *InfoTypeÉnum) -> n8
{
    retourne PyUnicodeEnum_Value(object, info) comme n8
}

PyUnicodeEnum_Value_n16 :: fonc (object: *PyObject, info: *InfoTypeÉnum) -> n16
{
    retourne PyUnicodeEnum_Value(object, info) comme n16
}

PyUnicodeEnum_Value_n32 :: fonc (object: *PyObject, info: *InfoTypeÉnum) -> n32
{
    retourne PyUnicodeEnum_Value(object, info) comme n32
}

PyUnicodeEnum_Value_n64 :: fonc (object: *PyObject, info: *InfoTypeÉnum) -> n64
{
    retourne PyUnicodeEnum_Value(object, info) comme n64
}

fonction_PyUnicodeEnum_Value_pour_info :: fonc (info_énum: *InfoTypeÉnum) -> chaine
{
    info := info_énum.type_sous_jacent

    si info == info_de(z8) {
        retourne "PyUnicodeEnum_Value_z8"
    }
    si info == info_de(z16) {
        retourne "PyUnicodeEnum_Value_z16"
    }
    si info == info_de(z32) {
        retourne "PyUnicodeEnum_Value_z32"
    }
    si info == info_de(z64) {
        retourne "PyUnicodeEnum_Value_z64"
    }
    si info == info_de(n8) {
        retourne "PyUnicodeEnum_Value_n8"
    }
    si info == info_de(n16) {
        retourne "PyUnicodeEnum_Value_n16"
    }
    si info == info_de(n32) {
        retourne "PyUnicodeEnum_Value_n32"
    }
    si info == info_de(n64) {
        retourne "PyUnicodeEnum_Value_n64"
    }
    retourne "PyUnicodeEnum_Value"
}

// ---------------------------------------------------
// Exceptions

externe PyExc_BaseException: *PyObject
externe PyExc_Exception: *PyObject
externe PyExc_ArithmeticError: *PyObject
externe PyExc_AssertionError: *PyObject
externe PyExc_AttributeError: *PyObject
externe PyExc_BlockingIOError: *PyObject
externe PyExc_BrokenPipeError: *PyObject
externe PyExc_BufferError: *PyObject
externe PyExc_ChildProcessError: *PyObject
externe PyExc_ConnectionAbortedError: *PyObject
externe PyExc_ConnectionError: *PyObject
externe PyExc_ConnectionRefusedError: *PyObject
externe PyExc_ConnectionResetError: *PyObject
externe PyExc_EOFError: *PyObject
externe PyExc_FileExistsError: *PyObject
externe PyExc_FileNotFoundError: *PyObject
externe PyExc_FloatingPointError: *PyObject
externe PyExc_GeneratorExit: *PyObject
externe PyExc_ImportError: *PyObject
externe PyExc_IndentationError: *PyObject
externe PyExc_IndexError: *PyObject
externe PyExc_InterruptedError: *PyObject
externe PyExc_IsADirectoryError: *PyObject
externe PyExc_KeyError: *PyObject
externe PyExc_KeyboardInterrupt: *PyObject
externe PyExc_LookupError: *PyObject
externe PyExc_MemoryError: *PyObject
externe PyExc_ModuleNotFoundError: *PyObject
externe PyExc_NameError: *PyObject
externe PyExc_NotADirectoryError: *PyObject
externe PyExc_NotImplementedError: *PyObject
externe PyExc_OSError: *PyObject
externe PyExc_OverflowError: *PyObject
externe PyExc_PermissionError: *PyObject
externe PyExc_ProcessLookupError: *PyObject
externe PyExc_RecursionError: *PyObject
externe PyExc_ReferenceError: *PyObject
externe PyExc_RuntimeError: *PyObject
externe PyExc_StopAsyncIteration: *PyObject
externe PyExc_StopIteration: *PyObject
externe PyExc_SyntaxError: *PyObject
externe PyExc_SystemError: *PyObject
externe PyExc_SystemExit: *PyObject
externe PyExc_TabError: *PyObject
externe PyExc_TimeoutError: *PyObject
externe PyExc_TypeError: *PyObject
externe PyExc_UnboundLocalError: *PyObject
externe PyExc_UnicodeDecodeError: *PyObject
externe PyExc_UnicodeEncodeError: *PyObject
externe PyExc_UnicodeError: *PyObject
externe PyExc_UnicodeTranslateError: *PyObject
externe PyExc_ValueError: *PyObject
externe PyExc_ZeroDivisionError: *PyObject

PyErr_SetObject :: fonc (exception: *PyObject, value: *PyObject) #externe libpython

/* Fonctions d'erreur pour le code généré. */

/* Erreur si le type d'un argument d'un appel de fonction n'est pas le bon. */
PyErr_MauvaisTypeArgument :: fonc (argument: *PyObject, nom_argument_attendu: chaine, type_argument_attendu: chaine) -> *PyObject
{
    chn_type := PyType_ChaineNom(argument)
    chn_erreur := enchaine("Mauvais type pour l'argument « ", nom_argument_attendu, " » ! Attendu : ", type_argument_attendu, ", obtenu : ", chn_type, " !")
    PyErr_SetObject(PyExc_TypeError, PyUnicode_FromChaine(chn_erreur))
    déloge(chn_type)
    déloge(chn_erreur)
    retourne nul
}

/* Erreur si nous ne pouvons comparer deux valeurs de deux types différents. */
PyErr_ComparaisonImpossible :: fonc (opérande: *PyObject, type_autre_opérande: chaine) -> *PyObject
{
    chn_type := PyType_ChaineNom(opérande)
    chn_erreur := enchaine("Ne peut comparer un objet de type ", type_autre_opérande, " avec un objet de type", chn_type, " !")
    PyErr_SetObject(PyExc_TypeError, PyUnicode_FromChaine(chn_erreur))
    déloge(chn_type)
    déloge(chn_erreur)
    retourne nul
}

/* Erreur si une valeur assignée n'a pas un type compatible avec celui de la variable. */
PyErr_MauvaisTypeAssignement :: fonc (valeur: *PyObject, type_variable: chaine) -> z32
{
    chn_type := PyType_ChaineNom(valeur)
    chn_erreur := enchaine("Ne peut assigner un objet de type '", chn_type, "' à un objet de type '", type_variable, "'")
    PyErr_SetObject(PyExc_TypeError, PyUnicode_FromChaine(chn_erreur))
    déloge(chn_type)
    déloge(chn_erreur)
    retourne -1
}

/* Fonctions de comparaison d'énum pour le code généré. */

Py_compare_énum_énum :: fonc (valeur1: $T, op: z32, valeur2: T) -> *PyObject
{
    si op == Py_EQ {
        si valeur1 == valeur2 {
            retourne Py_NewRef(Py_True)
        }
        retourne Py_NewRef(Py_False)
    }

    si op == Py_NE {
        si valeur1 != valeur2 {
            retourne Py_NewRef(Py_True)
        }
        retourne Py_NewRef(Py_False)
    }

    retourne Py_NewRef(Py_NotImplemented)
}

Py_compare_énum_chaine :: fonc (valeur_énum: $T, op: z32, valeur_chaine: chaine) -> *PyObject
{
    infos := info_de(T)
    valeur_énum_comme_chaine := infos.noms[valeur_énum]

    si op == Py_EQ {
        si valeur_chaine == valeur_énum_comme_chaine {
            retourne Py_NewRef(Py_True)
        }
        retourne Py_NewRef(Py_False)
    }

    si op == Py_NE {
        si valeur_chaine != valeur_énum_comme_chaine {
            retourne Py_NewRef(Py_True)
        }
        retourne Py_NewRef(Py_False)
    }

    retourne Py_NewRef(Py_NotImplemented)
}

/* Auxilliaire pour assigner une chaine à un énum. */

Py_AssigneChaineÉnum :: fonc (valeur_énum: &$T, valeur_chaine: chaine) -> z32
{
    infos := info_de(T)

    pour infos.noms {
        si it == valeur_chaine {
            valeur_énum = infos.valeurs[index_it] comme T
            retourne 0
        }
    }

    PyErr_SetObject(PyExc_ValueError, PyUnicode_FromChaine("Valeur invalide pour l'énumération"))
    retourne -1
}

/* Auxilliaire pour ajouter les types au module lors de l'initialisation. */

DonnéesAjoutType :: struct {
    type: *PyTypeObject
    nom: ChaineC
}

Py_AjouteTypesAuModule :: fonc (module: *PyObject, types: []DonnéesAjoutType) -> *PyObject
{
    /* Initialisation des types. */
    pour types {
        saufsi it.type {
            continue
        }

        si PyType_Ready(it.type) == -1 {
            Py_DECREF(module)
            retourne python_retourne_rien()
        }
    }

    /* Après que tous les types furent initialisés, ajoutons-les au module.
     * Nous faisons cela séparement afin que le Py_DECREF utilisé en cas d'erreur
     * d'initialisation détruise correctement le module (jusqu'ici son compte
     * de référence est de 1, il sera incrémenté pour chaque type).
     */
    pour types {
        saufsi it.type {
            continue
        }

        Py_INCREF(it.type)
        PyModule_AddObject(module, it.nom, it.type)
    }

    retourne module
}
