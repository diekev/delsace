/*

Génération de code Kuri pour créer un module Python depuis du code Kuri.

*/

importe Compilatrice
importe Fondation
importe SysFichier

// À FAIRE : gère proprement les chaines, les chaines C ne sont jamais détruites !

ModulePython :: struct {
    nom: chaine
    méthodes : []MéthodePython
    constantes_nombre_entier : []ConstanteNombreEntier
    constantes_chaine : []ConstanteChaine
    types: []TypePython
}

ConfidentialitéType :: énum {
    /* Les membres du type peuvent être accédés. */
    ACCESSIBLE
    /* Les membres du type peuvent être mutés, ceci implique qu'ils sont également ACCESSIBLE. */
    MUTABLE
    /* Les membres du type ne sont pas ni accessible, ni mutable. */
    OPAQUE
}

TypePython :: struct {
    nom: chaine
    type_kuri: *InfoTypeStructure

    confidentialité: ConfidentialitéType

    méthodes: []MéthodePython

    new: MéthodePython
    init: MéthodePython
    repr: MéthodePython
    str: MéthodePython

    /* Données pour la génération de code, mises en place lors de celle-ci. */

    /* Le nom de la globale qui défini les informations sur le PyTypeObject correspondant. */
    nom_globale_type: chaine
}

ajoute_type :: fonc (module: &ModulePython, type_kuri: *InfoTypeStructure, confidentialité: ConfidentialitéType)
{
    pour module.types {
        si it.type_kuri == type_kuri {
            // À FAIRE : vérifie la confidentialité.
            retourne
        }
    }

    type := TypePython()
    type.nom = type_kuri.nom
    type.type_kuri = type_kuri
    type.confidentialité = confidentialité

    tableau_ajoute(*module.types, type)
}

type_python_pour :: fonc (module: &ModulePython, info: *InfoTypeStructure) -> *TypePython
{
    pour * module.types {
        si it.type_kuri == info {
            retourne it
        }
    }

    retourne nul
}

ajoute_méthode :: fonc (type: &TypePython, fonction: *NoeudCodeEntêteFonction)
{
    méthode := méthode_python_depuis_entête(fonction)
    tableau_ajoute(*type.méthodes, méthode)
}

ajoute_méthode_new :: fonc (type: *TypePython, fonction: *NoeudCodeEntêteFonction)
{
    type.new = méthode_python_depuis_entête(fonction, vrai)
}

ajoute_méthode_init :: fonc (type: *TypePython, fonction: *NoeudCodeEntêteFonction)
{
    type.init = méthode_python_depuis_entête(fonction, vrai)
}

ajoute_méthode_repr :: fonc (type: *TypePython, fonction: *NoeudCodeEntêteFonction)
{
    type.repr = méthode_python_depuis_entête(fonction)
}

ajoute_méthode_str :: fonc (type: *TypePython, fonction: *NoeudCodeEntêteFonction)
{
    type.str = méthode_python_depuis_entête(fonction)
}

ConstanteNombreEntier :: struct {
    nom: chaine
    valeur: z64
}

ConstanteChaine :: struct {
    nom: chaine
    valeur: chaine
}

ajoute_constante_nombre_entier :: fonc (module: &ModulePython, nom: chaine, valeur: z64)
{
    tableau_ajoute(*module.constantes_nombre_entier, ConstanteNombreEntier(nom, valeur))
}

ajoute_constante_chaine :: fonc (module: &ModulePython, nom: chaine, valeur: chaine)
{
    tableau_ajoute(*module.constantes_chaine, ConstanteChaine(nom, valeur))
}

GenreTypePython :: énum {
    /* Un nombre entier. */
    LONG
    /* Un nombre décimal. */
    DOUBLE
    /* Un PyObject */
    OBJET
    /* Une chaine, qui devrat être convertis depuis et vers Python. */
    CHAINE
    /* Pour None. */
    RIEN
    /* Ceci est pour les objets que nous allouons sur la pile, et que l'on via PyLong_AsVoidPtr, etc. */
    POINTEUR_QUELCONQUE
}

/* Chaine de caractère pour le type Kuri utilisé dans l'IPA C de Python. */
chaine_pour_genre_type_python :: fonc (type: GenreTypePython) -> chaine
{
    discr type {
        LONG {
            retourne "z32"
        }
        DOUBLE {
            retourne "r64"
        }
        CHAINE {
            retourne "*z8"
        }
        RIEN,
        OBJET,
        POINTEUR_QUELCONQUE {
            retourne "*PyObject"
        }
    }

    retourne "invalide"
}

/* Retourne le format à utiliser pour PyArg_ParseTuple selon le type. */
format_extraction_genre_type_python :: fonc (type: GenreTypePython) -> chaine
{
    discr type {
        LONG {
            retourne "i"
        }
        DOUBLE {
            retourne "d"
        }
        CHAINE {
            retourne "s"
        }
        RIEN,
        OBJET,
        POINTEUR_QUELCONQUE {
            retourne "O"
        }
    }

    retourne "invalide"
}

genre_type_python_pour_info_type :: fonc (info: *InfoType) -> GenreTypePython
{
    discr info.id {
        ENTIER {
            retourne GenreTypePython.LONG
        }
        RÉEL {
            retourne GenreTypePython.DOUBLE
        }
        CHAINE {
            retourne GenreTypePython.CHAINE
        }
        RIEN {
            retourne GenreTypePython.RIEN
        }
        sinon {
            retourne GenreTypePython.POINTEUR_QUELCONQUE
        }
    }
}

ParamètreMéthodePython :: struct {
    nom: chaine
    type: GenreTypePython
    type_kuri: *InfoType
}

MéthodePython :: struct {
    nom: chaine
    paramètres_entrée: []ParamètreMéthodePython
    paramètres_sortie: []ParamètreMéthodePython
}

ne_retourne_rien :: fonc (méthode: &MéthodePython) -> bool
{
    saufsi méthode.paramètres_sortie {
        retourne vrai
    }

    premier_param := méthode.paramètres_sortie[0]
    retourne méthode.paramètres_sortie.taille == 1 && premier_param.type == GenreTypePython.RIEN
}

convertis_paramètre :: fonc (param: *NoeudCode) -> ParamètreMéthodePython
{
    résultat: ParamètreMéthodePython
    résultat.nom = param.nom
    résultat.type_kuri = param.type
    résultat.type = genre_type_python_pour_info_type(param.type)
    retourne résultat
}

// ignore_premier_paramètre_après_contexte est pour les fonctions d'allocation, etc.,
// qui doivent prendre un paramètre du type dans kuri, mais qui peuvent ne pas prendre
// l'objet en paramètre dans Python.
méthode_python_depuis_entête :: fonc (entête: *NoeudCodeEntêteFonction, ignore_premier_paramètre_après_contexte := faux) -> MéthodePython
{
    résultat: MéthodePython
    résultat.nom = entête.nom

    après_contexte := vrai

    pour entête.params {
        /* Ignore le contexte implicite, seuls les vrais paramètres devraient être convertis. */
        si it.type == info_de(ContexteProgramme) {
            après_contexte = vrai
            continue
        }

        si après_contexte && ignore_premier_paramètre_après_contexte {
            après_contexte = faux
            continue
        }

        param := convertis_paramètre(it)
        tableau_ajoute(*résultat.paramètres_entrée, param)
    }

    pour entête.params_sorties {
        param := convertis_paramètre(it)
        tableau_ajoute(*résultat.paramètres_sortie, param)
    }

    retourne résultat
}

ajoute_fonction :: fonc (module: &ModulePython, fonction: *NoeudCodeEntêteFonction)
{
    méthode := méthode_python_depuis_entête(fonction)
    tableau_ajoute(*module.méthodes, méthode)
}

génère_interface_python :: fonc (module: &ModulePython) -> chaine
{
    enchaineuse : Enchaineuse
    initialise_enchaineuse(*enchaineuse)
    diffère détruit_tampons(*enchaineuse)

    ajoute_au_tampon(*enchaineuse, "importe GlibC\n") // Pour ChaineC
    ajoute_au_tampon(*enchaineuse, "importe Fondation\n")
    ajoute_au_tampon(*enchaineuse, "importe Python\n")

    ajoute_au_tampon(*enchaineuse, "importe Courriel\n") // À FAIRE

    pour & module.types {
        génère_déclaration_type_python(*enchaineuse, module, it)
    }

    pour module.méthodes {
        génère_interface_fonction(*enchaineuse, it)
    }

    génère_initialisation_module(*enchaineuse, module)
    retourne chaine_depuis_enchaineuse(*enchaineuse)
}

protège_type_python :: fonc (enchaineuse: *Enchaineuse, variable: chaine, genre: GenreTypePython)
{
    discr genre {
        LONG {
            enchaineuse.ajoute_au_tampon("    saufsi PyLong_Check(", variable, ") {\n")
        }
        DOUBLE {
            enchaineuse.ajoute_au_tampon("    saufsi PyFloat_Check(", variable, ") {\n")
        }
        CHAINE {
            enchaineuse.ajoute_au_tampon("    saufsi PyUnicode_Check(", variable, ") {\n")
        }
        RIEN,
        OBJET,
        POINTEUR_QUELCONQUE {
            // À FAIRE
        }
    }
}

construit_type_python :: fonc (enchaineuse: *Enchaineuse, variable: chaine, genre: GenreTypePython)
{
    discr genre {
        LONG {
            enchaineuse.ajoute_au_tampon("PyLong_FromLong(", variable, ")")
        }
        DOUBLE {
            enchaineuse.ajoute_au_tampon("PyFloat_FromDouble(", variable, ")")
        }
        CHAINE {
            enchaineuse.ajoute_au_tampon("PyUnicode_DepuisChaine(", variable, ")")
        }
        RIEN {
            enchaineuse.ajoute_au_tampon("pythong_retourne_rien()")
        }
        OBJET,
        POINTEUR_QUELCONQUE {
            // À FAIRE
        }
    }
}

extrait_valeur_type_python :: fonc (enchaineuse: *Enchaineuse, variable: chaine, genre: GenreTypePython)
{
    discr genre {
        LONG {
            enchaineuse.ajoute_au_tampon("PyLong_AsLong(", variable, ")")
        }
        DOUBLE {
            enchaineuse.ajoute_au_tampon("PyFloat_AsDouble(", variable, ")")
        }
        CHAINE {
            enchaineuse.ajoute_au_tampon("python_extrait_chaine(", variable, ")")
        }
        RIEN {
        }
        OBJET,
        POINTEUR_QUELCONQUE {
            // À FAIRE
        }
    }
}

/* Génère les méthodes pour accéder et muter les membres du type. Retourne la globales où les méthodes sont initialisés. */
génère_méthodes_getset_pour_type :: fonc (enchaineuse: *Enchaineuse, type: &TypePython) -> chaine
{
    si type.confidentialité == ConfidentialitéType.OPAQUE {
        retourne copie_chaine("")
    }

    nombre_de_membres := type.type_kuri.membres.taille

    /* Déclare les fonctions get/set. */
    pour type.type_kuri.membres {
        genre_type_python_membre := genre_type_python_pour_info_type(it.id)

        // get : fonc (*PyObject, *rien)(*PyObject)

        enchaineuse.ajoute_au_tampon("get_", type.nom, "_", it.nom, " :: fonc (instance: *PyObject, closure: *rien@inutilisée) -> *PyObject #nulctx\n")
        enchaineuse.ajoute_au_tampon("{\n")
        enchaineuse.ajoute_au_tampon("    notre_instance := (instance comme *", type.nom, "PourPython).notre_instance\n")
        enchaineuse.ajoute_au_tampon("    membre := notre_instance.", it.nom, "\n")
        enchaineuse.ajoute_au_tampon("    retourne ")
        construit_type_python(enchaineuse, "membre", genre_type_python_membre)
        enchaineuse.ajoute_au_tampon("\n")
        enchaineuse.ajoute_au_tampon("}\n")

        si type.confidentialité == ConfidentialitéType.MUTABLE {
            // set : fonc (*PyObject, *PyObject, *rien)(z32)
            // retourne 0 pour un succès
            // retourne -1 pour une erreur
            enchaineuse.ajoute_au_tampon("get_", type.nom, "_", it.nom, " :: fonc (instance: *PyObject, valeur: *PyObject, closure: *rien@inutilisée) -> z32 #nulctx\n")
            enchaineuse.ajoute_au_tampon("{\n")

            protège_type_python(enchaineuse, "valeur", genre_type_python_membre)
            // À FAIRE : erreur -> attendu un objet de type "type attendu", obtenu un "type reçu"
            enchaineuse.ajoute_au_tampon("        retourne -1\n")
            enchaineuse.ajoute_au_tampon("    }\n")

            enchaineuse.ajoute_au_tampon("    notre_instance := *(instance comme *", type.nom, "PourPython).notre_instance\n")

            enchaineuse.ajoute_au_tampon("    notre_instance.", it.nom, " = ")
            extrait_valeur_type_python(enchaineuse, "valeur", genre_type_python_membre)
            enchaineuse.ajoute_au_tampon("    retourne 0\n")
            enchaineuse.ajoute_au_tampon("}\n")
        }
    }

    nom_globale := enchaine("getset_", type.nom)

    /* Déclare la globale, nous devons un élément supplémentaire à la fin. */
    enchaineuse.imprime_dans_enchaineuse("%: [%]PyGetSetDef\n", nom_globale, nombre_de_membres + 1)

    /* Défini la fonction d'initialisation de la globale */
    enchaineuse.ajoute_au_tampon("initialise_", nom_globale, " :: fonc ()\n")
    enchaineuse.ajoute_au_tampon("{\n")
    pour type.type_kuri.membres {
        enchaineuse.imprime_dans_enchaineuse("    %[%].name = crée_chaine_c(\"%\")\n", nom_globale, index_it, it.nom)
        enchaineuse.imprime_dans_enchaineuse("    %[%].get = get_%_%\n", nom_globale, index_it, type.nom, it.nom)
        si type.confidentialité == ConfidentialitéType.MUTABLE {
            enchaineuse.imprime_dans_enchaineuse("    %[%].set = set_%_%\n", nom_globale, index_it, type.nom, it.nom)
        }
        sinon {
            enchaineuse.imprime_dans_enchaineuse("    %[%].set = nul\n", nom_globale, index_it, type.nom, it.nom)
        }
        enchaineuse.imprime_dans_enchaineuse("    %[%].doc = ChaineC(nul)\n", nom_globale, index_it, it.nom)
        enchaineuse.imprime_dans_enchaineuse("    %[%].closure = nul\n", nom_globale, index_it, it.nom)
    }
    enchaineuse.imprime_dans_enchaineuse("    %[%].name = ChaineC(nul)\n", nom_globale, nombre_de_membres)
    enchaineuse.imprime_dans_enchaineuse("    %[%].get = nul\n", nom_globale, nombre_de_membres)
    enchaineuse.imprime_dans_enchaineuse("    %[%].set = nul\n", nom_globale, nombre_de_membres)
    enchaineuse.imprime_dans_enchaineuse("    %[%].doc = ChaineC(nul)\n", nom_globale, nombre_de_membres)
    enchaineuse.imprime_dans_enchaineuse("    %[%].closure = nul\n", nom_globale, nombre_de_membres)
    enchaineuse.ajoute_au_tampon("}\n")

    retourne nom_globale
}

génère_fonction_new :: fonc (enchaineuse: *Enchaineuse, type: &TypePython) -> chaine
{
    méthode := type.new

    saufsi méthode.nom {
        retourne copie_chaine("")
    }

    nom_fonction_new := enchaine("new_", type.nom)

    enchaineuse.ajoute_au_tampon(nom_fonction_new, " :: fonc (subtype: *PyTypeObject, args: *PyObject, kwds: *PyObject @inutilisée) -> *PyObject #nulctx\n")
    enchaineuse.ajoute_au_tampon("pousse_contexte __contexte_fil_principal {\n")

    /* Parse les arguments. */
    génère_parsage_args_tuple(enchaineuse, méthode, "nul")

    /* Appel la fonction d'initialisation. */
    génère_conversion_args_vers_kuri(enchaineuse, méthode)

    enchaineuse.ajoute_au_tampon("    résultat :", type.nom, "\n")
    enchaineuse.ajoute_au_tampon("    succès := ")
    génère_appel_méthode_kuri(enchaineuse, méthode, "*résultat")

    enchaineuse.ajoute_au_tampon("    saufsi succès {\n")
    enchaineuse.ajoute_au_tampon("        retourne nul\n")
    enchaineuse.ajoute_au_tampon("    }\n")

    /* Crée un objet python correspondant, et retourne. */
    enchaineuse.ajoute_au_tampon("    objet_résultat := subtype.tp_alloc(subtype, 1) comme *", type.nom, "PourPython\n")
    enchaineuse.ajoute_au_tampon("    objet_résultat.notre_instance = résultat\n")
    enchaineuse.ajoute_au_tampon("    retourne objet_résultat\n")
    enchaineuse.ajoute_au_tampon("}\n")

    retourne nom_fonction_new
}

génère_fonction_str :: fonc (enchaineuse: *Enchaineuse, type: &TypePython) -> chaine
{
    méthode := type.str

    saufsi méthode.nom {
        retourne copie_chaine("")
    }

    nom_fonction_str := enchaine("str_", type.nom)

    // doit retourner un PyUnicodeObject
    enchaineuse.ajoute_au_tampon(nom_fonction_str, ":: fonc (self: *PyObject) -> *PyObject #nulctx\n")
    enchaineuse.ajoute_au_tampon("pousse_contexte __contexte_fil_principal {\n")
    enchaineuse.ajoute_au_tampon("    notre_instance := (self comme *", type.nom, "PourPython).notre_instance\n")
    enchaineuse.ajoute_au_tampon("    résultat := ", méthode.nom, "(*notre_instance)\n")
    enchaineuse.ajoute_au_tampon("    retourne PyUnicode_DepuisChaine(résultat)\n")
    enchaineuse.ajoute_au_tampon("}\n")

    retourne nom_fonction_str
}

génère_fonction_repr :: fonc (enchaineuse: *Enchaineuse, type: &TypePython) -> chaine
{
    méthode := type.repr

    saufsi méthode.nom {
        retourne copie_chaine("")
    }

    nom_fonction_repr := enchaine("repr_", type.nom)

    // doit retourner un PyUnicodeObject
    enchaineuse.ajoute_au_tampon(nom_fonction_repr, ":: fonc (self: *PyObject) -> *PyObject #nulctx\n")
    enchaineuse.ajoute_au_tampon("pousse_contexte __contexte_fil_principal {\n")
    enchaineuse.ajoute_au_tampon("    notre_instance := (self comme *", type.nom, "PourPython).notre_instance\n")
    enchaineuse.ajoute_au_tampon("    résultat := ", méthode.nom, "(*notre_instance)\n")
    enchaineuse.ajoute_au_tampon("    résultat = enchaine(\"", type.nom, "('\", résultat, \"')\")\n")
    enchaineuse.ajoute_au_tampon("    retourne PyUnicode_DepuisChaine(résultat)\n")
    enchaineuse.ajoute_au_tampon("}\n")

    retourne nom_fonction_repr
}

génère_déclaration_type_python :: fonc (enchaineuse: *Enchaineuse, module: &ModulePython, type: &TypePython)
{
    /* Déclaration de la structure associée, dérivée de PyObject.
     * Pour une structure appelée « Structure », la version Python s'appelera « StructurePourPython ». */
    enchaineuse.ajoute_au_tampon(type.nom, "PourPython :: struct {\n")
    enchaineuse.ajoute_au_tampon("    empl base: PyObject\n")
    enchaineuse.ajoute_au_tampon("    notre_instance: ", type.nom, "\n")
    enchaineuse.ajoute_au_tampon("}\n")

    /* Déclaration de la globale qui servira pour contenir les données sur le type Python.
     * Cet objet s'appel « TypeStructurePourPython ». */
    nom_globale_type := enchaine("Type", type.nom, "PourPython")
    type.nom_globale_type = nom_globale_type
    enchaineuse.ajoute_au_tampon(nom_globale_type, ": PyTypeObject\n")

    /*
        À FAIRE : méthodes types
            __init__ pour les membres mutables
            méthodes diverses

            NomDuType.tp_flags = Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE;

     */

    globale_getset := génère_méthodes_getset_pour_type(enchaineuse, type)
    diffère déloge(globale_getset)

    fonction_new := génère_fonction_new(enchaineuse, type)
    diffère déloge(fonction_new)

    // À FAIRE __init__
    // fonction_init := génère_fonction_init(enchaineuse, type)
    // diffère déloge(fonction_init)

    fonction_str := génère_fonction_str(enchaineuse, type)
    diffère déloge(fonction_str)

    fonction_repr := génère_fonction_repr(enchaineuse, type)
    diffère déloge(fonction_repr)

    /* Définition de la fonction d'initialisation de la globale pour le type Python. */
    enchaineuse.ajoute_au_tampon("initialise_", nom_globale_type, " :: fonc () -> bool #nulctx\n")
    enchaineuse.ajoute_au_tampon("pousse_contexte __contexte_fil_principal {\n")

    /* Le nom requis pour Python, qui est de forme <module>.<nom>. */
    tp_name := enchaine(module.nom, ".", type.nom)
    diffère déloge(tp_name)

    enchaineuse.ajoute_au_tampon("    init_de(PyTypeObject)(*", nom_globale_type, ")\n")
    enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".ob_refcnt = 1\n")
    enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".ob_size = 0\n")
    enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".tp_basicsize = taille_de(", type.nom, ") comme Py_ssize_t\n")
    enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".tp_base = *PyBaseObject_Type\n")
    enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".tp_name = crée_chaine_c(\"", tp_name, "\")\n")
    enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".tp_flags = 1 << 10 | 1 << 18\n")

    si fonction_new {
        enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".tp_new = ", fonction_new, "\n")
    }

    si fonction_str {
        enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".tp_str = ", fonction_str, "\n")
    }

    si fonction_repr {
        enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".tp_repr = ", fonction_repr, "\n")
    }

    si globale_getset {
        enchaineuse.ajoute_au_tampon("    initialise_getset_", type.nom, "()\n")
        enchaineuse.ajoute_au_tampon("    ", nom_globale_type, ".tp_getset = *", globale_getset, "[0]\n")
    }

    enchaineuse.ajoute_au_tampon("    retourne PyType_Ready(*", nom_globale_type, ") != -1\n")
    enchaineuse.ajoute_au_tampon("}\n")
}

génère_code_pour_compilatrice :: fonc (module: &ModulePython, espace: *EspaceDeTravail)
{
    source := module.génère_interface_python()
    diffère déloge(source)
    ajoute_chaine_à_la_compilation(espace, source)
}

/* Extrait les paramètres des arguments passés à la fonction. Pour le moment ces arguments
 * ont des types conforment à Python. Le nom des arguments doit être "args". */
génère_parsage_args_tuple :: fonc (enchaineuse: *Enchaineuse, méthode: &MéthodePython, valeur_retour: chaine)
{
    saufsi méthode.paramètres_entrée {
        retourne
    }

    pour méthode.paramètres_entrée {
        chaine_type_python := chaine_pour_genre_type_python(it.type)
        enchaineuse.imprime_dans_enchaineuse("    pyobject_%: %\n", it.nom, chaine_type_python)
    }

    enchaineuse.ajoute_au_tampon("    saufsi PyArg_ParseTuple(args, crée_chaine_c(\"")
    pour méthode.paramètres_entrée {
        enchaineuse.ajoute_au_tampon(format_extraction_genre_type_python(it.type))
    }
    enchaineuse.ajoute_au_tampon("\")")
    virgule := ", "
    pour méthode.paramètres_entrée {
        enchaineuse.ajoute_au_tampon(virgule, "*pyobject_", it.nom)
    }
    enchaineuse.ajoute_au_tampon(") {\n")
    enchaineuse.ajoute_au_tampon("        retourne ", valeur_retour, "\n")
    enchaineuse.ajoute_au_tampon("    }\n")
}

/* Convertis les paramètres de fonction vers des objets de type Kuri natif (les types du programme). */
génère_conversion_args_vers_kuri :: fonc (enchaineuse: *Enchaineuse, méthode: &MéthodePython)
{
    saufsi méthode.paramètres_entrée {
        retourne
    }

    // À FAIRE : convertis les types python
    pour méthode.paramètres_entrée {
        enchaineuse.imprime_dans_enchaineuse("    %: ", it.nom)
        imprime_type(enchaineuse, it.type_kuri)

        si it.type == GenreTypePython.CHAINE {
            enchaineuse.ajoute_au_tampon(" = convertis_chaine_c(ChaineC(pyobject_", it.nom, "))\n")
        }
        sinon {
            enchaineuse.ajoute_au_tampon(" = pyobject_", it.nom, "\n")
        }
    }
}

// Génère l'expression d'appel pour le code Kuri de la méthode. La fonction appelante doit gérer la potentielle valeur de retour (nom, assignation, etc.).
génère_appel_méthode_kuri :: fonc (enchaineuse: *Enchaineuse, méthode: &MéthodePython, premier_paramètre_implicite: chaine = "")
{
    enchaineuse.ajoute_au_tampon(méthode.nom)
    virgule := "("
    si premier_paramètre_implicite  {
        enchaineuse.ajoute_au_tampon(virgule, premier_paramètre_implicite)
        virgule = ", "
    }
    sinon saufsi méthode.paramètres_entrée {
        enchaineuse.ajoute_au_tampon(virgule)
    }
    pour méthode.paramètres_entrée {
        enchaineuse.ajoute_au_tampon(virgule, it.nom)
        virgule = ", "
    }
    enchaineuse.ajoute_au_tampon(")\n")
}

génère_interface_fonction :: fonc (enchaineuse: *Enchaineuse, méthode: MéthodePython)
{
    // À FAIRE : conversion de type paramètres
    // À FAIRE : initialisation des variables globales de kuri

    // À FAIRE : self, pour les méthodes de module, c'est la méthode, pour le reste, c'est l'objet
    self_inutilisé := "@inutilisée"
    args_inutilisés := ""
    saufsi méthode.paramètres_entrée {
        args_inutilisés = "@inutilisée"
    }

    enchaineuse.imprime_dans_enchaineuse("enveloppe_python_% :: fonc (self: *PyObject%, args: *PyObject%) -> *PyObject #nulctx\n", méthode.nom, self_inutilisé, args_inutilisés)
    enchaineuse.ajoute_au_tampon("pousse_contexte __contexte_fil_principal {\n")

    génère_parsage_args_tuple(enchaineuse, méthode, "nul")
    génère_conversion_args_vers_kuri(enchaineuse, méthode)

    /* Appel la fonction. */
    possède_retour := !méthode.ne_retourne_rien()

    enchaineuse.ajoute_au_tampon("    ")
    si possède_retour {
        enchaineuse.ajoute_au_tampon("résultat := ")
    }

    génère_appel_méthode_kuri(enchaineuse, méthode)

    si possède_retour {
        enchaineuse.ajoute_au_tampon("    retourne PyLong_FromLong(résultat)\n")
    }
    sinon {
        enchaineuse.ajoute_au_tampon("    retourne python_retourne_rien()\n")
    }

    enchaineuse.ajoute_au_tampon("}\n")
}

génère_initialisation_module :: fonc (enchaineuse: *Enchaineuse, module: &ModulePython)
{
    /* Déclare le tableau de méthodes. Il y a une méthode supplémentaire nulle comme sentinelle. */
    enchaineuse.imprime_dans_enchaineuse("méthodes_du_module : [%]PyMethodDef\n", module.méthodes.taille + 1)

    /* Fonction d'initialisation pour les méthodes. */
    enchaineuse.ajoute_au_tampon("initialise_méthodes :: fonc () #nulctx\n")
    enchaineuse.ajoute_au_tampon("pousse_contexte __contexte_fil_principal {\n")

    pour module.méthodes {
        enchaineuse.imprime_dans_enchaineuse("    méthodes_du_module[%].ml_name = crée_chaine_c(\"%\")\n", index_it, it.nom)
        enchaineuse.imprime_dans_enchaineuse("    méthodes_du_module[%].ml_meth = enveloppe_python_%\n", index_it, it.nom)

        drapeaux_méthode := ""
        si it.paramètres_entrée {
            drapeaux_méthode = "METH_VARARGS"
        }
        sinon {
            drapeaux_méthode = "METH_NOARGS"
        }

        enchaineuse.imprime_dans_enchaineuse("    méthodes_du_module[%].ml_flag = %\n", index_it, drapeaux_méthode)
        enchaineuse.imprime_dans_enchaineuse("    méthodes_du_module[%].ml_doc = ChaineC(nul)\n", index_it)
    }

    /* Sentienelle */
    index_it_ := module.méthodes.taille
    enchaineuse.imprime_dans_enchaineuse("    méthodes_du_module[%].ml_name = ChaineC(nul)\n", index_it_)
    enchaineuse.imprime_dans_enchaineuse("    méthodes_du_module[%].ml_meth = nul\n", index_it_)
    enchaineuse.imprime_dans_enchaineuse("    méthodes_du_module[%].ml_flag = 0\n", index_it_)
    enchaineuse.imprime_dans_enchaineuse("    méthodes_du_module[%].ml_doc = ChaineC(nul)\n", index_it_)

    enchaineuse.ajoute_au_tampon("}\n")

    /* Déclaration de la globale pour la définition du module. */
    enchaineuse.ajoute_au_tampon("définition_module: PyModuleDef\n")

    /* Fonction d'initialisation pour la définition du module. */
    enchaineuse.ajoute_au_tampon("initialise_définition_module :: fonc () #nulctx\n")
    enchaineuse.ajoute_au_tampon("pousse_contexte __contexte_fil_principal {\n")
    enchaineuse.imprime_dans_enchaineuse("    définition_module.m_name = crée_chaine_c(\"%\")\n", module.nom)
    enchaineuse.ajoute_au_tampon("    définition_module.m_doc = ChaineC(nul)\n")
    enchaineuse.ajoute_au_tampon("    définition_module.m_size = -1\n")
    enchaineuse.ajoute_au_tampon("    définition_module.m_methods = *méthodes_du_module[0]\n")
    enchaineuse.ajoute_au_tampon("    définition_module.m_slots = nul\n")
    enchaineuse.ajoute_au_tampon("    définition_module.m_traverse = nul\n")
    enchaineuse.ajoute_au_tampon("    définition_module.m_clear = nul\n")
    enchaineuse.ajoute_au_tampon("    définition_module.m_free = nul\n")
    enchaineuse.ajoute_au_tampon("}\n")

    /* La fonction d'initialisation du module doit avoir la signature : PyInit_nom_module :: fonc () -> *PyObject */
    enchaineuse.imprime_dans_enchaineuse("PyInit_% :: fonc () -> *PyObject #nulctx #racine #sansbroyage\n", module.nom)
    enchaineuse.ajoute_au_tampon("{\n")

    /* Nous devons tout d'abord initialiser le contexte. */
    code_initialisation_contexte := «
    init_de(ContexteProgramme)(*__contexte_fil_principal)
    info_trace_appel := InfoFonctionTraceAppel(nom = "PyInit", fichier = "", adresse = nul)
    trace_appel := TraceAppel(info_fonction = *info_trace_appel)

    base_allocatrice : BaseAllocatrice
    stockage_temporaire : StockageTemporaire = ---

    __initialise_contexte_extra(*__contexte_fil_principal, *trace_appel, *base_allocatrice, *stockage_temporaire)»

    enchaineuse.ajoute_au_tampon(code_initialisation_contexte, "\n")

    // À FAIRE : supprimer ceci quand les globales seront proprement initialisées
    enchaineuse.ajoute_au_tampon("    Py_None = *_Py_NoneStruct\n")
    enchaineuse.ajoute_au_tampon("    Py_True = *_Py_TrueStruct\n")
    enchaineuse.ajoute_au_tampon("    Py_False = *_Py_FalseStruct\n")
    enchaineuse.ajoute_au_tampon("    initialise_méthodes()\n")
    enchaineuse.ajoute_au_tampon("    initialise_définition_module()\n")

    enchaineuse.ajoute_au_tampon("    module_pyobject := PyModule_Create2(*définition_module, PYTHON_API_VERSION)\n")

    pour module.constantes_nombre_entier {
        enchaineuse.imprime_dans_enchaineuse("    si PyModule_AddIntConstant(module_pyobject, crée_chaine_c(\"%\"), %) == -1 {\n", it.nom, it.valeur)
        enchaineuse.ajoute_au_tampon("        retourne python_retourne_rien()\n")
        enchaineuse.ajoute_au_tampon("    }\n")
    }

    pour module.constantes_chaine {
        enchaineuse.imprime_dans_enchaineuse("    si PyModule_AddStringConstant(module_pyobject, crée_chaine_c(\"%\"), crée_chaine_c(\"%\")) == -1 {\n", it.nom, it.valeur)
        enchaineuse.ajoute_au_tampon("        retourne python_retourne_rien()\n")
        enchaineuse.ajoute_au_tampon("    }\n")
    }

    pour module.types {
        enchaineuse.ajoute_au_tampon("    saufsi initialise_", it.nom_globale_type, "() {\n")
        enchaineuse.ajoute_au_tampon("        Py_DECREF(module_pyobject)\n")
        enchaineuse.ajoute_au_tampon("        retourne python_retourne_rien()\n")
        enchaineuse.ajoute_au_tampon("    }\n")
        enchaineuse.ajoute_au_tampon("    Py_INCREF(*", it.nom_globale_type, ")\n")
        // crée_chaine_c requiers un contexte
        enchaineuse.ajoute_au_tampon("    PyModule_AddObject(module_pyobject, ChaineC(\"", it.nom, "\\0\".pointeur), *", it.nom_globale_type, ")\n")
    }

    enchaineuse.ajoute_au_tampon("    retourne module_pyobject\n")
    enchaineuse.ajoute_au_tampon("}\n")
}
