/*

Génération de code Kuri pour créer un module Python depuis du code Kuri.

*/

importe Compilatrice
importe Fondation
importe SysFichier

// À FAIRE : gère proprement les chaines, les chaines C ne sont jamais détruites !

ModulePython :: struct {
    nom: chaine
    méthodes : []MéthodePython
    constantes_nombre_entier : []ConstanteNombreEntier
    constantes_chaine : []ConstanteChaine
    types: []TypePython
}

ConfidentialitéType :: énum {
    /* Les membres du type peuvent être accédés. */
    ACCESSIBLE
    /* Les membres du type peuvent être mutés, ceci implique qu'ils sont également ACCESSIBLE. */
    MUTABLE
    /* Les membres du type ne sont pas ni accessible, ni mutable. */
    OPAQUE
}

TypePython :: struct {
    nom: chaine
    type_kuri: *InfoTypeStructure

    confidentialité: ConfidentialitéType

    méthodes: []MéthodePython

    new: MéthodePython
    init: MéthodePython
    repr: MéthodePython
    str: MéthodePython

    /* Données pour la génération de code, mises en place lors de celle-ci. */

    /* Le nom de la globale qui défini les informations sur le PyTypeObject correspondant. */
    nom_globale_type: chaine
}

ajoute_type :: fonc (module: &ModulePython, type_kuri: *InfoTypeStructure, confidentialité: ConfidentialitéType)
{
    pour module.types {
        si it.type_kuri == type_kuri {
            // À FAIRE : vérifie la confidentialité.
            retourne
        }
    }

    type := TypePython()
    type.nom = type_kuri.nom
    type.type_kuri = type_kuri
    type.confidentialité = confidentialité

    tableau_ajoute(*module.types, type)
}

type_python_pour :: fonc (module: &ModulePython, info: *InfoTypeStructure) -> *TypePython
{
    pour * module.types {
        si it.type_kuri == info {
            retourne it
        }
    }

    retourne nul
}

ajoute_méthode :: fonc (type: &TypePython, fonction: *NoeudCodeEntêteFonction)
{
    méthode := méthode_python_depuis_entête(fonction)
    tableau_ajoute(*type.méthodes, méthode)
}

ajoute_méthode_new :: fonc (type: *TypePython, fonction: *NoeudCodeEntêteFonction)
{
    type.new = méthode_python_depuis_entête(fonction, vrai)
}

ajoute_méthode_init :: fonc (type: *TypePython, fonction: *NoeudCodeEntêteFonction)
{
    type.init = méthode_python_depuis_entête(fonction, vrai)
}

ajoute_méthode_repr :: fonc (type: *TypePython, fonction: *NoeudCodeEntêteFonction)
{
    type.repr = méthode_python_depuis_entête(fonction)
}

ajoute_méthode_str :: fonc (type: *TypePython, fonction: *NoeudCodeEntêteFonction)
{
    type.str = méthode_python_depuis_entête(fonction)
}

ConstanteNombreEntier :: struct {
    nom: chaine
    valeur: z64
}

ConstanteChaine :: struct {
    nom: chaine
    valeur: chaine
}

ajoute_constante_nombre_entier :: fonc (module: &ModulePython, nom: chaine, valeur: z64)
{
    tableau_ajoute(*module.constantes_nombre_entier, ConstanteNombreEntier(nom, valeur))
}

ajoute_constante_chaine :: fonc (module: &ModulePython, nom: chaine, valeur: chaine)
{
    tableau_ajoute(*module.constantes_chaine, ConstanteChaine(nom, valeur))
}

GenreTypePython :: énum {
    /* Un nombre entier. */
    LONG
    /* Un nombre décimal. */
    DOUBLE
    /* Un PyObject */
    OBJET
    /* Une chaine, qui devrat être convertis depuis et vers Python. */
    CHAINE
    /* Pour None. */
    RIEN
    /* Ceci est pour les objets que nous allouons sur la pile, et que l'on via PyLong_AsVoidPtr, etc. */
    POINTEUR_QUELCONQUE
}

genre_type_python_pour_info_type :: fonc (info: *InfoType) -> GenreTypePython
{
    discr info.id {
        ENTIER {
            retourne GenreTypePython.LONG
        }
        RÉEL {
            retourne GenreTypePython.DOUBLE
        }
        CHAINE {
            retourne GenreTypePython.CHAINE
        }
        RIEN {
            retourne GenreTypePython.RIEN
        }
        sinon {
            retourne GenreTypePython.POINTEUR_QUELCONQUE
        }
    }
}

ParamètreMéthodePython :: struct {
    nom: chaine
    type: GenreTypePython
    type_kuri: *InfoType
}

MéthodePython :: struct {
    nom: chaine
    paramètres_entrée: []ParamètreMéthodePython
    paramètres_sortie: []ParamètreMéthodePython
}

ne_retourne_rien :: fonc (méthode: &MéthodePython) -> bool
{
    saufsi méthode.paramètres_sortie {
        retourne vrai
    }

    premier_param := méthode.paramètres_sortie[0]
    retourne méthode.paramètres_sortie.taille == 1 && premier_param.type == GenreTypePython.RIEN
}

convertis_paramètre :: fonc (param: *NoeudCode) -> ParamètreMéthodePython
{
    résultat: ParamètreMéthodePython
    résultat.nom = param.nom
    résultat.type_kuri = param.type
    résultat.type = genre_type_python_pour_info_type(param.type)
    retourne résultat
}

// ignore_premier_paramètre_après_contexte est pour les fonctions d'allocation, etc.,
// qui doivent prendre un paramètre du type dans kuri, mais qui peuvent ne pas prendre
// l'objet en paramètre dans Python.
méthode_python_depuis_entête :: fonc (entête: *NoeudCodeEntêteFonction, ignore_premier_paramètre_après_contexte := faux) -> MéthodePython
{
    résultat: MéthodePython
    résultat.nom = entête.nom

    après_contexte := vrai

    pour entête.params {
        /* Ignore le contexte implicite, seuls les vrais paramètres devraient être convertis. */
        si it.type == info_de(ContexteProgramme) {
            après_contexte = vrai
            continue
        }

        si après_contexte && ignore_premier_paramètre_après_contexte {
            après_contexte = faux
            continue
        }

        param := convertis_paramètre(it)
        tableau_ajoute(*résultat.paramètres_entrée, param)
    }

    pour entête.params_sorties {
        param := convertis_paramètre(it)
        tableau_ajoute(*résultat.paramètres_sortie, param)
    }

    retourne résultat
}

ajoute_fonction :: fonc (module: &ModulePython, fonction: *NoeudCodeEntêteFonction)
{
    méthode := méthode_python_depuis_entête(fonction)
    tableau_ajoute(*module.méthodes, méthode)
}
