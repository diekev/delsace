/*

Génération de code Kuri pour créer un module Python depuis du code Kuri.

*/

importe Compilatrice
importe Fondation
importe SysFichier

// À FAIRE : gère proprement les chaines, les chaines C ne sont jamais détruites !

ModulePython :: struct {
    nom: chaine
    méthodes : []MéthodePython
    constantes_nombre_entier : []ConstanteNombreEntier
    constantes_chaine : []ConstanteChaine
}

ConstanteNombreEntier :: struct {
    nom: chaine
    valeur: z64
}

ConstanteChaine :: struct {
    nom: chaine
    valeur: chaine
}

ajoute_constante_nombre_entier :: fonc (module: &ModulePython, nom: chaine, valeur: z64)
{
    tableau_ajoute(*module.constantes_nombre_entier, ConstanteNombreEntier(nom, valeur))
}

ajoute_constante_chaine :: fonc (module: &ModulePython, nom: chaine, valeur: chaine)
{
    tableau_ajoute(*module.constantes_chaine, ConstanteChaine(nom, valeur))
}

ParamètreMéthodePython :: struct {
    nom: chaine
    type: *TypePython
    /* Les types Python n'ont pas d'information sur s'ils sont pointeur ou non.
     * Par défaut, nous stockons une instance de notre type par valeur dans le
     * PyObject que nous créons pour notre type (sauf si TOUJOURS_COMME_POINTEUR
     * est vrai). Ceci nous sers à déterminer, lors des appels de nos fonctions,
     * si nous devrions passer la valeur par pointeur ou par valeur. */
    param_originel_est_pointeur: bool
}

MéthodePython :: struct {
    nom: chaine
    /* Nom unique pour éviter les problèmes de redéfinition de fonction. */
    nom_enveloppe: chaine
    paramètres_entrée: []ParamètreMéthodePython
    paramètres_sortie: []ParamètreMéthodePython
}

ne_retourne_rien :: fonc (méthode: &MéthodePython) -> bool
{
    saufsi méthode.paramètres_sortie {
        retourne vrai
    }

    premier_param := méthode.paramètres_sortie[0]
    retourne méthode.paramètres_sortie.taille == 1 && premier_param.type == nul
}

convertis_paramètre :: fonc (param: *NoeudCode, système_type: &SystèmeType) -> ParamètreMéthodePython
{
    résultat: ParamètreMéthodePython
    résultat.nom = param.nom
    résultat.type = système_type.convertis_vers_type_python(param.type)
    résultat.param_originel_est_pointeur = param.type.id == id_info.POINTEUR
    retourne résultat
}

// ignore_premier_paramètre est pour les fonctions d'allocation, etc.
méthode_python_depuis_entête :: fonc (entête: *NoeudCodeEntêteFonction, système_type: &SystèmeType, ignore_premier_paramètre := faux) -> MéthodePython
{
    résultat: MéthodePython
    résultat.nom = entête.nom
    résultat.nom_enveloppe = imprime_chaine("enveloppe_python_%%", entête.nom, entête)

    pour entête.params {
        si index_it == 0 && ignore_premier_paramètre {
            continue
        }

        param := convertis_paramètre(it, système_type)
        tableau_ajoute(*résultat.paramètres_entrée, param)
    }

    pour entête.params_sorties {
        param := convertis_paramètre(it, système_type)
        tableau_ajoute(*résultat.paramètres_sortie, param)
    }

    retourne résultat
}

ajoute_fonction :: fonc (module: &ModulePython, système_type: &SystèmeType, fonction: *NoeudCodeEntêteFonction)
{
    méthode := méthode_python_depuis_entête(fonction, système_type)
    tableau_ajoute(*module.méthodes, méthode)
}

// ---------------------------------------------------

/* Pour chaque type Python, nous enregistrons certaines fonctions permettant de les convertir ou discriminer. */
FonctionsTypePython :: struct {
    pour_discrimination: chaine // PyLong_Check, etc.
    pour_extraction_valeur: chaine // PyLong_AsLong, etc.
    pour_construction: chaine // PyLong_FromLong, etc.
}

/* Entiers relatifs. */

init_fonctions_type_z8 :: fonc (fonctions: &FonctionsTypePython)
{
    fonctions.pour_discrimination = copie_chaine("PyLong_Check")
    fonctions.pour_extraction_valeur = copie_chaine("PyLong_AsZ8")
    fonctions.pour_construction = copie_chaine("PyLong_FromLong")
}

init_fonctions_type_z16 :: fonc (fonctions: &FonctionsTypePython)
{
    fonctions.pour_discrimination = copie_chaine("PyLong_Check")
    fonctions.pour_extraction_valeur = copie_chaine("PyLong_AsZ16")
    fonctions.pour_construction = copie_chaine("PyLong_FromLong")
}

init_fonctions_type_z32 :: fonc (fonctions: &FonctionsTypePython)
{
    fonctions.pour_discrimination = copie_chaine("PyLong_Check")
    fonctions.pour_extraction_valeur = copie_chaine("PyLong_AsZ32")
    fonctions.pour_construction = copie_chaine("PyLong_FromLong")
}

init_fonctions_type_z64 :: fonc (fonctions: &FonctionsTypePython)
{
    fonctions.pour_discrimination = copie_chaine("PyLong_Check")
    fonctions.pour_extraction_valeur = copie_chaine("PyLong_AsLong")
    fonctions.pour_construction = copie_chaine("PyLong_FromLong")
}

/* Entiers naturels. */

init_fonctions_type_n8 :: fonc (fonctions: &FonctionsTypePython)
{
    fonctions.pour_discrimination = copie_chaine("PyLong_Check")
    fonctions.pour_extraction_valeur = copie_chaine("PyLong_AsN8")
    fonctions.pour_construction = copie_chaine("PyLong_FromN8")
}

init_fonctions_type_n16 :: fonc (fonctions: &FonctionsTypePython)
{
    fonctions.pour_discrimination = copie_chaine("PyLong_Check")
    fonctions.pour_extraction_valeur = copie_chaine("PyLong_AsN16")
    fonctions.pour_construction = copie_chaine("PyLong_FromN16")
}

init_fonctions_type_n32 :: fonc (fonctions: &FonctionsTypePython)
{
    fonctions.pour_discrimination = copie_chaine("PyLong_Check")
    fonctions.pour_extraction_valeur = copie_chaine("PyLong_AsN32")
    fonctions.pour_construction = copie_chaine("PyLong_FromN32")
}

init_fonctions_type_n64 :: fonc (fonctions: &FonctionsTypePython)
{
    fonctions.pour_discrimination = copie_chaine("PyLong_Check")
    fonctions.pour_extraction_valeur = copie_chaine("PyLong_AsN64")
    fonctions.pour_construction = copie_chaine("PyLong_FromN64")
}

/* Booléen. */

init_fonctions_type_bool :: fonc (fonctions: &FonctionsTypePython)
{
    fonctions.pour_discrimination = copie_chaine("PyBool_Check")
    fonctions.pour_extraction_valeur = copie_chaine("PyBool_AsBool")
    fonctions.pour_construction = copie_chaine("PyBool_FromBool")
}

/* Réel. */

init_fonctions_type_r16 :: fonc (fonctions: &FonctionsTypePython)
{
    fonctions.pour_discrimination = copie_chaine("PyFloat_Check")
    fonctions.pour_extraction_valeur = copie_chaine("PyFloat_AsR16")
    fonctions.pour_construction = copie_chaine("PyFloat_FromDouble")
}

init_fonctions_type_r32 :: fonc (fonctions: &FonctionsTypePython)
{
    fonctions.pour_discrimination = copie_chaine("PyFloat_Check")
    fonctions.pour_extraction_valeur = copie_chaine("PyFloat_AsR32")
    fonctions.pour_construction = copie_chaine("PyFloat_FromDouble")
}

init_fonctions_type_r64 :: fonc (fonctions: &FonctionsTypePython)
{
    fonctions.pour_discrimination = copie_chaine("PyFloat_Check")
    fonctions.pour_extraction_valeur = copie_chaine("PyFloat_AsDouble")
    fonctions.pour_construction = copie_chaine("PyFloat_FromDouble")
}

/* Chaine. */

init_fonctions_type_chaine :: fonc (fonctions: &FonctionsTypePython)
{
    fonctions.pour_discrimination = copie_chaine("PyUnicode_Check")
    fonctions.pour_extraction_valeur = copie_chaine("PyUnicode_AsChaine")
    fonctions.pour_construction = copie_chaine("PyUnicode_FromChaine")
}

/* Structures, unions, énums, etc. */

init_fonctions_type_structure :: fonc (fonctions: &FonctionsTypePython, nom: chaine)
{
    fonctions.pour_discrimination = enchaine("Py", nom, "_Check")
    fonctions.pour_extraction_valeur = enchaine("Py", nom, "_As", nom)
    fonctions.pour_construction = enchaine("Py", nom, "_From", nom)
}

// ---------------------------------------------------

ConfidentialitéType :: énum {
    /* Les membres du type peuvent être accédés. */
    ACCESSIBLE
    /* Les membres du type peuvent être mutés, ceci implique qu'ils sont également ACCESSIBLE. */
    MUTABLE
    /* Les membres du type ne sont pas ni accessible, ni mutable. */
    OPAQUE
}

confidentialité_pour_annotation :: fonc (annotations: []*AnnotationCode) -> ConfidentialitéType
{
    pour annotations {
        si it.nom == "privé" {
            retourne ConfidentialitéType.OPAQUE
        }

        si it.nom == "mutable" {
            retourne ConfidentialitéType.MUTABLE
        }

        si it.nom == "accessible" {
            retourne ConfidentialitéType.ACCESSIBLE
        }
    }

    /* Par défaut, les membres sont opaques. */
    retourne ConfidentialitéType.OPAQUE
}

MembreType :: struct {
    nom: chaine
    confidentialité: ConfidentialitéType
    type: *TypePython
}

DrapeauxType :: énum_drapeau {
    TYPE_EST_UNION
    TYPE_EST_ÉNUM
    TYPE_EST_TABLEAU
    TYPE_EST_ITÉRATEUR
    /* Indique qu'un pointeur est stocké dans le membre "notre_instance" du type Python. */
    TOUJOURS_COMME_POINTEUR
    /* Pour les types composés, le programme devra définir une fonction de rafinage
     * appelée « rafine_type_{nom_du_type}. */
    REQUIERS_RAFINAGE
}

TypePython :: struct {
    nom: chaine
    type_kuri: *InfoType

    nom_type_kuri: chaine

    /* Si le type est un type de base, qui ne doit avoir un PyTypeObject associé. */
    est_basique: bool

    drapeaux: DrapeauxType

    fonctions : FonctionsTypePython

    confidentialité: ConfidentialitéType

    membres: []MembreType

    méthodes: []MéthodePython

    new: MéthodePython
    init: MéthodePython
    repr: MéthodePython
    str: MéthodePython

    /* Données pour la génération de code, mises en place lors de celle-ci. */

    /* Le nom de la globale qui défini les informations sur le PyTypeObject correspondant. */
    nom_globale_type: chaine

    /* Type de base du type. */
    base: *TypePython

    /* Type des éléments pour les tableaux. */
    type_élément: *TypePython

    /* Type de l'objet itéré pour les itérateurs. */
    type_itéré: *TypePython
    type_itérateur: *TypePython

    /* Interne, pour généré le code d'initialisation des types dans l'ordre d'héritage. */
    code_pour_init_module_fut_généré: bool
}

ajoute_méthode :: fonc (type: *TypePython, système_type: &SystèmeType, fonction: *NoeudCodeEntêteFonction)
{
    méthode := méthode_python_depuis_entête(fonction, système_type, vrai)
    tableau_ajoute(*type.méthodes, méthode)
}

ajoute_méthode_new :: fonc (type: *TypePython, système_type: &SystèmeType, fonction: *NoeudCodeEntêteFonction)
{
    type.new = méthode_python_depuis_entête(fonction, système_type, vrai)
}

ajoute_méthode_init :: fonc (type: *TypePython, système_type: &SystèmeType, fonction: *NoeudCodeEntêteFonction)
{
    type.init = méthode_python_depuis_entête(fonction, système_type, vrai)
}

ajoute_méthode_repr :: fonc (type: *TypePython, système_type: &SystèmeType, fonction: *NoeudCodeEntêteFonction)
{
    type.repr = méthode_python_depuis_entête(fonction, système_type)
}

ajoute_méthode_str :: fonc (type: *TypePython, système_type: &SystèmeType, fonction: *NoeudCodeEntêteFonction)
{
    type.str = méthode_python_depuis_entête(fonction, système_type)
}
