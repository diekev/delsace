
/* Une chaine internée est une chaine qui n'existe qu'en un seul exemplaire dans
 * le programme, ceci nous permet de ne faire qu'une comparaison de pointeur au
 * lieu d'une comparaison de chaine complète. */

importe Fondation

/* Le type de chaine qui sera interné. Ceci utilise la sémantique de valeur, ainsi deux chaines de types
 * différents (p.e. chaine et ChaineUTF32) qui possède les mêmes points de code dans un codec commun ne
 * seront internées qu'une seule fois. */
TypeChaineInternée :: union {
    chn_native: chaine
    chn_utf32: ChaineUTF32
}

détruit_chaine :: fonc (type_chaine: TypeChaineInternée)
{
    discr type_chaine {
        chn_native {
            déloge(type_chaine.chn_native)
        }
        chn_utf32 {
            détruit_chaine(type_chaine.chn_utf32)
        }
    }
}

opérateur == :: fonc (type_chaine: TypeChaineInternée, chn: chaine) -> bool
{
    discr type_chaine {
        chn_native {
            retourne type_chaine.chn_native == chn
        }
        chn_utf32 {
            retourne type_chaine.chn_utf32 == chn
        }
    }

    retourne faux
}

opérateur == :: fonc (type_chaine: TypeChaineInternée, chn: ChaineUTF32) -> bool
{
    discr type_chaine {
        chn_native {
            retourne type_chaine.chn_native == chn
        }
        chn_utf32 {
            retourne type_chaine.chn_utf32 == chn
        }
    }

    retourne faux
}

ChaineInternée :: struct {
    chn: TypeChaineInternée
}

opérateur == :: fonc (chaine_internée: *ChaineInternée, chn: chaine) -> bool
{
    si chaine_internée == nul {
        retourne chn == ""
    }

    retourne chaine_internée.chn == chn
}

opérateur != :: fonc (chaine_internée: *ChaineInternée, chn: chaine) -> bool
{
    retourne !(chaine_internée == chn)
}

opérateur == :: fonc (chaine_internée: *ChaineInternée, chn: ChaineUTF32) -> bool
{
    si chaine_internée == nul {
        retourne chn.est_vide()
    }

    retourne chaine_internée.chn == chn
}

opérateur != :: fonc (chaine_internée: *ChaineInternée, chn: ChaineUTF32) -> bool
{
    retourne !(chaine_internée == chn)
}

opérateur < :: fonc (chaine_internée: *ChaineInternée, chn: chaine) -> bool
{
    retourne chaine_internée.chn < chn
}

opérateur > :: fonc (chaine_internée: *ChaineInternée, chn: chaine) -> bool
{
    si chaine_internée == nul {
        retourne faux
    }

    retourne chaine_internée.chn > chn
}

table_des_chaines : []*ChaineInternée

crée_chaine_internée :: fonc (chn: $T) -> *ChaineInternée
{
    chaine_existante := trouve_chaine_internée(chn)

    saufsi chaine_existante {
        nouvelle_chaine := loge(ChaineInternée)
        nouvelle_chaine.chn = copie_chaine(chn)

        tableau_ajoute(*table_des_chaines, nouvelle_chaine)
        chaine_existante = nouvelle_chaine
    }

    retourne chaine_existante
}

trouve_chaine_internée :: fonc (chn: $T) -> *ChaineInternée
{
    pour table_des_chaines {
        si it.chn == chn {
            retourne it
        }
    }

    retourne nul
}

détruit_chaines_internées :: fonc ()
{
    pour table_des_chaines {
        détruit_chaine(it.chn)
        déloge(it)
    }

    déloge(table_des_chaines)
}
