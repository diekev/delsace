// Interface pour le module C Aléa

importe Alphabet
importe Fondation
importe Introspection
importe Math // nous dépendons sur libm.so pour le moment

charge "interface_aléa"

charge "halton"

// À FAIRE : ce serait bien de le définir lors de la génération du code
#dépendance_bibliothèque libaléa libcmath

crée_gna :: fonc (ctx_kuri : *ContexteKuri, graine: n32) -> *GNA
{
    retourne ALEA_cree_gna(ctx_kuri, graine)
}

resème :: fonc (gna: *GNA, graine: n32) -> rien
{
    ALEA_reseme_gna(gna, graine)
}

détruit_gna :: fonc (ctx_kuri : *ContexteKuri, gna: *GNA) -> rien
{
    ALEA_detruit_gna(ctx_kuri, gna)
}

uniforme :: fonc (gna: *GNA, min: r32, max: r32) -> r32
{
    retourne ALEA_uniforme_r32(gna, min, max)
}

uniforme :: fonc (gna: *GNA, min: r64, max: r64) -> r64
{
    retourne ALEA_uniforme_r64(gna, min, max)
}

normale :: fonc (gna: *GNA, moyenne: r32, écart: r32) -> r32
{
    retourne ALEA_normale_r32(gna, moyenne, écart)
}

normale :: fonc (gna: *GNA, moyenne: r64, écart: r64) -> r64
{
    retourne ALEA_normale_r64(gna, moyenne, écart)
}

// ------------------------------------------------------

choisit :: fonc (gna: *GNA, tableau: []$T) -> T
{
    saufsi tableau {
        valeur_défaut: T
        retourne valeur_défaut
    }

    index_r32 := gna.uniforme(0 comme r32, (tableau.taille) comme r32)
    index := index_r32 comme z64
    retourne tableau[index]
}

mélange_tableau :: fonc (gna: *GNA, tableau: *[]$T)
{
    pour tableau.taille {
        nouvel_index := gna.uniforme(0.0, (tableau.taille - 1) comme r32) comme z64

        si nouvel_index == index_it {
            continue
        }

        tmp := tableau.pointeur[index_it]
        tableau.pointeur[index_it] = tableau.pointeur[nouvel_index]
        tableau.pointeur[nouvel_index] = tmp
    }
}

// ------------------------------------------------------

// À FAIRE: #portée_fichier
// À FAIRE: système pour ajouter dans init_execution_kuri, termine_execution_kuri
fonctions_génération_données_aléatoires : []FonctionInstrospection(fonc(&GénératriceDonnéesAléatoire, eini)(rien))

ajoute_fonction_génération_données_aléatoires :: fonc (info: *InfoType, fonction: fonc(&GénératriceDonnéesAléatoire, eini)(rien))
{
    ajoute_fonction(*fonctions_génération_données_aléatoires, info, fonction)
}

trouve_fonction_génération_données_aléatoires :: fonc (info: *InfoType) -> *FonctionInstrospection(fonc(&GénératriceDonnéesAléatoire, eini)(rien))
{
    retourne trouve_fonction_pour_type(fonctions_génération_données_aléatoires, info)
}

// ------------------------------------------------------

GénératriceDonnéesAléatoire :: struct {
    gna: *GNA
    taille_min_chaine := 1
    taille_max_chaine := 32
}

génère_données_aléatoires :: fonc (génératrice: &GénératriceDonnéesAléatoire, $T: type_de_données) -> T
{
    #assert info_de(T).id == id_info.STRUCTURE

    résultat : T

    info := info_de(T)

    pour info.membres {
        fonction_parsage := trouve_fonction_génération_données_aléatoires(it.id)

        saufsi fonction_parsage {
            continue
        }

        tampon : []octet
        tampon.pointeur = (*résultat comme *z8 + it.décalage)
        tampon.taille = it.id.taille_en_octet comme z64

        // fonction_parsage.rappel ajournera le ptr_résultat via le tampon
        fonction_parsage.fonction(génératrice, tampon)
    }

    retourne résultat
}

// ------------------------------------------------------

chaine_aléatoire :: fonc (gna: *GNA, alphabet: &Alphabet.Alphabet, taille_min: z32, taille_max: z32) -> chaine
{
    nombre_de_caractères := alphabet.taille_alphabet()

    min_r32 := 0.0
    max_r32 := (nombre_de_caractères - 1) comme r32

    taille := gna.uniforme(taille_min comme r32, taille_max comme r32) comme z32

    résultat : chaine

    pour i dans 0 ... taille - 1 {
        index_r32 := gna.uniforme(min_r32, max_r32)
        index_z32 := index_r32 comme z32
        caractère := alphabet.caractère_pour_index(index_z32)

        chaine_ajoute(*résultat, caractère)
    }

    retourne résultat
}

génère_chaine_aléatoire :: fonc (génératrice: &GénératriceDonnéesAléatoire) -> chaine
{
    alphabet := crée_alphabet_ascii_pour_nom()
    diffère détruit_alphabet(alphabet)
    résultat := chaine_aléatoire(génératrice.gna, alphabet, génératrice.taille_min_chaine, génératrice.taille_max_chaine)
    retourne résultat
}

rappel_génère_chaine_aléatoire :: fonc (génératrice: &GénératriceDonnéesAléatoire, valeur: eini)
{
    résultat := génère_chaine_aléatoire(génératrice)
    ptr := mémoire(valeur.pointeur comme **chaine)
    mémoire(ptr) = résultat
}
/*

SérieAléatoire :: struct {
    état: n32
}

graine_aléatoire :: fonc (graine: n32) -> SérieAléatoire
{

}

aléatoire :: fonc (série: &SérieAléatoire, min: $T, max: T)
{

}

aléatoire_suivant :: fonc (série: &SérieAléatoire)
{

}

aléatoire_unilatéral :: fonc () // entre 0.0 et 1.0
aléatoire_bilatéral :: fonc () // entre -1.0 et 1.0

entropie := graine_aléatoire(1234)

entropie.aléatoire_suivant()

entropie.aléatoire_entre(z32, 0, 1)

entropie.énum_aléatoire(TypeEnum)

 */


// -------------------------------------------------------------------------

// https://www.pcg-random.org/

rotation_horaire :: fonc (n: n64, d: n64) -> n64
{
    retourne (n >> d) | (n << (64 - d));
}

rotation_antihoraire :: fonc (n: n64, d: n64) -> n64
{
    retourne (n << d) | (n >> (64 - d));
}

pcg_xsh_rr :: fonc (état: &n64) -> n32
{
    état_ := xor_shift(état)
    sortie := rotation_horaire((état_ ^ (état_ >> 18)) >> 27, état_ >> 59)
    retourne sortie comme n32
}

xor_shift :: fonc (état: &n32) -> n32
{
    x : n32 = état
    x ^= x << 13
    x ^= x >> 17
    x ^= x << 5
    état = x
    retourne x
}

xor_shift :: fonc (état: &n64) -> n64
{
    x : n64 = état
    x ^= x << 13
    x ^= x >> 7
    x ^= x << 17
    état = x
    retourne x
}

SérieAléatoire :: struct {
    état : n32
}

graine_aléatoire :: fonc (graine: n32) -> SérieAléatoire
{
    graine = (graine & 0x330e) | (graine << 16)
    graine = xor_shift(graine)
    graine = (graine & 0x330e) | (graine << 16)
    graine = xor_shift(graine)
    graine = (graine & 0x330e) | (graine << 16)
    retourne SérieAléatoire(graine)
}

aléatoire_unilatérale :: fonc (série: &SérieAléatoire) -> r32
{
    retourne xor_shift(série.état) comme r32 / ((-1 comme n32) comme r32)
}

aléatoire_bilatérale :: fonc (série: &SérieAléatoire) -> r32
{
    retourne série.aléatoire_unilatérale() * 2.0 - 1.0
}

// -------------------------------------------------------------------------

/* Tiré de "Sampling with Hammersley and Halton Points" TT Wong
 * Appendice : Source Code 1 */
inverse_radical :: fonc (n: n32) -> r64
{
    u : r64 = 0.0
    p : r64 = 0.5

    /* This reverse the bit-wise representation
     * around the decimal point. */
    tantque n != 0 {
        si (n & 1) != 0 {
            u += p
        }

        p *= 0.5
        n >>= 1
    }

    retourne u
}

hammersley_1d :: fonc (n: n32) -> r64
{
    retourne inverse_radical(n)
}

séquence_hammersley_2d :: fonc (n: n32, r: *r64)
{
    pour s dans 0 ... n - 1 {
        r[s * 2 + 0] = (s comme r64 + 0.5) / n comme r64;
        r[s * 2 + 1] = inverse_radical(s);
    }
}
