importe Chaine
importe Fondation
importe Math
importe Périphériques
importe Typographie
importe Unicode

/* ------------------------------------------------------------------------- */
/** \nom RappelsÉditionTexte
 * Rappels pour être notifié du changement du texte lors de l'édition.
 * \{ */

RappelsÉditionTexte :: struct {
    /* Appelé à chaque changement. */
    sur_édition: fonc(*RappelsÉditionTexte, chaine)(rien)
    /* Appelé lors de la fin de l'édition. */
    sur_fin_édition: fonc(*RappelsÉditionTexte, chaine)(rien)
    /* Appelé au début de l'édition de texte.
     * Ceci permets aux applications clientes de démarrer un chronomètre
     * pour faire clignoter le curseur, via Éditrice.curseur_est_affiché.
     * Optionnel. */
    sur_démarre_clignotage_curseur: fonc(*RappelsÉditionTexte, *ÉditriceTexte)(rien)
    /* Appelé à la fin de l'édition de texte pour terminer le choronomètre de
     * clignotage associé.
     * Optionnel, mais obligatoire si sur_démarre_clignotage_curseur existe. */
    sur_termine_clignotage_curseur: fonc(*RappelsÉditionTexte, *ÉditriceTexte)(rien)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ÉditriceTexte
 * \{ */

ModeÉditionTexte :: énum {
    UNE_SEULE_LIGNE
    PLUSIEURS_LIGNES
}

ÉditriceTexte :: struct {
    texte_à_éditer: ChaineUTF32
    lignes: [..]ChaineUTF32
    mode: ModeÉditionTexte

    fonte: *Fonte
    rappels: *RappelsÉditionTexte
    curseur: CurseurTexte
    en_édition: bool
    curseur_est_affiché: bool
}

initialise_éditrice :: fonc (éditrice: *ÉditriceTexte, fonte: *Fonte, texte: chaine, rappels: *RappelsÉditionTexte, mode := ModeÉditionTexte.UNE_SEULE_LIGNE)
{
    éditrice.texte_à_éditer = crée_chaine_utf32(texte)
    éditrice.curseur.éditrice = éditrice
    éditrice.rappels = rappels
    éditrice.fonte = fonte
    éditrice.mode = mode

    si éditrice.mode == ModeÉditionTexte.PLUSIEURS_LIGNES {
        lignes := divise(texte, '\n')
        pour lignes {
            tableau_ajoute(*éditrice.lignes, crée_chaine_utf32(it))
        }
    }
}

détruit_données :: fonc (éditrice: *ÉditriceTexte)
{
    détruit_chaine(éditrice.texte_à_éditer)

    pour éditrice.lignes {
        détruit_chaine(it)
    }
    déloge(éditrice.lignes)
}

démarre_édition :: fonc (éditrice: *ÉditriceTexte)
{
    éditrice.en_édition = vrai
    éditrice.curseur_est_affiché = vrai

    si éditrice.rappels && éditrice.rappels.sur_démarre_clignotage_curseur {
        éditrice.rappels.sur_démarre_clignotage_curseur(éditrice.rappels, éditrice)
    }
}

termine_édition :: fonc (empl éditrice: *ÉditriceTexte)
{
    en_édition = faux
    curseur_est_affiché = faux

    curseur.début = curseur.fin
    notifie_fin_édition(*éditrice.curseur)
    
    saufsi rappels {
        retourne
    }

    saufsi rappels.sur_termine_clignotage_curseur {
        assert(rappels.sur_démarre_clignotage_curseur == nul)
        retourne
    }

    rappels.sur_termine_clignotage_curseur(rappels, éditrice)
}

donne_lignes_pour_rendu :: fonc (éditrice: *ÉditriceTexte) -> []ChaineUTF32
{
    retourne éditrice.lignes
}

donne_tampon_texte_natif :: fonc (éditrice: *ÉditriceTexte) -> chaine
{
    si éditrice.mode == ModeÉditionTexte.UNE_SEULE_LIGNE {
        retourne converti_vers_chaine(éditrice.texte_à_éditer)
    }

    enchaineuse: Enchaineuse
    initialise_enchaineuse(*enchaineuse)

    pour éditrice.lignes {
        ajoute_au_tampon(*enchaineuse, it)
        ajoute_au_tampon(*enchaineuse, "\n")
    }

    retourne chaine_depuis_enchaineuse(*enchaineuse)
}

sur_touche_clavier :: fonc (éditrice: *ÉditriceTexte, touche: InfoToucheClavier)
{
    si touche.type == ToucheClavier.DÉBUT {
        si touche.modificateur == ModificateurClavier.MAJUSCULE {
            définis_position(*éditrice.curseur, ModeDéplacementCurseur.GardeAncre, 0)
        }
        sinon si touche.modificateur == ModificateurClavier.zéro {
            définis_position(*éditrice.curseur, ModeDéplacementCurseur.DéplaceAncre, 0)
        }
        retourne
    }

    si touche.type == ToucheClavier.FIN {
        si touche.modificateur == ModificateurClavier.MAJUSCULE {
            définis_position(*éditrice.curseur, ModeDéplacementCurseur.GardeAncre, éditrice.texte_à_éditer.taille())
        }
        sinon si touche.modificateur == ModificateurClavier.zéro {
            définis_position(*éditrice.curseur, ModeDéplacementCurseur.DéplaceAncre, éditrice.texte_à_éditer.taille())
        }
        retourne
    }

    si touche.type == ToucheClavier.FLÈCHE_GAUCHE {
        si touche.modificateur == ModificateurClavier.MAJUSCULE {
            définis_position(*éditrice.curseur, ModeDéplacementCurseur.GardeAncre, éditrice.curseur.début - 1)
        }
        sinon si touche.modificateur == ModificateurClavier.CONTROL {
            position := donne_position_mot_précédent(*éditrice.curseur)
            définis_position(*éditrice.curseur, ModeDéplacementCurseur.DéplaceAncre, position)
        }
        sinon si touche.modificateur == ModificateurClavier.CTRL_MAJ {
            position := donne_position_mot_précédent(*éditrice.curseur)
            définis_position(*éditrice.curseur, ModeDéplacementCurseur.GardeAncre, position)
        }
        sinon si touche.modificateur == ModificateurClavier.zéro {
            définis_position(*éditrice.curseur, ModeDéplacementCurseur.DéplaceAncre, éditrice.curseur.début - 1)
        }
        retourne
    }

    si touche.type == ToucheClavier.FLÈCHE_DROITE {
        si touche.modificateur == ModificateurClavier.MAJUSCULE {
            définis_position(*éditrice.curseur, ModeDéplacementCurseur.GardeAncre, éditrice.curseur.fin + 1)
        }
        sinon si touche.modificateur == ModificateurClavier.CONTROL {
            position := donne_position_mot_suivant(*éditrice.curseur)
            définis_position(*éditrice.curseur, ModeDéplacementCurseur.DéplaceAncre, position)
        }
        sinon si touche.modificateur == ModificateurClavier.CTRL_MAJ {
            position := donne_position_mot_suivant(*éditrice.curseur)
            définis_position(*éditrice.curseur, ModeDéplacementCurseur.GardeAncre, position)
        }
        sinon si touche.modificateur == ModificateurClavier.zéro {
            définis_position(*éditrice.curseur, ModeDéplacementCurseur.DéplaceAncre, éditrice.curseur.fin + 1)
        }
        retourne
    }

    si touche.type == ToucheClavier.FLÈCHE_HAUT && éditrice.mode == ModeÉditionTexte.PLUSIEURS_LIGNES {
        éditrice.curseur.ligne = restreint(0 comme z64, éditrice.curseur.ligne - 1, éditrice.lignes.taille - 1)
        ligne := donne_ligne_courante(*éditrice.curseur)
        éditrice.curseur.début = restreint(0 comme z64, éditrice.curseur.début, ligne.points_de_code.taille)
        définis_position(*éditrice.curseur, ModeDéplacementCurseur.DéplaceAncre, éditrice.curseur.début)
        retourne
    }

    si touche.type == ToucheClavier.FLÈCHE_BAS && éditrice.mode == ModeÉditionTexte.PLUSIEURS_LIGNES {
        éditrice.curseur.ligne = restreint(0 comme z64, éditrice.curseur.ligne + 1, éditrice.lignes.taille - 1)
        ligne := donne_ligne_courante(*éditrice.curseur)
        éditrice.curseur.début = restreint(0 comme z64, éditrice.curseur.début, ligne.points_de_code.taille)
        définis_position(*éditrice.curseur, ModeDéplacementCurseur.DéplaceAncre, éditrice.curseur.début)
        retourne
    }

    si touche.type == ToucheClavier.EFFACE {
        si touche.modificateur == ModificateurClavier.CONTROL {
            position := donne_position_mot_précédent(*éditrice.curseur)
            définis_position(*éditrice.curseur, ModeDéplacementCurseur.GardeAncre, position)
            efface(*éditrice.curseur)
        }
        sinon si touche.modificateur == ModificateurClavier.zéro {
            efface(*éditrice.curseur)
        }
        retourne
    }

    si touche.type == ToucheClavier.SUPPRIMER {
        si touche.modificateur == ModificateurClavier.CONTROL {
            position := donne_position_mot_suivant(*éditrice.curseur)
            définis_position(*éditrice.curseur, ModeDéplacementCurseur.GardeAncre, position)
            supprime(*éditrice.curseur)
        }
        sinon si touche.modificateur == ModificateurClavier.zéro {
            supprime(*éditrice.curseur)
        }
        retourne
    }

    si touche.texte.taille != 0 {
        est_valide := nombre_octets_utf8_rapide(touche.texte.pointeur) == touche.texte.taille
        si est_valide {
            point_de_code := converti_utf8_utf32(touche.texte.pointeur, touche.texte.taille) comme n32
            insère(*éditrice.curseur, point_de_code)
        }

        retourne
    }
}

// À FAIRE : permet de paramétriser
est_séparation_mot :: fonc (rune: n32) -> bool
{
    si est_ascii_espace_blanche(rune) {
        retourne vrai
    }

    ponctuations := "./#"

    pour ponctuations {
        si rune == it {
            retourne vrai
        }
    }

    retourne faux
}

ajoute_ligne :: fonc (éditrice: *ÉditriceTexte)
{
    si éditrice.lignes {
        ligne := éditrice.lignes[éditrice.curseur.ligne]
        ligne = avance(ligne, éditrice.curseur.début comme z32)

        indice_nouvelle_ligne := éditrice.curseur.ligne + 1

        si indice_nouvelle_ligne == éditrice.lignes.taille {
            tableau_ajoute(*éditrice.lignes, copie_chaine(ligne))
        }
        sinon {
            tableau_insère_indice(*éditrice.lignes, copie_chaine(ligne), indice_nouvelle_ligne)
        }

        éditrice.lignes[éditrice.curseur.ligne].points_de_code.taille = éditrice.curseur.début

        éditrice.curseur.ligne += 1
        définis_position(*éditrice.curseur, ModeDéplacementCurseur.DéplaceAncre, 0)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom CurseurTexte
 * \{ */

CurseurTexte :: struct {
    ligne: z64
    début: z64
    fin: z64
    ancre: z64
    texte: *ChaineUTF32
    éditrice: *ÉditriceTexte
    fut_modifié: bool
}

ModeDéplacementCurseur :: énum {
    GardeAncre
    DéplaceAncre
}

donne_ligne_courante :: fonc (curseur: *CurseurTexte) -> *ChaineUTF32
{
    si curseur.éditrice.mode == ModeÉditionTexte.UNE_SEULE_LIGNE {
        retourne *curseur.éditrice.texte_à_éditer
    }

    retourne *curseur.éditrice.lignes[curseur.ligne]
}

donne_position_mot_précédent :: fonc (curseur: *CurseurTexte) -> z64
{
    ligne := mémoire(donne_ligne_courante(curseur))
    position := curseur.début

    si position == ligne.taille() && ligne.taille() != 0 {
        position -= 1
    }

    si position > 0 && est_séparation_mot(ligne[position - 1]) {
        position -= 1
    }

    tantque position > 0 {
        c := ligne[position]
        si !est_séparation_mot(c) {
            arrête
        }

        position -= 1
    }

    tantque position > 0 {
        c := ligne[position]
        si est_séparation_mot(c) {
            position += 1
            arrête
        }

        position -= 1
    }

    retourne position
}

donne_position_mot_suivant :: fonc (curseur: *CurseurTexte) -> z64
{
    ligne := mémoire(donne_ligne_courante(curseur))
    position := curseur.début

    eu_séparation := faux
    tantque position < ligne.taille() {
        c := ligne[position]
        si eu_séparation && !est_séparation_mot(c) {
            arrête
        }

        si est_séparation_mot(c) {
            eu_séparation = vrai
        }

        position += 1
    }

    retourne position
}

déplace_vers :: fonc (curseur: *CurseurTexte, mode: ModeDéplacementCurseur, position: z64)
{
    définis_position(curseur, mode, position)
}

définis_position :: fonc (curseur: *CurseurTexte, mode: ModeDéplacementCurseur, position: z64)
{
    position = restreint_position(curseur, position)

    discr mode {
        GardeAncre {
            si position < curseur.ancre {
                curseur.début = position
                curseur.fin = curseur.ancre
            }
            sinon {
                curseur.début = curseur.ancre
                curseur.fin = position
            }
        }
        DéplaceAncre {
            curseur.début = position
            curseur.fin = position
            curseur.ancre = position
        }
    }
}

restreint_position :: fonc (curseur: *CurseurTexte, position: z64) -> z64
{
    texte := donne_ligne_courante(curseur)

    si position > texte.points_de_code.taille {
        retourne texte.points_de_code.taille
    }
    si position < 0 {
        retourne 0
    }
    retourne position
}

efface :: fonc (curseur: *CurseurTexte)
{
    texte := donne_ligne_courante(curseur)

    si curseur.début == curseur.fin {
        si curseur.début == 0 {
            si curseur.ligne >= 1 {
                indice_ligne_courante := curseur.ligne

                curseur.ligne -= 1
                ligne_précédente := donne_ligne_courante(curseur)
                curseur.début = ligne_précédente.points_de_code.taille
                définis_position(curseur, ModeDéplacementCurseur.DéplaceAncre, curseur.début - 1)

                tableau_ajoute(*ligne_précédente.points_de_code, ...texte.points_de_code)

                déloge(texte.points_de_code)

                tableau_supprime_indice(*curseur.éditrice.lignes, indice_ligne_courante)
            }
            retourne
        }

        tableau_supprime_indice(*texte.points_de_code, curseur.début - 1)
        définis_position(curseur, ModeDéplacementCurseur.DéplaceAncre, curseur.début - 1)
    }
    sinon {
        tableau_supprime_entre(*texte.points_de_code, curseur.début, curseur.fin)
        définis_position(curseur, ModeDéplacementCurseur.DéplaceAncre, curseur.début)
    }

    notifie_changement(curseur)
}

supprime :: fonc (curseur: *CurseurTexte)
{
    texte := donne_ligne_courante(curseur)

    si curseur.début == curseur.fin {
        si curseur.début == texte.points_de_code.taille {
            retourne
        }

        tableau_supprime_indice(*texte.points_de_code, curseur.début)
    }
    sinon {
        tableau_supprime_entre(*texte.points_de_code, curseur.début, curseur.fin)
    }

    définis_position(curseur, ModeDéplacementCurseur.DéplaceAncre, curseur.début)
    notifie_changement(curseur)
}

insère :: fonc (curseur: *CurseurTexte, point_de_code: n32)
{
    texte := donne_ligne_courante(curseur)

    si curseur.début == curseur.fin {
        tableau_insère_indice(*texte.points_de_code, point_de_code, curseur.début)
    }
    sinon {
        texte.points_de_code[curseur.début] = point_de_code
        tableau_supprime_entre(*texte.points_de_code, curseur.début + 1, curseur.fin)
    }

    définis_position(curseur, ModeDéplacementCurseur.DéplaceAncre, curseur.début + 1)
    notifie_changement(curseur)
}

notifie_changement :: fonc (curseur: *CurseurTexte)
{
    curseur.fut_modifié = vrai

    éditrice := curseur.éditrice
    saufsi éditrice.rappels && éditrice.rappels.sur_édition {
        retourne
    }

    chn := donne_tampon_texte_natif(curseur.éditrice)
    diffère déloge(chn)

    éditrice.rappels.sur_édition(éditrice.rappels, chn)
}

notifie_fin_édition :: fonc (curseur: *CurseurTexte)
{
    saufsi curseur.fut_modifié {
        retourne
    }
    curseur.fut_modifié = vrai

    éditrice := curseur.éditrice
    saufsi éditrice.rappels && éditrice.rappels.sur_fin_édition {
        retourne
    }

    chn := donne_tampon_texte_natif(curseur.éditrice)
    diffère déloge(chn)

    éditrice.rappels.sur_fin_édition(éditrice.rappels, chn)
}

/** \} */
