importe Chaine
importe Fondation
importe GlibC

charge "interface"

FluxVidéo :: struct {
    format_ctx: *AVFormatContext
    codec_ctx: *AVCodecContext
    audio_codec_ctx: *AVCodecContext
    codec: *AVCodec
    sws_ctx: *SwsContext

    video_stream_idx: z32
    /* -1 si aucun audio. */
    audio_stream_idx: z32

    /* Frame et tampon pour l'image courante. */
    frame_rgb: *AVFrame
    tampon_image_courante: *n8
}

détruit_données_flux_vidéo :: fonc (flux: *FluxVidéo)
{
    avcodec_free_context(*flux.codec_ctx)
    avcodec_free_context(*flux.audio_codec_ctx)
    avformat_close_input(*flux.format_ctx)
    av_frame_free(*flux.frame_rgb)
    sws_freeContext(flux.sws_ctx)
}

alloue_tampon_pour_image :: fonc (empl flux_vidéo: *FluxVidéo)
{
    si tampon_image_courante != nul {
        retourne
    }

    frame_rgb = av_frame_alloc()
    assert(frame_rgb != nul)

    // Determine required buffer size and allocate buffer
    taille := av_image_get_buffer_size(AVPixelFormat.AV_PIX_FMT_RGB24, codec_ctx.width, codec_ctx.height, 1)
    tampon_image_courante = av_malloc(taille comme n64 * taille_de(n8)) comme *n8

    // Assign appropriate parts of buffer to image planes in pFrameRGB
    // Note that pFrameRGB is an AVFrame, but AVFrame is a superset
    // of AVPicture
    av_image_fill_arrays(*frame_rgb.data[0], *frame_rgb.linesize[0], tampon_image_courante, AVPixelFormat.AV_PIX_FMT_RGB24, codec_ctx.width, codec_ctx.height, 1);
}

ouvre_flux_vidéo_depuis_fichier :: fonc (résultat: *FluxVidéo, chemin: chaine) -> bool
{
    détruit_données_flux_vidéo(résultat)

    input_file := crée_chaine_c(chemin)
    diffère détruit_chaine_c(input_file)

    // Register all available codecs, demuxers, and protocols
    av_register_all();

    // Open input file and allocate format context
    format_ctx: *AVFormatContext
    si (avformat_open_input(*format_ctx, input_file, nul, nul) < 0) {
        imprime("Could not open input file: %\n", input_file)
        retourne faux
    }

    // Retrieve stream information
    si (avformat_find_stream_info(format_ctx, nul) < 0) {
        imprime("Could not find stream information\n")
        retourne faux
    }

    // Find video stream
    video_stream_idx := -1;
    audio_stream_idx := -1
    pour format_ctx.nb_streams {
        si (format_ctx.streams[it].codecpar.codec_type == AVMediaType.AVMEDIA_TYPE_VIDEO) {
            video_stream_idx = it comme z32
            continue
        }
        si (format_ctx.streams[it].codecpar.codec_type == AVMediaType.AVMEDIA_TYPE_AUDIO) {
            audio_stream_idx = it comme z32
            continue
        }
    }

    si (video_stream_idx == -1) {
        imprime("Could not find video stream\n")
        retourne faux
    }

    imprime("audio stream idx : %\n", audio_stream_idx)

    // Get codec parameters and codec context
    codecpar := format_ctx.streams[video_stream_idx].codecpar
    codec := avcodec_find_decoder(codecpar.codec_id)
    codec_ctx := avcodec_alloc_context3(codec)
    avcodec_parameters_to_context(codec_ctx, codecpar)

    // Open codec
    si (avcodec_open2(codec_ctx, codec, nul) < 0) {
        imprime("Could not open codec\n")
        retourne faux
    }

    // Audio
    audio_codec_ctx: *AVCodecContext
    si audio_stream_idx != -1 {
        audio_stream := format_ctx.streams[audio_stream_idx].codecpar
        codec_audio := avcodec_find_decoder(audio_stream.codec_id)

        si codec_audio {
            // imprime("trouvé codec audio\n")
            audio_codec_ctx = avcodec_alloc_context3(codec_audio)

            avcodec_parameters_to_context(audio_codec_ctx, audio_stream)

            si avcodec_open2(audio_codec_ctx, codec_audio, nul) < 0 {
                imprime("Could not open audio codec\n")
                retourne faux
            }

            // imprime("sample_rate : %\n", audio_codec_ctx.sample_rate)
            // imprime("channels    : %\n", audio_codec_ctx.channels)
        }
    }

    imprime("codec_ctx.pix_fmt %\n", codec_ctx.pix_fmt)

    // initialize SWS context for software scaling
    sws_ctx := sws_getContext(codec_ctx.width,
        codec_ctx.height,
        codec_ctx.pix_fmt,
        codec_ctx.width,
        codec_ctx.height,
        AVPixelFormat.AV_PIX_FMT_RGB24,
        SWS_BILINEAR,
        nul,
        nul,
        nul)

    saufsi sws_ctx {
        imprime("Could not create sws_ctx\n")
        retourne faux
    }

    résultat.format_ctx = format_ctx
    résultat.video_stream_idx = video_stream_idx
    résultat.audio_stream_idx = audio_stream_idx
    résultat.codec = codec
    résultat.codec_ctx = codec_ctx
    résultat.audio_codec_ctx = audio_codec_ctx
    résultat.sws_ctx = sws_ctx
    retourne vrai
}

lis_une_frame :: fonc (empl flux_vidéo: *FluxVidéo) -> bool
{
    résultat: bool

    alloue_tampon_pour_image(flux_vidéo)

    // Allocate frame and packet
    frame := av_frame_alloc();
    packet: AVPacket = ---
    av_init_packet(*packet)

    // Read frames from the video stream
    tantque (av_read_frame(format_ctx, *packet) >= 0) {
        si (packet.stream_index == video_stream_idx) {
            // Decode video frame
            ret := avcodec_send_packet(codec_ctx, *packet)
            si (ret < 0) {
                imprime("Error sending packet for decoding")
                arrête
            }

            image_reçu := faux

            tantque (ret >= 0) {
                ret = avcodec_receive_frame(codec_ctx, frame)
                si (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) {
                    arrête
                }
                sinon si (ret < 0) {
                    imprime("Error during decoding")
                    arrête
                }
                sinon si ret == 0 {
                    image_reçu = vrai
                    résultat = vrai
                    arrête
                }

                // Print basic frame properties
                // std::cout << "Frame " << codec_ctx->frame_number
                //           << " (type=" << av_get_picture_type_char(frame->pict_type)
                //           << ", size=" << frame->pkt_size
                //           << " bytes) pts " << frame->pts
                //           << " key_frame " << frame->key_frame
                //           << std::endl;
            }

            // Did we get a video frame?
            si image_reçu {
                // imprime("Frame : %\n", codec_ctx.frame_number)

                // Convert the image from its native format to RGB
                _ := sws_scale(sws_ctx, *frame.data[0],
                        *frame.linesize[0], 0, codec_ctx.height,
                        *frame_rgb.data[0], *frame_rgb.linesize[0])
                arrête
            }
        }

        av_packet_unref(*packet)
    }

    // Free allocated resources
    av_frame_free(*frame)
    retourne résultat
}
