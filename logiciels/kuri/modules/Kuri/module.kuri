importe Fondation
importe GlibC // pour le signal de violation de segmentation

charge "infos_types"
charge "panique"
charge "r16"

// Ce fichier est utiliser pour définir des variables et fonctions de
// bases (« connus par le compilateur ») que tous les modules doivent importer.
// Ceci nous évite d'avoir à manuellement spécifier ces choses dans le
// code du compilateur.
// Par contre, ce fichier ne devrait pas pouvoir être modifié par les
// utilisateurs du langage.

malloc :: fonc (taille : n64) -> *rien #externe libc
realloc :: fonc (ptr : *rien, taille : n64) -> *rien #externe libc
free :: fonc (ptr : *rien) -> rien #externe libc

// --------------------------

// Position dans le code source. Quand cette structure est instantiée, le
// compilateur remplis les membres de cette structure avec les valeurs
// correspondantes de la position du lexème dans le fichier où se fait ladite
// construction.
PositionCodeSource :: struct #interface {
    // le nom du fichier où se trouve l'objet
    fichier : chaine
    // le nom de la fonction où se trouve l'objet, vide si variable globale
    fonction : chaine
    // la ligne où se trouve l'objet
    ligne : z32
    // la colonne où se trouve l'objet
    colonne : z32
}

// --------------------------

ModeAllocatrice :: énum z32 {
    ALLOUE
    RÉALLOUE
    DÉSALLOUE
}

BaseAllocatrice :: struct #interface {
    nombre_allocations : z64 = 0
    nombre_réallocations : z64 = 0
    nombre_désallocations : z64 = 0
    mémoire_utilisée : z64 = 0
    pic_de_mémoire : z64 = 0

    // pour pouvoir déterminer quelle type d'allocatrice nous avons
    infos : *InfoTypeStructure = info_de(BaseAllocatrice)

    allocatrice_parente : *BaseAllocatrice = nul
    allocatrice_secours : *BaseAllocatrice = nul
}

TypeFonctionAllocation :: fonc (ModeAllocatrice, z64, z64, *rien, *BaseAllocatrice, *InfoType, PositionCodeSource)(*rien)

allocatrice_défaut :: fonc(
    mode : ModeAllocatrice,
    nouvelle_taille : z64,
    ancienne_taille : z64,
    ancien_pointeur : *rien,
    données : *BaseAllocatrice,
    info : *InfoType @inutilisée,
    pos : PositionCodeSource @inutilisée) -> *rien
{
    discr mode {
        ALLOUE {
            données.mémoire_utilisée += nouvelle_taille
            données.nombre_allocations += 1

            si données.pic_de_mémoire < données.mémoire_utilisée {
                données.pic_de_mémoire = données.mémoire_utilisée
            }

            retourne malloc(nouvelle_taille comme n64)
        }
        RÉALLOUE {
            données.mémoire_utilisée += nouvelle_taille - ancienne_taille
            données.nombre_allocations += 1
            données.nombre_réallocations += 1

            si données.pic_de_mémoire < données.mémoire_utilisée {
                données.pic_de_mémoire = données.mémoire_utilisée
            }

            retourne realloc(ancien_pointeur, nouvelle_taille comme n64)
        }
        DÉSALLOUE {
            données.mémoire_utilisée -= ancienne_taille
            données.nombre_désallocations += 1

            free(ancien_pointeur)
            retourne nul
        }
    }

    retourne nul
}

/* Fonctions de bases pour loger des valeurs en mémoire. */

loge_mémoire :: fonc (taille: z64, info: *InfoType, pos : PositionCodeSource) -> *rien
{
    ptr := contexte().allocatrice(
        ModeAllocatrice.ALLOUE,
        taille,
        0,
        nul,
        contexte().données_allocatrice,
        info,
        pos)

    saufsi ptr {
        panique_hors_mémoire()
    }

    retourne ptr
}

reloge_mémoire :: fonc (ancienne_taille: z64, nouvelle_taille: z64, ancien_pointeur: *rien, info: *InfoType, pos: PositionCodeSource) -> *rien
{
    nouveau_pointeur := contexte().allocatrice(
        ModeAllocatrice.RÉALLOUE,
        nouvelle_taille,
        ancienne_taille,
        ancien_pointeur,
        contexte().données_allocatrice,
        info,
        pos)

    saufsi nouveau_pointeur {
        panique_hors_mémoire()
    }

    retourne nouveau_pointeur
}

déloge_mémoire :: fonc (taille: z64, pointeur: *rien, info: *InfoType, pos : PositionCodeSource)
{
    _ := contexte().allocatrice(
        ModeAllocatrice.DÉSALLOUE,
        0,
        taille,
        pointeur,
        contexte().données_allocatrice,
        info,
        pos)
}

loge :: fonc ($T: type_de_données, pos := PositionCodeSource()) -> *T
{
    info := info_de(T)
    ptr := loge_mémoire(info.taille_en_octet comme z64, info, pos) comme *T

    init_de(T)(ptr)

    retourne ptr
}

reloge :: fonc (pointeur: &*$T, pos := PositionCodeSource())
{
    info := info_de(T)
    ancien_pointeur := pointeur
    nouveau_pointeur := reloge_mémoire(
        info.taille_en_octet comme z64,
        info.taille_en_octet comme z64,
        ancien_pointeur,
        info,
        pos)

    pointeur = nouveau_pointeur
}

déloge :: fonc (pointeur: &*$T, pos := PositionCodeSource())
{
    info := info_de(T)
    ancien_pointeur := pointeur
    déloge_mémoire(info.taille_en_octet comme z64, ancien_pointeur, info, pos)
    pointeur = nul
}

loge_chaine :: fonc (taille: z64, pos := PositionCodeSource()) -> chaine
{
    ptr := loge_mémoire(taille, info_de(chaine), pos)

    chn: chaine = ---
    chn.pointeur = ptr
    chn.taille = taille

    retourne chn
}

reloge_chaine :: fonc (chn: &chaine, nouvelle_taille: z64, pos := PositionCodeSource())
{
    ptr := reloge_mémoire(chn.taille, nouvelle_taille, chn.pointeur, info_de(chaine), pos)

    chn.pointeur = ptr
    chn.taille = nouvelle_taille
}

déloge :: fonc (chn: &chaine, pos := PositionCodeSource())
{
    déloge_mémoire(chn.taille, chn.pointeur, info_de(chaine), pos)
    chn.pointeur = nul
    chn.taille = 0
}

// ----------------------------

SystèmeExploitation :: énum {
    AUCUN
    LINUX
    ANDROIDE
    WINDOWS
    MACOS
}

// ----------------------------

ModeLogage :: énum z32 {
    AUCUN
    MINIMAL
    JOURNALIER
    VERBEUX
}

// ----------------------------

// Le StockageTemporaire est un stockage mis en place par le compilateur, qui réserve
// une certaine taille dans l'exécutable où mettre des données temporaire.
StockageTemporaire :: struct #interface {
    données : *octet
    taille : z32
    occupé : z32
    occupation_maximale : z32
}

// ----------------------------

InfoFonctionTraceAppel :: struct #interface {
    nom : chaine
    fichier : chaine
    adresse : *rien
    // peut-être que nous pourrions avoir ceci dans le future, en fonction des besoins
    // position: PositionCodeSource
    // desc_type: *InfoTypeFonction
}

// redondance : peut être remplacé par PositionCodeSource
InfoAppelTraceAppel :: struct #interface {
    ligne: z32
    colonne: z32
    texte: chaine
}

TraceAppel :: struct #interface {
    précédente : *TraceAppel
    info_fonction : *InfoFonctionTraceAppel
    info_appel : *InfoAppelTraceAppel
    profondeur : z32
}

nombre_de_trace :: fonc (racine: *TraceAppel) -> z64
{
    résultat := 0
    trace := racine

    tantque trace != nul {
        résultat += 1
        trace = trace.précédente
    }

    retourne résultat
}

copie_trace_appel :: fonc (racine: *TraceAppel, tableau: [..]TraceAppel)
{
    trace := racine
    index := 0

    tantque trace != nul {
        copie : TraceAppel
        copie.info_appel = trace.info_appel
        copie.info_fonction = trace.info_fonction
        tableau.pointeur[index] = copie
        index += 1
        trace = trace.précédente
    }
}

enregistre_liste_trace_appels :: fonc (racine: *TraceAppel) -> [..]TraceAppel
{
    n := nombre_de_trace(racine)

    /* À FAIRE: remplace l'appel à malloc par allocatrice_défaut, ou loge_mémoire. */
    t := malloc(taille_de(TraceAppel) * n comme n64)

    tableau_traces : [..]TraceAppel
    tableau_traces.pointeur = t
    tableau_traces.taille = n
    copie_trace_appel(racine, tableau_traces)
    retourne tableau_traces
}

imprime_trace :: fonc (tableau: [..]TraceAppel, enchaineuse: *Enchaineuse)
{
    pour tableau {
        trace := it
        info_fonction := trace.info_fonction
        info_appel := trace.info_appel
        imprime_dans_enchaineuse(enchaineuse, "%:%:% : dans % (%)\n", info_fonction.fichier, info_appel.ligne, info_appel.colonne, info_fonction.nom, info_fonction.adresse);
        imprime_dans_enchaineuse(enchaineuse, "%\n", info_appel.texte);
    }
}

détruit_liste_trace_appels :: fonc (tableau_traces: [..]TraceAppel)
{
    free(tableau_traces.pointeur)
}

/* ------------------------------------------------------------------------- */
/** \nom Formattage des nombres pour les impressions.
 *
 * Ces structures permettent de définir comment les nombres entiers et réels
 * doivent être formattés lors des impressions (via Fondation.imprime).
 *
 * Par défaut, les nombres entiers ou réels sont imprimés sans séparateurs et
 * en base 10.
 *
 * Pour remplacer le formattage par défaut, nous pouvons utiliser un contexte
 * temporaire :
 *
 *     format : FormatEntier
 *     format.base = 2
 *     format.séparation = 4
 *     ctx := contexte()
 *     ctx.format_entier = format
 *     pousse_contexte ctx {
 *         imprime("%\n", 123456)
 *     }
 * \{ */

FormatEntier :: struct {
    valeur : eini
    ajoute_zéros_début := faux
    nombre_zéros := 0
    base := 10
    séparation := 0
}

donne_format_entier_contexte :: fonc (valeur: eini) -> FormatEntier
{
    résultat := contexte().format_entier
    résultat.valeur = valeur
    retourne résultat
}

donne_format_entier_contexte_pour_base :: fonc (valeur: eini, base: z32) -> FormatEntier
{
    résultat := contexte().format_entier
    résultat.valeur = valeur
    résultat.base = base
    retourne résultat
}

FormatRéel :: struct {
    valeur: eini
    précision := 6
}

donne_format_réel_contexte :: fonc (valeur: eini) -> FormatRéel
{
    résultat := contexte().format_réel
    résultat.valeur = valeur
    retourne résultat
}

/** } */

// Structure passée implicitement à toutes les fonctions non marquées par #!nulctx.
ContexteProgramme :: struct {
    allocatrice := allocatrice_défaut
    données_allocatrice : *BaseAllocatrice = nul

    logueur := __logueur_défaut
    données_logueur : *rien = nul

    stockage_temporaire : *StockageTemporaire

    trace_appel : *TraceAppel

    rappel_panique := __rappel_panique_défaut
    données_rappel_panique : *rien

    /* Formats pour les nombres entiers et réels. */
    format_entier: FormatEntier
    format_réel: FormatRéel
}

__logueur_défaut :: fonc (message: chaine  @inutilisée,
                          ident: chaine  @inutilisée,
                          mode: ModeLogage  @inutilisée,
                          données: *rien  @inutilisée) -> rien
{
}

__rappel_panique_défaut :: fonc () -> rien {}

// ----------------------------

// Fonctions de convénience pour accéder aux données sur les allocations
// de l'allocatrice courante du contexte
mémoire_utilisée :: fonc() -> z64 #enligne
{
    retourne contexte().données_allocatrice.mémoire_utilisée
}

pic_de_mémoire :: fonc() -> z64 #enligne
{
    retourne contexte().données_allocatrice.pic_de_mémoire
}

nombre_allocations :: fonc() -> z64 #enligne
{
    retourne contexte().données_allocatrice.nombre_allocations
}

nombre_réallocations :: fonc() -> z64 #enligne
{
    retourne contexte().données_allocatrice.nombre_réallocations
}

nombre_désallocations :: fonc() -> z64 #enligne
{
    retourne contexte().données_allocatrice.nombre_désallocations
}

// ----------------------------
// Implémentation des fonctions du stockage temporaire

donne_marque_stockage_temporaire :: fonc () -> z32
{
    retourne __contexte_fil_principal.stockage_temporaire.occupé
}

définis_marque_stockage_temporaire :: fonc (marque: z32) -> rien
{
    //assert(marque >= 0)
    //assert(marque < contexte().stockage_temporaire.taille)
    __contexte_fil_principal.stockage_temporaire.occupé = marque
}

réinitialise_stockage_temporaire :: fonc () -> rien
{
    définis_marque_stockage_temporaire(0)
    __contexte_fil_principal.stockage_temporaire.occupation_maximale = 0
}

alloc_stockage_temporaire :: fonc (alloc: *StockageTemporaire, nouvelle_taille: z64) -> *rien
{
    si alloc.occupé + nouvelle_taille > alloc.taille {
        // À FAIRE : utilisation de l'allocatrice par défaut
        retourne nul
    }

    ptr := alloc.données + alloc.occupé
    alloc.occupé += nouvelle_taille comme z32

    si alloc.occupé > alloc.occupation_maximale {
        alloc.occupation_maximale = alloc.occupé
    }

    retourne ptr
}

__stockage_temporaire :: fonc(
    mode : ModeAllocatrice,
    nouvelle_taille : z64,
    ancienne_taille : z64,
    ancien_pointeur : *rien,
    données : *BaseAllocatrice @inutilisée,
    info : *InfoType @inutilisée,
    pos : PositionCodeSource @inutilisée) -> *rien
{
    alloc := contexte().stockage_temporaire

    discr mode {
        ALLOUE {
            retourne alloc_stockage_temporaire(alloc, nouvelle_taille)
        }
        RÉALLOUE {
            ptr := ancien_pointeur comme *octet

            si ptr == nul {
                retourne alloc_stockage_temporaire(alloc, nouvelle_taille)
            }

            delta := nouvelle_taille - ancienne_taille

            // À FAIRE
            // Nous ne pouvons réallouer que si le pointeur fut le dernier alloué...
            /*
            n := ancienne_taille

            si ptr + n != alloc.ptr {
                retourne nul
            }

            // ... et qu'il y a suffisament de place pour delta

            n = delta  // arrondis_pour_aligner(delta, 8)

            d := transtype(alloc.ptr: z64)
            f := transtype(alloc.début + alloc.données.taille: z64)

            si n > (f - d) {
                retourne nul
            }

            alloc.ptr += n
            */

            alloc.occupé += delta comme z32

            si alloc.occupé > alloc.occupation_maximale {
                alloc.occupation_maximale = alloc.occupé
            }

            retourne ancien_pointeur
        }
        DÉSALLOUE {
            // À FAIRE
            alloc.occupé -= ancienne_taille comme z32
            retourne nul
        }
    }

    retourne nul
}

// fonction de convénience pour loge un tampon dans le stockage temporaire
// principalement utilisé pour loger des chaines avec une terminaison nulle
// afin de pouvoir les passer aux fonctions de C
logement_temp :: fonc(taille: z64) -> *octet
{
    nouveau_contexte := contexte()
    nouveau_contexte.allocatrice = __stockage_temporaire

    ptr : *octet

    pousse_contexte nouveau_contexte {
        tmp := loge_tableau(octet, taille)
        ptr = tmp.pointeur
    }

    retourne ptr
}

// -----------------------------

// Fonctions de bases pour les opérateurs de comparaisons de chaines
opérateur == :: fonc(chn1: chaine, chn2: chaine) -> bool
{
    si chn1.taille != chn2.taille {
        retourne faux
    }

    taille := chn1.taille
    début : z64 = 0

    pour i dans début...(taille - 1) {
        si chn1[i] != chn2[i] {
            retourne faux
        }
    }

    retourne vrai
}

opérateur != :: fonc(chn1: chaine, chn2: chaine) -> bool
{
    retourne !(chn1 == chn2)
}

/*
    while (*s1 == *s2++)
        if (*s1++ == 0)
            return (0);
    return (*(const unsigned char *)s1 - *(const unsigned char *)(s2 - 1));
*/
compare_chaine :: fonc (chn1: chaine, chn2: chaine) -> z32
{
    pour c, i dans chn1 {
        si i == chn2.taille {
            retourne 1
        }

        si chn2[i] > c {
            retourne -1
        }

        si c > chn2[i] {
            retourne 1
        }
    }

    si chn1.taille < chn2.taille {
        retourne -1
    }

    retourne 0
}

opérateur < :: fonc(chn1: chaine, chn2: chaine) -> bool
{
    retourne compare_chaine(chn1, chn2) < 0
}

opérateur <= :: fonc(chn1: chaine, chn2: chaine) -> bool
{
    retourne compare_chaine(chn1, chn2) <= 0
}

opérateur > :: fonc(chn1: chaine, chn2: chaine) -> bool
{
    retourne compare_chaine(chn1, chn2) > 0
}

opérateur >= :: fonc(chn1: chaine, chn2: chaine) -> bool
{
    retourne compare_chaine(chn1, chn2) >= 0
}

/*
test_compare_chaine_impl :: fonc (chn1: chaine, chn2: chaine, attendu: z32) -> rien
{
    résultat := mon_compare_chaine(chn1, chn2)

    si résultat != attendu {
        imprime("Erreur : le résultat de compare_chaine pour '%' et '%' doit être de %, mais eu %\n", chn1, chn2, attendu, résultat)
    }
}

test_compare_chaine :: fonc () -> rien
{
    test_compare_chaine_impl("", "", 0)
    test_compare_chaine_impl("", "abc", -1)
    test_compare_chaine_impl("abc", "", 1)
    test_compare_chaine_impl("abc", "def", -1)
    test_compare_chaine_impl("abc", "abcd", -1)
    test_compare_chaine_impl("abc", "ABC", 1)
    test_compare_chaine_impl("abc", "abc", 0)
    test_compare_chaine_impl("Prashant", "Surendra", -1)
    test_compare_chaine_impl("Surendra", "Jaya", 1)
    test_compare_chaine_impl("Jaya", "Shruti", -1)
    test_compare_chaine_impl("Shruti", "Mangala", 1)
}
*/

// --------------------------------

strlen :: fonc (str: *z8) -> n64 #externe libc

arguments_ligne_commande :: fonc () -> [..]chaine
{
    tabl_args : [..]chaine

    si __arguments_ligne_commande.taille == 0 {
        retourne tabl_args
    }

    nouveau_contexte := contexte()
    nouveau_contexte.allocatrice = __stockage_temporaire

    pousse_contexte nouveau_contexte {
        tabl_args = loge_tableau(chaine, __arguments_ligne_commande.taille)

        pour __arguments_ligne_commande {
            chn : chaine
            chn.pointeur = it
            chn.taille = strlen(it) comme z64
            tableau_ajoute(*tabl_args, chn)
        }

        retourne tabl_args
    }
}

crée_contexte :: fonc () -> rien #création_contexte
{
    info_trace_appel := InfoFonctionTraceAppel(nom = "main", fichier = "module.kuri", adresse = nul)

    trace_appel := TraceAppel(info_fonction = *info_trace_appel)

    base_allocatrice : BaseAllocatrice = ---

    init_de(ContexteProgramme)(*__contexte_fil_principal)

    __contexte_fil_principal.données_allocatrice = *base_allocatrice

    // __contexte_fil_principal.stockage_temporaire = *stockage_temporaire

    // init_de(ContexteProgramme) remet à zéro la trace_appel
    __contexte_fil_principal.trace_appel = *trace_appel

    init_de(BaseAllocatrice)(*base_allocatrice)
}

__contexte_fil_principal : ContexteProgramme = ---
__arguments_ligne_commande : []*z8 = ---
__tampon_stockage_tamporaire : [16384]z8 = ---
__table_des_types : []*InfoType

contexte :: fonc () -> ContexteProgramme #horsligne
{
    retourne __contexte_fil_principal
}

__init_contexte_kuri :: fonc (argc: z32, argv: **z8) -> *ContexteProgramme #sanstrace
{
    __arguments_ligne_commande.taille = argc
    __arguments_ligne_commande.pointeur = argv

    ctx := *__contexte_fil_principal
    init_de(ContexteProgramme)(ctx)
    retourne ctx
}

__init_exécution_kuri :: fonc () #sanstrace #interface
{
    // Ici serons ajoutées toutes les expression des directives #ajoute_init.
}

__fini_exécution_kuri :: fonc () #sanstrace #interface
{
    // Ici seront ajoutées toutes les expression des directives #ajoute_fini.
}

__init_globales_kuri :: fonc () #sanstrace #interface
{
    // Ici seront ajoutées l'initialisation de toutes les globales ayant besoin d'une initialisation spécifique
}

// Ceci sera remplacé par la fonction principale ou par les métaprogrammes
__principale :: fonc () -> z32 #principale

__initialise_contexte_extra :: fonc (ctx: *ContexteProgramme, trace_appel: *TraceAppel, base_allocatrice : *BaseAllocatrice, stockage_temporaire: *StockageTemporaire) #sanstrace
{
    ctx.trace_appel = trace_appel

    ctx.données_allocatrice = base_allocatrice

    stockage_temporaire.données = *__tampon_stockage_tamporaire[0]
    stockage_temporaire.taille = __tampon_stockage_tamporaire.taille comme z32
    stockage_temporaire.occupé = 0
    stockage_temporaire.occupation_maximale = 0
    ctx.stockage_temporaire = stockage_temporaire
}

__point_d_entree_systeme :: fonc (argc: z32, argv: **z8) -> z32 #sanstrace #sansbroyage
{
    ctx := __init_contexte_kuri(argc, argv)

    // initalise les autres membres du contexte
    info_trace_appel := InfoFonctionTraceAppel(nom = "__point_d_entree_systeme", fichier = "module.kuri", adresse = nul)
    trace_appel := TraceAppel(info_fonction = *info_trace_appel)

    base_allocatrice : BaseAllocatrice
    stockage_temporaire : StockageTemporaire = ---

    __initialise_contexte_extra(ctx, *trace_appel, *base_allocatrice, *stockage_temporaire)

    __init_exécution_kuri()

    __init_globales_kuri()

    info_appel := InfoAppelTraceAppel(ligne = 749, colonne = 27, texte = "    résultat := principale()\n")
    trace_appel.info_appel = *info_appel

    système_ajoute_action_pour_action_erreur_de_segmentation()

    résultat := __principale()

    __fini_exécution_kuri()

    retourne résultat
}

/* ----------------------------------------------------------------------------
 * Point d'entrée et de sortie pour les bibliothèques partagées.
 */

/* Globales nécessaires pour Kuri. */
__info_trace_appel_dynamique : InfoFonctionTraceAppel = ---
__trace_appel_dynamique : TraceAppel = ---
__base_allocatrice_dynamique : BaseAllocatrice = ---
__stockage_temporaire_dynamique : StockageTemporaire = ---

__point_d_entree_dynamique :: fonc () #sanstrace #sansbroyage
{
    init_de(ContexteProgramme)(*__contexte_fil_principal)
    __info_trace_appel_dynamique = InfoFonctionTraceAppel(nom = "__point_d_entree_dynamique", fichier = "", adresse = nul)
    __trace_appel_dynamique = TraceAppel(info_fonction = *__info_trace_appel_dynamique)
    __base_allocatrice_dynamique = BaseAllocatrice()

    __initialise_contexte_extra(*__contexte_fil_principal, *__trace_appel_dynamique, *__base_allocatrice_dynamique, *__stockage_temporaire_dynamique)
    __init_exécution_kuri()
    __init_globales_kuri()
}

__point_de_sortie_dynamique :: fonc () #sanstrace #sansbroyage
{
    __fini_exécution_kuri()
}

// -----------------------------------

// Contexte pour les fonctions/modules C.
ContexteKuri :: struct {
    loge_memoire : fonc (*ContexteKuri,n64)(*rien)
    reloge_memoire : fonc (*ContexteKuri,*rien,n64,n64)(*rien)
    deloge_memoire : fonc (*ContexteKuri,*rien,n64)(rien)
}

loge_memoire_pour_contexte_kuri :: fonc (ctx: *ContexteKuri @inutilisée, taille: n64) -> *rien
{
    retourne loge_mémoire(taille comme z64, nul, PositionCodeSource())
}

reloge_memoire_pour_contexte_kuri :: fonc (ctx: *ContexteKuri @inutilisée, ancien_pointeur: *rien, ancienne_taille: n64, nouvelle_taille: n64) -> *rien
{
    retourne reloge_mémoire(ancienne_taille comme z64, nouvelle_taille comme z64, ancien_pointeur, nul, PositionCodeSource())
}

déloge_memoire_pour_contexte_kuri :: fonc (ctx: *ContexteKuri @inutilisée, ancien_pointeur: *rien, ancienne_taille: n64) -> rien
{
    déloge_mémoire(ancienne_taille comme z64, ancien_pointeur, nul, PositionCodeSource())
}

initialise_contexte_kuri :: fonc () -> ContexteKuri
{
    ctx: ContexteKuri
    ctx.loge_memoire = loge_memoire_pour_contexte_kuri
    ctx.reloge_memoire = reloge_memoire_pour_contexte_kuri
    ctx.deloge_memoire = déloge_memoire_pour_contexte_kuri
    retourne ctx
}
