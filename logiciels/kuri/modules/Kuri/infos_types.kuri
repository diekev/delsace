// Structures de bases pour contenir les informations d'un type.

importe Compilatrice // Pour AnnotationCode

id_info :: énum z32 {
    ENTIER          :: 0
	RÉEL            :: 1
	BOOLÉEN         :: 2
	CHAINE          :: 3
	POINTEUR        :: 4
	STRUCTURE       :: 5
	FONCTION        :: 6
	TABLEAU         :: 7
	EINI            :: 8
	RIEN            :: 9
	ÉNUM            :: 10
	OCTET           :: 11
	TYPE_DE_DONNÉES :: 12
	UNION           :: 13
	OPAQUE          :: 14
}

InfoType :: struct #interface {
	id : id_info
	taille_en_octet : n32
	index_dans_table_des_types : n32
}

InfoTypeEntier :: struct #interface {
	empl base : InfoType

	est_signé : bool
}

InfoTypePointeur :: struct #interface {
	empl base : InfoType

	type_pointé : *InfoType
	est_référence : bool
}

InfoTypeTableau :: struct #interface {
	empl base : InfoType

	type_pointé : *InfoType
	est_tableau_fixe : bool
	taille_fixe : z32
}

InfoTypeMembreStructure :: struct #interface {
	Drapeaux :: énum_drapeau {
		EST_CONSTANT
		EST_IMPLICITE
	}

	nom : chaine
	id : *InfoType
	décalage : z64 // décalage en octets dans la structure
	drapeaux : Drapeaux
  annotations: []*AnnotationCode
}

possède_annotation :: fonc (info: *InfoTypeMembreStructure, nom: chaine) -> bool
{
	pour info.annotations {
		si it.nom == nom {
			retourne vrai
		}
	}

	retourne faux
}

trouve_annotation :: fonc (info: *InfoTypeMembreStructure, nom: chaine) -> *AnnotationCode
{
	pour info.annotations {
		si it.nom == nom {
			retourne it
		}
	}

	retourne nul
}

InfoTypeStructure :: struct #interface {
	empl base : InfoType

	nom : chaine
	membres : []*InfoTypeMembreStructure
	structs_employées : []*InfoTypeStructure
}

InfoTypeUnion :: struct #interface {
	empl base : InfoType

	nom : chaine
	membres : []*InfoTypeMembreStructure
	type_le_plus_grand : *InfoType
	décalage_index : z64
	est_sûre : bool
}

InfoTypeFonction :: struct #interface {
	empl base : InfoType

	types_entrée : []*InfoType
	types_sortie : []*InfoType
	est_coroutine : bool
}

InfoTypeÉnum :: struct #interface {
	empl base : InfoType

	nom : chaine
	valeurs : []z32
	noms : []chaine
	est_drapeau : bool
	type_sous_jacent: *InfoTypeEntier
}

InfoTypeOpaque :: struct #interface {
	empl base : InfoType

	nom : chaine
	type_opacifié : *InfoType
}

est_référence_vers :: fonc (info: *InfoType, type_pointé: *InfoType) -> bool
{
    si info.id != id_info.POINTEUR {
        retourne faux
    }

    référence := info comme *InfoTypePointeur
    saufsi référence.est_référence {
        retourne faux
    }

    retourne référence.type_pointé == type_pointé
}

est_pointeur_vers :: fonc (info: *InfoType, type_pointé: *InfoType) -> bool
{
    si info.id != id_info.POINTEUR {
        retourne faux
    }

    pointeur := info comme *InfoTypePointeur
    si pointeur.est_référence {
        retourne faux
    }

    retourne pointeur.type_pointé == type_pointé
}

est_struct_ou_employeuse_de :: fonc (info: *InfoTypeStructure, base: *InfoTypeStructure) -> bool
{
    si info == base {
        retourne vrai
    }

    pour info.structs_employées {
        si est_struct_ou_employeuse_de(it, base) {
            retourne vrai
        }
    }

    retourne faux
}

est_pointeur_de :: fonc (info: *InfoType) -> *InfoType
{
    si info == nul {
        retourne nul
    }

    si info.id != id_info.POINTEUR {
        retourne nul
    }

    info_pointeur := info comme *InfoTypePointeur
    si info_pointeur.est_référence {
        retourne nul
    }

    retourne info_pointeur.type_pointé
}

est_pointeur_de_structure :: fonc (info: *InfoType) -> *InfoTypeStructure
{
	type_pointé := est_pointeur_de(info)

	si !type_pointé {
		retourne nul
	}

    si type_pointé.id != id_info.STRUCTURE {
        retourne nul
    }

    retourne type_pointé comme *InfoTypeStructure
}

est_pointeur_de_structure_ou_union :: fonc (info: *InfoType) -> *InfoType
{
	type_pointé := est_pointeur_de(info)

	si !type_pointé {
		retourne nul
	}

    si type_pointé.id != id_info.STRUCTURE && type_pointé.id != id_info.UNION {
        retourne nul
    }

    retourne type_pointé
}
