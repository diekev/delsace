// Structures de bases pour contenir les informations d'un type.

importe Compilatrice // Pour AnnotationCode

id_info :: énum z32 {
    ENTIER          :: 0
    RÉEL            :: 1
    BOOLÉEN         :: 2
    CHAINE          :: 3
    POINTEUR        :: 4
    STRUCTURE       :: 5
    FONCTION        :: 6
    TABLEAU         :: 7
    EINI            :: 8
    RIEN            :: 9
    ÉNUM            :: 10
    OCTET           :: 11
    TYPE_DE_DONNÉES :: 12
    UNION           :: 13
    OPAQUE          :: 14
    VARIADIQUE      :: 15
    TRANCHE         :: 16
    TABLEAU_FIXE    :: 17
}

InfoType :: struct #interface {
    id : id_info
    taille_en_octet : n32
    index_dans_table_des_types : n32
}

InfoTypeEntier :: struct #interface {
    empl base : InfoType

    est_signé : bool
}

InfoTypePointeur :: struct #interface {
    empl base : InfoType

    type_pointé : *InfoType
    est_référence : bool
}

InfoTypeTableau :: struct #interface {
    empl base : InfoType

    type_pointé : *InfoType
}

InfoTypeTableauFixe :: struct #interface {
    empl base : InfoType

    type_pointé : *InfoType
    nombre_éléments : n32
}

InfoTypeTranche :: struct #interface {
    empl base : InfoType

    type_élément : *InfoType
}

possède_annotation :: fonc (annotations: []*AnnotationCode, nom: chaine) -> bool
{
    retourne trouve_annotation(annotations, nom) != nul
}

trouve_annotation :: fonc (annotations: []*AnnotationCode, nom: chaine) -> *AnnotationCode
{
    pour annotations {
        si it.nom == nom {
            retourne it
        }
    }

    retourne nul
}

InfoTypeMembreStructure :: struct #interface {
    Drapeaux :: énum_drapeau {
        EST_CONSTANT
        EST_IMPLICITE
    }

    nom : chaine
    id : *InfoType
    décalage : z64 // décalage en octets dans la structure
    drapeaux : Drapeaux
    annotations: []*AnnotationCode
}

possède_annotation :: fonc (info: *InfoTypeMembreStructure, nom: chaine) -> bool
{
    retourne possède_annotation(info.annotations, nom)
}

trouve_annotation :: fonc (info: *InfoTypeMembreStructure, nom: chaine) -> *AnnotationCode
{
    retourne trouve_annotation(info.annotations, nom)
}

InfoTypeStructure :: struct #interface {
    empl base : InfoType

    nom : chaine
    membres : []*InfoTypeMembreStructure
    structs_employées : []*InfoTypeStructure
  	annotations: []*AnnotationCode
}

possède_annotation :: fonc (info: *InfoTypeStructure, nom: chaine) -> bool
{
    retourne possède_annotation(info.annotations, nom)
}

trouve_annotation :: fonc (info: *InfoTypeStructure, nom: chaine) -> *AnnotationCode
{
    retourne trouve_annotation(info.annotations, nom)
}

InfoTypeUnion :: struct #interface {
    empl base : InfoType

    nom : chaine
    membres : []*InfoTypeMembreStructure
    type_le_plus_grand : *InfoType
    décalage_index : z64
    est_sûre : bool
  	annotations: []*AnnotationCode
}

possède_annotation :: fonc (info: *InfoTypeUnion, nom: chaine) -> bool
{
    retourne possède_annotation(info.annotations, nom)
}

trouve_annotation :: fonc (info: *InfoTypeUnion, nom: chaine) -> *AnnotationCode
{
    retourne trouve_annotation(info.annotations, nom)
}

InfoTypeFonction :: struct #interface {
    empl base : InfoType

    types_entrée : []*InfoType
    types_sortie : []*InfoType
    est_coroutine : bool
}

/* Retourne vrai si les d'entrée et de sortie de l'InfoTypeFonction sont les
 * mêmes que ceux données en paramtères. */
apparie_type_fonction :: fonc (info_type: *InfoTypeFonction, types_entrée : []*InfoType, types_sortie: []*InfoType) -> bool
{
    retourne tableaux_sont_égaux(info_type.types_entrée, types_entrée) && tableaux_sont_égaux(info_type.types_sortie, types_sortie)
}

InfoTypeÉnum :: struct #interface {
    empl base : InfoType

    nom : chaine
    valeurs : []z32
    noms : []chaine
    est_drapeau : bool
    type_sous_jacent: *InfoTypeEntier
}

donne_valeur_énum_pour_nom :: fonc (info: *InfoTypeÉnum, nom: chaine) -> z32, bool
{
    pour info.noms {
        si it == nom {
            retourne info.valeurs[index_it], vrai
        }
    }

    retourne 0, faux
}

donne_nom_énum_pour_valeur :: fonc (info: *InfoTypeÉnum, valeur: z32) -> chaine
{
    pour info.valeurs {
        si it == valeur {
            retourne info.noms[index_it]
        }
    }

    retourne ""
}

donne_eini_valeur_énum_index :: fonc (info: *InfoTypeÉnum, index: z64) -> eini
{
    résultat : eini = ---
    résultat.pointeur = *info.valeurs[index]
    résultat.info = info.type_sous_jacent
    retourne résultat
}

InfoTypeOpaque :: struct #interface {
    empl base : InfoType

    nom : chaine
    type_opacifié : *InfoType
}

InfoTypeVariadique :: struct #interface {
    empl base : InfoType

    type_élément : *InfoType
}

est_référence_vers :: fonc (info: *InfoType, type_pointé: *InfoType) -> bool
{
    si info.id != id_info.POINTEUR {
        retourne faux
    }

    référence := info comme *InfoTypePointeur
    saufsi référence.est_référence {
        retourne faux
    }

    retourne référence.type_pointé == type_pointé
}

est_pointeur_vers :: fonc (info: *InfoType, type_pointé: *InfoType) -> bool
{
    si info.id != id_info.POINTEUR {
        retourne faux
    }

    pointeur := info comme *InfoTypePointeur
    si pointeur.est_référence {
        retourne faux
    }

    retourne pointeur.type_pointé == type_pointé
}

est_struct_ou_employeuse_de :: fonc (info: *InfoTypeStructure, base: *InfoTypeStructure) -> bool
{
    si info == base {
        retourne vrai
    }

    pour info.structs_employées {
        si est_struct_ou_employeuse_de(it, base) {
            retourne vrai
        }
    }

    retourne faux
}

est_pointeur_de :: fonc (info: *InfoType) -> *InfoType
{
    si info == nul {
        retourne nul
    }

    si info.id != id_info.POINTEUR {
        retourne nul
    }

    info_pointeur := info comme *InfoTypePointeur
    si info_pointeur.est_référence {
        retourne nul
    }

    retourne info_pointeur.type_pointé
}

est_pointeur_de_structure :: fonc (info: *InfoType) -> *InfoTypeStructure
{
    type_pointé := est_pointeur_de(info)

    si !type_pointé {
        retourne nul
    }

    si type_pointé.id != id_info.STRUCTURE {
        retourne nul
    }

    retourne type_pointé comme *InfoTypeStructure
}

est_pointeur_de_structure_ou_union :: fonc (info: *InfoType) -> *InfoType
{
    type_pointé := est_pointeur_de(info)

    si !type_pointé {
        retourne nul
    }

    si type_pointé.id != id_info.STRUCTURE && type_pointé.id != id_info.UNION {
        retourne nul
    }

    retourne type_pointé
}
