charge "infos_types"

malloc :: fonc externe (taille : z64) -> *rien
realloc :: fonc externe (ptr : *rien, taille : z64) -> *rien
free :: fonc externe (ptr : *rien) -> rien

// Ce fichier est utiliser pour définir des variables et fonctions de
// bases (« connus par le compilateur ») que tous les modules doivent importer.
// Ceci nous évite d'avoir à manuellement spécifier ces choses dans le
// code du compilateur.
// Par contre, ce fichier ne devrait pas pouvoir être modifié par les
// utilisateurs du langage.

// --------------------------

// Position dans le code source. Quand cette structure est instantiée, le
// compilateur remplis les membres de cette structure avec les valeurs
// correspondantes de la position du lexème dans le fichier où se fait ladite
// construction.
PositionCodeSource :: struct {
    // le nom du fichier où se trouve l'objet
    fichier : chaine
    // le nom de la fonction où se trouve l'objet, vide si variable globale
    fonction : chaine
    // la ligne où se trouve l'objet
    ligne : z32
    // la colonne où se trouve l'objet
    colonne : z32
}

// --------------------------

ModeAllocatrice :: énum z32 {
    ALLOUE
    RÉALLOUE
    DÉSALLOUE
}

BaseAllocatrice :: struct {
    nombre_allocations : z64 = 0
    nombre_réallocations : z64 = 0
    nombre_désallocations : z64 = 0
    mémoire_utilisée : z64 = 0
    pic_de_mémoire : z64 = 0

    // pour pouvoir déterminer quelle type d'allocatrice nous avons
    infos : *InfoTypeStructure = nul

    allocatrice_parente : *BaseAllocatrice = nul
    allocatrice_secours : *BaseAllocatrice = nul
}

initialise_base_allocatrice :: fonc (base : *BaseAllocatrice) -> rien
{
    base.nombre_allocations = 0
    base.nombre_réallocations = 0
    base.nombre_désallocations = 0
    base.mémoire_utilisée = 0
    base.pic_de_mémoire = 0
    base.infos = info_de(mémoire(base))
    base.allocatrice_parente = nul
    base.allocatrice_secours = nul
}

allocatrice_défaut :: fonc(
    mode : ModeAllocatrice,
    nouvelle_taille : z64,
    ancienne_taille : z64,
    ancien_pointeur : *rien,
    données : *BaseAllocatrice,
    info : *InfoType,
    pos : PositionCodeSource) -> *rien
{
    discr mode {
        ALLOUE {
            données.mémoire_utilisée += nouvelle_taille
            données.nombre_allocations += 1

            si données.pic_de_mémoire < données.mémoire_utilisée {
                données.pic_de_mémoire = données.mémoire_utilisée
            }

            retourne malloc(nouvelle_taille)
        }
        RÉALLOUE {
            données.mémoire_utilisée += nouvelle_taille - ancienne_taille
            données.nombre_allocations += 1
            données.nombre_réallocations += 1

            si données.pic_de_mémoire < données.mémoire_utilisée {
                données.pic_de_mémoire = données.mémoire_utilisée
            }

            retourne realloc(ancien_pointeur, nouvelle_taille)
        }
        DÉSALLOUE {
            données.mémoire_utilisée -= ancienne_taille
            données.nombre_désallocations += 1

            free(ancien_pointeur)
            retourne nul
        }
    }

    retourne nul
}

/*
// À FAIRE : considère remplacer loge, déloge, et reloge avec ces fonctions
// À FAIRE : type dépendant (gabarits, il faudra que les types deviennent citoyens de première classe)
// À FAIER : infos types


_loge :: fonc ($t : Type, pos := PositionCodeSource{}) -> *t
{
    info := info_de(t)

    ptr := contexte.allocatrice(
        ModeAllocatrice.ALLOUE,
        info.taille_en_octet,
        0,
        nul,
        contexte.données_allocatrice,
        info,
        pos)

    si ptr == nul {
        avorte_hors_mémoire()
    }

    retourne ptr
}

_reloge :: fonc (ancien_pointeur: *$T, pos := PositionCodeSource{}) -> *$T
{
    info := info_de($T)

    ptr := contexte.allocatrice(
        ModeAllocatrice.RÉALLOUE,
        info.taille_en_octet,
        info.taille_en_octet,
        ancien_pointeur,
        contexte.données_allocatrice,
        info,
        pos)

    retourne ptr
}

_déloge :: fonc (ancien_pointeur: *$T, pos := PositionCodeSource{}) -> *$T
{
    info := info_de($T)

    ptr := contexte.allocatrice(
        ModeAllocatrice.RÉALLOUE,
        info.taille_en_octet,
        0,
        ancien_pointeur,
        contexte.données_allocatrice,
        info,
        pos)

    retourne ptr
}

_reloge :: fonc (ancien_tableau: []$T, nouvelle_taille: z64, pos := PositionCodeSource{}) -> []$T
{
    info := info_de([]$T)

    ptr := contexte.allocatrice(
        ModeAllocatrice.RÉALLOUE,
        ancien_tableau.taille,
        nouvelle_taille,
        ancien_tableau.pointeur,
        contexte.données_allocatrice,
        info,
        pos)

    nouveau_tableau : []$T
    nouveau_tableau.pointeur = ptr
    nouveau_tableau.taille = nouvelle_taille

    retourne nouveau_tableau
}

_déloge :: fonc (ancien_tableau: []$T, pos := PositionCodeSource{}) -> []$T
{
    info := info_de([]$T)

    ptr := ontexte.allocatrice(
        ModeAllocatrice.DÉSALLOUE,
        ancien_tableau.taille,
        0,
        ancien_tableau.pointeur,
        contexte.données_allocatrice,
        info,
        pos)

    nouveau_tableau : []$T
    retourne nouvelle_chaine
}

_reloge :: fonc (ancienne_chaine : chaine, nouvelle_taille : z64, pos := PositionCodeSource{}) -> chaine
{
    info := info_de(chaine)

    ptr := contexte.allocatrice(
        ModeAllocatrice.RÉALLOUE,
        ancienne_chaine.taille,
        nouvelle_taille,
        ancienne_chaine.pointeur,
        contexte.données_allocatrice,
        info,
        pos)

    nouvelle_chaine : chaine
    nouvelle_chaine.pointeur = ptr
    nouvelle_chaine.taille = taille

    retourne nouvelle_chaine
}

_déloge :: fonc (ancienne_chaine: chaine, pos := PositionCodeSource{}) -> chaine
{
    info := info_de(chaine)

    ptr := ontexte.allocatrice(
        ModeAllocatrice.DÉSALLOUE,
        0,
        ancienne_chaine.taille,
        ancienne_chaine.pointeur,
        contexte.données_allocatrice,
        info,
        pos)

    nouvelle_chaine : chaine
    retourne nouvelle_chaine
}

alloue :: fonc(nouvelle_taille: z64) -> *rien
{
    retourne contexte.allocatrice(
        ModeAllocatrice.ALLOUE,
        nouvelle_taille,
        0,
        nul,
        contexte.données_allocatrice,
        nul)
}

réalloue :: fonc (pointeur: *rien, ancienne_taille: z64, nouvelle_taille: z64) -> *rien
{
    retourne contexte.allocatrice(
        ModeAllocatrice.RÉALLOUE,
        nouvelle_taille,
        ancienne_taille,
        pointeur,
        contexte.données_allocatrice,
        nul)
}

désalloue :: fonc (pointeur: *rien, ancienne_taille: z64) -> *rien
{
    retourne contexte.allocatrice(
        ModeAllocatrice.DÉSALLOUE,
        0,
        ancienne_taille,
        pointeur,
        contexte.données_allocatrice,
        nul)
}

// alloue_avec pour changer l'allocatrice
// alloue_tableau, alloue_chaine, etc.
*/

// ----------------------------

ModeLogage :: énum z32 {
    AUCUN
    MINIMAL
    JOURNALIER
    VERBEUX
}

// ----------------------------

// Le StockageTemporaire est un stockage mis en place par le compilateur, qui réserve
// une certaine taille dans l'exécutable où mettre des données temporaire.
// À FAIRE : option de compilation pour définir la taille du stockage temporaire
// on attendra que la métoprogrammation soit ici pour passer les options par celle-ci
StockageTemporaire :: struct {
    données : *octet
    taille : z32
    occupé : z32
    occupation_maximale : z32
}

// Structure passée implicitement à toutes les fonctions non marquées par #!nulctx.
// À FAIRE : permettre aux utilisateurs du langage d'ajouter des variables dans
// cette structure.
ContexteProgramme :: struct {
    allocatrice := allocatrice_défaut
    données_allocatrice : *BaseAllocatrice = nul

    logueur := __logueur_défaut
    données_logueur : *rien = nul

    stockage_temporaire : *StockageTemporaire
}

__logueur_défaut :: fonc (message: chaine, ident: chaine, mode: ModeLogage, données: *rien) -> rien {}

// ----------------------------

// Fonctions de convénience pour accéder aux données sur les allocations
// de l'allocatrice courante du contexte
mémoire_utilisée :: fonc() -> z64 #enligne
{
    retourne contexte.données_allocatrice.mémoire_utilisée
}

pic_de_mémoire :: fonc() -> z64 #enligne
{
    retourne contexte.données_allocatrice.pic_de_mémoire
}

nombre_allocations :: fonc() -> z64 #enligne
{
    retourne contexte.données_allocatrice.nombre_allocations
}

nombre_réallocations :: fonc() -> z64 #enligne
{
    retourne contexte.données_allocatrice.nombre_réallocations
}

nombre_désallocations :: fonc() -> z64 #enligne
{
    retourne contexte.données_allocatrice.nombre_désallocations
}

// ----------------------------
// Implémentation des fonctions du stockage temporaire

obtiens_marque_stockage_temporaire :: fonc () -> z32
{
    retourne contexte.stockage_temporaire.occupé
}

set_marque_stockage_temporaire :: fonc (marque: z32) -> rien
{
    //assert(marque >= 0)
    //assert(marque < contexte.stockage_temporaire.taille)
    contexte.stockage_temporaire.occupé = marque
}

réinitialise_stockage_temporaire :: fonc () -> rien
{
    set_marque_stockage_temporaire(0)
    contexte.stockage_temporaire.occupation_maximale = 0
}

alloc_stockage_temporaire :: fonc (alloc: *StockageTemporaire, nouvelle_taille: z64) -> *rien
{
    si alloc.occupé + nouvelle_taille > alloc.taille {
        // À FAIRE : utilisation de l'allocatrice par défaut
        retourne nul
    }

    ptr := alloc.données + alloc.occupé
    alloc.occupé += transtype(nouvelle_taille: z32)

    si alloc.occupé > alloc.occupation_maximale {
        alloc.occupation_maximale = alloc.occupé
    }

    retourne ptr
}

__stockage_temporaire :: fonc(
    mode : ModeAllocatrice,
    nouvelle_taille : z64,
    ancienne_taille : z64,
    ancien_pointeur : *rien,
    données : *BaseAllocatrice,
    info : *InfoType,
    pos : PositionCodeSource) -> *rien
{
    alloc := transtype(contexte.stockage_temporaire: *StockageTemporaire)

    discr mode {
        ALLOUE {
            retourne alloc_stockage_temporaire(alloc, nouvelle_taille)
        }
        RÉALLOUE {
            ptr := transtype(ancien_pointeur: *octet)

            si ptr == nul {
                retourne alloc_stockage_temporaire(alloc, nouvelle_taille)
            }

            delta := nouvelle_taille - ancienne_taille

            // À FAIRE
            // Nous ne pouvons réallouer que si le pointeur fut le dernier alloué...
            /*
            n := ancienne_taille

            si ptr + n != alloc.ptr {
                retourne nul
            }

            // ... et qu'il y a suffisament de place pour delta

            n = delta  // arrondis_pour_aligner(delta, 8)

            d := transtype(alloc.ptr: z64)
            f := transtype(alloc.début + alloc.données.taille: z64)

            si n > (f - d) {
                retourne nul
            }

		    alloc.ptr += n
            */

            alloc.occupé += transtype(delta: z32)

            si alloc.occupé > alloc.occupation_maximale {
                alloc.occupation_maximale = alloc.occupé
            }

            retourne ancien_pointeur
        }
        DÉSALLOUE {
            // À FAIRE
            alloc.occupé -= transtype(ancienne_taille: z32)
            retourne nul
        }
    }

    retourne nul
}

// fonction de convénience pour loge un tampon dans le stockage temporaire
// principalement utilisé pour loger des chaines avec une terminaison nulle
// afin de pouvoir les passer aux fonctions de C
logement_temp :: fonc(taille: z64) -> *octet
{
    nouveau_contexte := contexte
    nouveau_contexte.allocatrice = __stockage_temporaire

    ptr : *octet

    pousse_contexte nouveau_contexte {
        tmp := loge [taille]octet
        ptr = tmp.pointeur
    }

    retourne ptr
}

// -----------------------------

// Fonctions de bases pour les opérateurs de comparaisons de chaines
opérateur == :: fonc(chn1: chaine, chn2: chaine) -> bool
{
    si chn1.taille != chn2.taille {
		retourne faux
    }

	taille := chn1.taille
	début : z64 = 0

    pour i dans début...(taille - 1) {
        si chn1[i] != chn2[i] {
			retourne faux
        }
    }

	retourne vrai
}

opérateur != :: fonc(chn1: chaine, chn2: chaine) -> bool
{
    retourne !(chn1 == chn2)
}

/*
    while (*s1 == *s2++)
        if (*s1++ == 0)
            return (0);
    return (*(const unsigned char *)s1 - *(const unsigned char *)(s2 - 1));
*/
compare_chaine :: fonc (chn1: chaine, chn2: chaine) -> z32
{
    pour c, i dans chn1 {
        si i == chn2.taille {
            retourne 1
        }

        si chn2[i] > c {
            retourne -1
        }

        si c > chn2[i] {
            retourne 1
        }
    }

    si chn1.taille < chn2.taille {
        retourne -1
    }

    retourne 0
}

opérateur < :: fonc(chn1: chaine, chn2: chaine) -> bool
{
    retourne compare_chaine(chn1, chn2) < 0
}

opérateur <= :: fonc(chn1: chaine, chn2: chaine) -> bool
{
    retourne compare_chaine(chn1, chn2) <= 0
}

opérateur > :: fonc(chn1: chaine, chn2: chaine) -> bool
{
    retourne compare_chaine(chn1, chn2) > 0
}

opérateur >= :: fonc(chn1: chaine, chn2: chaine) -> bool
{
    retourne compare_chaine(chn1, chn2) >= 0
}

/*
test_compare_chaine_impl :: fonc (chn1: chaine, chn2: chaine, attendu: z32) -> rien
{
    résultat := mon_compare_chaine(chn1, chn2)

    si résultat != attendu {
        imprime("Erreur : le résultat de compare_chaine pour '%' et '%' doit être de %, mais eu %\n", chn1, chn2, attendu, résultat)
    }
}

test_compare_chaine :: fonc () -> rien
{
    test_compare_chaine_impl("", "", 0)
    test_compare_chaine_impl("", "abc", -1)
    test_compare_chaine_impl("abc", "", 1)
    test_compare_chaine_impl("abc", "def", -1)
    test_compare_chaine_impl("abc", "abcd", -1)
    test_compare_chaine_impl("abc", "ABC", 1)
    test_compare_chaine_impl("abc", "abc", 0)
    test_compare_chaine_impl("Prashant", "Surendra", -1)
    test_compare_chaine_impl("Surendra", "Jaya", 1)
    test_compare_chaine_impl("Jaya", "Shruti", -1)
    test_compare_chaine_impl("Shruti", "Mangala", 1)
}
*/

// Fonctions basiques pour les tableaux

tableau_ajoute :: fonc (tabl: *[]$T, valeur: $T) -> rien
{
    tmp := mémoire(tabl)

    si tmp.taille == tmp.capacité {
        capacité := tmp.capacité
        reloge tmp: [capacité + 1]$T
    }

    tmp.taille += 1
    tmp[tmp.taille - 1] = valeur

    mémoire(tabl) = tmp
}

tableau_réserve :: fonc(tabl: *[]$T, taille: z64) -> rien
{
    si taille <= tabl.capacité {
        retourne
    }

	tmp := mémoire(tabl)

	reloge tmp : [taille]$T

	mémoire(tabl) = tmp
}

tableau_copie :: fonc(tabl: []$T) -> []$T
{
	tmp := loge [tabl.capacité]$T
    copie_mem_nonsur(src = tabl.pointeur, dst = tabl.pointeur, taille = tabl.taille * transtype(taille_de(z64): z64))
    tmp.taille = tabl.taille
    retourne tmp
}

tableau_insère :: fonc(tabl: *[]$T, index: z32, valeur: $T) -> rien
{
	tmp := mémoire(tabl)
	tmp[index] = valeur
	mémoire(tabl) = tmp
}

tableau_supprime :: fonc(tabl: *[]$T, index: z32) -> rien
{
	si index < 0 || index >= tabl.taille {
		retourne
	}

	tmp := mémoire(tabl)

	taille := tabl.taille

	pour i dans transtype(index: z64) ... taille - 2 {
		tmp[i] = tmp[i + 1]
	}

	reloge tmp : [taille - 1]$T

	mémoire(tabl) = tmp
}

// --------------------------------

externe __ARGV : **z8
externe __ARGC : z32

strlen :: fonc externe (str: *z8) -> z64

arguments_ligne_commande :: fonc () -> []chaine
{
    tabl_args : []chaine

    si __ARGC == 0 {
        retourne tabl_args
    }

    nouveau_contexte := contexte
    nouveau_contexte.allocatrice = __stockage_temporaire

    pousse_contexte nouveau_contexte {
        tabl_args = loge [__ARGC]chaine

        pour idx dans 0 ... __ARGC - 1 {
            chn : chaine
            chn.pointeur = __ARGV[idx]
            chn.taille = strlen(__ARGV[idx])
            tableau_ajoute(@tabl_args, chn)
        }

        retourne tabl_args
    }
}

/*
avorte_dépassement_limites_tableau :: fonc (
    taille: z64,
    index: z64,
    pos : PositionCodeSource) -> rien
{
    imprime("%:%\n", pos.fichier, pos.ligne)
    imprime("Dépassements des limites du tableau !\n")
    imprime("La taille est de % mais l'index est de %\n", taille, index)
    abort()
}

avorte_dépassement_limites_chaine :: fonc (
    taille: z64,
    index: z64,
    pos : PositionCodeSource) -> rien
{
    imprime("%:%\n", pos.fichier, pos.ligne)
    imprime("Dépassements des limites de la chaine !\n")
    imprime("La taille est de % mais l'index est de %\n", taille, index)
    abort()
}

avorte_hors_mémoire :: fonc (
    pos : PositionCodeSource) -> rien
{
    imprime("%:%\n", pos.fichier, pos.ligne)
    imprime("Impossible d'allouer de la mémoire !\n")
    abort()
}

avorte_accès_union :: fonc (
    pos : PositionCodeSource) -> rien
{
    imprime("%:%\n", pos.fichier, pos.ligne)
    imprime("Impossible d'accèder au membre de l'union car il n'est pas actif !\n")
    abort()
}
*/
