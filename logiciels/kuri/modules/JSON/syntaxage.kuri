importe Fondation
importe Tori

charge "assemblage_objet"
charge "lexage"

SyntaxeuseJSON :: struct {
	lexèmes : []DonneesLexèmeJSON
    assembleuse : AssembleuseObjet

	position := 0
}

construit_syntaxeuse :: fonc(lexèmes : &[]DonneesLexèmeJSON) -> SyntaxeuseJSON
{
	syntaxeuse : SyntaxeuseJSON
	syntaxeuse.lexèmes = lexèmes

	retourne syntaxeuse
}

détruit :: fonc(syntaxeuse : &SyntaxeuseJSON) -> rien
{
    détruit(syntaxeuse.assembleuse)
}

lexème_courant :: fonc(syntaxeuse : &SyntaxeuseJSON) -> TypeLexèmeJSON
{
	retourne syntaxeuse.lexèmes[syntaxeuse.position].lexème
}

avance :: fonc(syntaxeuse : &SyntaxeuseJSON) -> rien
{
	syntaxeuse.position += 1
}

requiers_lexème :: fonc(syntaxeuse : &SyntaxeuseJSON, type : TypeLexèmeJSON) -> bool
{
	t := syntaxeuse.lexème_courant()
	syntaxeuse.avance()
	retourne t == type
}

est_lexème :: fonc(syntaxeuse : &SyntaxeuseJSON, type : TypeLexèmeJSON) -> bool
{
	retourne syntaxeuse.lexème_courant() == type
}

données :: fonc(syntaxeuse : &SyntaxeuseJSON) -> &DonneesLexèmeJSON
{
	retourne syntaxeuse.lexèmes[syntaxeuse.position - 1]
}

analyse_objet :: fonc(syntaxeuse : &SyntaxeuseJSON) -> rien
{
	si (!syntaxeuse.requiers_lexème(TypeLexèmeJSON.CHAINE_CARACTERE)) {
		//lance_erreur("Attendu une chaine de caractère")
	}

	nom_objet := syntaxeuse.données().chn

	si (!syntaxeuse.requiers_lexème(TypeLexèmeJSON.DOUBLE_POINTS)) {
		//lance_erreur("Attendu un double-point ':'")
	}

	syntaxeuse.analyse_valeur(nom_objet)

	si (syntaxeuse.est_lexème(TypeLexèmeJSON.VIRGULE)) {
		syntaxeuse.avance()
		syntaxeuse.analyse_objet()
	}
}

analyse_valeur :: fonc(syntaxeuse : &SyntaxeuseJSON, nom_objet : chaine) -> rien
{
	discr syntaxeuse.lexème_courant() {
		ACCOLADE_OUVRANTE {
			syntaxeuse.avance()

			obj := syntaxeuse.assembleuse.crée_objet(nom_objet, TypeObjet.DICTIONNAIRE)
			syntaxeuse.assembleuse.empile_objet(obj)

			syntaxeuse.analyse_objet()

			syntaxeuse.assembleuse.dépile_objet()

			si (!syntaxeuse.requiers_lexème(TypeLexèmeJSON.ACCOLADE_FERMANTE)) {
				//lance_erreur("Attendu une accolade fermante '}' à la fin de l'objet")
			}
		}
		CROCHET_OUVRANT {
			syntaxeuse.avance()

			obj := syntaxeuse.assembleuse.crée_objet(nom_objet, TypeObjet.LISTE)
			syntaxeuse.assembleuse.empile_objet(obj)

			tantque !syntaxeuse.est_lexème(TypeLexèmeJSON.CROCHET_FERMANT) {
				syntaxeuse.analyse_valeur("")

				si (syntaxeuse.est_lexème(TypeLexèmeJSON.VIRGULE)) {
					syntaxeuse.avance()
				}
			}

			syntaxeuse.assembleuse.dépile_objet()

			syntaxeuse.avance()
		}
		NOMBRE_ENTIER {
			syntaxeuse.avance()

			obj := syntaxeuse.assembleuse.crée_objet(nom_objet, TypeObjet.ENTIER)
			obj_entier := obj comme *ObjetEntier
            obj_entier.valeur = extrait_nombre_entier(syntaxeuse.données().chn)
		}
		NOMBRE_REEL {
			syntaxeuse.avance()

			obj := syntaxeuse.assembleuse.crée_objet(nom_objet, TypeObjet.RÉEL)
			obj_réel := obj comme *ObjetRéel
            obj_réel.valeur = extrait_nombre_réel(syntaxeuse.données().chn)
		}
		CHAINE_CARACTERE {
			syntaxeuse.avance()

			obj := syntaxeuse.assembleuse.crée_objet(nom_objet, TypeObjet.CHAINE)
			obj_chaine := obj comme *ObjetChaine
            obj_chaine.valeur = syntaxeuse.données().chn

			// À FAIRE: gestion des chaines allouées dynamiquement
			//res = dls::chaine()

			//for (i = 0 i < donnees().chaine.taille() ++i) {
			//	c = donnees().chaine[i]

			//	si (c == '\\') {
			//		continue
			//	}

			//	res += c
			//}
		}
		sinon {
			syntaxeuse.avance()
			// À FAIRE : lance_erreur("Élément inattendu")
		}
	}
}

lance_analyse :: fonc(syntaxeuse : &SyntaxeuseJSON) -> rien
{
	syntaxeuse.position = 0

	si (syntaxeuse.lexèmes.taille == 0) {
		retourne
	}

	si (!syntaxeuse.requiers_lexème(TypeLexèmeJSON.ACCOLADE_OUVRANTE)) {
		//lance_erreur("Attendu une accolade ouvrante '{' au début du script")
	}

    obj := syntaxeuse.assembleuse.crée_objet("", TypeObjet.DICTIONNAIRE)
	syntaxeuse.assembleuse.empile_objet(obj)

	syntaxeuse.analyse_objet()

    // Ne dépile pas le dictionnaire, car il est la racine

	si (!syntaxeuse.requiers_lexème(TypeLexèmeJSON.ACCOLADE_FERMANTE)) {
		//lance_erreur("Attendu une accolade fermante '}' à la fin du script")
	}

	//imprime_arbre(syntaxeuse.assembleuse.racine.get(), 0, std::cerr)
}
