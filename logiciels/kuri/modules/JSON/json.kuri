importe Fondation

imprime_valeur_json :: fonc (enchaineuse: *Enchaineuse, pointeur: *z8, info: *InfoType) -> rien
{
    discr info.id {
		OCTET {
			x := mémoire(pointeur comme *octet)
            chiffres_hex := "0123456789ABCDEF"

			chiffre := (x >> 4 comme octet) & 0x0F comme octet
			ajoute_au_tampon(enchaineuse, chiffres_hex[chiffre])

			chiffre = x & 0x0F comme octet
			ajoute_au_tampon(enchaineuse, chiffres_hex[chiffre])
		}
		ENTIER {
			info_arg := info comme *InfoTypeEntier

            e : eini
            e.pointeur = pointeur
            e.info = info_arg

            imprime_nombre_entier(enchaineuse, FormatEntier(valeur = e))
		}
		RÉEL {
			y : r32

            si info.taille_en_octet == 2 {
				x := mémoire(pointeur comme *r16)
				y = x
			}
			sinon si info.taille_en_octet == 4 {
				y = mémoire(pointeur comme *r32)
			}
			sinon si info.taille_en_octet == 8 {
				x := mémoire(pointeur comme *r64)
				y = x comme r32
			}

			imprime_nombre_réel(enchaineuse, FormatRéel(valeur = y))
		}
		BOOLÉEN {
			x := mémoire(pointeur comme *bool)

            si x {
				ajoute_au_tampon(enchaineuse, "true")
			}
			sinon {
				ajoute_au_tampon(enchaineuse, "false")
			}
		}
		CHAINE {
			x := mémoire(pointeur comme *chaine)

			ajoute_au_tampon(enchaineuse, '"')
			ajoute_au_tampon(enchaineuse, x)
			ajoute_au_tampon(enchaineuse, '"')
		}
		STRUCTURE {
			info_arg := info comme *InfoTypeStructure

            ajoute_au_tampon(enchaineuse, "{")

            pour membre, idx dans info_arg.membres {
				nom := membre.nom
                décalage := membre.décalage
				id := membre.id

                si idx != 0 {
                    ajoute_au_tampon(enchaineuse, ',')
                }

                ajoute_au_tampon(enchaineuse, '"')
                ajoute_au_tampon(enchaineuse, nom)
                ajoute_au_tampon(enchaineuse, '"')
                ajoute_au_tampon(enchaineuse, ":")

				imprime_valeur_json(enchaineuse, pointeur + décalage, id)
			}

            ajoute_au_tampon(enchaineuse, "}")
		}
		TABLEAU {
			info_arg := info comme *InfoTypeTableau

            ajoute_au_tampon(enchaineuse, "[")

            décalage := info_arg.type_pointé.taille_en_octet comme z32

            si info_arg.est_tableau_fixe {
                pour i dans 0 ... info_arg.taille_fixe - 1 {
                    si i != 0 {
                        ajoute_au_tampon(enchaineuse, ',')
                    }

                    imprime_valeur_json(enchaineuse, pointeur + décalage * i, info_arg.type_pointé)
                }
            }
            sinon {
                x := mémoire(pointeur comme *[]z8)

                pour i dans 0 ... x.taille - 1 {
                    si i != 0 {
                        ajoute_au_tampon(enchaineuse, ',')
                    }

                    imprime_valeur_json(enchaineuse, x.pointeur + décalage * i, info_arg.type_pointé)
                }
            }

            ajoute_au_tampon(enchaineuse, "]")
		}
		ÉNUM {
			info_arg := info comme *InfoTypeÉnum

			// À FAIRE(langage) : typage selon énum
			valeur := mémoire(pointeur comme *z32)
			noms := info_arg.noms

			si info_arg.est_drapeau {
				valeur_trouvée := faux

				pour v, i dans info_arg.valeurs {
					si (v & valeur) != 0 {
						si valeur_trouvée {
							ajoute_au_tampon(enchaineuse, " | ")
						}

						ajoute_au_tampon(enchaineuse, noms[i])
						valeur_trouvée = vrai
					}
				}

				si !valeur_trouvée {
					ajoute_au_tampon(enchaineuse, "0")
				}
			}
			sinon {
				pour v, i dans info_arg.valeurs {
					si v == valeur {
						ajoute_au_tampon(enchaineuse, noms[i])
						arrête
					}
				}
			}
		}
        sinon {
            ajoute_au_tampon(enchaineuse, "null")
        }
	}
}

// -----------------------------------

// une syntaxeuse qui met directement les données dans une structure
SyntaxeuseStruct :: struct {
	lexèmes : []DonneesLexèmeJSON

	position := 0
}

construit_syntaxeuse_struct :: fonc(lexèmes : []DonneesLexèmeJSON) -> SyntaxeuseStruct
{
	syntaxeuse : SyntaxeuseStruct
	syntaxeuse.lexèmes = lexèmes

	retourne syntaxeuse
}

lexème_courant :: fonc(syntaxeuse : *SyntaxeuseStruct) -> TypeLexèmeJSON
{
	retourne syntaxeuse.lexèmes[syntaxeuse.position].lexème
}

avance :: fonc(syntaxeuse : *SyntaxeuseStruct) -> rien
{
	syntaxeuse.position += 1
}

requiers_lexème :: fonc(syntaxeuse : *SyntaxeuseStruct, type : TypeLexèmeJSON) -> bool
{
	t := syntaxeuse.lexème_courant()
	syntaxeuse.avance()
	retourne t == type
}

est_lexème :: fonc(syntaxeuse : *SyntaxeuseStruct, type : TypeLexèmeJSON) -> bool
{
	retourne syntaxeuse.lexème_courant() == type
}

données :: fonc(syntaxeuse : *SyntaxeuseStruct) -> &DonneesLexèmeJSON
{
	retourne syntaxeuse.lexèmes[syntaxeuse.position - 1]
}

analyse_objet :: fonc(
    syntaxeuse : *SyntaxeuseStruct,
    pointeur_arg: *z8,
    info_arg: *InfoTypeStructure) -> rien
{
	si (!syntaxeuse.requiers_lexème(TypeLexèmeJSON.CHAINE_CARACTERE)) {
		//lance_erreur("Attendu une chaine de caractère")
        retourne
	}

	nom_objet := syntaxeuse.données().chn

    // cherche le nom de l'objet dans l'InfoTypeStructure
    info_membre : *InfoTypeMembreStructure = nul

    pour membre dans info_arg.membres {
        si membre.nom == nom_objet {
            info_membre = membre
            arrête
        }
    }

    si info_membre == nul {
        // À FAIRE : erreur
        retourne
    }

	si (!syntaxeuse.requiers_lexème(TypeLexèmeJSON.DOUBLE_POINTS)) {
		//lance_erreur("Attendu un double-point ':'")
        retourne
	}

    pointeur_membre := pointeur_arg + info_membre.décalage

	syntaxeuse.analyse_valeur(nom_objet, pointeur_membre, info_membre.id)

	si (syntaxeuse.est_lexème(TypeLexèmeJSON.VIRGULE)) {
		syntaxeuse.avance()
		syntaxeuse.analyse_objet(pointeur_arg, info_arg)
	}
}

analyse_valeur :: fonc(
    syntaxeuse : *SyntaxeuseStruct,
    nom_objet : chaine,
    pointeur_membre: *z8,
    info_membre: *InfoType) -> rien
{
	discr syntaxeuse.lexème_courant() {
		ACCOLADE_OUVRANTE {
			syntaxeuse.avance()

            si info_membre.id != id_info.STRUCTURE {
                retourne
            }

			syntaxeuse.analyse_objet(pointeur_membre, info_membre comme *InfoTypeStructure)

			si (!syntaxeuse.requiers_lexème(TypeLexèmeJSON.ACCOLADE_FERMANTE)) {
				//lance_erreur("Attendu une accolade fermante '}' à la fin de l'objet")
			}
		}
		CROCHET_OUVRANT {
			syntaxeuse.avance()

			tantque !syntaxeuse.est_lexème(TypeLexèmeJSON.CROCHET_FERMANT) {
                // À FAIRE
				//syntaxeuse.analyse_valeur("")

				si (syntaxeuse.est_lexème(TypeLexèmeJSON.VIRGULE)) {
					syntaxeuse.avance()
				}
			}


			syntaxeuse.avance()
		}
		NOMBRE_ENTIER {
			syntaxeuse.avance()

            si info_membre.id != id_info.ENTIER {
                retourne
            }

            // À FAIRE: typage
            ptr := pointeur_membre comme *z32
            mémoire(ptr) = extrait_nombre_entier(syntaxeuse.données().chn) comme z32
		}
		NOMBRE_REEL {
			syntaxeuse.avance()

            si info_membre.id != id_info.RÉEL {
                retourne
            }

            // À FAIRE: typage
            ptr := pointeur_membre comme *r32
            mémoire(ptr) = extrait_nombre_réel(syntaxeuse.données().chn) comme r32
		}
		CHAINE_CARACTERE {
			syntaxeuse.avance()

            si info_membre.id != id_info.CHAINE {
                retourne
            }

            ptr := pointeur_membre comme *chaine
            mémoire(ptr) = syntaxeuse.données().chn
		}
		sinon {
			syntaxeuse.avance()
			// À FAIRE : lance_erreur("Élément inattendu")
		}
	}
}

lance_analyse :: fonc(syntaxeuse : *SyntaxeuseStruct, arg: eini) -> rien
{
	syntaxeuse.position = 0

	si (syntaxeuse.lexèmes.taille == 0) {
		retourne
	}

	si (!syntaxeuse.requiers_lexème(TypeLexèmeJSON.ACCOLADE_OUVRANTE)) {
		//lance_erreur("Attendu une accolade ouvrante '{' au début du script")
	}

	syntaxeuse.analyse_objet(arg.pointeur, arg.info comme *InfoTypeStructure)

	si (!syntaxeuse.requiers_lexème(TypeLexèmeJSON.ACCOLADE_FERMANTE)) {
		//lance_erreur("Attendu une accolade fermante '}' à la fin du script")
	}
}

// -----------------------------------

chaine_json_depuis_struct :: fonc (arg: eini) -> chaine
{
    enchaineuse : Enchaineuse
	initialise_enchaineuse(*enchaineuse)
    diffère { détruit_tampons(*enchaineuse) }

    imprime_valeur_json(*enchaineuse, arg.pointeur, arg.info)

	retourne chaine_depuis_enchaineuse(*enchaineuse)
}

remplis_struct_depuis_json :: fonc (script: chaine, arg: eini) -> rien
{
    lexeuse := construit_lexeuse(script)
    diffère { détruit_lexeuse(lexeuse); }

    lexeuse.performe_lexage()

    syntaxeuse := construit_syntaxeuse_struct(lexeuse.lexèmes)

    lance_analyse(*syntaxeuse, arg)
}
