importe Fondation
importe Introspection

imprime_valeur_json :: fonc (enchaineuse: *Enchaineuse, valeur: eini) -> rien
{
    discr valeur.info.id {
		OCTET {
            imprime_nombre_entier(enchaineuse, FormatEntier(valeur = valeur))
		}
		ENTIER {
            imprime_nombre_entier(enchaineuse, FormatEntier(valeur = valeur))
		}
		RÉEL {
			imprime_nombre_réel(enchaineuse, FormatRéel(valeur = valeur))
		}
		BOOLÉEN {
			valeur_ := valeur.comme_bool()

            si valeur_ {
				ajoute_au_tampon(enchaineuse, "true")
			}
			sinon {
				ajoute_au_tampon(enchaineuse, "false")
			}
		}
		CHAINE {
			ajoute_au_tampon(enchaineuse, "\"", valeur.comme_chaine(), "\"")
		}
		STRUCTURE {
			info_arg := valeur.info comme *InfoTypeStructure

            ajoute_au_tampon(enchaineuse, "{")
			idx := 0

            pour membre dans info_arg.membres {
				si (membre.drapeaux & InfoTypeMembreStructure.Drapeaux.EST_CONSTANT) != 0 {
					continue
				}

				nom := membre.nom
                décalage := membre.décalage

                si idx != 0 {
                    ajoute_au_tampon(enchaineuse, ',')
                }

				ajoute_au_tampon(enchaineuse, "\"", nom, "\":")

				valeur_membre : eini = ---
				valeur_membre.pointeur = valeur.pointeur + décalage
				valeur_membre.info = membre.id

				imprime_valeur_json(enchaineuse, valeur_membre)

				idx += 1
			}

            ajoute_au_tampon(enchaineuse, "}")
		}
		TABLEAU {
			index := 0
			itératrice := crée_itératrice_tableau(valeur)

            ajoute_au_tampon(enchaineuse, "[")

			boucle {
				valeur_ := itératrice.valeur_suivante()

				saufsi valeur_.est_valide() {
					arrête
				}

				si index != 0 {
					ajoute_au_tampon(enchaineuse, ',')
				}

                imprime_valeur(enchaineuse, valeur_, vrai)
				index += 1
			}

            ajoute_au_tampon(enchaineuse, "]")
		}
		ÉNUM {
			info_arg := valeur.info comme *InfoTypeÉnum

			// À FAIRE(langage) : typage selon énum
			valeur_ := mémoire(valeur.pointeur comme *z32)
			noms := info_arg.noms

			si info_arg.est_drapeau {
				valeur_trouvée := faux

				pour v, i dans info_arg.valeurs {
					si (v & valeur_) != 0 {
						si valeur_trouvée {
							ajoute_au_tampon(enchaineuse, " | ")
						}

						ajoute_au_tampon(enchaineuse, noms[i])
						valeur_trouvée = vrai
					}
				}

				si !valeur_trouvée {
					ajoute_au_tampon(enchaineuse, "0")
				}
			}
			sinon {
				pour v, i dans info_arg.valeurs {
					si v == valeur_ {
						ajoute_au_tampon(enchaineuse, noms[i])
						arrête
					}
				}
			}
		}
		OPAQUE {
			info_arg := valeur.info comme *InfoTypeOpaque
			valeur.info = info_arg.type_opacifié
			imprime_valeur(enchaineuse, valeur, vrai)
		}
        sinon {
            ajoute_au_tampon(enchaineuse, "null")
        }
	}
}

// -----------------------------------

// une syntaxeuse qui met directement les données dans une structure
SyntaxeuseStruct :: struct {
	lexèmes : []DonneesLexèmeJSON

	position := 0
}

construit_syntaxeuse_struct :: fonc(lexèmes : []DonneesLexèmeJSON) -> SyntaxeuseStruct
{
	syntaxeuse : SyntaxeuseStruct
	syntaxeuse.lexèmes = lexèmes

	retourne syntaxeuse
}

lexème_courant :: fonc(syntaxeuse : *SyntaxeuseStruct) -> TypeLexèmeJSON
{
	retourne syntaxeuse.lexèmes[syntaxeuse.position].lexème
}

avance :: fonc(syntaxeuse : *SyntaxeuseStruct) -> rien
{
	syntaxeuse.position += 1
}

requiers_lexème :: fonc(syntaxeuse : *SyntaxeuseStruct, type : TypeLexèmeJSON) -> bool
{
	t := syntaxeuse.lexème_courant()
	syntaxeuse.avance()
	retourne t == type
}

est_lexème :: fonc(syntaxeuse : *SyntaxeuseStruct, type : TypeLexèmeJSON) -> bool
{
	retourne syntaxeuse.lexème_courant() == type
}

données :: fonc(syntaxeuse : *SyntaxeuseStruct) -> &DonneesLexèmeJSON
{
	retourne syntaxeuse.lexèmes[syntaxeuse.position - 1]
}

analyse_objet :: fonc(
    syntaxeuse : *SyntaxeuseStruct,
    pointeur_arg: *z8,
    info_arg: *InfoTypeStructure) -> rien
{
	si (!syntaxeuse.requiers_lexème(TypeLexèmeJSON.CHAINE_CARACTERE)) {
		//lance_erreur("Attendu une chaine de caractère")
        retourne
	}

	nom_objet := syntaxeuse.données().chn

    // cherche le nom de l'objet dans l'InfoTypeStructure
    info_membre : *InfoTypeMembreStructure = nul

    pour membre dans info_arg.membres {
        si membre.nom == nom_objet {
            info_membre = membre
            arrête
        }
    }

    si info_membre == nul {
        // À FAIRE : erreur
        retourne
    }

	si (!syntaxeuse.requiers_lexème(TypeLexèmeJSON.DOUBLE_POINTS)) {
		//lance_erreur("Attendu un double-point ':'")
        retourne
	}

    pointeur_membre := pointeur_arg + info_membre.décalage

	syntaxeuse.analyse_valeur(nom_objet, pointeur_membre, info_membre.id)

	si (syntaxeuse.est_lexème(TypeLexèmeJSON.VIRGULE)) {
		syntaxeuse.avance()
		syntaxeuse.analyse_objet(pointeur_arg, info_arg)
	}
}

analyse_valeur :: fonc(
    syntaxeuse : *SyntaxeuseStruct,
    nom_objet : chaine,
    pointeur_membre: *z8,
    info_membre: *InfoType) -> rien
{
	discr syntaxeuse.lexème_courant() {
		ACCOLADE_OUVRANTE {
			syntaxeuse.avance()

            si info_membre.id != id_info.STRUCTURE {
                retourne
            }

			syntaxeuse.analyse_objet(pointeur_membre, info_membre comme *InfoTypeStructure)

			si (!syntaxeuse.requiers_lexème(TypeLexèmeJSON.ACCOLADE_FERMANTE)) {
				//lance_erreur("Attendu une accolade fermante '}' à la fin de l'objet")
			}
		}
		CROCHET_OUVRANT {
			syntaxeuse.avance()

			tantque !syntaxeuse.est_lexème(TypeLexèmeJSON.CROCHET_FERMANT) {
                // À FAIRE
				//syntaxeuse.analyse_valeur("")

				si (syntaxeuse.est_lexème(TypeLexèmeJSON.VIRGULE)) {
					syntaxeuse.avance()
				}
			}


			syntaxeuse.avance()
		}
		NOMBRE_ENTIER {
			syntaxeuse.avance()

            si info_membre.id != id_info.ENTIER {
                retourne
            }

            // À FAIRE: typage
            ptr := pointeur_membre comme *z32
            mémoire(ptr) = extrait_nombre_entier(syntaxeuse.données().chn) comme z32
		}
		NOMBRE_REEL {
			syntaxeuse.avance()

            si info_membre.id != id_info.RÉEL {
                retourne
            }

            // À FAIRE: typage
            ptr := pointeur_membre comme *r32
            mémoire(ptr) = extrait_nombre_réel(syntaxeuse.données().chn) comme r32
		}
		CHAINE_CARACTERE {
			syntaxeuse.avance()

            si info_membre.id != id_info.CHAINE {
                retourne
            }

            ptr := pointeur_membre comme *chaine
            mémoire(ptr) = syntaxeuse.données().chn
		}
		sinon {
			syntaxeuse.avance()
			// À FAIRE : lance_erreur("Élément inattendu")
		}
	}
}

lance_analyse :: fonc(syntaxeuse : *SyntaxeuseStruct, arg: eini) -> rien
{
	syntaxeuse.position = 0

	si (syntaxeuse.lexèmes.taille == 0) {
		retourne
	}

	si (!syntaxeuse.requiers_lexème(TypeLexèmeJSON.ACCOLADE_OUVRANTE)) {
		//lance_erreur("Attendu une accolade ouvrante '{' au début du script")
	}

	syntaxeuse.analyse_objet(arg.pointeur, arg.info comme *InfoTypeStructure)

	si (!syntaxeuse.requiers_lexème(TypeLexèmeJSON.ACCOLADE_FERMANTE)) {
		//lance_erreur("Attendu une accolade fermante '}' à la fin du script")
	}
}

// -----------------------------------

chaine_json_depuis_struct :: fonc (arg: eini) -> chaine
{
    enchaineuse : Enchaineuse
	initialise_enchaineuse(*enchaineuse)
    diffère { détruit_tampons(*enchaineuse) }

    imprime_valeur_json(*enchaineuse, arg)

	retourne chaine_depuis_enchaineuse(*enchaineuse)
}

remplis_struct_depuis_json :: fonc (script: chaine, arg: eini) -> rien
{
    lexeuse := construit_lexeuse(script)
    diffère { détruit_lexeuse(lexeuse); }

    lexeuse.performe_lexage()

    syntaxeuse := construit_syntaxeuse_struct(lexeuse.lexèmes)

    lance_analyse(*syntaxeuse, arg)
}
