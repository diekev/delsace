importe Fondation

//##############################################################################

TypeLexèmeJSON :: énum z32 {
	INCONNU

	PARENTHESE_OUVRANTE
	PARENTHESE_FERMANTE
	VIRGULE
	DOUBLE_POINTS
	CROCHET_OUVRANT
	CROCHET_FERMANT
	ACCOLADE_OUVRANTE
	ACCOLADE_FERMANTE
	CHAINE_CARACTERE
	NOMBRE_ENTIER
	NOMBRE_REEL
	NOMBRE_BINAIRE
	NOMBRE_OCTAL
	NOMBRE_HEXADECIMAL
}

DonneesLexèmeJSON :: struct {
	chn : chaine
	lexème : TypeLexèmeJSON
}

est_caractère_spécial :: fonc(c : z8) -> bool, TypeLexèmeJSON
{
    discr c {
        '(' { retourne vrai, TypeLexèmeJSON.PARENTHESE_OUVRANTE }
        ')' { retourne vrai, TypeLexèmeJSON.PARENTHESE_FERMANTE }
        ',' { retourne vrai, TypeLexèmeJSON.VIRGULE }
        ':' { retourne vrai, TypeLexèmeJSON.DOUBLE_POINTS }
        '[' { retourne vrai, TypeLexèmeJSON.CROCHET_OUVRANT }
        ']' { retourne vrai, TypeLexèmeJSON.CROCHET_FERMANT }
        '{' { retourne vrai, TypeLexèmeJSON.ACCOLADE_OUVRANTE }
        '}' { retourne vrai, TypeLexèmeJSON.ACCOLADE_FERMANTE }
    }

    retourne faux, TypeLexèmeJSON.INCONNU
}

LexeuseJSON :: struct {
    tampon : chaine
    début_mot : *z8 = nul
    début : *z8 = nul
    fin : *z8 = nul

    lexèmes : []DonneesLexèmeJSON

    taille_mot_courant := 0
    compte_ligne := 0
    position_ligne := 0
    pos_mot := 0
}

construit_lexeuse :: fonc(chn : chaine) -> LexeuseJSON
{
    dyn lexeuse : LexeuseJSON
    lexeuse.tampon = chn
    lexeuse.début_mot = @chn[0]
    lexeuse.début = @chn[0]
    lexeuse.fin = lexeuse.début + chn.taille

    retourne lexeuse
}

détruit_lexeuse :: fonc(dyn lexeuse : &LexeuseJSON) -> rien
{
    déloge lexeuse.lexèmes
}

a_fini :: fonc(dyn lexeuse : &LexeuseJSON) -> bool
{
	retourne lexeuse.début >= lexeuse.fin
}

caractère_courant :: fonc(dyn lexeuse : &LexeuseJSON) -> z8
{
    retourne mémoire(lexeuse.début)
}

caractère_courant :: fonc(dyn lexeuse : &LexeuseJSON, n : z32) -> z8
{
    retourne mémoire(lexeuse.début + n)
}

avance :: fonc(dyn lexeuse : &LexeuseJSON, n : z32) -> rien
{
	pour i dans 0 ... n - 1 {
		si (lexeuse.caractère_courant() == '\n') {
			lexeuse.compte_ligne += 1
			lexeuse.position_ligne = 0
		}
		sinon {
			lexeuse.position_ligne += 1
		}

		lexeuse.début += 1
	}
}

pousse_caractère :: fonc(dyn lexeuse : &LexeuseJSON) -> rien
{
	lexeuse.taille_mot_courant += 1
}

mot_courant :: fonc(dyn lexeuse : &LexeuseJSON) -> chaine
{
	retourne construit_chaine(lexeuse.début_mot, lexeuse.taille_mot_courant)
}

pousse_mot :: fonc(dyn lexeuse : &LexeuseJSON, lexème : TypeLexèmeJSON) -> rien
{
    dyn données : DonneesLexèmeJSON
    données.lexème = lexème
    données.chn = lexeuse.mot_courant()

    tableau_ajoute(@lexeuse.lexèmes, données)

    lexeuse.taille_mot_courant = 0
	lexeuse.début_mot = nul
}

enregistre_position_mot :: fonc(dyn lexeuse : &LexeuseJSON) -> rien
{
	lexeuse.pos_mot = lexeuse.position_ligne
	lexeuse.début_mot = lexeuse.début
}

performe_lexage :: fonc(dyn lexeuse : &LexeuseJSON) -> rien
{
    tantque !lexeuse.a_fini() {
		// À FAIRE : permet la déclaration simultanée de plusieurs variables
		dyn est_spécial : bool
		dyn lexème : TypeLexèmeJSON

		// À FAIRE : l'assignation de plusieurs variables est cassée depuis que nous pouvons
		// avoir des valeurs par défaut pour les paramètres des fonctions
        //est_spécial, lexème = est_caractère_spécial(lexeuse.caractère_courant())

        si (est_spécial) {
			lexeuse.enregistre_position_mot()
			lexeuse.pousse_caractère()
			lexeuse.pousse_mot(lexème)
			lexeuse.avance(1)
		}
		sinon si (est_espace_blanc(lexeuse.caractère_courant())) {
			lexeuse.avance(1)
		}
		sinon si (lexeuse.caractère_courant() == '"') {
			lexeuse.avance(1)

			lexeuse.enregistre_position_mot()

			dyn dernier_caractère := lexeuse.caractère_courant()

			boucle {
				si (lexeuse.caractère_courant() == '"' && dernier_caractère != '\\') {
					arrête
				}

				dernier_caractère = lexeuse.caractère_courant()

				lexeuse.pousse_caractère()
				lexeuse.avance(1)
			}

			lexeuse.pousse_mot(TypeLexèmeJSON.CHAINE_CARACTERE)
			lexeuse.avance(1)
		}
		sinon si (est_nombre_décimal(lexeuse.caractère_courant())) {
			lexeuse.enregistre_position_mot()

			// nous savons que nous avons un nombre
			lexeuse.pousse_caractère()
			lexeuse.avance(1)

			dyn est_nombre_réel := faux

			tantque !lexeuse.a_fini() {
				c := lexeuse.caractère_courant()

				si c == '.' {
					est_nombre_réel = vrai
				}
				sinon si !est_nombre_décimal(c) {
					arrête
				}

				lexeuse.pousse_caractère()
				lexeuse.avance(1)
			}

			si est_nombre_réel {
				lexeuse.pousse_mot(TypeLexèmeJSON.NOMBRE_REEL)
			}
			sinon {
				lexeuse.pousse_mot(TypeLexèmeJSON.NOMBRE_ENTIER)
			}
		}
		sinon {
			lexeuse.avance(1)
		}
    }
}
