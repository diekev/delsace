importe Fondation

//##############################################################################

TypeLexème :: énum z32 {
	INCONNU

	PARENTHESE_OUVRANTE
	PARENTHESE_FERMANTE
	VIRGULE
	DOUBLE_POINTS
	CROCHET_OUVRANT
	CROCHET_FERMANT
	ACCOLADE_OUVRANTE
	ACCOLADE_FERMANTE
	CHAINE_CARACTERE
	NOMBRE_ENTIER
	NOMBRE_REEL
	NOMBRE_BINAIRE
	NOMBRE_OCTAL
	NOMBRE_HEXADECIMAL
}

DonneesLexème :: struct {
	chn : chaine
	lexème : TypeLexème
}

est_caractère_spécial :: fonc(c : z8) -> bool, TypeLexème
{
    discr c {
        '(' { retourne vrai, TypeLexème.PARENTHESE_OUVRANTE }
        ')' { retourne vrai, TypeLexème.PARENTHESE_FERMANTE }
        ',' { retourne vrai, TypeLexème.VIRGULE }
        ':' { retourne vrai, TypeLexème.DOUBLE_POINTS }
        '[' { retourne vrai, TypeLexème.CROCHET_OUVRANT }
        ']' { retourne vrai, TypeLexème.CROCHET_FERMANT }
        '{' { retourne vrai, TypeLexème.ACCOLADE_OUVRANTE }
        '}' { retourne vrai, TypeLexème.ACCOLADE_FERMANTE }
    }

    retourne faux, TypeLexème.INCONNU
}

Lexeuse :: struct {
    tampon : chaine
    début_mot : *z8 = nul
    début : *z8 = nul
    fin : *z8 = nul

    lexèmes : []DonneesLexème

    taille_mot_courant := 0
    compte_ligne := 0
    position_ligne := 0
    pos_mot := 0
}

construit_lexeuse :: fonc(chn : chaine) -> Lexeuse
{
    dyn lexeuse : Lexeuse
    lexeuse.tampon = chn
    lexeuse.début_mot = @chn[0]
    lexeuse.début = @chn[0]
    lexeuse.fin = lexeuse.début + chn.taille

    retourne lexeuse
}

détruit_lexeuse :: fonc(dyn lexeuse : &Lexeuse) -> rien
{
    déloge lexeuse.lexèmes
}

a_fini :: fonc(dyn lexeuse : &Lexeuse) -> bool
{
	retourne lexeuse.début >= lexeuse.fin
}

caractère_courant :: fonc(dyn lexeuse : &Lexeuse) -> z8
{
    retourne mémoire(lexeuse.début)
}

caractère_courant :: fonc(dyn lexeuse : &Lexeuse, n : z32) -> z8
{
    retourne mémoire(lexeuse.début + n)
}

avance :: fonc(dyn lexeuse : &Lexeuse, n : z32) -> rien
{
	pour i dans 0 ... n - 1 {
		si (lexeuse.caractère_courant() == '\n') {
			lexeuse.compte_ligne += 1
			lexeuse.position_ligne = 0
		}
		sinon {
			lexeuse.position_ligne += 1
		}

		lexeuse.début += 1
	}
}

pousse_caractère :: fonc(dyn lexeuse : &Lexeuse) -> rien
{
	lexeuse.taille_mot_courant += 1
}

mot_courant :: fonc(dyn lexeuse : &Lexeuse) -> chaine
{
	retourne construit_chaine(lexeuse.début_mot, lexeuse.taille_mot_courant)
}

pousse_mot :: fonc(dyn lexeuse : &Lexeuse, lexème : TypeLexème) -> rien
{
    dyn données : DonneesLexème
    données.lexème = lexème
    données.chn = lexeuse.mot_courant()

    tableau_ajoute(@lexeuse.lexèmes, données)

    lexeuse.taille_mot_courant = 0
	lexeuse.début_mot = nul
}

enregistre_position_mot :: fonc(dyn lexeuse : &Lexeuse) -> rien
{
	lexeuse.pos_mot = lexeuse.position_ligne
	lexeuse.début_mot = lexeuse.début
}

performe_lexage :: fonc(dyn lexeuse : &Lexeuse) -> rien
{
    tantque !lexeuse.a_fini() {
		// À FAIRE : permet la déclaration simultanée de plusieurs variables
		dyn est_spécial : bool
		dyn lexème : TypeLexème
        est_spécial, lexème = est_caractère_spécial(lexeuse.caractère_courant())

        si (est_spécial) {
			lexeuse.enregistre_position_mot()
			lexeuse.pousse_caractère()
			lexeuse.pousse_mot(lexème)
			lexeuse.avance(1)
		}
		sinon si (est_espace_blanc(lexeuse.caractère_courant())) {
			lexeuse.avance(1)
		}
		sinon si (lexeuse.caractère_courant() == '"') {
			lexeuse.avance(1)

			lexeuse.enregistre_position_mot()

			dyn dernier_caractère := lexeuse.caractère_courant()

			boucle {
				si (lexeuse.caractère_courant() == '"' && dernier_caractère != '\\') {
					arrête
				}

				dernier_caractère = lexeuse.caractère_courant()

				lexeuse.pousse_caractère()
				lexeuse.avance(1)
			}

			lexeuse.pousse_mot(TypeLexème.CHAINE_CARACTERE)
			lexeuse.avance(1)
		}
		sinon si (est_nombre_décimal(lexeuse.caractère_courant())) {
			lexeuse.enregistre_position_mot()

			// nous savons que nous avons un nombre
			lexeuse.pousse_caractère()
			lexeuse.avance(1)

			dyn est_nombre_réel := faux

			tantque !lexeuse.a_fini() {
				c := lexeuse.caractère_courant()

				si c == '.' {
					est_nombre_réel = vrai
				}
				sinon si !est_nombre_décimal(c) {
					arrête
				}

				lexeuse.pousse_caractère()
				lexeuse.avance(1)
			}

			si est_nombre_réel {
				lexeuse.pousse_mot(TypeLexème.NOMBRE_REEL)
			}
			sinon {
				lexeuse.pousse_mot(TypeLexème.NOMBRE_ENTIER)
			}
		}
		sinon {
			lexeuse.avance(1)
		}
    }
}
