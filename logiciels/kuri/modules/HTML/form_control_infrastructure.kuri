/* ------------------------------------------------------------------------- */
/** \nom 4.10.18 Form control infrastructure
 * \{ */

/* https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#form-owner */
donne_form_owner :: fonc (élément: *Element) -> *HTMLFormElement
{
    // À FAIRE : respecte le standard

    parent := élément.parent
    tantque parent != nul {
        si parent.table.classe == HTMLFormElement {
            retourne parent comme *HTMLFormElement
        }

        parent = parent.parent
    }

    retourne nul
}

/** \} */

#portée_module

/* ------------------------------------------------------------------------- */
/** \nom 4.10.19 Attributes common to form controls
 * \{ */

/* https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#concept-fs-method */
donne_method :: fonc (élément: *Element) -> DOMString
{
    résultat := donne_attribut_ou_chaine_vide(élément, ATTR_formmethod)
    si résultat.est_vide() {
        form_owner := donne_form_owner(élément)
        assert(form_owner != nul)
        résultat = donne_attribut_ou_chaine_vide(form_owner, ATTR_method)
    }

    /* https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#attr-fs-method */
    si résultat.est_vide() {
        retourne ATTR_get
    }

    si résultat != ATTR_get && résultat != ATTR_post && résultat != ATTR_dialog {
        retourne ATTR_get
    }

    retourne résultat
}

/* 4.10.19.5 Enabling and disabling form controls: the disabled attribute
 * https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#enabling-and-disabling-form-controls:-the-disabled-attribute */
is_disabled :: fonc (element: *Element) -> bool
{
    // A form control is disabled if any of the following are true:
    résultat := faux

    // the element is a button, input, select, textarea, or À FAIRE form-associated custom element,
    // and the disabled attribute is specified on this element (regardless of its value); or
    si element.local_name == TAG_button || element.local_name == TAG_input || element.local_name == TAG_select || element.local_name == TAG_textarea {
        résultat = possède_attribut(element, ATTR_disabled)
    }

    // À FAIRE the element is a descendant of a fieldset element whose disabled attribute is specified, and is not a descendant of that fieldset element's first legend element child, if any.

    retourne résultat
}

/* https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#concept-fs-action */
donne_action :: fonc (élément: *Element) -> DOMString
{
    résultat := donne_attribut_ou_chaine_vide(élément, ATTR_formaction)
    si résultat.est_vide() {
        form_owner := donne_form_owner(élément)
        assert(form_owner != nul)
        résultat = donne_attribut_ou_chaine_vide(form_owner, ATTR_action)
    }
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 4.10.22 Form submission
 * https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#form-submission-2
 * \{ */

/* 4.10.22.2 Implicit submission
 * https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#implicit-submission */
donne_default_button :: fonc (form_element: *HTMLFormElement) -> *Element
{
    // A form element's default button is the first submit button in tree order whose form owner
    // is that form element.
    pour Descendants(form_element) {
        si est_élément(it) && is_submit_button(it comme *Element) && donne_form_owner(it comme *Element) == form_element {
            retourne it comme *Element
        }
    }

    retourne nul
}

#portée_export

gère_soumission_implicite :: fonc (form_element: *HTMLFormElement)
{
    // If the user agent supports letting the user submit a form implicitly (for example, on some platforms hitting
    // the "enter" key while a text control is focused implicitly submits the form), then doing so for a form,
    // whose default button has activation behavior and is not disabled, must cause the user agent to fire a
    // click event at that default button.
    default_button := donne_default_button(form_element)
    si default_button {
        si possède_activation_behavior(default_button) && !is_disabled(default_button) {
            _ := fire_a_click_event(default_button)
        }
    }
    sinon {
        // If the form has no submit button, then the implicit submission mechanism must perform the following steps:

        // 1. If the form has more than one field that blocks implicit submission, then return.
        //
        // For the purpose of the previous paragraph, an element is a field that blocks implicit submission of a form
        // element if it is an input element whose form owner is that form element and whose type attribute is in one
        // of the following states: Text, Search, Telephone, URL, Email, Password, Date, Month, Week, Time, Local Date
        // and Time, Number
        nombre_de_champs_bloquants := 0
        pour Descendants(form_element) {
            si est_élément(it) {
                element := it comme *Element
                si element.local_name == TAG_input {
                    state := donne_state(element comme *HTMLInputElement)
                    discr state {
                        Text, Search, Telephone, URL, Email, Password, Date, Month, Week, Time, Local_Date_and_Time, Number {
                            nombre_de_champs_bloquants += 1
                            si nombre_de_champs_bloquants > 1 {
                                retourne
                            }
                        }
                        sinon {}
                    }
                }
            }
        }

        // 2. Submit the form element from the form element itself with userInvolvement set to "activation".
        submit(form_element, form_element, user_involvement = UserNavigationInvolvement.Activation)
    }
}

#portée_module

fire_a_synthetic_pointer_event :: fonc (e: EventType, target: *EventTarget, not_trusted : *bool = nul) -> bool
{
    // 1. Let event be the result of creating an event using PointerEvent.
    event := crée_platform_object(target, PointerEvent)

    // 2. Initialize event's type attribute to e.
    event.type = e

    // 3. Initialize event's bubbles and cancelable attributes to true.
    event.bubbles = vrai
    // À FAIRE event.cancelable = vrai

    // 4. Set event's composed flag.
    event.composed = vrai

    // 5. If the not trusted flag is set, initialize event's isTrusted attribute to false.
    si not_trusted && mémoire(not_trusted) {
        event.is_trusted = faux
    }
    sinon {
        event.is_trusted = vrai
    }

    // À FAIRE : 6. Initialize event's ctrlKey, shiftKey, altKey, and metaKey attributes according to the current state of the key input device, if any (false for any keys that are not available).

    // 7. Initialize event's view attribute to target's node document's Window object, if any, and null otherwise.

    // 8. event's getModifierState() method is to return values appropriately describing the current state of the key input device.

    // 9. Return the result of dispatching event at target.
    retourne dispatch(event, target)
}

/* https://html.spec.whatwg.org/multipage/webappapis.html#fire-a-click-event */
fire_a_click_event :: fonc (target: *EventTarget) -> bool
{
    retourne fire_a_synthetic_pointer_event(EventType.click, target)
}

/* 4.10.22.3 Form submission algorithm
 * https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#concept-form-submit */
submit :: fonc (form: *HTMLFormElement, submitter: *Element, submitted_from_submit_method := faux, user_involvement := UserNavigationInvolvement.None)
{
    // 1. If form cannot navigate, then return.
    si cannot_navigate(form) {
        imprime("[%] cannot_navigate\n", #nom_de_cette_fonction)
        retourne
    }

    // 2. If form's constructing entry list is true, then return.
    si form.constructing_entry_list {
        retourne
    }

    // 3. Let form document be form's node document.
    form_document := form.document

    // 4. If form document's active sandboxing flag set has its sandboxed forms browsing context flag set, then return.
    si form_document.active_sandboxing_flags.Forms {
        retourne
    }

    // 5. If submitted from submit() method is false, then:
    saufsi submitted_from_submit_method {
        // 1. If form's firing submission events is true, then return.
        si form.firing_submission_events {
            retourne
        }

        // 2. Set form's firing submission events to true.
        form.firing_submission_events = vrai

        // 3. For each element field in the list of submittable elements whose form owner is form, set field's user validity to true.

        // 4. If the submitter element's no-validate state is false, then interactively validate the constraints of form and examine the result. If the result is negative (i.e., the constraint validation concluded that there were invalid fields and probably informed the user of this), then:

            // 1. Set form's firing submission events to false.

            // 2. Return.

        // 5. Let submitterButton be null if submitter is form. Otherwise, let submitterButton be submitter.

        // 6. Let shouldContinue be the result of firing an event named submit at form using SubmitEvent, with the submitter attribute initialized to submitterButton, the bubbles attribute initialized to true, and the cancelable attribute initialized to true.

        // 7. Set form's firing submission events to false.
        form.firing_submission_events = faux

        // 8. If shouldContinue is false, then return.

        // 9. If form cannot navigate, then return.
        si cannot_navigate(form) {
            retourne
        }
    }

    // À FAIRE : 6. Let encoding be the result of picking an encoding for the form.

    // 7. Let entry list be the result of constructing the entry list with form, submitter, and encoding.
    // @fuite-de-mémoire (ceci est passé à navigate() via une tâche
    entry_list := construct_the_entry_list(form, submitter)

    // 8. Assert: entry list is not null.
    assert(entry_list != nul)

    // 9. If form cannot navigate, then return.
    si cannot_navigate(form) {
        retourne
    }

    // 10. Let method be the submitter element's method.
    method := donne_method(submitter)

    // 11. If method is dialog, then:
    si method == ATTR_dialog {
        imprime("[%] À FAIRE : dialog\n", #nom_de_cette_fonction)
        // If form does not have an ancestor dialog element, then return.

        // Let subject be form's nearest ancestor dialog element.

        // Let result be null.

        // If submitter is an input element whose type attribute is in the Image Button state, then:

        // Let (x, y) be the selected coordinate.

        // Set result to the concatenation of x, ",", and y.

        // Otherwise, if submitter has a value, then set result to that value.

        // Close the dialog subject with result.

        // Return.
        retourne
    }

    // 12. Let action be the submitter element's action.
    action := copie_chaine(donne_action(submitter).donne_chaine_utf16())
    diffère détruit_chaine(action)

    // 13. If action is the empty string, let action be the URL of the form document.
    si action.est_vide() {
        chn_action := url_serializer(form.document.url)
        action = crée_chaine_utf16(chn_action)
        déloge(chn_action)
    }

    // 14. Let parsed action be the result of encoding-parsing a URL given action, relative to submitter's node document.
    parsed_action := encoding_parse_a_url(action, submitter.document)

    // 15. If parsed action is failure, then return.
    si is_failure(parsed_action) {
        retourne
    }

    // 16. Let scheme be the scheme of parsed action.
    scheme := parsed_action.scheme

    // 17. Let enctype be the submitter element's enctype.

    // 18. Let formTarget be null.
    form_target := crée_chaine_utf16_unique_vide()

    // À FAIRE : 19. If the submitter element is a submit button and it has a formtarget attribute, then set formTarget to the formtarget attribute value.

    // 20. Let target be the result of getting an element's target given submitter's form owner and formTarget.
    target := get_an_element_s_target(donne_form_owner(submitter), form_target)
    // si ce n'est pas vide il faut implémenter les deux étapes suivantes
    assert(target.est_vide())

    // 21. Let noopener be the result of getting an element's noopener with form, parsed action, and target.

    // 22. Let targetNavigable be the first return value of applying the rules for choosing a navigable given target, form's node navigable, and noopener.
    target_navigable := form.donne_node_navigable()

    // 23. If targetNavigable is null, then return.
    saufsi target_navigable {
        retourne
    }

    // 24. Let historyHandling be "auto".
    history_handling := NavigationHistoryBehavior.AUTO

    // À FAIRE 25. If form document equals targetNavigable's active document, and form document has not yet completely loaded, then set historyHandling to "replace".

    // 26. Select the appropriate row in the table below based on scheme as given by the first cell of each row.
    //     Then, select the appropriate cell on that row based on method as given in the first cell of each column.
    //     Then, jump to the steps named in that cell and defined below the table.
    params: ParamètresNavigationNavigable
    params.url = parsed_action
    params.source_document = form.document
    params.history_handling = history_handling
    params.user_involvement = user_involvement
    params.form_data_entry_list = entry_list

    si scheme == "http" || scheme == "https" || scheme == "data" {
        si method == ATTR_get {
            mutate_action_url(form, entry_list, parsed_action, target_navigable, params)
        }
        sinon si method == ATTR_post {
            si scheme == "data" {
                plan_to_navigate(form, target_navigable, params)
            }
            sinon {
                // Submit as entity body
            }
        }
    }
    sinon si scheme == "ftp" || scheme == "javascript" {
        plan_to_navigate(form, target_navigable, params)
    }
    sinon si scheme == "mailto" {
        si method == ATTR_get {
            // Mail with headers
        }
        sinon si method == ATTR_post {
            // Mail as body
        }
    }
}

/* https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#submit-mutate-action */
mutate_action_url :: fonc (form: *HTMLFormElement, entry_list: *EntryList, parsed_action: *URL, target_navigable: *Navigable, params: ParamètresNavigationNavigable)
{
    assert(parsed_action == params.url)

    // Let pairs be the result of converting to a list of name-value pairs with entry list.
    pairs := convert_an_entry_list_to_a_list(entry_list)
    diffère déloge(pairs)

    // Let query be the result of running the application/x-www-form-urlencoded serializer with pairs and encoding.
    query := run_application_x_www_form_urlencode_serializer(pairs)

    // Set parsed action's query component to query.
    parsed_action.query = query

    // Plan to navigate to parsed action.
    plan_to_navigate(form, target_navigable, params)
}

/* https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plan-to-navigate */
plan_to_navigate :: fonc (form: *HTMLFormElement, target_navigable: *Navigable, params: ParamètresNavigationNavigable)
{
    // À FAIRE 1. Let referrerPolicy be the empty string.

    // 2. If the form element's link types include the noreferrer keyword, then set referrerPolicy to "no-referrer".

    // 3. If the form has a non-null planned navigation, remove it from its task queue.
    assert(form.planned_navigation == nul)

    // 4. Queue an element task on the DOM manipulation task source given the form element and the following steps:
    Tâche :: struct {
        empl base: Algorithm

        form: *HTMLFormElement
        target_navigable: *Navigable
        params: ParamètresNavigationNavigable
    }

    sur_run :: fonc (base: *Algorithm)
    {
        empl tâche := base comme *Tâche

        // 1. Set the form's planned navigation to null.
        form.planned_navigation = nul

        // 2. Navigate targetNavigable to url using the form element's node document,
        //    with historyHandling set to historyHandling, userInvolvement set to userInvolvement,
        //    sourceElement set to submitter, referrerPolicy set to referrerPolicy,
        //    documentResource set to postResource, and formDataEntryList set to entry list.
        navigate(params.source_document.donne_user_agent(), target_navigable, params)
    }

    tâche := crée_algorithm(sur_run, Tâche)
    tâche.form = form
    tâche.target_navigable = target_navigable
    tâche.params = params

    user_agent := params.source_document.donne_user_agent()
    user_agent.queue_an_element_task(SourceDeTâche.ManipulationDOM, form, tâche)

    // 5. Set the form's planned navigation to the just-queued task.
    form.planned_navigation = tâche
}

/* 4.10.22.4 Constructing the entry list */

/* https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#constructing-form-data-set */
EntryList :: struct {
    Entry :: struct {
        name: chaine
        value: chaine
    }

    entries: [..]Entry
}

détruit_entry_list :: fonc (entry_list: *EntryList)
{
    pour entry_list.entries {
        déloge(it.name)
        déloge(it.value)
    }

    déloge(entry_list.entries)
    déloge(entry_list)
}

/* https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#constructing-the-form-data-set */
construct_the_entry_list :: fonc (form: *HTMLFormElement, submitter : *Element = nul @inutilisée) -> *EntryList
{
    // 1. If form's constructing entry list is true, then return null.
    si form.constructing_entry_list {
        retourne nul
    }

    // 2. Set form's constructing entry list to true.
    form.constructing_entry_list = vrai

    // 3. Let controls be a list of all the submittable elements whose form owner is form, in tree order.
    controls := donne_submittable_elements(form)
    diffère déloge(controls)

    // 4. Let entry list be a new empty entry list.
    entry_list := loge(EntryList)

    // 5. For each element field in controls, in tree order:
    pour field dans controls {
        si field.table.classe == HTMLInputElement {
            name := field.donne_attribut_ou_chaine_vide(ATTR_name)
            saufsi name.est_vide() {
                entry := tableau_ajoute_élément(*entry_list.entries)
                entry.name = converti_vers_chaine(name.donne_chaine_utf16())
                entry.value = converti_vers_chaine(donne_value(field comme *HTMLInputElement))
            }
        }

        // À FAIRE If any of the following are true:

        // field has a datalist element ancestor;

        // field is disabled;

        // field is a button but it is not submitter;

        // field is an input element whose type attribute is in the Checkbox state and whose checkedness is false; or

        // field is an input element whose type attribute is in the Radio Button state and whose checkedness is false,

        // then continue.

        // If the field element is an input element whose type attribute is in the Image Button state, then:

        // If the field element is not submitter, then continue.

        // If the field element has a name attribute specified and its value is not the empty string, let name be that value followed by U+002E (.). Otherwise, let name be the empty string.

        // Let namex be the concatenation of name and U+0078 (x).

        // Let namey be the concatenation of name and U+0079 (y).

        // Let (x, y) be the selected coordinate.

        // Create an entry with namex and x, and append it to entry list.

        // Create an entry with namey and y, and append it to entry list.

        // Continue.

        // If the field is a form-associated custom element, then perform the entry construction algorithm given field and entry list, then continue.

        // If either the field element does not have a name attribute specified, or its name attribute's value is the empty string, then continue.

        // Let name be the value of the field element's name attribute.

        // If the field element is a select element, then for each option element in the select element's list of options whose selectedness is true and that is not disabled, create an entry with name and the value of the option element, and append it to entry list.

        // Otherwise, if the field element is an input element whose type attribute is in the Checkbox state or the Radio Button state, then:

        // If the field element has a value attribute specified, then let value be the value of that attribute; otherwise, let value be the string "on".

        // Create an entry with name and value, and append it to entry list.

        // Otherwise, if the field element is an input element whose type attribute is in the File Upload state, then:

        // If there are no selected files, then create an entry with name and a new File object with an empty name, application/octet-stream as type, and an empty body, and append it to entry list.

        // Otherwise, for each file in selected files, create an entry with name and a File object representing the file, and append it to entry list.

        // Otherwise, if the field element is an input element whose type attribute is in the Hidden state and name is an ASCII case-insensitive match for "_charset_":

        // Let charset be the name of encoding.

        // Create an entry with name and charset, and append it to entry list.

        // Otherwise, create an entry with name and the value of the field element, and append it to entry list.

        // If the element has a dirname attribute, that attribute's value is not the empty string, and the element is an auto-directionality form-associated element:

        // Let dirname be the value of the element's dirname attribute.

        // Let dir be the string "ltr" if the directionality of the element is 'ltr', and "rtl" otherwise (i.e., when the directionality of the element is 'rtl').

        // Create an entry with dirname and dir, and append it to entry list.
    }

    // À FAIRE 6. Let form data be a new FormData object associated with entry list.

    // 7. Fire an event named formdata at form using FormDataEvent, with the formData attribute initialized to form data and the bubbles attribute initialized to true.

    // 8. Set form's constructing entry list to false.
    form.constructing_entry_list = faux

    // 9. Return a clone of entry list.
    retourne entry_list
}

/* 4.10.22.6 Converting an entry list to a list of name-value pairs
 * https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#convert-to-a-list-of-name-value-pairs */
NameValuePair :: struct {
    name: chaine
    value: chaine
}

convert_an_entry_list_to_a_list :: fonc (entry_list: *EntryList) -> [..]NameValuePair
{
    // 1. Let list be an empty list of name-value pairs.
    list: [..]NameValuePair

    // 2. For each entry of entry list:
    pour entry dans entry_list.entries {
        // À FAIRE : assainissement
        // 1. Let name be entry's name, with every occurrence of U+000D (CR) not followed by U+000A (LF),
        //    and every occurrence of U+000A (LF) not preceded by U+000D (CR), replaced by a string consisting
        //    of U+000D (CR) and U+000A (LF).
        name := entry.name

        // 2. If entry's value is a File object, then let value be entry's value's name. Otherwise, let value be entry's value.
        value := entry.value

        // 3. Replace every occurrence of U+000D (CR) not followed by U+000A (LF), and every occurrence of U+000A (LF)
        //    not preceded by U+000D (CR), in value, by a string consisting of U+000D (CR) and U+000A (LF).

        // 4. Append to list a new name-value pair whose name is name and whose value is value.
        tableau_ajoute(*list, NameValuePair(name, value))
    }

    // 3. Return list.
    retourne list
}

/** \} */
