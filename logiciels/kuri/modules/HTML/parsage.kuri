importe Fondation

est_caractère_espace_blanc :: fonc (point_de_code: n32) -> bool
{
    retourne point_de_code == ESPACE || point_de_code == TABULATION || point_de_code == RETOUR_CHARIOT || point_de_code == NOUVELLE_LIGNE || point_de_code == 0x0C
}

TypeFonctionModeInsertion :: fonc(*Parseuse, Lexème)(rien)

Parseuse :: struct {
    mode_insertion : TypeFonctionModeInsertion
    mode_insertion_original : TypeFonctionModeInsertion
    pile_insertion_template : []TypeFonctionModeInsertion
    lexeuse: Lexeuse
    document: *Document

    élément_head : *Élément
    élément_form : *Élément

    pile_éléments_ouvert : PileÉlémentsOuverts
    liste_éléments_actifs_formattage : ListeÉlémentsActifsFormattage

    arrête_de_parser := faux
    adoption_activée := faux
    scripting_flag := faux
    frameset_ok := vrai
    pause := faux

    niveau_imbrication_script := 0
}

initialise_parseuse :: fonc (entrée: chaine) -> Parseuse
{
    parseuse: Parseuse
    parseuse.mode_insertion = insère_mode_Initial
    parseuse.lexeuse = initialise_lexeuse(entrée)
    parseuse.document = crée_noeud_document()

    retourne parseuse
}

détruit_parseuse :: fonc (parseuse: *Parseuse)
{
    détruit_lexeuse(*parseuse.lexeuse)
    détruit_liste(*parseuse.liste_éléments_actifs_formattage)
    déloge(parseuse.pile_éléments_ouvert.éléments)
    déloge(parseuse.pile_insertion_template)
}

parse :: fonc (parseuse: *Parseuse)
{
    boucle {
        lexème := lexème_suivant(*parseuse.lexeuse)

        si lexème.genre == GenreLexème.FinDeFichier {
            arrête
        }

        //imprime("mode_insertion : %\n", parseuse.mode_insertion)

        gère_lexème_pour_mode(parseuse, parseuse.mode_insertion, lexème)

        détruit_lexème(*lexème)

        si parseuse.arrête_de_parser {
            arrête
        }
    }
}

noeud_courant :: fonc (parseuse: *Parseuse) -> *Élément
{
    retourne noeud_courant(*parseuse.pile_éléments_ouvert)
}

crée_élément_pour :: fonc (parseuse: *Parseuse, lexème: Lexème) -> *Élément
{
    élément := crée_élément_avec_tag(parseuse.document, lexème.nom)

    pour lexème.attributs {
        élément.ajoute_attribut(it.nom, it.valeur)
    }

    retourne élément
}

gère_lexème_pour_mode :: fonc (parseuse: *Parseuse, mode: TypeFonctionModeInsertion, lexème: Lexème)
{
    // si lexème.genre != GenreLexème.Caractère {
    //     imprime("gère lexème : % (%), mode insertion : %\n", lexème.nom, lexème.genre, mode)
    // }

    mode(parseuse, lexème)
}

trouve_position_appropriée_pour_insertion :: fonc (parseuse: *Parseuse, cible_override: *Noeud = nul) -> *Noeud
{
    cible : *Noeud = nul

    si cible_override {
        cible = cible_override
    }
    sinon {
        cible = parseuse.noeud_courant()
    }

    si parseuse.adoption_activée {
        panique("adotion non implémenté")
    }

    // À FAIRE : si la cible est un template, retourne le dernier enfant de son contenu
    retourne cible
}

insère_élément_html :: fonc (parseuse: *Parseuse, lexème: Lexème) -> *Élément
{
    position_ajustée_d_insertion := trouve_position_appropriée_pour_insertion(parseuse)
    élément := parseuse.crée_élément_pour(lexème)
    // À FAIRE : vérifie s'il est possible d'insérer élément à position_ajustée_d_insertion
    // À FAIRE : file d'évènements, voir spec
    position_ajustée_d_insertion.ajoute_enfant(élément)
    empile(*parseuse.pile_éléments_ouvert, élément)
    retourne élément
}

insère_caractère :: fonc (parseuse: *Parseuse, point_de_code: n32)
{
    position_ajustée_d_insertion := trouve_position_appropriée_pour_insertion(parseuse)

    si position_ajustée_d_insertion.genre == GenreNoeud.Document {
        // ignore
        retourne
    }

    noeud_texte : *NoeudTexte = nul

    si position_ajustée_d_insertion.enfants.taille != 0 && position_ajustée_d_insertion.enfants[position_ajustée_d_insertion.enfants.taille - 1].genre == GenreNoeud.Texte {
        noeud_texte = position_ajustée_d_insertion.enfants[position_ajustée_d_insertion.enfants.taille - 1] comme *NoeudTexte
    }
    sinon {
        noeud_texte = crée_noeud_texte(position_ajustée_d_insertion.document)
        position_ajustée_d_insertion.ajoute_enfant(noeud_texte)
    }

    chaine_ajoute(*noeud_texte.données, point_de_code)
}

insère_commentaire :: fonc (parseuse: *Parseuse, lexème: Lexème, position : *Noeud = nul)
{
    position_ajustée_d_insertion := position

    si !position_ajustée_d_insertion {
        position_ajustée_d_insertion = trouve_position_appropriée_pour_insertion(parseuse)
    }

    noeud_commentaire := crée_noeud_commentaire(position_ajustée_d_insertion.document, lexème.données)
    position_ajustée_d_insertion.ajoute_enfant(noeud_commentaire)
}

insère_mode_Initial :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    si lexème.genre == GenreLexème.Caractère && est_caractère_espace_blanc(lexème.point_de_code) {
        retourne
    }

    si lexème.genre == GenreLexème.Commentaire {
        insère_commentaire(parseuse, lexème, parseuse.document)
        retourne
    }

    si lexème.genre == GenreLexème.Doctype {
        doctype := crée_noeud_doctype(parseuse.document)
        doctype.ajoute_attribut("name", lexème.nom)
        parseuse.document.ajoute_enfant(doctype)
        parseuse.mode_insertion = insère_mode_AvantHtml
        retourne
    }

    // À FAIRE : vérifie si nous avons un iframe srcdoc

    parseuse.mode_insertion = insère_mode_AvantHtml
    parseuse.gère_lexème_pour_mode(parseuse.mode_insertion, lexème)
}

insère_mode_AvantHtml :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    si lexème.genre == GenreLexème.Doctype {
        erreur_de_parsage("<doctype> inattendu")
        retourne
    }

    si lexème.genre == GenreLexème.Commentaire {
        insère_commentaire(parseuse, lexème, parseuse.document)
        retourne
    }

    si lexème.genre == GenreLexème.Caractère && est_caractère_espace_blanc(lexème.point_de_code) {
        retourne
    }

    si lexème.genre == GenreLexème.DébutTag && lexème.nom == "html" {
        élément := parseuse.crée_élément_pour(lexème)
        parseuse.document.ajoute_enfant(élément)
        parseuse.mode_insertion = insère_mode_AvantHead
        empile(*parseuse.pile_éléments_ouvert, élément)
        // À FAIRE : contexte navigation, voir spec
        retourne
    }

    si lexème.genre == GenreLexème.FinTag && !fait_partie_de(lexème.nom, "head", "body", "html", "br") {
        retourne
    }

    lexème_html : Lexème
    lexème_html.nom = "html"
    élément := parseuse.crée_élément_pour(lexème_html)
    parseuse.document.ajoute_enfant(élément)
    empile(*parseuse.pile_éléments_ouvert, élément)

    // À FAIRE : si document est chargé dans un contexte navigation...

    parseuse.mode_insertion = insère_mode_AvantHead
    parseuse.gère_lexème_pour_mode(parseuse.mode_insertion, lexème)
}

insère_mode_AvantHead :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    si lexème.genre == GenreLexème.Caractère && est_caractère_espace_blanc(lexème.point_de_code) {
        retourne
    }

    si lexème.genre == GenreLexème.Commentaire {
        insère_commentaire(parseuse, lexème)
        retourne
    }

    si lexème.genre == GenreLexème.Doctype {
        erreur_de_parsage("<doctype> avant <head>")
        retourne
    }

    si lexème.genre == GenreLexème.DébutTag {
        si lexème.nom == "html" {
            gère_lexème_pour_mode(parseuse, insère_mode_DansBody, lexème)
            retourne
        }

        si lexème.nom == "head" {
            élément := parseuse.insère_élément_html(lexème)
            parseuse.élément_head = élément
            parseuse.mode_insertion = insère_mode_DansHead
            retourne
        }
    }

    si lexème.genre == GenreLexème.FinTag && !fait_partie_de(lexème.nom, "head", "body", "html", "br") {
        retourne
    }

    lexème_head := Lexème(genre = GenreLexème.DébutTag, nom = "head")
    élément := parseuse.insère_élément_html(lexème_head)
    parseuse.élément_head = élément
    parseuse.mode_insertion = insère_mode_DansHead
    gère_lexème_pour_mode(parseuse, parseuse.mode_insertion, lexème)
}

gère_élément_contenant_texte_cru :: fonc (parseuse: *Parseuse, lexème: Lexème, état_lexeuse: ÉtatLexage)
{
    _ := parseuse.insère_élément_html(lexème)
    parseuse.lexeuse.état = état_lexeuse
    parseuse.mode_insertion_original = parseuse.mode_insertion
    parseuse.mode_insertion = insère_mode_Texte
}

insère_mode_DansHead :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    si lexème.genre == GenreLexème.Caractère && est_caractère_espace_blanc(lexème.point_de_code) {
        parseuse.insère_caractère(lexème.point_de_code)
        retourne
    }

    si lexème.genre == GenreLexème.Commentaire {
        insère_commentaire(parseuse, lexème)
        retourne
    }

    si lexème.genre == GenreLexème.Doctype {
        erreur_de_parsage("<doctype> dans <head>")
        retourne
    }

    si lexème.genre == GenreLexème.DébutTag {
        si lexème.nom == "html" {
            gère_lexème_pour_mode(parseuse, insère_mode_DansBody, lexème)
            retourne
        }

        si fait_partie_de(lexème.nom, "base", "basefront", "bgsound", "link") {
            _ := parseuse.insère_élément_html(lexème)
            dépile(*parseuse.pile_éléments_ouvert)
            reconnait_drapeau_auto_fermant(*lexème)
            retourne
        }

        si lexème.nom == "meta" {
            _ := parseuse.insère_élément_html(lexème)
            dépile(*parseuse.pile_éléments_ouvert)
            reconnait_drapeau_auto_fermant(*lexème)
            // À FAIRE : gère attributs charset, http-equiv, content
            retourne
        }

        si lexème.nom == "title" {
            gère_élément_contenant_texte_cru(parseuse, lexème, ÉtatLexage.RCDATA)
            retourne
        }

        si lexème.nom == "style" || lexème.nom == "noframes" {
            gère_élément_contenant_texte_cru(parseuse, lexème, ÉtatLexage.RAWTEXT)
            retourne
        }

        si lexème.nom == "noscript" {
            si parseuse.scripting_flag {
                gère_élément_contenant_texte_cru(parseuse, lexème, ÉtatLexage.RAWTEXT)
            }
            sinon {
                _ := parseuse.insère_élément_html(lexème)
                parseuse.mode_insertion = insère_mode_DansHeadNoScript
            }

            retourne
        }

        si lexème.nom == "script" {
            position_ajustée_d_insertion := trouve_position_appropriée_pour_insertion(parseuse)
            élément := parseuse.crée_élément_pour(lexème)
            // À FAIRE : élément_script.document_parseur = parseuse.document
            // À FAIRE : élément_script.non_blocant = faux
            // À FAIRE : élément_script.déjà_lancé = parseuse.créée_depuis_parsage_fragment
            // À FAIRE : document.write()
            position_ajustée_d_insertion.ajoute_enfant(élément)
            empile(*parseuse.pile_éléments_ouvert, élément)
            parseuse.lexeuse.état = ÉtatLexage.ScriptData
            parseuse.mode_insertion_original = parseuse.mode_insertion
            parseuse.mode_insertion = insère_mode_Texte
            retourne
        }

        si lexème.nom == "template" {
            _ := parseuse.insère_élément_html(lexème)
            ajoute_marqueur(*parseuse.liste_éléments_actifs_formattage)
            parseuse.frameset_ok = faux
            parseuse.mode_insertion = insère_mode_DansTemplate
            tableau_ajoute(*parseuse.pile_insertion_template, insère_mode_DansTemplate)
            retourne
        }

        si lexème.nom == "head" {
            retourne
        }
    }

    si lexème.genre == GenreLexème.FinTag {
        si lexème.nom == "head" {
            dépile(*parseuse.pile_éléments_ouvert)
            parseuse.mode_insertion = insère_mode_AprèsHead
            retourne
        }

        si lexème.nom == "template" {
            si !possède_dans_portée(*parseuse.pile_éléments_ouvert, "template") {
                erreur_de_parsage("aucun <template> dans la pile d'éléments ouverts")
                retourne
            }

            parseuse.génère_tags_fin_implicites_attentivement()

            si parseuse.noeud_courant().texte != "template" {
                erreur_de_parsage("le noeud courant n'est pas un <template>")
            }

            parseuse.dépile_tous_les_éléments_jusque("template")
            parseuse.pile_insertion_template.taille -= 1
            parseuse.restaure_mode_insertion_appropriemment()
            retourne
        }

        si !fait_partie_de(lexème.nom, "body", "html", "br") {
            retourne
        }
    }

    dépile(*parseuse.pile_éléments_ouvert)
    parseuse.mode_insertion = insère_mode_AprèsHead
}

insère_mode_DansHeadNoScript :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    si lexème.genre == GenreLexème.Doctype {
        erreur_de_parsage("<doctype> dans <noscript>")
        retourne
    }

    si lexème.genre == GenreLexème.Commentaire {
        gère_lexème_pour_mode(parseuse, insère_mode_DansHead, lexème)
        retourne
    }

    si lexème.genre == GenreLexème.Caractère {
        si est_caractère_espace_blanc(lexème.point_de_code) {
            gère_lexème_pour_mode(parseuse, insère_mode_DansHead, lexème)
            retourne
        }
    }

    si lexème.genre == GenreLexème.DébutTag {
        si lexème.nom == "html" {
            gère_lexème_pour_mode(parseuse, insère_mode_DansBody, lexème)
            retourne
        }

        si lexème.nom == "head" || lexème.nom == "noscript" {
            erreur_de_parsage("<head> ou <noscript> dans <noscript>")
            retourne
        }

        si fait_partie_de(lexème.nom, "bgsound", "link", "meta", "noframes", "style") {
            gère_lexème_pour_mode(parseuse, insère_mode_DansHead, lexème)
            retourne
        }
    }

    si lexème.genre == GenreLexème.FinTag {
        si lexème.nom == "noscript" {
            dépile(*parseuse.pile_éléments_ouvert)
            parseuse.mode_insertion = insère_mode_DansHead
            retourne
        }

        si lexème.nom != "br" {
            erreur_de_parsage("élément inattendu dans <noscript>")
            retourne
        }
    }

    dépile(*parseuse.pile_éléments_ouvert)
    parseuse.mode_insertion = insère_mode_DansHead
    gère_lexème_pour_mode(parseuse, parseuse.mode_insertion, lexème)
}

insère_mode_AprèsHead :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    si lexème.genre == GenreLexème.Caractère && est_caractère_espace_blanc(lexème.point_de_code) {
        parseuse.insère_caractère(lexème.point_de_code)
        retourne
    }

    si lexème.genre == GenreLexème.Commentaire {
        insère_commentaire(parseuse, lexème)
        retourne
    }

    si lexème.genre == GenreLexème.Doctype {
        erreur_de_parsage("<doctype> après <head>")
        retourne
    }

    si lexème.genre == GenreLexème.DébutTag {
        si lexème.nom == "html" {
            gère_lexème_pour_mode(parseuse, insère_mode_DansBody, lexème)
            retourne
        }

        si lexème.nom == "body" {
            _ := parseuse.insère_élément_html(lexème)
            parseuse.frameset_ok = faux
            parseuse.mode_insertion = insère_mode_DansBody
            retourne
        }

        si lexème.nom == "frameset" {
            _ := parseuse.insère_élément_html(lexème)
            parseuse.mode_insertion = insère_mode_DansFrameSet
            retourne
        }

        si lexème.nom == "head" {
            retourne
        }

        si fait_partie_de(lexème.nom, "base", "basefont", "bgsound", "link", "meta", "noframes", "script", "style", "template", "title") {
            erreur_de_parsage("élément inattendu après <head>")

            empile(*parseuse.pile_éléments_ouvert, parseuse.élément_head)
            parseuse.gère_lexème_pour_mode(insère_mode_DansHead, lexème)
            supprime_élément(*parseuse.pile_éléments_ouvert, parseuse.élément_head)
            retourne
        }
    }

    si lexème.genre == GenreLexème.FinTag {
        si lexème.nom == "template" {
            gère_lexème_pour_mode(parseuse, insère_mode_DansHead, lexème)
            retourne
        }

        si !fait_partie_de(lexème.nom, "body", "html", "br") {
            retourne
        }
    }

    lexème_body := Lexème(genre = GenreLexème.DébutTag, nom = "body")
    élément := parseuse.insère_élément_html(lexème_body)
    parseuse.mode_insertion = insère_mode_DansBody
    gère_lexème_pour_mode(parseuse, parseuse.mode_insertion, lexème)
}

insère_mode_DansBody :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    // continue le spec à An end tag whose tag name is "p"

    si lexème.genre == GenreLexème.Caractère {
        si lexème.point_de_code == 0x0 {
            // ignore
            retourne
        }

        // À FAIRE : reconstruit les éléments de formattage actifs
        parseuse.insère_caractère(lexème.point_de_code)

        si !est_caractère_espace_blanc(lexème.point_de_code) {
            parseuse.frameset_ok = faux
        }

        retourne
    }

    si lexème.genre == GenreLexème.Commentaire {
        insère_commentaire(parseuse, lexème)
        retourne
    }

    si lexème.genre == GenreLexème.DébutTag {
        si lexème.nom == "html" {
            panique("algorithme d'insertion incomplet")
        }

        si fait_partie_de(lexème.nom, "base", "basefont", "bgsound", "link", "meta", "noframes", "script", "style", "template", "title") {
            gère_lexème_pour_mode(parseuse, insère_mode_DansHead, lexème)
            retourne
        }

        si lexème.nom == "body" {
            si taille(*parseuse.pile_éléments_ouvert) == 1 {
                retourne
            }

            si parseuse.pile_éléments_ouvert.éléments[1].texte != "body" {
                retourne
            }

            si possède_dans_portée(*parseuse.pile_éléments_ouvert, "template") {
                retourne
            }

            élément_body := parseuse.pile_éléments_ouvert.éléments[1]
            parseuse.frameset_ok = faux

            pour lexème.attributs {
                si !élément_body.possède_attribut(it.nom) {
                    élément_body.ajoute_attribut(it.nom, it.valeur)
                }
            }

            retourne
        }

        si lexème.nom == "frameset" {
            panique("algorithme d'insertion incomplet")
        }

        si lexème.nom == "form" {
            template_dans_portée := possède_dans_portée(*parseuse.pile_éléments_ouvert, "template")

            si parseuse.élément_form != nul && !template_dans_portée {
                // parser error, ignore le lexème
                retourne
            }

            si possède_dans_portée_button(*parseuse.pile_éléments_ouvert, "p") {
                ferme_un_élément_p(parseuse)
            }

            élément := parseuse.insère_élément_html(lexème)

            si !template_dans_portée {
                parseuse.élément_form = élément
            }

            retourne
        }

        si lexème.nom == "li" {
            parseuse.frameset_ok = vrai

            index := taille(*parseuse.pile_éléments_ouvert) - 1

            boucle {
                noeud := parseuse.pile_éléments_ouvert.éléments[index]

                si noeud.texte == "li" {
                    parseuse.génère_tags_fin_implicites_autres_que("li")

                    noeud = parseuse.noeud_courant()

                    si noeud.texte != "li" {
                        erreur_de_parsage("le noeud courant n'est pas un <li>")
                    }

                    tantque noeud.texte != "li" {
                        dépile(*parseuse.pile_éléments_ouvert)
                        noeud = parseuse.noeud_courant()
                    }
                    dépile(*parseuse.pile_éléments_ouvert)

                    arrête
                }

                si fait_partie_de_catégorie_spécial(noeud.texte) && !fait_partie_de(noeud.texte, "address", "div", "p") {
                    arrête
                }

                noeud = parseuse.pile_éléments_ouvert.éléments[index]
                index -= 1
            }

            si possède_dans_portée_button(*parseuse.pile_éléments_ouvert, "p") {
                ferme_un_élément_p(parseuse)
            }

            _ := insère_élément_html(parseuse, lexème)
            retourne
        }

        si fait_partie_de(lexème.nom, "address", "article", "aside", "blockquote", "center", "details", "dialog", "dir", "div", "dl", "fieldset", "figcaption", "figure", "footer", "header", "hgroup", "main", "menu", "nav", "ol", "p", "section", "summary", "ul") {
            si possède_dans_portée_button(*parseuse.pile_éléments_ouvert, "p") {
                ferme_un_élément_p(parseuse)
            }

            _ := insère_élément_html(parseuse, lexème)
            retourne
        }

        si fait_partie_de(lexème.nom, "h1", "h2", "h3", "h4", "h5", "h6") {
            si possède_dans_portée_button(*parseuse.pile_éléments_ouvert, "p") {
                ferme_un_élément_p(parseuse)
            }

            noeud := parseuse.noeud_courant()
            si fait_partie_de(noeud.texte, "h1", "h2", "h3", "h4", "h5", "h6") {
                erreur_de_parsage("élément <h> ouvert quand un autre <h> s'ouvre")
                dépile(*parseuse.pile_éléments_ouvert)
            }

            _ := insère_élément_html(parseuse, lexème)
            retourne
        }

        si fait_partie_de(lexème.nom, "pre", "listing") {
            si possède_dans_portée_button(*parseuse.pile_éléments_ouvert, "p") {
                ferme_un_élément_p(parseuse)
            }

            _ := insère_élément_html(parseuse, lexème)
            // À FAIRE : ignore le token suivant si c'est un caractère de nouvelle ligne (0x0A)
            parseuse.frameset_ok = faux
            retourne
        }

        si fait_partie_de(lexème.nom, "dd", "dt") {
            parseuse.frameset_ok = faux
            index := parseuse.pile_éléments_ouvert.éléments.taille - 1

            boucle {
                noeud := parseuse.pile_éléments_ouvert.éléments[index]

                si noeud.texte == "dd" {
                    parseuse.génère_tags_fin_implicites_autres_que("dd")

                    si parseuse.noeud_courant().texte != "dd" {
                        erreur_de_parsage("le noeud courant doit être un <dd>")
                    }

                    parseuse.dépile_tous_les_éléments_jusque("dd")
                    arrête
                }
                sinon si noeud.texte == "dt" {
                    parseuse.génère_tags_fin_implicites_autres_que("dt")

                    si parseuse.noeud_courant().texte != "dt" {
                        erreur_de_parsage("le noeud courant doit être un <dt>")
                    }

                    parseuse.dépile_tous_les_éléments_jusque("dt")
                    arrête
                }
                sinon si fait_partie_de_catégorie_spécial(noeud.texte) && !fait_partie_de("address", "div", "p") {
                    arrête
                }

                index -= 1
            }

            si possède_dans_portée_button(*parseuse.pile_éléments_ouvert, "p") {
                parseuse.ferme_un_élément_p()
            }

            _ := parseuse.insère_élément_html(lexème)
            retourne
        }

        si lexème.nom == "plaintext" {
            panique("algorithme d'insertion incomplet")
        }

        si lexème.nom == "button" {
            si possède_dans_portée(*parseuse.pile_éléments_ouvert, "button") {
                erreur_de_parsage("<button> déjà ouvert lors de l'ouverture d'un <button>")
                génère_tags_fin_implicites(parseuse)

                dépile_tous_les_éléments_jusque(parseuse, "button")
            }

            parseuse.reconstruit_liste_des_éléments_de_formattage_actifs()

            _ := insère_élément_html(parseuse, lexème)
            parseuse.frameset_ok = faux
            retourne
        }

        si lexème.nom == "a" {
            élément := élément_avant_marqueur(*parseuse.liste_éléments_actifs_formattage, "a")

            si élément != nul {
                // erreur de parsage
                parseuse.lance_algorithme_adoption(lexème)
                supprime_élément(*parseuse.liste_éléments_actifs_formattage, élément)
                supprime_élément(*parseuse.pile_éléments_ouvert, élément)
            }

            parseuse.reconstruit_liste_des_éléments_de_formattage_actifs()
            élément = insère_élément_html(parseuse, lexème)
            pousse_sur_liste_éléments_actifs(parseuse, élément, lexème)
            retourne
        }

        si fait_partie_de(lexème.nom, "b", "big", "code", "em", "font", "i", "s", "small", "strike", "strong", "tt", "u") {
            parseuse.reconstruit_liste_des_éléments_de_formattage_actifs()
            élément := insère_élément_html(parseuse, lexème)
            pousse_sur_liste_éléments_actifs(parseuse, élément, lexème)
            retourne
        }

        si lexème.nom == "nobr" {
            parseuse.reconstruit_liste_des_éléments_de_formattage_actifs()
            _ := parseuse.insère_élément_html(lexème)
            ajoute_marqueur(*parseuse.liste_éléments_actifs_formattage)
            parseuse.frameset_ok = faux
            retourne
        }

        si fait_partie_de(lexème.nom, "applet", "marquee", "object") {
            panique("algorithm d'insertion incomplet")
        }

        si lexème.nom == "table" {
            si !parseuse.document.quirks_mode && possède_dans_portée_button(*parseuse.pile_éléments_ouvert, "p") {
                ferme_un_élément_p(parseuse)
            }

            _ := insère_élément_html(parseuse, lexème)
            parseuse.frameset_ok = faux
            parseuse.mode_insertion = insère_mode_DansTable
            retourne
        }

        si fait_partie_de(lexème.nom, "area", "br", "embed", "img", "keygen", "wbr") {
            parseuse.reconstruit_liste_des_éléments_de_formattage_actifs()
            _ := parseuse.insère_élément_html(lexème)
            dépile(*parseuse.pile_éléments_ouvert)
            reconnait_drapeau_auto_fermant(*lexème)
            parseuse.frameset_ok = faux
            retourne
        }

        si lexème.nom == "input" {
            parseuse.reconstruit_liste_des_éléments_de_formattage_actifs()
            _ := parseuse.insère_élément_html(lexème)
            dépile(*parseuse.pile_éléments_ouvert)
            reconnait_drapeau_auto_fermant(*lexème)
            // À FAIRE : parseuse.frameset_ok = !élément.possède_attribut("type") || élément.attribut("type") == "hidden" // case-insensitive
            //parseuse.frameset_ok = faux
            retourne
        }

        si fait_partie_de(lexème.nom, "param", "source", "track") {
            _ := parseuse.insère_élément_html(lexème)
            dépile(*parseuse.pile_éléments_ouvert)
            reconnait_drapeau_auto_fermant(*lexème)
            retourne
        }

        si lexème.nom == "hr" {
            si possède_dans_portée_button(*parseuse.pile_éléments_ouvert, "p") {
                parseuse.ferme_un_élément_p()
            }

            _ := parseuse.insère_élément_html(lexème)
            dépile(*parseuse.pile_éléments_ouvert)
            reconnait_drapeau_auto_fermant(*lexème)
            parseuse.frameset_ok = faux
            retourne
        }

        si lexème.nom == "image" {
            lexème.nom = copie_chaine("img")
            gère_lexème_pour_mode(parseuse, parseuse.mode_insertion, lexème)
            retourne
        }

        si lexème.nom == "textarea" {
            _ := insère_élément_html(parseuse, lexème)

            curseur := parseuse.lexeuse.curseur
            lexème_suiv := lexème_suivant(*parseuse.lexeuse)

            si lexème_suiv.genre != GenreLexème.Caractère || lexème_suiv.point_de_code != NOUVELLE_LIGNE {
                // si nous n'avons pas de nouvelle ligne restaure l'état de la lexeuse, car celles-ci sont ignorées par convénience
                détruit_lexème(*lexème_suiv)
                parseuse.lexeuse.curseur = curseur
            }

            parseuse.lexeuse.état = ÉtatLexage.RCDATA
            parseuse.mode_insertion_original = parseuse.mode_insertion
            parseuse.mode_insertion = insère_mode_Texte
            parseuse.frameset_ok = faux
            retourne
        }

        si lexème.nom == "xmp" {
            si possède_dans_portée_button(*parseuse.pile_éléments_ouvert, "p") {
                parseuse.ferme_un_élément_p()
            }

            parseuse.reconstruit_liste_des_éléments_de_formattage_actifs()
            parseuse.frameset_ok = faux
            parseuse.gère_élément_contenant_texte_cru(lexème, ÉtatLexage.RCDATA)
            retourne
        }

        si lexème.nom == "iframe" {
            parseuse.frameset_ok = faux
            gère_élément_contenant_texte_cru(parseuse, lexème, ÉtatLexage.RAWTEXT)
            retourne
        }

        si lexème.nom == "noembed" || (lexème.nom == "noscript" && parseuse.scripting_flag == vrai) {
            gère_élément_contenant_texte_cru(parseuse, lexème, ÉtatLexage.RAWTEXT)
            retourne
        }

        si lexème.nom == "select" {
            parseuse.reconstruit_liste_des_éléments_de_formattage_actifs()
            _ := parseuse.insère_élément_html(lexème)
            parseuse.frameset_ok = faux

            si fait_partie_de(parseuse.mode_insertion, insère_mode_DansTable, insère_mode_DansCaption, insère_mode_DansCorpsTable, insère_mode_DansRow, insère_mode_DansCell) {
                parseuse.mode_insertion = insère_mode_DansSelectDansTable
            }
            sinon {
                parseuse.mode_insertion = insère_mode_DansSelect
            }

            retourne
        }

        si lexème.nom == "optgroup" || lexème.nom == "option" {
            si parseuse.noeud_courant().texte == "option" {
                dépile(*parseuse.pile_éléments_ouvert)
            }

            parseuse.reconstruit_liste_des_éléments_de_formattage_actifs()
            _ := parseuse.insère_élément_html(lexème)
            retourne
        }

        si lexème.nom == "rb" || lexème.nom == "rtc" {
            si possède_dans_portée(*parseuse.pile_éléments_ouvert, "ruby") {
                parseuse.génère_tags_fin_implicites()

                si parseuse.noeud_courant().texte != "ruby" {
                    erreur_de_parsage("attendu un élément <ruby>")
                }

                _ := parseuse.insère_élément_html(lexème)
                retourne
            }
        }

        si lexème.nom == "rp" || lexème.nom == "rt" {
            si possède_dans_portée(*parseuse.pile_éléments_ouvert, "ruby") {
                parseuse.génère_tags_fin_implicites_autres_que("rtc")

                si !fait_partie_de(parseuse.noeud_courant().texte, "ruby", "rtc") {
                    erreur_de_parsage("attendu un élément <ruby> ou <rtc>")
                }

                _ := parseuse.insère_élément_html(lexème)
                retourne
            }
        }

        si lexème.nom == "math" {
            panique("algorithm d'insertion incomplet")
        }

        si lexème.nom == "svg" {
            parseuse.reconstruit_liste_des_éléments_de_formattage_actifs()
            // À FAIRE : ajuste les attributs SVG
            // À FAIRE : ajuste les attributs étrangers
            // À FAIRE : insère dans l'espace de nom SVG
            _ := parseuse.insère_élément_html(lexème)

            si lexème.auto_fermant {
                reconnait_drapeau_auto_fermant(*lexème)
                dépile(*parseuse.pile_éléments_ouvert)
            }

            retourne
        }

        si fait_partie_de(lexème.nom, "caption", "col", "colgroup", "frame", "head", "tbody", "td", "tfoot", "th", "thead", "tr") {
            // erreur de parsage, ignore le lexème
            retourne
        }

        parseuse.reconstruit_liste_des_éléments_de_formattage_actifs()
        _ := parseuse.insère_élément_html(lexème)
        retourne
    }

    si lexème.genre == GenreLexème.FinTag {
        si lexème.nom == "template" {
            gère_lexème_pour_mode(parseuse, insère_mode_DansHead, lexème)
            retourne
        }

        si lexème.nom == "body" {
            si !possède_dans_portée(*parseuse.pile_éléments_ouvert, "body") {
                // À FAIRE : comprendre ce que la spec veut dire
            }

            parseuse.mode_insertion = insère_mode_AprèsBody
            retourne
        }

        si lexème.nom == "html" {
            si !possède_dans_portée(*parseuse.pile_éléments_ouvert, "body") {
                // À FAIRE : comprendre ce que la spec veut dire
            }

            parseuse.mode_insertion = insère_mode_AprèsBody
            gère_lexème_pour_mode(parseuse, parseuse.mode_insertion, lexème)
            retourne
        }

        si fait_partie_de(lexème.nom, "address", "article", "aside", "blockquote", "button", "center", "details", "dialog", "dir", "div", "dl", "fieldset", "figcaption", "figure", "footer", "header", "hgroup", "listing", "main", "menu", "nav", "ol", "pre", "section", "summary", "ul") {
            si !possède_dans_portée(*parseuse.pile_éléments_ouvert, lexème.nom) {
                erreur_de_parsage("la portée ne possède aucun élément du même tag de fin")
                retourne
            }

            parseuse.génère_tags_fin_implicites()

            noeud := parseuse.noeud_courant()

            si noeud.texte != lexème.nom {
                erreur_de_parsage("le noeud courrant ne possède pas le même tag de fin")
            }

            dépile_tous_les_éléments_jusque(parseuse, lexème.nom)
            retourne
        }

        si lexème.nom == "form" {
            template_dans_portée := possède_dans_portée(*parseuse.pile_éléments_ouvert, "template")

            si !template_dans_portée {
                noeud := parseuse.élément_form
                parseuse.élément_form = nul

                si noeud == nul || !possède_dans_portée(*parseuse.pile_éléments_ouvert, noeud) {
                    // erreur de parsage ignore
                    retourne
                }

                parseuse.génère_tags_fin_implicites()

                si noeud != parseuse.noeud_courant() {
                    erreur_de_parsage("l'élément <form> n'est pas le noeud courrant")
                }

                supprime_élément(*parseuse.pile_éléments_ouvert, noeud)
            }
            sinon {
                si !possède_dans_portée(*parseuse.pile_éléments_ouvert, "form") {
                    erreur_de_parsage("<form> n'est pas la dans la portée")
                    retourne
                }

                parseuse.génère_tags_fin_implicites()

                noeud := parseuse.noeud_courant()

                si noeud.texte != "form" {
                    erreur_de_parsage("attendu un élément <form>")
                }

                dépile_tous_les_éléments_jusque(parseuse, "form")
            }

            retourne
        }

        si lexème.nom == "p" {
            si !possède_dans_portée_button(*parseuse.pile_éléments_ouvert, "p") {
                erreur_de_parsage("aucun <p> ouvert dans une portée <button>")

                lexème_p : Lexème
                lexème_p.genre = GenreLexème.DébutTag
                lexème_p.nom = "p"
                _ := insère_élément_html(parseuse, lexème_p)
            }

            ferme_un_élément_p(parseuse)
            retourne
        }

        si lexème.nom == "li" {
            si !possède_dans_portée_list_item(*parseuse.pile_éléments_ouvert, "li") {
                erreur_de_parsage("aucun <li> dans portée list item")
                retourne
            }

            parseuse.génère_tags_fin_implicites_autres_que("li")

            noeud := parseuse.noeud_courant()

            si noeud.texte != "li" {
                erreur_de_parsage("le noeud courant n'est pas un <li>")
            }

            dépile_tous_les_éléments_jusque(parseuse, "li")
            retourne
        }

        si lexème.nom == "dd" || lexème.nom == "dt" {
            si !possède_dans_portée(*parseuse.pile_éléments_ouvert, lexème.nom) {
                erreur_de_parsage("aucun <dd> ou <dt> dans la portée")
                retourne
            }

            parseuse.génère_tags_fin_implicites_autres_que(lexème.nom)

            si parseuse.noeud_courant().texte != lexème.nom {
                erreur_de_parsage("le noeud courant n'est ni un <dd> ni un <dt>")
            }

            parseuse.dépile_tous_les_éléments_jusque(lexème.nom)
            retourne
        }

        si fait_partie_de(lexème.nom, "h1", "h2", "h3", "h4", "h5", "h6") {
            si !possède_dans_portée(*parseuse.pile_éléments_ouvert, lexème.nom) {
                erreur_de_parsage("aucun élément <h> dans la porté")
                retourne
            }

            parseuse.génère_tags_fin_implicites()

            noeud := parseuse.noeud_courant()

            si noeud.texte != lexème.nom {
                erreur_de_parsage("le noeud courant n'a pas de balise <h>")
                imprime("balise : <%>\n", lexème.nom)
            }

            dépile_tous_les_éléments_jusque(parseuse, lexème.nom)
            retourne
        }

        si fait_partie_de(lexème.nom, "a", "b", "big", "code", "em", "font", "i", "nobr", "s", "small", "strike", "strong", "tt", "u") {
            parseuse.lance_algorithme_adoption(lexème)
            retourne
        }

        si fait_partie_de(lexème.nom, "applet", "marquee", "object") {
            panique("algorithm d'insertion incomplet")
        }

        si lexème.nom == "br" {
            panique("algorithm d'insertion incomplet")
        }

        tout_autre_tag_fin_DansBody(parseuse, lexème)
        retourne
    }

    si lexème.genre == GenreLexème.FinDeFichier {
        panique("algorithme d'insertion incomplet")
    }
}

insère_mode_Texte :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    si lexème.genre == GenreLexème.Caractère {
        parseuse.insère_caractère(lexème.point_de_code)
        retourne
    }

    si lexème.genre == GenreLexème.FinDeFichier {
        // À FAIRE : gère élément script

        dépile(*parseuse.pile_éléments_ouvert)
        parseuse.mode_insertion = parseuse.mode_insertion_original
        gère_lexème_pour_mode(parseuse, parseuse.mode_insertion, lexème)
        retourne
    }

    si lexème.genre == GenreLexème.FinTag && lexème.nom == "script" {
        // À FAIRE : JavaScript execution context stack

        script := parseuse.noeud_courant()
        dépile(*parseuse.pile_éléments_ouvert)
        parseuse.mode_insertion = parseuse.mode_insertion_original

        // À FAIRE : old insertion point
        // À FAIRE : prépare le script

        parseuse.niveau_imbrication_script -= 1
        parseuse.pause = parseuse.niveau_imbrication_script == 0

        // À FAIRE : restaure insertion point (insertion_point = old_insertion_point)
        // À FAIRE : pending parsing-blocking script
        retourne
    }

    dépile(*parseuse.pile_éléments_ouvert)
    parseuse.mode_insertion = parseuse.mode_insertion_original
}

insère_mode_DansTable :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    si lexème.genre == GenreLexème.Caractère {
        noeud := parseuse.noeud_courant()

        si fait_partie_de(noeud.texte, "table", "tbody", "tfoot", "thead", "tr") {
            // À FAIRE
            retourne
        }
    }

    si lexème.genre == GenreLexème.Commentaire {
        parseuse.insère_commentaire(lexème)
        retourne
    }

    si lexème.genre == GenreLexème.Doctype {
        erreur_de_parsage("doctype dans table")
        retourne
    }

    si lexème.genre == GenreLexème.DébutTag {
        si lexème.nom == "caption" {
            parseuse.dépile_vers_contexte_table()
            _ := parseuse.insère_élément_html(lexème)
            parseuse.mode_insertion = insère_mode_DansCaption
            retourne
        }

        si lexème.nom == "colgroup" {
            parseuse.dépile_vers_contexte_table()
            _ := parseuse.insère_élément_html(lexème)
            parseuse.mode_insertion = insère_mode_DansGroupeColonne
            retourne
        }

        si lexème.nom == "col" {
            parseuse.dépile_vers_contexte_table()

            lexème_col : Lexème
            lexème_col.nom = "colgroup"
            lexème_col.genre = GenreLexème.DébutTag
            _ := parseuse.insère_élément_html(lexème_col)

            parseuse.mode_insertion = insère_mode_DansGroupeColonne
            parseuse.gère_lexème_pour_mode(parseuse.mode_insertion, lexème)
            retourne
        }

        si fait_partie_de(lexème.nom, "tbody", "tfoot", "thead") {
            parseuse.dépile_vers_contexte_table()
            _ := parseuse.insère_élément_html(lexème)
            parseuse.mode_insertion = insère_mode_DansCorpsTable
            retourne
        }

        si fait_partie_de(lexème.nom, "td", "th", "tr") {
            parseuse.dépile_vers_contexte_table()

            lexème_tbody : Lexème
            lexème_tbody.nom = "tbody"
            lexème_tbody.genre = GenreLexème.DébutTag
            _ := parseuse.insère_élément_html(lexème_tbody)

            parseuse.mode_insertion = insère_mode_DansCorpsTable
            parseuse.gère_lexème_pour_mode(parseuse.mode_insertion, lexème)
            retourne
        }

        si lexème.nom == "table" {
            erreur_de_parsage("<table> dans <table>")

            si !possède_dans_portée_table(*parseuse.pile_éléments_ouvert, "table") {
                retourne
            }

            parseuse.dépile_tous_les_éléments_jusque("table")
            parseuse.restaure_mode_insertion_appropriemment()
            parseuse.gère_lexème_pour_mode(parseuse.mode_insertion, lexème)
            retourne
        }

        si fait_partie_de(lexème.nom, "style", "script", "template") {
            parseuse.gère_lexème_pour_mode(insère_mode_DansHead, lexème)
            retourne
        }

        si lexème.nom == "input" {
            attr := cherche_attribut(*lexème, "type")

            si attr == nul || !compare_ascii_insensible_à_la_casse(attr.valeur, "hidden") {
                erreur_de_parsage("lexème inattendu dans table")
                parseuse.adoption_activée = vrai
                parseuse.gère_lexème_pour_mode(insère_mode_DansBody, lexème)
                parseuse.adoption_activée = faux
                retourne
            }

            _ := parseuse.insère_élément_html(lexème)
            dépile(*parseuse.pile_éléments_ouvert)
            reconnait_drapeau_auto_fermant(*lexème)
            retourne
        }

        si lexème.nom == "form" {
            erreur_de_parsage("<form> dans <table>")

            si parseuse.élément_form != nul || possède_dans_portée(*parseuse.pile_éléments_ouvert, "template") {
                // ignore
                retourne
            }

            parseuse.élément_form = parseuse.insère_élément_html(lexème)
            dépile(*parseuse.pile_éléments_ouvert)
            retourne
        }
    }

    si lexème.genre == GenreLexème.FinTag {
        si lexème.nom == "table" {
            si !possède_dans_portée_table(*parseuse.pile_éléments_ouvert, "table") {
                erreur_de_parsage("auncune <table> dans la portée table")
                retourne
            }

            parseuse.dépile_tous_les_éléments_jusque("table")
            parseuse.restaure_mode_insertion_appropriemment()
            retourne
        }

        si fait_partie_de(lexème.nom, "body", "caption", "col", "colgroup", "html", "tbody", "td", "tfoot", "th", "thead", "tr") {
            erreur_de_parsage("balise inattendue dans <table>")
            retourne
        }

        si lexème.nom == "template" {
            parseuse.gère_lexème_pour_mode(insère_mode_DansHead, lexème)
            retourne
        }
    }

    si lexème.genre == GenreLexème.FinDeFichier {
        parseuse.gère_lexème_pour_mode(insère_mode_DansBody, lexème)
        retourne
    }

    erreur_de_parsage("lexème inattendu dans table")
    parseuse.adoption_activée = vrai
    parseuse.gère_lexème_pour_mode(insère_mode_DansBody, lexème)
    parseuse.adoption_activée = faux
}

insère_mode_DansTexteTable :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    panique("algorithme d'insertion incomplet")
}

insère_mode_DansCaption :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    panique("algorithme d'insertion incomplet")
}

insère_mode_DansGroupeColonne :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    panique("algorithme d'insertion incomplet")
}

insère_mode_DansCorpsTable :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    si lexème.genre == GenreLexème.DébutTag {
        si lexème.nom == "tr" {
            parseuse.dépile_vers_contexte_table_body()
            _ := parseuse.insère_élément_html(lexème)
            parseuse.mode_insertion = insère_mode_DansRow
            retourne
        }

        si fait_partie_de(lexème.nom, "th", "td") {
            erreur_de_parsage("<th> ou <td> dans corps table")
            parseuse.dépile_vers_contexte_table_body()

            lexème_tr : Lexème
            lexème_tr.genre = GenreLexème.DébutTag
            lexème_tr.nom = "tr"
            _ := parseuse.insère_élément_html(lexème)

            parseuse.mode_insertion = insère_mode_DansRow
            parseuse.gère_lexème_pour_mode(parseuse.mode_insertion, lexème)
            retourne
        }

        si fait_partie_de(lexème.nom, "caption", "col", "colgroup", "tbody", "tfoot", "thead") {
            // À FAIRE : vérifier qu'il y a un tbody, thead, ou tfoot dans une portée table, si non : erreur de parsage ignore

            parseuse.dépile_vers_contexte_table_body()
            dépile(*parseuse.pile_éléments_ouvert)
            parseuse.mode_insertion = insère_mode_DansTable
            parseuse.gère_lexème_pour_mode(parseuse.mode_insertion, lexème)
            retourne
        }
    }

    si lexème.genre == GenreLexème.FinTag {
        si fait_partie_de(lexème.nom, "tbody", "tfoot", "thead") {
            si !possède_dans_portée_table(*parseuse.pile_éléments_ouvert, lexème.nom) {
                erreur_de_parsage("élément hors d'une portée <table>")
                // ignore
                retourne
            }

            parseuse.dépile_vers_contexte_table_body()
            dépile(*parseuse.pile_éléments_ouvert)
            parseuse.mode_insertion = insère_mode_DansTable
            retourne
        }

        si lexème.nom == "table" {
            // À FAIRE : vérifier qu'il y a un tbody, thead, ou tfoot dans une portée table, si non : erreur de parsage ignore

            parseuse.dépile_vers_contexte_table_body()
            dépile(*parseuse.pile_éléments_ouvert)
            parseuse.mode_insertion = insère_mode_DansTable
            parseuse.gère_lexème_pour_mode(parseuse.mode_insertion, lexème)
            retourne
        }

        si fait_partie_de(lexème.nom, "body", "caption", "col", "colgroup", "html", "td", "th", "tr") {
            erreur_de_parsage("élément invalide dans <table>")
        }
    }

    parseuse.gère_lexème_pour_mode(insère_mode_DansTable, lexème)
}

insère_mode_DansRow :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    si lexème.genre == GenreLexème.DébutTag {
        si fait_partie_de(lexème.nom, "th", "td") {
            parseuse.dépile_vers_contexte_table_row()
            _ := parseuse.insère_élément_html(lexème)
            parseuse.mode_insertion = insère_mode_DansCell
            ajoute_marqueur(*parseuse.liste_éléments_actifs_formattage)
            retourne
        }

        si fait_partie_de(lexème.nom, "caption", "col", "colgroup", "tbody", "tfoot", "thead", "tr") {
            si !possède_dans_portée_table(*parseuse.pile_éléments_ouvert, "tr") {
                erreur_de_parsage("élément invalide dans <tr>")
                retourne
            }

            parseuse.dépile_vers_contexte_table_row()
            dépile(*parseuse.pile_éléments_ouvert)
            parseuse.mode_insertion = insère_mode_DansCorpsTable
            parseuse.gère_lexème_pour_mode(parseuse.mode_insertion, lexème)
            retourne
        }
    }

    si lexème.genre == GenreLexème.FinTag {
        si lexème.nom == "tr" {
            si !possède_dans_portée_table(*parseuse.pile_éléments_ouvert, "tr") {
                erreur_de_parsage("<tr> manquant dans portée <table>")
                retourne
            }

            parseuse.dépile_vers_contexte_table_row()
            dépile(*parseuse.pile_éléments_ouvert)
            parseuse.mode_insertion = insère_mode_DansCorpsTable
            retourne
        }

        si lexème.nom == "table" {
            si !possède_dans_portée_table(*parseuse.pile_éléments_ouvert, "tr") {
                erreur_de_parsage("élément invalide dans <tr>")
                retourne
            }

            parseuse.dépile_vers_contexte_table_row()
            dépile(*parseuse.pile_éléments_ouvert)
            parseuse.mode_insertion = insère_mode_DansCorpsTable
            parseuse.gère_lexème_pour_mode(parseuse.mode_insertion, lexème)
            retourne
        }

        si fait_partie_de(lexème.nom, "tbody", "tfoot", "thead") {
            si !possède_dans_portée_table(*parseuse.pile_éléments_ouvert, lexème.nom) {
                erreur_de_parsage("élément manquant dans <tr>")
                retourne
            }

            si !possède_dans_portée_table(*parseuse.pile_éléments_ouvert, "tr") {
                retourne
            }

            parseuse.dépile_vers_contexte_table_row()
            dépile(*parseuse.pile_éléments_ouvert)
            parseuse.mode_insertion = insère_mode_DansCorpsTable
            parseuse.gère_lexème_pour_mode(parseuse.mode_insertion, lexème)
            retourne
        }

        si fait_partie_de(lexème.nom, "body", "caption", "col", "colgroup", "html", "td", "th") {
            erreur_de_parsage("élément invalide dans <tr>")
            retourne
        }
    }

    parseuse.gère_lexème_pour_mode(insère_mode_DansTable, lexème)
}

insère_mode_DansCell :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    si lexème.genre == GenreLexème.FinTag {
        si fait_partie_de(lexème.nom, "td", "th") {
            si !possède_dans_portée_table(*parseuse.pile_éléments_ouvert, lexème.nom) {
                erreur_de_parsage("aucun élément du type dans portée <table>")
                retourne
            }

            parseuse.génère_tags_fin_implicites()

            si parseuse.noeud_courant().texte != lexème.nom {
                erreur_de_parsage("le noeud courant n'est pas de la même balise")
            }

            parseuse.dépile_tous_les_éléments_jusque(lexème.nom)
            enlève_éléments_jusqu_au_dernier_marqueur(*parseuse.liste_éléments_actifs_formattage)
            parseuse.mode_insertion = insère_mode_DansRow
            retourne
        }

        si fait_partie_de(lexème.nom, "body", "caption", "col", "colgroup", "html") {
            erreur_de_parsage("élément invalide dans cellule")
            retourne
        }

        si fait_partie_de(lexème.nom, "table", "tbody", "tfoot", "thead", "tr") {
            si !possède_dans_portée_table(*parseuse.pile_éléments_ouvert, lexème.nom) {
                erreur_de_parsage("élément manquant de la portée <table>")
                retourne
            }

            parseuse.ferme_la_cellule()
            parseuse.gère_lexème_pour_mode(parseuse.mode_insertion, lexème)
            retourne
        }
    }

    si lexème.genre == GenreLexème.DébutTag {
        si fait_partie_de(lexème.nom, "caption", "col", "colgroup", "tbody", "td", "tfoot", "th", "thead", "tr") {
            si !possède_dans_portée_table(*parseuse.pile_éléments_ouvert, "td") && !possède_dans_portée_table(*parseuse.pile_éléments_ouvert, "th") {
                erreur_de_parsage("<td> ou <tr> manquant dans portée <table>")
                retourne
            }

            parseuse.ferme_la_cellule()
            parseuse.gère_lexème_pour_mode(parseuse.mode_insertion, lexème)
            retourne
        }
    }

    parseuse.gère_lexème_pour_mode(insère_mode_DansBody, lexème)
}

insère_mode_DansSelect :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    si lexème.genre == GenreLexème.Caractère {
        si lexème.point_de_code == NUL {
            erreur_de_parsage("caractère nul dans <select>")
            retourne
        }

        parseuse.insère_caractère(lexème.point_de_code)
        retourne
    }

    si lexème.genre == GenreLexème.Commentaire {
        parseuse.insère_commentaire(lexème)
        retourne
    }

    si lexème.genre == GenreLexème.Doctype {
        erreur_de_parsage("<doctype> dans <select>")
        retourne
    }

    si lexème.genre == GenreLexème.DébutTag {
        si lexème.nom == "html" {
            parseuse.gère_lexème_pour_mode(insère_mode_DansBody, lexème)
            retourne
        }

        si lexème.nom == "option" {
            si parseuse.noeud_courant().texte == "option" {
                dépile(*parseuse.pile_éléments_ouvert)
            }

            _ := parseuse.insère_élément_html(lexème)
            retourne
        }

        si lexème.nom == "optgroup" {
            si parseuse.noeud_courant().texte == "option" {
                dépile(*parseuse.pile_éléments_ouvert)
            }

            si parseuse.noeud_courant().texte == "optgroup" {
                dépile(*parseuse.pile_éléments_ouvert)
            }

            _ := parseuse.insère_élément_html(lexème)
            retourne
        }

        si lexème.nom == "select" {
            erreur_de_parsage("<select> inattendu")

            si !possède_dans_portée_select(*parseuse.pile_éléments_ouvert, "select") {
                erreur_de_parsage("aucun <select> dans la portée <select>")
                retourne
            }

            parseuse.dépile_tous_les_éléments_jusque("select")
            parseuse.restaure_mode_insertion_appropriemment()
            retourne
        }

        si fait_partie_de(lexème.nom, "input", "keygen", "textarea") {
            erreur_de_parsage("élément inattendu dans <select>")

            si !possède_dans_portée_select(*parseuse.pile_éléments_ouvert, "select") {
                erreur_de_parsage("aucun <select> dans la portée <select>")
                retourne
            }

            parseuse.dépile_tous_les_éléments_jusque("select")
            parseuse.restaure_mode_insertion_appropriemment()
            retourne
        }

        si fait_partie_de(lexème.nom, "script", "template") {
            parseuse.gère_lexème_pour_mode(insère_mode_DansHead, lexème)
            retourne
        }
    }

    si lexème.genre == GenreLexème.FinTag {
        si lexème.nom == "optgroup" {
            si parseuse.noeud_courant().texte == "option" && parseuse.pile_éléments_ouvert.éléments[parseuse.pile_éléments_ouvert.éléments.taille - 1].texte == "optgroup" {
                dépile(*parseuse.pile_éléments_ouvert)
            }

            si parseuse.noeud_courant().texte != "optgroup" {
                erreur_de_parsage("attendu <optgroup> sur la pile d'éléments ouverts")
                retourne
            }

            dépile(*parseuse.pile_éléments_ouvert)
            retourne
        }

        si lexème.nom == "option" {
            si parseuse.noeud_courant().texte != "option"  {
                erreur_de_parsage("attendu <option> sur la pile d'éléments ouverts")
                retourne
            }

            dépile(*parseuse.pile_éléments_ouvert)
            retourne
        }

        si lexème.nom == "select" {
            si !possède_dans_portée_select(*parseuse.pile_éléments_ouvert, "select") {
                erreur_de_parsage("aucun <select> dans la portée <select>")
                retourne
            }

            parseuse.dépile_tous_les_éléments_jusque("select")
            parseuse.restaure_mode_insertion_appropriemment()
            retourne
        }

        si fait_partie_de(lexème.nom, "template") {
            parseuse.gère_lexème_pour_mode(insère_mode_DansHead, lexème)
            retourne
        }
    }

    si lexème.genre == GenreLexème.FinDeFichier {
        parseuse.gère_lexème_pour_mode(insère_mode_DansBody, lexème)
        retourne
    }

    erreur_de_parsage("lexème inattendu dans <select>")
}

insère_mode_DansSelectDansTable :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    panique("algorithme d'insertion incomplet")
}

insère_mode_DansFrameSet :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    panique("algorithme d'insertion incomplet")
}

insère_mode_DansTemplate :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    si lexème.genre == GenreLexème.Caractère || lexème.genre == GenreLexème.Commentaire || lexème.genre == GenreLexème.Doctype {
        parseuse.gère_lexème_pour_mode(insère_mode_DansBody, lexème)
        retourne
    }

    si lexème.genre == GenreLexème.DébutTag {
        si fait_partie_de(lexème.nom,  "base", "basefont", "bgsound", "link", "meta", "noframes", "script", "style", "template", "title") {
            parseuse.gère_lexème_pour_mode(insère_mode_DansHead, lexème)
            retourne
        }

        si fait_partie_de(lexème.nom, "caption", "colgroup", "tbody", "tfoot", "thead") {
            parseuse.pile_insertion_template[parseuse.pile_insertion_template.taille - 1] = insère_mode_DansTable
            parseuse.mode_insertion = insère_mode_DansTable
            parseuse.gère_lexème_pour_mode(parseuse.mode_insertion, lexème)
            retourne
        }

        si lexème.nom == "col" {
            parseuse.pile_insertion_template[parseuse.pile_insertion_template.taille - 1] = insère_mode_DansGroupeColonne
            parseuse.mode_insertion = insère_mode_DansGroupeColonne
            parseuse.gère_lexème_pour_mode(parseuse.mode_insertion, lexème)
            retourne
        }

        si lexème.nom == "tr" {
            parseuse.pile_insertion_template[parseuse.pile_insertion_template.taille - 1] = insère_mode_DansCorpsTable
            parseuse.mode_insertion = insère_mode_DansCorpsTable
            parseuse.gère_lexème_pour_mode(parseuse.mode_insertion, lexème)
            retourne
        }

        si lexème.nom == "td" || lexème.nom == "th" {
            parseuse.pile_insertion_template[parseuse.pile_insertion_template.taille - 1] = insère_mode_DansRow
            parseuse.mode_insertion = insère_mode_DansRow
            parseuse.gère_lexème_pour_mode(parseuse.mode_insertion, lexème)
            retourne
        }

        parseuse.pile_insertion_template[parseuse.pile_insertion_template.taille - 1] = insère_mode_DansBody
        parseuse.mode_insertion = insère_mode_DansBody
        parseuse.gère_lexème_pour_mode(parseuse.mode_insertion, lexème)
        retourne
    }

    si lexème.genre == GenreLexème.FinTag {
        si lexème.nom == "template" {
            parseuse.gère_lexème_pour_mode(insère_mode_DansHead, lexème)
            retourne
        }

        erreur_de_parsage("fin de tag invalide dans <template>")
        retourne
    }

    si lexème.genre == GenreLexème.FinDeFichier {
        si !possède_dans_portée(*parseuse.pile_éléments_ouvert, "template") {
            parseuse.arrête_de_parser = vrai
            retourne
        }

        erreur_de_parsage("fin de fichier dans <template>")
        parseuse.dépile_tous_les_éléments_jusque("template")
        enlève_éléments_jusqu_au_dernier_marqueur(*parseuse.liste_éléments_actifs_formattage)
        parseuse.pile_insertion_template.taille -= 1
        parseuse.restaure_mode_insertion_appropriemment()
        parseuse.gère_lexème_pour_mode(parseuse.mode_insertion, lexème)
        retourne
    }
}

insère_mode_AprèsBody :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    si lexème.genre == GenreLexème.Caractère && est_caractère_espace_blanc(lexème.point_de_code) {
        gère_lexème_pour_mode(parseuse, insère_mode_DansBody, lexème)
        retourne
    }

    si lexème.genre == GenreLexème.Commentaire {
        // ajoute le comme enfant de l'élément html (le premier élément de la pile d'éléments ouverts)
        insère_commentaire(parseuse, lexème, parseuse.pile_éléments_ouvert.éléments[0])
        retourne
    }

    si lexème.genre == GenreLexème.Doctype {
        erreur_de_parsage("obtenu doctype après body")
        retourne
    }

    si lexème.genre == GenreLexème.DébutTag && lexème.nom == "html" {
        gère_lexème_pour_mode(parseuse, insère_mode_DansBody, lexème)
        retourne
    }

    si lexème.genre == GenreLexème.FinTag && lexème.nom == "html" {
        // À FAIRE : ignore si nous sommes dans un parsage de fragment html
        parseuse.mode_insertion = insère_mode_AprèsAprèsBody
        retourne
    }

    si lexème.genre == GenreLexème.FinDeFichier {
        parseuse.arrête_de_parser = vrai
        retourne
    }

    parseuse.mode_insertion = insère_mode_DansBody
    gère_lexème_pour_mode(parseuse, parseuse.mode_insertion, lexème)
}

insère_mode_AprèsAprèsBody :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    si lexème.genre == GenreLexème.Commentaire {
        insère_commentaire(parseuse, lexème, parseuse.document)
        retourne
    }

    si lexème.genre == GenreLexème.Doctype || (lexème.genre == GenreLexème.Caractère && est_caractère_espace_blanc(lexème.point_de_code)) || (lexème.genre == GenreLexème.DébutTag && lexème.nom == "html") {
        gère_lexème_pour_mode(parseuse, insère_mode_DansBody, lexème)
        retourne
    }

    si lexème.genre == GenreLexème.FinDeFichier {
        parseuse.arrête_de_parser = vrai
        retourne
    }

    parseuse.mode_insertion = insère_mode_DansBody
    gère_lexème_pour_mode(parseuse, parseuse.mode_insertion, lexème)
}

insère_mode_AprèsFrameSet :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    panique("algorithme d'insertion incomplet")
}

insère_mode_AprèsAprèsFrameSet :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    panique("algorithme d'insertion incomplet")
}

// NOTE : les trois fonctions suivantes sont des labels dans l'algorithme
__rewind :: fonc (parseuse: *Parseuse, entrée: EntréeFormattage, index: z64)
{
    si index == 0 {
        __create(parseuse, entrée, index)
        retourne
    }

    index -= 1

    entrée = parseuse.liste_éléments_actifs_formattage.entrées[index]

    si entrée.élément != nul || !possède(*parseuse.pile_éléments_ouvert, entrée.élément) {
        __rewind(parseuse, entrée, index)
        retourne
    }

    __advance(parseuse, entrée, index)
}

__create :: fonc (parseuse: *Parseuse, entrée: EntréeFormattage, index: z64)
{
    nouvel_élément := insère_élément_html(parseuse, entrée.lexème)
    parseuse.liste_éléments_actifs_formattage.entrées[index].élément = nouvel_élément
    entrée = parseuse.liste_éléments_actifs_formattage.entrées[index]

    si index != parseuse.liste_éléments_actifs_formattage.entrées.taille - 1 {
        __advance(parseuse, entrée, index)
    }
}

__advance :: fonc (parseuse: *Parseuse, entrée: EntréeFormattage, index: z64)
{
    index += 1
    entrée = parseuse.liste_éléments_actifs_formattage.entrées[index]
    __create(parseuse, entrée, index)
}

reconstruit_liste_des_éléments_de_formattage_actifs :: fonc (parseuse: *Parseuse)
{
    si est_vide(*parseuse.liste_éléments_actifs_formattage) {
        retourne
    }

    index := parseuse.liste_éléments_actifs_formattage.entrées.taille - 1

    entrée := parseuse.liste_éléments_actifs_formattage.entrées[index]

    si entrée.élément == nul || possède(*parseuse.pile_éléments_ouvert, entrée.élément) {
        retourne
    }

    __rewind(parseuse, entrée, index)
}

génère_tags_fin_implicites :: fonc (parseuse: *Parseuse)
{
    noeud := parseuse.noeud_courant()

    tantque fait_partie_de(noeud.texte, "dd", "dt", "li", "optgroup", "option", "p", "rb", "rt", "rtc") {
        dépile(*parseuse.pile_éléments_ouvert)
        noeud = parseuse.noeud_courant()
    }
}

génère_tags_fin_implicites_autres_que :: fonc (parseuse: *Parseuse, tag: chaine)
{
    noeud := parseuse.noeud_courant()

    tantque noeud.texte != tag && fait_partie_de(noeud.texte, "dd", "dt", "li", "optgroup", "option", "p", "rb", "rt", "rtc") {
        dépile(*parseuse.pile_éléments_ouvert)
        noeud = parseuse.noeud_courant()
    }
}

génère_tags_fin_implicites_attentivement :: fonc (parseuse: *Parseuse)
{
    noeud := parseuse.noeud_courant()

    tantque fait_partie_de(noeud.texte, "caption", "colgroup", "dd", "dt", "li", "optgroup", "option", "p", "rb", "rp", "rt", "rtc", "tbody", "td", "tfoot", "th", "thead", "tr") {
        dépile(*parseuse.pile_éléments_ouvert)
        noeud = parseuse.noeud_courant()
    }
}

pousse_sur_liste_éléments_actifs :: fonc (parseuse: *Parseuse, élément: *Élément, lexème: Lexème)
{
    // À FAIRE : vérifie si nous avons 3 éléments de même nom de tag
    ajoute(*parseuse.liste_éléments_actifs_formattage, élément, lexème)
}

lance_algorithme_adoption :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    sujet := lexème.nom
    noeud := parseuse.noeud_courant()

    si noeud.texte == sujet && !possède(*parseuse.liste_éléments_actifs_formattage, noeud) {
        dépile(*parseuse.pile_éléments_ouvert)
        retourne
    }

    outer_loop_counter := 0

    boucle {
        si outer_loop_counter >= 8 {
            retourne
        }

        outer_loop_counter += 1

        élément_formattage := élément_avant_marqueur(*parseuse.liste_éléments_actifs_formattage, sujet)

        si élément_formattage == nul {
            tout_autre_tag_fin_DansBody(parseuse, lexème)
            retourne
        }

        si !possède(*parseuse.pile_éléments_ouvert, élément_formattage) {
            erreur_de_parsage("l'élément de formattage n'est pas dans la pile d'élément ouvert")
            supprime_élément(*parseuse.liste_éléments_actifs_formattage, élément_formattage)
            retourne
        }

        si !possède_dans_portée(*parseuse.pile_éléments_ouvert, élément_formattage) {
            erreur_de_parsage("l'élément de formattage n'est pas dans la portée")
            retourne
        }

        si élément_formattage != parseuse.noeud_courant() {
            erreur_de_parsage("l'élément de formattage n'est pas le noeud courrant")
            // ne retourne pas
        }

        furthest_block := élément_spécial_précédent(*parseuse.pile_éléments_ouvert, élément_formattage)

        // À FAIRE : implémente correctement cet algorithme
        //si furthest_block == nul {
            tantque parseuse.noeud_courant() != élément_formattage {
                dépile(*parseuse.pile_éléments_ouvert)
            }
            dépile(*parseuse.pile_éléments_ouvert)

            supprime_élément(*parseuse.liste_éléments_actifs_formattage, élément_formattage)
            retourne
        //}

        common_ancestor := élément_précédent(*parseuse.pile_éléments_ouvert, élément_formattage)

        bookmark := index_élément_formattage(*parseuse.liste_éléments_actifs_formattage, élément_formattage)

        noeud = furthest_block
        dernier_noeud := furthest_block

        inner_loop_counter := 0
        boucle {
            inner_loop_counter += 1
            // À FAIRE : noeud put être enlevé, donc il faut prendre le noeud précédent d'avant qu'il fut enlevé
            noeud = élément_précédent(*parseuse.pile_éléments_ouvert, noeud)

            si noeud == élément_formattage {
                arrête
            }

            si inner_loop_counter > 3 && possède(*parseuse.liste_éléments_actifs_formattage, noeud) {
                supprime_élément(*parseuse.liste_éléments_actifs_formattage, noeud)
            }

            si !possède(*parseuse.liste_éléments_actifs_formattage, noeud) {
                supprime_élément(*parseuse.pile_éléments_ouvert, noeud)
                continue
            }

            // À FAIRE 7.
            // À FAIRE 8.
            // À FAIRE 9.

            dernier_noeud = noeud
        }
    }

    panique("algorithme d'adoption incomplet")
}

tout_autre_tag_fin_DansBody :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    index := taille(*parseuse.pile_éléments_ouvert) - 1

    boucle {
        élément := parseuse.pile_éléments_ouvert.éléments[index]

        // À FAIRE : vérifier si nous avons un élément HTML, la spec suggère que nous pourrions avoir autre chose
        si élément.texte == lexème.nom {
            parseuse.génère_tags_fin_implicites_autres_que(lexème.nom)

            si élément != parseuse.noeud_courant() {
                erreur_de_parsage("l'élément n'est pas le noeud courrant")
            }

            // 3. Pop all the nodes from the current node up to node, including node : ceci devrait déjà être fait ?
            tantque élément != parseuse.noeud_courant() {
                dépile(*parseuse.pile_éléments_ouvert)
            }
            dépile(*parseuse.pile_éléments_ouvert)

            arrête
        }
        sinon si fait_partie_de_catégorie_spécial(élément.texte) {
            erreur_de_parsage("l'élément est dans la catégorie spéciale")
            retourne
        }

        élément = parseuse.pile_éléments_ouvert.éléments[index]
        index -= 1
    }
}

ferme_un_élément_p :: fonc (parseuse: *Parseuse)
{
    génère_tags_fin_implicites_autres_que(parseuse, "p")

    noeud := parseuse.noeud_courant()

    si noeud.texte != "p" {
        erreur_de_parsage("l'élément courant n'est pas un <p>")
    }

    dépile_tous_les_éléments_jusque(parseuse, "p")
}

dépile_tous_les_éléments_jusque :: fonc (parseuse: *Parseuse, nom_tag: chaine)
{
    noeud := parseuse.noeud_courant()

    tantque noeud.texte != nom_tag {
        dépile(*parseuse.pile_éléments_ouvert)
        noeud = parseuse.noeud_courant()
    }
    dépile(*parseuse.pile_éléments_ouvert)
}

dépile_vers_contexte_table :: fonc (parseuse: *Parseuse)
{
    noeud := parseuse.noeud_courant()

    tantque !fait_partie_de(noeud.texte, "table", "template", "html") {
        dépile(*parseuse.pile_éléments_ouvert)
        noeud = parseuse.noeud_courant()
    }
}

dépile_vers_contexte_table_body :: fonc (parseuse: *Parseuse)
{
    noeud := parseuse.noeud_courant()

    tantque !fait_partie_de(noeud.texte, "tbody", "tfoot", "thead", "template", "html") {
        dépile(*parseuse.pile_éléments_ouvert)
        noeud = parseuse.noeud_courant()
    }
}

dépile_vers_contexte_table_row :: fonc (parseuse: *Parseuse)
{
    noeud := parseuse.noeud_courant()

    tantque !fait_partie_de(noeud.texte, "tr", "template", "html") {
        dépile(*parseuse.pile_éléments_ouvert)
        noeud = parseuse.noeud_courant()
    }
}

erreur_de_parsage :: fonc (message: chaine)
{
    imprime("erreur de parsage : % !\n", message)
}

restaure_mode_insertion_appropriemment :: fonc (parseuse: *Parseuse)
{
    dernier := faux
    index := parseuse.pile_éléments_ouvert.éléments.taille - 1

    boucle {
        noeud := parseuse.pile_éléments_ouvert.éléments[index]

        si index == 0 {
            dernier = vrai

            // À FAIRE : si fragment, noeud = élément_contexte
        }

        si noeud.texte == "select" {
            si !dernier {
                index_ancêtre := index

                tantque index_ancêtre != 0 {
                    ancêtre := parseuse.pile_éléments_ouvert.éléments[index_ancêtre]

                    si ancêtre.texte == "template" {
                        arrête
                    }

                    si ancêtre.texte == "table" {
                        parseuse.mode_insertion = insère_mode_DansSelectDansTable
                        retourne
                    }

                    index_ancêtre -= 1
                }
            }

            parseuse.mode_insertion = insère_mode_DansSelect
            retourne
        }

        si noeud.texte == "td" || noeud.texte == "th" {
            parseuse.mode_insertion = insère_mode_DansCell
            retourne
        }

        si noeud.texte == "tr" {
            parseuse.mode_insertion = insère_mode_DansRow
            retourne
        }

        si fait_partie_de(noeud.texte, "tbody", "thead", "tfoot") {
            parseuse.mode_insertion = insère_mode_DansCorpsTable
            retourne
        }

        si noeud.texte == "caption" {
            parseuse.mode_insertion = insère_mode_DansCaption
            retourne
        }

        si noeud.texte == "colgroup" {
            parseuse.mode_insertion = insère_mode_DansGroupeColonne
            retourne
        }

        si noeud.texte == "table" {
            parseuse.mode_insertion = insère_mode_DansTable
            retourne
        }

        si noeud.texte == "template" {
            // À FAIRE : pile de mode d'insertion pour les templates
            parseuse.mode_insertion = parseuse.pile_insertion_template[parseuse.pile_insertion_template.taille - 1]
            retourne
        }

        si noeud.texte == "head" && !dernier {
            parseuse.mode_insertion = insère_mode_DansHead
            retourne
        }

        si noeud.texte == "body" {
            parseuse.mode_insertion = insère_mode_DansBody
            retourne
        }

        si noeud.texte == "frameset" {
            parseuse.mode_insertion = insère_mode_DansFrameSet
            retourne
        }

        si noeud.texte == "html" {
            si parseuse.élément_head == nul {
                parseuse.mode_insertion = insère_mode_AvantHead
            }
            sinon {
                parseuse.mode_insertion = insère_mode_AprèsHead
            }

            retourne
        }

        si dernier {
            parseuse.mode_insertion = insère_mode_DansBody
            retourne
        }

        index -= 1
    }
}

ferme_la_cellule :: fonc (parseuse: *Parseuse)
{
    parseuse.génère_tags_fin_implicites()

    noeud := parseuse.noeud_courant()

    si !fait_partie_de(noeud.texte, "td", "th") {
        erreur_de_parsage("attendu un <td> ou <th>")
    }

    tantque !fait_partie_de(noeud.texte, "td", "th") {
        dépile(*parseuse.pile_éléments_ouvert)
        noeud = parseuse.noeud_courant()
    }
    dépile(*parseuse.pile_éléments_ouvert)

    enlève_éléments_jusqu_au_dernier_marqueur(*parseuse.liste_éléments_actifs_formattage)

    parseuse.mode_insertion = insère_mode_DansRow
}
