importe Fondation

charge "document"
charge "élément"
charge "lexage"
charge "liste_éléments_actifs_formattage"
charge "noeud"
charge "pile_éléments_ouverts"

est_caractère_espace_blanc :: fonc (point_de_code: n32) -> bool
{
    retourne point_de_code == ESPACE || point_de_code == TABULATION || point_de_code == RETOUR_CHARIOT || point_de_code == NOUVELLE_LIGNE || point_de_code == 0x0C
}

ModeInsertion :: énum {
    Initial
    AvantHtml
    AvantHead
    DansHead
    DansHeadNoScript
    AprèsHead
    DansBody
    Texte
    DansTable
    DansTexteTable
    DansCaption
    DansGroupeColonne
    DansCorpsTable
    DansRow
    DansCell
    DansSelect
    DansSelectDansTable
    DansFrameSet
    AprèsBody
    AprèsAprèsBody
    AprèsFrameSet
    AprèsAprèsFrameSet
}

fonctions_insertions := [
    insère_mode_Initial,
    insère_mode_AvantHtml,
    insère_mode_AvantHead,
    insère_mode_DansHead,
    insère_mode_DansHeadNoScript,
    insère_mode_AprèsHead,
    insère_mode_DansBody,
    insère_mode_Texte,
    insère_mode_DansTable,
    insère_mode_DansTexteTable,
    insère_mode_DansCaption,
    insère_mode_DansGroupeColonne,
    insère_mode_DansCorpsTable,
    insère_mode_DansRow,
    insère_mode_DansCell,
    insère_mode_DansSelect,
    insère_mode_DansSelectDansTable,
    insère_mode_DansFrameSet,
    insère_mode_AprèsBody,
    insère_mode_AprèsAprèsBody,
    insère_mode_AprèsFrameSet,
    insère_mode_AprèsAprèsFrameSet
]

Parseuse :: struct {
    mode_insertion : ModeInsertion
    mode_insertion_original : ModeInsertion
    lexeuse: Lexeuse
    document: *Document

    élément_head : *Élément
    élément_form : *Élément

    pile_éléments_ouvert : PileÉlémentsOuverts
    liste_éléments_actifs_formattage : ListeÉlémentsActifsFormattage

    arrête_de_parser := faux
    adoption_activée := faux
    scripting_flag := faux
    frameset_ok := vrai
    pause := faux

    niveau_imbrication_script := 0
}

initialise_parseuse :: fonc (entrée: chaine) -> Parseuse
{
    parseuse: Parseuse
    parseuse.mode_insertion = ModeInsertion.Initial
    parseuse.lexeuse = initialise_lexeuse(entrée)
    parseuse.document = crée_noeud_document()

    retourne parseuse
}

détruit_parseuse :: fonc (parseuse: *Parseuse)
{
    détruit_lexeuse(@parseuse.lexeuse)
    détruit_liste(@parseuse.liste_éléments_actifs_formattage)
    déloge parseuse.pile_éléments_ouvert.éléments
}

parse :: fonc (parseuse: *Parseuse)
{
    boucle {
        lexème := lexème_suivant(@parseuse.lexeuse)

        si lexème.genre == GenreLexème.FinDeFichier {
            arrête
        }

        //imprime("mode_insertion : %\n", parseuse.mode_insertion)

        gère_lexème_pour_mode(parseuse, parseuse.mode_insertion, lexème)

        détruit_lexème(@lexème)

        si parseuse.arrête_de_parser {
            arrête
        }
    }
}

noeud_courant :: fonc (parseuse: *Parseuse) -> *Élément
{
    retourne noeud_courant(@parseuse.pile_éléments_ouvert)
}

crée_élément_pour :: fonc (parseuse: *Parseuse, lexème: Lexème) -> *Élément
{
    élément := élément_depuis_tag(parseuse.document, lexème.nom)

    pour lexème.attributs {
        élément.ajoute_attribut(it.nom, it.valeur)
    }

    retourne élément
}

gère_lexème_pour_mode :: fonc (parseuse: *Parseuse, mode: ModeInsertion, lexème: Lexème)
{
    si lexème.genre != GenreLexème.Caractère {
        imprime("gère lexème : % (%), mode insertion : %\n", lexème.nom, lexème.genre, mode)
    }

    fonction := fonctions_insertions[mode]
    fonction(parseuse, lexème)
}

trouve_position_appropriée_pour_insertion :: fonc (parseuse: *Parseuse, cible_override: *Noeud = nul) -> *Noeud
{
    cible : *Noeud = nul

    si cible_override {
        cible = cible_override
    }
    sinon {
        // À FAIRE(langage) : bug dans la génération de la RI
        //cible = parseuse.noeud_courant()
        élément := parseuse.noeud_courant()
        cible = élément
    }

    si parseuse.adoption_activée {
        panique("adotion non implémenté")
    }

    // À FAIRE : si la cible est un template, retourne le dernier enfant de son contenu
    retourne cible
}

insère_élément_html :: fonc (parseuse: *Parseuse, lexème: Lexème) -> *Élément
{
    position_ajustée_d_insertion := trouve_position_appropriée_pour_insertion(parseuse)
    élément := parseuse.crée_élément_pour(lexème)
    // À FAIRE : vérifie s'il est possible d'insérer élément à position_ajustée_d_insertion
    // À FAIRE : file d'évènements, voir spec
    position_ajustée_d_insertion.ajoute_enfant(élément)
    empile(@parseuse.pile_éléments_ouvert, élément)
    retourne élément
}

insère_caractère :: fonc (parseuse: *Parseuse, point_de_code: n32)
{
    position_ajustée_d_insertion := trouve_position_appropriée_pour_insertion(parseuse)

    si position_ajustée_d_insertion.genre == GenreNoeud.Document {
        // ignore
        retourne
    }

    noeud_texte : *NoeudTexte = nul

    si position_ajustée_d_insertion.enfants.taille != 0 && position_ajustée_d_insertion.enfants[position_ajustée_d_insertion.enfants.taille - 1].genre == GenreNoeud.Texte {
        noeud_texte = position_ajustée_d_insertion.enfants[position_ajustée_d_insertion.enfants.taille - 1] comme *NoeudTexte
    }
    sinon {
        noeud_texte = crée_noeud_texte(position_ajustée_d_insertion.document)
        position_ajustée_d_insertion.ajoute_enfant(noeud_texte)
    }

    chaine_ajoute(@noeud_texte.données, point_de_code)
}

insère_commentaire :: fonc (parseuse: *Parseuse, lexème: Lexème, position : *Noeud = nul)
{
    position_ajustée_d_insertion := position

    si !position_ajustée_d_insertion {
        position_ajustée_d_insertion = trouve_position_appropriée_pour_insertion(parseuse)
    }

    noeud_commentaire := crée_noeud_commentaire(position_ajustée_d_insertion.document, lexème.données)
    position_ajustée_d_insertion.ajoute_enfant(noeud_commentaire)
}

insère_mode_Initial :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    si lexème.genre == GenreLexème.Caractère && est_caractère_espace_blanc(lexème.point_de_code) {
        // ignore seulement si ' ', '\t', '\n', '\a', '\r'
        retourne
    }

    si lexème.genre == GenreLexème.Commentaire {
        insère_commentaire(parseuse, lexème, parseuse.document)
        retourne
    }

    si lexème.genre == GenreLexème.Doctype {
        doctype := crée_noeud_doctype(parseuse.document)
        doctype.ajoute_attribut("name", lexème.nom)
        parseuse.document.ajoute_enfant(doctype)
        parseuse.mode_insertion = ModeInsertion.AvantHtml
        retourne
    }

    panique("algorithme d'insertion incomplet")
}

insère_mode_AvantHtml :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    si lexème.genre == GenreLexème.Doctype {
        // erreur de parsage, ignore
        retourne
    }

    si lexème.genre == GenreLexème.Commentaire {
        insère_commentaire(parseuse, lexème, parseuse.document)
        retourne
    }

    si lexème.genre == GenreLexème.Caractère && est_caractère_espace_blanc(lexème.point_de_code) {
        // ignore seulement si ' ', '\t', '\n', '\a', '\r'
        retourne
    }

    si lexème.genre == GenreLexème.DébutTag && lexème.nom == "html" {
        élément := parseuse.crée_élément_pour(lexème)
        parseuse.document.ajoute_enfant(élément)
        parseuse.mode_insertion = ModeInsertion.AvantHead
        empile(@parseuse.pile_éléments_ouvert, élément)
        // À FAIRE : contexte navigation, voir spec
        retourne
    }

    si lexème.genre == GenreLexème.FinTag && !fait_partie_de(lexème.nom, "head", "body", "html", "br") {
        // ignore le tag
        retourne
    }

    panique("algorithme d'insertion incomplet")
}

insère_mode_AvantHead :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    si lexème.genre == GenreLexème.Caractère && est_caractère_espace_blanc(lexème.point_de_code) {
        // ignore seulement si ' ', '\t', '\n', '\a', '\r'
        retourne
    }

    si lexème.genre == GenreLexème.Commentaire {
        insère_commentaire(parseuse, lexème)
        retourne
    }

    si lexème.genre == GenreLexème.Doctype {
        // erreur de parsage, ignore
        retourne
    }

    si lexème.genre == GenreLexème.DébutTag {
        si lexème.nom == "html" {
            gère_lexème_pour_mode(parseuse, ModeInsertion.DansBody, lexème)
            retourne
        }

        si lexème.nom == "head" {
            élément := parseuse.insère_élément_html(lexème)
            parseuse.élément_head = élément
            parseuse.mode_insertion = ModeInsertion.DansHead
            retourne
        }
    }

    si lexème.genre == GenreLexème.FinTag && !fait_partie_de(lexème.nom, "head", "body", "html", "br") {
        // ignore le tag
        retourne
    }

    lexème_head := Lexème(genre = GenreLexème.DébutTag, nom = "head")
    élément := parseuse.insère_élément_html(lexème_head)
    parseuse.élément_head = élément
    parseuse.mode_insertion = ModeInsertion.DansHead
    gère_lexème_pour_mode(parseuse, parseuse.mode_insertion, lexème)
}

gère_élément_contenant_texte_cru :: fonc (parseuse: *Parseuse, lexème: Lexème, état_lexeuse: ÉtatLexage)
{
    _ := parseuse.insère_élément_html(lexème)
    parseuse.lexeuse.état = état_lexeuse
    parseuse.mode_insertion_original = parseuse.mode_insertion
    parseuse.mode_insertion = ModeInsertion.Texte
}

insère_mode_DansHead :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    si lexème.genre == GenreLexème.Caractère && est_caractère_espace_blanc(lexème.point_de_code) {
        parseuse.insère_caractère(lexème.point_de_code)
        retourne
    }

    si lexème.genre == GenreLexème.Commentaire {
        insère_commentaire(parseuse, lexème)
        retourne
    }

    si lexème.genre == GenreLexème.Doctype {
        // erreur de parsage, ignore
        retourne
    }

    si lexème.genre == GenreLexème.DébutTag {
        si lexème.nom == "html" {
            gère_lexème_pour_mode(parseuse, ModeInsertion.DansBody, lexème)
            retourne
        }

        si fait_partie_de(lexème.nom, "base", "basefront", "bgsound", "link") {
            _ := parseuse.insère_élément_html(lexème)
            dépile(@parseuse.pile_éléments_ouvert)
            // À FAIRE : reconnait le drapeau auto-fermant du lexème si actif
            retourne
        }

        si lexème.nom == "meta" {
            _ := parseuse.insère_élément_html(lexème)
            dépile(@parseuse.pile_éléments_ouvert)
            // À FAIRE : reconnait le drapeau auto-fermant du lexème si actif
            // À FAIRE : gère attributs charset, http-equiv, content
            retourne
        }

        si lexème.nom == "title" {
            gère_élément_contenant_texte_cru(parseuse, lexème, ÉtatLexage.RCDATA)
            retourne
        }

        si lexème.nom == "style" || lexème.nom == "noframes" {
            gère_élément_contenant_texte_cru(parseuse, lexème, ÉtatLexage.RAWTEXT)
            retourne
        }

        si lexème.nom == "noscript" {
            si parseuse.scripting_flag {
                gère_élément_contenant_texte_cru(parseuse, lexème, ÉtatLexage.RAWTEXT)
            }
            sinon {
                _ := parseuse.insère_élément_html(lexème)
                parseuse.mode_insertion = ModeInsertion.DansHeadNoScript
            }

            retourne
        }

        si lexème.nom == "script" {
            position_ajustée_d_insertion := trouve_position_appropriée_pour_insertion(parseuse)
            élément := parseuse.crée_élément_pour(lexème)
            // À FAIRE : élément_script.document_parseur = parseuse.document
            // À FAIRE : élément_script.non_blocant = faux
            // À FAIRE : élément_script.déjà_lancé = parseuse.créée_depuis_parsage_fragment
            // À FAIRE : document.write()
            position_ajustée_d_insertion.ajoute_enfant(élément)
            empile(@parseuse.pile_éléments_ouvert, élément)
            parseuse.lexeuse.état = ÉtatLexage.ScriptData
            parseuse.mode_insertion_original = parseuse.mode_insertion
            parseuse.mode_insertion = ModeInsertion.Texte
            retourne
        }

        si lexème.nom == "template" {
            panique("algorithme d'insertion incomplet")
        }

        si lexème.nom == "head" {
            // ignore
            retourne
        }
    }

    si lexème.genre == GenreLexème.FinTag {
        si lexème.nom == "head" {
            dépile(@parseuse.pile_éléments_ouvert)
            parseuse.mode_insertion = ModeInsertion.AprèsHead
            retourne
        }

        si lexème.nom == "template" {
            panique("algorithme d'insertion incomplet")
        }

        si !fait_partie_de(lexème.nom, "body", "html", "br") {
            // ignore tous les autres
            retourne
        }
    }

    dépile(@parseuse.pile_éléments_ouvert)
    parseuse.mode_insertion = ModeInsertion.AprèsHead
}

insère_mode_DansHeadNoScript :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    si lexème.genre == GenreLexème.Doctype {
        // erreur de parsage, ignore le lexème
        retourne
    }

    si lexème.genre == GenreLexème.Commentaire {
        gère_lexème_pour_mode(parseuse, ModeInsertion.DansHead, lexème)
        retourne
    }

    si lexème.genre == GenreLexème.Caractère {
        si est_caractère_espace_blanc(lexème.point_de_code) {
            gère_lexème_pour_mode(parseuse, ModeInsertion.DansHead, lexème)
            retourne
        }
    }

    si lexème.genre == GenreLexème.DébutTag {
        si lexème.nom == "html" {
            gère_lexème_pour_mode(parseuse, ModeInsertion.DansBody, lexème)
            retourne
        }

        si lexème.nom == "head" || lexème.nom == "noscript" {
            // erreur de parsage, ignore le lexème
            retourne
        }

        si fait_partie_de(lexème.nom, "bgsound", "link", "meta", "noframes", "style") {
            gère_lexème_pour_mode(parseuse, ModeInsertion.DansHead, lexème)
            retourne
        }
    }

    si lexème.genre == GenreLexème.FinTag {
        si lexème.nom == "noscript" {
            dépile(@parseuse.pile_éléments_ouvert)
            parseuse.mode_insertion = ModeInsertion.DansHead
            retourne
        }

        si lexème.nom != "br" {
            // erreur de parsage, ignore le lexème
            retourne
        }
    }

    dépile(@parseuse.pile_éléments_ouvert)
    parseuse.mode_insertion = ModeInsertion.DansHead
    gère_lexème_pour_mode(parseuse, parseuse.mode_insertion, lexème)
}

insère_mode_AprèsHead :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    si lexème.genre == GenreLexème.Caractère && est_caractère_espace_blanc(lexème.point_de_code) {
        parseuse.insère_caractère(lexème.point_de_code)
        retourne
    }

    si lexème.genre == GenreLexème.Commentaire {
        insère_commentaire(parseuse, lexème)
        retourne
    }

    si lexème.genre == GenreLexème.Doctype {
        // erreur de parsage, ignore
        retourne
    }

    si lexème.genre == GenreLexème.DébutTag {
        si lexème.nom == "html" {
            gère_lexème_pour_mode(parseuse, ModeInsertion.DansBody, lexème)
            retourne
        }

        si lexème.nom == "body" {
            _ := parseuse.insère_élément_html(lexème)
            parseuse.frameset_ok = faux
            parseuse.mode_insertion = ModeInsertion.DansBody
            retourne
        }

        si lexème.nom == "frameset" {
            _ := parseuse.insère_élément_html(lexème)
            parseuse.mode_insertion = ModeInsertion.DansFrameSet
            retourne
        }

        si lexème.nom == "head" {
            // ignore
            retourne
        }

        si fait_partie_de(lexème.nom, "base", "basefont", "bgsound", "link", "meta", "noframes", "script", "style", "template", "title") {
            panique("algorithme d'insertion incomplet")
        }
    }

    si lexème.genre == GenreLexème.FinTag {
        si lexème.nom == "template" {
            gère_lexème_pour_mode(parseuse, ModeInsertion.DansHead, lexème)
            retourne
        }

        si !fait_partie_de(lexème.nom, "body", "html", "br") {
            // ignore
            retourne
        }
    }

    lexème_body := Lexème(genre = GenreLexème.DébutTag, nom = "body")
    élément := parseuse.insère_élément_html(lexème_body)
    parseuse.mode_insertion = ModeInsertion.DansBody
    gère_lexème_pour_mode(parseuse, parseuse.mode_insertion, lexème)
}

insère_mode_DansBody :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    // continue le spec à An end tag whose tag name is "p"

    si lexème.genre == GenreLexème.Caractère {
        si lexème.point_de_code == 0x0 {
            // ignore
            retourne
        }

        // À FAIRE : reconstruit les éléments de formattage actifs
        parseuse.insère_caractère(lexème.point_de_code)

        si !est_caractère_espace_blanc(lexème.point_de_code) {
            parseuse.frameset_ok = faux
        }

        retourne
    }

    si lexème.genre == GenreLexème.Commentaire {
        insère_commentaire(parseuse, lexème)
        retourne
    }

    si lexème.genre == GenreLexème.DébutTag {
        si lexème.nom == "html" {
            panique("algorithme d'insertion incomplet")
        }

        si fait_partie_de(lexème.nom, "base", "basefont", "bgsound", "link", "meta", "noframes", "script", "style", "template", "title") {
            gère_lexème_pour_mode(parseuse, ModeInsertion.DansHead, lexème)
            retourne
        }

        si lexème.nom == "body" {
            si taille(@parseuse.pile_éléments_ouvert) == 1 {
                //imprime("la taille de la pile est de 1\n")
                // ignore
                retourne
            }

            si parseuse.pile_éléments_ouvert.éléments[1].genre_élément != GenreÉlément.BODY {
                //imprime("le deuxième élément n'est pas un body : %\n", parseuse.pile_éléments_ouvert.éléments[1].genre_élément)
                // ignore
                retourne
            }

            si possède_dans_portée(@parseuse.pile_éléments_ouvert, "template") {
                //imprime("la pile possède un template\n")
                // ignore
                retourne
            }

            élément_body := parseuse.pile_éléments_ouvert.éléments[1]
            parseuse.frameset_ok = faux

            pour lexème.attributs {
                si !élément_body.possède_attribut(it.nom) {
                    élément_body.ajoute_attribut(it.nom, it.valeur)
                }
            }

            retourne
        }

        si lexème.nom == "frameset" {
            panique("algorithme d'insertion incomplet")
        }

        si lexème.nom == "form" {
            template_dans_portée := possède_dans_portée(@parseuse.pile_éléments_ouvert, "template")

            si parseuse.élément_head != nul && !template_dans_portée {
                // parser error, ignore le lexème
                retourne
            }

            si possède_dans_portée_button(@parseuse.pile_éléments_ouvert, "p") {
                ferme_un_élément_p(parseuse)
            }

            élément := parseuse.insère_élément_html(lexème)

            si !template_dans_portée {
                parseuse.élément_form = élément
            }

            retourne
        }

        si lexème.nom == "li" {
            parseuse.frameset_ok = vrai

            index := taille(@parseuse.pile_éléments_ouvert) - 1

            boucle {
                noeud := parseuse.pile_éléments_ouvert.éléments[index]

                si noeud.texte == "li" {
                    parseuse.génère_tags_fin_implicites_autres_que("li")

                    noeud = parseuse.noeud_courant()

                    si noeud.texte != "li" {
                        erreur_de_parsage("le noeud courant n'est pas un <li>")
                    }

                    tantque noeud.texte != "li" {
                        dépile(@parseuse.pile_éléments_ouvert)
                        noeud = parseuse.noeud_courant()
                    }
                    dépile(@parseuse.pile_éléments_ouvert)

                    arrête
                }

                si fait_partie_de_catégorie_spécial(noeud.texte) && !fait_partie_de(noeud.texte, "address", "div", "p") {
                    arrête
                }

                noeud = parseuse.pile_éléments_ouvert.éléments[index]
                index -= 1
            }

            si possède_dans_portée_button(@parseuse.pile_éléments_ouvert, "p") {
                ferme_un_élément_p(parseuse)
            }

            _ := insère_élément_html(parseuse, lexème)
            retourne
        }

        si fait_partie_de(lexème.nom, "address", "article", "aside", "blockquote", "center", "details", "dialog", "dir", "div", "dl", "fieldset", "figcaption", "figure", "footer", "header", "hgroup", "main", "menu", "nav", "ol", "p", "section", "summary", "ul") {
            si possède_dans_portée_button(@parseuse.pile_éléments_ouvert, "p") {
                ferme_un_élément_p(parseuse)
            }

            _ := insère_élément_html(parseuse, lexème)
            retourne
        }

        si fait_partie_de(lexème.nom, "h1", "h2", "h3", "h4", "h5", "h6") {
            si possède_dans_portée_button(@parseuse.pile_éléments_ouvert, "p") {
                ferme_un_élément_p(parseuse)
            }

            noeud := parseuse.noeud_courant()
            si fait_partie_de(noeud.texte, "h1", "h2", "h3", "h4", "h5", "h6") {
                erreur_de_parsage("élément <h> ouvert quand un autre <h> s'ouvre")
                dépile(@parseuse.pile_éléments_ouvert)
            }

            _ := insère_élément_html(parseuse, lexème)
            retourne
        }

        si fait_partie_de(lexème.nom, "pre", "listing") {
            si possède_dans_portée_button(@parseuse.pile_éléments_ouvert, "p") {
                ferme_un_élément_p(parseuse)
            }

            _ := insère_élément_html(parseuse, lexème)
            // À FAIRE : ignore le token suivant si c'est un caractère de nouvelle ligne (0x0A)
            parseuse.frameset_ok = faux
            retourne
        }

        si fait_partie_de(lexème.nom, "dd", "dt") {
            panique("algorithme d'insertion incomplet")
        }

        si lexème.nom == "plaintext" {
            panique("algorithme d'insertion incomplet")
        }

        si lexème.nom == "button" {
            si possède_dans_portée(@parseuse.pile_éléments_ouvert, "button") {
                erreur_de_parsage("<button> déjà ouvert lors de l'ouverture d'un <button>")
                génère_tags_fin_implicites(parseuse)

                dépile_tous_les_éléments_jusque(parseuse, "button")
            }

            parseuse.reconstruit_liste_des_éléments_de_formattage_actifs()

            _ := insère_élément_html(parseuse, lexème)
            parseuse.frameset_ok = faux
            retourne
        }

        si lexème.nom == "a" {
            élément := élément_avant_marqueur(@parseuse.liste_éléments_actifs_formattage, "a")

            si élément != nul {
                // erreur de parsage
                parseuse.lance_algorithme_adoption(lexème)
                supprime_élément(@parseuse.liste_éléments_actifs_formattage, élément)
                supprime_élément(@parseuse.pile_éléments_ouvert, élément)
            }

            parseuse.reconstruit_liste_des_éléments_de_formattage_actifs()
            élément = insère_élément_html(parseuse, lexème)
            pousse_sur_liste_éléments_actifs(parseuse, élément, lexème)
            retourne
        }

        si fait_partie_de(lexème.nom, "b", "big", "code", "em", "font", "i", "s", "small", "strike", "strong", "tt", "u") {
            panique("algorithm d'insertion incomplet")
        }

        si lexème.nom == "nobr" {
            panique("algorithm d'insertion incomplet")
        }

        si fait_partie_de(lexème.nom, "applet", "marquee", "object") {
            panique("algorithm d'insertion incomplet")
        }

        si lexème.nom == "table" {
            panique("algorithm d'insertion incomplet")
        }

        si fait_partie_de(lexème.nom, "area", "br", "embed", "img", "keygen", "wbr") {
            parseuse.reconstruit_liste_des_éléments_de_formattage_actifs()
            _ := parseuse.insère_élément_html(lexème)
            dépile(@parseuse.pile_éléments_ouvert)
            // À FAIRE : reconnait le drapeau auto-fermant
            parseuse.frameset_ok = faux
            retourne
        }

        si lexème.nom == "input" {
            parseuse.reconstruit_liste_des_éléments_de_formattage_actifs()
            _ := parseuse.insère_élément_html(lexème)
            dépile(@parseuse.pile_éléments_ouvert)
            // À FAIRE : reconnait le drapeau auto-fermant
            // À FAIRE : parseuse.frameset_ok = !élément.possède_attribut("type") || élément.attribut("type") == "hidden" // case-insensitive
            //parseuse.frameset_ok = faux
            retourne
        }

        si fait_partie_de(lexème.nom, "param", "source", "track") {
            panique("algorithm d'insertion incomplet")
        }

        si lexème.nom == "hr" {
            panique("algorithm d'insertion incomplet")
        }

        si lexème.nom == "image" {
            lexème.nom = copie_chaine("img")
            gère_lexème_pour_mode(parseuse, parseuse.mode_insertion, lexème)
            retourne
        }

        si lexème.nom == "textarea" {
            _ := insère_élément_html(parseuse, lexème)
            panique("algorithm d'insertion incomplet")
        }

        si lexème.nom == "xmp" {
            panique("algorithm d'insertion incomplet")
        }

        si lexème.nom == "iframe" {
            parseuse.frameset_ok = faux
            gère_élément_contenant_texte_cru(parseuse, lexème, ÉtatLexage.RAWTEXT)
            retourne
        }

        si lexème.nom == "noembed" || (lexème.nom == "noscript" && parseuse.scripting_flag == vrai) {
            gère_élément_contenant_texte_cru(parseuse, lexème, ÉtatLexage.RAWTEXT)
            retourne
        }

        si lexème.nom == "select" {
            panique("algorithm d'insertion incomplet")
        }

        si lexème.nom == "optgroup" || lexème.nom == "option" {
            panique("algorithm d'insertion incomplet")
        }

        si lexème.nom == "rb" || lexème.nom == "rtc" {
            panique("algorithm d'insertion incomplet")
        }

        si lexème.nom == "rp" || lexème.nom == "rt" {
            panique("algorithm d'insertion incomplet")
        }

        si lexème.nom == "math" {
            panique("algorithm d'insertion incomplet")
        }

        si lexème.nom == "svg" {
            parseuse.reconstruit_liste_des_éléments_de_formattage_actifs()
            // À FAIRE : ajuste les attributs SVG
            // À FAIRE : ajuste les attributs étrangers
            // À FAIRE : insère dans l'espace de nom SVG
            _ := parseuse.insère_élément_html(lexème)

            si lexème.auto_fermant {
                // À FAIRE : reconnait le drapeau auto-fermant
                dépile(@parseuse.pile_éléments_ouvert)
            }

            retourne
        }

        si fait_partie_de(lexème.nom, "caption", "col", "colgroup", "frame", "head", "tbody", "td", "tfoot", "th", "thead", "tr") {
            // erreur de parsage, ignore le lexème
            retourne
        }

        parseuse.reconstruit_liste_des_éléments_de_formattage_actifs()
        _ := parseuse.insère_élément_html(lexème)
        retourne
    }

    si lexème.genre == GenreLexème.FinTag {
        si lexème.nom == "template" {
            gère_lexème_pour_mode(parseuse, ModeInsertion.DansHead, lexème)
            retourne
        }

        si lexème.nom == "body" {
            si !possède_dans_portée(@parseuse.pile_éléments_ouvert, "body") {
                // À FAIRE : comprendre ce que la spec veut dire
            }

            parseuse.mode_insertion = ModeInsertion.AprèsBody
            retourne
        }

        si lexème.nom == "html" {
            si !possède_dans_portée(@parseuse.pile_éléments_ouvert, "body") {
                // À FAIRE : comprendre ce que la spec veut dire
            }

            parseuse.mode_insertion = ModeInsertion.AprèsBody
            gère_lexème_pour_mode(parseuse, parseuse.mode_insertion, lexème)
            retourne
        }

        si fait_partie_de(lexème.nom, "address", "article", "aside", "blockquote", "button", "center", "details", "dialog", "dir", "div", "dl", "fieldset", "figcaption", "figure", "footer", "header", "hgroup", "listing", "main", "menu", "nav", "ol", "pre", "section", "summary", "ul") {
            si !possède_dans_portée(@parseuse.pile_éléments_ouvert, lexème.nom) {
                erreur_de_parsage("la portée ne possède aucun élément du même tag de fin")
                dépile(@parseuse.pile_éléments_ouvert)
                retourne
            }

            parseuse.génère_tags_fin_implicites()

            noeud := parseuse.noeud_courant()

            si noeud.texte != lexème.nom {
                erreur_de_parsage("le noeud courrant ne possède pas le même tag de fin")
            }

            dépile_tous_les_éléments_jusque(parseuse, lexème.nom)
            retourne
        }

        si lexème.nom == "form" {
            template_dans_portée := possède_dans_portée(@parseuse.pile_éléments_ouvert, "template")

            si !template_dans_portée {
                noeud := parseuse.élément_form
                parseuse.élément_form = nul

                si noeud == nul || !possède_dans_portée(@parseuse.pile_éléments_ouvert, noeud) {
                    // erreur de parsage ignore
                    retourne
                }

                parseuse.génère_tags_fin_implicites()

                si noeud != parseuse.noeud_courant() {
                    erreur_de_parsage("l'élément <form> n'est pas le noeud courrant")
                }

                // À FAIRE : enlève le noeud peu importe où il se trouve
                dépile(@parseuse.pile_éléments_ouvert)
            }
            sinon {
                si !possède_dans_portée(@parseuse.pile_éléments_ouvert, "form") {
                    erreur_de_parsage("<form> n'est pas la dans la portée")
                    retourne
                }

                parseuse.génère_tags_fin_implicites()

                noeud := parseuse.noeud_courant()

                si noeud.texte != "form" {
                    erreur_de_parsage("attendu un élément <form>")
                }

                dépile_tous_les_éléments_jusque(parseuse, "form")
            }

            retourne
        }

        si lexème.nom == "p" {
            si !possède_dans_portée_button(@parseuse.pile_éléments_ouvert, "p") {
                erreur_de_parsage("aucun <p> ouvert dans une portée <button>")

                lexème_p : Lexème
                lexème_p.genre = GenreLexème.DébutTag
                lexème_p.nom = "p"
                _ := insère_élément_html(parseuse, lexème_p)
            }

            ferme_un_élément_p(parseuse)
            retourne
        }

        si lexème.nom == "li" {
            si !possède_dans_portée_list_item(@parseuse.pile_éléments_ouvert, "li") {
                erreur_de_parsage("aucun <li> dans portée list item")
                retourne
            }

            parseuse.génère_tags_fin_implicites_autres_que("li")

            noeud := parseuse.noeud_courant()

            si noeud.texte != "li" {
                erreur_de_parsage("le noeud courant n'est pas un <li>")
            }

            dépile_tous_les_éléments_jusque(parseuse, "li")
            retourne
        }

        si lexème.nom == "dd" || lexème.nom == "dt" {
            panique("algorithme d'insertion incomplet")
        }

        si fait_partie_de(lexème.nom, "h1", "h2", "h3", "h4", "h5", "h6") {
            panique("algorithme d'insertion incomplet")
        }

        si fait_partie_de(lexème.nom, "a", "b", "big", "code", "em", "font", "i", "nobr", "s", "small", "strike", "strong", "tt", "u") {
            parseuse.lance_algorithme_adoption(lexème)
            retourne
        }

        si fait_partie_de(lexème.nom, "applet", "marquee", "object") {
            panique("algorithm d'insertion incomplet")
        }

        si lexème.nom == "br" {
            panique("algorithm d'insertion incomplet")
        }

        tout_autre_tag_fin_DansBody(parseuse, lexème)
        retourne
    }

    si lexème.genre == GenreLexème.FinDeFichier {
        panique("algorithme d'insertion incomplet")
    }
}

insère_mode_Texte :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    si lexème.genre == GenreLexème.Caractère {
        parseuse.insère_caractère(lexème.point_de_code)
        retourne
    }

    si lexème.genre == GenreLexème.FinDeFichier {
        // À FAIRE : gère élément script

        dépile(@parseuse.pile_éléments_ouvert)
        parseuse.mode_insertion = parseuse.mode_insertion_original
        gère_lexème_pour_mode(parseuse, parseuse.mode_insertion, lexème)
        retourne
    }

    si lexème.genre == GenreLexème.FinTag && lexème.nom == "script" {
        // À FAIRE : JavaScript execution context stack

        script := parseuse.noeud_courant()
        dépile(@parseuse.pile_éléments_ouvert)
        parseuse.mode_insertion = parseuse.mode_insertion_original

        // À FAIRE : old insertion point
        // À FAIRE : prépare le script

        parseuse.niveau_imbrication_script -= 1
        parseuse.pause = parseuse.niveau_imbrication_script == 0

        // À FAIRE : restaure insertion point (insertion_point = old_insertion_point)
        // À FAIRE : pending parsing-blocking script
        retourne
    }

    dépile(@parseuse.pile_éléments_ouvert)
    parseuse.mode_insertion = parseuse.mode_insertion_original
}

insère_mode_DansTable :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    panique("algorithme d'insertion incomplet")
}

insère_mode_DansTexteTable :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    panique("algorithme d'insertion incomplet")
}

insère_mode_DansCaption :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    panique("algorithme d'insertion incomplet")
}

insère_mode_DansGroupeColonne :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    panique("algorithme d'insertion incomplet")
}

insère_mode_DansCorpsTable :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    panique("algorithme d'insertion incomplet")
}

insère_mode_DansRow :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    panique("algorithme d'insertion incomplet")
}

insère_mode_DansCell :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    panique("algorithme d'insertion incomplet")
}

insère_mode_DansSelect :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    panique("algorithme d'insertion incomplet")
}

insère_mode_DansSelectDansTable :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    panique("algorithme d'insertion incomplet")
}

insère_mode_DansFrameSet :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    panique("algorithme d'insertion incomplet")
}

insère_mode_AprèsBody :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    si lexème.genre == GenreLexème.Caractère && est_caractère_espace_blanc(lexème.point_de_code) {
        gère_lexème_pour_mode(parseuse, ModeInsertion.DansBody, lexème)
        retourne
    }

    si lexème.genre == GenreLexème.Commentaire {
        // ajoute le comme enfant de l'élément html (le premier élément de la pile d'éléments ouverts)
        insère_commentaire(parseuse, lexème, parseuse.pile_éléments_ouvert.éléments[0])
        retourne
    }

    si lexème.genre == GenreLexème.Doctype {
        erreur_de_parsage("obtenu doctype après body")
        retourne
    }

    si lexème.genre == GenreLexème.DébutTag && lexème.nom == "html" {
        gère_lexème_pour_mode(parseuse, ModeInsertion.DansBody, lexème)
        retourne
    }

    si lexème.genre == GenreLexème.FinTag && lexème.nom == "html" {
        // À FAIRE : ignore si nous sommes dans un parsage de fragment html
        parseuse.mode_insertion = ModeInsertion.AprèsAprèsBody
        retourne
    }

    si lexème.genre == GenreLexème.FinDeFichier {
        parseuse.arrête_de_parser = vrai
        retourne
    }

    parseuse.mode_insertion = ModeInsertion.DansBody
    gère_lexème_pour_mode(parseuse, parseuse.mode_insertion, lexème)
}

insère_mode_AprèsAprèsBody :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    si lexème.genre == GenreLexème.Commentaire {
        insère_commentaire(parseuse, lexème, parseuse.document)
        retourne
    }

    si lexème.genre == GenreLexème.Doctype || (lexème.genre == GenreLexème.Caractère && est_caractère_espace_blanc(lexème.point_de_code)) || (lexème.genre == GenreLexème.DébutTag && lexème.nom == "html") {
        gère_lexème_pour_mode(parseuse, ModeInsertion.DansBody, lexème)
        retourne
    }

    si lexème.genre == GenreLexème.FinDeFichier {
        parseuse.arrête_de_parser = vrai
        retourne
    }

    parseuse.mode_insertion = ModeInsertion.DansBody
    gère_lexème_pour_mode(parseuse, parseuse.mode_insertion, lexème)
}

insère_mode_AprèsFrameSet :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    panique("algorithme d'insertion incomplet")
}

insère_mode_AprèsAprèsFrameSet :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    panique("algorithme d'insertion incomplet")
}

// NOTE : les trois fonctions suivantes sont des labels dans l'algorithme
__rewind :: fonc (parseuse: *Parseuse, entrée: EntréeFormattage)
{
    première := première_entrée(@parseuse.liste_éléments_actifs_formattage)

    // vérifie s'il n'y a pas d'entrées avant entrée
    si première.élément == entrée.élément {
        __create(parseuse, entrée)
        retourne
    }

    entrée = entrée_précédente(@parseuse.liste_éléments_actifs_formattage, entrée)

    si entrée.élément != nul || !possède(@parseuse.pile_éléments_ouvert, entrée.élément) {
        __rewind(parseuse, entrée)
    }
}

__create :: fonc (parseuse: *Parseuse, entrée: EntréeFormattage)
{
    nouvel_élément := insère_élément_html(parseuse, entrée.lexème)
    entrée = remplace(@parseuse.liste_éléments_actifs_formattage, entrée, nouvel_élément)
    dernière := dernière_entrée(@parseuse.liste_éléments_actifs_formattage)

    si dernière.élément != nouvel_élément {
        __advance(parseuse, entrée)
    }
}

__advance :: fonc (parseuse: *Parseuse, entrée: EntréeFormattage)
{
    entrée = entrée_suivante(@parseuse.liste_éléments_actifs_formattage, entrée)
    __create(parseuse, entrée)
}

reconstruit_liste_des_éléments_de_formattage_actifs :: fonc (parseuse: *Parseuse)
{
    si est_vide(@parseuse.liste_éléments_actifs_formattage) {
        retourne
    }

    entrée := dernière_entrée(@parseuse.liste_éléments_actifs_formattage)

    si entrée.élément == nul || possède(@parseuse.pile_éléments_ouvert, entrée.élément) {
        retourne
    }

    __rewind(parseuse, entrée)
}

génère_tags_fin_implicites :: fonc (parseuse: *Parseuse)
{
    noeud := parseuse.noeud_courant()

    tantque fait_partie_de(noeud.texte, "dd", "dt", "li", "optgroup", "option", "p", "rb", "rt", "rtc") {
        dépile(@parseuse.pile_éléments_ouvert)
        noeud = parseuse.noeud_courant()
    }
}

génère_tags_fin_implicites_autres_que :: fonc (parseuse: *Parseuse, tag: chaine)
{
    noeud := parseuse.noeud_courant()

    tantque noeud.texte != tag && fait_partie_de(noeud.texte, "dd", "dt", "li", "optgroup", "option", "p", "rb", "rt", "rtc") {
        dépile(@parseuse.pile_éléments_ouvert)
        noeud = parseuse.noeud_courant()
    }
}

fait_partie_de_catégorie_spécial :: fonc (nom: chaine) -> bool
{
    // À FAIRE : utilisation d'une recherche binaire
    retourne fait_partie_de(nom, "address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "keygen", "li", "link", "listing", "main", "marquee", "menu", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp", "mi", "mo", "mn", "ms", "mtext", "annotation-xml", "foreignObject", "desc", "title")
}

pousse_sur_liste_éléments_actifs :: fonc (parseuse: *Parseuse, élément: *Élément, lexème: Lexème)
{
    // À FAIRE : vérifie si nous avons 3 éléments de même nom de tag
    ajoute(@parseuse.liste_éléments_actifs_formattage, élément, lexème)
}

lance_algorithme_adoption :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    sujet := lexème.nom
    noeud := parseuse.noeud_courant()

    si noeud.texte == sujet && !possède(@parseuse.liste_éléments_actifs_formattage, noeud) {
        dépile(@parseuse.pile_éléments_ouvert)
        retourne
    }

    outer_loop_counter := 0

    boucle {
        si outer_loop_counter >= 8 {
            retourne
        }

        outer_loop_counter += 1

        élément_formattage := élément_avant_marqueur(@parseuse.liste_éléments_actifs_formattage, sujet)

        si élément_formattage == nul {
            tout_autre_tag_fin_DansBody(parseuse, lexème)
            retourne
        }

        si possède(@parseuse.pile_éléments_ouvert, élément_formattage) {
            erreur_de_parsage("l'élément de formattage n'est pas dans la pile d'élément ouvert")
            supprime_élément(@parseuse.liste_éléments_actifs_formattage, élément_formattage)
            retourne
        }

        // À FAIRE : vérifie si dans portée

        si élément_formattage != noeud {
            erreur_de_parsage("l'élément de formattage n'est pas le noeud courrant")
            // ne retourne pas
        }

        arrête

        // furthest_block : *Élément = nul

        // // À FAIRE :

        // si !furthest_block {

        // }
    }

    panique("algorithme d'adoption incomplet")
}

tout_autre_tag_fin_DansBody :: fonc (parseuse: *Parseuse, lexème: Lexème)
{
    index := taille(@parseuse.pile_éléments_ouvert) - 1

    boucle {
        élément := parseuse.pile_éléments_ouvert.éléments[index]

        // À FAIRE : vérifier si nous avons un élément HTML, la spec suggère que nous pourrions avoir autre chose
        si élément.texte == lexème.nom {
            parseuse.génère_tags_fin_implicites_autres_que(lexème.nom)

            si élément != parseuse.noeud_courant() {
                erreur_de_parsage("l'élément n'est pas le noeud courrant")
            }

            // 3. Pop all the nodes from the current node up to node, including node : ceci devrait déjà être fait ?
            tantque élément != parseuse.noeud_courant() {
                dépile(@parseuse.pile_éléments_ouvert)
            }
            dépile(@parseuse.pile_éléments_ouvert)

            arrête
        }
        sinon si fait_partie_de_catégorie_spécial(élément.texte) {
            imprime("sujet : %\n", lexème.nom)
            imprime("élément : %\n", élément.texte)
            erreur_de_parsage("l'élément est dans la catégorie spéciale")
            retourne
        }

        élément = parseuse.pile_éléments_ouvert.éléments[index]
        index -= 1
    }
}

ferme_un_élément_p :: fonc (parseuse: *Parseuse)
{
    génère_tags_fin_implicites_autres_que(parseuse, "p")

    noeud := parseuse.noeud_courant()

    si noeud.texte != "p" {
        erreur_de_parsage("l'élément courant n'est pas un <p>")
    }

    dépile_tous_les_éléments_jusque(parseuse, "p")
}

dépile_tous_les_éléments_jusque :: fonc (parseuse: *Parseuse, nom_tag: chaine)
{
    noeud := parseuse.noeud_courant()

    tantque noeud.texte != nom_tag {
        dépile(@parseuse.pile_éléments_ouvert)
        noeud = parseuse.noeud_courant()
    }
    dépile(@parseuse.pile_éléments_ouvert)
}

erreur_de_parsage :: fonc (message: chaine)
{
    imprime("erreur de parsage : % !\n", message)
}
