importe Chaine
importe Fondation

/* ------------------------------------------------------------------------- */
/** \nom Event handler types.
 * https://html.spec.whatwg.org/multipage/webappapis.html#event-handlers-on-elements,-document-objects,-and-window-objects
 *
 * Spécification pour UIEvents :
 * https://w3c.github.io/uievents/
 * \{ */

EventType :: énum n8 {
    /* The following are the event handlers (and their corresponding event
     * handler event types) that must be supported by all HTML elements, as
     * both event handler content attributes and event handler IDL attributes;
     * and that must be supported by all Document and Window objects, as event
     * handler IDL attributes. */
    abort
    auxclick
    beforeinput
    beforematch
    beforetoggle
    cancel
    canplay
    canplaythrough
    change
    click
    close
    contextlost
    contextmenu
    contextrestored
    copy
    cuechange
    cut
    dblclick
    drag
    dragend
    dragenter
    dragleave
    dragover
    dragstart
    drop
    durationchange
    emptied
    ended
    formdata
    input
    invalid
    keydown
    keypress
    keyup
    loadeddata
    loadedmetadata
    loadstart
    mousedown
    mouseenter
    mouseleave
    mousemove
    mouseout
    mouseover
    mouseup
    paste
    pause
    play
    playing
    progress
    ratechange
    reset
    scrollend
    securitypolicyviolation
    seeked
    seeking
    select
    slotchange
    stalled
    submit
    suspend
    timeupdate
    toggle
    volumechange
    waiting
    webkitanimationend
    webkitanimationiteration
    webkitanimationstart
    webkittransitionend
    wheel

    /* The following are the event handlers (and their corresponding event
     * handler event types) that must be supported by all HTML elements other
     * than body and frameset elements, as both event handler content attributes
     * and event handler IDL attributes; that must be supported by all Document
     * objects, as event handler IDL attributes; and that must be supported by
     * all Window objects, as event handler IDL attributes on the Window objects
     * themselves, and with corresponding event handler content attributes and
     * event handler IDL attributes exposed on all body and frameset elements
     * that are owned by that Window object's associated Document. */
    blur
    error
    focus
    load
    resize
    scroll

    /* The following are the event handlers (and their corresponding event
     * handler event types) that must be supported by Window objects, as event
     * handler IDL attributes on the Window objects themselves, and with
     * corresponding event handler content attributes and event handler IDL
     * attributes exposed on all body and frameset elements that are owned by
     * that Window object's associated Document. */
    afterprint
    beforeprint
    beforeunload
    hashchange
    languagechange
    message
    messageerror
    offline
    online
    pageswap
    pagehide
    pagereveal
    pageshow
    popstate
    rejectionhandled
    storage
    unhandledrejection
    unload

    /* The following are the event handlers (and their corresponding event
     * handler event types) that must be supported on Document objects as
     * event handler IDL attributes. */
    readystatechange
    visibilitychange

    /* Autres */
    DOMContentLoaded
}

is_event_handler_content_attribute_name :: fonc (nom: DOMString) -> bool
#corps_texte {
    enchaineuse: Enchaineuse
    initialise_enchaineuse(*enchaineuse)
    diffère détruit_tampons(*enchaineuse)

    infos := info_de(EventType)
    pour infos.noms {
        si it == "DOMContentLoaded" {
            continue
        }
        ajoute_au_tampon(*enchaineuse, "si nom == EVT_on", it, " { retourne vrai }\n")
    }
    ajoute_au_tampon(*enchaineuse, "retourne faux\n")

    retourne chaine_depuis_enchaineuse(*enchaineuse)
}

donne_event_type_pour_nom_event_handler :: fonc (nom: DOMString) -> EventType
#corps_texte {
    enchaineuse: Enchaineuse
    initialise_enchaineuse(*enchaineuse)
    diffère détruit_tampons(*enchaineuse)

    infos := info_de(EventType)
    pour infos.noms {
        si it == "DOMContentLoaded" {
            continue
        }
        ajoute_au_tampon(*enchaineuse, "si nom == EVT_on", it, " { retourne EventType.", it, "}\n")
    }
    ajoute_au_tampon(*enchaineuse, "panique(\"évènement inconnu : %\", nom)\n")

    retourne chaine_depuis_enchaineuse(*enchaineuse)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Event
 * https://dom.spec.whatwg.org/#event
 * \{ */

/* https://dom.spec.whatwg.org/#dom-event-eventphase */
EventPhase :: énum {
    NONE :: 0
    CAPTURING_PHASE :: 1
    AT_TARGET :: 2
    BUBBLING_PHASE :: 3
}

Event :: struct {
    empl platform_object: PlatformObject
    table = *table_virtuelle_event

    type: EventType
    event_phase: EventPhase

    target: *EventTarget
    related_target: *EventTarget
    current_target: *EventTarget
    touch_target_list: [..]*EventTarget

    /* Flags. */
    dispatch: bool
    initialized: bool
    canceled: bool
    stop_propagation: bool
    stop_immediate_propagation: bool
    bubbles: bool
    composed: bool

    /* Attributes. */
    is_trusted: bool
    est_dans_activation_behavior: bool

    /* https://dom.spec.whatwg.org/#event-path */
    Path :: struct {
        invocation_target: *EventTarget
        shadow_adjusted_target: *EventTarget
        related_target: *EventTarget
        touch_target_list: [..]*EventTarget
        root_of_closed_tree: bool
        slot_in_closed_tree: bool
        invocation_target_in_shadow_tree: bool
    }

    path: [..]Path
}

#portée_fichier

table_virtuelle_event := TableVirtuellePlatformObject(
    classe = Event,
    sur_destruction = event_sur_destruction
)

event_sur_destruction :: fonc (base: *JavaScript.Cellule)
{
    event := base comme *Event
    déloge(event.touch_target_list)
    déloge(event.path)
}

#portée_export

/* https://dom.spec.whatwg.org/#concept-event-path-append */
append_event_path :: fonc (event: *Event, invocation_target: *EventTarget, shadow_adjusted_target: *EventTarget, related_target: *EventTarget, touch_target_list: [..]*EventTarget, slot_in_closed_tree: bool)
{
    // 1. Let invocationTargetInShadowTree be false.
    invocation_target_in_shadow_tree := faux

    // 2. If invocationTarget is a node and its root is a shadow root, then set invocationTargetInShadowTree to true.
    si invocation_target.est_node() && racine_est_shadow_root(invocation_target comme *Noeud) {
        invocation_target_in_shadow_tree = vrai
    }

    // 3. Let root-of-closed-tree be false.
    root_of_closed_tree := faux

    // 4. If invocationTarget is a shadow root whose mode is "closed", then set root-of-closed-tree to true.
    si invocation_target.est_node() && (invocation_target comme *Noeud).genre == GenreNoeud.ShadowRoot {
        shadow_root := invocation_target comme *ShadowRoot
        root_of_closed_tree = shadow_root.mode == ShadowRootMode.closed
    }

    // 5. Append a new struct to event’s path whose
    // invocation target is invocationTarget,
    // invocation-target-in-shadow-tree is invocationTargetInShadowTree,
    // shadow-adjusted target is shadowAdjustedTarget,
    // relatedTarget is relatedTarget,
    // touch target list is touchTargets,
    // root-of-closed-tree is root-of-closed-tree,
    // and slot-in-closed-tree is slot-in-closed-tree.
    path: Event.Path
    path.invocation_target = invocation_target
    path.shadow_adjusted_target = shadow_adjusted_target
    path.related_target = related_target
    path.touch_target_list = touch_target_list
    path.invocation_target_in_shadow_tree = invocation_target_in_shadow_tree
    path.root_of_closed_tree = root_of_closed_tree
    path.slot_in_closed_tree = slot_in_closed_tree

    tableau_ajoute(*event.path, path)
}

/** } */

/* ------------------------------------------------------------------------- */
/** \nom MouseEvent
 * https://w3c.github.io/uievents/#mouseevent
 * https://drafts.csswg.org/cssom-view/#extensions-to-the-mouseevent-interface
 * \{ */

MouseEvent :: struct {
    empl event: Event
    table = *table_virtuelle_mouse_event

    screen_x: r64
    screen_y: r64
    offset_x: r64
    offset_y: r64
}

#portée_fichier

table_virtuelle_mouse_event := TableVirtuellePlatformObject(
    classe = MouseEvent,
    sur_destruction = event_sur_destruction
)

#portée_export

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Callbacks
 * https://webidl.spec.whatwg.org/#idl-callback-interface
 * \{ */

CallbackType :: struct {
    empl cellule: JavaScript.Cellule

    object: *JavaScript.Object
    callback_context: *EnvironmentSettings
}

/* https://html.spec.whatwg.org/multipage/webappapis.html#incumbent-settings-object */
donne_incumbent_settings_object :: fonc () -> *EnvironmentSettings
{
    // À FAIRE
    retourne nul
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom EventListener
 * https://dom.spec.whatwg.org/#callbackdef-eventlistener
 * \{ */

#portée_fichier

table_virtuelle_event_listener := JavaScript.TableVirtuelleCellule(classe = EventListener)

#portée_export

EventListener :: struct {
    empl callback_type: CallbackType
    table = *table_virtuelle_event_listener
}

crée_event_listener :: fonc (object: *JavaScript.Object) -> *EventListener
{
    tas_de_mémoire := JavaScript.donne_tas_de_mémoire(object)
    résultat := JavaScript.alloue(tas_de_mémoire, EventListener)
    résultat.object = object
    résultat.callback_context = donne_incumbent_settings_object()
    retourne résultat
}

EventListenerOptions :: struct {
    capture := faux
}

AddEventListenerOptions :: struct {
    empl base: EventListenerOptions
    passive: Optionnel(bool)
    once := faux
    signal: *AbortSignal
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom EventHandler
 * \{ */

#portée_fichier

table_virtuelle_event_handler := JavaScript.TableVirtuelleCellule(classe = EventHandler)

#portée_export

EventHandler :: struct {
    empl callback_type: CallbackType
    table = *table_virtuelle_event_handler
}

crée_event_handler :: fonc (object: *JavaScript.Object, callback_context : *EnvironmentSettings = nul) -> *EventHandler
{
    tas_de_mémoire := JavaScript.donne_tas_de_mémoire(object)
    résultat := JavaScript.alloue(tas_de_mémoire, EventHandler)
    résultat.object = object
    saufsi callback_context {
        callback_context = donne_incumbent_settings_object()
    }
    résultat.callback_context = callback_context
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom EventTarget
 * https://dom.spec.whatwg.org/#eventtarget
 * \{ */

#portée_module

TableVirtuelleEventTarget :: struct {
    empl platform_object: TableVirtuellePlatformObject

    sur_destruction = event_target_sur_destruction

    /* https://dom.spec.whatwg.org/#get-the-parent */
    sur_get_the_parent: fonc(*EventTarget, *Event)(*EventTarget) = event_target_sur_get_the_parent
    /* https://dom.spec.whatwg.org/#eventtarget-activation-behavior */
    sur_activation_behavior: fonc(*EventTarget, *Event)(rien)
    /* https://dom.spec.whatwg.org/#eventtarget-legacy-pre-activation-behavior */
    sur_legacy_pre_activation_behavior: fonc(*EventTarget, *Event)(rien)
    /* https://dom.spec.whatwg.org/#eventtarget-legacy-canceled-activation-behavior */
    sur_legacy_canceled_activation_behavior: fonc(*EventTarget, *Event)(rien)
}

event_target_sur_destruction :: fonc (base: *JavaScript.Cellule)
{
    platform_object_sur_destruction(base)
    target := base comme *EventTarget
    déloge(target.listeners)
    déloge(target.event_handlers)
}

/* Implémentation défaut pour get_the_parent. */
event_target_sur_get_the_parent :: fonc (target: *EventTarget @inutilisée, event: *Event @inutilisée) -> *EventTarget
{
    retourne nul
}

#portée_export

EventTarget :: struct {
    empl platform_object: PlatformObject

    EventListenerEntry :: struct {
        type: EventType
        callback: *CallbackType
        capture: bool
        passive: Optionnel(bool)
        once: bool
        signal: *AbortSignal
        removed: bool
    }

    listeners: [..]EventListenerEntry
    event_handlers: [..]EventHandlerEntry
}

donne_table :: fonc (event_target: *EventTarget) -> *TableVirtuelleEventTarget #enligne
{
    retourne event_target.table comme *TableVirtuelleEventTarget
}

get_the_parent :: fonc (target: *EventTarget, event: *Event) -> *EventTarget
{
    table := target.donne_table()
    assert(table != nul)
    assert(table.sur_get_the_parent != nul)
    retourne table.sur_get_the_parent(target, event)
}

possède_activation_behavior :: fonc (target: *EventTarget) -> bool
{
    table := target.donne_table()
    /* À FAIRE : nous pourrions avoir une condition plus subtile pour,
     *  par exemple, les éléments ancres qui n'ont pas de href. */
    retourne table != nul && table.sur_activation_behavior != nul
}

run_activation_behavior :: fonc (target: *EventTarget, event: *Event)
{
    event.est_dans_activation_behavior = vrai
    diffère event.est_dans_activation_behavior = faux
    table := target.donne_table()
    assert(table != nul)
    assert(table.sur_activation_behavior != nul)
    table.sur_activation_behavior(target, event)
}

possède_legacy_pre_activation_behavior :: fonc (target: *EventTarget) -> bool
{
    assert(possède_activation_behavior(target))
    table := target.donne_table()
    retourne table != nul && table.sur_legacy_pre_activation_behavior != nul
}

run_legacy_pre_activation_behavior :: fonc (target: *EventTarget, event: *Event)
{
    table := target.donne_table()
    assert(table != nul)
    assert(table.sur_legacy_pre_activation_behavior != nul)
    table.sur_legacy_pre_activation_behavior(target, event)
}

run_legacy_canceled_activation_behavior :: fonc (target: *EventTarget, event: *Event)
{
    table := target.donne_table()
    assert(table != nul)
    assert(table.sur_legacy_canceled_activation_behavior != nul)
    table.sur_legacy_canceled_activation_behavior(target, event)
}

/* https://dom.spec.whatwg.org/#add-an-event-listener */
add_an_event_listener :: fonc (target: *EventTarget, listener: EventTarget.EventListenerEntry)
{
    // À FAIRE 1. If eventTarget is a ServiceWorkerGlobalScope object,
    // its service worker’s script resource’s has ever been evaluated flag is set,
    // and listener’s type matches the type attribute value of any of the service worker events,
    // then report a warning to the console that this might not give the expected results.

    // 2. If listener’s signal is not null and is aborted, then return.
    si listener.signal != nul && listener.signal.aborted {
        retourne
    }

    // 3. If listener’s callback is null, then return.
    si listener.callback == nul {
        retourne
    }

    // 4. If listener’s passive is null, then set it to the default passive value given listener’s type and eventTarget.
    saufsi listener.passive.possède_valeur() {
        listener.passive = default_passive_value(listener.type, target)
    }

    // 5. If eventTarget’s event listener list does not contain an event listener whose type is listener’s type,
    //    callback is listener’s callback, and capture is listener’s capture, then append listener to
    //    eventTarget’s event listener list.
    pour target.listeners {
        si it.type != listener.type {
            continue
        }
        si it.callback != listener.callback {
            continue
        }
        si it.capture != listener.capture {
            continue
        }

        arrête
    }
    sansarrêt {
        tableau_ajoute(*target.listeners, listener)
    }

    // À FAIRE 6. If listener’s signal is not null, then add the following abort steps to it:
    //    1. Remove an event listener with eventTarget and listener.
}

/* https://dom.spec.whatwg.org/#remove-an-event-listener */
remove_an_event_listener :: fonc (target: *EventTarget, event_listener: EventTarget.EventListenerEntry, index: z64)
{
    // À FAIRE 1. If eventTarget is a ServiceWorkerGlobalScope object and its service
    //    worker’s set of event types to handle contains listener’s type, then
    //    report a warning to the console that this might not give the expected
    //    results.

    // 2. Set listener’s removed to true and remove listener from eventTarget’s event listener list.
    event_listener.removed = vrai
    tableau_supprime_index(*target.listeners, index)
}

/* https://dom.spec.whatwg.org/#remove-all-event-listeners */
remove_all_listeners :: fonc (target: *EventTarget)
{
    pour > target.event_listener {
        remove_an_event_listener(target, it, index_it)
    }
}

/* https://dom.spec.whatwg.org/#default-passive-value */
default_passive_value :: fonc (type: EventType @inutilisée, target: *EventTarget @inutilisée) -> bool
{
    // À FAIRE 1. Return true if all of the following are true:
    //
    //    type is one of "touchstart", "touchmove", "wheel", or "mousewheel".
    //
    //    eventTarget is a Window object, or is a node whose node document is eventTarget,
    //    or is a node whose node document’s document element is eventTarget,
    //    or is a node whose node document’s body element is eventTarget.

    // 2. Return false.
    retourne faux
}

/* https://html.spec.whatwg.org/multipage/nav-history-apis.html#concept-document-window */
donne_document_associé :: fonc (target: *EventTarget) -> *Document
{
    assert(target.table.classe == Window)
    window := target comme *Window
    retourne window.document
}

#portée_export

/* Enveloppe pour IDL où EventType n'est pas convertis. */
add_event_listener :: fonc (target: *EventTarget, type: ChaineUTF16Unique, callback: *CallbackType, options : *AddEventListenerOptions = nul)
{
    chn_type := converti_vers_chaine(type.donne_chaine_utf16())
    diffère déloge(chn_type)

    valeur_type, trouvé := donne_valeur_énum_pour_nom(info_de(EventType), chn_type)
    saufsi trouvé {
        // À FAIRE : que faire ?
        retourne
    }

    add_event_listener(target, valeur_type comme EventType, callback, options)
}

/* https://dom.spec.whatwg.org/#dom-eventtarget-addeventlistener */
add_event_listener :: fonc (target: *EventTarget, type: EventType, callback: *CallbackType, options : *AddEventListenerOptions = nul)
{
    // 1. Let capture, passive, once, and signal be the result of flattening more options.
    capture := faux
    passive: Optionnel(bool)
    once := faux
    signal: *AbortSignal

    si options {
        capture = options.capture
        passive = options.passive
        once = options.once
        signal = options.signal
    }

    // 2. Add an event listener with this and an event listener whose type is type,
    //    callback is callback, capture is capture, passive is passive, once is once,
    //    and signal is signal.
    event_listener: EventTarget.EventListenerEntry
    event_listener.type = type
    event_listener.callback = callback
    event_listener.capture = capture
    event_listener.passive = passive
    event_listener.once = once
    event_listener.signal = signal

    add_an_event_listener(target, event_listener)
}

/* https://dom.spec.whatwg.org/#dom-eventtarget-removeeventlistener */
remove_event_listener :: fonc (target: *EventTarget, type: EventType, callback: *CallbackType, options : *EventListenerOptions = nul)
{
    // 1. Let capture be the result of flattening options.
    capture := faux
    si options {
        capture = options.capture
    }

    // 2. If this’s event listener list contains an event listener whose type is type, 
    //    callback is callback, and capture is capture, then remove an event listener
    //    with this and that event listener.
    pour target.listeners {
        si it.type != type {
            continue
        }
        si it.callback != callback {
            continue
        }
        si it.capture != capture {
            continue
        }

        remove_an_event_listener(target, it, index_it)
        arrête
    }
}

/* https://dom.spec.whatwg.org/#concept-event-fire */
ConfigurationIDLAttributes :: struct {
    bubbles: bool
    composed: bool
}

fire_an_event :: fonc (target: *EventTarget, nom: EventType, config: ConfigurationIDLAttributes) -> bool
{
    event := crée_platform_object(target, Event)
    event.type = nom
    event.bubbles = config.bubbles
    event.composed = config.composed
    retourne dispatch(event, target, nul)
}

fire_an_event :: fonc (target: *EventTarget, nom: EventType, legacy_target_override : *bool = nul) -> bool
{
    event := crée_platform_object(target, Event)
    event.type = nom
    retourne dispatch(event, target, legacy_target_override)
}

/* https://dom.spec.whatwg.org/#dom-eventtarget-dispatchevent */
dispatch_event :: fonc (target: *EventTarget, event: *Event) -> bool
{
    // 1. If event’s dispatch flag is set, or if its initialized flag is not set,
    //    then throw an "InvalidStateError" DOMException.
    si event.dispatch == vrai || event.initialized == faux {
        imprime("[%] À FAIRE : throw an \"InvalidStateError\" DOMException\n", #nom_de_cette_fonction)
        retourne faux
    }

    // 2. Initialize event’s isTrusted attribute to false.
    event.is_trusted = faux

    // 3. Return the result of dispatching event to this.
    retourne dispatch(event, target)
}

/* https://dom.spec.whatwg.org/#concept-event-dispatch */
dispatch :: fonc (event: *Event, target: *EventTarget, legacy_target_override : *bool = nul, legacy_output_did_listeners_throw : *bool = nul) -> bool
{
    // 1. Set event’s dispatch flag.
    event.dispatch = vrai

    // 2. Let targetOverride be target, if legacy target override flag is not given, and target’s associated Document otherwise.
    target_override: *EventTarget
    saufsi legacy_target_override {
        target_override = target
    }
    sinon {
        target_override = target.donne_document_associé()
    }

    // 3. Let activationTarget be null.
    activation_target: *EventTarget

    // 4. Let relatedTarget be the result of retargeting event’s relatedTarget against target.
    related_target := retarget(event.related_target, target)
    
    // 5. If target is not relatedTarget or target is event’s relatedTarget, then:
    clear_targets := faux

    si target != related_target || target == event.related_target {
        // 1. Let touchTargets be a new list.
        touch_targets: [..]*EventTarget

        // 2. For each touchTarget of event’s touch target list, append the result of retargeting touchTarget against target to touchTargets.
        pour event.touch_target_list {
            tableau_ajoute(*touch_targets, retarget(it, target))
        }

        // 3. Append to an event path with event, target, targetOverride, relatedTarget, touchTargets, and false.
        append_event_path(event, target, target_override, related_target, touch_targets, faux)

        // 4. Let isActivationEvent be true, if event is a MouseEvent object and event’s type attribute is "click"; otherwise false.
        // À FAIRE : vérifie si MouseEvent
        is_activation_event := event.type == EventType.click

        // 5. If isActivationEvent is true and target has activation behavior, then set activationTarget to target.
        si is_activation_event && target.possède_activation_behavior() {
            activation_target = target
        }

        // À FAIRE 6. Let slottable be target, if target is a slottable and is assigned, and null otherwise.
        // slottable: *EventTarget

        // 7. Let slot-in-closed-tree be false.
        slot_in_closed_tree := faux

        // 8. Let parent be the result of invoking target’s get the parent with event.
        parent := get_the_parent(target, event)

        // 9. While parent is non-null:
        tantque parent != nul {
            // 1. If slottable is non-null:

                // 1. Assert: parent is a slot.

                // 2. Set slottable to null.

                // 3. If parent’s root is a shadow root whose mode is "closed", then set slot-in-closed-tree to true.

            // 2. If parent is a slottable and is assigned, then set slottable to parent.

            // 3. Let relatedTarget be the result of retargeting event’s relatedTarget against parent.
            related_target = retarget(related_target, parent)

            // 4. Let touchTargets be a new list.

            // 5. For each touchTarget of event’s touch target list, append the result of retargeting touchTarget against parent to touchTargets.

            // 6. If parent is a Window object, or parent is a node and target’s root is a shadow-including inclusive ancestor of parent, then:

                // 1. If isActivationEvent is true, event’s bubbles attribute is true, activationTarget is null, and parent has activation behavior, then set activationTarget to parent.

                // 2. Append to an event path with event, parent, null, relatedTarget, touchTargets, and slot-in-closed-tree.

            // 7. Otherwise, if parent is relatedTarget, then set parent to null.
            si parent == related_target {
                parent = nul
            }
            // 8. Otherwise, set target to parent and then:
            sinon {
                target = parent

                // 1. If isActivationEvent is true, activationTarget is null, and target has activation behavior, then set activationTarget to target.
                si is_activation_event == vrai && activation_target == nul && target.possède_activation_behavior() {
                    activation_target = target
                }

                // 2. Append to an event path with event, parent, target, relatedTarget, touchTargets, and slot-in-closed-tree.
                append_event_path(event, parent, target, related_target, touch_targets, slot_in_closed_tree)
            }

            // 9. If parent is non-null, then set parent to the result of invoking parent’s get the parent with event.
            si parent != nul {
                parent = get_the_parent(parent, event)
            }

            // 10. Set slot-in-closed-tree to false.
            slot_in_closed_tree = faux
        }

        // 10. Let clearTargetsStruct be the last struct in event’s path whose shadow-adjusted target is non-null.

        // 11. Let clearTargets be true if clearTargetsStruct’s shadow-adjusted target, clearTargetsStruct’s relatedTarget, or an EventTarget object in clearTargetsStruct’s touch target list is a node and its root is a shadow root; otherwise false.

        // 12. If activationTarget is non-null and activationTarget has legacy-pre-activation behavior,
        //     then run activationTarget’s legacy-pre-activation behavior.
        si activation_target && activation_target.possède_legacy_pre_activation_behavior() {
            run_legacy_pre_activation_behavior(activation_target, event)
        }

        // 13. For each struct in event’s path, in reverse order:
        pour > event.path {
            // 1. If struct’s shadow-adjusted target is non-null, then set event’s eventPhase attribute to AT_TARGET.
            si it.shadow_adjusted_target {
                event.event_phase = EventPhase.AT_TARGET
            }
            // 2. Otherwise, set event’s eventPhase attribute to CAPTURING_PHASE.
            sinon {
                event.event_phase = EventPhase.CAPTURING_PHASE
            }

            // 3. Invoke with struct, event, "capturing", and legacyOutputDidListenersThrowFlag if given.
            invoke(it, event, "capturing", legacy_output_did_listeners_throw)
        }

        // 14. For each struct in event’s path:
        pour event.path {
            // 1. If struct’s shadow-adjusted target is non-null, then set event’s eventPhase attribute to AT_TARGET.
            si it.shadow_adjusted_target {
                event.event_phase = EventPhase.AT_TARGET
            }
            // 2. Otherwise:
            sinon {
                // 1. If event’s bubbles attribute is false, then continue.
                saufsi event.bubbles {
                    continue
                }

                // 2. Set event’s eventPhase attribute to BUBBLING_PHASE.
                event.event_phase = EventPhase.BUBBLING_PHASE
            }

            // 3. Invoke with struct, event, "bubbling", and legacyOutputDidListenersThrowFlag if given.
            invoke(it, event, "bubbling", legacy_output_did_listeners_throw)
        }
    }

    // 6. Set event’s eventPhase attribute to NONE.
    event.event_phase = EventPhase.NONE

    // 7. Set event’s currentTarget attribute to null.
    event.current_target = nul

    // 8. Set event’s path to the empty list.
    déloge(event.path)

    // 9. Unset event’s dispatch flag, stop propagation flag, and stop immediate propagation flag.
    event.dispatch = faux
    event.stop_propagation = faux
    event.stop_immediate_propagation = faux

    // 10. If clearTargets, then:
    si clear_targets {
        // 1. Set event’s target to null.
        event.target = nul

        // 2. Set event’s relatedTarget to null.
        event.related_target = nul

        // 3. Set event’s touch target list to the empty list.
        déloge(event.touch_target_list)
    }

    // 11. If activationTarget is non-null, then:
    si activation_target {
        // 1. If event’s canceled flag is unset, then run activationTarget’s activation behavior with event.
        saufsi event.canceled {
            run_activation_behavior(activation_target, event)
        }
        // 2. Otherwise, if activationTarget has legacy-canceled-activation behavior, then run activationTarget’s legacy-canceled-activation behavior.
        sinon {
            run_legacy_canceled_activation_behavior(activation_target, event)
        }
    }

    // 12. Return false if event’s canceled flag is set; otherwise true.
    retourne event.canceled == faux
}

/* https://dom.spec.whatwg.org/#concept-event-listener-invoke */
invoke :: fonc (segment: &Event.Path, event: *Event, phase: chaine, legacy_output_did_listeners_throw : *bool = nul @inutilisée)
{
    // imprime("À FAIRE : [%]\n", #nom_de_cette_fonction)
    event.current_target = segment.invocation_target
    inner_invoke(event, segment.invocation_target.listeners, phase)
}

/* https://dom.spec.whatwg.org/#concept-event-listener-invoke */
inner_invoke :: fonc (event: *Event, listeners: []EventTarget.EventListenerEntry, phase: chaine)
{
    // imprime("À FAIRE : [%]\n", #nom_de_cette_fonction)

    arguments: [..]JavaScript.Valeur
    diffère déloge(arguments)
    tableau_ajoute(*arguments, JavaScript.Valeur(Object = event))

    pour listeners {
        si it.type != event.type {
            continue
        }

        si it.removed {
            continue
        }

        si it.capture == faux && phase == "capturing" {
            continue
        }

        si it.capture == vrai && phase == "bubbling" {
            continue
        }

        completion := call_a_user_object_operation(JavaScript.Valeur(Object = it.callback.object), arguments, JavaScript.Valeur(Object = event.current_target))
        saufsi JavaScript.est_normal(completion) {
            // À FAIRE : it.callback.callback_context.donne_global_object()
            global := event.target.realm.global_object
            report_an_exception(completion.valeur.V, global)
        }
    }
}

/* https://webidl.spec.whatwg.org/#call-a-user-objects-operation */
call_a_user_object_operation :: fonc (value: JavaScript.Valeur, args: []JavaScript.Valeur, this_arg: JavaScript.Valeur) -> JavaScript.CompletionRecord
{
    // imprime("À FAIRE : [%]\n", #nom_de_cette_fonction)

    target := JavaScript.donne_objet(this_arg) comme *EventTarget

    realm := target.realm
    settings := JavaScript.donne_données(realm.host_defined, EnvironmentSettings)

    prepare_to_run_script(settings)

    evaluation_status := JavaScript.call(JavaScript.donne_mv(realm), value, this_arg, args)

    cleanup_after_running_script(settings)

    retourne evaluation_status
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom EventHandler
 * \{ */

TypeValeurEventHandler :: énum {
    Nulle
    InternalRawUncompiled
    Valeur
}

EventHandlerEntry :: struct {
    nom: DOMString
    type_valeur: TypeValeurEventHandler
    internal_raw_uncompiled: DOMString
    value: *EventHandler

    listener : z64 = -1
}

donne_event_handler :: fonc (event_target: *EventTarget, nom: DOMString) -> *EventHandlerEntry
{
    pour * event_target.event_handlers {
        si it.nom == nom {
            retourne it
        }
    }

    résultat := tableau_ajoute_élément(*event_target.event_handlers)
    résultat.nom = nom
    résultat.value = nul
    retourne résultat
}

/* https://html.spec.whatwg.org/multipage/webappapis.html#deactivate-an-event-handler */
deactivate_an_event_handler :: fonc (event_target: *EventTarget, nom: DOMString)
{
    // 1. Let handlerMap be eventTarget's event handler map.
    // 2. Let eventHandler be handlerMap[name].
    event_handler := donne_event_handler(event_target, nom)

    // 3. Set eventHandler's value to null.
    event_handler.type_valeur = TypeValeurEventHandler.Nulle
    event_handler.value = nul

    // 4. Let listener be eventHandler's listener.
    listener := event_handler.listener

    // 5. If listener is not null, then remove an event listener with eventTarget and listener.
    si listener != -1 {
        remove_an_event_listener(event_target, event_target.listeners[listener], listener)
    }

    // 6. Set eventHandler's listener to null.
    event_handler.listener = -1
}

activate_an_event_handler :: fonc (event_target: *EventTarget, nom: DOMString)
{
    // 1. Let handlerMap be eventTarget's event handler map.
    // 2. Let eventHandler be handlerMap[name].
    event_handler := donne_event_handler(event_target, nom)

    // 3. If eventHandler's listener is not null, then return.
    si event_handler.listener != -1 {
        retourne
    }

    // 4. Let callback be the result of creating a Web IDL EventListener instance representing
    //    a reference to a function of one argument that executes the steps of the event handler
    //    processing algorithm, given eventTarget, name, and its argument.
    //    The EventListener's callback context can be arbitrary; it does not impact the steps of the event handler processing algorithm. [DOM]
    processor := crée_event_handler_processor(event_target, nom)
    callback := crée_event_listener(processor)

    // 5. Let listener be a new event listener whose type is the event handler event type corresponding to eventHandler and callback is callback.
    listener: EventTarget.EventListenerEntry
    listener.type = donne_event_type_pour_nom_event_handler(nom)
    listener.callback = callback

    // 6. Add an event listener with eventTarget and listener.
    add_an_event_listener(event_target, listener)

    // 7. Set eventHandler's listener to listener.
    pour event_target.listeners {
        si it.callback == callback {
            event_handler.listener = index_it
            arrête
        }
    }
}

/* https://html.spec.whatwg.org/multipage/webappapis.html#event-handler-idl-attributes */
get_event_handler_idl_attribute :: fonc (this: *EventTarget, name: DOMString) -> *EventHandler
{
    // À FAIRE : 1. Let eventTarget be the result of determining the target of an event handler given this object and name.
    event_target := determine_the_target_of_an_event_handler(this, name)

    // 2. If eventTarget is null, then return null.
    si event_target == nul {
        retourne nul
    }
    
    // 3. Return the result of getting the current value of the event handler given eventTarget and name.
    retourne get_the_current_value_of_the_event_handler(event_target, name)
}

set_event_handler_idl_attribute :: fonc (this: *EventTarget, name: DOMString, value: *EventHandler)
{
    // 1. Let eventTarget be the result of determining the target of an event handler given this object and name.
    event_target := determine_the_target_of_an_event_handler(this, name)

    // 2. If eventTarget is null, then return.
    si event_target == nul {
        retourne
    }

    // 3. If the given value is null, then deactivate an event handler given eventTarget and name.
    si value == nul {
        deactivate_an_event_handler(event_target, name)
    }
    // 4. Otherwise:
    sinon {
        // 1. Let handlerMap be eventTarget's event handler map.
        // 2. Let eventHandler be handlerMap[name].
        event_handler := donne_event_handler(event_target, name)

        // 3. Set eventHandler's value to the given value.
        event_handler.type_valeur = TypeValeurEventHandler.Valeur
        event_handler.value = value

        // 4. Activate an event handler given eventTarget and name.
        activate_an_event_handler(event_target, name)
    }
}

/* https://html.spec.whatwg.org/multipage/webappapis.html#getting-the-current-value-of-the-event-handler */
get_the_current_value_of_the_event_handler :: fonc (event_target: *EventTarget, name: DOMString) -> *EventHandler
{
    // 1. Let handlerMap be eventTarget's event handler map.
    // 2. Let eventHandler be handlerMap[name].
    event_handler := donne_event_handler(event_target, name)

    // 3. If eventHandler's value is an internal raw uncompiled handler, then:
    si event_handler.type_valeur == TypeValeurEventHandler.InternalRawUncompiled {
        // 1. If eventTarget is an element, then let element be eventTarget, and document be
        //    element's node document. Otherwise, eventTarget is a Window object, let element
        //    be null, and document be eventTarget's associated Document.
        élément := est_élément(event_target)
        document: *Document
        si élément {
            document = élément.document
        }
        sinon {
            assert(event_target.table.classe == Window)
            document = (event_target comme *Window).document
        }

        // 2. If scripting is disabled for document, then return null.
        si scripting_est_désactivé(document) {
            retourne nul
        }

        // 3. Let body be the uncompiled script body in eventHandler's value.
        body := event_handler.internal_raw_uncompiled

        // À FAIRE 4. Let location be the location where the script body originated, as given by eventHandler's value.

        // 5. If element is not null and element has a form owner, let form owner be that form owner. Otherwise, let form owner be null.

        // 6. Let settings object be the relevant settings object of document.
        settings_object := document.donne_relevant_settings_object()

        // 7. If body is not parsable as FunctionBody or if parsing detects an early error, then follow these substeps:
        // @fuite-de-mémoire
        realm := event_target.realm
        texte_source := JavaScript.crée_texte_source(body)
        parsed_body: *JavaScript.NoeudSyntaxique

        discr JavaScript.parse_text(realm, *texte_source, JavaScript.GoalSymbol.FunctionBody) {
            Ok(n) {
                parsed_body = n
            }
            sinon {
                // 1. Set eventHandler's value to null.
                event_handler.type_valeur = TypeValeurEventHandler.Nulle
                event_handler.value = nul

                //  À FAIRE : 2. Let syntaxError be a new SyntaxError exception associated with settings object's realm which describes the error while parsing. It should be based on location, where the script body originated.

                // 3. Report an exception with syntaxError for settings object's global object.

                // 4. Return null.
                retourne nul
            }
        }

        // 8. Push settings object's realm execution context onto the JavaScript execution context stack; it is now the running JavaScript execution context.
        execution_context := settings_object.donne_realm_execution_context()
        mv := JavaScript.donne_mv(realm)
        JavaScript.empile_execution_context(mv, execution_context)

        // 9. Let function be the result of calling OrdinaryFunctionCreate, with arguments:
        // functionPrototype %Function.prototype%
        function_prototype := realm.intrinsics.function_prototype

        // sourceText
        // If name is onerror and eventTarget is a Window object
        // The string formed by concatenating "function ", name, "(event, source, lineno, colno, error) {", U+000A LF, body, U+000A LF, and "}".
        // Otherwise
        // The string formed by concatenating "function ", name, "(event) {", U+000A LF, body, U+000A LF, and "}".
        source_text := si name == EVT_onerror {
            imprime_chaine("function %(event, source, lineno, colno, error) {\n%\n}", name, body)
        }
        sinon {
            imprime_chaine("function %(event) {\n%\n}", name, body)
        }

        // ParameterList
        // If name is onerror and eventTarget is a Window object
        // Let the function have five arguments, named event, source, lineno, colno, and error.
        // Otherwise
        // Let the function have a single argument called event.
        parameter_list: [..]*JavaScript.Expression
        si name == EVT_onerror {
            identifier := JavaScript.crée_identifier_pour_html(crée_chaine_utf16_unique("event"))
            tableau_ajoute(*parameter_list, identifier)
            identifier = JavaScript.crée_identifier_pour_html(crée_chaine_utf16_unique("source"))
            tableau_ajoute(*parameter_list, identifier)
            identifier = JavaScript.crée_identifier_pour_html(crée_chaine_utf16_unique("lineno"))
            tableau_ajoute(*parameter_list, identifier)
            identifier = JavaScript.crée_identifier_pour_html(crée_chaine_utf16_unique("colno"))
            tableau_ajoute(*parameter_list, identifier)
            identifier = JavaScript.crée_identifier_pour_html(crée_chaine_utf16_unique("error"))
            tableau_ajoute(*parameter_list, identifier)
        }
        sinon {
            identifier := JavaScript.crée_identifier_pour_html(crée_chaine_utf16_unique("event"))
            tableau_ajoute(*parameter_list, identifier)
        }

        // body The result of parsing body above.

        // thisMode non-lexical-this

        // scope
        scope: *JavaScript.Environment
        {
            // 1. Let realm be settings object's realm.
            scope_realm := settings_object.donne_realm()

            // 2. Let scope be realm.[[GlobalEnv]].
            scope = scope_realm.global_environment

            // À FAIRE 3. If eventHandler is an element's event handler, then set scope to NewObjectEnvironment(document, true, scope).

            //    (Otherwise, eventHandler is a Window object's event handler.)

            // 4. If form owner is not null, then set scope to NewObjectEnvironment(form owner, true, scope).

            // 5. If element is not null, then set scope to NewObjectEnvironment(element, true, scope).

            // 6. Return scope.
        }

        function := JavaScript.ordinary_function_create(realm, function_prototype, source_text, parameter_list, parsed_body comme *JavaScript.Statement, JavaScript.NON_LEXICAL_THIS, scope, nul)

        // 10. Remove settings object's realm execution context from the JavaScript execution context stack.
        JavaScript.dépile_execution_context(mv)

        // 11. Set function.[[ScriptOrModule]] to null.
        function.script_or_module = nul

        // 12. Set eventHandler's value to the result of creating a Web IDL EventHandler callback function
        //     object whose object reference is function and whose callback context is settings object.
        event_handler.value = crée_event_handler(function, settings_object)
    }

    // 4. Return eventHandler's value.
    retourne event_handler.value
}

/* https://html.spec.whatwg.org/multipage/webappapis.html#determining-the-target-of-an-event-handler */
determine_the_target_of_an_event_handler :: fonc (event_target: *EventTarget, name: DOMString @inutilisée) -> *EventTarget
{
    // 1. If eventTarget is not a body element or a frameset element, then return eventTarget.
    élément := est_élément(event_target)
    si élément && !(élément.local_name == TAG_body || élément.local_name == TAG_frameset) {
        retourne event_target
    }

    // À FAIRE : 2. If name is not the name of an attribute member of the WindowEventHandlers interface mixin
    //    and the Window-reflecting body element event handler set does not contain name, then return
    //    eventTarget.

    // 3. If eventTarget's node document is not an active document, then return null.
    // document := event_target_donne_node_document(event_target)
    // À FAIRE : est active plutôt que fully active
    // saufsi document && document.est_fully_active() {
    //     retourne nul
    // }

    // 4. Return eventTarget's node document's relevant global object.
    global := donne_relevant_settings_object(event_target).donne_global_object()
    retourne JavaScript.vérifie_comme(global, EventTarget)
}

est_élément :: fonc (event_target: *EventTarget) -> *Élément
{
    table := event_target.table
    saufsi table {
        retourne nul
    }

    infos := __table_des_types[table.classe] comme *InfoTypeStructure
    saufsi est_struct_ou_employeuse_de(infos, info_de(Élément)) {
        retourne nul
    }

    retourne event_target comme *Élément
}

est_node :: fonc (event_target: *EventTarget) -> *Noeud
{
    table := event_target.table
    saufsi table {
        retourne nul
    }

    infos := __table_des_types[table.classe] comme *InfoTypeStructure
    saufsi est_struct_ou_employeuse_de(infos, info_de(Noeud)) {
        retourne nul
    }

    retourne event_target comme *Noeud
}

/* À FAIRE(langage) : erreur de compilation si cela s'appèle donne_node_document :
 * il nous faudra prendre en compte la distance (en terme de structures employées)
 * entre les structures employantes et le type racine lors de la résolution des appels. */
event_target_donne_node_document :: fonc (event_target: *EventTarget) -> *Document
{
    node := est_node(event_target)
    saufsi node {
        retourne nul
    }
    retourne node.document
}

#portée_fichier

event_handler_processor_sur_appel :: fonc (params: *JavaScript.ParamètresObjectCall) -> JavaScript.CompletionRecord
{
    processor := JavaScript.vérifie_comme(params.object, EventHandlerProcessor)
    objet := JavaScript.donne_objet(JavaScript.donne_argument(params, 0))
    event := JavaScript.vérifie_comme(objet, Event)
    retourne process_event_handler(processor.event_target, processor.nom, event)
}

/* https://html.spec.whatwg.org/multipage/webappapis.html#the-event-handler-processing-algorithm */
process_event_handler :: fonc (event_target: *EventTarget, nom: DOMString, event: *Event) -> JavaScript.CompletionRecord
{
    // 1. Let callback be the result of getting the current value of the event handler given eventTarget and name.
    callback := get_the_current_value_of_the_event_handler(event_target, nom)

    // 2. If callback is null, then return.
    si callback == nul {
        retourne JavaScript.normal_completion(JavaScript.js_undefined)
    }

    // À FAIRE : 3. Let special error event handling be true if event is an ErrorEvent object, event's type is "error", and event's currentTarget implements the WindowOrWorkerGlobalScope mixin. Otherwise, let special error event handling be false.
    special_error_event := faux

    // 4. Process the Event object event as follows:
    return_value := JavaScript.js_undefined
    // If special error event handling is true
    si special_error_event {
        // Let return value be the result of invoking callback with « event's message, event's filename, event's lineno, event's colno, event's error », "rethrow", and with callback this value set to event's currentTarget.
    }
    // Otherwise
    sinon {
        // À FAIRE : Let return value be the result of invoking callback with « event », "rethrow", and with callback this value set to event's currentTarget.

        arg_event := JavaScript.Valeur(Object = event)

        args: []JavaScript.Valeur
        args.pointeur = *arg_event
        args.taille = 1

        this_value := JavaScript.Valeur(Object = event.current_target)

        completion := call_a_user_object_operation(JavaScript.Valeur(Object = callback.object), args, this_value)
        saufsi JavaScript.est_normal(completion) {
            retourne completion
        }
        return_value = completion.valeur.V
    }

    // 5. Process return value as follows:

    // If event is a BeforeUnloadEvent object and event's type is "beforeunload"
        // If return value is not null, then:
            // Set event's canceled flag.

            // If event's returnValue attribute's value is the empty string, then set event's returnValue attribute's value to return value.

    // If special error event handling is true
        // If return value is true, then set event's canceled flag.

    // Otherwise
    // If return value is false, then set event's canceled flag.
    si JavaScript.est_false(return_value) {
        event.canceled = vrai
    }

    retourne JavaScript.normal_completion(return_value)
}

table_virtuelle_event_handler_processor := JavaScript.TableVirtuelleObject(classe = EventHandlerProcessor, sur_call = event_handler_processor_sur_appel)

EventHandlerProcessor :: struct {
    empl function: JavaScript.Function
    table = *table_virtuelle_event_handler_processor

    event_target: *EventTarget
    nom: DOMString
}

crée_event_handler_processor :: fonc (event_target: *EventTarget, nom: DOMString) -> *EventHandlerProcessor
{
    tas_de_mémoire := JavaScript.donne_tas_de_mémoire(event_target.realm)
    résultat := JavaScript.alloue(tas_de_mémoire, EventHandlerProcessor)
    JavaScript.set_function_length(résultat, 1.0)
    résultat.event_target = event_target
    résultat.nom = nom
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom AbortSignal
 * https://dom.spec.whatwg.org/#abortsignal
 * \{ */

#portée_fichier

table_virtuelle_abort_signal := TableVirtuelleEventTarget(
    classe = AbortSignal
)

#portée_export

AbortSignal :: struct {
    empl event_target: EventTarget
    table = *table_virtuelle_abort_signal

    aborted: bool
}

/** \} */
