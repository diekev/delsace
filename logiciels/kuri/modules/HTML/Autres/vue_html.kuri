importe Allocatrices
importe Chaine
importe Couleur
importe Fondation
importe Géométrie
importe HTML
importe HTTP
importe Internet
importe Math
importe OpenGL
importe PeintureInterface
importe Qt
importe SysFichier
importe Temps
importe Typographie

DÉBOGUE_ALLOCATIONS :: faux

/* ------------------------------------------------------------------------- */
/** \nom Fonction principale.
 * \{ */

allocatrice_gardée: AllocatriceGardée
contexte_entrée: ContexteProgramme

mon_logueur :: fonc (c: chaine, message: chaine @inutilisée, mode: ModeLogage @inutilisée, données: *rien @inutilisée)
{
    imprime("%\n", c)
}

principale :: fonc () -> z32
{
    mémoire_entrée := mémoire_utilisée()

    /* Nous ne pouvons pas utiliser un nouveau contexte car la fonction principale
     * peut ne pas se terminer (lors des fermetures de fenêtres). */
    contexte_entrée = __contexte_fil_principal

    #si DÉBOGUE_ALLOCATIONS {
        __contexte_fil_principal.logueur = mon_logueur
        __contexte_fil_principal.allocatrice = allocation_gardée
        __contexte_fil_principal.données_allocatrice = *allocatrice_gardée
    }

    arguments := __arguments_ligne_commande

    chemin_fichier: chaine
    si arguments.taille > 1 {
        arg1 := convertis_chaine_c_statique(ChaineC(arguments[1]))
        chemin_fichier = arg1
    }

    /* Création application. */
    taille_arguments := arguments.taille comme z32
    app := QT_cree_application(*taille_arguments, arguments.pointeur)
    diffère QT_detruit_application(app)

    rappel_fermeture: RappelFermetureApp
    rappel_fermeture.mémoire_entrée = mémoire_entrée
    QT_application_sur_fin_boucle_evenement(app, *rappel_fermeture)

    QT_core_application_definis_nom_organisation(vers_qt("delsace"))
    QT_core_application_definis_nom_application(vers_qt("HTML"))

    initialise_évènements_personnalisés()

    /* Création fenêtre. */
    rappels_fenêtre : RappelsFenetrePrincipale
    rappel_fermeture.rappels_fenêtre = *rappels_fenêtre

    fenêtre := QT_cree_fenetre_principale(*rappels_fenêtre)
    diffère QT_detruit_fenetre_principale(fenêtre)

    QT_widget_definis_titre_fenetre(fenêtre, vers_qt("HTML"))
    QT_widget_affiche_maximisee(fenêtre)

    rappels_fenêtre.chargeuse_ressource.rappels_interface = crée_rappels_interface_qt(fenêtre)

    si chemin_fichier {
        évènement := loge(ÉvènementCréationOnglet)
        évènement.uri = chemin_fichier

        QT_application_poste_evenement_et_donnees(fenêtre, évènement_sur_création_onglet, évènement)
    }

    retourne QT_application_exec(app)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Évènements
 * \{ */

évènement_sur_création_onglet : z32 = -1

ÉvènementCréationOnglet :: struct {
    uri: chaine
}

initialise_évènements_personnalisés :: fonc ()
{
    évènement_sur_création_onglet = QT_enregistre_evenement_personnel()
}

sur_filtre_evenement_impl :: fonc (base: *QT_Rappels_Fenetre_Principale, event: *QT_Evenement) -> z32
{
    type := QT_evenement_donne_type(event) comme n32 comme z32

    si type == évènement_sur_création_onglet {
        rappels := base comme *RappelsFenetrePrincipale

        message := QT_event_perso_donne_donnees(event) comme *ÉvènementCréationOnglet

        // ressource := crée_ressource_pour_chargement_page_web(rappels.fenetre, message.uri)
        // charge_ressource(*rappels.chargeuse_ressource, ressource, vrai)

        uri: URI

        si est_un_fichier_régulier(CheminFichier(message.uri)) {
            uri.schéma = "file"
            uri.schéma_est_défini = vrai
            uri.autorité_est_définie = vrai
            uri.chemin = message.uri
            uri = uri
        }
        sinon {
            uri = tente parse_uri_standard(message.uri) piège nonatteignable
        }

        navigable := crée_un_fresh_top_level_traversable(*rappels.user_agent, uri) comme *TraversableNavigable
        tableau_ajoute(*rappels.user_agent.top_level_traversables, navigable)

        page_web := crée_page_web(uri, navigable.donne_active_document())
        crée_widget_pour_page(rappels.fenetre, page_web)

        déloge(message)

        QT_evenement_accepte(event)
        retourne 1
    }

    retourne 0
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Sur fermeture application.
 * \{ */

RappelFermetureApp :: struct {
    empl base: QT_Rappel_Generique

    rappels_fenêtre: *RappelsFenetrePrincipale
    mémoire_entrée: z64

    sur_rappel = sur_fermeture_application
}

sur_fermeture_application :: fonc (base: *QT_Rappel_Generique)
{    
    rappel := base comme *RappelFermetureApp

    détruit_données_page_web(*rappel.rappels_fenêtre.page_web)

    /* Restaure le contexte. */
    __contexte_fil_principal = contexte_entrée

    imprime("mémoire_utilisée %\n", mémoire_utilisée() - rappel.mémoire_entrée)

    #si DÉBOGUE_ALLOCATIONS {
        imprime_liste_mémoire(*allocatrice_gardée)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom PageWeb
 * \{ */

PageWeb :: struct {
    uri: URI
    parsat: ParsatHTML
    contenu: chaine
    arbre_de_disposition: *ArbreDeDisposition
    fonte: *Fonte
}

crée_page_web :: fonc (uri: &URI, contenu: chaine) -> PageWeb
{
    résultat: PageWeb
    résultat.uri = uri
    résultat.contenu = contenu
    résultat.parsat = parse_document(contenu)
    imprime("Temps de parsage : %\n", résultat.parsat.temps)
    retourne résultat
}

crée_page_web :: fonc (uri: &URI, document: *Document) -> PageWeb
{
    résultat: PageWeb
    résultat.uri = uri
    résultat.parsat.document = document
    retourne résultat
}

détruit_données_page_web :: fonc (page: *PageWeb)
{
    détruit(page.parsat)
    déloge(page.contenu)
    détruit_arbre(page.arbre_de_disposition)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Données fenêtre principale.
 * \{ */

RappelsFenetrePrincipale :: struct {
    empl base : QT_Rappels_Fenetre_Principale

    user_agent: UserAgent

    page_web: PageWeb
    chargeuse_ressource: ChargeuseRessource

    /* Données rappels. */
    sur_filtre_evenement = sur_filtre_evenement_impl
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Widget page.
 * \{ */

crée_widget_pour_page :: fonc (fenêtre: *QT_Fenetre_Principale, page_web: PageWeb)
{
    rappels := QT_fenetre_principale_donne_rappels(fenêtre) comme *RappelsFenetrePrincipale
    rappels.page_web = page_web

    tabs := QT_cree_tab_widget(nul, fenêtre)
    QT_tab_widget_definis_tabs_fermable(tabs, 0)

    widget_rendu := crée_widget_pour_rendu(fenêtre, tabs)
    QT_tab_widget_ajoute_tab(tabs, widget_rendu, "Rendu")

    widget_source := crée_widget_vue_source(fenêtre, tabs)
    QT_tab_widget_ajoute_tab(tabs, widget_source, "Source")

    widget_arbre := crée_widget_arbre_pour_dom(fenêtre, tabs)
    QT_tab_widget_ajoute_tab(tabs, widget_arbre, "DOM")

    widget_texte := crée_widget_vue_texte(fenêtre, tabs)
    QT_tab_widget_ajoute_tab(tabs, widget_texte, "Texte")

    widget_arbre_disposition := crée_widget_vue_arbre_de_disposition(fenêtre, tabs)
    QT_tab_widget_ajoute_tab(tabs, widget_arbre_disposition, "Arbre de Disposition")

    QT_fenetre_principale_definis_widget_central(fenêtre, tabs)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ÉditriceArborescence
 * \{ */

WidgetArbre :: struct {
    empl base: QT_Rappels_TreeWidget
}

crée_widget_arbre :: fonc (rappels: *QT_Rappels_TreeWidget, parent: QT_Generic_Widget) -> *QT_TreeWidget
{
    résultat := QT_cree_treewidget(rappels, parent)

    QT_treewidget_definis_taille_icone(résultat, 20, 20)
    QT_treewidget_definis_toutes_les_colonnes_montre_focus(résultat, 1)
    QT_treewidget_definis_anime(résultat, 0)
    QT_treewidget_definis_auto_defilement(résultat, 0)
    QT_treewidget_definis_hauteurs_uniformes_lignes(résultat, 1)
    QT_treewidget_definis_mode_selection(résultat, QT_Mode_Selection.SELECTION_UNIQUE)
    QT_treewidget_definis_mode_drag_drop(résultat, QT_Mode_DragDrop.AUCUN_DRAG_DROP)
    QT_treewidget_definis_activation_drag(résultat, 0)
    QT_treewidget_definis_comportement_focus(résultat, QT_Comportement_Focus.AUCUN_FOCUS)
    QT_treewidget_definis_comportement_menu_contextuel(résultat, QT_Comportement_Menu_Contextuel.MENU_PERSONNALISE)
    QT_treewidget_definis_entete_visible(résultat, 1)

    retourne résultat
}

RappelsArborescence :: struct {
    empl base: QT_Rappels_TreeWidget

    fenêtre_principale: *QT_Fenetre_Principale
}

initialise_rappels_arborescence :: fonc (fenêtre_principale: *QT_Fenetre_Principale) -> RappelsArborescence
{
    // sur_changement_item_courant :: fonc (rappels: *QT_Rappels_TreeWidget, courant: *QT_TreeWidgetItem, précédent: *QT_TreeWidgetItem @inutilisée)
    // {
    //     rappels_arborescence := rappels comme *RappelsArborescence
    //     données := QT_treewidgetitem_donne_donnees(courant)
    // }

    résultat: RappelsArborescence
    résultat.fenêtre_principale = fenêtre_principale
    résultat.sur_changement_item_courant = sur_changement_item_courant
    retourne résultat
}

crée_widget_arbre_pour_dom :: fonc (fenêtre: *QT_Fenetre_Principale, parent: QT_Generic_Widget) -> *QT_TreeWidget
{
    rappels := QT_fenetre_principale_donne_rappels(fenêtre) comme *RappelsFenetrePrincipale

    résultat := crée_widget_arbre(nul, parent)

    parsat := rappels.page_web.parsat
    si parsat.document {
        titre := parsat.document.donne_title_element()
        si titre {
            texte_titre := extrait_texte_noeud(titre)
            diffère déloge(texte_titre)

            QT_widget_definis_titre_fenetre(fenêtre, vers_qt(texte_titre))
        }

        item_document := QT_cree_treewidgetitem(nul, nul)
        QT_treewidgetitem_definis_indicateur_enfant(item_document, QT_Indicateur_Enfant_Arbre.INVISIBLE_SI_SANS_ENFANT)
        texte := vers_qt("document")
        QT_treewidgetitem_definis_texte(item_document, 0, *texte)
        QT_treewidget_ajoute_item_racine(résultat, item_document)

        pour parsat.document.enfants {
            ajoute_item_pour_noeud(item_document, it)
        }
    }

    retourne résultat
}

ajoute_item_pour_noeud :: fonc (parent: *QT_TreeWidgetItem, noeud: *Noeud)
{
    texte := ""
    diffère déloge(texte)

    si noeud.est_élément() {
        élément := noeud comme *Élément

        enchaineuse: Enchaineuse
        initialise_enchaineuse(*enchaineuse)
        diffère détruit_tampons(*enchaineuse)

        ajoute_au_tampon(*enchaineuse, "<", élément.texte)

        pour noeud.attributs {
            ajoute_au_tampon(*enchaineuse, " ", it.nom, "=\"", it.valeur, "\"")
        }

        ajoute_au_tampon(*enchaineuse, ">")

        texte = chaine_depuis_enchaineuse(*enchaineuse)
    }
    sinon {
        si noeud.est_texte() {
            noeud_texte := noeud comme *NoeudTexte
            si est_espace_blanche_entre_élément(noeud_texte) {
                retourne
            }
        }

        texte = imprime_chaine("%", noeud.genre)
    }

    item_noeud := QT_cree_treewidgetitem(nul, nul)
    QT_treewidgetitem_definis_indicateur_enfant(item_noeud, QT_Indicateur_Enfant_Arbre.INVISIBLE_SI_SANS_ENFANT)
    qtexte := vers_qt(texte)
    QT_treewidgetitem_definis_texte(item_noeud, 0, *qtexte)

    QT_treewidgetitem_ajoute_enfant(parent, item_noeud)

    pour noeud.enfants {
        ajoute_item_pour_noeud(item_noeud, it)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom VueSource
 * \{ */

crée_widget_vue_source :: fonc (fenêtre: *QT_Fenetre_Principale, parent: QT_Generic_Widget) -> *QT_PlainTextEdit
{
    rappels := QT_fenetre_principale_donne_rappels(fenêtre) comme *RappelsFenetrePrincipale
    contenu := rappels.page_web.contenu

    résultat := QT_cree_plain_text_edit(nul, parent)
    QT_plain_text_edit_definis_lecture_seule(résultat, vrai)
    QT_plain_text_edit_definis_mode_retour_ligne(résultat, QT_Line_Wrap_Mode.AUCUN)
    QT_plain_text_edit_definis_texte(résultat, contenu)
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom VueSource
 * \{ */

crée_widget_vue_texte :: fonc (fenêtre: *QT_Fenetre_Principale, parent: QT_Generic_Widget) -> *QT_PlainTextEdit
{
    rappels := QT_fenetre_principale_donne_rappels(fenêtre) comme *RappelsFenetrePrincipale
    document := rappels.page_web.parsat.document

    résultat := QT_cree_plain_text_edit(nul, parent)
    QT_plain_text_edit_definis_lecture_seule(résultat, vrai)
    QT_plain_text_edit_definis_mode_retour_ligne(résultat, QT_Line_Wrap_Mode.AUCUN)
    si document {
        body := document.donne_élément_body()
        texte := extrait_texte_noeud(body)
        diffère déloge(texte)
        QT_plain_text_edit_definis_texte(résultat, texte)
    }
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Vue arbre de disposition
 * \{ */

crée_widget_vue_arbre_de_disposition :: fonc (fenêtre: *QT_Fenetre_Principale, parent: QT_Generic_Widget) -> *QT_TreeWidget
{
    rappels := QT_fenetre_principale_donne_rappels(fenêtre) comme *RappelsFenetrePrincipale

    résultat := crée_widget_arbre(nul, parent)

    arbre := crée_arbre_de_disposition(*rappels.page_web)
    si arbre {
        item_document := QT_cree_treewidgetitem(nul, nul)
        QT_treewidgetitem_definis_indicateur_enfant(item_document, QT_Indicateur_Enfant_Arbre.INVISIBLE_SI_SANS_ENFANT)
        texte := vers_qt("bloc")
        QT_treewidgetitem_definis_texte(item_document, 0, *texte)
        QT_treewidget_ajoute_item_racine(résultat, item_document)

        pour arbre.racine.enfants {
            ajoute_item_pour_noeud(item_document, it)
        }
    }
    retourne résultat
}

ajoute_item_pour_noeud :: fonc (parent: *QT_TreeWidgetItem, noeud: *NoeudDeDisposition)
{
    item_noeud := QT_cree_treewidgetitem(nul, nul)
    QT_treewidgetitem_definis_indicateur_enfant(item_noeud, QT_Indicateur_Enfant_Arbre.INVISIBLE_SI_SANS_ENFANT)
    texte := si noeud.type == NoeudDeDispositionBloc {
        "bloc"
    }
    sinon {
        "texte"
    }
    qtexte := vers_qt(texte)
    QT_treewidgetitem_definis_texte(item_noeud, 0, *qtexte)

    QT_treewidgetitem_ajoute_enfant(parent, item_noeud)

    pour noeud.enfants {
        ajoute_item_pour_noeud(item_noeud, it)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom VueRendu
 * \{ */

crée_widget_pour_rendu :: fonc (fenêtre: *QT_Fenetre_Principale, parent: QT_Generic_Widget) -> *QT_GLWidget
{
    rappels := QT_fenetre_principale_donne_rappels(fenêtre) comme *RappelsFenetrePrincipale
    résultat := crée_vue_rendu_page(parent, *rappels.page_web)
    retourne résultat
}

VueRenduPage :: struct {
    empl base: QT_Rappels_GLWidget

    sur_destruction = vue_rendu_page_sur_destruction
    sur_initialisation_gl = vue_rendu_page_sur_initialisation
    sur_peinture_gl = vue_rendu_page_sur_peinture
    sur_redimensionnement_gl = vue_rendu_page_sur_redimensionnement

    page: *PageWeb

    hauteur: z32
    largeur: z32

    peintre: *Peintre
}

crée_vue_rendu_page :: fonc (parent: QT_Generic_Widget, page: *PageWeb) -> *QT_GLWidget
{
    rappels := loge(VueRenduPage)
    rappels.page = page
    résultat := QT_cree_glwidget(rappels, parent)
    QT_widget_definis_trackage_souris(résultat, vrai)
    retourne résultat
}

vue_rendu_page_sur_destruction :: fonc (rappels: *QT_Rappels_GLWidget)
{
    vue_rendu_page := rappels comme *VueRenduPage
    déloge(vue_rendu_page)
}

vue_rendu_page_sur_initialisation :: fonc (base: *QT_Rappels_GLWidget @inutilisée)
{
    glewExperimental = 1
    erreur_ := glewInit()

    si erreur_ != 0 {
        imprime("Erreur lors de l'initilisation de GLEW !\n")
        retourne
    }
}

vue_rendu_page_sur_peinture :: fonc (base: *QT_Rappels_GLWidget)
{
    vue_rendu_page := base comme *VueRenduPage

    taille_cannevas := Taille(largeur = Largeur(vue_rendu_page.largeur), hauteur = Hauteur(vue_rendu_page.hauteur))

    saufsi vue_rendu_page.peintre {
        vue_rendu_page.peintre = crée_peintre_igumi(taille_cannevas)
    }

    peintre := vue_rendu_page.peintre
    peintre.définis_taille_cannevas(taille_cannevas)

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    glClearColor(1.0, 1.0, 1.0, 1.0)

    arbre := crée_arbre_de_disposition(vue_rendu_page.page)
    saufsi arbre && arbre.racine {
        retourne
    }

    page := vue_rendu_page.page

    ctx: ContexteDessin
    ctx.fonte = page.fonte
    ctx.peintre = peintre
    ctx.hauteur_vue = vue_rendu_page.hauteur

    dessine(arbre.racine, *ctx)
}

vue_rendu_page_sur_redimensionnement :: fonc (rappels: *QT_Rappels_GLWidget, taille: QT_Taille)
{
    vue_rendu_page := rappels comme *VueRenduPage
    vue_rendu_page.largeur = taille.largeur
    vue_rendu_page.hauteur = taille.hauteur
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Arbre de disposition
 * \{ */

ArbreDeDisposition :: struct {
    racine: *NoeudDeDisposition

    noeuds: [..]*NoeudDeDisposition
}

détruit_arbre :: fonc (arbre: *ArbreDeDisposition)
{
    saufsi arbre {
        retourne
    }

    pour arbre.noeuds {
        déloge(it.enfants)

        si it.type == NoeudDeDispositionBloc {
            bloc := it comme *NoeudDeDispositionBloc
            déloge(bloc)
        }
        sinon si it.type == NoeudDeDispositionTexte {
            texte := it comme *NoeudDeDispositionBloc
            déloge(texte)
        }
        sinon {
            imprime("noeud inconnu !")
            déloge(it)
        }
    }

    déloge(arbre.noeuds)
    déloge(arbre)
}

crée_noeud :: fonc (arbre: *ArbreDeDisposition, $TypeNoeud: type_de_données) -> *TypeNoeud
{
    résultat := loge(TypeNoeud)
    tableau_ajoute(*arbre.noeuds, résultat)
    retourne résultat
}

ContexteDisposition :: struct {
    fonte: *Fonte
    largeur_disponible: n32
}

ContexteDessin :: struct {
    fonte: *Fonte
    peintre: *Peintre

    hauteur_vue: z32
}

donne_rectangle_corrigé :: fonc (ctx: *ContexteDessin, noeud: *NoeudDeDisposition) -> RectanglePosDim(z32)
{
    rect: RectanglePosDim(z32)
    rect.x = noeud.position_x comme z32
    /* Nous disposons les noeuds comme si leur origine était leur coin du haut
     * gauche mais nous devons les dessiner comme si leur origine était leur
     * coin du bas gauche.
     * De plus, nous devons nous assurer que l'origine du document est le bas
     * gauche de la page et non le haut gauche. */
    rect.y = ctx.hauteur_vue - noeud.position_y comme z32 - noeud.hauteur comme z32
    rect.largeur = noeud.largeur comme z32
    rect.hauteur = noeud.hauteur comme z32
    retourne rect
}

NoeudDeDisposition :: struct {
    type := #type_de_cette_structure

    parent: *NoeudDeDisposition
    enfants: [..]*NoeudDeDisposition

    position_x: n32
    position_y: n32

    largeur: n32
    hauteur: n32

    sur_mesure: fonc (*NoeudDeDisposition, *ContexteDisposition)(rien)
    sur_dessin: fonc (*NoeudDeDisposition, *ContexteDessin)(rien)
}

décale :: fonc (noeud: *NoeudDeDisposition, x: n32, y: n32)
{
    noeud.position_x += x
    noeud.position_y += y

    pour noeud.enfants {
        it.décale(x, y)
    }
}

donne_nom_classe :: fonc (noeud: *NoeudDeDisposition) -> chaine
{
    infos := __table_des_types[noeud.type] comme *InfoTypeStructure
    retourne infos.nom
}

mesure :: fonc (noeud: *NoeudDeDisposition, ctx: *ContexteDisposition)
{
    si noeud.sur_mesure {
        noeud.sur_mesure(noeud, ctx)
    }
}

dessine :: fonc (noeud: *NoeudDeDisposition, ctx: *ContexteDessin)
{
    si noeud.largeur == 0 || noeud.hauteur == 0 {
        retourne
    }

    si noeud.sur_dessin {
        noeud.sur_dessin(noeud, ctx)
    }
}

ajoute_enfant :: fonc (parent: *NoeudDeDisposition, enfant: *NoeudDeDisposition)
{
    enfant.parent = parent
    tableau_ajoute(*parent.enfants, enfant)
}

/* Créé pour chaque noeud hors texte */
NoeudDeDispositionBloc :: struct {
    empl base: NoeudDeDisposition
    type = #type_de_cette_structure
    sur_mesure = noeud_disposition_bloc_sur_mesure
    sur_dessin = noeud_disposition_bloc_sur_dessin

    élément: *Élément
}

noeud_disposition_bloc_sur_mesure :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDisposition)
{
    noeud := base comme *NoeudDeDispositionBloc

    pour noeud.enfants {
        it.mesure(ctx)

        it.décale(0, noeud.hauteur)

        noeud.hauteur += it.hauteur
        noeud.largeur = max(noeud.largeur, it.largeur)
    }
}

noeud_disposition_bloc_sur_dessin :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDessin)
{
    noeud := base comme *NoeudDeDispositionBloc

    // rect := ctx.donne_rectangle_corrigé(noeud)

    // couleur := CouleurRVBA(0.5, 0.0, 0.5, 1.0)

    // peintre := ctx.peintre
    // peintre.dessine_rectangle(rect, couleur)

    pour noeud.enfants {
        dessine(it, ctx)
    }
}

/* Créé pour chaque élément contenant du texte. */
NoeudDeDispositionTexte :: struct {
    empl base: NoeudDeDisposition
    type = #type_de_cette_structure
    sur_mesure = noeud_disposition_texte_sur_mesure
    sur_dessin = noeud_disposition_texte_sur_dessin

    noeud_texte: *NoeudTexte
    texte: ChaineUTF16
}

noeud_disposition_texte_sur_mesure :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDisposition)
{
    noeud := base comme *NoeudDeDispositionTexte

    si est_vide_ou_uniquement_espaces_blanches(noeud.noeud_texte.données) {
        noeud.hauteur = 0
        noeud.largeur = 0
        noeud.sur_dessin = nul
        retourne
    }

    fonte := ctx.fonte

    métriques := fonte.donne_métriques_fonte()

    texte := supprime_espace_blanches_autour(noeud.noeud_texte.données)
    noeud.texte = texte

    noeud.hauteur = (métriques.donne_hauteur_ligne() + 0.5) comme n32
    noeud.largeur = fonte.donne_largeur_texte(texte) comme n32
}

noeud_disposition_texte_sur_dessin :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDessin)
{
    noeud := base comme *NoeudDeDispositionTexte

    rect := ctx.donne_rectangle_corrigé(noeud)

    couleur := CouleurRVBA(0.0, 0.0, 0.0, 1.0)

    texte := noeud.texte

    peintre := ctx.peintre
    fonte := ctx.fonte
    peintre.dessine_texte(fonte, texte, rect, couleur)
}

est_display_none :: fonc (noeud: *Noeud) -> bool
{
    si noeud.est_texte() {
        retourne faux
    }

    saufsi noeud.est_élément() {
        retourne vrai
    }

    élément := noeud comme *Élément

    tags_none := [
        TAG_area,
        TAG_base,
        TAG_basefont,
        TAG_datalist,
        TAG_head,
        TAG_link,
        TAG_meta,
        TAG_noembed,
        TAG_noframes,
        TAG_param,
        TAG_rp,
        TAG_script,
        TAG_style,
        TAG_template,
        TAG_title
    ]

    pour tags_none {
        si élément.texte == it {
            retourne vrai
        }
    }

    retourne faux
}

crée_arbre_de_disposition :: fonc (page: *PageWeb) -> *ArbreDeDisposition
{
    si page.arbre_de_disposition {
        retourne page.arbre_de_disposition
    }

    document := page.parsat.document

    saufsi document {
        retourne nul
    }

    html := document.donne_élément_html()
    saufsi html {
        retourne nul
    }

    résultat := loge(ArbreDeDisposition)

    racine := résultat.crée_noeud(NoeudDeDispositionBloc)
    racine.élément = html

    résultat.racine = racine

    pour html.enfants {
        si est_display_none(it) {
            continue
        }
        crée_noeud_pour_élément(résultat, résultat.racine, it)
    }

    saufsi page.fonte {
        TAILLE_POLICE_DÉFAUT :: 16.0

        page.fonte = crée_fonte(CheminFichier("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf"), TAILLE_POLICE_DÉFAUT)
    }

    imprime("Créé % noeud(s)\n", résultat.noeuds.taille)

    ctx: ContexteDisposition
    ctx.fonte = page.fonte

    mesure(racine, *ctx)

    imprime("taille arbre : %x%\n", résultat.racine.largeur, résultat.racine.hauteur)

    // imprime_arbre(résultat)

    page.arbre_de_disposition = résultat
    retourne résultat
}

imprime_arbre :: fonc (arbre: *ArbreDeDisposition)
{
    saufsi arbre.racine {
        retourne
    }

    enchaineuse: Enchaineuse
    initialise_enchaineuse(*enchaineuse)
    diffère détruit_tampons(*enchaineuse)

    imprime_arbre(*enchaineuse, arbre.racine, 0)

    résultat := chaine_depuis_enchaineuse(*enchaineuse)
    diffère déloge(résultat)

    imprime("%\n", résultat)
}

imprime_arbre :: fonc (enchaineuse: *Enchaineuse, racine: *NoeudDeDisposition, profondeur: n32)
{
    indentation := donne_chaine_indentation(profondeur comme z32)

    imprime_dans_enchaineuse(enchaineuse, "%%", indentation, racine.donne_nom_classe())
    si racine.type == NoeudDeDispositionBloc {
        bloc := racine comme *NoeudDeDispositionBloc
        imprime_dans_enchaineuse(enchaineuse, " %", bloc.élément.texte)
    }

    imprime_dans_enchaineuse(enchaineuse, " % % %x%\n", racine.position_x, racine.position_y, racine.largeur, racine.hauteur)

    pour racine.enfants {
        imprime_arbre(enchaineuse, it, profondeur + 1)
    }
}

crée_noeud_pour_élément :: fonc (arbre: *ArbreDeDisposition, parent: *NoeudDeDisposition, noeud: *Noeud)
{
    si noeud.est_texte() {
        résultat := arbre.crée_noeud(NoeudDeDispositionTexte)
        résultat.noeud_texte = noeud comme *NoeudTexte
        parent.ajoute_enfant(résultat)
        retourne
    }

    résultat := arbre.crée_noeud(NoeudDeDispositionBloc)
    résultat.élément = noeud comme *Élément
    parent.ajoute_enfant(résultat)

    pour noeud.enfants {
        si est_display_none(it) {
            continue
        }

        crée_noeud_pour_élément(arbre, résultat, it)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom RappelsInterface
 * \{ */

RappelsInterface :: struct {
    sur_lancement_requête: fonc(*RappelsInterface, *Requête)(rien)
    sur_spin_event_loop: fonc(*RappelsInterface)(rien)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ChargeuseRessource
 * \{ */

ChargeuseRessource :: struct {
    ressources_en_chargement: [..]*Ressource
    rappels_interface: *RappelsInterface
}

charge_ressource :: fonc (chargeuse: *ChargeuseRessource, ressource: *Ressource, async: bool)
{
    si est_fichier(ressource) {
        contenu := contenu_fichier_texte(ressource.uri.chemin)
        ressource_fut_chargée(ressource, contenu)
        retourne
    }

    requête := loge(Requête)
    requête.ressource = ressource
    lance_requête(chargeuse, requête)

    saufsi async {
        tantque !ressource.chargement_terminé {
            spin_event_loop(chargeuse)
        }
    }
}

lance_requête :: fonc (chargeuse: *ChargeuseRessource, requête: *Requête)
{
    rappels := chargeuse.rappels_interface
    saufsi rappels && rappels.sur_lancement_requête {
        retourne
    }

    rappels.sur_lancement_requête(rappels, requête)
}

spin_event_loop :: fonc (chargeuse: *ChargeuseRessource)
{
    rappels := chargeuse.rappels_interface
    saufsi rappels && rappels.sur_spin_event_loop {
        retourne
    }

    rappels.sur_spin_event_loop(rappels)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Ressource
 * \{ */

Ressource :: struct {
    sur_chargement: fonc(*Ressource, chaine)(rien)
    sur_erreur: fonc(*Ressource)(rien)

    uri: URI
    type: chaine // application/javascript, text/html, etc.

    chargement_terminé := faux

    fenêtre: *QT_Fenetre_Principale
}

crée_ressource_pour_chargement_page_web :: fonc (fenêtre: *QT_Fenetre_Principale, chemin: chaine) -> *Ressource
{
    sur_chargement :: fonc (ressource: *Ressource, données: chaine)
    {
        page_web := crée_page_web(ressource.uri, données)
        crée_widget_pour_page(ressource.fenêtre, page_web)
    }

    résultat := loge(Ressource)
    résultat.sur_chargement = sur_chargement
    résultat.type = "text/html"
    résultat.fenêtre = fenêtre

    si est_un_fichier_régulier(CheminFichier(chemin)) {
        uri: URI
        uri.schéma = "file"
        uri.schéma_est_défini = vrai
        uri.autorité_est_définie = vrai
        uri.chemin = chemin
        résultat.uri = uri
    }
    sinon {
        résultat.uri = tente parse_uri_standard(chemin) piège nonatteignable
    }

    retourne résultat
}

est_fichier :: fonc (ressource: *Ressource) -> bool
{
    uri := ressource.uri

    si uri.schéma == "file" {
        retourne vrai
    }

    retourne faux
}

ressource_fut_chargée :: fonc (ressource: *Ressource, données: chaine)
{
    si ressource.sur_chargement {
        ressource.sur_chargement(ressource, données)
    }

    ressource.chargement_terminé = vrai
}

ressource_eu_erreur :: fonc (ressource: *Ressource)
{
    si ressource.sur_erreur {
        ressource.sur_erreur(ressource)
    }

    ressource.chargement_terminé = vrai
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Requête
 * \{ */

Requête :: struct {
    ressource: *Ressource
    message: MessageServeuseHTTP
}

est_http :: fonc (requête: *Requête) -> bool
{
    assert(requête.ressource != nul)
    retourne requête.ressource.uri.schéma == "http"
}

est_https :: fonc (requête: *Requête) -> bool
{
    assert(requête.ressource != nul)
    retourne requête.ressource.uri.schéma == "https"
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom RappelsInterfaceQt
 * \{ */

RappelsInterfaceQt :: struct {
    empl base: RappelsInterface
    fenêtre: *QT_Fenetre_Principale
}

crée_rappels_interface_qt :: fonc (fenêtre: *QT_Fenetre_Principale) -> *RappelsInterfaceQt
{
    résultat := loge(RappelsInterfaceQt)
    résultat.fenêtre = fenêtre
    résultat.sur_lancement_requête = rappels_interface_sur_lancement_requête
    résultat.sur_spin_event_loop = rappels_interface_sur_spin_event_loop
    retourne résultat
}

rappels_interface_sur_lancement_requête :: fonc (base: *RappelsInterface, requête: *Requête)
{
    rappels := base comme *RappelsInterfaceQt

    rappels_socket := crée_rappel_socket_pour_requête(requête)

    parent := rappels.fenêtre

    uri := requête.ressource.uri
    hôte := uri.hôte
    port := port_pour_uri(uri)

    si requête.est_http() {
        prise := QT_cree_ssl_socket_rappels(parent, rappels_socket)
        QT_abstract_socket_connect_to_host(prise, hôte.vers_qt(), port)
    }
    sinon {
        assert(requête.est_https())
        prise := QT_cree_ssl_socket_rappels(parent, rappels_socket)
        QT_ssl_socket_connect_to_host_encrypted(prise, hôte.vers_qt(), port)
    }
}

crée_rappel_socket_pour_requête :: fonc (requête: *Requête) -> *QT_Rappels_Socket
{
    RappelsRequête :: struct {
        empl base: QT_Rappels_Socket

        requête: *Requête
        parseuse: ParseuseMessageServeuseHTTP

        temps_parsage_http: z64
        début_requête: Instantané
    }

    sur_connexion :: fonc (base: *QT_Rappels_Socket)
    {
        rappels := base comme *RappelsRequête

        rappels.début_requête = maintenant_précis()

        enchaineuse: Enchaineuse
        initialise_enchaineuse(*enchaineuse)
        diffère détruit_tampons(*enchaineuse)

        uri := rappels.requête.ressource.uri

        ajoute_au_tampon(*enchaineuse, "GET ")
        si uri.chemin {
            ajoute_au_tampon(*enchaineuse, uri.chemin)
        }
        sinon {
            ajoute_au_tampon(*enchaineuse, "/")
        }
        si uri.requête {
            ajoute_au_tampon(*enchaineuse, "?")
            ajoute_au_tampon(*enchaineuse, uri.requête)
        }

        ajoute_au_tampon(*enchaineuse, " HTTP/1.1\r\n")
        ajoute_au_tampon(*enchaineuse, "Host: ")
        ajoute_au_tampon(*enchaineuse, uri.hôte)
        ajoute_au_tampon(*enchaineuse, "\r\n")
        ajoute_au_tampon(*enchaineuse, "Accept-Encoding: identity\r\n")
        ajoute_au_tampon(*enchaineuse, "Accept-Charset: utf-8, iso-8859-1q=0.5\r\n")
        ajoute_au_tampon(*enchaineuse, "Accept: text/html,application/xhtml+xml,application/xmlq=0.9,image/webp,image/apng,*/ *q=0.8\r\n")
        ajoute_au_tampon(*enchaineuse, "User-Agent: delsace\r\n")
        ajoute_au_tampon(*enchaineuse, "Connection: close\r\n")
        ajoute_au_tampon(*enchaineuse, "\r\n")

        texte_requête := chaine_depuis_enchaineuse(*enchaineuse)
        diffère déloge(texte_requête)

        _ := QT_abstract_socket_write(rappels.socket, texte_requête.pointeur, texte_requête.taille)
        // imprime("Écris : % / %\n", écris, texte_requête.taille)
    }

    sur_erreur :: fonc (base: *QT_Rappels_Socket)
    {
        rappels := base comme *RappelsRequête
        imprime("Erreur\n")
        ressource_eu_erreur(rappels.requête.ressource)
    }

    sur_prêt_à_lire :: fonc (base: *QT_Rappels_Socket)
    {
        rappels := base comme *RappelsRequête
        parseuse := *rappels.parseuse
        requête := rappels.requête

        enchaineuse: Enchaineuse
        initialise_enchaineuse(*enchaineuse)
        diffère détruit_tampons(*enchaineuse)

        octets_lu := QT_abstract_socket_read(rappels.socket, *enchaineuse.tampon_courant.données[0], TAILLE_TAMPON_ENCHAINEUSE)

        enchaineuse.tampon_courant.occupé = octets_lu comme z32

        lu := chaine_depuis_enchaineuse(*enchaineuse)

        début_parsage_http := maintenant_précis()
        ajourne_données(parseuse, lu)
        rappels.temps_parsage_http += début_parsage_http.temps_écoulé_microsecondes()

        si message_est_erroné(parseuse) {
            imprime("Erreur de parsage")
            QT_abstract_socket_close(rappels.socket)
            retourne
        }

        saufsi message_prêt_pour_finalisation(parseuse) {
            retourne
        }

        imprime("Temps de parsage HTTP : %\n", rappels.temps_parsage_http)
        imprime("Temps requête         : %\n", rappels.début_requête.temps_écoulé_microsecondes())

        message := finalise_message(parseuse)

        content_type := entête(*message, "Content-Type")
        si content_type {
            // imprime("Content-Type : %\n", content_type.valeur)

            position_charset := cherche_aiguille_par_force_brute(content_type.valeur, "charset=")
            si position_charset != -1 {
                charset := avance(content_type.valeur, position_charset + "charset=".taille)

                si charset == "ISO-8859-1" {
                    nouveau_contenu := convertis_iso_8859_1_vers_utf8(message.contenu)
                    déloge(message.contenu)
                    message.contenu = nouveau_contenu
                }
            }
        }

        requête.message = message
        ressource_fut_chargée(requête.ressource, message.contenu)

        réinitialise(parseuse)

        QT_abstract_socket_close(rappels.socket)
    }

    rappels := loge(RappelsRequête)
    rappels.requête = requête
    rappels.sur_pret_a_lire = sur_prêt_à_lire
    rappels.sur_connexion = sur_connexion
    rappels.sur_erreur = sur_erreur
    retourne rappels
}

rappels_interface_sur_spin_event_loop :: fonc (base: *RappelsInterface @inutilisée)
{
    QT_application_process_events()
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Conversion jeu de caractères.
 * \{ */

/* https://www.charset.org/charsets/iso-8859-1 */
convertis_iso_8859_1_vers_utf8 :: fonc (texte: chaine) -> chaine
{
    taille_résultat := texte.taille

    pour texte {
        si it < 0 {
            taille_résultat += 1
        }
    }

    si taille_résultat == texte.taille {
        retourne copie_chaine(texte)
    }

    résultat := loge_chaine(taille_résultat)

    ptr_sortie := résultat.pointeur comme *n8

    pour texte {
        si it >= 0 {
            mémoire(ptr_sortie) = it comme n8
            ptr_sortie += 1
            continue
        }

        naturel := it comme n8

        si 0xA0 <= naturel <= 0xBF {
            mémoire(ptr_sortie) = 0xC2
            ptr_sortie += 1
            mémoire(ptr_sortie) = naturel
            ptr_sortie += 1
        }
        sinon si naturel >= 0xA0 {
            mémoire(ptr_sortie) = 0xC3
            ptr_sortie += 1
            mémoire(ptr_sortie) = naturel - 0x40
            ptr_sortie += 1
        }
        sinon {
            imprime("%\n", naturel)
            assert(faux)
        }
    }

    retourne résultat
}

/** \} */
