importe Allocatrices
importe Chaine
importe Couleur
importe #inemployé CSS
importe Fondation
importe Géométrie
importe HTML
importe HTTP
importe Internet
importe Math
importe OpenGL
importe PeintureInterface
importe Qt
importe SysFichier
importe Temps
importe Typographie

DÉBOGUE_ALLOCATIONS :: faux

/* ------------------------------------------------------------------------- */
/** \nom Fonction principale.
 * \{ */

allocatrice_gardée: AllocatriceGardée
contexte_entrée: ContexteProgramme

mon_logueur :: fonc (c: chaine, message: chaine @inutilisée, mode: ModeLogage @inutilisée, données: *rien @inutilisée)
{
    fichier := tente ouvre_fichier_crée_si_non_existant(CheminFichier("fuites_de_mémoire.txt"), pour_écriture_tronquée) piège _ {
        imprime("%\n", c)
        retourne
    }

    _ := écris(*fichier, c)
    _ := ferme(*fichier)
}

principale :: fonc () -> z32
{
    mémoire_entrée := mémoire_utilisée()

    /* Nous ne pouvons pas utiliser un nouveau contexte car la fonction principale
     * peut ne pas se terminer (lors des fermetures de fenêtres). */
    __contexte_fil_principal.logueur = mon_logueur
    contexte_entrée = __contexte_fil_principal

    #si DÉBOGUE_ALLOCATIONS {
        __contexte_fil_principal.allocatrice = allocation_gardée
        __contexte_fil_principal.données_allocatrice = *allocatrice_gardée
    }

    diffère {
        /* Restaure le contexte. */
        __contexte_fil_principal = contexte_entrée

        imprime("mémoire_utilisée %\n", mémoire_utilisée() - mémoire_entrée)

        #si DÉBOGUE_ALLOCATIONS {
            imprime_liste_mémoire(*allocatrice_gardée)
        }
    }

    arguments := __arguments_ligne_commande

    chemin_fichier: chaine
    si arguments.taille > 1 {
        arg1 := convertis_chaine_c_statique(ChaineC(arguments[1]))
        chemin_fichier = arg1
    }

    /* Création application. */
    taille_arguments := arguments.taille comme z32
    app := QT_cree_application(*taille_arguments, arguments.pointeur)
    diffère QT_detruit_application(app)

    rappel_fermeture: RappelFermetureApp
    rappel_fermeture.mémoire_entrée = mémoire_entrée
    QT_application_sur_fin_boucle_evenement(app, *rappel_fermeture)

    QT_core_application_definis_nom_organisation(vers_qt("delsace"))
    QT_core_application_definis_nom_application(vers_qt("HTML"))

    initialise_évènements_personnalisés()

    /* Création fenêtre. */
    rappels_fenêtre : RappelsFenetrePrincipale
    rappel_fermeture.rappels_fenêtre = *rappels_fenêtre

    fenêtre := QT_cree_fenetre_principale(*rappels_fenêtre)
    diffère QT_detruit_fenetre_principale(fenêtre)

    QT_widget_definis_titre_fenetre(fenêtre, vers_qt("HTML"))
    QT_widget_affiche_maximisee(fenêtre)

    rappels_user_agent := crée_rappels_interface_qt(fenêtre)
    définis_rappels_interface(*rappels_fenêtre.user_agent, rappels_user_agent)

    si chemin_fichier {
        évènement := loge(ÉvènementCréationOnglet)
        évènement.uri = chemin_fichier

        QT_application_poste_evenement_et_donnees(fenêtre, évènement_sur_création_onglet, évènement)
    }

    retourne QT_application_exec(app)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Évènements
 * \{ */

évènement_sur_création_onglet : z32 = -1
évènement_sur_survole_élément : z32 = -1
évènement_sur_requête_rendu : z32 = -1
évènement_sur_tâche_manipulation_dom : z32 = -1
évènement_sur_tâche_interaction_utilisateur : z32 = -1
évènement_sur_tâche_réseautage : z32 = -1
évènement_sur_tâche_navigation_et_traversée : z32 = -1
évènement_sur_tâche_rendu : z32 = -1

ÉvènementCréationOnglet :: struct {
    uri: chaine
}

initialise_évènements_personnalisés :: fonc ()
{
    évènement_sur_création_onglet = QT_enregistre_evenement_personnel()
    évènement_sur_survole_élément = QT_enregistre_evenement_personnel()
    évènement_sur_requête_rendu = QT_enregistre_evenement_personnel()
    évènement_sur_tâche_manipulation_dom = QT_enregistre_evenement_personnel()
    évènement_sur_tâche_interaction_utilisateur = QT_enregistre_evenement_personnel()
    évènement_sur_tâche_réseautage = QT_enregistre_evenement_personnel()
    évènement_sur_tâche_navigation_et_traversée = QT_enregistre_evenement_personnel()
    évènement_sur_tâche_rendu = QT_enregistre_evenement_personnel()
}

sur_filtre_evenement_impl :: fonc (base: *QT_Rappels_Fenetre_Principale, event: *QT_Evenement) -> z32
{
    type := QT_evenement_donne_type(event) comme n32 comme z32

    si type == évènement_sur_création_onglet {
        rappels := base comme *RappelsFenetrePrincipale

        message := QT_event_perso_donne_donnees(event) comme *ÉvènementCréationOnglet

        uri: URI

        si est_un_fichier_régulier(CheminFichier(message.uri)) {
            uri.schéma = "file"
            uri.schéma_est_défini = vrai
            uri.autorité_est_définie = vrai
            uri.chemin = message.uri
            uri = uri
        }
        sinon {
            uri = tente parse_uri_standard(message.uri) piège nonatteignable
        }

        navigable := crée_un_fresh_top_level_traversable(*rappels.user_agent, uri) comme *TraversableNavigable

        page_web := crée_page_web(uri, navigable)
        crée_widget_pour_page(rappels.fenetre, page_web)

        déloge(message)

        QT_evenement_accepte(event)
        retourne 1
    }

    si type == évènement_sur_survole_élément {
        rappels := base comme *RappelsFenetrePrincipale
        document := donne_document(*rappels.page_web)

        /* Restaure toujours le curseur pour éviter d'être bloqué avec un curseur quand
         * nous passons d'un élément à un autre ayant le même curseur : ceci empilera un
         * nouveau curseur et une restauration suivante nous renverraient sur le curseur
         * du premier élément. */
        QT_gui_application_restaure_curseur()

        élément := document.noeud_survolé
        si élément && élément.noeud_de_disposition {
            curseur_qt := curseur_qt_depuis_css(CSS.donne_curseur(élément.noeud_de_disposition))
            QT_gui_application_definis_curseur(curseur_qt)
        }

        QT_evenement_accepte(event)
        retourne 1
    }

    si type == évènement_sur_requête_rendu {
        rappels := base comme *RappelsFenetrePrincipale
        QT_widget_ajourne(rappels.widget_rendu)
        QT_evenement_accepte(event)
        retourne 1
    }

    si type == évènement_sur_tâche_manipulation_dom ||
       type == évènement_sur_tâche_interaction_utilisateur ||
       type == évènement_sur_tâche_réseautage ||
       type == évènement_sur_tâche_navigation_et_traversée ||
       type == évènement_sur_tâche_rendu {
        algorithm := QT_event_perso_donne_donnees(event) comme *Algorithm
        algorithm.run()
        QT_evenement_accepte(event)
        retourne 1
    }

    retourne 0
}

curseur_qt_depuis_css :: fonc (type: CSS.CursorType) -> QT_CursorShape
{
    discr type {
        auto,
        default {
            retourne QT_CursorShape.ARROW
        }
        none {
            retourne QT_CursorShape.BLANK
        }
        context_menu {
            retourne QT_CursorShape.ARROW
        }
        help {
            retourne QT_CursorShape.WHATS_THIS
        }
        pointer {
            retourne QT_CursorShape.POINTING_HAND
        }
        progress {
            retourne QT_CursorShape.BUSY
        }
        wait {
            retourne QT_CursorShape.WAIT
        }
        cell {
            retourne QT_CursorShape.ARROW
        }
        crosshair {
            retourne QT_CursorShape.CROSS
        }
        text {
            retourne QT_CursorShape.IBEAM
        }
        vertical_text {
            retourne QT_CursorShape.ARROW
        }
        alias {
            retourne QT_CursorShape.ARROW
        }
        copy {
            retourne QT_CursorShape.ARROW
        }
        move {
            retourne QT_CursorShape.ARROW
        }
        no_drop {
            retourne QT_CursorShape.ARROW
        }
        not_allowed {
            retourne QT_CursorShape.FORBIDDEN
        }
        grab {
            retourne QT_CursorShape.OPEN_HAND
        }
        grabbing {
            retourne QT_CursorShape.DRAG_MOVE
        }
        e_resize {
            retourne QT_CursorShape.ARROW
        }
        n_resize {
            retourne QT_CursorShape.ARROW
        }
        ne_resize {
            retourne QT_CursorShape.ARROW
        }
        nw_resize {
            retourne QT_CursorShape.ARROW
        }
        s_resize {
            retourne QT_CursorShape.ARROW
        }
        se_resize {
            retourne QT_CursorShape.ARROW
        }
        sw_resize {
            retourne QT_CursorShape.ARROW
        }
        w_resize {
            retourne QT_CursorShape.ARROW
        }
        ew_resize {
            retourne QT_CursorShape.SIZE_HORIZONTAL
        }
        ns_resize {
            retourne QT_CursorShape.SIZE_VERTICAL
        }
        nesw_resize {
            retourne QT_CursorShape.ARROW
        }
        nwse_resize {
            retourne QT_CursorShape.ARROW
        }
        col_resize {
            retourne QT_CursorShape.ARROW
        }
        row_resize {
            retourne QT_CursorShape.ARROW
        }
        all_scroll {
            retourne QT_CursorShape.ARROW
        }
        zoom_in {
            retourne QT_CursorShape.ARROW
        }
        zoom_out {
            retourne QT_CursorShape.ARROW
        }
    }

    retourne QT_CursorShape.ARROW
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Sur fermeture application.
 * \{ */

RappelFermetureApp :: struct {
    empl base: QT_Rappel_Generique

    rappels_fenêtre: *RappelsFenetrePrincipale
    mémoire_entrée: z64

    sur_rappel = sur_fermeture_application
}

sur_fermeture_application :: fonc (base: *QT_Rappel_Generique)
{    
    rappel := base comme *RappelFermetureApp
    détruit_données_page_web(*rappel.rappels_fenêtre.page_web)
    détruit_données_user_agent(*rappel.rappels_fenêtre.user_agent)
    détruit_table_chaines_utf16_uniques()
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom PageWeb
 * \{ */

BarreDeDéfilement :: struct {
    rect: RectanglePosDim(r32)
    est_cliqué: bool
    est_survolé: bool
    pos_clique_y: r32
    hauteur: r32
    ratio: r32 = 1.0
}

décale_par :: fonc (barre: *BarreDeDéfilement, delta: r32)
{
    barre.rect.y += delta

    si barre.rect.y < 0.0 {
        barre.rect.y = 0.0
    }
    sinon si (barre.rect.y + barre.rect.hauteur) > barre.hauteur {
        barre.rect.y = barre.hauteur - barre.rect.hauteur
    }
}

PageWeb :: struct {
    uri: URI
    parsat: ParsatHTML
    navigable: *Navigable
    contenu: chaine
    fonte: *Fonte

    défilement_vertical: BarreDeDéfilement
}

crée_page_web :: fonc (uri: &URI, contenu: chaine) -> PageWeb
{
    résultat: PageWeb
    résultat.uri = uri
    résultat.contenu = contenu
    résultat.parsat = parse_document(contenu)
    imprime("Temps de parsage : %\n", résultat.parsat.temps)
    retourne résultat
}

crée_page_web :: fonc (uri: &URI, navigable: *Navigable) -> PageWeb
{
    résultat: PageWeb
    résultat.uri = uri
    résultat.navigable = navigable
    retourne résultat
}

donne_document :: fonc (page: *PageWeb) -> *Document
{
    si page.navigable {
        retourne page.navigable.donne_active_document()
    }
    retourne page.parsat.document
}

détruit_données_page_web :: fonc (page: *PageWeb)
{
    détruit(page.parsat)
    si page.fonte {
        détruit_fonte(page.fonte)
    }
    déloge(page.contenu)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Données fenêtre principale.
 * \{ */

RappelsFenetrePrincipale :: struct {
    empl base : QT_Rappels_Fenetre_Principale

    user_agent: UserAgent

    page_web: PageWeb
    widget_rendu: *QT_GLWidget
    widget_arbre_de_dispostion: *QT_TreeWidget

    /* Données rappels. */
    sur_filtre_evenement = sur_filtre_evenement_impl
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Widget page.
 * \{ */

crée_widget_pour_page :: fonc (fenêtre: *QT_Fenetre_Principale, page_web: PageWeb)
{
    rappels := QT_fenetre_principale_donne_rappels(fenêtre) comme *RappelsFenetrePrincipale
    rappels.page_web = page_web

    tabs := QT_cree_tab_widget(nul, fenêtre)
    QT_tab_widget_definis_tabs_fermable(tabs, 0)

    widget_rendu := crée_widget_pour_rendu(fenêtre, tabs)
    QT_tab_widget_ajoute_tab(tabs, widget_rendu, "Rendu")
    rappels.widget_rendu = widget_rendu

    widget_source := crée_widget_vue_source(fenêtre, tabs)
    QT_tab_widget_ajoute_tab(tabs, widget_source, "Source")

    widget_arbre := crée_widget_arbre_pour_dom(fenêtre, tabs)
    QT_tab_widget_ajoute_tab(tabs, widget_arbre, "DOM")

    widget_texte := crée_widget_vue_texte(fenêtre, tabs)
    QT_tab_widget_ajoute_tab(tabs, widget_texte, "Texte")

    widget_arbre_disposition := crée_widget_vue_arbre_de_disposition(fenêtre, tabs)
    QT_tab_widget_ajoute_tab(tabs, widget_arbre_disposition, "Arbre de Disposition")

    QT_fenetre_principale_definis_widget_central(fenêtre, tabs)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ÉditriceArborescence
 * \{ */

WidgetArbre :: struct {
    empl base: QT_Rappels_TreeWidget
}

crée_widget_arbre :: fonc (rappels: *QT_Rappels_TreeWidget, parent: QT_Generic_Widget) -> *QT_TreeWidget
{
    résultat := QT_cree_treewidget(rappels, parent)

    QT_treewidget_definis_taille_icone(résultat, 20, 20)
    QT_treewidget_definis_toutes_les_colonnes_montre_focus(résultat, 1)
    QT_treewidget_definis_anime(résultat, 0)
    QT_treewidget_definis_auto_defilement(résultat, 0)
    QT_treewidget_definis_hauteurs_uniformes_lignes(résultat, 1)
    QT_treewidget_definis_mode_selection(résultat, QT_Mode_Selection.SELECTION_UNIQUE)
    QT_treewidget_definis_mode_drag_drop(résultat, QT_Mode_DragDrop.AUCUN_DRAG_DROP)
    QT_treewidget_definis_activation_drag(résultat, 0)
    QT_treewidget_definis_comportement_focus(résultat, QT_Comportement_Focus.AUCUN_FOCUS)
    QT_treewidget_definis_comportement_menu_contextuel(résultat, QT_Comportement_Menu_Contextuel.MENU_PERSONNALISE)
    QT_treewidget_definis_entete_visible(résultat, 1)

    retourne résultat
}

RappelsArborescence :: struct {
    empl base: QT_Rappels_TreeWidget

    fenêtre_principale: *QT_Fenetre_Principale
}

initialise_rappels_arborescence :: fonc (fenêtre_principale: *QT_Fenetre_Principale) -> RappelsArborescence
{
    // sur_changement_item_courant :: fonc (rappels: *QT_Rappels_TreeWidget, courant: *QT_TreeWidgetItem, précédent: *QT_TreeWidgetItem @inutilisée)
    // {
    //     rappels_arborescence := rappels comme *RappelsArborescence
    //     données := QT_treewidgetitem_donne_donnees(courant)
    // }

    résultat: RappelsArborescence
    résultat.fenêtre_principale = fenêtre_principale
    résultat.sur_changement_item_courant = sur_changement_item_courant
    retourne résultat
}

crée_widget_arbre_pour_dom :: fonc (fenêtre: *QT_Fenetre_Principale, parent: QT_Generic_Widget) -> *QT_TreeWidget
{
    rappels := QT_fenetre_principale_donne_rappels(fenêtre) comme *RappelsFenetrePrincipale

    résultat := crée_widget_arbre(nul, parent)

    document := donne_document(*rappels.page_web)
    si document {
        titre := document.donne_title_element()
        si titre {
            texte_titre := donne_contenu_texte_descandants(titre)
            diffère détruit_chaine(texte_titre)

            texte_filtré := supprime_espace_blanches_autour(texte_titre)
            diffère détruit_chaine(texte_filtré)

            texte_natif := converti_vers_chaine(texte_filtré)
            diffère déloge(texte_natif)

            QT_widget_definis_titre_fenetre(fenêtre, vers_qt(texte_natif))
        }

        item_document := QT_cree_treewidgetitem(nul, nul)
        QT_treewidgetitem_definis_indicateur_enfant(item_document, QT_Indicateur_Enfant_Arbre.INVISIBLE_SI_SANS_ENFANT)
        texte := vers_qt("document")
        QT_treewidgetitem_definis_texte(item_document, 0, *texte)
        QT_treewidget_ajoute_item_racine(résultat, item_document)

        pour document.enfants {
            ajoute_item_pour_noeud(item_document, it)
        }
    }

    retourne résultat
}

ajoute_item_pour_noeud :: fonc (parent: *QT_TreeWidgetItem, noeud: *Noeud)
{
    texte := ""
    diffère déloge(texte)

    si noeud.est_élément() {
        élément := noeud comme *Élément

        enchaineuse: Enchaineuse
        initialise_enchaineuse(*enchaineuse)
        diffère détruit_tampons(*enchaineuse)

        ajoute_au_tampon(*enchaineuse, "<", élément.local_name)

        pour noeud.attributs {
            ajoute_au_tampon(*enchaineuse, " ", it.nom, "=\"", it.valeur, "\"")
        }

        ajoute_au_tampon(*enchaineuse, ">")

        texte = chaine_depuis_enchaineuse(*enchaineuse)
    }
    sinon {
        si noeud.est_texte() {
            noeud_texte := noeud comme *NoeudTexte
            si est_espace_blanche_entre_élément(noeud_texte) {
                retourne
            }
        }

        texte = imprime_chaine("%", noeud.genre)
    }

    item_noeud := QT_cree_treewidgetitem(nul, nul)
    QT_treewidgetitem_definis_indicateur_enfant(item_noeud, QT_Indicateur_Enfant_Arbre.INVISIBLE_SI_SANS_ENFANT)
    qtexte := vers_qt(texte)
    QT_treewidgetitem_definis_texte(item_noeud, 0, *qtexte)

    QT_treewidgetitem_ajoute_enfant(parent, item_noeud)

    pour noeud.enfants {
        ajoute_item_pour_noeud(item_noeud, it)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom VueSource
 * \{ */

crée_widget_vue_source :: fonc (fenêtre: *QT_Fenetre_Principale, parent: QT_Generic_Widget) -> *QT_PlainTextEdit
{
    rappels := QT_fenetre_principale_donne_rappels(fenêtre) comme *RappelsFenetrePrincipale
    contenu := rappels.page_web.contenu

    résultat := QT_cree_plain_text_edit(nul, parent)
    QT_plain_text_edit_definis_lecture_seule(résultat, vrai)
    QT_plain_text_edit_definis_mode_retour_ligne(résultat, QT_Line_Wrap_Mode.AUCUN)
    QT_plain_text_edit_definis_texte(résultat, contenu)
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom VueSource
 * \{ */

crée_widget_vue_texte :: fonc (fenêtre: *QT_Fenetre_Principale, parent: QT_Generic_Widget) -> *QT_PlainTextEdit
{
    rappels := QT_fenetre_principale_donne_rappels(fenêtre) comme *RappelsFenetrePrincipale
    document := donne_document(*rappels.page_web)

    résultat := QT_cree_plain_text_edit(nul, parent)
    QT_plain_text_edit_definis_lecture_seule(résultat, vrai)
    QT_plain_text_edit_definis_mode_retour_ligne(résultat, QT_Line_Wrap_Mode.AUCUN)
    si document {
        body := document.donne_élément_body()
        si body {
            texte := extrait_texte_noeud(body)
            diffère déloge(texte)
            QT_plain_text_edit_definis_texte(résultat, texte)
        }
    }
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Vue arbre de disposition
 * \{ */

crée_widget_vue_arbre_de_disposition :: fonc (fenêtre: *QT_Fenetre_Principale, parent: QT_Generic_Widget) -> *QT_TreeWidget
{
    rappels := QT_fenetre_principale_donne_rappels(fenêtre) comme *RappelsFenetrePrincipale

    résultat := crée_widget_arbre(nul, parent)
    rappels.widget_arbre_de_dispostion = résultat
    ajourne_widget_arbre_de_disposition(rappels)
    retourne résultat
}

ajourne_widget_arbre_de_disposition :: fonc (rappels: *RappelsFenetrePrincipale)
{
    QT_treewidget_efface(rappels.widget_arbre_de_dispostion)

    document := donne_document(*rappels.page_web)
    saufsi document {
        retourne
    }

    arbre := document.arbre_de_disposition
    saufsi arbre {
        retourne
    }

    widget := rappels.widget_arbre_de_dispostion

    item_document := QT_cree_treewidgetitem(nul, nul)
    QT_treewidgetitem_definis_indicateur_enfant(item_document, QT_Indicateur_Enfant_Arbre.INVISIBLE_SI_SANS_ENFANT)
    texte := donne_texte_item_pour_noeud(arbre.racine)
    diffère déloge_si_logée(texte)
    qtexte := vers_qt(texte)
    QT_treewidgetitem_definis_texte(item_document, 0, *qtexte)
    QT_treewidget_ajoute_item_racine(widget, item_document)

    pour arbre.racine.enfants {
        ajoute_item_pour_noeud(item_document, it)
    }
}

ajoute_item_pour_noeud :: fonc (parent: *QT_TreeWidgetItem, noeud: *CSS.NoeudDeDisposition)
{
    item_noeud := QT_cree_treewidgetitem(nul, nul)
    QT_treewidgetitem_definis_indicateur_enfant(item_noeud, QT_Indicateur_Enfant_Arbre.INVISIBLE_SI_SANS_ENFANT)
    texte := donne_texte_item_pour_noeud(noeud)
    diffère déloge_si_logée(texte)
    qtexte := vers_qt(texte)
    QT_treewidgetitem_definis_texte(item_noeud, 0, *qtexte)

    QT_treewidgetitem_ajoute_enfant(parent, item_noeud)

    pour noeud.enfants {
        ajoute_item_pour_noeud(item_noeud, it)
    }
}

donne_texte_item_pour_noeud :: fonc (noeud: *CSS.NoeudDeDisposition) -> chaine
{
    si noeud.type == CSS.NoeudDeDispositionTexte {
        retourne "texte"
    }

    si noeud.type == CSS.NoeudDeDispositionNouvelleLigne {
        retourne "<br/>"
    }

    noeud_bloc := noeud comme *CSS.NoeudDeDispositionBloc
    retourne imprime_chaine("% (%) [%x%] [%x%]", CSS.donne_nom_classe(noeud), noeud_bloc.élément.local_name, noeud.position_x, noeud.position_y, noeud.largeur, noeud.hauteur)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom VueRendu
 * \{ */

crée_widget_pour_rendu :: fonc (fenêtre: *QT_Fenetre_Principale, parent: QT_Generic_Widget) -> *QT_GLWidget
{
    rappels := QT_fenetre_principale_donne_rappels(fenêtre) comme *RappelsFenetrePrincipale
    résultat := crée_vue_rendu_page(fenêtre, parent, *rappels.page_web)
    retourne résultat
}

VueRenduPage :: struct {
    empl base: QT_Rappels_GLWidget

    sur_destruction = vue_rendu_page_sur_destruction
    sur_initialisation_gl = vue_rendu_page_sur_initialisation
    sur_peinture_gl = vue_rendu_page_sur_peinture
    sur_redimensionnement_gl = vue_rendu_page_sur_redimensionnement
    sur_deplacement_souris = vue_rendu_page_sur_déplacement_souris
    sur_pression_souris = vue_rendu_page_sur_pression_souris
    sur_relachement_souris = vue_rendu_page_sur_relachement_souris
    sur_molette_souris = vue_rendu_page_sur_molette_souris

    fenêtre_principale: *QT_Fenetre_Principale
    page: *PageWeb

    hauteur: z32
    largeur: z32

    peintre: *Peintre
}

crée_vue_rendu_page :: fonc (fenêtre_principale: *QT_Fenetre_Principale, parent: QT_Generic_Widget, page: *PageWeb) -> *QT_GLWidget
{
    rappels := loge(VueRenduPage)
    rappels.page = page
    rappels.fenêtre_principale = fenêtre_principale
    résultat := QT_cree_glwidget(rappels, parent)
    QT_widget_definis_trackage_souris(résultat, vrai)
    retourne résultat
}

vue_rendu_page_sur_destruction :: fonc (rappels: *QT_Rappels_GLWidget)
{
    vue_rendu_page := rappels comme *VueRenduPage
    si vue_rendu_page.peintre {
        détruit_peintre_igumi(vue_rendu_page.peintre)
    }
    déloge(vue_rendu_page)
}

vue_rendu_page_sur_initialisation :: fonc (base: *QT_Rappels_GLWidget @inutilisée)
{
    glewExperimental = 1
    erreur_ := glewInit()

    si erreur_ != 0 {
        imprime("Erreur lors de l'initilisation de GLEW !\n")
        retourne
    }
}

vue_rendu_page_sur_peinture :: fonc (base: *QT_Rappels_GLWidget)
{
    vue_rendu_page := base comme *VueRenduPage

    taille_cannevas := Taille(largeur = Largeur(vue_rendu_page.largeur), hauteur = Hauteur(vue_rendu_page.hauteur))

    saufsi vue_rendu_page.peintre {
        vue_rendu_page.peintre = crée_peintre_igumi(taille_cannevas)
    }

    peintre := vue_rendu_page.peintre
    peintre.définis_taille_cannevas(taille_cannevas)

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    glClearColor(1.0, 1.0, 1.0, 1.0)

    ancien_arbre := donne_arbre_de_disposition(vue_rendu_page.page)

    arbre := crée_arbre_de_disposition(vue_rendu_page.page, vue_rendu_page.largeur, vue_rendu_page.hauteur)
    saufsi arbre && arbre.racine {
        retourne
    }

    si ancien_arbre != arbre {
        rappels := QT_fenetre_principale_donne_rappels(vue_rendu_page.fenêtre_principale) comme *RappelsFenetrePrincipale
        ajourne_widget_arbre_de_disposition(rappels)
    }

    page := vue_rendu_page.page
    document := donne_document(page)

    ctx: CSS.ContexteDessin
    ctx.globales = document.globales_dessin
    ctx.peintre = peintre
    ctx.hauteur_vue = vue_rendu_page.hauteur
    ctx.largeur_vue = vue_rendu_page.largeur

    racine := arbre.racine
    si racine.hauteur > vue_rendu_page.hauteur comme n32 {
        ctx.décalage_y = page.défilement_vertical.rect.y / page.défilement_vertical.ratio
    }

    // début_rendu := maintenant_précis()

    CSS.dessine(arbre, *ctx)

    // imprime("temps de rendu : %\n", début_rendu.temps_écoulé_millisecondes())

    si racine.hauteur > vue_rendu_page.hauteur comme n32 {
        hauteur_vue := vue_rendu_page.hauteur comme r32
        hauteur_page := racine.hauteur comme r32

        largeur_barre := 12.0
        hauteur_barre := hauteur_vue * hauteur_vue / hauteur_page
        page.défilement_vertical.ratio = hauteur_vue / hauteur_page

        rect_barre: RectanglePosDim(r32)
        si page.défilement_vertical.rect.largeur == 0.0 {
            rect_barre.x = vue_rendu_page.largeur comme r32 - largeur_barre
            rect_barre.largeur = largeur_barre
            rect_barre.y = 0.0
            rect_barre.hauteur = hauteur_barre

            page.défilement_vertical.rect = rect_barre
        }
        sinon {
            rect_barre = page.défilement_vertical.rect
        }

        couleur := CouleurRVBA(1.0, 0.5, 0.5, 0.5)

        si page.défilement_vertical.est_cliqué || page.défilement_vertical.est_survolé {
            couleur.r *= 0.5
            couleur.v *= 0.5
            couleur.b *= 0.5
        }

        /* Change la position pour le dessin qui commence du bas. */
        rect_barre.y = hauteur_vue - hauteur_barre - page.défilement_vertical.rect.y

        peintre.remplis_rectangle(rect_barre, couleur)
    }
}

vue_rendu_page_sur_redimensionnement :: fonc (rappels: *QT_Rappels_GLWidget, taille: QT_Taille)
{
    vue_rendu_page := rappels comme *VueRenduPage
    vue_rendu_page.largeur = taille.largeur
    vue_rendu_page.hauteur = taille.hauteur

    page := vue_rendu_page.page
    document := donne_document(page)
    si document {
        document.invalide_style_pour_redimensionnement()
    }
    /* Réinitialise la barre de défilement. */
    page.défilement_vertical.rect.largeur = 0.0
    page.défilement_vertical.ratio = 1.0
    page.défilement_vertical.hauteur = vue_rendu_page.hauteur comme r32
}

vue_rendu_page_sur_déplacement_souris :: fonc (base: *QT_Rappels_GLWidget, event: *QT_MouseEvent)
{
    vue_rendu_page := base comme *VueRenduPage

    document := donne_document(vue_rendu_page.page)
    saufsi document {
        retourne
    }

    arbre := document.arbre_de_disposition
    saufsi arbre {
        retourne
    }

    position: QT_Position
    QT_mouse_event_donne_position(event, *position)

    élément := CSS.donne_élément_pour_position(arbre, position.x, position.y)
    document.définis_noeud_survolé(élément)

    défilement := *vue_rendu_page.page.défilement_vertical

    si défilement.est_cliqué {
        décalage := position.y comme r32 - défilement.pos_clique_y
        défilement.pos_clique_y = position.y comme r32
        défilement.décale_par(décalage)
        QT_widget_ajourne(vue_rendu_page.widget)
    }
    sinon si défilement.rect.contient(position.x comme r32, position.y comme r32) {
        saufsi défilement.est_survolé {
            défilement.est_survolé = vrai
            QT_widget_ajourne(vue_rendu_page.widget)
        }
    }
    sinon si défilement.est_survolé {
        défilement.est_survolé = faux
        QT_widget_ajourne(vue_rendu_page.widget)
    }
}

vue_rendu_page_sur_pression_souris :: fonc (base: *QT_Rappels_GLWidget, event: *QT_MouseEvent)
{
    vue_rendu_page := base comme *VueRenduPage

    document := donne_document(vue_rendu_page.page)
    saufsi document {
        retourne
    }

    arbre := document.arbre_de_disposition
    saufsi arbre {
        retourne
    }

    position: QT_Position
    QT_mouse_event_donne_position(event, *position)

    si vue_rendu_page.page.défilement_vertical.est_survolé {
        vue_rendu_page.page.défilement_vertical.est_cliqué = vrai
        vue_rendu_page.page.défilement_vertical.pos_clique_y = position.y comme r32
        retourne
    }

    élément := CSS.donne_élément_pour_position(arbre, position.x, position.y)
    si élément {
        élément.est_en_train_d_être_activé(vrai)
    }
    document.élément_en_cours_d_activation = élément
}

vue_rendu_page_sur_relachement_souris :: fonc (base: *QT_Rappels_GLWidget, event: *QT_MouseEvent)
{
    vue_rendu_page := base comme *VueRenduPage

    document := donne_document(vue_rendu_page.page)
    saufsi document {
        retourne
    }

    arbre := document.arbre_de_disposition
    saufsi arbre {
        retourne
    }

    si vue_rendu_page.page.défilement_vertical.est_cliqué {
        vue_rendu_page.page.défilement_vertical.est_cliqué = faux
        retourne
    }

    position: QT_Position
    QT_mouse_event_donne_position(event, *position)

    élément := CSS.donne_élément_pour_position(arbre, position.x, position.y)
    si élément {
        élément.est_en_train_d_être_activé(faux)
    }
    si document.élément_en_cours_d_activation {
        si document.élément_en_cours_d_activation != élément {
            document.élément_en_cours_d_activation.est_en_train_d_être_activé(faux)
        }
        sinon {
            envoie_un_clic(élément)
        }
    }
    document.élément_en_cours_d_activation = nul
}

vue_rendu_page_sur_molette_souris :: fonc (base: *QT_Rappels_GLWidget, event: *QT_WheelEvent)
{
    vue_rendu_page := base comme *VueRenduPage

    document := donne_document(vue_rendu_page.page)
    saufsi document {
        retourne
    }

    arbre := document.arbre_de_disposition
    saufsi arbre {
        retourne
    }

    delta := QT_wheel_event_donne_delta(event)

    HAUTEURE_LIGNE :: 16.0
    NOMBRE_DE_LIGNES_PAR_ROULEMENT :: 5.0
    DÉCALAGE_PAR_ROULEMENT :: NOMBRE_DE_LIGNES_PAR_ROULEMENT * HAUTEURE_LIGNE

    si delta > 0 {
        décale_par(*vue_rendu_page.page.défilement_vertical, -DÉCALAGE_PAR_ROULEMENT)
    }
    sinon {
        décale_par(*vue_rendu_page.page.défilement_vertical, DÉCALAGE_PAR_ROULEMENT)
    }
    QT_widget_ajourne(vue_rendu_page.widget)
}

/* https://w3c.github.io/uievents/#send-click-event */
envoie_un_clic :: fonc (élément: *HTML.Élément)
{
    /* À FAIRE : standardise. */
    évènement := loge(HTML.Event)
    évènement.target = élément
    évènement.type = HTML.EventType.click

    _ := dispatch(évènement, élément)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Arbre de disposition
 * \{ */

donne_feuille_de_style_défaut :: fonc () -> *CSS.CSSStyleSheet
{
    contenu := contenu_fichier_texte("/home/kevin/defaults.css")
    diffère déloge(contenu)

    ctx: CSS.ContexteParsageFeuilleDeStyle
    diffère CSS.détruit_données_contexte(*ctx)

    stylesheet := CSS.parse_a_css_style_sheet(*ctx, contenu)
    CSS.rapporte_propriétés_non_supportées(*ctx, #nom_de_cette_fonction)

    retourne stylesheet
}

crée_arbre_de_disposition :: fonc (page: *PageWeb, largeur: z32, hauteur: z32) -> *CSS.ArbreDeDisposition
{
    document := donne_document(page)
    saufsi document {
        retourne nul
    }

    si document.arbre_de_disposition {
        retourne document.arbre_de_disposition
    }

    saufsi document.feuille_de_style_agent {
        document.feuille_de_style_agent = donne_feuille_de_style_défaut()
        tableau_insère_index(*document.feuilles_de_style, document.feuille_de_style_agent, 0)
    }
    CSS.crée_arbre_de_disposition(document, largeur, hauteur)
    retourne document.arbre_de_disposition
}

donne_arbre_de_disposition :: fonc (page: *PageWeb) -> *CSS.ArbreDeDisposition
{
    document := donne_document(page)
    saufsi document {
        retourne nul
    }

    retourne document.arbre_de_disposition
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom RappelsInterfaceQt
 * \{ */

RappelsInterfaceQt :: struct {
    empl base: RappelsInterface
    fenêtre: *QT_Fenetre_Principale
}

crée_rappels_interface_qt :: fonc (fenêtre: *QT_Fenetre_Principale) -> *RappelsInterfaceQt
{
    résultat := loge(RappelsInterfaceQt)
    résultat.fenêtre = fenêtre
    résultat.sur_destruction = rappels_interface_sur_destruction
    résultat.sur_élément_survolé = rappels_interface_sur_élément_survolé
    résultat.sur_requête_rendu = rappels_interface_sur_requête_rendu
    résultat.sur_lancement_requête = rappels_interface_sur_lancement_requête
    résultat.sur_spin_event_loop = rappels_interface_sur_spin_event_loop
    résultat.sur_enfile_une_tâche = rappels_interface_sur_enfile_une_tâche
    retourne résultat
}

rappels_interface_sur_destruction :: fonc (base: *RappelsInterface)
{
    rappels := base comme *RappelsInterfaceQt
    déloge(rappels)
}

rappels_interface_sur_élément_survolé :: fonc (base: *RappelsInterface)
{
    rappels := base comme *RappelsInterfaceQt
    QT_application_poste_evenement(rappels.fenêtre, évènement_sur_survole_élément)
}

rappels_interface_sur_requête_rendu :: fonc (base: *RappelsInterface)
{
    rappels := base comme *RappelsInterfaceQt
    QT_application_poste_evenement(rappels.fenêtre, évènement_sur_requête_rendu)
}

RappelsRequête :: struct {
    empl base: QT_Rappels_Socket

    requête: *Request
    parseuse: ParseuseMessageServeuseHTTP
    response: *Response

    temps_parsage_http: z64
    début_requête: Instantané
}

rappels_interface_sur_lancement_requête :: fonc (base: *RappelsInterface, requête: *Request) -> *Response
{
    rappels := base comme *RappelsInterfaceQt

    rappels_socket := crée_rappel_socket_pour_requête(requête)

    parent := rappels.fenêtre

    uri := requête.donne_url_courant()
    hôte := uri.hôte
    port := port_pour_uri(uri)

    si uri.schéma == "http" {
        prise := QT_cree_ssl_socket_rappels(parent, rappels_socket)
        QT_abstract_socket_connect_to_host(prise, hôte.vers_qt(), port)
    }
    sinon {
        assert(uri.schéma == "https")
        prise := QT_cree_ssl_socket_rappels(parent, rappels_socket)
        QT_ssl_socket_connect_to_host_encrypted(prise, hôte.vers_qt(), port)
    }

    tantque rappels_socket.response == nul {
        rappels_interface_sur_spin_event_loop(rappels)
    }

    retourne rappels_socket.response
}

crée_rappel_socket_pour_requête :: fonc (requête: *Request) -> *RappelsRequête
{
    sur_connexion :: fonc (base: *QT_Rappels_Socket)
    {
        rappels := base comme *RappelsRequête

        rappels.début_requête = maintenant_précis()

        enchaineuse: Enchaineuse
        initialise_enchaineuse(*enchaineuse)
        diffère détruit_tampons(*enchaineuse)

        uri := rappels.requête.donne_url_courant()

        ajoute_au_tampon(*enchaineuse, "GET ")
        si uri.chemin {
            ajoute_au_tampon(*enchaineuse, uri.chemin)
        }
        sinon {
            ajoute_au_tampon(*enchaineuse, "/")
        }
        si uri.requête {
            ajoute_au_tampon(*enchaineuse, "?")
            ajoute_au_tampon(*enchaineuse, uri.requête)
        }

        ajoute_au_tampon(*enchaineuse, " HTTP/1.1\r\n")
        ajoute_au_tampon(*enchaineuse, "Host: ")
        ajoute_au_tampon(*enchaineuse, uri.hôte)
        ajoute_au_tampon(*enchaineuse, "\r\n")
        ajoute_au_tampon(*enchaineuse, "Accept-Encoding: identity\r\n")
        ajoute_au_tampon(*enchaineuse, "Accept-Charset: utf-8, iso-8859-1q=0.5\r\n")
        ajoute_au_tampon(*enchaineuse, "Accept: text/html,application/xhtml+xml,application/xmlq=0.9,image/webp,image/apng,*/ *q=0.8\r\n")
        ajoute_au_tampon(*enchaineuse, "User-Agent: delsace\r\n")
        ajoute_au_tampon(*enchaineuse, "Connection: close\r\n")
        ajoute_au_tampon(*enchaineuse, "\r\n")

        texte_requête := chaine_depuis_enchaineuse(*enchaineuse)
        diffère déloge(texte_requête)

        _ := QT_abstract_socket_write(rappels.socket, texte_requête.pointeur, texte_requête.taille)
        // imprime("Écris : % / %\n", écris, texte_requête.taille)
    }

    sur_erreur :: fonc (base: *QT_Rappels_Socket)
    {
        rappels := base comme *RappelsRequête
        imprime("Erreur\n")
        rappels.response = network_error()
    }

    sur_prêt_à_lire :: fonc (base: *QT_Rappels_Socket)
    {
        rappels := base comme *RappelsRequête
        parseuse := *rappels.parseuse

        enchaineuse: Enchaineuse
        initialise_enchaineuse(*enchaineuse)
        diffère détruit_tampons(*enchaineuse)

        octets_lu := QT_abstract_socket_read(rappels.socket, *enchaineuse.tampon_courant.données[0], TAILLE_TAMPON_ENCHAINEUSE)

        enchaineuse.tampon_courant.occupé = octets_lu comme z32

        lu := chaine_depuis_enchaineuse(*enchaineuse)

        début_parsage_http := maintenant_précis()
        ajourne_données(parseuse, lu)
        rappels.temps_parsage_http += début_parsage_http.temps_écoulé_microsecondes()

        si message_est_erroné(parseuse) {
            imprime("Erreur de parsage")
            QT_abstract_socket_close(rappels.socket)
            retourne
        }

        saufsi message_prêt_pour_finalisation(parseuse) {
            retourne
        }

        imprime("Temps de parsage HTTP : %\n", rappels.temps_parsage_http)
        imprime("Temps requête         : %\n", rappels.début_requête.temps_écoulé_microsecondes())

        message := finalise_message(parseuse)

        entête_content_type := entête(*message, "Content-Type")
        content_type := "text/html" // À FAIRE
        si entête_content_type {
            imprime("Content-Type : %\n", entête_content_type.valeur)

            position_charset := cherche_aiguille_par_force_brute(entête_content_type.valeur, "charset=")
            si position_charset != -1 {
                charset := avance(entête_content_type.valeur, position_charset + "charset=".taille)

                si charset == "ISO-8859-1" {
                    nouveau_contenu := convertis_iso_8859_1_vers_utf8(message.contenu)
                    déloge(message.contenu)
                    message.contenu = nouveau_contenu
                }
            }
        }

        response := loge(Response)
        response.status = message.status

        body_info := loge(ResponseBodyInfo)
        body_info.decodede_size = message.contenu.taille comme z32
        body_info.content_type = content_type

        response.body_info = body_info
        response.body = message.contenu

        rappels.response = response

        réinitialise(parseuse)

        QT_abstract_socket_close(rappels.socket)
    }

    rappels := loge(RappelsRequête)
    rappels.requête = requête
    rappels.sur_pret_a_lire = sur_prêt_à_lire
    rappels.sur_connexion = sur_connexion
    rappels.sur_erreur = sur_erreur
    retourne rappels
}

rappels_interface_sur_spin_event_loop :: fonc (base: *RappelsInterface @inutilisée)
{
    QT_application_process_events()
}

rappels_interface_sur_enfile_une_tâche :: fonc (base: *RappelsInterface, source: SourceDeTâche, algorithm: *Algorithm)
{
    rappels := base comme *RappelsInterfaceQt

    discr source {
        ManipulationDOM {
            QT_application_poste_evenement_et_donnees(rappels.fenêtre, évènement_sur_tâche_manipulation_dom, algorithm)
        }
        InteractionUtilisateur {
            QT_application_poste_evenement_et_donnees(rappels.fenêtre, évènement_sur_tâche_interaction_utilisateur, algorithm)
        }
        Réseautage {
            QT_application_poste_evenement_et_donnees(rappels.fenêtre, évènement_sur_tâche_réseautage, algorithm)
        }
        NavigationEtTraversée {
            QT_application_poste_evenement_et_donnees(rappels.fenêtre, évènement_sur_tâche_navigation_et_traversée, algorithm)
        }
        Rendu {
            QT_application_poste_evenement_et_donnees(rappels.fenêtre, évènement_sur_tâche_rendu, algorithm)
        }
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Conversion jeu de caractères.
 * \{ */

/* https://www.charset.org/charsets/iso-8859-1 */
convertis_iso_8859_1_vers_utf8 :: fonc (texte: chaine) -> chaine
{
    taille_résultat := texte.taille

    pour texte {
        si it < 0 {
            taille_résultat += 1
        }
    }

    si taille_résultat == texte.taille {
        retourne copie_chaine(texte)
    }

    résultat := loge_chaine(taille_résultat)

    ptr_sortie := résultat.pointeur comme *n8

    pour texte {
        si it >= 0 {
            mémoire(ptr_sortie) = it comme n8
            ptr_sortie += 1
            continue
        }

        naturel := it comme n8

        si 0xA0 <= naturel <= 0xBF {
            mémoire(ptr_sortie) = 0xC2
            ptr_sortie += 1
            mémoire(ptr_sortie) = naturel
            ptr_sortie += 1
        }
        sinon si naturel >= 0xA0 {
            mémoire(ptr_sortie) = 0xC3
            ptr_sortie += 1
            mémoire(ptr_sortie) = naturel - 0x40
            ptr_sortie += 1
        }
        sinon {
            imprime("%\n", naturel)
            assert(faux)
        }
    }

    retourne résultat
}

/** \} */
