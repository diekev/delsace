importe Allocatrices
importe Chaine
importe Couleur
importe #inemployé CSS
importe Fondation
importe Géométrie
importe HTML
importe HTTP
importe Internet
importe Math
importe OpenGL
importe PeintureInterface
importe Qt
importe SysFichier
importe Temps
importe Typographie

DÉBOGUE_ALLOCATIONS :: faux

/* ------------------------------------------------------------------------- */
/** \nom Fonction principale.
 * \{ */

allocatrice_gardée: AllocatriceGardée
contexte_entrée: ContexteProgramme

mon_logueur :: fonc (c: chaine, message: chaine @inutilisée, mode: ModeLogage @inutilisée, données: *rien @inutilisée)
{
    fichier := tente ouvre_fichier_crée_si_non_existant(CheminFichier("fuites_de_mémoire.txt"), pour_écriture_tronquée) piège _ {
        imprime("%\n", c)
        retourne
    }

    _ := écris(*fichier, c)
    _ := ferme(*fichier)
}

principale :: fonc () -> z32
{
    mémoire_entrée := mémoire_utilisée()

    /* Nous ne pouvons pas utiliser un nouveau contexte car la fonction principale
     * peut ne pas se terminer (lors des fermetures de fenêtres). */
    __contexte_fil_principal.logueur = mon_logueur
    contexte_entrée = __contexte_fil_principal

    #si DÉBOGUE_ALLOCATIONS {
        __contexte_fil_principal.allocatrice = allocation_gardée
        __contexte_fil_principal.données_allocatrice = *allocatrice_gardée
    }

    diffère {
        /* Restaure le contexte. */
        __contexte_fil_principal = contexte_entrée

        imprime("mémoire_utilisée %\n", mémoire_utilisée() - mémoire_entrée)

        #si DÉBOGUE_ALLOCATIONS {
            imprime_liste_mémoire(*allocatrice_gardée)
        }
    }

    arguments := __arguments_ligne_commande

    chemin_fichier: chaine
    si arguments.taille > 1 {
        arg1 := convertis_chaine_c_statique(ChaineC(arguments[1]))
        chemin_fichier = arg1
    }

    /* Création application. */
    taille_arguments := arguments.taille comme z32
    app := QT_cree_application(*taille_arguments, arguments.pointeur)
    diffère QT_detruit_application(app)

    rappel_fermeture: RappelFermetureApp
    rappel_fermeture.mémoire_entrée = mémoire_entrée
    QT_application_sur_fin_boucle_evenement(app, *rappel_fermeture)

    QT_core_application_definis_nom_organisation(vers_qt("delsace"))
    QT_core_application_definis_nom_application(vers_qt("HTML"))

    initialise_évènements_personnalisés()

    /* Création fenêtre. */
    rappels_fenêtre : RappelsFenetrePrincipale
    rappel_fermeture.rappels_fenêtre = *rappels_fenêtre

    fenêtre := QT_cree_fenetre_principale(*rappels_fenêtre)
    diffère QT_detruit_fenetre_principale(fenêtre)

    QT_widget_definis_titre_fenetre(fenêtre, vers_qt("HTML"))
    QT_widget_affiche_maximisee(fenêtre)

    rappels_fenêtre.chargeuse_ressource.rappels_interface = crée_rappels_interface_qt(fenêtre)

    si chemin_fichier {
        évènement := loge(ÉvènementCréationOnglet)
        évènement.uri = chemin_fichier

        QT_application_poste_evenement_et_donnees(fenêtre, évènement_sur_création_onglet, évènement)
    }

    retourne QT_application_exec(app)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Évènements
 * \{ */

évènement_sur_création_onglet : z32 = -1

ÉvènementCréationOnglet :: struct {
    uri: chaine
}

initialise_évènements_personnalisés :: fonc ()
{
    évènement_sur_création_onglet = QT_enregistre_evenement_personnel()
}

sur_filtre_evenement_impl :: fonc (base: *QT_Rappels_Fenetre_Principale, event: *QT_Evenement) -> z32
{
    type := QT_evenement_donne_type(event) comme n32 comme z32

    si type == évènement_sur_création_onglet {
        rappels := base comme *RappelsFenetrePrincipale

        message := QT_event_perso_donne_donnees(event) comme *ÉvènementCréationOnglet

        // ressource := crée_ressource_pour_chargement_page_web(rappels.fenetre, message.uri)
        // charge_ressource(*rappels.chargeuse_ressource, ressource, vrai)

        uri: URI

        si est_un_fichier_régulier(CheminFichier(message.uri)) {
            uri.schéma = "file"
            uri.schéma_est_défini = vrai
            uri.autorité_est_définie = vrai
            uri.chemin = message.uri
            uri = uri
        }
        sinon {
            uri = tente parse_uri_standard(message.uri) piège nonatteignable
        }

        navigable := crée_un_fresh_top_level_traversable(*rappels.user_agent, uri) comme *TraversableNavigable

        page_web := crée_page_web(uri, navigable.donne_active_document())
        crée_widget_pour_page(rappels.fenetre, page_web)

        déloge(message)

        QT_evenement_accepte(event)
        retourne 1
    }

    retourne 0
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Sur fermeture application.
 * \{ */

RappelFermetureApp :: struct {
    empl base: QT_Rappel_Generique

    rappels_fenêtre: *RappelsFenetrePrincipale
    mémoire_entrée: z64

    sur_rappel = sur_fermeture_application
}

sur_fermeture_application :: fonc (base: *QT_Rappel_Generique)
{    
    rappel := base comme *RappelFermetureApp
    détruit_données_page_web(*rappel.rappels_fenêtre.page_web)
    détruit_données_user_agent(*rappel.rappels_fenêtre.user_agent)

    rappels_interface := rappel.rappels_fenêtre.chargeuse_ressource.rappels_interface comme *RappelsInterfaceQt
    déloge(rappels_interface)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom PageWeb
 * \{ */

PageWeb :: struct {
    uri: URI
    parsat: ParsatHTML
    document: *Document
    contenu: chaine
    fonte: *Fonte
}

crée_page_web :: fonc (uri: &URI, contenu: chaine) -> PageWeb
{
    résultat: PageWeb
    résultat.uri = uri
    résultat.contenu = contenu
    résultat.parsat = parse_document(contenu)
    imprime("Temps de parsage : %\n", résultat.parsat.temps)
    retourne résultat
}

crée_page_web :: fonc (uri: &URI, document: *Document) -> PageWeb
{
    résultat: PageWeb
    résultat.uri = uri
    résultat.document = document
    retourne résultat
}

donne_document :: fonc (page: *PageWeb) -> *Document
{
    si page.document {
        retourne page.document
    }
    retourne page.parsat.document
}

détruit_données_page_web :: fonc (page: *PageWeb)
{
    détruit(page.parsat)
    si page.fonte {
        détruit_fonte(page.fonte)
    }
    déloge(page.contenu)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Données fenêtre principale.
 * \{ */

RappelsFenetrePrincipale :: struct {
    empl base : QT_Rappels_Fenetre_Principale

    user_agent: UserAgent

    page_web: PageWeb
    chargeuse_ressource: ChargeuseRessource

    /* Données rappels. */
    sur_filtre_evenement = sur_filtre_evenement_impl
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Widget page.
 * \{ */

crée_widget_pour_page :: fonc (fenêtre: *QT_Fenetre_Principale, page_web: PageWeb)
{
    rappels := QT_fenetre_principale_donne_rappels(fenêtre) comme *RappelsFenetrePrincipale
    rappels.page_web = page_web

    tabs := QT_cree_tab_widget(nul, fenêtre)
    QT_tab_widget_definis_tabs_fermable(tabs, 0)

    widget_rendu := crée_widget_pour_rendu(fenêtre, tabs)
    QT_tab_widget_ajoute_tab(tabs, widget_rendu, "Rendu")

    widget_source := crée_widget_vue_source(fenêtre, tabs)
    QT_tab_widget_ajoute_tab(tabs, widget_source, "Source")

    widget_arbre := crée_widget_arbre_pour_dom(fenêtre, tabs)
    QT_tab_widget_ajoute_tab(tabs, widget_arbre, "DOM")

    widget_texte := crée_widget_vue_texte(fenêtre, tabs)
    QT_tab_widget_ajoute_tab(tabs, widget_texte, "Texte")

    widget_arbre_disposition := crée_widget_vue_arbre_de_disposition(fenêtre, tabs)
    QT_tab_widget_ajoute_tab(tabs, widget_arbre_disposition, "Arbre de Disposition")

    QT_fenetre_principale_definis_widget_central(fenêtre, tabs)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ÉditriceArborescence
 * \{ */

WidgetArbre :: struct {
    empl base: QT_Rappels_TreeWidget
}

crée_widget_arbre :: fonc (rappels: *QT_Rappels_TreeWidget, parent: QT_Generic_Widget) -> *QT_TreeWidget
{
    résultat := QT_cree_treewidget(rappels, parent)

    QT_treewidget_definis_taille_icone(résultat, 20, 20)
    QT_treewidget_definis_toutes_les_colonnes_montre_focus(résultat, 1)
    QT_treewidget_definis_anime(résultat, 0)
    QT_treewidget_definis_auto_defilement(résultat, 0)
    QT_treewidget_definis_hauteurs_uniformes_lignes(résultat, 1)
    QT_treewidget_definis_mode_selection(résultat, QT_Mode_Selection.SELECTION_UNIQUE)
    QT_treewidget_definis_mode_drag_drop(résultat, QT_Mode_DragDrop.AUCUN_DRAG_DROP)
    QT_treewidget_definis_activation_drag(résultat, 0)
    QT_treewidget_definis_comportement_focus(résultat, QT_Comportement_Focus.AUCUN_FOCUS)
    QT_treewidget_definis_comportement_menu_contextuel(résultat, QT_Comportement_Menu_Contextuel.MENU_PERSONNALISE)
    QT_treewidget_definis_entete_visible(résultat, 1)

    retourne résultat
}

RappelsArborescence :: struct {
    empl base: QT_Rappels_TreeWidget

    fenêtre_principale: *QT_Fenetre_Principale
}

initialise_rappels_arborescence :: fonc (fenêtre_principale: *QT_Fenetre_Principale) -> RappelsArborescence
{
    // sur_changement_item_courant :: fonc (rappels: *QT_Rappels_TreeWidget, courant: *QT_TreeWidgetItem, précédent: *QT_TreeWidgetItem @inutilisée)
    // {
    //     rappels_arborescence := rappels comme *RappelsArborescence
    //     données := QT_treewidgetitem_donne_donnees(courant)
    // }

    résultat: RappelsArborescence
    résultat.fenêtre_principale = fenêtre_principale
    résultat.sur_changement_item_courant = sur_changement_item_courant
    retourne résultat
}

crée_widget_arbre_pour_dom :: fonc (fenêtre: *QT_Fenetre_Principale, parent: QT_Generic_Widget) -> *QT_TreeWidget
{
    rappels := QT_fenetre_principale_donne_rappels(fenêtre) comme *RappelsFenetrePrincipale

    résultat := crée_widget_arbre(nul, parent)

    document := donne_document(*rappels.page_web)
    si document {
        titre := document.donne_title_element()
        si titre {
            texte_titre := extrait_texte_noeud(titre)
            diffère déloge(texte_titre)

            QT_widget_definis_titre_fenetre(fenêtre, vers_qt(texte_titre))
        }

        item_document := QT_cree_treewidgetitem(nul, nul)
        QT_treewidgetitem_definis_indicateur_enfant(item_document, QT_Indicateur_Enfant_Arbre.INVISIBLE_SI_SANS_ENFANT)
        texte := vers_qt("document")
        QT_treewidgetitem_definis_texte(item_document, 0, *texte)
        QT_treewidget_ajoute_item_racine(résultat, item_document)

        pour document.enfants {
            ajoute_item_pour_noeud(item_document, it)
        }
    }

    retourne résultat
}

ajoute_item_pour_noeud :: fonc (parent: *QT_TreeWidgetItem, noeud: *Noeud)
{
    texte := ""
    diffère déloge(texte)

    si noeud.est_élément() {
        élément := noeud comme *Élément

        enchaineuse: Enchaineuse
        initialise_enchaineuse(*enchaineuse)
        diffère détruit_tampons(*enchaineuse)

        ajoute_au_tampon(*enchaineuse, "<", élément.texte)

        pour noeud.attributs {
            ajoute_au_tampon(*enchaineuse, " ", it.nom, "=\"", it.valeur, "\"")
        }

        ajoute_au_tampon(*enchaineuse, ">")

        texte = chaine_depuis_enchaineuse(*enchaineuse)
    }
    sinon {
        si noeud.est_texte() {
            noeud_texte := noeud comme *NoeudTexte
            si est_espace_blanche_entre_élément(noeud_texte) {
                retourne
            }
        }

        texte = imprime_chaine("%", noeud.genre)
    }

    item_noeud := QT_cree_treewidgetitem(nul, nul)
    QT_treewidgetitem_definis_indicateur_enfant(item_noeud, QT_Indicateur_Enfant_Arbre.INVISIBLE_SI_SANS_ENFANT)
    qtexte := vers_qt(texte)
    QT_treewidgetitem_definis_texte(item_noeud, 0, *qtexte)

    QT_treewidgetitem_ajoute_enfant(parent, item_noeud)

    pour noeud.enfants {
        ajoute_item_pour_noeud(item_noeud, it)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom VueSource
 * \{ */

crée_widget_vue_source :: fonc (fenêtre: *QT_Fenetre_Principale, parent: QT_Generic_Widget) -> *QT_PlainTextEdit
{
    rappels := QT_fenetre_principale_donne_rappels(fenêtre) comme *RappelsFenetrePrincipale
    contenu := rappels.page_web.contenu

    résultat := QT_cree_plain_text_edit(nul, parent)
    QT_plain_text_edit_definis_lecture_seule(résultat, vrai)
    QT_plain_text_edit_definis_mode_retour_ligne(résultat, QT_Line_Wrap_Mode.AUCUN)
    QT_plain_text_edit_definis_texte(résultat, contenu)
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom VueSource
 * \{ */

crée_widget_vue_texte :: fonc (fenêtre: *QT_Fenetre_Principale, parent: QT_Generic_Widget) -> *QT_PlainTextEdit
{
    rappels := QT_fenetre_principale_donne_rappels(fenêtre) comme *RappelsFenetrePrincipale
    document := donne_document(*rappels.page_web)

    résultat := QT_cree_plain_text_edit(nul, parent)
    QT_plain_text_edit_definis_lecture_seule(résultat, vrai)
    QT_plain_text_edit_definis_mode_retour_ligne(résultat, QT_Line_Wrap_Mode.AUCUN)
    si document {
        body := document.donne_élément_body()
        texte := extrait_texte_noeud(body)
        diffère déloge(texte)
        QT_plain_text_edit_definis_texte(résultat, texte)
    }
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Vue arbre de disposition
 * \{ */

crée_widget_vue_arbre_de_disposition :: fonc (fenêtre: *QT_Fenetre_Principale, parent: QT_Generic_Widget) -> *QT_TreeWidget
{
    rappels := QT_fenetre_principale_donne_rappels(fenêtre) comme *RappelsFenetrePrincipale

    résultat := crée_widget_arbre(nul, parent)

    arbre := crée_arbre_de_disposition(*rappels.page_web)
    si arbre {
        item_document := QT_cree_treewidgetitem(nul, nul)
        QT_treewidgetitem_definis_indicateur_enfant(item_document, QT_Indicateur_Enfant_Arbre.INVISIBLE_SI_SANS_ENFANT)
        texte := vers_qt("bloc")
        QT_treewidgetitem_definis_texte(item_document, 0, *texte)
        QT_treewidget_ajoute_item_racine(résultat, item_document)

        pour arbre.racine.enfants {
            ajoute_item_pour_noeud(item_document, it)
        }
    }
    retourne résultat
}

ajoute_item_pour_noeud :: fonc (parent: *QT_TreeWidgetItem, noeud: *CSS.NoeudDeDisposition)
{
    item_noeud := QT_cree_treewidgetitem(nul, nul)
    QT_treewidgetitem_definis_indicateur_enfant(item_noeud, QT_Indicateur_Enfant_Arbre.INVISIBLE_SI_SANS_ENFANT)
    texte := si noeud.type == CSS.NoeudDeDispositionBloc {
        "bloc"
    }
    sinon {
        "texte"
    }
    qtexte := vers_qt(texte)
    QT_treewidgetitem_definis_texte(item_noeud, 0, *qtexte)

    QT_treewidgetitem_ajoute_enfant(parent, item_noeud)

    pour noeud.enfants {
        ajoute_item_pour_noeud(item_noeud, it)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom VueRendu
 * \{ */

crée_widget_pour_rendu :: fonc (fenêtre: *QT_Fenetre_Principale, parent: QT_Generic_Widget) -> *QT_GLWidget
{
    rappels := QT_fenetre_principale_donne_rappels(fenêtre) comme *RappelsFenetrePrincipale
    résultat := crée_vue_rendu_page(parent, *rappels.page_web)
    retourne résultat
}

VueRenduPage :: struct {
    empl base: QT_Rappels_GLWidget

    sur_destruction = vue_rendu_page_sur_destruction
    sur_initialisation_gl = vue_rendu_page_sur_initialisation
    sur_peinture_gl = vue_rendu_page_sur_peinture
    sur_redimensionnement_gl = vue_rendu_page_sur_redimensionnement
    sur_deplacement_souris = vue_rendu_page_sur_déplacement_souris

    page: *PageWeb

    hauteur: z32
    largeur: z32

    peintre: *Peintre
}

crée_vue_rendu_page :: fonc (parent: QT_Generic_Widget, page: *PageWeb) -> *QT_GLWidget
{
    rappels := loge(VueRenduPage)
    rappels.page = page
    résultat := QT_cree_glwidget(rappels, parent)
    QT_widget_definis_trackage_souris(résultat, vrai)
    retourne résultat
}

vue_rendu_page_sur_destruction :: fonc (rappels: *QT_Rappels_GLWidget)
{
    vue_rendu_page := rappels comme *VueRenduPage
    si vue_rendu_page.peintre {
        détruit_peintre_igumi(vue_rendu_page.peintre)
    }
    déloge(vue_rendu_page)
}

vue_rendu_page_sur_initialisation :: fonc (base: *QT_Rappels_GLWidget @inutilisée)
{
    glewExperimental = 1
    erreur_ := glewInit()

    si erreur_ != 0 {
        imprime("Erreur lors de l'initilisation de GLEW !\n")
        retourne
    }
}

vue_rendu_page_sur_peinture :: fonc (base: *QT_Rappels_GLWidget)
{
    vue_rendu_page := base comme *VueRenduPage

    taille_cannevas := Taille(largeur = Largeur(vue_rendu_page.largeur), hauteur = Hauteur(vue_rendu_page.hauteur))

    saufsi vue_rendu_page.peintre {
        vue_rendu_page.peintre = crée_peintre_igumi(taille_cannevas)
    }

    peintre := vue_rendu_page.peintre
    peintre.définis_taille_cannevas(taille_cannevas)

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    glClearColor(1.0, 1.0, 1.0, 1.0)

    arbre := crée_arbre_de_disposition(vue_rendu_page.page)
    saufsi arbre && arbre.racine {
        retourne
    }

    page := vue_rendu_page.page

    ctx: CSS.ContexteDessin
    ctx.fonte = page.fonte
    ctx.peintre = peintre
    ctx.hauteur_vue = vue_rendu_page.hauteur

    CSS.dessine(arbre.racine, *ctx)
}

vue_rendu_page_sur_redimensionnement :: fonc (rappels: *QT_Rappels_GLWidget, taille: QT_Taille)
{
    vue_rendu_page := rappels comme *VueRenduPage
    vue_rendu_page.largeur = taille.largeur
    vue_rendu_page.hauteur = taille.hauteur
}

vue_rendu_page_sur_déplacement_souris :: fonc (base: *QT_Rappels_GLWidget, event: *QT_MouseEvent)
{
    vue_rendu_page := base comme *VueRenduPage

    document := donne_document(vue_rendu_page.page)
    saufsi document {
        retourne
    }

    arbre := document.arbre_de_disposition
    saufsi arbre {
        retourne
    }

    position: QT_Position
    QT_mouse_event_donne_position(event, *position)

    élément := CSS.donne_élément_pour_position(arbre, position.x, position.y)
    document.définis_noeud_survolé(élément)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Arbre de disposition
 * \{ */

donne_feuille_de_style_défaut :: fonc () -> *CSS.CSSStyleSheet
{
    contenu := contenu_fichier_texte("/home/kevin/defaults.css")
    diffère déloge(contenu)

    ctx: CSS.ContexteParsageFeuilleDeStyle
    diffère CSS.détruit_données_contexte(*ctx)

    stylesheet := CSS.parse_a_css_style_sheet(*ctx, contenu)
    CSS.rapporte_propriétés_non_supportées(*ctx)

    retourne stylesheet
}

crée_arbre_de_disposition :: fonc (page: *PageWeb) -> *CSS.ArbreDeDisposition
{
    document := donne_document(page)
    saufsi document {
        retourne nul
    }

    si document.arbre_de_disposition {
        retourne document.arbre_de_disposition
    }

    saufsi page.fonte {
        TAILLE_POLICE_DÉFAUT :: 16.0

        page.fonte = crée_fonte(CheminFichier("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf"), TAILLE_POLICE_DÉFAUT)
    }

    document.ajoute_feuille_de_style(donne_feuille_de_style_défaut())
    CSS.crée_arbre_de_disposition(document, page.fonte)
    retourne document.arbre_de_disposition
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ChargeuseRessource
 * \{ */

ChargeuseRessource :: struct {
    ressources_en_chargement: [..]*Ressource
    rappels_interface: *RappelsInterface
}

charge_ressource :: fonc (chargeuse: *ChargeuseRessource, ressource: *Ressource, async: bool)
{
    si est_fichier(ressource) {
        contenu := contenu_fichier_texte(ressource.uri.chemin)
        ressource_fut_chargée(ressource, contenu)
        retourne
    }

    requête := loge(Requête)
    requête.ressource = ressource
    lance_requête(chargeuse, requête)

    saufsi async {
        tantque !ressource.chargement_terminé {
            spin_event_loop(chargeuse)
        }
    }
}

lance_requête :: fonc (chargeuse: *ChargeuseRessource, requête: *Requête)
{
    rappels := chargeuse.rappels_interface
    saufsi rappels && rappels.sur_lancement_requête {
        retourne
    }

    rappels.sur_lancement_requête(rappels, requête)
}

spin_event_loop :: fonc (chargeuse: *ChargeuseRessource)
{
    rappels := chargeuse.rappels_interface
    saufsi rappels && rappels.sur_spin_event_loop {
        retourne
    }

    rappels.sur_spin_event_loop(rappels)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom RappelsInterfaceQt
 * \{ */

RappelsInterfaceQt :: struct {
    empl base: RappelsInterface
    fenêtre: *QT_Fenetre_Principale
}

crée_rappels_interface_qt :: fonc (fenêtre: *QT_Fenetre_Principale) -> *RappelsInterfaceQt
{
    résultat := loge(RappelsInterfaceQt)
    résultat.fenêtre = fenêtre
    résultat.sur_lancement_requête = rappels_interface_sur_lancement_requête
    résultat.sur_spin_event_loop = rappels_interface_sur_spin_event_loop
    retourne résultat
}

rappels_interface_sur_lancement_requête :: fonc (base: *RappelsInterface, requête: *Requête)
{
    rappels := base comme *RappelsInterfaceQt

    rappels_socket := crée_rappel_socket_pour_requête(requête)

    parent := rappels.fenêtre

    uri := requête.ressource.uri
    hôte := uri.hôte
    port := port_pour_uri(uri)

    si requête.est_http() {
        prise := QT_cree_ssl_socket_rappels(parent, rappels_socket)
        QT_abstract_socket_connect_to_host(prise, hôte.vers_qt(), port)
    }
    sinon {
        assert(requête.est_https())
        prise := QT_cree_ssl_socket_rappels(parent, rappels_socket)
        QT_ssl_socket_connect_to_host_encrypted(prise, hôte.vers_qt(), port)
    }
}

crée_rappel_socket_pour_requête :: fonc (requête: *Requête) -> *QT_Rappels_Socket
{
    RappelsRequête :: struct {
        empl base: QT_Rappels_Socket

        requête: *Requête
        parseuse: ParseuseMessageServeuseHTTP

        temps_parsage_http: z64
        début_requête: Instantané
    }

    sur_connexion :: fonc (base: *QT_Rappels_Socket)
    {
        rappels := base comme *RappelsRequête

        rappels.début_requête = maintenant_précis()

        enchaineuse: Enchaineuse
        initialise_enchaineuse(*enchaineuse)
        diffère détruit_tampons(*enchaineuse)

        uri := rappels.requête.ressource.uri

        ajoute_au_tampon(*enchaineuse, "GET ")
        si uri.chemin {
            ajoute_au_tampon(*enchaineuse, uri.chemin)
        }
        sinon {
            ajoute_au_tampon(*enchaineuse, "/")
        }
        si uri.requête {
            ajoute_au_tampon(*enchaineuse, "?")
            ajoute_au_tampon(*enchaineuse, uri.requête)
        }

        ajoute_au_tampon(*enchaineuse, " HTTP/1.1\r\n")
        ajoute_au_tampon(*enchaineuse, "Host: ")
        ajoute_au_tampon(*enchaineuse, uri.hôte)
        ajoute_au_tampon(*enchaineuse, "\r\n")
        ajoute_au_tampon(*enchaineuse, "Accept-Encoding: identity\r\n")
        ajoute_au_tampon(*enchaineuse, "Accept-Charset: utf-8, iso-8859-1q=0.5\r\n")
        ajoute_au_tampon(*enchaineuse, "Accept: text/html,application/xhtml+xml,application/xmlq=0.9,image/webp,image/apng,*/ *q=0.8\r\n")
        ajoute_au_tampon(*enchaineuse, "User-Agent: delsace\r\n")
        ajoute_au_tampon(*enchaineuse, "Connection: close\r\n")
        ajoute_au_tampon(*enchaineuse, "\r\n")

        texte_requête := chaine_depuis_enchaineuse(*enchaineuse)
        diffère déloge(texte_requête)

        _ := QT_abstract_socket_write(rappels.socket, texte_requête.pointeur, texte_requête.taille)
        // imprime("Écris : % / %\n", écris, texte_requête.taille)
    }

    sur_erreur :: fonc (base: *QT_Rappels_Socket)
    {
        rappels := base comme *RappelsRequête
        imprime("Erreur\n")
        ressource_eu_erreur(rappels.requête.ressource)
    }

    sur_prêt_à_lire :: fonc (base: *QT_Rappels_Socket)
    {
        rappels := base comme *RappelsRequête
        parseuse := *rappels.parseuse
        requête := rappels.requête

        enchaineuse: Enchaineuse
        initialise_enchaineuse(*enchaineuse)
        diffère détruit_tampons(*enchaineuse)

        octets_lu := QT_abstract_socket_read(rappels.socket, *enchaineuse.tampon_courant.données[0], TAILLE_TAMPON_ENCHAINEUSE)

        enchaineuse.tampon_courant.occupé = octets_lu comme z32

        lu := chaine_depuis_enchaineuse(*enchaineuse)

        début_parsage_http := maintenant_précis()
        ajourne_données(parseuse, lu)
        rappels.temps_parsage_http += début_parsage_http.temps_écoulé_microsecondes()

        si message_est_erroné(parseuse) {
            imprime("Erreur de parsage")
            QT_abstract_socket_close(rappels.socket)
            retourne
        }

        saufsi message_prêt_pour_finalisation(parseuse) {
            retourne
        }

        imprime("Temps de parsage HTTP : %\n", rappels.temps_parsage_http)
        imprime("Temps requête         : %\n", rappels.début_requête.temps_écoulé_microsecondes())

        message := finalise_message(parseuse)

        content_type := entête(*message, "Content-Type")
        si content_type {
            // imprime("Content-Type : %\n", content_type.valeur)

            position_charset := cherche_aiguille_par_force_brute(content_type.valeur, "charset=")
            si position_charset != -1 {
                charset := avance(content_type.valeur, position_charset + "charset=".taille)

                si charset == "ISO-8859-1" {
                    nouveau_contenu := convertis_iso_8859_1_vers_utf8(message.contenu)
                    déloge(message.contenu)
                    message.contenu = nouveau_contenu
                }
            }
        }

        requête.message = message
        ressource_fut_chargée(requête.ressource, message.contenu)

        réinitialise(parseuse)

        QT_abstract_socket_close(rappels.socket)
    }

    rappels := loge(RappelsRequête)
    rappels.requête = requête
    rappels.sur_pret_a_lire = sur_prêt_à_lire
    rappels.sur_connexion = sur_connexion
    rappels.sur_erreur = sur_erreur
    retourne rappels
}

rappels_interface_sur_spin_event_loop :: fonc (base: *RappelsInterface @inutilisée)
{
    QT_application_process_events()
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Conversion jeu de caractères.
 * \{ */

/* https://www.charset.org/charsets/iso-8859-1 */
convertis_iso_8859_1_vers_utf8 :: fonc (texte: chaine) -> chaine
{
    taille_résultat := texte.taille

    pour texte {
        si it < 0 {
            taille_résultat += 1
        }
    }

    si taille_résultat == texte.taille {
        retourne copie_chaine(texte)
    }

    résultat := loge_chaine(taille_résultat)

    ptr_sortie := résultat.pointeur comme *n8

    pour texte {
        si it >= 0 {
            mémoire(ptr_sortie) = it comme n8
            ptr_sortie += 1
            continue
        }

        naturel := it comme n8

        si 0xA0 <= naturel <= 0xBF {
            mémoire(ptr_sortie) = 0xC2
            ptr_sortie += 1
            mémoire(ptr_sortie) = naturel
            ptr_sortie += 1
        }
        sinon si naturel >= 0xA0 {
            mémoire(ptr_sortie) = 0xC3
            ptr_sortie += 1
            mémoire(ptr_sortie) = naturel - 0x40
            ptr_sortie += 1
        }
        sinon {
            imprime("%\n", naturel)
            assert(faux)
        }
    }

    retourne résultat
}

/** \} */
