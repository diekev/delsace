importe Allocatrices
importe Chaine
importe Compilatrice
importe Couleur
importe #inemployé CSS
importe Fondation
importe Géométrie
importe HTML
importe HTTP
importe #inemployé JavaScript
importe OpenGL
importe PeintureInterface
importe Qt
importe SysFichier
importe Temps
importe Typographie

DÉBOGUE_ALLOCATIONS :: faux

CHAINE_USER_AGENT :: "Mozilla/5.0 (X11; Linux x86_64) Version/0.0 (KHTML, like Gecko) VueHTML/0.0"

// #exécute compile_pour_débogage_avec_asan()

/* ------------------------------------------------------------------------- */
/** \nom Fonction principale.
 * \{ */

allocatrice_gardée: AllocatriceGardée
contexte_entrée: ContexteProgramme

mon_logueur :: fonc (c: chaine, message: chaine @inutilisée, mode: ModeLogage @inutilisée, données: *rien @inutilisée)
{
    fichier := tente ouvre_fichier_crée_si_non_existant(CheminFichier("fuites_de_mémoire.txt"), pour_écriture_tronquée) piège _ {
        imprime("%\n", c)
        retourne
    }

    _ := écris(*fichier, c)
    _ := ferme(*fichier)
}

principale :: fonc () -> z32
{
    mémoire_entrée := mémoire_utilisée()

    /* Nous ne pouvons pas utiliser un nouveau contexte car la fonction principale
     * peut ne pas se terminer (lors des fermetures de fenêtres). */
    __contexte_fil_principal.logueur = mon_logueur
    contexte_entrée = __contexte_fil_principal

    #si DÉBOGUE_ALLOCATIONS {
        __contexte_fil_principal.allocatrice = allocation_gardée
        __contexte_fil_principal.données_allocatrice = *allocatrice_gardée
    }

    diffère {
        /* Restaure le contexte. */
        __contexte_fil_principal = contexte_entrée

        imprime("mémoire_utilisée %\n", mémoire_utilisée() - mémoire_entrée)

        #si DÉBOGUE_ALLOCATIONS {
            imprime_liste_mémoire(*allocatrice_gardée)
        }
    }

    arguments := arguments_ligne_commande()

    utilise_javascript := faux
    chemin_fichier: chaine
    si arguments.taille > 1 {
        si arguments.taille == 3 {
            si arguments[1] != "--js" {
                imprime("Argument '%' inconnu\n", arguments[1])
                retourne 1
            }

            utilise_javascript = vrai
            chemin_fichier = copie_chaine(arguments[2])
        }
        sinon si arguments[1] == "--js" {
            utilise_javascript = vrai
        }
        sinon {
            chemin_fichier = copie_chaine(arguments[1])
        }
    }

    diffère QT_détruit_tampon_rappels()

    /* Création application. */
    taille_arguments := arguments.taille comme z32
    app := QT_cree_application(*taille_arguments, __arguments_ligne_commande.pointeur)
    diffère QT_detruit_application(app)

    rappel_fermeture: RappelFermetureApp
    rappel_fermeture.mémoire_entrée = mémoire_entrée
    QT_application_sur_fin_boucle_evenement(app, *rappel_fermeture)

    QT_core_application_definis_nom_organisation(vers_qt("delsace"))
    QT_core_application_definis_nom_application(vers_qt("HTML"))

    initialise_évènements_personnalisés()

    /* Création fenêtre. */
    rappels_fenêtre: RappelsFenetrePrincipale
    rappels_fenêtre.user_agent = loge(UserAgent)
    rappels_fenêtre.user_agent.supporte_scripting = utilise_javascript
    rappels_fenêtre.user_agent.user_agent_string = crée_chaine_utf16_unique(CHAINE_USER_AGENT)
    rappel_fermeture.rappels_fenêtre = *rappels_fenêtre

    fenêtre := QT_cree_fenetre_principale(*rappels_fenêtre)
    diffère QT_detruit_fenetre_principale(fenêtre)

    définis_titre_fenêtre(fenêtre, nul)
    QT_widget_affiche_maximisee(fenêtre)

    rappels_user_agent := crée_rappels_interface_qt(fenêtre)
    initialise_user_agent(rappels_fenêtre.user_agent)
    définis_rappels_interface(rappels_fenêtre.user_agent, rappels_user_agent)

    si chemin_fichier {
        évènement := loge(ÉvènementCréationOnglet)
        évènement.uri = chemin_fichier

        QT_application_poste_evenement_et_donnees(fenêtre, évènement_sur_création_onglet, évènement)
    }

    retourne QT_application_exec(app)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Évènements
 * \{ */

évènement_sur_création_onglet : z32 = -1
évènement_sur_survole_élément : z32 = -1
évènement_sur_requête_rendu : z32 = -1
évènement_sur_tâche_manipulation_dom : z32 = -1
évènement_sur_tâche_interaction_utilisateur : z32 = -1
évènement_sur_tâche_réseautage : z32 = -1
évènement_sur_tâche_navigation_et_traversée : z32 = -1
évènement_sur_tâche_rendu : z32 = -1
évènement_sur_tâche_parallèle : z32 = -1
évènement_sur_tâche_traversable : z32 = -1

ÉvènementCréationOnglet :: struct {
    uri: chaine
}

initialise_évènements_personnalisés :: fonc ()
{
    évènement_sur_création_onglet = QT_enregistre_evenement_personnel()
    évènement_sur_survole_élément = QT_enregistre_evenement_personnel()
    évènement_sur_requête_rendu = QT_enregistre_evenement_personnel()
    évènement_sur_tâche_manipulation_dom = QT_enregistre_evenement_personnel()
    évènement_sur_tâche_interaction_utilisateur = QT_enregistre_evenement_personnel()
    évènement_sur_tâche_réseautage = QT_enregistre_evenement_personnel()
    évènement_sur_tâche_navigation_et_traversée = QT_enregistre_evenement_personnel()
    évènement_sur_tâche_rendu = QT_enregistre_evenement_personnel()
    évènement_sur_tâche_parallèle = QT_enregistre_evenement_personnel()
    évènement_sur_tâche_traversable = QT_enregistre_evenement_personnel()
}

fenêtre_principale_sur_création_barre_menu :: fonc (base: *QT_Rappels_Fenetre_Principale, créatrice: *QT_Creatrice_Barre_Menu)
{
    rappels_fenêtre := base comme *RappelsFenetrePrincipale

    créatrice.commence_menu_env("Débogage")

    action := crée_action_pour_activer_javascript(rappels_fenêtre)
    créatrice.ajoute_action_env(action)

    action = crée_action_pour_dessin_tampon_id(rappels_fenêtre)
    créatrice.ajoute_action_env(action)

    créatrice.termine_menu_env()
}

crée_action_pour_dessin_tampon_id :: fonc (rappels_fenêtre: *RappelsFenetrePrincipale) -> *QT_Action
{
    sur_rappel :: fonc (rappels: *RappelsFenetrePrincipale, action: *QT_Action)
    {
        vue_rendu_page := QT_glwidget_donne_rappels(rappels.widget_rendu) comme *VueRenduPage
        vue_rendu_page.dessine_tampon_id = QT_action_est_coche(action)
        QT_widget_ajourne(rappels.widget_rendu)
    }

    retourne crée_action_cochable(rappels_fenêtre, "Dessine Tampon ID", faux, sur_rappel)
}

crée_action_pour_activer_javascript :: fonc (rappels_fenêtre: *RappelsFenetrePrincipale) -> *QT_Action
{
    sur_rappel :: fonc (rappels: *RappelsFenetrePrincipale, action: *QT_Action)
    {
        user_agent := rappels.user_agent
        user_agent.supporte_scripting = QT_action_est_coche(action)
    }

    user_agent := rappels_fenêtre.user_agent
    retourne crée_action_cochable(rappels_fenêtre, "Active JavaScript", user_agent.supporte_scripting, sur_rappel)
}

crée_action_cochable :: fonc (rappels_fenêtre: *RappelsFenetrePrincipale, nom: chaine, est_cochée: bool, sur_rappel: fonc(*RappelsFenetrePrincipale, *QT_Action)(rien)) -> *QT_Action
{
    RappelActionMenu :: struct {
        empl base: QT_Rappel_Generique
        action: *QT_Action
        rappels_fenêtre: *RappelsFenetrePrincipale
        sur_rappel_local: fonc(*RappelsFenetrePrincipale, *QT_Action)(rien)
    }

    envellope_rappel :: fonc (base: *QT_Rappel_Generique)
    {
        rappel := base comme *RappelActionMenu
        rappel.sur_rappel_local(rappel.rappels_fenêtre, rappel.action)
    }

    résultat := QT_cree_action(vers_qt(nom), rappels_fenêtre.fenetre)
    QT_action_definis_cochable(résultat, vrai)
    QT_action_definis_coche(résultat, est_cochée)

    rappel := QT_loge_rappel(RappelActionMenu)
    rappel.rappels_fenêtre = rappels_fenêtre
    rappel.sur_rappel = envellope_rappel
    rappel.sur_rappel_local = sur_rappel
    rappel.action = résultat
    QT_action_sur_declenchage(résultat, rappel)

    retourne résultat
}

sur_filtre_evenement_impl :: fonc (base: *QT_Rappels_Fenetre_Principale, event: *QT_Evenement) -> z32
{
    type := QT_evenement_donne_type(event) comme n32 comme z32

    si type == évènement_sur_création_onglet {
        rappels := base comme *RappelsFenetrePrincipale

        message := QT_event_perso_donne_donnees(event) comme *ÉvènementCréationOnglet

        chaine_uri := message.uri

        si est_un_fichier_régulier(CheminFichier(message.uri)) {
            chaine_uri = enchaine("file://", chaine_uri)
        }

        uri := url_parser(rappels.user_agent, chaine_uri)
        assert(uri != nul)

        navigable := crée_un_fresh_top_level_traversable(rappels.user_agent, uri) comme *TraversableNavigable

        page_web := crée_page_web(uri, navigable)
        crée_widget_pour_page(rappels.fenetre, page_web)

        déloge(message)

        QT_evenement_accepte(event)
        retourne 1
    }

    si type == évènement_sur_survole_élément {
        rappels := base comme *RappelsFenetrePrincipale
        document := donne_document(*rappels.page_web)

        /* Restaure toujours le curseur pour éviter d'être bloqué avec un curseur quand
         * nous passons d'un élément à un autre ayant le même curseur : ceci empilera un
         * nouveau curseur et une restauration suivante nous renverraient sur le curseur
         * du premier élément. */
        QT_gui_application_restaure_curseur()

        élément := document.noeud_survolé
        si élément && élément.noeud_de_disposition {
            curseur_qt := curseur_qt_depuis_css(CSS.donne_curseur(élément.noeud_de_disposition))
            QT_gui_application_definis_curseur(curseur_qt)
        }

        QT_evenement_accepte(event)
        retourne 1
    }

    si type == évènement_sur_requête_rendu {
        rappels := base comme *RappelsFenetrePrincipale
        QT_widget_ajourne(rappels.widget_rendu)
        QT_evenement_accepte(event)
        retourne 1
    }

    si type == évènement_sur_tâche_manipulation_dom ||
       type == évènement_sur_tâche_interaction_utilisateur ||
       type == évènement_sur_tâche_réseautage ||
       type == évènement_sur_tâche_navigation_et_traversée ||
       type == évènement_sur_tâche_rendu {
        algorithm := QT_event_perso_donne_donnees(event) comme *Algorithm
        algorithm.run()
        QT_evenement_accepte(event)
        retourne 1
    }

    retourne 0
}

curseur_qt_depuis_css :: fonc (type: CSS.CursorType) -> QT_CursorShape
{
    discr type {
        auto,
        default {
            retourne QT_CursorShape.ARROW
        }
        none {
            retourne QT_CursorShape.BLANK
        }
        context_menu {
            retourne QT_CursorShape.ARROW
        }
        help {
            retourne QT_CursorShape.WHATS_THIS
        }
        pointer {
            retourne QT_CursorShape.POINTING_HAND
        }
        progress {
            retourne QT_CursorShape.BUSY
        }
        wait {
            retourne QT_CursorShape.WAIT
        }
        cell {
            retourne QT_CursorShape.ARROW
        }
        crosshair {
            retourne QT_CursorShape.CROSS
        }
        text {
            retourne QT_CursorShape.IBEAM
        }
        vertical_text {
            retourne QT_CursorShape.ARROW
        }
        alias {
            retourne QT_CursorShape.ARROW
        }
        copy {
            retourne QT_CursorShape.ARROW
        }
        move {
            retourne QT_CursorShape.ARROW
        }
        no_drop {
            retourne QT_CursorShape.ARROW
        }
        not_allowed {
            retourne QT_CursorShape.FORBIDDEN
        }
        grab {
            retourne QT_CursorShape.OPEN_HAND
        }
        grabbing {
            retourne QT_CursorShape.DRAG_MOVE
        }
        e_resize {
            retourne QT_CursorShape.ARROW
        }
        n_resize {
            retourne QT_CursorShape.ARROW
        }
        ne_resize {
            retourne QT_CursorShape.ARROW
        }
        nw_resize {
            retourne QT_CursorShape.ARROW
        }
        s_resize {
            retourne QT_CursorShape.ARROW
        }
        se_resize {
            retourne QT_CursorShape.ARROW
        }
        sw_resize {
            retourne QT_CursorShape.ARROW
        }
        w_resize {
            retourne QT_CursorShape.ARROW
        }
        ew_resize {
            retourne QT_CursorShape.SIZE_HORIZONTAL
        }
        ns_resize {
            retourne QT_CursorShape.SIZE_VERTICAL
        }
        nesw_resize {
            retourne QT_CursorShape.ARROW
        }
        nwse_resize {
            retourne QT_CursorShape.ARROW
        }
        col_resize {
            retourne QT_CursorShape.ARROW
        }
        row_resize {
            retourne QT_CursorShape.ARROW
        }
        all_scroll {
            retourne QT_CursorShape.ARROW
        }
        zoom_in {
            retourne QT_CursorShape.ARROW
        }
        zoom_out {
            retourne QT_CursorShape.ARROW
        }
    }

    retourne QT_CursorShape.ARROW
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Sur fermeture application.
 * \{ */

RappelFermetureApp :: struct {
    empl base: QT_Rappel_Generique

    rappels_fenêtre: *RappelsFenetrePrincipale
    mémoire_entrée: z64

    sur_rappel = sur_fermeture_application
}

sur_fermeture_application :: fonc (base: *QT_Rappel_Generique)
{
    rappel := base comme *RappelFermetureApp
    détruit_données_page_web(*rappel.rappels_fenêtre.page_web)
    détruit_user_agent(rappel.rappels_fenêtre.user_agent)
    détruit_table_chaines_utf16_uniques()
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom PageWeb
 * \{ */

BarreDeDéfilement :: struct {
    rect: RectanglePosDim(r32)
    est_cliqué: bool
    est_survolé: bool
    pos_clique_y: r32
    hauteur: r32
    ratio : r32 = 1.0
}

définis_position_y :: fonc (barre: *BarreDeDéfilement, y: r32) -> bool
{
    vieil_y := barre.rect.y
    barre.rect.y = y

    si barre.rect.y < 0.0 {
        barre.rect.y = 0.0
    }
    sinon si (barre.rect.y + barre.rect.hauteur) > barre.hauteur {
        barre.rect.y = barre.hauteur - barre.rect.hauteur
    }

    retourne barre.rect.y != vieil_y
}

décale_par :: fonc (barre: *BarreDeDéfilement, delta: r32) -> bool
{
    retourne définis_position_y(barre, barre.rect.y + delta)
}

PageWeb :: struct {
    uri: *URL
    parsat: ParsatHTML
    navigable: *TraversableNavigable
    contenu: chaine
    fonte: *Fonte

    défilement_vertical: BarreDeDéfilement
}

crée_page_web :: fonc (uri: *URL, contenu: chaine) -> PageWeb
{
    résultat: PageWeb
    résultat.uri = uri
    résultat.contenu = contenu
    résultat.parsat = parse_document(contenu)
    imprime("Temps de parsage : %\n", résultat.parsat.temps)
    retourne résultat
}

crée_page_web :: fonc (uri: *URL, navigable: *TraversableNavigable) -> PageWeb
{
    résultat: PageWeb
    résultat.uri = uri
    résultat.navigable = navigable
    retourne résultat
}

donne_document :: fonc (page: *PageWeb) -> *Document
{
    si page.navigable {
        retourne page.navigable.donne_active_document()
    }
    retourne page.parsat.document
}

détruit_données_page_web :: fonc (page: *PageWeb)
{
    détruit(page.parsat)
    si page.fonte {
        détruit_fonte(page.fonte)
    }
    déloge(page.contenu)
}

donne_défilement_vertical :: fonc (page: *PageWeb, largeur_vue: r32, hauteur_vue: r32, hauteur_page: r32) -> *BarreDeDéfilement
{
    si hauteur_page == 0.0 || hauteur_page <= hauteur_vue {
        retourne nul
    }

    barre := *page.défilement_vertical

    hauteur_barre := hauteur_vue * hauteur_vue / hauteur_page

    si barre.rect.hauteur == hauteur_barre {
        retourne barre
    }

    /* Ajourne la barre */
    largeur_barre := 12.0
    barre.ratio = hauteur_vue / hauteur_page

    rect_barre: RectanglePosDim(r32)
    rect_barre.x = largeur_vue - largeur_barre
    rect_barre.largeur = largeur_barre
    rect_barre.y = 0.0
    rect_barre.hauteur = hauteur_barre

    barre.hauteur = hauteur_vue

    barre.rect = rect_barre

    retourne barre
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Données fenêtre principale.
 * \{ */

WidgetsPage :: struct {
    line_edit: *QT_LineEdit
    bouton_avant: *QT_PushButton
    bouton_arrière: *QT_PushButton
    bouton_recharge: *QT_PushButton
}

RappelsFenetrePrincipale :: struct {
    empl base: QT_Rappels_Fenetre_Principale

    user_agent: *UserAgent

    page_web: PageWeb
    widgets_page: WidgetsPage
    widget_rendu: *QT_OpenGLWidget
    widget_arbre_de_disposition: *QT_TreeWidget
    widget_arbre_dom: *QT_TreeWidget

    /* Données rappels. */
    sur_filtre_evenement = sur_filtre_evenement_impl
    sur_creation_barre_menu = fenêtre_principale_sur_création_barre_menu
}

définis_titre_fenêtre :: fonc (fenêtre: *QT_Fenetre_Principale, document: *Document)
{
    saufsi document {
        QT_widget_definis_titre_fenetre(fenêtre, vers_qt("Vue HTML"))
        retourne
    }

    titre := document.donne_title_element()
    saufsi titre {
        QT_widget_definis_titre_fenetre(fenêtre, vers_qt("Document Sans Titre - Vue HTML"))
        retourne
    }

    texte_titre := donne_contenu_texte_descandants(titre)
    diffère détruit_chaine(texte_titre)

    texte_filtré := supprime_espace_blanches_autour(texte_titre)
    diffère détruit_chaine(texte_filtré)

    texte_final := imprime_chaine("% - Vue HTML", texte_filtré)
    diffère déloge(texte_final)

    QT_widget_definis_titre_fenetre(fenêtre, vers_qt(texte_final))
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Widget page.
 * \{ */

RappelsTab :: struct {
    empl base: QT_Rappels_TabWidget

    fenêtre: *QT_Fenetre_Principale

    sur_changement_page = rappels_widget_page_sur_changement_index
    sur_destruction = rappels_widget_page_sur_destruction
}

rappels_widget_page_sur_changement_index :: fonc (base: *QT_Rappels_TabWidget, index: z32 @inutilisée)
{
    rappels := base comme *RappelsTab
    fenêtre := rappels.fenêtre
    rappels_fenêtre := QT_fenetre_principale_donne_rappels(fenêtre) comme *RappelsFenetrePrincipale

    page := QT_tab_widget_donne_widget_courant(rappels.widget)

    si page == (rappels_fenêtre.widget_arbre_de_disposition comme *QT_Widget) {
        ajourne_widget_arbre_de_disposition(rappels_fenêtre)
    }
}

rappels_widget_page_sur_destruction :: fonc (base: *QT_Rappels_TabWidget)
{
    rappels := base comme *RappelsTab
    déloge(rappels)
}

crée_widget_pour_page :: fonc (fenêtre: *QT_Fenetre_Principale, page_web: PageWeb)
{
    rappels := QT_fenetre_principale_donne_rappels(fenêtre) comme *RappelsFenetrePrincipale
    rappels.page_web = page_web

    widget := QT_cree_widget(nul, fenêtre)

    barre_de_navigation := crée_barre_de_navigation(rappels.user_agent, *rappels.page_web, *rappels.widgets_page, widget)

    rappels_tabs := loge(RappelsTab)
    rappels_tabs.fenêtre = fenêtre
    tabs := QT_cree_tab_widget(rappels_tabs, fenêtre)
    QT_tab_widget_definis_tabs_fermable(tabs, 0)

    widget_rendu := crée_widget_pour_rendu(fenêtre, tabs)
    QT_tab_widget_ajoute_tab(tabs, widget_rendu, "Rendu")
    rappels.widget_rendu = widget_rendu

    widget_source := crée_widget_vue_source(fenêtre, tabs)
    QT_tab_widget_ajoute_tab(tabs, widget_source, "Source")

    widget_arbre := crée_widget_arbre_pour_dom(fenêtre, tabs)
    QT_tab_widget_ajoute_tab(tabs, widget_arbre, "DOM")

    widget_texte := crée_widget_vue_texte(fenêtre, tabs)
    QT_tab_widget_ajoute_tab(tabs, widget_texte, "Texte")

    widget_arbre_disposition := crée_widget_vue_arbre_de_disposition(fenêtre, tabs)
    QT_tab_widget_ajoute_tab(tabs, widget_arbre_disposition, "Arbre de Disposition")

    disposition := QT_cree_vbox_layout(widget)
    QT_layout_ajoute_widget(disposition, barre_de_navigation)
    QT_layout_ajoute_widget(disposition, tabs)

    QT_fenetre_principale_definis_widget_central(fenêtre, widget)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Barre de navigation.
 * \{ */

RappelChangementAdresse :: struct {
    empl base: QT_Rappel_Generique

    user_agent: *UserAgent
    page_web: *PageWeb
    line_edit: *QT_LineEdit
}

crée_rappel_changement_adresse :: fonc (user_agent: *UserAgent, page_web: *PageWeb, line_edit: *QT_LineEdit) -> *QT_Rappel_Generique
{
    résultat := QT_loge_rappel(RappelChangementAdresse)
    résultat.sur_rappel = rappel_changement_adresse_sur_rappel
    résultat.user_agent = user_agent
    résultat.page_web = page_web
    résultat.line_edit = line_edit
    retourne résultat
}

rappel_changement_adresse_sur_rappel :: fonc (base: *QT_Rappel_Generique)
{
    rappel := base comme *RappelChangementAdresse

    line_edit := rappel.line_edit
    texte := QT_line_edit_donne_texte(line_edit).vers_kuri().copie_chaine()

    si texte.est_vide() {
        retourne
    }

    url := url_parser(rappel.user_agent, texte)
    saufsi url {
        retourne
    }

    page_web := rappel.page_web
    document := page_web.donne_document()

    navigate(rappel.user_agent, page_web.navigable, url, document)
}

QT_crée_push_button :: fonc (texte: chaine, icone: *QT_Icon, parent: QT_Generic_Widget) -> *QT_PushButton
{
    résultat := QT_cree_push_button(texte.vers_qt(), parent)
    QT_push_button_definis_icone(résultat, icone)
    retourne résultat
}

crée_barre_de_navigation :: fonc (user_agent: *UserAgent, page_web: *PageWeb, widgets: *WidgetsPage, parent: *QT_Widget) -> *QT_Widget
{
    widget := QT_cree_widget(nul, parent)
    line_edit := QT_cree_line_edit(widget)

    rappel_changement := crée_rappel_changement_adresse(user_agent, page_web, line_edit)
    QT_line_edit_connecte_sur_pression_retour(line_edit, rappel_changement)

    style := QT_application_donne_style()

    icone_avant := QT_style_donne_standard_icon(style, QT_Standard_Pixmap.ArrowForward)
    diffère QT_detruit_icon(icone_avant)

    icone_arrière := QT_style_donne_standard_icon(style, QT_Standard_Pixmap.ArrowBack)
    diffère QT_detruit_icon(icone_arrière)

    icone_recharge := QT_style_donne_standard_icon(style, QT_Standard_Pixmap.BrowserReload)
    diffère QT_detruit_icon(icone_recharge)

    bouton_avant := QT_crée_push_button("", icone_avant, widget)
    crée_rappel_pour_bouton_avant(user_agent, page_web, bouton_avant)

    bouton_arrière := QT_crée_push_button("", icone_arrière, widget)
    crée_rappel_pour_bouton_arrière(user_agent, page_web, bouton_arrière)

    bouton_recharge := QT_crée_push_button("", icone_recharge, widget)
    crée_rappel_pour_bouton_recharge(user_agent, page_web, bouton_recharge)

    QT_widget_definis_actif(bouton_avant, faux)
    QT_widget_definis_actif(bouton_arrière, faux)

    disposition := QT_cree_hbox_layout(widget)
    QT_layout_ajoute_widget(disposition, bouton_arrière)
    QT_layout_ajoute_widget(disposition, bouton_avant)
    QT_layout_ajoute_widget(disposition, bouton_recharge)
    QT_layout_ajoute_widget(disposition, line_edit)

    widgets.line_edit = line_edit
    widgets.bouton_avant = bouton_avant
    widgets.bouton_arrière = bouton_arrière
    widgets.bouton_recharge = bouton_recharge

    retourne widget
}

crée_rappel_pour_bouton_avant :: fonc (user_agent: *UserAgent, page_web: *PageWeb, bouton: *QT_PushButton)
{
    RappelTraversée :: struct {
        empl base: QT_Rappel_Generique

        user_agent: *UserAgent
        page_web: *PageWeb
    }

    sur_traversée :: fonc (base: *QT_Rappel_Generique)
    {
        rappel := base comme *RappelTraversée
        user_agent := rappel.user_agent
        page_web := rappel.page_web
        traversable := page_web.navigable

        traverse_the_history_by_a_delta(user_agent, traversable, 1)
    }

    rappel := QT_loge_rappel(RappelTraversée)
    rappel.sur_rappel = sur_traversée
    rappel.user_agent = user_agent
    rappel.page_web = page_web

    QT_push_button_connecte_sur_clic(bouton, rappel)
}

crée_rappel_pour_bouton_arrière :: fonc (user_agent: *UserAgent, page_web: *PageWeb, bouton: *QT_PushButton)
{
    RappelTraversée :: struct {
        empl base: QT_Rappel_Generique

        user_agent: *UserAgent
        page_web: *PageWeb
    }

    sur_traversée :: fonc (base: *QT_Rappel_Generique)
    {
        rappel := base comme *RappelTraversée
        user_agent := rappel.user_agent
        page_web := rappel.page_web
        traversable := page_web.navigable

        traverse_the_history_by_a_delta(user_agent, traversable, -1)
    }

    rappel := QT_loge_rappel(RappelTraversée)
    rappel.sur_rappel = sur_traversée
    rappel.user_agent = user_agent
    rappel.page_web = page_web

    QT_push_button_connecte_sur_clic(bouton, rappel)
}

crée_rappel_pour_bouton_recharge :: fonc (user_agent: *UserAgent, page_web: *PageWeb, bouton: *QT_PushButton)
{
    RappelTraversée :: struct {
        empl base: QT_Rappel_Generique

        user_agent: *UserAgent
        page_web: *PageWeb
    }

    sur_traversée :: fonc (base: *QT_Rappel_Generique)
    {
        rappel := base comme *RappelTraversée
        user_agent := rappel.user_agent
        page_web := rappel.page_web
        traversable := page_web.navigable

        reload(user_agent, traversable, UserNavigationInvolvement.BrowserUI)
    }

    rappel := QT_loge_rappel(RappelTraversée)
    rappel.sur_rappel = sur_traversée
    rappel.user_agent = user_agent
    rappel.page_web = page_web

    QT_push_button_connecte_sur_clic(bouton, rappel)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ÉditriceArborescence
 * \{ */

WidgetArbre :: struct {
    empl base: QT_Rappels_TreeWidget
}

crée_widget_arbre :: fonc (rappels: *QT_Rappels_TreeWidget, parent: QT_Generic_Widget) -> *QT_TreeWidget
{
    résultat := QT_cree_treewidget(rappels, parent)

    QT_treewidget_definis_taille_icone(résultat, 20, 20)
    QT_treewidget_definis_toutes_les_colonnes_montre_focus(résultat, 1)
    QT_treewidget_definis_anime(résultat, 0)
    QT_treewidget_definis_auto_defilement(résultat, 0)
    QT_treewidget_definis_hauteurs_uniformes_lignes(résultat, 1)
    QT_treewidget_definis_mode_selection(résultat, QT_Mode_Selection.SELECTION_UNIQUE)
    QT_treewidget_definis_mode_drag_drop(résultat, QT_Mode_DragDrop.AUCUN_DRAG_DROP)
    QT_treewidget_definis_activation_drag(résultat, 0)
    QT_treewidget_definis_comportement_focus(résultat, QT_Comportement_Focus.AUCUN_FOCUS)
    QT_treewidget_definis_comportement_menu_contextuel(résultat, QT_Comportement_Menu_Contextuel.MENU_PERSONNALISE)
    QT_treewidget_definis_entete_visible(résultat, 1)

    retourne résultat
}

RappelsArborescence :: struct {
    empl base: QT_Rappels_TreeWidget

    fenêtre_principale: *QT_Fenetre_Principale
}

initialise_rappels_arborescence :: fonc (fenêtre_principale: *QT_Fenetre_Principale) -> RappelsArborescence
{
    // sur_changement_item_courant :: fonc (rappels: *QT_Rappels_TreeWidget, courant: *QT_TreeWidgetItem, précédent: *QT_TreeWidgetItem @inutilisée)
    // {
    //     rappels_arborescence := rappels comme *RappelsArborescence
    //     données := QT_treewidgetitem_donne_donnees(courant)
    // }

    résultat: RappelsArborescence
    résultat.fenêtre_principale = fenêtre_principale
    résultat.sur_changement_item_courant = sur_changement_item_courant
    retourne résultat
}

crée_widget_arbre_pour_dom :: fonc (fenêtre: *QT_Fenetre_Principale, parent: QT_Generic_Widget) -> *QT_TreeWidget
{
    rappels := QT_fenetre_principale_donne_rappels(fenêtre) comme *RappelsFenetrePrincipale
    résultat := crée_widget_arbre(nul, parent)
    rappels.widget_arbre_dom = résultat
    ajourne_widget_arbre_dom(rappels)
    retourne résultat
}

ajourne_widget_arbre_dom :: fonc (rappels: *RappelsFenetrePrincipale)
{
    QT_treewidget_efface(rappels.widget_arbre_dom)

    document := donne_document(*rappels.page_web)
    saufsi document {
        retourne
    }

    arbre := rappels.widget_arbre_dom

    item_document := QT_cree_treewidgetitem(nul, nul)
    QT_treewidgetitem_definis_indicateur_enfant(item_document, QT_Indicateur_Enfant_Arbre.INVISIBLE_SI_SANS_ENFANT)
    texte := vers_qt("document")
    QT_treewidgetitem_definis_texte(item_document, 0, *texte)
    QT_treewidget_ajoute_item_racine(arbre, item_document)

    pour document.enfants {
        ajoute_item_pour_noeud(item_document, it)
    }
}

ajoute_item_pour_noeud :: fonc (parent: *QT_TreeWidgetItem, noeud: *Noeud)
{
    texte := ""
    diffère déloge(texte)

    si noeud.est_élément() {
        élément := noeud comme *Élément

        enchaineuse: Enchaineuse
        initialise_enchaineuse(*enchaineuse)
        diffère détruit_tampons(*enchaineuse)

        ajoute_au_tampon(*enchaineuse, "<", élément.local_name)

        pour noeud.attributs {
            ajoute_au_tampon(*enchaineuse, " ", it.local_name, "=\"", it.valeur, "\"")
        }

        ajoute_au_tampon(*enchaineuse, ">")

        texte = chaine_depuis_enchaineuse(*enchaineuse)
    }
    sinon {
        si noeud.est_texte() {
            noeud_texte := noeud comme *NoeudTexte
            si est_espace_blanche_entre_élément(noeud_texte) {
                retourne
            }
        }

        texte = imprime_chaine("%", noeud.genre)
    }

    item_noeud := QT_cree_treewidgetitem(nul, nul)
    QT_treewidgetitem_definis_indicateur_enfant(item_noeud, QT_Indicateur_Enfant_Arbre.INVISIBLE_SI_SANS_ENFANT)
    qtexte := vers_qt(texte)
    QT_treewidgetitem_definis_texte(item_noeud, 0, *qtexte)

    QT_treewidgetitem_ajoute_enfant(parent, item_noeud)

    pour noeud.enfants {
        ajoute_item_pour_noeud(item_noeud, it)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom VueSource
 * \{ */

crée_widget_vue_source :: fonc (fenêtre: *QT_Fenetre_Principale, parent: QT_Generic_Widget) -> *QT_PlainTextEdit
{
    rappels := QT_fenetre_principale_donne_rappels(fenêtre) comme *RappelsFenetrePrincipale
    contenu := rappels.page_web.contenu

    résultat := QT_cree_plain_text_edit(nul, parent)
    QT_plain_text_edit_definis_lecture_seule(résultat, vrai)
    QT_plain_text_edit_definis_mode_retour_ligne(résultat, QT_Line_Wrap_Mode.AUCUN)
    QT_plain_text_edit_definis_texte(résultat, contenu)
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom VueSource
 * \{ */

crée_widget_vue_texte :: fonc (fenêtre: *QT_Fenetre_Principale, parent: QT_Generic_Widget) -> *QT_PlainTextEdit
{
    rappels := QT_fenetre_principale_donne_rappels(fenêtre) comme *RappelsFenetrePrincipale
    document := donne_document(*rappels.page_web)

    résultat := QT_cree_plain_text_edit(nul, parent)
    QT_plain_text_edit_definis_lecture_seule(résultat, vrai)
    QT_plain_text_edit_definis_mode_retour_ligne(résultat, QT_Line_Wrap_Mode.AUCUN)
    si document {
        body := document.donne_élément_body()
        si body {
            texte := extrait_texte_noeud(body)
            diffère déloge(texte)
            QT_plain_text_edit_definis_texte(résultat, texte)
        }
    }
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Vue arbre de disposition
 * \{ */

crée_widget_vue_arbre_de_disposition :: fonc (fenêtre: *QT_Fenetre_Principale, parent: QT_Generic_Widget) -> *QT_TreeWidget
{
    rappels := QT_fenetre_principale_donne_rappels(fenêtre) comme *RappelsFenetrePrincipale

    résultat := crée_widget_arbre(nul, parent)
    rappels.widget_arbre_de_disposition = résultat
    ajourne_widget_arbre_de_disposition(rappels)
    retourne résultat
}

ajourne_widget_arbre_de_disposition :: fonc (rappels: *RappelsFenetrePrincipale)
{
    QT_treewidget_efface(rappels.widget_arbre_de_disposition)

    document := donne_document(*rappels.page_web)
    saufsi document {
        retourne
    }

    arbre := document.arbre_de_disposition
    saufsi arbre {
        retourne
    }

    widget := rappels.widget_arbre_de_disposition

    item_document := QT_cree_treewidgetitem(nul, nul)
    QT_treewidgetitem_definis_indicateur_enfant(item_document, QT_Indicateur_Enfant_Arbre.INVISIBLE_SI_SANS_ENFANT)
    texte := donne_texte_item_pour_noeud(arbre.racine)
    diffère déloge_si_logée(texte)
    qtexte := vers_qt(texte)
    QT_treewidgetitem_definis_texte(item_document, 0, *qtexte)
    QT_treewidget_ajoute_item_racine(widget, item_document)

    pour arbre.racine.enfants {
        ajoute_item_pour_noeud(item_document, it)
    }
}

ajoute_item_pour_noeud :: fonc (parent: *QT_TreeWidgetItem, noeud: *CSS.NoeudDeDisposition)
{
    item_noeud := QT_cree_treewidgetitem(nul, nul)
    QT_treewidgetitem_definis_indicateur_enfant(item_noeud, QT_Indicateur_Enfant_Arbre.INVISIBLE_SI_SANS_ENFANT)
    texte := donne_texte_item_pour_noeud(noeud)
    diffère déloge_si_logée(texte)
    qtexte := vers_qt(texte)
    QT_treewidgetitem_definis_texte(item_noeud, 0, *qtexte)

    QT_treewidgetitem_ajoute_enfant(parent, item_noeud)

    pour noeud.enfants {
        ajoute_item_pour_noeud(item_noeud, it)
    }
}

donne_texte_item_pour_noeud :: fonc (noeud: *CSS.NoeudDeDisposition) -> chaine
{
    si noeud.type == CSS.NoeudDeDispositionTexte {
        retourne "texte"
    }

    si noeud.type == CSS.NoeudDeDispositionNouvelleLigne {
        retourne "<br/>"
    }

    noeud_bloc := noeud comme *CSS.NoeudDeDispositionBloc

    local_name := crée_chaine_utf16_unique("#anonyme")
    si noeud_bloc.élément {
        local_name = noeud_bloc.élément.local_name
    }

    position_x := noeud.modèle_de_boite.marge.x
    position_y := noeud.modèle_de_boite.marge.y
    largeur := noeud.modèle_de_boite.marge.largeur
    hauteur := noeud.modèle_de_boite.marge.hauteur

    retourne imprime_chaine("% (%) [%x%] [%x%]", CSS.donne_nom_classe(noeud), local_name, position_x, position_y, largeur, hauteur)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom VueRendu
 * \{ */

crée_widget_pour_rendu :: fonc (fenêtre: *QT_Fenetre_Principale, parent: QT_Generic_Widget) -> *QT_OpenGLWidget
{
    rappels := QT_fenetre_principale_donne_rappels(fenêtre) comme *RappelsFenetrePrincipale
    résultat := crée_vue_rendu_page(fenêtre, parent, *rappels.page_web)
    retourne résultat
}

VueRenduPage :: struct {
    empl base: QT_Rappels_GLWidget

    sur_destruction = vue_rendu_page_sur_destruction
    sur_initialisation_gl = vue_rendu_page_sur_initialisation
    sur_peinture_gl = vue_rendu_page_sur_peinture
    sur_redimensionnement_gl = vue_rendu_page_sur_redimensionnement
    sur_deplacement_souris = vue_rendu_page_sur_déplacement_souris
    sur_pression_souris = vue_rendu_page_sur_pression_souris
    sur_relachement_souris = vue_rendu_page_sur_relachement_souris
    sur_molette_souris = vue_rendu_page_sur_molette_souris
    sur_sortie = vue_rendu_page_sur_sortie
    sur_relachement_cle = vue_rendu_page_sur_relachement_cle

    fenêtre_principale: *QT_Fenetre_Principale
    page: *PageWeb

    hauteur: z32
    largeur: z32

    dessine_tampon_id: bool

    peintre: *Peintre
    peintre_id: *Peintre
}

crée_vue_rendu_page :: fonc (fenêtre_principale: *QT_Fenetre_Principale, parent: QT_Generic_Widget, page: *PageWeb) -> *QT_OpenGLWidget
{
    rappels := loge(VueRenduPage)
    rappels.page = page
    rappels.fenêtre_principale = fenêtre_principale
    résultat := QT_cree_glwidget(rappels, parent)
    QT_widget_definis_comportement_focus(résultat, QT_Focus_Policy.WheelFocus)
    QT_widget_definis_trackage_souris(résultat, vrai)
    retourne résultat
}

vue_rendu_page_sur_destruction :: fonc (rappels: *QT_Rappels_GLWidget)
{
    vue_rendu_page := rappels comme *VueRenduPage
    si vue_rendu_page.peintre {
        détruit_peintre(vue_rendu_page.peintre)
    }
    si vue_rendu_page.peintre_id {
        détruit_peintre(vue_rendu_page.peintre_id)
    }
    déloge(vue_rendu_page)
}

vue_rendu_page_sur_initialisation :: fonc (base: *QT_Rappels_GLWidget @inutilisée)
{
    glewExperimental = 1
    erreur_ := glewInit()

    si erreur_ != 0 {
        imprime("Erreur lors de l'initilisation de GLEW !\n")
        retourne
    }
}

vue_rendu_page_sur_peinture :: fonc (base: *QT_Rappels_GLWidget)
{
    /* Réinitialise les erreurs.
     * Il semblerait que Qt génère une erreur entre les appels à cette fonction... :/ */
    _ := glGetError()

    vue_rendu_page := base comme *VueRenduPage

    taille_cannevas := Taille(largeur = Largeur(vue_rendu_page.largeur), hauteur = Hauteur(vue_rendu_page.hauteur))

    saufsi vue_rendu_page.peintre {
        vue_rendu_page.peintre = crée_peintre_igumi(taille_cannevas)
        // vue_rendu_page.peintre = crée_peintre_module_dessin(taille_cannevas)
    }

    saufsi vue_rendu_page.peintre_id {
        vue_rendu_page.peintre_id = crée_peintre_igumi(taille_cannevas)
    }

    peintre := vue_rendu_page.peintre
    peintre.définis_taille_cannevas(taille_cannevas)

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    glClearColor(1.0, 1.0, 1.0, 1.0)

    page := vue_rendu_page.page
    document := donne_document(page)

    si document.is_initial_about_blank {
        retourne
    }

    arbre := crée_arbre_de_disposition(page, vue_rendu_page.largeur, vue_rendu_page.hauteur)
    saufsi arbre && arbre.racine {
        retourne
    }

    ctx: CSS.ContexteDessin
    ctx.document = document
    ctx.globales = document.globales_dessin
    ctx.peintre = peintre
    ctx.hauteur_vue = vue_rendu_page.hauteur
    ctx.largeur_vue = vue_rendu_page.largeur

    hauteur_racine := arbre.racine.modèle_de_boite.marge.hauteur
    barre := donne_défilement_vertical(page, vue_rendu_page.largeur comme r32, vue_rendu_page.hauteur comme r32, hauteur_racine)

    si barre {
        ctx.décalage_y = barre.rect.y / barre.ratio
    }

    // début_rendu := maintenant_précis()

    ctx.peintre.remplis_arrière_plan(CouleurRVBAN8(255, 255, 255, 255))

    si vue_rendu_page.dessine_tampon_id {
        CSS.dessine_tampon_id_couleur(arbre, *ctx)
    }
    sinon {
        CSS.dessine(arbre, *ctx)
    }

    // imprime("temps de rendu : %\n", début_rendu.temps_écoulé_millisecondes())

    si barre {
        hauteur_vue := vue_rendu_page.hauteur comme r32

        rect_barre := barre.rect

        /* Change la position pour le dessin qui commence du bas. */
        rect_barre.y = hauteur_vue - rect_barre.hauteur - rect_barre.y

        couleur := CouleurRVBA(1.0, 0.5, 0.5, 0.5)
        si barre.est_cliqué || barre.est_survolé {
            couleur.r *= 0.5
            couleur.v *= 0.5
            couleur.b *= 0.5
        }

        peintre.remplis_rectangle(rect_barre, couleur)
        peintre.termine_dessin()
    }

    lien_survolé := document.donne_lien_survolé()
    si lien_survolé {
        href := lien_survolé.donne_href()

        saufsi href.est_vide() {
            texte := href.donne_chaine_utf16()
            fonte := CSS.donne_fonte_défaut(document.globales_dessin)
            métriques := fonte.donne_métriques_fonte()

            rect: RectanglePosDim(r32)
            rect.y = 0
            rect.hauteur = métriques.donne_hauteur_ligne()
            rect.largeur = fonte.donne_largeur_texte(texte) comme r32 + 2.0 * métriques.largeur_moyenne

            couleur := CouleurRVBAN8(255, 255, 255, 255)
            peintre.remplis_rectangle(rect, couleur)

            couleur = CouleurRVBAN8(0, 0, 0, 255)
            rect.x = métriques.largeur_moyenne
            rect.y -= métriques.jambage_inférieur
            peintre.dessine_texte(fonte, texte, rect, couleur, nul)

            peintre.termine_dessin()
        }
    }

    ctx.peintre.dessine_tampon_sur_écran()

    ctx.peintre = vue_rendu_page.peintre_id
    CSS.dessine_tampon_id(arbre, *ctx)

    /* Nous devrions faire ça plus haut mais il semblerait qu'il manque, ou qu'il y a une préemption, des ajournements. */
    window := document.realm.global_object comme *Window
    exécute_animation_frames(window)
}

vue_rendu_page_sur_redimensionnement :: fonc (rappels: *QT_Rappels_GLWidget, taille: QT_Taille)
{
    vue_rendu_page := rappels comme *VueRenduPage
    vue_rendu_page.largeur = taille.largeur
    vue_rendu_page.hauteur = taille.hauteur

    page := vue_rendu_page.page
    document := donne_document(page)
    si document {
        document.invalide_style_pour_redimensionnement(taille.largeur, taille.hauteur)
    }
    /* Réinitialise la barre de défilement. */
    page.défilement_vertical.rect.largeur = 0.0
    page.défilement_vertical.ratio = 1.0
    page.défilement_vertical.hauteur = vue_rendu_page.hauteur comme r32
}

vue_rendu_page_sur_déplacement_souris :: fonc (base: *QT_Rappels_GLWidget, event: *QT_MouseEvent)
{
    vue_rendu_page := base comme *VueRenduPage

    document := donne_document(vue_rendu_page.page)
    saufsi document {
        retourne
    }

    arbre := document.arbre_de_disposition
    saufsi arbre {
        retourne
    }

    position: QT_Position
    QT_mouse_event_donne_position(event, *position)

    élément := CSS.donne_élément_pour_position(arbre, position.x, position.y)
    document.définis_noeud_survolé(élément)
    si élément {
        envoie_mousemove(élément, position.x, position.y)
    }

    défilement := *vue_rendu_page.page.défilement_vertical

    ajourne_rendu := faux

    si défilement.est_cliqué {
        décalage := position.y comme r32 - défilement.pos_clique_y
        défilement.pos_clique_y = position.y comme r32
        ajourne_rendu |= défilement.décale_par(décalage)
    }

    si défilement.rect.contient(position.x comme r32, position.y comme r32) {
        saufsi défilement.est_survolé {
            défilement.est_survolé = vrai
            ajourne_rendu = vrai
        }
    }
    sinon si défilement.est_survolé {
        défilement.est_survolé = faux
        ajourne_rendu = vrai
    }

    si ajourne_rendu {
        QT_widget_ajourne(vue_rendu_page.widget)
    }
}

vue_rendu_page_sur_pression_souris :: fonc (base: *QT_Rappels_GLWidget, event: *QT_MouseEvent)
{
    vue_rendu_page := base comme *VueRenduPage

    document := donne_document(vue_rendu_page.page)
    saufsi document {
        retourne
    }

    arbre := document.arbre_de_disposition
    saufsi arbre {
        retourne
    }

    position: QT_Position
    QT_mouse_event_donne_position(event, *position)

    si vue_rendu_page.page.défilement_vertical.est_survolé {
        vue_rendu_page.page.défilement_vertical.est_cliqué = vrai
        vue_rendu_page.page.défilement_vertical.pos_clique_y = position.y comme r32
        retourne
    }

    élément := CSS.donne_élément_pour_position(arbre, position.x, position.y)
    si élément {
        élément.est_en_train_d_être_activé(vrai)
        envoie_mousedown(élément, position.x, position.y)
    }
    document.élément_en_cours_d_activation = élément
}

vue_rendu_page_sur_relachement_souris :: fonc (base: *QT_Rappels_GLWidget, event: *QT_MouseEvent)
{
    vue_rendu_page := base comme *VueRenduPage

    document := donne_document(vue_rendu_page.page)
    saufsi document {
        retourne
    }

    arbre := document.arbre_de_disposition
    saufsi arbre {
        retourne
    }

    si vue_rendu_page.page.défilement_vertical.est_cliqué {
        vue_rendu_page.page.défilement_vertical.est_cliqué = faux
        QT_widget_ajourne(vue_rendu_page.widget)
        retourne
    }

    position: QT_Position
    QT_mouse_event_donne_position(event, *position)

    élément := CSS.donne_élément_pour_position(arbre, position.x, position.y)
    si élément {
        élément.est_en_train_d_être_activé(faux)
        envoie_mouseup(élément, position.x, position.y)
    }
    si document.élément_en_cours_d_activation {
        si document.élément_en_cours_d_activation != élément {
            document.élément_en_cours_d_activation.est_en_train_d_être_activé(faux)
        }
        sinon {
            envoie_un_clic(élément)
        }
    }
    document.élément_en_cours_d_activation = nul
}

vue_rendu_page_sur_molette_souris :: fonc (base: *QT_Rappels_GLWidget, event: *QT_WheelEvent)
{
    vue_rendu_page := base comme *VueRenduPage

    document := donne_document(vue_rendu_page.page)
    saufsi document {
        retourne
    }

    arbre := document.arbre_de_disposition
    saufsi arbre {
        retourne
    }

    delta_molette := QT_wheel_event_donne_delta(event)

    HAUTEURE_LIGNE :: 16.0
    NOMBRE_DE_LIGNES_PAR_ROULEMENT :: 5.0
    DÉCALAGE_PAR_ROULEMENT :: NOMBRE_DE_LIGNES_PAR_ROULEMENT * HAUTEURE_LIGNE

    delta := DÉCALAGE_PAR_ROULEMENT * vue_rendu_page.page.défilement_vertical.ratio

    si delta_molette > 0 {
        delta = -delta
    }

    si décale_par(*vue_rendu_page.page.défilement_vertical, delta) {
        QT_widget_ajourne(vue_rendu_page.widget)
    }
}

vue_rendu_page_sur_sortie :: fonc (base: *QT_Rappels_GLWidget, event: *QT_Evenement @inutilisée)
{
    vue_rendu_page := base comme *VueRenduPage
    si vue_rendu_page.page.défilement_vertical.est_cliqué {
        retourne
    }
    vue_rendu_page.page.défilement_vertical.est_survolé = faux
    QT_gui_application_restaure_curseur()
}

vue_rendu_page_sur_relachement_cle :: fonc (base: *QT_Rappels_GLWidget, event: *QT_KeyEvent)
{
    vue_rendu_page := base comme *VueRenduPage
    touche := QT_key_event_donne_cle(event)

    barre := *vue_rendu_page.page.défilement_vertical
    ajourne_rendu := faux

    si touche == QT_Key.Home {
        ajourne_rendu = barre.définis_position_y(0.0)
    }
    sinon si touche == QT_Key.End {
        ajourne_rendu = barre.définis_position_y(barre.hauteur - barre.rect.hauteur)
    }
    sinon si touche == QT_Key.PageDown {
        ajourne_rendu = barre.décale_par(barre.rect.hauteur * 0.9)
    }
    sinon si touche == QT_Key.PageUp {
        ajourne_rendu = barre.décale_par(-barre.rect.hauteur * 0.9)
    }

    si ajourne_rendu {
        QT_widget_ajourne(vue_rendu_page.widget)
    }
}

/* https://w3c.github.io/uievents/#send-click-event */
envoie_un_clic :: fonc (élément: *HTML.Élément)
{
    /* À FAIRE : standardise. */
    évènement := crée_platform_object(élément, HTML.Event)
    évènement.target = élément
    évènement.type = HTML.EventType.click

    _ := dispatch(évènement, élément)
}

envoie_mousedown :: fonc (élément: *HTML.Élément, position_x: z32, position_y: z32)
{
    évènement := crée_platform_object(élément, HTML.MouseEvent)
    évènement.target = élément
    évènement.type = HTML.EventType.mousedown
    évènement.bubbles = vrai
    évènement.screen_x = position_x comme r64
    évènement.screen_y = position_y comme r64

    rect := CSS.donne_rectangle_rembourrage(élément.noeud_de_disposition)
    évènement.offset_x = évènement.screen_x - rect.x
    évènement.offset_y = évènement.screen_y - rect.y

    _ := dispatch(évènement, élément)
}

envoie_mousemove :: fonc (élément: *HTML.Élément, position_x: z32, position_y: z32)
{
    évènement := crée_platform_object(élément, HTML.MouseEvent)
    évènement.target = élément
    évènement.type = HTML.EventType.mousemove
    évènement.bubbles = vrai
    évènement.screen_x = position_x comme r64
    évènement.screen_y = position_y comme r64

    rect := CSS.donne_rectangle_rembourrage(élément.noeud_de_disposition)
    évènement.offset_x = évènement.screen_x - rect.x
    évènement.offset_y = évènement.screen_y - rect.y

    _ := dispatch(évènement, élément)
}

envoie_mouseup :: fonc (élément: *HTML.Élément, position_x: z32, position_y: z32)
{
    évènement := crée_platform_object(élément, HTML.MouseEvent)
    évènement.target = élément
    évènement.type = HTML.EventType.mouseup
    évènement.bubbles = vrai
    évènement.screen_x = position_x comme r64
    évènement.screen_y = position_y comme r64

    rect := CSS.donne_rectangle_rembourrage(élément.noeud_de_disposition)
    évènement.offset_x = évènement.screen_x - rect.x
    évènement.offset_y = évènement.screen_y - rect.y

    _ := dispatch(évènement, élément)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Arbre de disposition
 * \{ */

donne_feuille_de_style_défaut :: fonc () -> *CSS.CSSStyleSheet
{
    chemin_fichier := donne_chemin_fichier_css_défaut()
    diffère détruit_chemin(chemin_fichier)

    contenu := contenu_fichier_texte(chemin_fichier)
    diffère déloge(contenu)

    ctx: CSS.ContexteParsageFeuilleDeStyle
    diffère CSS.détruit_données_contexte(*ctx)

    stylesheet := CSS.parse_a_css_style_sheet(*ctx, contenu)
    stylesheet.origine = CSS.OrigineCascade.UserAgent
    CSS.rapporte_propriétés_non_supportées(*ctx, #nom_de_cette_fonction)

    retourne stylesheet
}

crée_arbre_de_disposition :: fonc (page: *PageWeb, largeur: z32, hauteur: z32) -> *CSS.ArbreDeDisposition
{
    document := donne_document(page)
    saufsi document {
        retourne nul
    }

    saufsi document.feuille_de_style_agent {
        document.feuille_de_style_agent = donne_feuille_de_style_défaut()
        tableau_insère_index(*document.feuilles_de_style, document.feuille_de_style_agent, 0)
    }

    retourne CSS.donne_arbre_de_disposition_ajourné(document, largeur, hauteur)
}

donne_arbre_de_disposition :: fonc (page: *PageWeb) -> *CSS.ArbreDeDisposition
{
    document := donne_document(page)
    saufsi document {
        retourne nul
    }

    retourne document.arbre_de_disposition
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom RappelsInterfaceQt
 * \{ */

RappelsInterfaceQt :: struct {
    empl base: RappelsInterface
    fenêtre: *QT_Fenetre_Principale

    files_parallèles: [..]FileParallèle
    files_parallèle_pour_traversable: [..]FileParallèle

    DonnéesTimer :: struct {
        timer: *QT_Timer
        id: z32
    }

    timers: [..]DonnéesTimer
    id_timer: z32
}

crée_rappels_interface_qt :: fonc (fenêtre: *QT_Fenetre_Principale) -> *RappelsInterfaceQt
{
    résultat := loge(RappelsInterfaceQt)
    résultat.fenêtre = fenêtre
    résultat.sur_destruction = rappels_interface_sur_destruction
    résultat.sur_élément_survolé = rappels_interface_sur_élément_survolé
    résultat.sur_requête_rendu = rappels_interface_sur_requête_rendu
    résultat.sur_lancement_requête = rappels_interface_sur_lancement_requête
    résultat.sur_spin_event_loop = rappels_interface_sur_spin_event_loop
    résultat.sur_enfile_une_tâche = rappels_interface_sur_enfile_une_tâche
    résultat.sur_tâche_parallèle = rappels_interface_sur_tâche_parallèle
    résultat.sur_tâche_traversable = rappels_interface_sur_tâche_traversable
    résultat.sur_document_est_prêt = rappels_interface_sur_document_est_prêt
    résultat.sur_est_exécuté_sur_fil_principal = rappels_interface_sur_est_exécuté_sur_fil_principal
    résultat.sur_est_exécuté_en_parallèle = rappels_interface_sur_est_exécuté_en_parallèle
    résultat.sur_est_exécuté_sur_file_parallèle = rappels_interface_sur_est_exécuté_sur_file_parallèle
    résultat.sur_création_file_parallèle_pour_traversable = rappels_interface_crée_file_parallèle_pour_traversable
    résultat.sur_affichage_alerte = rappels_interface_sur_affichage_alerte
    résultat.sur_création_timeout = rappels_interface_sur_création_timeout
    résultat.sur_destruction_timeout = rappels_interface_sur_destruction_timeout
    résultat.sur_request_animation_frame = rappels_interface_sur_request_animation_frame

    // À FAIRE : paramétrise le nombre de threads
    nombres_de_threads := 2

    params: ParamètresFileParallèle
    params.type_évènement = évènement_sur_tâche_parallèle
    params.sur_évènement = file_parallèle_sur_évènement

    pour nombres_de_threads {
        file := crée_file_parallèle(params)
        tableau_ajoute(*résultat.files_parallèles, file)
    }

    retourne résultat
}

file_parallèle_sur_évènement :: fonc (évènement: *QT_Evenement)
{
    algorithm := QT_event_perso_donne_donnees(évènement) comme *Algorithm
    run(algorithm)
}

rappels_interface_sur_destruction :: fonc (base: *RappelsInterface)
{
    rappels := base comme *RappelsInterfaceQt

    pour rappels.files_parallèles {
        QT_thread_quit(it.thread)
        QT_thread_wait(it.thread)
    }

    pour rappels.files_parallèle_pour_traversable {
        QT_thread_quit(it.thread)
        QT_thread_wait(it.thread)
    }

    pour rappels.timers {
        QT_timer_arrete(it.timer)
    }

    déloge(rappels.files_parallèle_pour_traversable)
    déloge(rappels.timers)
    déloge(rappels)
}

rappels_interface_sur_élément_survolé :: fonc (base: *RappelsInterface)
{
    rappels := base comme *RappelsInterfaceQt
    QT_application_poste_evenement(rappels.fenêtre, évènement_sur_survole_élément)
}

rappels_interface_sur_requête_rendu :: fonc (base: *RappelsInterface)
{
    rappels := base comme *RappelsInterfaceQt
    QT_application_poste_evenement(rappels.fenêtre, évènement_sur_requête_rendu)
}

RappelsRequête :: struct {
    empl base: QT_Rappels_Socket

    requête: *Request
    parseuse: ParseuseMessageServeuseHTTP
    response: *Response

    temps_parsage_http: z64
    début_requête: Instantané
}

rappels_interface_sur_lancement_requête :: fonc (base: *RappelsInterface, requête: *Request) -> *Response
{
    rappels := base comme *RappelsInterfaceQt

    rappels_socket := crée_rappel_socket_pour_requête(requête)
    diffère déloge(rappels_socket)

    /* Parent nul pour éviter les problèmes si nous ne sommes dans le fil principal. */
    parent : *QT_Object = nul

    uri := requête.donne_url_courant()
    hôte := uri.host
    port := donne_port_ou_défaut(uri)

    si uri.scheme == "http" {
        prise := QT_cree_ssl_socket_rappels(parent, rappels_socket)
        QT_abstract_socket_connect_to_host(prise, hôte.vers_qt(), port)
    }
    sinon {
        assert(uri.scheme == "https")
        prise := QT_cree_ssl_socket_rappels(parent, rappels_socket)
        QT_ssl_socket_connect_to_host_encrypted(prise, hôte.vers_qt(), port)
    }

    tantque rappels_socket.response == nul {
        rappels_interface_sur_spin_event_loop(rappels)
    }

    retourne rappels_socket.response
}

crée_rappel_socket_pour_requête :: fonc (requête: *Request) -> *RappelsRequête
{
    sur_connexion :: fonc (base: *QT_Rappels_Socket)
    {
        rappels := base comme *RappelsRequête

        rappels.début_requête = maintenant_précis()

        enchaineuse: Enchaineuse
        initialise_enchaineuse(*enchaineuse)
        diffère détruit_tampons(*enchaineuse)

        uri := rappels.requête.donne_url_courant()

        ajoute_au_tampon(*enchaineuse, "GET ")
        sérialise_chemin(*enchaineuse, uri)
        sérialise_requête(*enchaineuse, uri)

        ajoute_au_tampon(*enchaineuse, " HTTP/1.1\r\n")
        ajoute_au_tampon(*enchaineuse, "Host: ")
        ajoute_au_tampon(*enchaineuse, uri.host.Quelque)
        ajoute_au_tampon(*enchaineuse, "\r\n")

        pour rappels.requête.header_list {
            ajoute_au_tampon(*enchaineuse, it.name, ": ", it.value, "\r\n")
        }

        ajoute_au_tampon(*enchaineuse, "Accept-Encoding: identity\r\n")
        ajoute_au_tampon(*enchaineuse, "User-Agent: ", CHAINE_USER_AGENT, "\r\n")
        ajoute_au_tampon(*enchaineuse, "Connection: close\r\n")
        ajoute_au_tampon(*enchaineuse, "\r\n")

        texte_requête := chaine_depuis_enchaineuse(*enchaineuse)
        diffère déloge(texte_requête)

        _ := QT_abstract_socket_write(rappels.socket, texte_requête.pointeur, texte_requête.taille)
        // imprime("Écris : % / %\n", écris, texte_requête.taille)
    }

    sur_erreur :: fonc (base: *QT_Rappels_Socket)
    {
        rappels := base comme *RappelsRequête
        imprime("Erreur\n")
        rappels.response = network_error(rappels.requête)
    }

    sur_prêt_à_lire :: fonc (base: *QT_Rappels_Socket)
    {
        rappels := base comme *RappelsRequête
        parseuse := *rappels.parseuse

        enchaineuse: Enchaineuse
        initialise_enchaineuse(*enchaineuse)
        diffère détruit_tampons(*enchaineuse)

        octets_lu := QT_abstract_socket_read(rappels.socket, *enchaineuse.tampon_courant.données[0], TAILLE_TAMPON_ENCHAINEUSE)

        enchaineuse.tampon_courant.occupé = octets_lu comme z32

        lu := chaine_depuis_enchaineuse(*enchaineuse)

        début_parsage_http := maintenant_précis()
        ajourne_données(parseuse, lu)
        rappels.temps_parsage_http += début_parsage_http.temps_écoulé_microsecondes()

        si message_est_erroné(parseuse) {
            imprime("Erreur de parsage")
            QT_abstract_socket_close(rappels.socket)
            retourne
        }

        saufsi message_prêt_pour_finalisation(parseuse) {
            retourne
        }

        imprime("Temps de parsage HTTP : %\n", rappels.temps_parsage_http)
        imprime("Temps requête         : %\n", rappels.début_requête.temps_écoulé_microsecondes())

        message := finalise_message(parseuse)

        contenu := copie_chaine(message.contenu)
        content_type := donne_type_contenu(*message)
        charset := donne_charset(*message)

        si compare_ascii_insensible_à_la_casse(charset, "ISO-8859-1") {
            nouveau_contenu := convertis_iso_8859_1_vers_utf8(message.contenu)
            déloge(contenu)
            contenu = nouveau_contenu
        }

        response := crée_réponse(rappels.requête)
        response.status = message.status

        body_info := loge(ResponseBodyInfo)
        body_info.decodede_size = message.contenu.taille comme z32
        body_info.content_type = copie_chaine(content_type)

        response.body_info = body_info
        response.body = contenu

        rappels.response = response

        réinitialise(parseuse)

        QT_abstract_socket_close(rappels.socket)
    }

    rappels := loge(RappelsRequête)
    rappels.requête = requête
    rappels.sur_pret_a_lire = sur_prêt_à_lire
    rappels.sur_connexion = sur_connexion
    rappels.sur_erreur = sur_erreur
    retourne rappels
}

rappels_interface_sur_spin_event_loop :: fonc (base: *RappelsInterface @inutilisée)
{
    QT_application_process_events()
}

rappels_interface_sur_enfile_une_tâche :: fonc (base: *RappelsInterface, source: SourceDeTâche, algorithm: *Algorithm)
{
    rappels := base comme *RappelsInterfaceQt

    discr source {
        ManipulationDOM {
            QT_application_poste_evenement_et_donnees(rappels.fenêtre, évènement_sur_tâche_manipulation_dom, algorithm)
        }
        InteractionUtilisateur {
            QT_application_poste_evenement_et_donnees(rappels.fenêtre, évènement_sur_tâche_interaction_utilisateur, algorithm)
        }
        Réseautage {
            QT_application_poste_evenement_et_donnees(rappels.fenêtre, évènement_sur_tâche_réseautage, algorithm)
        }
        NavigationEtTraversée {
            QT_application_poste_evenement_et_donnees(rappels.fenêtre, évènement_sur_tâche_navigation_et_traversée, algorithm)
        }
        Rendu {
            QT_application_poste_evenement_et_donnees(rappels.fenêtre, évènement_sur_tâche_rendu, algorithm)
        }
    }
}

rappels_interface_sur_tâche_parallèle :: fonc (base: *RappelsInterface, algorithm: *Algorithm)
{
    rappels := base comme *RappelsInterfaceQt

    /* Donne la tâche au premier thread qui n'est pas le nôtre. */
    pour rappels.files_parallèles {
        si it.thread != QT_thread_courant() {
            QT_application_poste_evenement_et_donnees(it.filtre_évènement, évènement_sur_tâche_parallèle, algorithm)
            retourne
        }
    }

    panique("pas assez de threads")
}

rappels_interface_sur_tâche_traversable :: fonc (base: *RappelsInterface, traversable: *TraversableNavigable, algorithm: *Algorithm)
{
    rappels := base comme *RappelsInterfaceQt
    file := rappels.files_parallèle_pour_traversable[traversable.index_file_parallèle]
    QT_application_poste_evenement_et_donnees(file.filtre_évènement, évènement_sur_tâche_traversable, algorithm)
}

rappels_interface_sur_document_est_prêt :: fonc (base: *RappelsInterface, document: *Document)
{
    rappels := base comme *RappelsInterfaceQt
    définis_titre_fenêtre(rappels.fenêtre, document)
    rappels_fenêtre := QT_fenetre_principale_donne_rappels(rappels.fenêtre) comme *RappelsFenetrePrincipale
    ajourne_widget_arbre_dom(rappels_fenêtre)

    chaine_url := url_serializer(document.url)
    diffère déloge(chaine_url)

    QT_line_edit_definis_texte(rappels_fenêtre.widgets_page.line_edit, chaine_url.vers_qt())

    page_web := rappels_fenêtre.page_web
    traversable := page_web.navigable

    index_courant := traversable.current_session_history_entry_step comme z64
    index_max := traversable.session_history_entries.taille - 1

    QT_widget_definis_actif(rappels_fenêtre.widgets_page.bouton_avant, index_courant < index_max)
    QT_widget_definis_actif(rappels_fenêtre.widgets_page.bouton_arrière, index_courant > 0)

    QT_widget_ajourne(rappels_fenêtre.widget_rendu)

    init_de(BarreDeDéfilement)(*rappels_fenêtre.page_web.défilement_vertical)

    QT_gui_application_restaure_curseur()
}

rappels_interface_sur_est_exécuté_sur_fil_principal :: fonc (base: *RappelsInterface @inutilisée) -> bool
{
    retourne QT_thread_courant() == QT_application_thread()
}

rappels_interface_sur_est_exécuté_en_parallèle :: fonc (base: *RappelsInterface @inutilisée) -> bool
{
    retourne QT_thread_courant() != QT_application_thread()
}

rappels_interface_sur_est_exécuté_sur_file_parallèle :: fonc (base: *RappelsInterface, traversable: *TraversableNavigable) -> bool
{
    rappels := base comme *RappelsInterfaceQt
    file := rappels.files_parallèle_pour_traversable[traversable.index_file_parallèle]
    retourne QT_thread_courant() == file.thread
}

rappels_interface_crée_file_parallèle_pour_traversable :: fonc (base: *RappelsInterface) -> z64
{
    rappels := base comme *RappelsInterfaceQt

    résultat := rappels.files_parallèle_pour_traversable.taille

    params: ParamètresFileParallèle
    params.type_évènement = évènement_sur_tâche_traversable
    params.sur_évènement = file_parallèle_sur_évènement

    file := crée_file_parallèle(params)
    tableau_ajoute(*rappels.files_parallèle_pour_traversable, file)

    retourne résultat
}

rappels_interface_sur_affichage_alerte :: fonc (base: *RappelsInterface, message: DOMString)
{
    rappels := base comme *RappelsInterfaceQt

    chn_message := converti_vers_chaine(message.donne_chaine_utf16())
    diffère déloge(chn_message)

    _ := QT_message_box_affiche_avertissement(rappels.fenêtre, vers_qt("Alerte"), vers_qt(chn_message), QT_StandardButton.OK)
}

rappels_interface_sur_création_timeout :: fonc (base: *RappelsInterface, algorithm: *Algorithm, time_out: z32, se_répète: bool) -> z32
{
    RappelTimer :: struct {
        empl base: QT_Rappels_Timer
        algorithm: *Algorithm
    }

    sur_timeout :: fonc (base: *QT_Rappels_Timer)
    {
        rappel := base comme *RappelTimer
        si rappel.algorithm.sur_run {
            rappel.algorithm.sur_run(rappel.algorithm)
        }
    }

    rappel_timer := QT_loge_rappel(RappelTimer)
    rappel_timer.algorithm = algorithm
    rappel_timer.sur_timeout = sur_timeout

    timer := QT_cree_timer(rappel_timer)
    QT_timer_definis_se_repete(timer, se_répète)

    rappels := base comme *RappelsInterfaceQt

    id := rappels.id_timer
    rappels.id_timer += 1

    données := tableau_ajoute_élément(*rappels.timers)
    données.timer = timer
    données.id = id

    QT_timer_debute(timer, time_out)

    retourne id
}

rappels_interface_sur_destruction_timeout :: fonc (base: *RappelsInterface, id: z32)
{
    rappels := base comme *RappelsInterfaceQt

    pour rappels.timers {
        si it.id == id {
            QT_timer_arrete(it.timer)
            tableau_supprime_index(*rappels.timers, index_it)
            retourne
        }
    }
}

rappels_interface_sur_request_animation_frame :: fonc (base: *RappelsInterface)
{
    rappels := base comme *RappelsInterfaceQt
    window := QT_widget_donne_window_handle(rappels.fenêtre)
    QT_window_request_update(window)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Conversion jeu de caractères.
 * \{ */

/* https://www.charset.org/charsets/iso-8859-1 */
convertis_iso_8859_1_vers_utf8 :: fonc (texte: chaine) -> chaine
{
    taille_résultat := texte.taille

    pour texte {
        si it < 0 {
            taille_résultat += 1
        }
    }

    si taille_résultat == texte.taille {
        retourne copie_chaine(texte)
    }

    résultat := loge_chaine(taille_résultat)

    ptr_sortie := résultat.pointeur comme *n8

    pour texte {
        si it >= 0 {
            mémoire(ptr_sortie) = it comme n8
            ptr_sortie += 1
            continue
        }

        naturel := it comme n8

        si 0xA0 <= naturel <= 0xBF {
            mémoire(ptr_sortie) = 0xC2
            ptr_sortie += 1
            mémoire(ptr_sortie) = naturel
            ptr_sortie += 1
        }
        sinon si naturel >= 0xA0 {
            mémoire(ptr_sortie) = 0xC3
            ptr_sortie += 1
            mémoire(ptr_sortie) = naturel - 0x40
            ptr_sortie += 1
        }
        sinon {
            imprime("%\n", naturel)
            assert(faux)
        }
    }

    retourne résultat
}

/** \} */
