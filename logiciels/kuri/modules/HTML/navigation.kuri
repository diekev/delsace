importe Ensemble
importe Fondation
importe Internet
importe MIME

/* https://html.spec.whatwg.org/multipage/browsers.html#cross-origin-opener-policy-value */
CrossOriginOpenerPolicyValue :: énum n8 {
    UnsafeNone
    SameOriginAllowPopup
    SameOrigin
    SameOriginPlusCEOP
}

/* https://html.spec.whatwg.org/multipage/browsers.html#cross-origin-opener-policy */
CrossOriginOpenerPolicy :: struct {
    value: CrossOriginOpenerPolicyValue
    reporting_endpoint: Optionnel(chaine)
    report_only_value: CrossOriginOpenerPolicyValue
    report_only_reporting_endpoint: Optionnel(chaine)
}

/* https://html.spec.whatwg.org/multipage/browsers.html#coop-enforcement-result */
CrossOriginOpenerPolicyEnforcementResult :: struct {
    needs_a_browsing_context_group_switch := faux
    would_need_a_browsing_context_group_switch_due_to_report_only := faux
    current_context_is_navigation_source := faux
    url: URI
    origin: Origin
    cross_origin_opener_policy: CrossOriginOpenerPolicy
}

/* https://w3c.github.io/navigation-timing/#sec-performance-navigation-types */
NavigationTimingType :: énum {
    navigate
    reload
    back_forward
    prerender
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#navigation-id */
NavigationID :: UUID

OngoingNavigationType :: union {
    NavigationID: NavigationID
    Chaine: chaine
}

est_nul :: fonc (ongoing: OngoingNavigationType) -> bool
{
    discr ongoing {
        NavigationID {
            retourne faux
        } 
        Chaine {
            retourne faux
        }
        sinon {}
    }
    retourne vrai
}

opérateur == :: fonc (a: OngoingNavigationType, b: OngoingNavigationType) -> bool
{
    discr a {
        NavigationID(id) {
            retourne b == id
        }
        Chaine(c) {
            retourne b == c
        }
        sinon {
            retourne faux
        }
    }
}

opérateur != :: fonc (a: OngoingNavigationType, b: OngoingNavigationType) -> bool
{
    retourne !(a == b)
}

opérateur == :: fonc (ongoing: OngoingNavigationType, navigation_id: NavigationID) -> bool
{
    discr ongoing {
        NavigationID(id) {
            retourne id == navigation_id
        }
        sinon {
            retourne faux
        }
    }
}

opérateur != :: fonc (ongoing: OngoingNavigationType, navigation_id: NavigationID) -> bool
{
    retourne !(ongoing == navigation_id)
}

opérateur == :: fonc (ongoing: OngoingNavigationType, chn: chaine) -> bool
{
    discr ongoing {
        Chaine(c) {
            retourne c == chn
        }
        sinon {
            retourne faux
        }
    }
}

opérateur != :: fonc (ongoing: OngoingNavigationType, chn: chaine) -> bool
{
    retourne !(ongoing == chn)
}

/* must be an algorithm accepting a Document */
CommitEarlyHints :: struct {
    sur_rappel: fonc(*CommitEarlyHints, *Document)(rien)
    sur_destruction: fonc (*CommitEarlyHints)(rien)
}

run :: fonc (commit_early_hints: *CommitEarlyHints, document: *Document)
{
    si commit_early_hints.sur_rappel {
        commit_early_hints.sur_rappel(commit_early_hints, document)
    }
    si commit_early_hints.sur_destruction {
        commit_early_hints.sur_destruction(commit_early_hints)
    }
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#navigation-params */
NavigationParams :: struct {
    id: Optionnel(NavigationID)
    navigable: *Navigable
    request: *Request
    response: *Response
    fetch_controller: *FetchController
    /* null or an algorithm accepting a Document, once it has been created */
    commit_early_hints: *CommitEarlyHints
    
    COOP_enforcement_result: CrossOriginOpenerPolicyEnforcementResult
    // reserved environment
    //    null or an environment reserved for the new Document
    
    origin: Origin
    
    //policy container
    //  a policy container to use for the new Document

    final_sandboxing_flag: SandboxingFlags
    cross_origin_opener_policy: CrossOriginOpenerPolicy
    
    navigation_timing_type: NavigationTimingType
    
    about_base_URL: Optionnel(URI)
}

/* À FAIRE https://html.spec.whatwg.org/multipage/browsing-the-web.html#non-fetch-scheme-navigation-params */
est_non_fetch_scheme :: fonc (navigation_params: *NavigationParams @inutilisée) -> bool
{
    retourne faux
}

est_navigation_params :: fonc (navigation_params: *NavigationParams @inutilisée) -> bool
{
    retourne vrai
}

détruit_navigation_params :: fonc (navigation_params: *NavigationParams)
{
    détruit_fetch_controller(navigation_params.fetch_controller)
    détruit_response(navigation_params.response)
    détruit_request(navigation_params.request)
    déloge(navigation_params)
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#source-snapshot-params */
SourceSnapshotParams :: struct {
    has_transient_activation: bool
    sandboxing_flags: SandboxingFlags
    allows_downloading: bool
    fetch_client: *rien // À FAIRE(settings object)
    source_policy_container: *rien // À FAIRE
}

snapshot_source_snapshot_params :: fonc (source_document: *Document @inutilisée) -> SourceSnapshotParams
{
    résultat: SourceSnapshotParams
    imprime("À FAIRE : [%]\n", #nom_de_cette_fonction)
    // has transient activation = true if sourceDocument's relevant global object has transient activation; otherwise false
    // sandboxing flags = sourceDocument's active sandboxing flag set
    // allows downloading = false if sourceDocument's active sandboxing flag set has the sandboxed downloads browsing context flag set; otherwise true
    // fetch client = sourceDocument's relevant settings object
    // source policy container = sourceDocument's policy container
    retourne résultat
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#target-snapshot-params */
TargetSnapshotParams :: struct {
    sandboxing_flags: SandboxingFlags
}

snapshot_target_snapshot_params :: fonc (target_navigable: *Navigable) -> TargetSnapshotParams
{
    résultat: TargetSnapshotParams
    résultat.sandboxing_flags = détermine_drapeaux_sanboxing(target_navigable.donne_active_browsing_context(), target_navigable.donne_container())
    retourne résultat
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#navigationhistorybehavior */
NavigationHistoryBehavior :: énum {
    PUSH
    REPLACE
    AUTO
}

/* https://html.spec.whatwg.org/multipage/nav-history-apis.html#navigationtype */
NavigationType :: énum {
    push
    replace
    reload
    traverse
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#the-navigation-must-be-a-replace */
navigation_must_be_a_replace :: fonc (url: &URI, document: *Document) -> bool
{
    retourne document.is_initial_about_blank || url.schéma == "javascript"
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#user-navigation-involvement */
UserNavigationInvolvement :: énum {
    BrowserUI
    Activation
    None
}

/* ------------------------------------------------------------------------- */
/** \nom 7.4.2.2 Beginning navigation
 * https://html.spec.whatwg.org/multipage/browsing-the-web.html#beginning-navigation
 * \{ */

/*
To navigate a

navigable navigable
URL url
Document sourceDocument, 
optional POST resource, string, or null documentResource (default null)
an optional response-or-null response (default null)
an optional boolean exceptionsEnabled (default false)
an optional NavigationHistoryBehavior historyHandling (default "auto")
an optional serialized state-or-null navigationAPIState (default null)
an optional entry list or null formDataEntryList (default null)
an optional referrer policy referrerPolicy (default the empty string)
and an optional user navigation involvement userInvolvement (default "none"):
*/
navigate :: fonc (user_agent: *UserAgent,
                  navigable: *Navigable,
                  url: &URI,
                  source_document: *Document,
                  history_handling := NavigationHistoryBehavior.AUTO)
{
    // 1. Let cspNavigationType be "form-submission" if formDataEntryList is non-null; otherwise "other".

    // 2. Let sourceSnapshotParams be the result of snapshotting source snapshot params given sourceDocument.
    source_snapshot_params := snapshot_source_snapshot_params(source_document)

    // 3. Let initiatorOriginSnapshot be sourceDocument's origin.
    initiator_origin_snapshot := source_document.origin

    // 4. Let initiatorBaseURLSnapshot be sourceDocument's document base URL.

    // 5. If sourceDocument's node navigable is not allowed by sandboxing to navigate navigable given sourceSnapshotParams, then:

        // 1. If exceptionsEnabled is true, then throw a "SecurityError" DOMException.

        // 2. Return.

    // 6. Let navigationId be the result of generating a random UUID. [WEBCRYPTO]
    navigation_id := génère_un_uuid_aléatoire()

    // 7. If the surrounding agent is equal to navigable's active document's relevant agent, then continue these steps. Otherwise, queue a global task on the navigation and traversal task source given navigable's active window to continue these steps.

    // 8. If navigable's active document's unload counter is greater than 0, then
    //    invoke WebDriver BiDi navigation failed with a WebDriver BiDi navigation
    //    status whose id is navigationId, status is "canceled", and url is url, and return.
    si navigable.donne_active_document().unload_counter > 0 {
        navigation_status: WebDriverNavigationStatus
        navigation_status.id = navigation_id
        navigation_status.url = url
        navigation_status.status = "canceled"
        webdriver_bidi_navigation_failed(navigable, *navigation_status)
    }

    // 9. Let container be navigable's container.

    // 10. If container is an iframe element and will lazy load element steps given container returns true, then stop intersection-observing a lazy loading element container and set container's lazy load resumption steps to null.

    // 11. If historyHandling is "auto", then:
    si history_handling == NavigationHistoryBehavior.AUTO {
        active_document := navigable.donne_active_document()

        chn_url := recompose_uri(*url)
        diffère déloge(chn_url)

        chn_url_active_document := recompose_uri(*active_document.url)
        diffère déloge(chn_url_active_document)

        // 1. If url equals navigable's active document's URL,
        //    and initiatorOriginSnapshot is same origin with targetNavigable's active document's origin,
        //    then set historyHandling to "replace".
        si chn_url == chn_url_active_document && sont_même_origine(initiator_origin_snapshot, active_document.origin) {
            history_handling = NavigationHistoryBehavior.REPLACE
        }
        // 2. Otherwise, set historyHandling to "push".
        sinon {
            history_handling = NavigationHistoryBehavior.PUSH
        }
    }

    // 12. If the navigation must be a replace given url and navigable's active document, then set historyHandling to "replace".
    si navigation_must_be_a_replace(url, navigable.donne_active_document()) {
        history_handling = NavigationHistoryBehavior.REPLACE
    }

    // 13. If all of the following are true:
    //     documentResource is null;
    //     response is null;
    //     url equals navigable's active session history entry's URL with exclude fragments set to true; and
    //     url's fragment is non-null,
    //     then:

        // 1. Navigate to a fragment given navigable, url, historyHandling, userInvolvement, navigationAPIState, and navigationId.

        // 2. Return.

    // 14. If navigable's parent is non-null, then set navigable's is delaying load events to true.
    si navigable.parent {
        navigable.is_delaying_load_events = vrai
    }

    // 15. Let targetBrowsingContext be navigable's active browsing context.
    target_browsing_context := navigable.donne_active_browsing_context()

    // 16. Let targetSnapshotParams be the result of snapshotting target snapshot params given navigable.
    target_snapshot_params := snapshot_target_snapshot_params(navigable)

    // 17. Invoke WebDriver BiDi navigation started with targetBrowsingContext,
    //     and a new WebDriver BiDi navigation status whose id is navigationId,
    //     status is "pending", and url is url.
    navigation_status: WebDriverNavigationStatus
    navigation_status.id = navigation_id
    navigation_status.url = url
    navigation_status.status = "pending"
    webdriver_bidi_navigation_started(target_browsing_context, *navigation_status)

    // 18. If navigable's ongoing navigation is "traversal", then:
    si navigable.ongoing_navigation == "traversal" {
        // 1. Invoke WebDriver BiDi navigation failed with targetBrowsingContext and a new WebDriver BiDi navigation status whose id is navigationId, status is "canceled", and url is url.
        navigation_status.id = navigation_id
        navigation_status.url = url
        navigation_status.status = "canceled"
        webdriver_bidi_navigation_failed(target_browsing_context, *navigation_status)

        // 2. Return.
        retourne
    }

    // 19. Set the ongoing navigation for navigable to navigationId.
    navigable.définis_ongoing_navigation(navigation_id)

    // 20. If url's scheme is "javascript", then:

        // 1. Queue a global task on the navigation and traversal task source given navigable's active window to navigate to a javascript: URL given navigable, url, historyHandling, initiatorOriginSnapshot, and cspNavigationType.

        // 2. Return.

    // 21. If all of the following are true:
    //     userInvolvement is not "browser UI";
    //     navigable's active document's origin is same origin-domain with sourceDocument's origin;
    //     navigable's active document's is initial about:blank is false; and
    //     url's scheme is a fetch scheme,
    //     then:

        // 1. Let navigation be navigable's active window's navigation API.

        // 2. Let entryListForFiring be formDataEntryList if documentResource is a POST resource; otherwise, null.

        // 3. Let navigationAPIStateForFiring be navigationAPIState if navigationAPIState is not null; otherwise, StructuredSerializeForStorage(undefined).

        // 4. Let continue be the result of firing a push/replace/reload navigate event at navigation with navigationType set to historyHandling, isSameDocument set to false, userInvolvement set to userInvolvement, formDataEntryList set to entryListForFiring, destinationURL set to url, and navigationAPIState set to navigationAPIStateForFiring.

        // 5. If continue is false, then return.

    // 22. In parallel, run these steps:
    Tâche :: struct {
        empl base: Algorithm

        user_agent: *UserAgent
        navigable: *Navigable
        url: URI
        source_snapshot_params: SourceSnapshotParams
        target_snapshot_params: TargetSnapshotParams
        history_handling: NavigationHistoryBehavior
        navigation_id: Optionnel(NavigationID)
        target_browsing_context: *BrowsingContext
    }

    sur_run :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche

        user_agent := tâche.user_agent
        navigable := tâche.navigable
        url := tâche.url
        source_snapshot_params_ := tâche.source_snapshot_params
        target_snapshot_params_ := tâche.target_snapshot_params
        history_handling := tâche.history_handling
        navigation_id_ := tâche.navigation_id
        target_browsing_context := tâche.target_browsing_context

        navigate_parallel_steps(user_agent, navigable, url, source_snapshot_params_, target_snapshot_params_, history_handling, navigation_id_, target_browsing_context)
    }

    sur_destruction :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche
        déloge(tâche)
    }

    tâche := loge(Tâche)
    tâche.sur_run = sur_run
    tâche.sur_destruction = sur_destruction
    tâche.user_agent = user_agent
    tâche.navigable = navigable
    tâche.url = url
    tâche.source_snapshot_params = source_snapshot_params
    tâche.target_snapshot_params = target_snapshot_params
    tâche.history_handling = history_handling
    tâche.navigation_id = navigation_id
    tâche.target_browsing_context = target_browsing_context

    user_agent.lance_en_parallèle(tâche)
}

navigate_parallel_steps :: fonc (user_agent: *UserAgent,
                                 navigable: *Navigable,
                                 url: &URI,
                                 source_snapshot_params: &SourceSnapshotParams,
                                 target_snapshot_params: &TargetSnapshotParams,
                                 history_handling: NavigationHistoryBehavior,
                                 navigation_id: NavigationID,
                                 target_browsing_context: *BrowsingContext)
{
    // 1. Let unloadPromptCanceled be the result of checking if unloading is
    //    canceled for navigable's active document's inclusive descendant navigables.

    // 2. If unloadPromptCanceled is true, or navigable's ongoing navigation is no longer navigationId, then:
    si navigable.ongoing_navigation != navigation_id {
        // 1. Invoke WebDriver BiDi navigation failed with targetBrowsingContext
        //    and a new WebDriver BiDi navigation status whose id is navigationId,
        //    status is "canceled", and url is url.
        navigation_status: WebDriverNavigationStatus
        navigation_status.id = navigation_id
        navigation_status.url = url
        navigation_status.status = "canceled"
        webdriver_bidi_navigation_failed(target_browsing_context, *navigation_status)

        // 2. Abort these steps.
        retourne
    }

    // 3. Queue a global task on the navigation and traversal task source given navigable's active window to abort a document and its descendants given navigable's active document.

    // À FAIRE : 4. Let documentState be a new document state with
    //     request referrer policy    referrerPolicy
    //     initiator origin    initiatorOriginSnapshot
    //     resource    documentResource
    //     navigable target name    navigable's target name
    document_state := loge(DocumentState)

    // 5. If url matches about:blank or is about:srcdoc, then:

        // 1. Set documentState's origin to initiatorOriginSnapshot.

        // 2. Set documentState's about base URL to initiatorBaseURLSnapshot.

    // 6. Let historyEntry be a new session history entry, with its URL set to url and its document state set to documentState.
    history_entry := loge(SessionHistoryEntry)
    history_entry.url = url
    history_entry.document_state = document_state

    // 7. Let navigationParams be null.
    navigation_params: *NavigationParams

    // 8. If response is non-null:

        // 1. Let policyContainer be the result of determining navigation params policy container given response's URL, null, a clone of the sourceDocument's policy container, navigable's container document's policy container, and null.

        // 2. Let finalSandboxFlags be the union of targetSnapshotParams's sandboxing flags and policyContainer's CSP list's CSP-derived sandboxing flags.

        // 3. Let responseOrigin be the result of determining the origin given response's URL, finalSandboxFlags, and documentState's initiator origin.

        // 4. Let coop be a new cross-origin opener policy.

        // 5. Let coopEnforcementResult be a new cross-origin opener policy enforcement result with
        //     url    response's URL
        //     origin     responseOrigin
        //     cross-origin opener policy     coop

        // 6. Set navigationParams to a new navigation params, with
        //     id     navigationId
        //     navigable    navigable
        //     request    null
        //     response    response
        //     fetch controller    null
        //     commit early hints    null
        //     COOP enforcement result    coopEnforcementResult
        //     reserved environment    null
        //     origin    responseOrigin
        //     policy container    policyContainer
        //     final sandboxing flag set    finalSandboxFlags
        //     cross-origin opener policy    coop
        //     navigation timing type    "navigate"
        //     about base URL    documentState's about base URL

    // 9. Attempt to populate the history entry's document for historyEntry, given
    //    navigable, "navigate", sourceSnapshotParams, targetSnapshotParams, navigationId, navigationParams, cspNavigationType, with allowPOST set to true
    //    and completionSteps set to the following step:
    //        1. Append session history traversal steps to navigable's traversable to finalize a cross-document navigation given navigable, historyHandling, and historyEntry.
    Tâche :: struct {
        empl base: Algorithm

        user_agent: *UserAgent
        navigable: *Navigable
        history_handling: NavigationHistoryBehavior
        history_entry: *SessionHistoryEntry
    }

    tâche_run :: fonc (base: *Algorithm)
    {
        steps := base comme *Tâche
        finalize_a_cross_document_navigation(steps.user_agent, steps.navigable, steps.history_handling, steps.history_entry)
    }

    tâche_détruit :: fonc (base: *Algorithm)
    {
        steps := base comme *Tâche
        déloge(steps)
    }

    tâche := loge(Tâche)
    tâche.user_agent = user_agent
    tâche.navigable = navigable
    tâche.history_handling = history_handling
    tâche.history_entry = history_entry
    tâche.sur_run = tâche_run
    tâche.sur_destruction = tâche_détruit

    completion_steps := crée_tâche_pour_traversable(user_agent, tâche, navigable.donne_traversable_navigable())

    history_entry_population_params: HistoryEntryPopulationParams
    history_entry_population_params.user_agent = user_agent
    history_entry_population_params.entry = history_entry
    history_entry_population_params.navigable = navigable
    history_entry_population_params.nav_timing_type =  NavigationTimingType.navigate
    history_entry_population_params.source_snapshot_params = source_snapshot_params
    history_entry_population_params.target_snapshot_params = target_snapshot_params
    history_entry_population_params.navigation_id = navigation_id
    history_entry_population_params.navigation_params = navigation_params
    history_entry_population_params.completion_steps = completion_steps

    attempt_to_populate_the_history_entry_document(*history_entry_population_params)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 7.4.2.3 Ending Navigation
 * \{ */

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#finalize-a-cross-document-navigation */
finalize_a_cross_document_navigation :: fonc (user_agent: *UserAgent, navigable: *Navigable, history_handling: NavigationHistoryBehavior, history_entry: *SessionHistoryEntry)
{
    traversable := navigable.donne_traversable_navigable()

    // 1. Assert: this is running on navigable's traversable navigable's session history traversal queue.
    assert(user_agent.est_exécuté_sur_file_parallèle(traversable))

    // 2. Set navigable's is delaying load events to false.
    navigable.is_delaying_load_events = faux

    // 3. If historyEntry's document is null, then return.
    si history_entry.donne_document() == nul {
        retourne
    }

    // À FAIRE : 4. If all of the following are true:
    //    navigable's parent is null;
    //    historyEntry's document's browsing context is not an auxiliary browsing context whose opener browsing context is non-null; and
    //    historyEntry's document's origin is not navigable's active document's origin,
    // then set historyEntry's document state's navigable target name to the empty string.

    // 5. Let entryToReplace be navigable's active session history entry if historyHandling is "replace", otherwise null.
    entry_to_replace: *SessionHistoryEntry
    si history_handling == NavigationHistoryBehavior.REPLACE {
        entry_to_replace = navigable.active_session_history_entry
    }

    // 6. Let traversable be navigable's traversable navigable.
    // Fait plus haut.

    // 7. Let targetStep be null.
    target_step: Optionnel(n32) 

    // 8. Let targetEntries be the result of getting session history entries for navigable.
    target_entries := donne_session_history_entries(user_agent, navigable)

    // 9. If entryToReplace is null, then:
    si entry_to_replace == nul {
        // À FAIRE : 1. Clear the forward session history of traversable.

        // 2. Set targetStep to traversable's current session history step + 1.
        target_step = traversable.current_session_history_entry_step + 1

        // 3. Set historyEntry's step to targetStep.
        history_entry.step = target_step.Quelque

        // 4. Append historyEntry to targetEntries.
        tableau_ajoute(target_entries, history_entry)
    }
    // Otherwise:
    sinon {
        // 1. Replace entryToReplace with historyEntry in targetEntries.
        tableau_remplace(target_entries, entry_to_replace, history_entry)

        // 2. Set historyEntry's step to entryToReplace's step.
        history_entry.step = entry_to_replace.step

        // À FAIRE 3. If historyEntry's document state's origin is same origin with entryToReplace's document state's origin,
        //    then set historyEntry's navigation API key to entryToReplace's navigation API key.

        // 4. Set targetStep to traversable's current session history step.
        target_step = traversable.current_session_history_entry_step
    }

    // 10. Apply the push/replace history step targetStep to traversable given historyHandling.
    _ := apply_the_push_replace_history_step(user_agent, target_step, traversable, history_handling)

    si user_agent {
        document := history_entry.donne_document()
        user_agent.document_est_prêt(document)
    }
}

/** } */

/* ------------------------------------------------------------------------- */
/** \nom 7.4.3 Reloading and traversing
 * https://html.spec.whatwg.org/multipage/browsing-the-web.html#reloading-and-traversing
 * \{ */

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#reload */
reload :: fonc (user_agent: *UserAgent, navigable: *Navigable, user_involvement := UserNavigationInvolvement.None)
{
    // If userInvolvement is not "browser UI", then:
    si user_involvement != UserNavigationInvolvement.BrowserUI {
        panique("non-implémenté")
        // 1. Let navigation be navigable's active window's navigation API.

        // 2. Let destinationNavigationAPIState be navigable's active session history entry's navigation API state.

        // 3. If navigationAPIState is not null, then set destinationNavigationAPIState to navigationAPIState.

        // 4. Let continue be the result of firing a push/replace/reload navigate event at navigation with navigationType set to "reload", isSameDocument set to false, userInvolvement set to userInvolvement, destinationURL set to navigable's active session history entry's URL, and navigationAPIState set to destinationNavigationAPIState.

        // 5. If continue is false, then return.
    }

    // 2. Set navigable's active session history entry's document state's reload pending to true.
    navigable.active_session_history_entry.document_state.reload_pending = vrai

    // 3. Let traversable be navigable's traversable navigable.
    traversable := navigable.donne_traversable_navigable()

    // 4. Append the following session history traversal steps to traversable:
    tâche := crée_tâche_pour_reload_history_step(user_agent, traversable)
    user_agent.lance_sur_file_parallèle(traversable, tâche)
}

crée_tâche_pour_reload_history_step :: fonc (user_agent: *UserAgent, traversable: *TraversableNavigable) -> *Algorithm
{
    Tâche :: struct {
        empl base: Algorithm

        user_agent: *UserAgent
        traversable: *TraversableNavigable
    }

    sur_run :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche

        // 1. Apply the reload history step to traversable.
        _ := apply_the_reload_history_step(tâche.user_agent, tâche.traversable)

        document := tâche.traversable.active_session_history_entry.donne_document()
        tâche.user_agent.document_est_prêt(document)
    }

    sur_destruction :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche
        déloge(tâche)
    }

    tâche := loge(Tâche)
    tâche.user_agent = user_agent
    tâche.traversable = traversable
    tâche.sur_run = sur_run
    tâche.sur_destruction = sur_destruction
    retourne tâche
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#traverse-the-history-by-a-delta */
traverse_the_history_by_a_delta :: fonc (user_agent: *UserAgent, traversable: *TraversableNavigable, delta: z32, source_document : *Document = nul)
{
    // 1. Let sourceSnapshotParams and initiatorToCheck be null.
    source_snapshot_params: *SourceSnapshotParams
    initiator_to_check: *Navigable

    // 2. Let userInvolvement be "browser UI".
    user_involvement := UserNavigationInvolvement.BrowserUI

    // 3. If sourceDocument is given, then:
    si source_document {
        // À FAIRE : 1. Set sourceSnapshotParams to the result of snapshotting source snapshot params given sourceDocument.

        // 2. Set initiatorToCheck to sourceDocument's node navigable.
        initiator_to_check = source_document.donne_node_navigable()

        // 3. Set userInvolvement to "none".
        user_involvement = UserNavigationInvolvement.None
    }

    // 4. Append the following session history traversal steps to traversable:
    tâche := crée_tâche_pour_traverse_history_step(user_agent, traversable, source_snapshot_params, initiator_to_check, user_involvement, delta)
    user_agent.lance_sur_file_parallèle(traversable, tâche)
}

crée_tâche_pour_traverse_history_step :: fonc (user_agent: *UserAgent,
                                               traversable: *TraversableNavigable,                           
                                               source_snapshot_params: *SourceSnapshotParams,
                                               initiator_to_check: *Navigable,
                                               user_involvement: UserNavigationInvolvement,
                                               delta: z32) -> *Algorithm
{
    Tâche :: struct {
        empl base: Algorithm

        user_agent: *UserAgent
        traversable: *TraversableNavigable
        source_snapshot_params: *SourceSnapshotParams
        initiator_to_check: *Navigable
        user_involvement: UserNavigationInvolvement
        delta: z32
    }

    sur_run :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche

        user_agent := tâche.user_agent
        traversable := tâche.traversable

        // 1. Let allSteps be the result of getting all used history steps for traversable.
        all_steps := get_all_used_history_steps(user_agent, traversable)

        // 2. Let currentStepIndex be the index of traversable's current session history step within allSteps.
        current_step_index : n32 = 0
        pour all_steps {
            si it == traversable.current_session_history_entry_step {
                current_step_index = index_it comme n32
                arrête
            }
        }

        // 3. Let targetStepIndex be currentStepIndex plus delta.
        target_step_index := (current_step_index comme z32 + tâche.delta)

        // 4. If allSteps[targetStepIndex] does not exist, then abort these steps.
        si target_step_index < 0 || target_step_index >= all_steps.taille {
            retourne
        }

        // 5. Apply the traverse history step allSteps[targetStepIndex] to traversable, given sourceSnapshotParams, initiatorToCheck, and userInvolvement.
        _ := apply_the_traverse_history_step(user_agent, all_steps[target_step_index], traversable, tâche.source_snapshot_params, tâche.initiator_to_check, tâche.user_involvement)

        document := tâche.traversable.active_session_history_entry.donne_document()
        tâche.user_agent.document_est_prêt(document)
    }

    sur_destruction :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche
        déloge(tâche)
    }

    tâche := loge(Tâche)
    tâche.user_agent = user_agent
    tâche.traversable = traversable
    tâche.source_snapshot_params = source_snapshot_params
    tâche.initiator_to_check = initiator_to_check
    tâche.user_involvement = user_involvement
    tâche.delta = delta
    tâche.sur_run = sur_run
    tâche.sur_destruction = sur_destruction
    retourne tâche
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 7.4.5
 * \{ */

HistoryEntryPopulationParams :: struct {
    user_agent: *UserAgent
    entry: *SessionHistoryEntry
    navigable: *Navigable
    nav_timing_type: NavigationTimingType
    source_snapshot_params: SourceSnapshotParams
    target_snapshot_params: TargetSnapshotParams
    navigation_id: Optionnel(NavigationID)
    navigation_params : *NavigationParams = nul
    csp_navigation_type := "other"
    allow_post := faux
    completion_steps : *Algorithm = nul
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#attempt-to-populate-the-history-entry's-document */
attempt_to_populate_the_history_entry_document :: fonc (params: *HistoryEntryPopulationParams)
{
    user_agent := params.user_agent
    entry := params.entry
    navigable := params.navigable
    nav_timing_type := params.nav_timing_type
    source_snapshot_params := params.source_snapshot_params
    target_snapshot_params := params.target_snapshot_params
    navigation_id := params.navigation_id
    navigation_params := params.navigation_params
    completion_steps := params.completion_steps

    // 1. Assert: this is running in parallel.
    assert(user_agent.est_exécuté_en_parallèle())

    // 2. Assert: if navigationParams is non-null, then navigationParams's response is non-null.

    // 3. Let currentBrowsingContext be navigable's active browsing context.

    // 4. Let documentResource be entry's document state's resource.

    // 5. If navigationParams is null, then:
    si navigation_params == nul {
        // 1. If documentResource is a string, then set navigationParams to the result of creating navigation params from a srcdoc resource given entry, navigable, targetSnapshotParams, navigationId, and navTimingType.

        // 2. Otherwise, if all of the following are true:
        //     entry's URL's scheme is a fetch scheme; and
        //     documentResource is null, or allowPOST is true and documentResource's request body is not failure,

        // then set navigationParams to the result of creating navigation params by fetching given entry, navigable, sourceSnapshotParams, targetSnapshotParams, cspNavigationType, navigationId, and navTimingType.
        navigation_params = create_navigation_params_by_fetching(user_agent, entry, navigable, source_snapshot_params, target_snapshot_params, navigation_id, nav_timing_type)

        // 3. Otherwise, if entry's URL's scheme is not a fetch scheme, then set navigationParams to a new non-fetch scheme navigation params, with
        //     id  navigationId
        //     navigable   navigable
        //     URL entry's URL
        //     target snapshot sandboxing flags    targetSnapshotParams's sandboxing flags
        //     source snapshot has transient activation    sourceSnapshotParams's has transient activation
        //     initiator origin    entry's document state's initiator origin
        //     navigation timing type  navTimingType
    }

    // 6. Queue a global task on the navigation and traversal task source, given navigable's active window, to run these steps:
    Tâche :: struct {
        empl base: Algorithm

        user_agent: *UserAgent
        completion_steps: *Algorithm
        entry: *SessionHistoryEntry
        navigation_params: *NavigationParams
        source_snapshot_params: SourceSnapshotParams
        navigable: *Navigable
        navigation_id: Optionnel(NavigationID)
    }

    sur_run :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche

        navigation_params := tâche.navigation_params
        diffère détruit_navigation_params(navigation_params)

        entry := tâche.entry
        completion_steps := tâche.completion_steps
        source_snapshot_params := tâche.source_snapshot_params
        user_agent := tâche.user_agent
        navigable := tâche.navigable
        navigation_id := tâche.navigation_id

        // 1. If navigable's ongoing navigation no longer equals navigationId, then run completionSteps and abort these steps.
        si (!navigation_id.possède_valeur() && !est_nul(navigable.ongoing_navigation)) || (navigable.ongoing_navigation != navigation_id) {
            run(completion_steps)
            retourne
        }

        // 2. Let saveExtraDocumentState be true.
        save_extra_document_state := vrai

        // 3. If navigationParams is a non-fetch scheme navigation params, then:
        si navigation_params != nul && navigation_params.est_non_fetch_scheme() {
            panique("non-implémenté")

            // 1. Set entry's document state's document to the result of running attempt to create a non-fetch scheme document given navigationParams.

            // 2. Set saveExtraDocumentState to false.
        }
        // 4. Otherwise, if any of the following are true:
        //    navigationParams is null;
        //    À FAIRE : the result of should navigation response to navigation request of type in target be blocked by Content Security Policy? given navigationParams's request, navigationParams's response, navigationParams's policy container's CSP list, cspNavigationType, and navigable is "Blocked";
        //    À FAIRE : navigationParams's reserved environment is non-null and the result of checking a navigation response's adherence to its embedder policy given navigationParams's response, navigable, and navigationParams's policy container's embedder policy is false; or
        //    À FAIRE : the result of checking a navigation response's adherence to `X-Frame-Options` given navigationParams's response, navigable, navigationParams's policy container's CSP list, and navigationParams's origin is false,
        // then:
        sinon si navigation_params == nul {
            panique("non-implémenté")

            // 1. Set entry's document state's document to the result of creating a document for inline content that doesn't have a DOM, given navigable, null, and navTimingType. The inline content should indicate to the user the sort of error that occurred.

            // 2. Make document unsalvageable given entry's document state's document and "navigation-failure".

            // 3. Set saveExtraDocumentState to false.

            // 4. If navigationParams is not null, then:

                // 1. Run the environment discarding steps for navigationParams's reserved environment.

                // 2. Invoke WebDriver BiDi navigation failed with currentBrowsingContext and a new WebDriver BiDi navigation status whose id is navigationId, status is "canceled", and url is navigationParams's response's URL.
        }
        // 5. Otherwise, if navigationParams's response has a `Content-Disposition` header specifying the attachment disposition type, then:
        // À FAIRE : attachment disposition type
        sinon si navigation_params.response.possède_entête("Content-Disposition") {
            panique("non-implémenté")

            // 1. Let sourceAllowsDownloading be sourceSnapshotParams's allows downloading.

            // 2. Let targetAllowsDownloading be false if navigationParams's final sandboxing flag set has the sandboxed downloads browsing context flag set; otherwise true.

            // 3. Let uaAllowsDownloading be true.

            // 4. Optionally, the user agent may set uaAllowsDownloading to false, if it believes doing so would safeguard the user from a potentially hostile download.

            // 5. If sourceAllowsDownloading, targetAllowsDownloading, and uaAllowsDownloading are true, then:

                // 1. Handle navigationParams's response as a download.

                // 2. Invoke WebDriver BiDi download started with currentBrowsingContext and a new WebDriver BiDi navigation status whose id is navigationId, status is "complete", and url is navigationParams's response's URL.
        }
        // 6. Otherwise, if navigationParams's response's status is not 204 and is not 205
        sinon si navigation_params.response.status != 204 && navigation_params.response.status != 205 {
            // then set entry's document state's document to the result of loading a document given
            // navigationParams, sourceSnapshotParams, and entry's document state's initiator origin.
            entry.document_state.document = load_a_document(user_agent, navigation_params, source_snapshot_params, Origin())
        }

        // 7. If entry's document state's document is not null, then:
        si entry.document_state.document != nul {
            // 1. Set entry's document state's ever populated to true.
            entry.document_state.ever_populated = vrai

            // 2. If saveExtraDocumentState is true:
            si save_extra_document_state {
                // 1. Let document be entry's document state's document.
                document := entry.document_state.document

                // 2. Set entry's document state's origin to document's origin.
                entry.document_state.origin = document.origin

                // À FAIRE : 3. If document's URL requires storing the policy container in history, then:

                    // 1. Assert: navigationParams is a navigation params (i.e., neither null nor a non-fetch scheme navigation params).

                    // 2. Set entry's document state's history policy container to navigationParams's policy container.
            }
            
            // 3. If entry's document state's request referrer is "client", and navigationParams is a navigation params (i.e., neither null nor a non-fetch scheme navigation params), then:
            si entry.document_state.request_referrer == "client" && navigation_params.est_navigation_params() {
                // 1. Assert: navigationParams's request is not null.
                assert(navigation_params.request != nul)

                // 2. Set entry's document state's request referrer to navigationParams's request's referrer.
                entry.document_state.request_referrer = navigation_params.request.referrer
            }
        }

        // 8. Run completionSteps.
        run(completion_steps)
    }

    sur_destruction :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche
        déloge(tâche)
    }

    tâche := loge(Tâche)
    tâche.sur_run = sur_run
    tâche.navigable = navigable
    tâche.navigation_id = navigation_id
    tâche.sur_destruction = sur_destruction
    tâche.user_agent = user_agent
    tâche.completion_steps = completion_steps
    tâche.entry = entry
    tâche.navigation_params = navigation_params
    tâche.source_snapshot_params = source_snapshot_params

    user_agent.enfile_une_tâche(SourceDeTâche.NavigationEtTraversée, tâche)
}

crée_tâche_pour_entry_population_attempt :: fonc (params: *HistoryEntryPopulationParams) -> *Algorithm
{
    Tâche :: struct {
        empl base: Algorithm

        params: HistoryEntryPopulationParams
    }

    sur_run :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche
        attempt_to_populate_the_history_entry_document(*tâche.params)
    }

    sur_destruction :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche
        déloge(tâche)
    }

    tâche := loge(Tâche)
    tâche.params = mémoire(params)
    tâche.sur_run = sur_run
    tâche.sur_destruction = sur_destruction
    retourne tâche
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#create-navigation-params-by-fetching
    To create navigation params by fetching given a session history entry entry, a navigable navigable, a source snapshot params sourceSnapshotParams, a target snapshot params targetSnapshotParams, a string cspNavigationType, a navigation ID-or-null navigationId, and a NavigationTimingType navTimingType, perform the following steps. They return a navigation params, a non-fetch scheme navigation params, or null.
 */
create_navigation_params_by_fetching :: fonc (user_agent: *UserAgent,
                                              entry: *SessionHistoryEntry,
                                              navigable: *Navigable,
                                              source_snapshot_params: &SourceSnapshotParams,
                                              target_snapshot_params: &TargetSnapshotParams @inutilisée,
                                              navigation_id: Optionnel(NavigationID),
                                              nav_timing_type: NavigationTimingType @inutilisée) -> *NavigationParams
{
    // 1. Assert: this is running in parallel.
    assert(user_agent.est_exécuté_en_parallèle())

    // 2. Let documentResource be entry's document state's resource.

    // 3. Let request be a new request, with
    //     url entry's URL
    //     client  sourceSnapshotParams's fetch client
    //     destination "document"
    //     credentials mode    "include"
    //     use-URL-credentials flag    set
    //     redirect mode   "manual"
    //     replaces client id  navigable's active document's relevant settings object's id
    //     mode    "navigate"
    //     referrer    entry's document state's request referrer
    //     referrer policy entry's document state's request referrer policy
    request := loge(Request)
    request.définis_url(tente parse_uri_standard(recompose_uri(*entry.url)) piège nonatteignable)
    request.client = source_snapshot_params.fetch_client
    request.destination = "document"
    request.credentials_mode = "include"
    request.use_url_credentials = vrai
    request.redirect_mode = "manual"
    // À FAIRE replaces_client_id
    request.mode = "navigate"
    request.referrer = entry.document_state.request_referrer
    request.referrer_policy = entry.document_state.request_referrer_policy

    // 4. If documentResource is a POST resource, then:

        // 1. Set request's method to `POST`.

        // 2. Set request's body to documentResource's request body.

        // 3. Set `Content-Type` to documentResource's request content-type in request's header list.

    // 5. If entry's document state's reload pending is true, then set request's reload-navigation flag.
    si entry.document_state.reload_pending {
        request.reload_navigation = vrai
    }
    // 6. Otherwise, if entry's document state's ever populated is true, then set request's history-navigation flag.
    sinon si entry.document_state.ever_populated {
        request.history_navigation = vrai
    }

    // 7. If sourceSnapshotParams's has transient activation is true, then set request's user-activation to true.
    si source_snapshot_params.has_transient_activation {
        request.user_activation = vrai
    }

    // 8. If navigable's container is non-null:

        // 1. If the navigable's container has a browsing context scope origin, then set request's origin to that browsing context scope origin.

        // 2. Set request's destination to navigable's container's local name.

        // 3. If sourceSnapshotParams's fetch client is navigable's container document's relevant settings object, then set request's initiator type to navigable's container's local name.

    // 9. Let response be null.
    response: *Response

    // 10. Let responseOrigin be null.

    // 11. Let fetchController be null.
    fetch_controller: *FetchController

    // 12. Let coopEnforcementResult be a new cross-origin opener policy enforcement result, with
    //     url navigable's active document's URL
    //     origin  navigable's active document's origin
    //     cross-origin opener policy  navigable's active document's cross-origin opener policy
    //     À FAIRE : current context is navigation source    true if navigable's active document's origin is same origin with entry's document state's initiator origin otherwise false
    coop_enforcement_result: CrossOriginOpenerPolicyEnforcementResult
    coop_enforcement_result.url = navigable.donne_active_document().url
    coop_enforcement_result.origin = navigable.donne_active_document().origin
    coop_enforcement_result.cross_origin_opener_policy = navigable.donne_active_document().cross_origin_opener_policy

    // 13. Let finalSandboxFlags be an empty sandboxing flag set.
    // final_sandboxing_flags: SandboxingFlags

    // 14. Let responsePolicyContainer be null.

    // 15. Let responseCOOP be a new cross-origin opener policy.
    response_coop: CrossOriginOpenerPolicy

    // 16. Let locationURL be null.

    // 17. Let currentURL be request's current URL.
    current_url := request.donne_url_courant()

    // 18. Let commitEarlyHints be null.

    // 19. While true:
    boucle {
        // 1. If request's reserved client is not null and currentURL's origin is not the same as request's reserved client's creation URL's origin, then:

            // 1. Run the environment discarding steps for request's reserved client.

            // 2. Set request's reserved client to null.

            // 3. Set commitEarlyHints to null.
            
        // 2. If request's reserved client is null, then:

            // 1. Let topLevelCreationURL be currentURL.

            // 2. Let topLevelOrigin be null.

            // 3. If navigable is not a top-level traversable, then:

                // 1. Let parentEnvironment be navigable's parent's active document's relevant settings object.

                // 2. Set topLevelCreationURL to parentEnvironment's top-level creation URL.

                // 3. Set topLevelOrigin to parentEnvironment's top-level origin.

            // 4. Set request's reserved client to a new environment whose id is a unique opaque string, target browsing context is navigable's active browsing context, creation URL is currentURL, top-level creation URL is topLevelCreationURL, and top-level origin is topLevelOrigin.

        // 3. If the result of should navigation request of type be blocked by Content Security Policy? given request and cspNavigationType is "Blocked", then set response to a network error and break. [CSP]

        // 4. Set response to null.
        response = nul

        // 5. If fetchController is null, then set fetchController to the result of fetching request, with processEarlyHintsResponse set to processEarlyHintsResponse as defined below, processResponse set to processResponse as defined below, and useParallelQueue set to true.
        si fetch_controller == nul {
            // À FAIRE :    Let processEarlyHintsResponse be the following algorithm given a response earlyResponse:
            //     1. If commitEarlyHints is null, then set commitEarlyHints to the result of processing early hint headers given earlyResponse and request's reserved client.

            // Let processResponse be the following algorithm given a response fetchedResponse:
            //     1. Set response to fetchedResponse.
            RappelProcessResponse :: struct {
                empl base: BaseProcessResponse

                réponse: **Response
            }

            sur_rappel_process_response :: fonc (base: *BaseProcessResponse, réponse: *Response)
            {
                rappel := base comme *RappelProcessResponse
                mémoire(rappel.réponse) = réponse
            }

            sur_destruction_process_response :: fonc (base: *BaseProcessResponse)
            {
                rappel := base comme *RappelProcessResponse
                déloge(rappel)
            }

            process_response := loge(RappelProcessResponse)
            process_response.réponse = *response
            process_response.sur_rappel = sur_rappel_process_response
            process_response.sur_destruction = sur_destruction_process_response

            fetch_controller = fetch(user_agent, request, process_response = process_response)
        }
        // 6. Otherwise, process the next manual redirect for fetchController.
        sinon {

        }

        // 7. Wait until either response is non-null, or navigable's ongoing navigation changes to no longer equal navigationId.
        //     If the latter condition occurs, then abort fetchController, and return.
        //     Otherwise, proceed onward.
        tantque response == nul && navigable.ongoing_navigation == navigation_id {
            continue
        }

        // 8. If request's body is null, then set entry's document state's resource to null.

        // 9. Set responsePolicyContainer to the result of creating a policy container from a fetch response given response and request's reserved client.

        // 10. Set finalSandboxFlags to the union of targetSnapshotParams's sandboxing flags and responsePolicyContainer's CSP list's CSP-derived sandboxing flags.

        // 11. Set responseOrigin to the result of determining the origin given response's URL, finalSandboxFlags, and entry's document state's initiator origin.

        // 12. If navigable is a top-level traversable, then:
        si navigable.est_top_level_traversable() {
            imprime("À FAIRE : [navigation/COOP]\n")
            // 1. Set responseCOOP to the result of obtaining a cross-origin opener policy given response and request's reserved client.

            // 2. Set coopEnforcementResult to the result of enforcing the response's cross-origin opener policy given navigable's active browsing context, response's URL, responseOrigin, responseCOOP, coopEnforcementResult and request's referrer.

            // 3. If finalSandboxFlags is not empty and responseCOOP's value is not "unsafe-none", then set response to an appropriate network error and break.
        }

        // 13. If response is not a network error, navigable is a child navigable, and the result of performing a cross-origin resource policy check with navigable's container document's origin, navigable's container document's relevant settings object, request's destination, response, and true is blocked, then set response to a network error and break.

        // 14. Set locationURL to response's location URL given currentURL's fragment.

        // 15. If locationURL is failure or null, then break.
        arrête

        // 16. Assert: locationURL is a URL.

        // 17. Set entry's classic history API state to StructuredSerializeForStorage(null).

        // 18. Let oldDocState be entry's document state.

        // 19. Set entry's document state to a new document state, with
        //     history policy container    a clone of the oldDocState's history policy container if it is non-null; null otherwise
        //     request referrer    oldDocState's request referrer
        //     request referrer policy oldDocState's request referrer policy
        //     initiator origin    oldDocState's initiator origin
        //     origin  oldDocState's origin
        //     about base URL  oldDocState's about base URL
        //     resource    oldDocState's resource
        //     ever populated  oldDocState's ever populated
        //     navigable target name   oldDocState's navigable target name

        // 20. If locationURL's scheme is not an HTTP(S) scheme, then:

            // 1. Set entry's document state's resource to null.

            // 2. Break.

        // 21. Set currentURL to locationURL.

        // 22. Set entry's URL to currentURL.
        entry.url = tente parse_uri_standard(recompose_uri(*current_url)) piège nonatteignable
    }

    // 20. If locationURL is a URL whose scheme is not a fetch scheme, then return a new non-fetch scheme navigation params, with
    //     id  navigationId
    //     navigable   navigable
    //     URL locationURL
    //     target snapshot sandboxing flags    targetSnapshotParams's sandboxing flags
    //     source snapshot has transient activation    sourceSnapshotParams's has transient activation
    //     initiator origin    responseOrigin
    //     navigation timing type  navTimingType

    // 21. If any of the following are true:
    //     response is a network error;
    //     locationURL is failure; or
    //     locationURL is a URL whose scheme is a fetch scheme,
    //     then return null.

    // 22. Assert: locationURL is null and response is not a network error.

    // 23. Let resultPolicyContainer be the result of determining navigation params policy container given response's URL, entry's document state's history policy container, sourceSnapshotParams's source policy container, null, and responsePolicyContainer.

    // 24. If navigable's container is an iframe, and response's timing allow passed flag is set, then set container's pending resource-timing start time to null.

    // 25. Return a new navigation params, with
    //     id  navigationId
    //     navigable   navigable
    //     request request
    //     response    response
    //     fetch controller    fetchController
    //     commit early hints  commitEarlyHints
    //     cross-origin opener policy  responseCOOP
    //     reserved environment    request's reserved client
    //     origin  responseOrigin
    //     policy container    resultPolicyContainer
    //     final sandboxing flag set   finalSandboxFlags
    //     COOP enforcement result coopEnforcementResult
    //     navigation timing type  navTimingType
    //     about base URL  entry's document state's about base URL
    résultat := loge(NavigationParams)
    résultat.id = navigation_id
    résultat.navigable = navigable
    résultat.request = request
    résultat.response = response
    résultat.fetch_controller = fetch_controller
    //     commit early hints  commitEarlyHints
    résultat.cross_origin_opener_policy = response_coop
    //     reserved environment    request's reserved client
    //     origin  responseOrigin
    //     policy container    resultPolicyContainer
    //     final sandboxing flag set   finalSandboxFlags
    résultat.COOP_enforcement_result = coop_enforcement_result
    //     navigation timing type  navTimingType
    //     about base URL  entry's document state's about base URL
    retourne résultat
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#loading-a-document */
load_a_document :: fonc (user_agent: *UserAgent, navigation_params: *NavigationParams, source_snapshot_params: SourceSnapshotParams @inutilisée, initiator_origin: Origin @inutilisée) -> *Document
{
    // 1. Let type be the computed type of navigationParams's response.
    mime_type := navigation_params.response.donne_mime_type()

    // 2. If the user agent has been configured to process resources of the given
    //    type using some mechanism other than rendering the content in a navigable,
    //    then skip this step.
    //    Otherwise, if the type is one of the following types:

    // an HTML MIME type
    si mime_type == MIME_text_html {
        // Return the result of loading an HTML document, given navigationParams.
        retourne load_an_html_document(user_agent, navigation_params)
    }

    // an XML MIME type that is not an explicitly supported XML MIME type
    // Return the result of loading an XML document given navigationParams and type.

    // a JavaScript MIME type
    // a JSON MIME type that is not an explicitly supported JSON MIME type
    // "text/css"
    // "text/plain"
    // "text/vtt"
    // Return the result of loading a text document given navigationParams and type.

    // "multipart/x-mixed-replace"
    // Return the result of loading a multipart/x-mixed-replace document, given navigationParams, sourceSnapshotParams, and initiatorOrigin.

    // A supported image, video, or audio type
    // Return the result of loading a media document given navigationParams and type.

    // "application/pdf"
    // "text/pdf"
    // If the user agent's PDF viewer supported is true, return the result of creating
    // a document for inline content that doesn't have a DOM given navigationParams's navigable.
    
    // Otherwise, proceed onward.
    retourne nul
}

/* https://html.spec.whatwg.org/multipage/browsers.html#obtain-browsing-context-navigation */
obtain_a_browsing_context_for_a_navigation_response :: fonc (user_agent: *UserAgent, browsing_context: *BrowsingContext, sandbox_flags: SandboxingFlags @inutilisée, navigation_coop: CrossOriginOpenerPolicy @inutilisée, coop_enforcement_result: CrossOriginOpenerPolicyEnforcementResult) -> *BrowsingContext
{
    // 1. If browsingContext is not a top-level browsing context, then return browsingContext.
    saufsi browsing_context.est_top_level_browsing_context() {
        retourne browsing_context
    }

    // 2. If coopEnforcementResult's needs a browsing context group switch is false, then:
    si coop_enforcement_result.needs_a_browsing_context_group_switch == faux {
        // À FAIRE : 1. If coopEnforcementResult's would need a browsing context group switch due to report-only is true,
        // set browsing context's virtual browsing context group ID to a new unique identifier.

        // 2. Return browsingContext.
        retourne browsing_context
    }

    // 3. Let newBrowsingContext be the first return value of creating a new top-level browsing context and document.
    new_browsing_context, _ := crée_un_nouveau_top_level_browsing_context_et_document(user_agent)

    // À FAIRE : 4. If navigationCOOP's value is "same-origin-plus-COEP", then set newBrowsingContext's group's cross-origin isolation mode to either "logical" or "concrete". The choice of which is implementation-defined.

    // À FAIRE : 5. If sandboxFlags is not empty, then:

        // 1. Assert: navigationCOOP's value is "unsafe-none".

        // 2. Assert: newBrowsingContext's popup sandboxing flag set is empty.

        // 3. Set newBrowsingContext's popup sandboxing flag set to a clone of sandboxFlags.

    // 6. Return newBrowsingContext.
    retourne new_browsing_context
}

/** } */

/* ------------------------------------------------------------------------- */
/** \nom 7.4.6.1 Updating the traversable.
 * https://html.spec.whatwg.org/multipage/browsing-the-web.html#updating-the-traversable
 * \{ */

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#changing-navigable-continuation-state */
ChangingNavigableContinuationState :: struct {
    displayed_document: *Document
    target_entry: *SessionHistoryEntry
    navigable: *Navigable
    update_only: bool
}

/* They return "initiator-disallowed", "canceled-by-beforeunload", "canceled-by-navigate", or "applied". */
HistoryApplication :: énum {
    Applied
    InitiatorDisallowed
    CanceledByBeforeunload
    CanceledByNavigate
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#apply-the-push/replace-history-step */
apply_the_push_replace_history_step :: fonc (user_agent: *UserAgent, step: n32, traversable: *TraversableNavigable, history_handling: NavigationHistoryBehavior) -> HistoryApplication
{
    assert(history_handling != NavigationHistoryBehavior.AUTO)

    navigation_type: NavigationType
    si history_handling == NavigationHistoryBehavior.PUSH {
        navigation_type = NavigationType.push
    }
    sinon {
        assert(history_handling == NavigationHistoryBehavior.REPLACE)
        navigation_type = NavigationType.replace
    }

    // 1. Return the result of applying the history step step to traversable given false, null, null, null, and historyHandling.
    retourne apply_the_history_step(user_agent, step, traversable, faux, nul, nul, nul, *navigation_type)
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#apply-the-reload-history-step */
apply_the_reload_history_step :: fonc (user_agent: *UserAgent, traversable: *TraversableNavigable) -> HistoryApplication
{
    // 1. Let step be traversable's current session history step.
    step := traversable.current_session_history_entry_step

    // 2. Return the result of applying the history step step to traversable given true, null, null, null, and "reload".
    navigation_type := NavigationType.reload
    retourne apply_the_history_step(user_agent, step, traversable, vrai, nul, nul, nul, *navigation_type)
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#apply-the-traverse-history-step */
apply_the_traverse_history_step :: fonc (user_agent: *UserAgent, step: n32, traversable: *TraversableNavigable, source_snapshot_params: *SourceSnapshotParams, initiator_to_check: *Navigable, user_involvement: UserNavigationInvolvement) -> HistoryApplication
{
    // 1. Return the result of applying the history step step to traversable given true, sourceSnapshotParams, initiatorToCheck, userInvolvement, and "traverse".
    navigation_type := NavigationType.traverse
    retourne apply_the_history_step(user_agent, step, traversable, vrai, source_snapshot_params, initiator_to_check, *user_involvement, *navigation_type)
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#apply-the-history-step */
apply_the_history_step :: fonc (user_agent: *UserAgent,
                                step: n32,
                                traversable: *TraversableNavigable,
                                check_for_canceletion: bool,
                                source_snapshot_params: *SourceSnapshotParams,
                                initiator_to_check: *Navigable,
                                user_involvement_for_navigate_events: *UserNavigationInvolvement,
                                navigation_type: *NavigationType) -> HistoryApplication
{
    // 1. Assert: This is running within traversable's session history traversal queue.
    assert(user_agent.est_exécuté_sur_file_parallèle(traversable))

    // 2. Let targetStep be the result of getting the used step given traversable and step.
    target_step := get_the_used_step(user_agent, traversable, step)

    // 3. If initiatorToCheck is not null, then:
    si initiator_to_check {
        // 1. Assert: sourceSnapshotParams is not null.
        assert(source_snapshot_params != nul)

        // 2. For each navigable of get all navigables whose current session history entry will change or reload:
        //    if initiatorToCheck is not allowed by sandboxing to navigate navigable given sourceSnapshotParams,
        //    then return "initiator-disallowed".
        panique("initiator_to_check != nul non-implémenté")
    }

    // 4. Let navigablesCrossingDocuments be the result of getting all navigables that might experience a
    //    cross-document traversal given traversable and targetStep.
    navigables_crossing_documents := get_all_navigables_that_might_experience_a_cross_document_traversal(user_agent, traversable, target_step)
    diffère déloge(navigables_crossing_documents)

    // 5. If checkForCancelation is true, and the result of checking if unloading is canceled given navigablesCrossingDocuments, traversable, targetStep, and userInvolvementForNavigateEvents is not "continue", then return that result.
    si check_for_canceletion {
        result := check_if_unloading_is_canceled(navigables_crossing_documents, traversable, user_involvement_for_navigate_events)
        si result == "canceled-by-beforeunload" {
            retourne HistoryApplication.CanceledByBeforeunload
        }
        si result == "canceled-by-navigate" {
            retourne HistoryApplication.CanceledByNavigate
        }
    }

    // 6. Let changingNavigables be the result of get all navigables whose current session history entry will change or reload given traversable and targetStep.
    changing_navigables := get_all_navigables_whose_current_session_history_entry_will_change_or_reload(user_agent, traversable, target_step)
    diffère déloge(changing_navigables)

    // 7. Let nonchangingNavigablesThatStillNeedUpdates be the result of getting all navigables that only need history object length/index update given traversable and targetStep.
    nonchanging_navigables_that_still_need_updates := get_all_navigables_that_only_need_history_object_length_index_update(user_agent, traversable, target_step)
    diffère déloge(nonchanging_navigables_that_still_need_updates)

    // 8. For each navigable of changingNavigables:
    pour navigable dans changing_navigables {
        // 1. Let targetEntry be the result of getting the target history entry given navigable and targetStep.
        target_entry := get_the_target_history_entry(user_agent, navigable, target_step)

        // 2. Set navigable's current session history entry to targetEntry.
        navigable.current_session_history_entry = target_entry

        // 3. Set the ongoing navigation for navigable to "traversal".
        navigable.définis_ongoing_navigation("traversal")
    }

    // 9. Let totalChangeJobs be the size of changingNavigables.
    total_change_jobs := changing_navigables.taille

    // 10. Let completedChangeJobs be 0.
    completed_change_jobs := 0

    // 11. Let changingNavigableContinuations be an empty queue of changing navigable continuation states.
    changing_navigable_continuations: [..]ChangingNavigableContinuationState
    diffère déloge(changing_navigable_continuations)

    // 12. For each navigable of changingNavigables, queue a global task on the navigation and traversal task source of navigable's active window to run the steps:
    pour navigable dans changing_navigables {
        tâche := crée_tâche_pour_changing_navigable_continuations_steps(user_agent, navigable, traversable, navigation_type, source_snapshot_params, *changing_navigable_continuations)
        user_agent.enfile_une_tâche(SourceDeTâche.NavigationEtTraversée, tâche)
    }

    // 13. Let navigablesThatMustWaitBeforeHandlingSyncNavigation be an empty set.
    navigables_that_must_wait_before_handling_sync_navigation: [..]*Navigable
    diffère déloge(navigables_that_must_wait_before_handling_sync_navigation)

    // 14. While completedChangeJobs does not equal totalChangeJobs:
    décalage_défilement := 0
    tantque completed_change_jobs != total_change_jobs {
        // 1. If traversable's running nested apply history step is false, then:
        si traversable.running_nested_apply_history_step == faux {
            // À FAIRE : 1. While traversable's session history traversal queue's algorithm set contains one or more synchronous navigation steps with a target navigable not contained in navigablesThatMustWaitBeforeHandlingSyncNavigation:

                // 1. Let steps be the first item in traversable's session history traversal queue's algorithm set that is synchronous navigation steps with a target navigable not contained in navigablesThatMustWaitBeforeHandlingSyncNavigation.

                // 2. Remove steps from traversable's session history traversal queue's algorithm set.

                // 3. Set traversable's running nested apply history step to true.

                // 4. Run steps.

                // 5. Set traversable's running nested apply history step to false.
        }

        // 2. Let changingNavigableContinuation be the result of dequeuing from changingNavigableContinuations.
        // 3. If changingNavigableContinuation is nothing, then continue.
        si décalage_défilement >= changing_navigable_continuations.taille {
            continue
        }

        changing_navigable_continuation := changing_navigable_continuations[décalage_défilement]
        décalage_défilement += 1

        // 4. Let displayedDocument be changingNavigableContinuation's displayed document.
        displayed_document := changing_navigable_continuation.displayed_document

        // 5. Let targetEntry be changingNavigableContinuation's target entry.
        target_entry := changing_navigable_continuation.target_entry

        // 6. Let navigable be changingNavigableContinuation's navigable.
        navigable := changing_navigable_continuation.navigable

        // À FAIRE 7. Let (scriptHistoryLength, scriptHistoryIndex) be the result of getting the history object length and index given traversable and targetStep.
        script_history_length : n32 = 0
        script_history_index : n32 = 0

        // 8. Append navigable to navigablesThatMustWaitBeforeHandlingSyncNavigation.
        tableau_ajoute(*navigables_that_must_wait_before_handling_sync_navigation, navigable)

        // À FAIRE : 9. Let entriesForNavigationAPI be the result of getting session history entries for the navigation API given navigable and targetStep.
        entries_for_navigation_api: [..]*SessionHistoryEntry

        after_potential_unloads_params: AfterPotentialUnloadsParams
        after_potential_unloads_params.target_entry = target_entry
        after_potential_unloads_params.displayed_document = displayed_document
        after_potential_unloads_params.navigable = navigable
        after_potential_unloads_params.changing_navigable_continuation = changing_navigable_continuation
        after_potential_unloads_params.completed_change_jobs = *completed_change_jobs
        after_potential_unloads_params.script_history_length = script_history_length
        after_potential_unloads_params.script_history_index = script_history_index
        after_potential_unloads_params.navigation_type = navigation_type
        after_potential_unloads_params.entries_for_navigation_api = entries_for_navigation_api
        after_potential_unloads_params.displayed_entry = navigable.active_session_history_entry

        tâche_after_potential_unloads := crée_tâche_pour_after_potential_unloads(user_agent, *after_potential_unloads_params)

        // 10. If changingNavigableContinuation's update-only is true, or targetEntry's document is displayedDocument, then:
        si changing_navigable_continuation.update_only || target_entry.donne_document() == displayed_document {
            // 1. Set the ongoing navigation for navigable to null.
            init_de(OngoingNavigationType)(*navigable.ongoing_navigation)

            // 2. Queue a global task on the navigation and traversal task source given navigable's active window to perform afterPotentialUnloads.
            user_agent.enfile_une_tâche(SourceDeTâche.NavigationEtTraversée, tâche_after_potential_unloads)
        }
        // 11. Otherwise:
        sinon {
            // 1. Assert: navigationType is not null.
            assert(navigation_type != nul)

            // 2. Deactivate displayedDocument, given userNavigationInvolvement, targetEntry, navigationType, and afterPotentialUnloads.
            deactivate_document_for_a_cross_document_navigation(user_agent, displayed_document, user_involvement_for_navigate_events, target_entry, mémoire(navigation_type), tâche_after_potential_unloads)
        }

        // 12. In both cases, let afterPotentialUnloads be the following steps:
        // NOTE : définis dans #after_potential_unloads
    }

    // 15. Let totalNonchangingJobs be the size of nonchangingNavigablesThatStillNeedUpdates.
    total_non_chaging_jobs := nonchanging_navigables_that_still_need_updates.taille

    // 16. Let completedNonchangingJobs be 0.
    completed_non_changing_jobs := 0

    // À FAIRE : 17. Let (scriptHistoryLength, scriptHistoryIndex) be the result of getting the history object length and index given traversable and targetStep.

    // 18. For each navigable of nonchangingNavigablesThatStillNeedUpdates, queue a global task on the navigation and traversal task source given navigable's active window to run the steps:
    // À FAIRE : crée une tâche
    pour /* navigable dans */ nonchanging_navigables_that_still_need_updates {
        // 1. Let document be navigable's active document.

        // 2. Set document's history object's index to scriptHistoryIndex.

        // 3. Set document's history object's length to scriptHistoryLength.

        // 4. Increment completedNonchangingJobs.
        completed_non_changing_jobs += 1
    }

    // 19. Wait for completedNonchangingJobs to equal totalNonchangingJobs.
    tantque completed_non_changing_jobs != total_non_chaging_jobs {
        continue
    }

    // 20. Set traversable's current session history step to targetStep.
    traversable.current_session_history_entry_step = target_step

    // 21. Return "applied".
    retourne HistoryApplication.Applied
}

AfterPotentialUnloadsParams :: struct {
    target_entry: *SessionHistoryEntry
    displayed_document: *Document
    navigable: *Navigable
    changing_navigable_continuation: ChangingNavigableContinuationState
    completed_change_jobs: *z32
    script_history_length: n32
    script_history_index: n32
    navigation_type: *NavigationType
    entries_for_navigation_api: []*SessionHistoryEntry
    displayed_entry: *SessionHistoryEntry
}

after_potential_unloads :: fonc (user_agent: *UserAgent, params: *AfterPotentialUnloadsParams)
{
    target_entry := params.target_entry

    // 1. If changingNavigableContinuation's update-only is false, then activate history entry targetEntry for navigable.
    saufsi params.changing_navigable_continuation.update_only {
        activate_histroy_entry(params.target_entry, params.navigable)
    }

    // 2. Let updateDocument be an algorithm step which performs update document for history step application given
    //    targetEntry's document, targetEntry, changingNavigableContinuation's update-only, scriptHistoryLength, scriptHistoryIndex, navigationType, entriesForNavigationAPI, and displayedEntry.
    document_update_params: DocumentUpdateParams
    document_update_params.document = target_entry.donne_document()
    document_update_params.entry = target_entry
    document_update_params.do_not_reactivate = params.changing_navigable_continuation.update_only
    document_update_params.script_history_length = params.script_history_length
    document_update_params.script_history_index = params.script_history_index
    document_update_params.navigation_type = params.navigation_type
    document_update_params.entries_for_navigation_api = params.entries_for_navigation_api
    document_update_params.previous_entry_for_activation = params.displayed_entry

    // 3. If targetEntry's document is equal to displayedDocument, then perform updateDocument.
    si target_entry.donne_document() == params.displayed_document {
        update_document_for_history_step_application(*document_update_params)
    }
    // 4. Otherwise, queue a global task on the navigation and traversal task source given targetEntry's document's relevant global object to perform updateDocument.
    sinon {
        // À FAIRE : relevant global object
        tâche := crée_tâche_pour_update_document(*document_update_params)
        user_agent.enfile_une_tâche(SourceDeTâche.NavigationEtTraversée,  tâche)
    }

    // 5. Increment completedChangeJobs.
    mémoire(params.completed_change_jobs) += 1
}

crée_tâche_pour_after_potential_unloads :: fonc (user_agent: *UserAgent, params: *AfterPotentialUnloadsParams) -> *Algorithm
{
    Tâche :: struct {
        empl base: Algorithm

        user_agent: *UserAgent
        params: AfterPotentialUnloadsParams
    }

    sur_run :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche
        after_potential_unloads(tâche.user_agent, *tâche.params)
    }

    sur_destruction :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche
        déloge(tâche)
    }

    tâche := loge(Tâche)
    tâche.user_agent = user_agent
    tâche.params = mémoire(params)
    tâche.sur_run = sur_run
    tâche.sur_destruction = sur_destruction
    retourne tâche
}

crée_tâche_pour_update_document :: fonc (params: *DocumentUpdateParams) -> *Algorithm
{
    Tâche :: struct {
        empl base: Algorithm

        params: DocumentUpdateParams
    }

    sur_run :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche
        update_document_for_history_step_application(*tâche.params)
    }

    sur_destruction :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche
        déloge(tâche)
    }

    tâche := loge(Tâche)
    tâche.params = mémoire(params)
    tâche.sur_run = sur_run
    tâche.sur_destruction = sur_destruction
    retourne tâche
}

crée_tâche_pour_changing_navigable_continuations_steps :: fonc (user_agent: *UserAgent,
                                                                navigable: *Navigable,
                                                                traversable: *TraversableNavigable,
                                                                navigation_type: *NavigationType,
                                                                source_snapshot_params: *SourceSnapshotParams,
                                                                changing_navigable_continuations: *[..]ChangingNavigableContinuationState) -> *Algorithm
{
    Tâche :: struct {
        empl base: Algorithm

        user_agent: *UserAgent
        navigable: *Navigable
        traversable: *TraversableNavigable
        navigation_type: *NavigationType
        source_snapshot_params: *SourceSnapshotParams
        changing_navigable_continuations: *[..]ChangingNavigableContinuationState
    }

    sur_run :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche

        user_agent := tâche.user_agent
        navigable := tâche.navigable
        traversable := tâche.traversable
        navigation_type := tâche.navigation_type
        source_snapshot_params := tâche.source_snapshot_params
        changing_navigable_continuations := tâche.changing_navigable_continuations

        changing_navigable_continuations_steps(user_agent, navigable, traversable, navigation_type, source_snapshot_params, changing_navigable_continuations)
    }

    sur_destruction :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche
        déloge(tâche)
    }

    tâche := loge(Tâche)
    tâche.user_agent = user_agent
    tâche.navigable = navigable
    tâche.traversable = traversable
    tâche.navigation_type = navigation_type
    tâche.source_snapshot_params = source_snapshot_params
    tâche.changing_navigable_continuations = changing_navigable_continuations
    tâche.sur_run = sur_run
    tâche.sur_destruction = sur_destruction
    retourne tâche
}

changing_navigable_continuations_steps :: fonc (user_agent: *UserAgent,
                                                navigable: *Navigable,
                                                traversable: *TraversableNavigable @inutilisée,
                                                navigation_type: *NavigationType,
                                                source_snapshot_params: *SourceSnapshotParams,
                                                changing_navigable_continuations: *[..]ChangingNavigableContinuationState)
{
    // 1. Let displayedEntry be navigable's active session history entry.
    displayed_entry := navigable.active_session_history_entry

    // 2. Let targetEntry be navigable's current session history entry.
    target_entry := navigable.current_session_history_entry

    // 3. Let changingNavigableContinuation be a changing navigable continuation state with:
    //    displayed document   displayedEntry's document
    //    target entry         targetEntry
    //    navigable            navigable
    //    update-only          false
    changing_navigable_continuation: ChangingNavigableContinuationState
    changing_navigable_continuation.displayed_document = displayed_entry.donne_document()
    changing_navigable_continuation.target_entry = target_entry
    changing_navigable_continuation.navigable = navigable
    changing_navigable_continuation.update_only = faux

    // 4. If displayedEntry is targetEntry and targetEntry's document state's reload pending is false, then:
    si displayed_entry == target_entry && target_entry.document_state.reload_pending == faux {
        // 1. Set changingNavigableContinuation's update-only to true.
        changing_navigable_continuation.update_only = vrai

        // 2. Enqueue changingNavigableContinuation on changingNavigableContinuations.
        tableau_ajoute(changing_navigable_continuations, changing_navigable_continuation)

        // 3. Abort these steps.
        retourne
    }

    // 5. Switch on navigationType:
    si navigation_type {
        discr mémoire(navigation_type) {
            reload {
                // "reload"
                // Assert: targetEntry's document state's reload pending is true.
                assert(target_entry.document_state.reload_pending == vrai)
            }
            traverse {
                // "traverse"
                // Assert: targetEntry's document state's ever populated is true.
                assert(target_entry.document_state.ever_populated == vrai)
            }
            replace {
                // "replace"
                // Assert: targetEntry's step is displayedEntry's step and targetEntry's document state's ever populated is false.
                assert(target_entry.step == displayed_entry.step)
                // assert(target_entry.document_state.ever_populated == faux)
            }
            push {
                // "push"
                // Assert: targetEntry's step is displayedEntry's step + 1 and targetEntry's document state's ever populated is false.
                assert(target_entry.step == displayed_entry.step + 1)
                // assert(target_entry.document_state.ever_populated == faux)
            }
        }
    }

    // 6. Let oldOrigin be targetEntry's document state's origin.
    // old_origin := target_entry.donne_document().origin

    // À FAIRE : 7. If all of the following are true:
    //    navigable is not traversable;
    //    targetEntry is not navigable's current session history entry; and
    //    oldOrigin is the same as navigable's current session history entry's document state's origin,
    //    then:
    {
        // 1. Assert: userInvolvementForNavigateEvents is not null.

        // 2. Let navigation be navigable's active window's navigation API.

        // 3. Fire a traverse navigate event at navigation given targetEntry and userInvolvementForNavigateEvents.
    }

    // 8. If targetEntry's document is null, or targetEntry's document state's reload pending is true, then:
    si target_entry.donne_document() == nul || target_entry.document_state.reload_pending == vrai {
        // 1. Let navTimingType be "back_forward" if targetEntry's document is null; otherwise "reload".
        nav_timing_type := si target_entry.donne_document() == nul {
            NavigationTimingType.back_forward
        }
        sinon {
            NavigationTimingType.reload
        }

        // 2. Let targetSnapshotParams be the result of snapshotting target snapshot params given navigable.
        target_snapshot_params := snapshot_target_snapshot_params(navigable)

        // 3. Let potentiallyTargetSpecificSourceSnapshotParams be sourceSnapshotParams.
        potentially_target_specific_source_snapshot_params: SourceSnapshotParams
        
        // 4. If potentiallyTargetSpecificSourceSnapshotParams is null, then set it to the result of snapshotting source snapshot params given navigable's active document.
        si source_snapshot_params == nul {
            potentially_target_specific_source_snapshot_params = snapshot_source_snapshot_params(navigable.donne_active_document())
        }

        // 5. Set targetEntry's document state's reload pending to false.
        target_entry.document_state.reload_pending = faux

        // 6. Let allowPOST be targetEntry's document state's reload pending.
        allow_post := target_entry.document_state.reload_pending

        // 7. In parallel, attempt to populate the history entry's document for targetEntry, given navigable, potentiallyTargetSpecificSourceSnapshotParams, targetSnapshotParams, with allowPOST set to allowPOST and
        //   completionSteps set to queue a global task on the navigation and traversal task source given navigable's active window to run afterDocumentPopulated.

        tâche_after_document_populated := crée_tâche_pour_after_document_populated(target_entry, navigable, changing_navigable_continuation, changing_navigable_continuations)
        // À FAIRE : navigable.active_window
        completion_steps := crée_tâche_pour_enfiler_tâche(user_agent, tâche_after_document_populated, SourceDeTâche.NavigationEtTraversée)

        history_entry_population_params: HistoryEntryPopulationParams
        history_entry_population_params.user_agent = user_agent
        history_entry_population_params.entry = target_entry
        history_entry_population_params.navigable = navigable
        history_entry_population_params.source_snapshot_params = potentially_target_specific_source_snapshot_params
        history_entry_population_params.target_snapshot_params = target_snapshot_params
        history_entry_population_params.completion_steps = completion_steps
        history_entry_population_params.allow_post = allow_post
        history_entry_population_params.nav_timing_type = nav_timing_type

        tâche_pour_entry_population_attempt := crée_tâche_pour_entry_population_attempt(*history_entry_population_params)
        user_agent.lance_en_parallèle(tâche_pour_entry_population_attempt)
        retourne
    }

    // Otherwise, run afterDocumentPopulated immediately.
    after_document_populated(target_entry, navigable, changing_navigable_continuation, changing_navigable_continuations)
}

crée_tâche_pour_after_document_populated :: fonc (target_entry: *SessionHistoryEntry,
                                                  navigable: *Navigable,
                                                  changing_navigable_continuation: ChangingNavigableContinuationState,
                                                  changing_navigable_continuations: *[..]ChangingNavigableContinuationState) -> *Algorithm
{
    Tâche :: struct {
        empl base: Algorithm

        target_entry: *SessionHistoryEntry
        navigable: *Navigable
        changing_navigable_continuation: ChangingNavigableContinuationState
        changing_navigable_continuations: *[..]ChangingNavigableContinuationState
    }

    sur_run :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche

        target_entry := tâche.target_entry
        navigable := tâche.navigable
        changing_navigable_continuation := tâche.changing_navigable_continuation
        changing_navigable_continuations := tâche.changing_navigable_continuations

        after_document_populated(target_entry, navigable, changing_navigable_continuation, changing_navigable_continuations)
    }

    sur_destruction :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche
        déloge(tâche)
    }

    tâche := loge(Tâche)
    tâche.target_entry = target_entry
    tâche.navigable = navigable
    tâche.changing_navigable_continuation = changing_navigable_continuation
    tâche.changing_navigable_continuations = changing_navigable_continuations
    tâche.sur_run = sur_run
    tâche.sur_destruction = sur_destruction
    retourne tâche
}

after_document_populated :: fonc (target_entry: *SessionHistoryEntry,
                                  navigable: *Navigable @inutilisée,
                                  changing_navigable_continuation: ChangingNavigableContinuationState,
                                  changing_navigable_continuations: *[..]ChangingNavigableContinuationState)
{
    // 1. If targetEntry's document is null, then set changingNavigableContinuation's update-only to true.
    si target_entry.donne_document() == nul {
        changing_navigable_continuation.update_only = vrai
    }

    // À FAIRE : 2. If targetEntry's document's origin is not oldOrigin, then set targetEntry's classic history API state to StructuredSerializeForStorage(null).

    // À FAIRE : 3. If all of the following are true:
    //    navigable's parent is null;
    //    targetEntry's document's browsing context is not an auxiliary browsing context whose opener browsing context is non-null; and
    //    targetEntry's document's origin is not oldOrigin,
    //    then set targetEntry's document state's navigable target name to the empty string.

    // 4. Enqueue changingNavigableContinuation on changingNavigableContinuations.
    tableau_ajoute(changing_navigable_continuations, changing_navigable_continuation)
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#deactivate-a-document-for-a-cross-document-navigation */
deactivate_document_for_a_cross_document_navigation :: fonc (user_agent: *UserAgent,
                                                             displayed_document: *Document,
                                                             user_navigation_involvement: *UserNavigationInvolvement @inutilisée,
                                                             target_entry: *SessionHistoryEntry,
                                                             navigation_type: NavigationType @inutilisée,
                                                             after_potential_unloads: *Algorithm)
{
    // 1. Let navigable be displayedDocument's node navigable.
    navigable := displayed_document.donne_node_navigable()

    // 2. Let potentiallyTriggerViewTransition be false.
    potentially_trigger_view_transition := faux

    // 3. Let isBrowserUINavigation be true if userNavigationInvolvement is "browser UI"; otherwise false.
    // is_browser_ui_navigation := user_navigation_involvement != nul && mémoire(user_navigation_involvement) == UserNavigationInvolvement.BrowserUI

    // À FAIRE : 4. Set potentiallyTriggerViewTransition to the result of calling can navigation trigger a cross-document view-transition? given displayedDocument, targetEntry's document, navigationType, and isBrowserUINavigation.

    // 5. If potentiallyTriggerViewTransition is false, then:
    saufsi potentially_trigger_view_transition {
        // À FAIRE : 1. Let firePageSwapBeforeUnload be the following step:
        fire_page_swap_steps: *Algorithm

            // 1. Fire the pageswap event given displayedDocument, targetEntry, navigationType, and null.

        // 2. Set the ongoing navigation for navigable to null.
        init_de(OngoingNavigationType)(*navigable.ongoing_navigation)

        // 3. Unload a document and its descendants given displayedDocument, targetEntry's document, afterPotentialUnloads, and firePageSwapBeforeUnload.
        unload_a_document_and_its_descendants(user_agent, displayed_document, target_entry.donne_document(), after_potential_unloads, fire_page_swap_steps)

        retourne
    }

    // 6. Otherwise, queue a global task on the navigation and traversal task source given navigable's active window to run the steps:
    panique("continue ici")

        // 1. Let proceedWithNavigationAfterViewTransitionCapture be the following step:

            // 1. Append the following session history traversal steps to navigable's traversable navigable:

                // 1. Set the ongoing navigation for navigable to null.

                // 2. Unload a document and its descendants given displayedDocument, targetEntry's document, and afterPotentialUnloads.

        // 2. Let viewTransition be the result of setting up a cross-document view-transition given displayedDocument, targetEntry's document, navigationType, and proceedWithNavigationAfterViewTransitionCapture.

        // 3. Fire the pageswap event given displayedDocument, targetEntry, navigationType, and viewTransition.

        // 4. If viewTransition is null, then run proceedWithNavigationAfterViewTransitionCapture.
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#activate-history-entry */
activate_histroy_entry :: fonc (entry: *SessionHistoryEntry, navigable: *Navigable)
{
    // 1. Save persisted state to the navigable's active session history entry.
    save_persisted_state(navigable.active_session_history_entry)

    // 2. Let newDocument be entry's document.
    new_document := entry.donne_document()

    // 3. Assert: newDocument's is initial about:blank is false, i.e., we never traverse back to the initial about:blank Document because it always gets replaced when we navigate away from it.
    assert(new_document.is_initial_about_blank == faux)

    // 4. Set navigable's active session history entry to entry.
    navigable.active_session_history_entry = entry

    // 5. Make active newDocument.
    make_active(new_document)
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#getting-the-used-step */
get_the_used_step :: fonc (user_agent: *UserAgent, traversable: *TraversableNavigable, step: n32) -> n32
{
    // 1. Let steps be the result of getting all used history steps within traversable.
    steps := get_all_used_history_steps(user_agent, traversable)
    diffère déloge(steps)
 
    // 2. Return the greatest item in steps that is less than or equal to step.
    résultat: n32

    pour steps {
        si it > step {
            arrête
        }
        résultat = it
    }

    retourne résultat
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#get-all-navigables-whose-current-session-history-entry-will-change-or-reload */
get_all_navigables_whose_current_session_history_entry_will_change_or_reload :: fonc (user_agent: *UserAgent, traversable: *TraversableNavigable, target_step: n32) -> [..]*Navigable
{
    // 1. Let results be an empty list.
    results: [..]*Navigable

    // 2. Let navigablesToCheck be « traversable ».
    navigables_to_check: [..]*Navigable
    tableau_ajoute(*navigables_to_check, traversable)

    // 3. For each navigable of navigablesToCheck:
    tantque navigables_to_check.taille != 0 {
        navigable := enlève_dernier_élément(*navigables_to_check)

        // 1. Let targetEntry be the result of getting the target history entry given navigable and targetStep.
        target_entry := get_the_target_history_entry(user_agent, navigable, target_step)

        // 2. If targetEntry is not navigable's current session history entry or targetEntry's document state's reload pending is true,
        //    then append navigable to results.
        si target_entry != navigable.current_session_history_entry || target_entry.document_state.reload_pending {
            tableau_ajoute(*results, navigable)
        }

        // 3. If targetEntry's document is navigable's document, and targetEntry's document state's reload pending is false,
        //    then extend navigablesToCheck with the child navigables of navigable.
        document_navigable := navigable.donne_active_document()
        si document_navigable == target_entry.donne_document() && target_entry.document_state.reload_pending == faux {
            pour navigable.enfants {
                tableau_ajoute(*navigables_to_check, it)
            }
        }
    }

    // 4. Return results.
    retourne results
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#getting-all-navigables-that-only-need-history-object-length/index-update */
get_all_navigables_that_only_need_history_object_length_index_update :: fonc (user_agent: *UserAgent, traversable: *TraversableNavigable, target_step: n32) -> [..]*Navigable
{
    // 1. Let results be an empty list.
    results: [..]*Navigable

    // 2. Let navigablesToCheck be « traversable ».
    navigables_to_check: [..]*Navigable
    tableau_ajoute(*navigables_to_check, traversable)

    // 3. For each navigable of navigablesToCheck:
    tantque navigables_to_check.taille != 0 {
        navigable := enlève_dernier_élément(*navigables_to_check)

        // 1. Let targetEntry be the result of getting the target history entry given navigable and targetStep.
        target_entry := get_the_target_history_entry(user_agent, navigable, target_step)

        // 2. If targetEntry is navigable's current session history entry and targetEntry's document state's reload pending is false, then:
        si target_entry == navigable.current_session_history_entry && target_entry.document_state.reload_pending == faux {
            // 1. Append navigable to results.
            tableau_ajoute(*results, navigable)

            // 2. Extend navigablesToCheck with navigable's child navigables.
            pour navigable.enfants {
                tableau_ajoute(*navigables_to_check, it)
            }
        }
    }

    // Return results.
    retourne results
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#getting-the-target-history-entry */
get_the_target_history_entry :: fonc (user_agent: *UserAgent, navigable: *Navigable, step: n32) -> *SessionHistoryEntry
{
    // 1. Let entries be the result of getting session history entries for navigable.
    entries := donne_session_history_entries(user_agent, navigable)

    // 2. Return the item in entries that has the greatest step less than or equal to step.
    résultat: *SessionHistoryEntry

    plus_grand_step : n32 = 0

    pour mémoire(entries) {
        si it.step > step {
            continue
        }

        si it.step >= plus_grand_step {
            plus_grand_step = it.step
            résultat = it
        }
    }

    assert(résultat != nul)
    retourne résultat
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#getting-all-used-history-steps */
get_all_used_history_steps :: fonc (user_agent: *UserAgent, traversable: *TraversableNavigable) -> [..]n32
{
    // 1. Assert: this is running within traversable's session history traversal queue.
    assert(user_agent.est_exécuté_sur_file_parallèle(traversable))

    // 2. Let steps be an empty ordered set of non-negative integers.
    steps: [..]n32

    // NOTE : les étapes suivantes sont réalisées différemment
    // 3. Let entryLists be the ordered set « traversable's session history entries ».
    // 4. For each entryList of entryLists:
        // 1. For each entry of entryList:
            // 1. Append entry's step to steps.
            // 2. For each nestedHistory of entry's document state's nested histories, append nestedHistory's entries list to entryLists.

    entrées_à_visiter := tableau_copie(traversable.session_history_entries)
    diffère déloge(entrées_à_visiter)

    entrées_visitées: [..]*SessionHistoryEntry
    diffère déloge(entrées_visitées)

    tantque entrées_à_visiter.taille != 0 {
        entrée := enlève_dernier_élément(*entrées_à_visiter)

        si ensemble_possède(*entrées_visitées, entrée) {
            continue
        }
        ensemble_ajoute(*entrées_visitées, entrée)

        ensemble_ajoute(*steps, entrée.step)

        pour entrée_nichée dans entrée.document_state.nested_histories {
            pour she dans entrée_nichée.entries {
                tableau_ajoute(*entrées_à_visiter, she)
            }
        }
    }

    // 5. Return steps, sorted.
    retourne steps
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#getting-all-navigables-that-might-experience-a-cross-document-traversal */
get_all_navigables_that_might_experience_a_cross_document_traversal :: fonc (user_agent: *UserAgent, traversable: *TraversableNavigable, target_step: n32) -> [..]*Navigable
{
    // 1. Let results be an empty list.
    results: [..]*Navigable

    // 2. Let navigablesToCheck be « traversable ».
    navigables_to_check: [..]*Navigable
    tableau_ajoute(*navigables_to_check, traversable)

    // 3. For each navigable of navigablesToCheck:
    tantque navigables_to_check.taille != 0 {
        navigable := enlève_dernier_élément(*navigables_to_check)

        // 1. Let targetEntry be the result of getting the target history entry given navigable and targetStep.
        target_entry := get_the_target_history_entry(user_agent, navigable, target_step)

        // 2. If targetEntry's document is not navigable's document or targetEntry's document state's reload pending is true, then append navigable to results.
        document_navigable := navigable.donne_active_document()
        si document_navigable != target_entry.donne_document() || target_entry.document_state.reload_pending == vrai {
            tableau_ajoute(*results, navigable)
        }
        // 3. Otherwise, extend navigablesToCheck with navigable's child navigables.
        sinon {
            pour navigable.enfants {
                tableau_ajoute(*navigables_to_check, it)
            }
        }
    }

    // 4. Return results.
    retourne results
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#checking-if-unloading-is-canceled */
check_if_unloading_is_canceled :: fonc (navigables_crossing_documents: [..]*Navigable @inutilisée, traversable: *TraversableNavigable @inutilisée, user_involvement_for_navigate_events: *UserNavigationInvolvement @inutilisée) -> chaine
{
    imprime("À FAIRE : [%]\n", #nom_de_cette_fonction)
    retourne "continue"
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 7.4.6.2 Updating the document
 * https://html.spec.whatwg.org/multipage/browsing-the-web.html#updating-the-document
 * \{ */

DocumentUpdateParams :: struct {
    document: *Document
    entry: *SessionHistoryEntry
    do_not_reactivate: bool
    script_history_length: n32
    script_history_index: n32
    navigation_type: *NavigationType
    entries_for_navigation_api: []*SessionHistoryEntry
    previous_entry_for_activation: Optionnel(*SessionHistoryEntry)
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#update-document-for-history-step-application */
update_document_for_history_step_application :: fonc (empl params: *DocumentUpdateParams)
{
    // 1. Let documentIsNew be true if document's latest entry is null; otherwise false.
    document_is_new := document.latest_entry != nul

    // 2. Let documentsEntryChanged be true if document's latest entry is not entry; otherwise false.
    documents_entry_changed := document.latest_entry != entry

    // À FAIRE 3. Set document's history object's index to scriptHistoryIndex.

    // À FAIRE 4. Set document's history object's length to scriptHistoryLength.

    // À FAIRE 5. Let navigation be history's relevant global object's navigation API.

    // 6. If documentsEntryChanged is true, then:
    si documents_entry_changed {
        // 1. Let oldURL be document's latest entry's URL.
        // old_url: URI
        // si document.latest_entry {
        //     document.latest_entry.url
        // }

        // 2. Set document's latest entry to entry.
        document.latest_entry = entry

        // 3. Restore the history object state given document and entry.
        restore_the_history_object_state(document, entry)

        // 4. If documentIsNew is false, then:
        saufsi document_is_new {
            // 1. Assert: navigationType is not null.
            assert(navigation_type != nul)

            // À FAIRE : 2. Update the navigation API entries for a same-document navigation given navigation, entry, and navigationType.

            // À FAIRE : 3. Fire an event named popstate at document's relevant global object, using PopStateEvent, with the state attribute initialized to document's history object's state and hasUAVisualTransition initialized to true if a visual transition, to display a cached rendered state of the latest entry, was done by the user agent.

            // 4. Restore persisted state given entry.
            restore_persisted_state(entry)

            // À FAIRE : 5. If oldURL's fragment is not equal to entry's URL's fragment, then queue a global task on the DOM manipulation task source given document's relevant global object to fire an event named hashchange at document's relevant global object, using HashChangeEvent, with the oldURL attribute initialized to the serialization of oldURL and the newURL attribute initialized to the serialization of entry's URL.
        }
        // 5. Otherwise:
        sinon {
            // À FAIRE : 1. Assert: entriesForNavigationAPI is given.

            // 2. Restore persisted state given entry.
            restore_persisted_state(entry)

            // À FAIRE : 3. Initialize the navigation API entries for a new document given navigation, entriesForNavigationAPI, and entry.
        }
    }

    // 7. If all the following are true:
    // previousEntryForActivation is given;
    // navigationType is non-null; and
    // navigationType is "reload" or previousEntryForActivation's document is not document,
    // then:
    si previous_entry_for_activation.possède_valeur() && navigation_type != nul && (mémoire(navigation_type) == NavigationType.reload || donne_document(previous_entry_for_activation.Quelque) != document) {
        // À FAIRE : 1. If navigation's activation is null, then set navigation's activation to a new NavigationActivation object in navigation's relevant realm.

        // 2. Let previousEntryIndex be the result of getting the navigation API entry index of previousEntryForActivation within navigation.

        // 3. If previousEntryIndex is non-negative, then set activation's old entry to navigation's entry list[previousEntryIndex].

        // 4. Otherwise, if all the following are true:
        // navigationType is "replace";
        // previousEntryForActivation's document state's origin is same origin with document's origin; and
        // previousEntryForActivation's document's initial about:blank is false,
        // then set activation's old entry to a new NavigationHistoryEntry in navigation's relevant realm, whose session history entry is previousEntryForActivation.

        // 5. Set activation's new entry to navigation's current entry.

        // 6. Set activation's navigation type to navigationType.
    }

    // 8. If documentIsNew is true, then:
    si document_is_new {
        // À FAIRE : 1. Try to scroll to the fragment for document.

        // À FAIRE : 2. At this point scripts may run for the newly-created document document.
    }
    // 9. Otherwise, if documentsEntryChanged is false and doNotReactivate is false, then:
    sinon {
        // À FAIRE : 1. Assert: entriesForNavigationAPI is given.

        // À FAIRE : 2. Reactivate document given entry and entriesForNavigationAPI.
    }
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#restore-the-history-object-state */
restore_the_history_object_state :: fonc (document: *Document @inutilisée, entry: *SessionHistoryEntry @inutilisée)
{
    imprime("À FAIRE : [%]\n", #nom_de_cette_fonction)
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#make-active */
make_active :: fonc (document: *Document @inutilisée)
{
    imprime("À FAIRE : [%]\n", #nom_de_cette_fonction)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 7.4.6.5 Persisted history entry state
 * https://html.spec.whatwg.org/multipage/browsing-the-web.html#persisted-user-state-restoration
 * \{ */

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#save-persisted-state */
save_persisted_state :: fonc (entry: *SessionHistoryEntry @inutilisée)
{
    imprime("À FAIRE : [%]\n", #nom_de_cette_fonction)
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#restore-persisted-state */
restore_persisted_state :: fonc (entry: *SessionHistoryEntry @inutilisée)
{
    imprime("À FAIRE : [%]\n", #nom_de_cette_fonction)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 7.5.1 Shared document creation infrastructure
 * https://html.spec.whatwg.org/multipage/document-lifecycle.html#shared-document-creation-infrastructure
 * \{ */

/* https://html.spec.whatwg.org/multipage/document-lifecycle.html#initialise-the-document-object */
create_and_initialize_a_document_object :: fonc (user_agent: *UserAgent, type: chaine,  content_type: chaine, navigation_params: *NavigationParams) -> *Document
{
    // 1. Let browsingContext be navigationParams's navigable's active browsing context.
    browsing_context := navigation_params.navigable.donne_active_browsing_context()

    // 2. Set browsingContext to the result of the obtaining a browsing context to use for a navigation response given browsingContext, navigationParams's final sandboxing flag set, navigationParams's cross-origin opener policy, and navigationParams's COOP enforcement result.
    browsing_context = obtain_a_browsing_context_for_a_navigation_response(user_agent, browsing_context, navigation_params.final_sandboxing_flag, navigation_params.cross_origin_opener_policy, navigation_params.COOP_enforcement_result)

    // À FAIRE 3. Let permissionsPolicy be the result of creating a permissions policy from a response given navigationParams's navigable's container, navigationParams's origin, and navigationParams's response. [PERMISSIONSPOLICY]

    // 4. Let creationURL be navigationParams's response's URL.
    creation_url := navigation_params.response.donne_url()

    // 5. If navigationParams's request is non-null, then set creationURL to navigationParams's request's current URL.
    si navigation_params.request {
        url := navigation_params.request.donne_url_courant()
        creation_url = tente parse_uri_standard(recompose_uri(*url)) piège nonatteignable
    }

    // À FAIRE 6. Let window be null.

    // À FAIRE 7. If browsingContext's active document's is initial about:blank is true, and browsingContext's active document's origin is same origin-domain with navigationParams's origin, then set window to browsingContext's active window.

    // À FAIRE 8. Otherwise:

        // 1. Let oacHeader be the result of getting a structured field value given `Origin-Agent-Cluster` and "item" from navigationParams's response's header list.

        // 2. Let requestsOAC be true if oacHeader is not null and oacHeader[0] is the boolean true; otherwise false.

        // 3. If navigationParams's reserved environment is a non-secure context, then set requestsOAC to false.

        // 4. Let agent be the result of obtaining a similar-origin window agent given navigationParams's origin, browsingContext's group, and requestsOAC.

        // 5. Let realmExecutionContext be the result of creating a new realm given agent and the following customizations:
            // For the global object, create a new Window object.
            // For the global this binding, use browsingContext's WindowProxy object.

        // 6. Set window to the global object of realmExecutionContext's Realm component.

        // 7. Let topLevelCreationURL be creationURL.

        // 8. Let topLevelOrigin be navigationParams's origin.

        // 9. If navigable's container is not null, then:

            // 1. Let parentEnvironment be navigable's container's relevant settings object.

            // 2. Set topLevelCreationURL to parentEnvironment's top-level creation URL.

            // 3. Set topLevelOrigin to parentEnvironment's top-level origin.

        // 10. Set up a window environment settings object with creationURL, realmExecutionContext, navigationParams's reserved environment, topLevelCreationURL, and topLevelOrigin.

    // À FAIRE 9. Let loadTimingInfo be a new document load timing info with its navigation start time set to navigationParams's response's timing info's start time.

    // 10. Let document be a new Document, with
    //     type type
    //     content type contentType
    //     origin navigationParams's origin
    //     browsing context browsingContext
    //     policy container navigationParams's policy container
    //     permissions policy permissionsPolicy
    //     active sandboxing flag set navigationParams's final sandboxing flag set
    //     cross-origin opener policy navigationParams's cross-origin opener policy
    //     load timing info loadTimingInfo
    //     was created via cross-origin redirects navigationParams's response's has cross-origin redirects
    //     during-loading navigation ID for WebDriver BiDi navigationParams's id
    //     URL creationURL
    //     current document readiness "loading"
    //     about base URL navigationParams's about base URL
    //     allow declarative shadow roots true
    document := crée_noeud_document()
    document.type = type
    document.type_contenu = content_type
    document.origin = navigation_params.origin
    document.browsing_context = browsing_context
    //     policy container navigationParams's policy container
    //     permissions policy permissionsPolicy
    document.active_sandboxing_flags = navigation_params.final_sandboxing_flag
    document.cross_origin_opener_policy = navigation_params.cross_origin_opener_policy
    //     load timing info loadTimingInfo
    //     was created via cross-origin redirects navigationParams's response's has cross-origin redirects
    //     during-loading navigation ID for WebDriver BiDi navigationParams's id
    document.url = creation_url
    //     current document readiness "loading"
    document.about_base_url = navigation_params.about_base_URL
    document.permets_racines_shadow_déclaratives = vrai

    // À FAIRE 11. Set window's associated Document to document.

    // À FAIRE 12. Run CSP initialization for a Document given document. [CSP]

    // 13. If navigationParams's request is non-null, then:
    si navigation_params.request {
        imprime("À FAIRE : [document referrer]\n")
        // 1. Set document's referrer to the empty string.

        // 2. Let referrer be navigationParams's request's referrer.

        // 3. If referrer is a URL record, then set document's referrer to the serialization of referrer.
    }

    // 14. If navigationParams's fetch controller is not null, then:
    si navigation_params.fetch_controller {
        imprime("À FAIRE : [extract the full timing info from navigationParams's fetch controller]\n")
        // 1. Let fullTimingInfo be the result of extracting the full timing info from navigationParams's fetch controller.

        // 2. Let redirectCount be 0 if navigationParams's response's has cross-origin redirects is true; otherwise navigationParams's request's redirect count.

        // 3. Create the navigation timing entry for document, given fullTimingInfo, redirectCount, navigationTimingType, navigationParams's response's service worker timing info, and navigationParams's response's body info.
    }

    // À FAIRE 15. Create the navigation timing entry for document, with navigationParams's response's timing info, redirectCount, navigationParams's navigation timing type, and navigationParams's response's service worker timing info.

    // À FAIRE 16. If navigationParams's response has a `Refresh` header, then:

        // 1. Let value be the isomorphic decoding of the value of the header.

        // 2. Run the shared declarative refresh steps with document and value.

    // 17. If navigationParams's commit early hints is not null, then call navigationParams's commit early hints with document.
    si navigation_params.commit_early_hints {
        run(navigation_params.commit_early_hints, document)
    }

    // À FAIRE 18. Process link headers given document, navigationParams's response, and "pre-media".

    // 19. Return document.
    retourne document
}

/* https://html.spec.whatwg.org/multipage/document-lifecycle.html#populate-with-html/head/body */
populate_with_html_head_body :: fonc (document: *Document)
{
    // 1. Let html be the result of creating an element given document, html, and the HTML namespace.
    html := crée_élément_avec_tag(document, TAG_html)

    // 2. Let head be the result of creating an element given document, head, and the HTML namespace.
    head := crée_élément_avec_tag(document, TAG_html)

    // 3. Let body be the result of creating an element given document, body, and the HTML namespace.
    body := crée_élément_avec_tag(document, TAG_html)

    // 4. Append html to document.
    document.ajoute_enfant(html)

    // 5. Append head to html.
    html.ajoute_enfant(head)

    // 6. Append body to html.
    html.ajoute_enfant(body)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 7.5.2 Loading HTML documents
 * https://html.spec.whatwg.org/multipage/document-lifecycle.html#read-html
 * \{ */

/* https://html.spec.whatwg.org/multipage/document-lifecycle.html#navigate-html */
load_an_html_document :: fonc (user_agent: *UserAgent, navigation_params: *NavigationParams) -> *Document
{
    response := navigation_params.response

    // 1. Let document be the result of creating and initializing a Document object given "html", "text/html", and navigationParams.
    document := create_and_initialize_a_document_object(user_agent, "html", "text/html", navigation_params)

    // 2. If document's URL is about:blank, then populate with html/head/body given document.
    si document.url.uri == "about:blank" {
        populate_with_html_head_body(document)
    }
    // 3. Otherwise, create an HTML parser and associate it with the document. Each task that the networking task source places on the task queue while fetching runs must then fill the parser's input byte stream with the fetched bytes and cause the HTML parser to perform the appropriate processing of the input stream.
    sinon {
        parseuse := initialise_parseuse(response.body.Quelque, document)
        diffère détruit_parseuse(*parseuse)

        // début := maintenant_précis()
        parse(*parseuse)
        // temps := début.temps_écoulé_microsecondes()

        // À FAIRE : The first task that the networking task source places on the task queue while fetching runs must process link headers given document, navigationParams's response, and "media", after the task has been processed by the HTML parser.
        // À FAIRE : Before any script execution occurs, the user agent must wait for scripts may run for the newly-created document to be true for document.
        // À FAIRE : When no more bytes are available, the user agent must queue a global task on the networking task source given document's relevant global object to have the parser process the implied EOF character, which eventually causes a load event to be fired.
    }

    // 4. Return document.
    retourne document
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 7.5.8 Finishing the loading process
 * https://html.spec.whatwg.org/multipage/document-lifecycle.html#loading-documents
 * \{ */

/* https://html.spec.whatwg.org/multipage/document-lifecycle.html#completely-finish-loading */
completely_finish_loading :: fonc (document: *Document)
{
    imprime("À FAIRE : [%]\n", #nom_de_cette_fonction)

    // 1. Assert: document's browsing context is non-null.
    assert(document.browsing_context != nul)

    // 2. Set document's completely loaded time to the current time.

    // 3. Let container be document's node navigable's container.

    // 4. If container is an iframe element, then queue an element task on the DOM manipulation task source given container to run the iframe load event steps given container.

    // 5. Otherwise, if container is non-null, then queue an element task on the DOM manipulation task source given container to fire an event named load at container.
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 7.5.9 Unloading documents
 * https://html.spec.whatwg.org/multipage/document-lifecycle.html#unloading-documents
 * \{ */

/* https://html.spec.whatwg.org/multipage/document-lifecycle.html#unload-a-document */
unload_a_document :: fonc (user_agent: *UserAgent, old_document: *Document @inutilisée, new_document : *Document = nul @inutilisée)
{
    imprime("À FAIRE : [%]\n", #nom_de_cette_fonction)

    // 1. Assert: this is running as part of a task queued on oldDocument's relevant agent's event loop.
    // À FAIRE : oldDocument's relevant agent's event loop
    assert(user_agent.est_exécuté_sur_fil_principal())

    // 2. Let unloadTimingInfo be a new document unload timing info.

    // 3. If newDocument is not given, then set unloadTimingInfo to null.

    // 4. Otherwise, if newDocument's event loop is not oldDocument's event loop, then the user agent may be unloading oldDocument in parallel. In that case, the user agent should set unloadTimingInfo to null.

    // 5. Let intendToKeepInBfcache be true if the user agent intends to keep oldDocument alive in a session history entry, such that it can later be used for history traversal.

    // 6. Let eventLoop be oldDocument's relevant agent's event loop.

    // 7. Increase eventLoop's termination nesting level by 1.

    // 8. Increase oldDocument's unload counter by 1.

    // 9. If intendToKeepInBfcache is false, then set oldDocument's salvageable state to false.

    // 10. If oldDocument's page showing is true:

        // 1. Set oldDocument's page showing to false.

        // 2. Fire a page transition event named pagehide at oldDocument's relevant global object with oldDocument's salvageable state.

        // 3. Update the visibility state of oldDocument to "hidden".

    // 11. If unloadTimingInfo is not null, then set unloadTimingInfo's unload event start time to the current high resolution time given newDocument's relevant global object, coarsened given oldDocument's relevant settings object's cross-origin isolated capability.

    // 12. If oldDocument's salvageable state is false, then fire an event named unload at oldDocument's relevant global object, with legacy target override flag set.

    // 13. If unloadTimingInfo is not null, then set unloadTimingInfo's unload event end time to the current high resolution time given newDocument's relevant global object, coarsened given oldDocument's relevant settings object's cross-origin isolated capability.

    // 14. Decrease eventLoop's termination nesting level by 1.

    // 15. Set oldDocument's suspension time to the current high resolution time given document's relevant global object.

    // 16. Set oldDocument's suspended timer handles to the result of getting the keys for the map of active timers.

    // 17. Set oldDocument's has been scrolled by the user to false.

    // 18. Run any unloading document cleanup steps for oldDocument that are defined by this specification and other applicable specifications.

    // 19. If oldDocument's node navigable is a top-level traversable, build not restored reasons for a top-level traversable and its descendants given oldDocument's node navigable.

    // 20. If oldDocument's salvageable state is false, then destroy oldDocument.

    // 21. Decrease oldDocument's unload counter by 1.

    // 22. If newDocument is given, newDocument's was created via cross-origin redirects is false, and newDocument's origin is the same as oldDocument's origin, then set newDocument's previous document unload timing to unloadTimingInfo.
}

/* https://html.spec.whatwg.org/multipage/document-lifecycle.html#unload-a-document-and-its-descendants */
unload_a_document_and_its_descendants :: fonc (user_agent: *UserAgent, document: *Document, new_document : *Document = nul, after_all_unloads : *Algorithm = nul, fire_page_swap_steps : *Algorithm = nul)
{
    // 1. Assert: this is running within document's node navigable's traversable navigable's session history traversal queue.
    traversable := document.donne_node_navigable().donne_traversable_navigable()
    assert(user_agent.est_exécuté_sur_file_parallèle(traversable))

    // 2. Let childNavigables be document's child navigables.
    child_navigables := traversable.enfants

    // 3. Let numberUnloaded be 0.
    number_unloaded := 0

    // 4. For each childNavigable of childNavigables,
    pour child_navigable dans child_navigables {
        // queue a global task on the navigation and traversal task source given childNavigable's active window to perform the following steps:
        tâche := crée_tâche_unload_étape_4(user_agent, child_navigable.donne_active_document(), *number_unloaded)
        user_agent.enfile_une_tâche(SourceDeTâche.NavigationEtTraversée, tâche)
    }

    // 5. Wait until numberUnloaded equals childNavigable's size.
    tantque number_unloaded != child_navigables.taille {
        continue
    }

    // 6. Queue a global task on the navigation and traversal task source given document's relevant global object to perform the following steps:
    tâche := crée_tâche_unload_étape_6(user_agent, document, new_document, after_all_unloads, fire_page_swap_steps)
    user_agent.enfile_une_tâche(SourceDeTâche.NavigationEtTraversée, tâche)
}

crée_tâche_unload_étape_4 :: fonc (user_agent: *UserAgent, document: *Document, number_unloaded: *z32) -> *Algorithm
{
    Tâche :: struct {
        empl base: Algorithm

        user_agent: *UserAgent
        document: *Document
        number_unloaded: *z32
    }

    sur_run :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche

        // 1. Let incrementUnloaded be an algorithm step which increments numberUnloaded.
        increment_unloaded := crée_tâche_incrément_entier(tâche.number_unloaded)

        // 2. Unload a document and its descendants given childNavigable's active document, null, and incrementUnloaded.
        unload_a_document_and_its_descendants(tâche.user_agent, tâche.document, nul, increment_unloaded)
    }

    sur_destruction :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche
        déloge(tâche)
    }

    tâche := loge(Tâche)
    tâche.user_agent = user_agent
    tâche.document = document
    tâche.number_unloaded = number_unloaded
    tâche.sur_run = sur_run
    tâche.sur_destruction = sur_destruction
    retourne tâche
}

crée_tâche_unload_étape_6 :: fonc (user_agent: *UserAgent, document: *Document, new_document: *Document, after_all_unloads: *Algorithm, fire_page_swap_steps: *Algorithm) -> *Algorithm
{
    Tâche :: struct {
        empl base: Algorithm

        user_agent: *UserAgent
        document: *Document
        new_document: *Document
        after_all_unloads: *Algorithm
        fire_page_swap_steps: *Algorithm
    }

    sur_run :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche

        // 1. If firePageSwapSteps is given, then run firePageSwapSteps.
        si tâche.fire_page_swap_steps {
            run(tâche.fire_page_swap_steps)
        }

        // 2. Unload document, passing along newDocument if it is not null.
        unload_a_document(tâche.user_agent, tâche.document, tâche.new_document)

        // 3. If afterAllUnloads was given, then run it.
        si tâche.after_all_unloads {
            run(tâche.after_all_unloads)
        }
    }

    sur_destruction :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche
        déloge(tâche)
    }

    tâche := loge(Tâche)
    tâche.user_agent = user_agent
    tâche.document = document
    tâche.new_document = new_document
    tâche.after_all_unloads = after_all_unloads
    tâche.fire_page_swap_steps = fire_page_swap_steps
    tâche.sur_run = sur_run
    tâche.sur_destruction = sur_destruction
    retourne tâche
}

crée_tâche_incrément_entier :: fonc (nombre: *z32) -> *Algorithm
{
    Tâche :: struct {
        empl base: Algorithm

        nombre: *z32
    }

    sur_run :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche
        mémoire(tâche.nombre) += 1
    }

    sur_destruction :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche
        déloge(tâche)
    }

    tâche := loge(Tâche)
    tâche.nombre = nombre
    tâche.sur_run = sur_run
    tâche.sur_destruction = sur_destruction
    retourne tâche
}

/** \} */
