/* https://html.spec.whatwg.org/multipage/browsers.html#cross-origin-opener-policy-value */
CrossOriginOpenerPolicyValue :: énum n8 {
    UnsafeNone
    SameOriginAllowPopup
    SameOrigin
    SameOriginPlusCEOP
}

/* https://html.spec.whatwg.org/multipage/browsers.html#cross-origin-opener-policy */
CrossOriginOpenerPolicy :: struct {
    value: CrossOriginOpenerPolicyValue
    reporting_endpoint: Optionnel(chaine)
    report_only_value: CrossOriginOpenerPolicyValue
    report_only_reporting_endpoint: Optionnel(chaine)
}

/* https://html.spec.whatwg.org/multipage/browsers.html#coop-enforcement-result */
CrossOriginOpenerPolicyEnforcementResult :: struct {
    needs_a_browsing_context_group_switch := faux
    would_need_a_browsing_context_group_switch_due_to_report_only := faux
    current_context_is_navigation_source := faux
    url: *URL
    origin: Origin
    cross_origin_opener_policy: CrossOriginOpenerPolicy
}

/* https://w3c.github.io/navigation-timing/#sec-performance-navigation-types */
NavigationTimingType :: énum {
    navigate
    reload
    back_forward
    prerender
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#navigation-id */
NavigationID :: UUID

OngoingNavigationType :: union {
    NavigationID: NavigationID
    Chaine: chaine
}

est_nul :: fonc (ongoing: OngoingNavigationType) -> bool
{
    discr ongoing {
        NavigationID {
            retourne faux
        } 
        Chaine {
            retourne faux
        }
        sinon {}
    }
    retourne vrai
}

opérateur == :: fonc (a: OngoingNavigationType, b: OngoingNavigationType) -> bool
{
    discr a {
        NavigationID(id) {
            retourne b == id
        }
        Chaine(c) {
            retourne b == c
        }
        sinon {
            retourne faux
        }
    }
}

opérateur != :: fonc (a: OngoingNavigationType, b: OngoingNavigationType) -> bool
{
    retourne !(a == b)
}

opérateur == :: fonc (ongoing: OngoingNavigationType, navigation_id: NavigationID) -> bool
{
    discr ongoing {
        NavigationID(id) {
            retourne id == navigation_id
        }
        sinon {
            retourne faux
        }
    }
}

opérateur != :: fonc (ongoing: OngoingNavigationType, navigation_id: NavigationID) -> bool
{
    retourne !(ongoing == navigation_id)
}

opérateur == :: fonc (ongoing: OngoingNavigationType, navigation_id: Optionnel(NavigationID)) -> bool
{
    discr ongoing {
        NavigationID(id) {
            si navigation_id.possède_valeur() {
                retourne id == navigation_id.Quelque
            }
            retourne faux
        }
        Chaine {
            retourne !navigation_id.possède_valeur()
        }
        sinon {
            si navigation_id.possède_valeur() {
                retourne faux
            }
            retourne vrai
        }
    }
}

opérateur != :: fonc (ongoing: OngoingNavigationType, navigation_id: Optionnel(NavigationID)) -> bool
{
    retourne !(ongoing == navigation_id)
}

opérateur == :: fonc (ongoing: OngoingNavigationType, chn: chaine) -> bool
{
    discr ongoing {
        Chaine(c) {
            retourne c == chn
        }
        sinon {
            retourne faux
        }
    }
}

opérateur != :: fonc (ongoing: OngoingNavigationType, chn: chaine) -> bool
{
    retourne !(ongoing == chn)
}

/* must be an algorithm accepting a Document */
CommitEarlyHints :: struct {
    sur_rappel: fonc(*CommitEarlyHints, *Document)(rien)
    sur_destruction: fonc (*CommitEarlyHints)(rien)
}

run :: fonc (commit_early_hints: *CommitEarlyHints, document: *Document)
{
    si commit_early_hints.sur_rappel {
        commit_early_hints.sur_rappel(commit_early_hints, document)
    }
    si commit_early_hints.sur_destruction {
        commit_early_hints.sur_destruction(commit_early_hints)
    }
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#navigation-params */
NavigationParams :: struct {
    id: Optionnel(NavigationID)
    navigable: *Navigable
    request: *Request
    response: *Response
    fetch_controller: *FetchController
    /* null or an algorithm accepting a Document, once it has been created */
    commit_early_hints: *CommitEarlyHints
    
    COOP_enforcement_result: CrossOriginOpenerPolicyEnforcementResult
    reserved_environment: *Environment
    
    origin: Origin
    
    // a policy container to use for the new Document
    policy_container: *PolicyContainer

    final_sandboxing_flag: SandboxingFlags
    cross_origin_opener_policy: CrossOriginOpenerPolicy
    
    navigation_timing_type: NavigationTimingType
    
    about_base_url: *URL
}

/* À FAIRE https://html.spec.whatwg.org/multipage/browsing-the-web.html#non-fetch-scheme-navigation-params */
est_non_fetch_scheme :: fonc (navigation_params: *NavigationParams @inutilisée) -> bool
{
    retourne faux
}

est_navigation_params :: fonc (navigation_params: *NavigationParams) -> bool
{
    /* À FAIRE : non-fetch scheme */
    retourne navigation_params != nul
}

détruit_navigation_params :: fonc (navigation_params: *NavigationParams)
{
    détruit_fetch_controller(navigation_params.fetch_controller)
    détruit_response(navigation_params.response)
    détruit_request(navigation_params.request)
    déloge(navigation_params)
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#source-snapshot-params */
SourceSnapshotParams :: struct {
    has_transient_activation: bool
    sandboxing_flags: SandboxingFlags
    allows_downloading: bool
    fetch_client: *EnvironmentSettings
    source_policy_container: *PolicyContainer
}

snapshot_source_snapshot_params :: fonc (source_document: *Document) -> SourceSnapshotParams
{
    imprime("À FAIRE : [%]\n", #nom_de_cette_fonction)

    résultat: SourceSnapshotParams
    // 1. If sourceDocument is null, then return a new source snapshot params with
    si source_document == nul {
        // has transient activation -> true
        résultat.has_transient_activation = vrai
        // sandboxing flags -> an empty sandboxing flag set
        // allows downloading -> true
        résultat.allows_downloading = vrai
        // fetch client -> null
        résultat.fetch_client = nul
        // source policy container -> a new policy container
        résultat.source_policy_container = loge(PolicyContainer)
    }
    // 2. Return a new source snapshot params with
    sinon {
        // has transient activation = true if sourceDocument's relevant global object has transient activation; otherwise false
        // sandboxing flags = sourceDocument's active sandboxing flag set
        // allows downloading = false if sourceDocument's active sandboxing flag set has the sandboxed downloads browsing context flag set; otherwise true
        // fetch client = sourceDocument's relevant settings object
        résultat.fetch_client = source_document.donne_relevant_settings_object()
        // source policy container -> a clone of sourceDocument's policy container

        // À FAIRE : doit être fait lors de la création
        saufsi source_document.policy_container {
            source_document.policy_container = loge(PolicyContainer)
        }

        résultat.source_policy_container = clone(source_document.policy_container)
    }
    retourne résultat
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#target-snapshot-params */
TargetSnapshotParams :: struct {
    sandboxing_flags: SandboxingFlags
}

snapshot_target_snapshot_params :: fonc (target_navigable: *Navigable) -> TargetSnapshotParams
{
    résultat: TargetSnapshotParams
    résultat.sandboxing_flags = détermine_drapeaux_sandboxing(target_navigable.donne_active_browsing_context(), target_navigable.donne_container())
    retourne résultat
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#navigationhistorybehavior */
NavigationHistoryBehavior :: énum {
    PUSH
    REPLACE
    AUTO
}

/* https://html.spec.whatwg.org/multipage/nav-history-apis.html#navigationtype */
NavigationType :: énum {
    push
    replace
    reload
    traverse
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#the-navigation-must-be-a-replace */
navigation_must_be_a_replace :: fonc (url: *URL, document: *Document) -> bool
{
    retourne document.is_initial_about_blank || url.scheme == "javascript"
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#user-navigation-involvement */
UserNavigationInvolvement :: énum {
    BrowserUI
    Activation
    None
}

/* ------------------------------------------------------------------------- */
/** \nom 7.4.2.2 Beginning navigation
 * https://html.spec.whatwg.org/multipage/browsing-the-web.html#beginning-navigation
 * \{ */

ParamètresNavigationNavigable :: struct {
    // URL url
    url: *URL
    // Document sourceDocument,
    source_document: *Document
    // optional POST resource, string, or null documentResource (default null)
    // an optional response-or-null response (default null)
    // an optional boolean exceptionsEnabled (default false)
    // an optional NavigationHistoryBehavior historyHandling (default "auto")
    history_handling := NavigationHistoryBehavior.AUTO
    // an optional serialized state-or-null navigationAPIState (default null)
    // an optional entry list or null formDataEntryList (default null)
    form_data_entry_list : *EntryList = nul
    // an optional referrer policy referrerPolicy (default the empty string)
    referrer_policy := ReferrerPolicy.EmptyString
    // and an optional user navigation involvement userInvolvement (default "none"):
    user_involvement := UserNavigationInvolvement.None
}

navigate :: fonc (user_agent: *UserAgent, navigable: *Navigable, empl params: ParamètresNavigationNavigable)
{
    // 1. Let cspNavigationType be "form-submission" if formDataEntryList is non-null; otherwise "other".

    // 2. Let sourceSnapshotParams be the result of snapshotting source snapshot params given sourceDocument.
    source_snapshot_params := snapshot_source_snapshot_params(source_document)

    // 3. Let initiatorOriginSnapshot be sourceDocument's origin.
    initiator_origin_snapshot := source_document.origin

    // 4. Let initiatorBaseURLSnapshot be sourceDocument's document base URL.

    // 5. If sourceDocument's node navigable is not allowed by sandboxing to navigate navigable given sourceSnapshotParams, then:

        // 1. If exceptionsEnabled is true, then throw a "SecurityError" DOMException.

        // 2. Return.

    // 6. Let navigationId be the result of generating a random UUID. [WEBCRYPTO]
    navigation_id := génère_un_uuid_aléatoire()

    // 7. If the surrounding agent is equal to navigable's active document's relevant agent, then continue these steps. Otherwise, queue a global task on the navigation and traversal task source given navigable's active window to continue these steps.

    // 8. If navigable's active document's unload counter is greater than 0, then
    //    invoke WebDriver BiDi navigation failed with a WebDriver BiDi navigation
    //    status whose id is navigationId, status is "canceled", and url is url, and return.
    si navigable.donne_active_document().unload_counter > 0 {
        navigation_status: WebDriverNavigationStatus
        navigation_status.id = navigation_id
        navigation_status.url = url
        navigation_status.status = "canceled"
        webdriver_bidi_navigation_failed(navigable, *navigation_status)
    }

    // 9. Let container be navigable's container.

    // 10. If container is an iframe element and will lazy load element steps given container returns true, then stop intersection-observing a lazy loading element container and set container's lazy load resumption steps to null.

    // 11. If historyHandling is "auto", then:
    si history_handling == NavigationHistoryBehavior.AUTO {
        active_document := navigable.donne_active_document()

        chn_url := url_serializer(url)
        diffère déloge(chn_url)

        chn_url_active_document := url_serializer(active_document.url)
        diffère déloge(chn_url_active_document)

        // 1. If url equals navigable's active document's URL,
        //    and initiatorOriginSnapshot is same origin with targetNavigable's active document's origin,
        //    then set historyHandling to "replace".
        si chn_url == chn_url_active_document && sont_même_origine(initiator_origin_snapshot, active_document.origin) {
            history_handling = NavigationHistoryBehavior.REPLACE
        }
        // 2. Otherwise, set historyHandling to "push".
        sinon {
            history_handling = NavigationHistoryBehavior.PUSH
        }
    }

    // 12. If the navigation must be a replace given url and navigable's active document, then set historyHandling to "replace".
    si navigation_must_be_a_replace(url, navigable.donne_active_document()) {
        history_handling = NavigationHistoryBehavior.REPLACE
    }

    // 13. If all of the following are true:
    //     À FAIRE documentResource is null;
    //     À FAIRE response is null;
    //     url equals navigable's active session history entry's URL with exclude fragments set to true; and
    //     url's fragment is non-null,
    //     then:
    si url.fragment.possède_valeur() && equals(url, navigable.active_session_history_entry.url, vrai) {
        // 1. Navigate to a fragment given navigable, url, historyHandling, userInvolvement, navigationAPIState, and navigationId.
        navigate_to_a_fragment(user_agent, navigable, url, history_handling, user_involvement, navigation_id)

        // 2. Return.
        retourne
    }

    // 14. If navigable's parent is non-null, then set navigable's is delaying load events to true.
    si navigable.parent {
        navigable.is_delaying_load_events = vrai
    }

    // 15. Let targetBrowsingContext be navigable's active browsing context.
    target_browsing_context := navigable.donne_active_browsing_context()

    // 16. Let targetSnapshotParams be the result of snapshotting target snapshot params given navigable.
    target_snapshot_params := snapshot_target_snapshot_params(navigable)

    // 17. Invoke WebDriver BiDi navigation started with targetBrowsingContext,
    //     and a new WebDriver BiDi navigation status whose id is navigationId,
    //     status is "pending", and url is url.
    navigation_status: WebDriverNavigationStatus
    navigation_status.id = navigation_id
    navigation_status.url = url
    navigation_status.status = "pending"
    webdriver_bidi_navigation_started(target_browsing_context, *navigation_status)

    // 18. If navigable's ongoing navigation is "traversal", then:
    si navigable.ongoing_navigation == "traversal" {
        // 1. Invoke WebDriver BiDi navigation failed with targetBrowsingContext and a new WebDriver BiDi navigation status whose id is navigationId, status is "canceled", and url is url.
        navigation_status.id = navigation_id
        navigation_status.url = url
        navigation_status.status = "canceled"
        webdriver_bidi_navigation_failed(target_browsing_context, *navigation_status)

        // 2. Return.
        retourne
    }

    // 19. Set the ongoing navigation for navigable to navigationId.
    navigable.définis_ongoing_navigation(navigation_id)

    // 20. If url's scheme is "javascript", then:
    si url.scheme == "javascript" {
        // 1. Queue a global task on the navigation and traversal task source given navigable's active window to navigate to a javascript: URL given navigable, url, historyHandling, initiatorOriginSnapshot, and cspNavigationType.
        tâche := crée_tâche_pour_navigate_to_javascript_url(user_agent, navigable, url, history_handling, initiator_origin_snapshot)
        user_agent.queue_a_globask_task(SourceDeTâche.NavigationEtTraversée, navigable.donne_active_window(), tâche)

        // 2. Return.
        retourne
    }

    // 21. If all of the following are true:
    //     userInvolvement is not "browser UI";
    //     navigable's active document's origin is same origin-domain with sourceDocument's origin;
    //     navigable's active document's is initial about:blank is false; and
    //     url's scheme is a fetch scheme,
    //     then:

        // 1. Let navigation be navigable's active window's navigation API.

        // 2. Let entryListForFiring be formDataEntryList if documentResource is a POST resource; otherwise, null.

        // 3. Let navigationAPIStateForFiring be navigationAPIState if navigationAPIState is not null; otherwise, StructuredSerializeForStorage(undefined).

        // 4. Let continue be the result of firing a push/replace/reload navigate event at navigation with navigationType set to historyHandling, isSameDocument set to false, userInvolvement set to userInvolvement, formDataEntryList set to entryListForFiring, destinationURL set to url, and navigationAPIState set to navigationAPIStateForFiring.

        // 5. If continue is false, then return.

    // 22. In parallel, run these steps:
    Tâche :: struct {
        empl base: Algorithm

        params: NavigateParallelStepsParams
    }

    sur_run :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche
        navigate_parallel_steps(*tâche.params)
    }

    tâche := crée_algorithm(sur_run, Tâche)
    tâche.params.user_agent = user_agent
    tâche.params.navigable = navigable
    tâche.params.url = url
    tâche.params.source_snapshot_params = source_snapshot_params
    tâche.params.target_snapshot_params = target_snapshot_params
    tâche.params.history_handling = history_handling
    tâche.params.navigation_id = navigation_id
    tâche.params.target_browsing_context = target_browsing_context
    tâche.params.referrer_policy = referrer_policy
    tâche.params.user_involvement = user_involvement

    user_agent.lance_en_parallèle(tâche)
}

NavigateParallelStepsParams :: struct {
    user_agent: *UserAgent
    navigable: *Navigable
    url: *URL
    source_snapshot_params: SourceSnapshotParams
    target_snapshot_params: TargetSnapshotParams
    history_handling: NavigationHistoryBehavior
    navigation_id: NavigationID
    target_browsing_context: *BrowsingContext
    referrer_policy: ReferrerPolicy
    user_involvement: UserNavigationInvolvement
}

navigate_parallel_steps :: fonc (params: *NavigateParallelStepsParams)
{
    user_agent := params.user_agent
    navigable := params.navigable
    url := params.url
    source_snapshot_params := params.source_snapshot_params
    target_snapshot_params := params.target_snapshot_params
    history_handling := params.history_handling
    navigation_id := params.navigation_id
    target_browsing_context := params.target_browsing_context
    user_involvement := params.user_involvement

    // 1. Let unloadPromptCanceled be the result of checking if unloading is
    //    canceled for navigable's active document's inclusive descendant navigables.

    // 2. If unloadPromptCanceled is true, or navigable's ongoing navigation is no longer navigationId, then:
    si navigable.ongoing_navigation != navigation_id {
        // 1. Invoke WebDriver BiDi navigation failed with targetBrowsingContext
        //    and a new WebDriver BiDi navigation status whose id is navigationId,
        //    status is "canceled", and url is url.
        navigation_status: WebDriverNavigationStatus
        navigation_status.id = navigation_id
        navigation_status.url = url
        navigation_status.status = "canceled"
        webdriver_bidi_navigation_failed(target_browsing_context, *navigation_status)

        // 2. Abort these steps.
        retourne
    }

    // 3. Queue a global task on the navigation and traversal task source given navigable's active window to abort a document and its descendants given navigable's active document.

    // À FAIRE : 4. Let documentState be a new document state with
    //     request referrer policy    referrerPolicy
    //     initiator origin    initiatorOriginSnapshot
    //     resource    documentResource
    //     navigable target name    navigable's target name
    document_state := loge(DocumentState)
    document_state.request_referrer_policy = params.referrer_policy

    // 5. If url matches about:blank or is about:srcdoc, then:

        // 1. Set documentState's origin to initiatorOriginSnapshot.

        // 2. Set documentState's about base URL to initiatorBaseURLSnapshot.

    // 6. Let historyEntry be a new session history entry, with its URL set to url and its document state set to documentState.
    history_entry := loge(SessionHistoryEntry)
    history_entry.url = url
    history_entry.document_state = document_state

    // 7. Let navigationParams be null.
    navigation_params: *NavigationParams

    // 8. If response is non-null:

        // 1. Let policyContainer be the result of determining navigation params policy container given response's URL, null, a clone of the sourceDocument's policy container, navigable's container document's policy container, and null.

        // 2. Let finalSandboxFlags be the union of targetSnapshotParams's sandboxing flags and policyContainer's CSP list's CSP-derived sandboxing flags.

        // 3. Let responseOrigin be the result of determining the origin given response's URL, finalSandboxFlags, and documentState's initiator origin.

        // 4. Let coop be a new cross-origin opener policy.

        // 5. Let coopEnforcementResult be a new cross-origin opener policy enforcement result with
        //     url    response's URL
        //     origin     responseOrigin
        //     cross-origin opener policy     coop

        // 6. Set navigationParams to a new navigation params, with
        //     id     navigationId
        //     navigable    navigable
        //     request    null
        //     response    response
        //     fetch controller    null
        //     commit early hints    null
        //     COOP enforcement result    coopEnforcementResult
        //     reserved environment    null
        //     origin    responseOrigin
        //     policy container    policyContainer
        //     final sandboxing flag set    finalSandboxFlags
        //     cross-origin opener policy    coop
        //     navigation timing type    "navigate"
        //     about base URL    documentState's about base URL

    // 9. Attempt to populate the history entry's document for historyEntry, given
    //    navigable, "navigate", sourceSnapshotParams, targetSnapshotParams, navigationId, navigationParams, cspNavigationType, with allowPOST set to true
    //    and completionSteps set to the following step:
    //        1. Append session history traversal steps to navigable's traversable to finalize a cross-document navigation given navigable, historyHandling, and historyEntry.
    Tâche :: struct {
        empl base: Algorithm

        user_agent: *UserAgent
        navigable: *Navigable
        user_involvement: UserNavigationInvolvement
        history_handling: NavigationHistoryBehavior
        history_entry: *SessionHistoryEntry
    }

    tâche_run :: fonc (base: *Algorithm)
    {
        steps := base comme *Tâche
        finalize_a_cross_document_navigation(steps.user_agent, steps.navigable, steps.history_handling, steps.user_involvement, steps.history_entry)
    }

    tâche := crée_algorithm(tâche_run, Tâche)
    tâche.user_agent = user_agent
    tâche.navigable = navigable
    tâche.history_handling = history_handling
    tâche.history_entry = history_entry
    tâche.user_involvement = user_involvement

    completion_steps := crée_tâche_pour_traversable(user_agent, tâche, navigable.donne_traversable_navigable())

    history_entry_population_params: HistoryEntryPopulationParams
    history_entry_population_params.user_agent = user_agent
    history_entry_population_params.entry = history_entry
    history_entry_population_params.navigable = navigable
    history_entry_population_params.nav_timing_type =  NavigationTimingType.navigate
    history_entry_population_params.source_snapshot_params = source_snapshot_params
    history_entry_population_params.target_snapshot_params = target_snapshot_params
    history_entry_population_params.navigation_id = navigation_id
    history_entry_population_params.navigation_params = navigation_params
    history_entry_population_params.completion_steps = completion_steps

    attempt_to_populate_the_history_entry_document(*history_entry_population_params)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 7.4.2.3 Ending Navigation
 * \{ */

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#finalize-a-cross-document-navigation */
finalize_a_cross_document_navigation :: fonc (user_agent: *UserAgent, navigable: *Navigable, history_handling: NavigationHistoryBehavior, user_involvement: UserNavigationInvolvement, history_entry: *SessionHistoryEntry)
{
    traversable := navigable.donne_traversable_navigable()

    // 1. Assert: this is running on navigable's traversable navigable's session history traversal queue.
    assert(user_agent.est_exécuté_sur_file_parallèle(traversable))

    // 2. Set navigable's is delaying load events to false.
    navigable.is_delaying_load_events = faux

    // 3. If historyEntry's document is null, then return.
    si history_entry.donne_document() == nul {
        retourne
    }

    // À FAIRE : 4. If all of the following are true:
    //    navigable's parent is null;
    //    historyEntry's document's browsing context is not an auxiliary browsing context whose opener browsing context is non-null; and
    //    historyEntry's document's origin is not navigable's active document's origin,
    // then set historyEntry's document state's navigable target name to the empty string.

    // 5. Let entryToReplace be navigable's active session history entry if historyHandling is "replace", otherwise null.
    entry_to_replace: *SessionHistoryEntry
    si history_handling == NavigationHistoryBehavior.REPLACE {
        entry_to_replace = navigable.active_session_history_entry
    }

    // 6. Let traversable be navigable's traversable navigable.
    // Fait plus haut.

    // 7. Let targetStep be null.
    target_step: Optionnel(n32) 

    // 8. Let targetEntries be the result of getting session history entries for navigable.
    target_entries := donne_session_history_entries(user_agent, navigable)

    // 9. If entryToReplace is null, then:
    si entry_to_replace == nul {
        // 1. Clear the forward session history of traversable.
        clear_the_forward_session_history(user_agent, traversable)

        // 2. Set targetStep to traversable's current session history step + 1.
        target_step = traversable.current_session_history_entry_step + 1

        // 3. Set historyEntry's step to targetStep.
        history_entry.step = target_step.Quelque

        // 4. Append historyEntry to targetEntries.
        tableau_ajoute(target_entries, history_entry)
    }
    // Otherwise:
    sinon {
        // 1. Replace entryToReplace with historyEntry in targetEntries.
        tableau_remplace(target_entries, entry_to_replace, history_entry)

        // 2. Set historyEntry's step to entryToReplace's step.
        history_entry.step = entry_to_replace.step

        // À FAIRE 3. If historyEntry's document state's origin is same origin with entryToReplace's document state's origin,
        //    then set historyEntry's navigation API key to entryToReplace's navigation API key.

        // 4. Set targetStep to traversable's current session history step.
        target_step = traversable.current_session_history_entry_step
    }

    // 10. Apply the push/replace history step targetStep to traversable given historyHandling.
    _ := apply_the_push_replace_history_step(user_agent, target_step, traversable, history_handling, user_involvement)

    si user_agent {
        document := history_entry.donne_document()
        user_agent.document_est_prêt(document)
    }
}

/** } */

/* ------------------------------------------------------------------------- */
/** \nom 7.4.2.3.2 The javascript: URL special case
 * https://html.spec.whatwg.org/multipage/browsing-the-web.html#navigate-to-a-javascript:-url
 * \{ */

navigate_to_a_javascript_url :: fonc (user_agent: *UserAgent, target_navigable: *Navigable, url: *URL, history_handling: NavigationHistoryBehavior, initiator_origin: Origin)
{
    saufsi user_agent.supporte_scripting {
        retourne
    }

    // 1. Assert: historyHandling is "replace".
    assert(history_handling == NavigationHistoryBehavior.REPLACE)

    // 2. Set the ongoing navigation for targetNavigable to null.
    init_de(OngoingNavigationType)(*target_navigable.ongoing_navigation)

    // 3. If initiatorOrigin is not same origin-domain with targetNavigable's active document's origin, then return.

    // 4. Let request be a new request whose URL is url.

    // 5. If the result of should navigation request of type be blocked by Content Security Policy? given request and cspNavigationType is "Blocked", then return. [CSP]

    // 6. Let newDocument be the result of evaluating a javascript: URL given targetNavigable, url, and initiatorOrigin.
    new_document := evaluate_a_javascript_url(user_agent, target_navigable, url, initiator_origin)

    // 7. If newDocument is null, then return.
    saufsi new_document {
        retourne
    }

    // 8. Assert: initiatorOrigin is newDocument's origin.
    panique("non-implémenté")

    // 9. Let entryToReplace be targetNavigable's active session history entry.

    // 10. Let oldDocState be entryToReplace's document state.

    // 11. Let documentState be a new document state with
    // document  newDocument
    // history policy container  a clone of the oldDocState's history policy container if it is non-null; null otherwise
    // request referrer  oldDocState's request referrer
    // request referrer policy oldDocState's request referrer policy or should this be the referrerPolicy that was passed to navigate?
    // initiator origin  initiatorOrigin
    // origin  initiatorOrigin
    // about base URL oldDocState's about base URL
    // resource  null
    // ever populated  true
    // navigable target name  oldDocState's navigable target name

    // 12. Let historyEntry be a new session history entry, with
    // URL  entryToReplace's URL
    // document state  documentState

    // 13. Append session history traversal steps to targetNavigable's traversable to finalize a cross-document navigation with targetNavigable, historyHandling, and historyEntry.
}

evaluate_a_javascript_url :: fonc (user_agent: *UserAgent, target_navigable: *Navigable, url: *URL, initiator_origin: Origin @inutilisée) -> *Document
{
    // 1. Let urlString be the result of running the URL serializer on url.
    url_string := url_serializer(url)
    diffère déloge(url_string)

    // 2. Let encodedScriptSource be the result of removing the leading "javascript:" from urlString.
    encoded_script_source := url_string.avance("javascript:".taille)

    // À FAIRE : 3. Let scriptSource be the UTF-8 decoding of the percent-decoding of encodedScriptSource.
    script_source := encoded_script_source

    // 4. Let settings be targetNavigable's active document's relevant settings object.
    settings := target_navigable.donne_active_document().donne_relevant_settings_object()

    // 5. Let baseURL be settings's API base URL.
    base_url := settings.donne_api_base_url()

    // 6. Let script be the result of creating a classic script given scriptSource, settings, baseURL, and the default script fetch options.
    options: OptionsFetchScript
    script := create_a_classic_script(user_agent, script_source, settings, base_url, options)

    // 7. Let evaluationStatus be the result of running the classic script script.
    evaluation_status := run_the_classic_script(script)

    // 8. Let result be null.

    // 9. If evaluationStatus is a normal completion, and evaluationStatus.[[Value]] is a String, then set result to evaluationStatus.[[Value]].
    si JS.est_normal(evaluation_status) && JS.est_chaine(evaluation_status.valeur.V) {
        panique("non-implémenté")
    }
    // 10. Otherwise, return null.
    sinon {
        retourne nul
    }

    // 11. Let response be a new response with
    // URL    targetNavigable's active document's URL
    // header list  « (`Content-Type`, `text/html;charset=utf-8`) »
    // body  the UTF-8 encoding of result, as a body
    panique("non-implémenté")

    // 12. Let policyContainer be targetNavigable's active document's policy container.

    // 13. Let finalSandboxFlags be policyContainer's CSP list's CSP-derived sandboxing flags.

    // 14. Let coop be targetNavigable's active document's opener policy.

    // 15. Let coopEnforcementResult be a new opener policy enforcement result with
    // url  url
    // origin  newDocumentOrigin
    // opener policy / coop

    // 16. Let navigationParams be a new navigation params, with
    // id   navigationId
    // navigable  targetNavigable
    // request null this will cause the referrer of the resulting Document to be null; is that correct?
    // response  response
    // fetch controller  null
    // commit early hints  null
    // COOP enforcement result coopEnforcementResult
    // reserved environment    null
    // origin    newDocumentOrigin
    // policy container   policyContainer
    // final sandboxing flag set  finalSandboxFlags
    // opener policy  coop
    // navigation timing type  "navigate"
    // about base URL targetNavigable's active document's about base URL

    // 17. Return the result of loading an HTML document given navigationParams.
}

#portée_fichier

crée_tâche_pour_navigate_to_javascript_url :: fonc (user_agent: *UserAgent, target_navigable: *Navigable, url: *URL, history_handling: NavigationHistoryBehavior, initiator_origin: Origin) -> *Algorithm
{
    Tâche :: struct {
        empl base: Algorithm

        user_agent: *UserAgent
        target_navigable: *Navigable
        url: *URL
        history_handling: NavigationHistoryBehavior
        initiator_origin: Origin
    }

    sur_run :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche
        navigate_to_a_javascript_url(tâche.user_agent, tâche.target_navigable, tâche.url, tâche.history_handling, tâche.initiator_origin)
    }

    tâche := crée_algorithm(sur_run, Tâche)
    tâche.user_agent = user_agent
    tâche.target_navigable = target_navigable
    tâche.url = url
    tâche.history_handling = history_handling
    tâche.initiator_origin = initiator_origin
    retourne tâche
}

#portée_export

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 7.4.2.3.3 Fragment navigations
 * https://html.spec.whatwg.org/multipage/browsing-the-web.html#scroll-to-fragid
 * \{ */

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#navigate-fragid */
navigate_to_a_fragment :: fonc (user_agent: *UserAgent,
                                navigable: *Navigable,
                                url: *URL,
                                history_handling: NavigationHistoryBehavior,
                                user_involvement: UserNavigationInvolvement,
                                navigation_id: &NavigationID @inutilisée)
{
    // 1. Let navigation be navigable's active window's navigation API.

    // 2. Let destinationNavigationAPIState be navigable's active session history entry's navigation API state.

    // 3. If navigationAPIState is not null, then set destinationNavigationAPIState to navigationAPIState.

    // 4. Let continue be the result of firing a push/replace/reload navigate event at navigation with navigationType set to historyHandling, isSameDocument set to true, userInvolvement set to userInvolvement, sourceElement set to sourceElement, destinationURL set to url, and navigationAPIState set to destinationNavigationAPIState.

    // 5. If continue is false, then return.

    // 6. Let historyEntry be a new session history entry, with
    // URL                       url
    // document state            navigable's active session history entry's document state
    // À FAIRE navigation API state      destinationNavigationAPIState
    // À FAIRE scroll restoration mode   navigable's active session history entry's scroll restoration mode
    history_entry := loge(SessionHistoryEntry)
    history_entry.url = url
    history_entry.document_state = copie_référence(navigable.active_session_history_entry.document_state)

    // 7. Let entryToReplace be navigable's active session history entry if historyHandling is "replace", otherwise null.
    entry_to_replace: *SessionHistoryEntry
    si history_handling == NavigationHistoryBehavior.REPLACE {
        entry_to_replace = navigable.active_session_history_entry
    }

    // 8. Let history be navigable's active document's history object.

    // 9. Let scriptHistoryIndex be history's index.
    script_history_index: n32

    // 10. Let scriptHistoryLength be history's length.
    script_history_length: n32

    // 11. If historyHandling is "push", then:

        // 1. Set history's state to null.

        // 2. Increment scriptHistoryIndex.

        // 3. Set scriptHistoryLength to scriptHistoryIndex + 1.

    // 12. Set navigable's active document's URL to url.
    document := navigable.donne_active_document()
    document.url = copie_url(url)

    // 13. Set navigable's active session history entry to historyEntry.
    navigable.définis_active_session_history_entry(history_entry)

    // 14. Update document for history step application given navigable's active document, historyEntry, true, scriptHistoryIndex, scriptHistoryLength, and historyHandling.
    // @specbug historyHandling n'est pas dans les paramètres
    update_params: DocumentUpdateParams
    update_params.document = document
    update_params.entry = history_entry
    update_params.do_not_reactivate = vrai
    update_params.script_history_index = script_history_index
    update_params.script_history_length = script_history_length

    update_document_for_history_step_application(*update_params)

    // 15. Scroll to the fragment given navigable's active document.
    scroll_to_the_fragment(user_agent, document)

    // 16. Let traversable be navigable's traversable navigable.
    traversable := navigable.donne_traversable_navigable()

    // 17. Append the following session history synchronous navigation steps involving navigable to traversable:
    //      1. Finalize a same-document navigation given traversable, navigable, historyEntry, entryToReplace, historyHandling, and userInvolvement.
    //      2. Invoke WebDriver BiDi fragment navigated with navigable and a new WebDriver BiDi navigation status whose id is navigationId, url is url, and status is "complete".

    params: FinalizeSameDocumentNavigationParams
    params.user_agent = user_agent
    params.traversable = traversable
    params.target_navigable = navigable
    params.target_entry = history_entry
    params.entry_to_replace = entry_to_replace
    params.history_handling = history_handling
    params.user_involvement = user_involvement

    tâche := crée_algorithm_pour_fonction(*params, finalize_a_same_document_navigation)
    user_agent.lance_sur_file_parallèle(traversable, tâche)
}

FinalizeSameDocumentNavigationParams :: struct {
    user_agent: *UserAgent
    traversable: *TraversableNavigable
    target_navigable: *Navigable
    target_entry: *SessionHistoryEntry
    entry_to_replace: *SessionHistoryEntry
    history_handling: NavigationHistoryBehavior
    user_involvement: UserNavigationInvolvement
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#finalize-a-same-document-navigation */
finalize_a_same_document_navigation :: fonc (empl params: *FinalizeSameDocumentNavigationParams)
{
    // 1. Assert: this is running on traversable's session history traversal queue.
    assert(user_agent.est_exécuté_sur_file_parallèle(traversable))

    // 2. If targetNavigable's active session history entry is not targetEntry, then return.
    si target_navigable.active_session_history_entry != target_entry {
        retourne
    }

    // 3. Let targetStep be null.
    target_step: Optionnel(n32) 

    // 4. Let targetEntries be the result of getting session history entries for targetNavigable.
    target_entries := donne_session_history_entries(user_agent, target_navigable)

    // 5. If entryToReplace is null, then:
    si entry_to_replace == nul {
        // 1. Clear the forward session history of traversable.
        clear_the_forward_session_history(user_agent, traversable)

        // 2. Set targetStep to traversable's current session history step + 1.
        target_step = traversable.current_session_history_entry_step + 1

        // 3. Set targetEntry's step to targetStep.
        target_entry.step = target_step.Quelque

        // 4. Append targetEntry to targetEntries.
        tableau_ajoute(target_entries, target_entry)
    }
    // Otherwise:
    sinon {
        // 1. Replace entryToReplace with targetEntry in targetEntries.
        tableau_remplace(target_entries, entry_to_replace, target_entry)

        // 2. Set targetEntry's step to entryToReplace's step.
        target_entry.step = entry_to_replace.step

        // 3. Set targetStep to traversable's current session history step.
        target_step = traversable.current_session_history_entry_step
    }

    // 6. Apply the push/replace history step targetStep to traversable given historyHandling and userInvolvement.
    _ := apply_the_push_replace_history_step(user_agent, target_step, traversable, history_handling, user_involvement)

    si user_agent {
        document := target_entry.donne_document()
        user_agent.document_est_prêt(document)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 7.4.3 Reloading and traversing
 * https://html.spec.whatwg.org/multipage/browsing-the-web.html#reloading-and-traversing
 * \{ */

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#reload */
reload :: fonc (user_agent: *UserAgent, navigable: *Navigable, user_involvement := UserNavigationInvolvement.None)
{
    // If userInvolvement is not "browser UI", then:
    si user_involvement != UserNavigationInvolvement.BrowserUI {
        panique("non-implémenté")
        // 1. Let navigation be navigable's active window's navigation API.

        // 2. Let destinationNavigationAPIState be navigable's active session history entry's navigation API state.

        // 3. If navigationAPIState is not null, then set destinationNavigationAPIState to navigationAPIState.

        // 4. Let continue be the result of firing a push/replace/reload navigate event at navigation with navigationType set to "reload", isSameDocument set to false, userInvolvement set to userInvolvement, destinationURL set to navigable's active session history entry's URL, and navigationAPIState set to destinationNavigationAPIState.

        // 5. If continue is false, then return.
    }

    // 2. Set navigable's active session history entry's document state's reload pending to true.
    navigable.active_session_history_entry.document_state.reload_pending = vrai

    // 3. Let traversable be navigable's traversable navigable.
    traversable := navigable.donne_traversable_navigable()

    // 4. Append the following session history traversal steps to traversable:
    tâche := crée_tâche_pour_reload_history_step(user_agent, traversable)
    user_agent.lance_sur_file_parallèle(traversable, tâche)
}

crée_tâche_pour_reload_history_step :: fonc (user_agent: *UserAgent, traversable: *TraversableNavigable) -> *Algorithm
{
    Tâche :: struct {
        empl base: Algorithm

        user_agent: *UserAgent
        traversable: *TraversableNavigable
    }

    sur_run :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche

        // 1. Apply the reload history step to traversable.
        _ := apply_the_reload_history_step(tâche.user_agent, tâche.traversable)

        document := tâche.traversable.active_session_history_entry.donne_document()
        tâche.user_agent.document_est_prêt(document)
    }

    tâche := crée_algorithm(sur_run, Tâche)
    tâche.user_agent = user_agent
    tâche.traversable = traversable
    retourne tâche
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#traverse-the-history-by-a-delta */
traverse_the_history_by_a_delta :: fonc (user_agent: *UserAgent, traversable: *TraversableNavigable, delta: z32, source_document : *Document = nul)
{
    // 1. Let sourceSnapshotParams and initiatorToCheck be null.
    source_snapshot_params: *SourceSnapshotParams
    initiator_to_check: *Navigable

    // 2. Let userInvolvement be "browser UI".
    user_involvement := UserNavigationInvolvement.BrowserUI

    // 3. If sourceDocument is given, then:
    si source_document {
        // À FAIRE : 1. Set sourceSnapshotParams to the result of snapshotting source snapshot params given sourceDocument.

        // 2. Set initiatorToCheck to sourceDocument's node navigable.
        initiator_to_check = source_document.donne_node_navigable()

        // 3. Set userInvolvement to "none".
        user_involvement = UserNavigationInvolvement.None
    }

    // 4. Append the following session history traversal steps to traversable:
    tâche := crée_tâche_pour_traverse_history_step(user_agent, traversable, source_snapshot_params, initiator_to_check, user_involvement, delta)
    user_agent.lance_sur_file_parallèle(traversable, tâche)
}

crée_tâche_pour_traverse_history_step :: fonc (user_agent: *UserAgent,
                                               traversable: *TraversableNavigable,                           
                                               source_snapshot_params: *SourceSnapshotParams,
                                               initiator_to_check: *Navigable,
                                               user_involvement: UserNavigationInvolvement,
                                               delta: z32) -> *Algorithm
{
    Tâche :: struct {
        empl base: Algorithm

        user_agent: *UserAgent
        traversable: *TraversableNavigable
        source_snapshot_params: *SourceSnapshotParams
        initiator_to_check: *Navigable
        user_involvement: UserNavigationInvolvement
        delta: z32
    }

    sur_run :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche

        user_agent := tâche.user_agent
        traversable := tâche.traversable

        // 1. Let allSteps be the result of getting all used history steps for traversable.
        all_steps := get_all_used_history_steps(user_agent, traversable)

        // 2. Let currentStepIndex be the index of traversable's current session history step within allSteps.
        current_step_index : n32 = 0
        pour all_steps {
            si it == traversable.current_session_history_entry_step {
                current_step_index = index_it comme n32
                arrête
            }
        }

        // 3. Let targetStepIndex be currentStepIndex plus delta.
        target_step_index := (current_step_index comme z32 + tâche.delta)

        // 4. If allSteps[targetStepIndex] does not exist, then abort these steps.
        si target_step_index < 0 || target_step_index >= all_steps.taille {
            retourne
        }

        // 5. Apply the traverse history step allSteps[targetStepIndex] to traversable, given sourceSnapshotParams, initiatorToCheck, and userInvolvement.
        _ := apply_the_traverse_history_step(user_agent, all_steps[target_step_index], traversable, tâche.source_snapshot_params, tâche.initiator_to_check, tâche.user_involvement)

        document := tâche.traversable.active_session_history_entry.donne_document()
        tâche.user_agent.document_est_prêt(document)
    }

    tâche := crée_algorithm(sur_run, Tâche)
    tâche.user_agent = user_agent
    tâche.traversable = traversable
    tâche.source_snapshot_params = source_snapshot_params
    tâche.initiator_to_check = initiator_to_check
    tâche.user_involvement = user_involvement
    tâche.delta = delta
    retourne tâche
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 7.4.5
 * \{ */

HistoryEntryPopulationParams :: struct {
    user_agent: *UserAgent
    entry: *SessionHistoryEntry
    navigable: *Navigable
    nav_timing_type: NavigationTimingType
    source_snapshot_params: SourceSnapshotParams
    target_snapshot_params: TargetSnapshotParams
    navigation_id: Optionnel(NavigationID)
    navigation_params : *NavigationParams = nul
    csp_navigation_type := "other"
    allow_post := faux
    completion_steps : *Algorithm = nul
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#attempt-to-populate-the-history-entry's-document */
attempt_to_populate_the_history_entry_document :: fonc (params: *HistoryEntryPopulationParams)
{
    user_agent := params.user_agent
    entry := params.entry
    navigable := params.navigable
    nav_timing_type := params.nav_timing_type
    source_snapshot_params := params.source_snapshot_params
    target_snapshot_params := params.target_snapshot_params
    navigation_id := params.navigation_id
    navigation_params := params.navigation_params
    completion_steps := params.completion_steps
    csp_navigation_type := params.csp_navigation_type

    // 1. Assert: this is running in parallel.
    assert(user_agent.est_exécuté_en_parallèle())

    // 2. Assert: if navigationParams is non-null, then navigationParams's response is non-null.

    // 3. Let currentBrowsingContext be navigable's active browsing context.

    // 4. Let documentResource be entry's document state's resource.

    // 5. If navigationParams is null, then:
    si navigation_params == nul {
        // 1. If documentResource is a string, then set navigationParams to the result of creating navigation params from a srcdoc resource given entry, navigable, targetSnapshotParams, navigationId, and navTimingType.

        // 2. Otherwise, if all of the following are true:
        //     entry's URL's scheme is a fetch scheme; and
        //     documentResource is null, or allowPOST is true and documentResource's request body is not failure,

        // then set navigationParams to the result of creating navigation params by fetching given entry, navigable, sourceSnapshotParams, targetSnapshotParams, cspNavigationType, navigationId, and navTimingType.
        navigation_params = create_navigation_params_by_fetching(user_agent, entry, navigable, source_snapshot_params, target_snapshot_params, navigation_id, csp_navigation_type, nav_timing_type)

        // 3. Otherwise, if entry's URL's scheme is not a fetch scheme, then set navigationParams to a new non-fetch scheme navigation params, with
        //     id  navigationId
        //     navigable   navigable
        //     URL entry's URL
        //     target snapshot sandboxing flags    targetSnapshotParams's sandboxing flags
        //     source snapshot has transient activation    sourceSnapshotParams's has transient activation
        //     initiator origin    entry's document state's initiator origin
        //     navigation timing type  navTimingType
    }

    // 6. Queue a global task on the navigation and traversal task source, given navigable's active window, to run these steps:
    Tâche :: struct {
        empl base: Algorithm

        user_agent: *UserAgent
        completion_steps: *Algorithm
        entry: *SessionHistoryEntry
        navigation_params: *NavigationParams
        source_snapshot_params: SourceSnapshotParams
        navigable: *Navigable
        navigation_id: Optionnel(NavigationID)
    }

    sur_run :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche

        navigation_params := tâche.navigation_params
        diffère détruit_navigation_params(navigation_params)

        entry := tâche.entry
        completion_steps := tâche.completion_steps
        source_snapshot_params := tâche.source_snapshot_params
        user_agent := tâche.user_agent
        navigable := tâche.navigable
        navigation_id := tâche.navigation_id

        // 1. If navigable's ongoing navigation no longer equals navigationId, then run completionSteps and abort these steps.
        si navigable.ongoing_navigation != navigation_id {
            run(completion_steps)
            retourne
        }

        // 2. Let saveExtraDocumentState be true.
        save_extra_document_state := vrai

        // 3. If navigationParams is a non-fetch scheme navigation params, then:
        si navigation_params != nul && navigation_params.est_non_fetch_scheme() {
            panique("non-implémenté")

            // 1. Set entry's document state's document to the result of running attempt to create a non-fetch scheme document given navigationParams.

            // 2. Set saveExtraDocumentState to false.
        }
        // 4. Otherwise, if any of the following are true:
        //    navigationParams is null;
        //    À FAIRE : the result of should navigation response to navigation request of type in target be blocked by Content Security Policy? given navigationParams's request, navigationParams's response, navigationParams's policy container's CSP list, cspNavigationType, and navigable is "Blocked";
        //    À FAIRE : navigationParams's reserved environment is non-null and the result of checking a navigation response's adherence to its embedder policy given navigationParams's response, navigable, and navigationParams's policy container's embedder policy is false; or
        //    À FAIRE : the result of checking a navigation response's adherence to `X-Frame-Options` given navigationParams's response, navigable, navigationParams's policy container's CSP list, and navigationParams's origin is false,
        // then:
        sinon si navigation_params == nul {
            panique("non-implémenté")

            // 1. Set entry's document state's document to the result of creating a document for inline content that doesn't have a DOM, given navigable, null, and navTimingType. The inline content should indicate to the user the sort of error that occurred.

            // 2. Make document unsalvageable given entry's document state's document and "navigation-failure".

            // 3. Set saveExtraDocumentState to false.

            // 4. If navigationParams is not null, then:

                // 1. Run the environment discarding steps for navigationParams's reserved environment.

                // 2. Invoke WebDriver BiDi navigation failed with currentBrowsingContext and a new WebDriver BiDi navigation status whose id is navigationId, status is "canceled", and url is navigationParams's response's URL.
        }
        // 5. Otherwise, if navigationParams's response has a `Content-Disposition` header specifying the attachment disposition type, then:
        // À FAIRE : attachment disposition type
        sinon si navigation_params.response.possède_entête("Content-Disposition") {
            panique("non-implémenté")

            // 1. Let sourceAllowsDownloading be sourceSnapshotParams's allows downloading.

            // 2. Let targetAllowsDownloading be false if navigationParams's final sandboxing flag set has the sandboxed downloads browsing context flag set; otherwise true.

            // 3. Let uaAllowsDownloading be true.

            // 4. Optionally, the user agent may set uaAllowsDownloading to false, if it believes doing so would safeguard the user from a potentially hostile download.

            // 5. If sourceAllowsDownloading, targetAllowsDownloading, and uaAllowsDownloading are true, then:

                // 1. Handle navigationParams's response as a download.

                // 2. Invoke WebDriver BiDi download started with currentBrowsingContext and a new WebDriver BiDi navigation status whose id is navigationId, status is "complete", and url is navigationParams's response's URL.
        }
        // 6. Otherwise, if navigationParams's response's status is not 204 and is not 205
        sinon si navigation_params.response.status != 204 && navigation_params.response.status != 205 {
            // then set entry's document state's document to the result of loading a document given
            // navigationParams, sourceSnapshotParams, and entry's document state's initiator origin.
            entry.document_state.document = load_a_document(user_agent, navigation_params, source_snapshot_params, Origin())
        }

        // 7. If entry's document state's document is not null, then:
        si entry.document_state.document != nul {
            // 1. Set entry's document state's ever populated to true.
            entry.document_state.ever_populated = vrai

            // 2. If saveExtraDocumentState is true:
            si save_extra_document_state {
                // 1. Let document be entry's document state's document.
                document := entry.document_state.document

                // 2. Set entry's document state's origin to document's origin.
                entry.document_state.origin = document.origin

                // 3. If document's URL requires storing the policy container in history, then:
                si requires_storing_the_policy_container_in_history(document.url) {
                    // 1. Assert: navigationParams is a navigation params (i.e., neither null nor a non-fetch scheme navigation params).
                    assert(est_navigation_params(navigation_params))

                    // 2. Set entry's document state's history policy container to navigationParams's policy container.
                    entry.document_state.history_policy_container = navigation_params.policy_container
                }
            }
            
            // 3. If entry's document state's request referrer is "client", and navigationParams is a navigation params (i.e., neither null nor a non-fetch scheme navigation params), then:
            si entry.document_state.request_referrer == "client" && navigation_params.est_navigation_params() {
                // 1. Assert: navigationParams's request is not null.
                assert(navigation_params.request != nul)

                // 2. Set entry's document state's request referrer to navigationParams's request's referrer.
                entry.document_state.request_referrer = navigation_params.request.referrer
            }
        }

        // 8. Run completionSteps.
        run(completion_steps)
    }

    tâche := crée_algorithm(sur_run, Tâche)
    tâche.navigable = navigable
    tâche.navigation_id = navigation_id
    tâche.user_agent = user_agent
    tâche.completion_steps = completion_steps
    tâche.entry = entry
    tâche.navigation_params = navigation_params
    tâche.source_snapshot_params = source_snapshot_params

    user_agent.queue_a_globask_task(SourceDeTâche.NavigationEtTraversée, navigable.donne_active_window(), tâche)
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#create-navigation-params-by-fetching */
create_navigation_params_by_fetching :: fonc (user_agent: *UserAgent,
                                              entry: *SessionHistoryEntry,
                                              navigable: *Navigable,
                                              source_snapshot_params: &SourceSnapshotParams,
                                              target_snapshot_params: &TargetSnapshotParams @inutilisée,
                                              navigation_id: Optionnel(NavigationID),
                                              csp_navigation_type: chaine,
                                              nav_timing_type: NavigationTimingType) -> *NavigationParams
{
    // 1. Assert: this is running in parallel.
    assert(user_agent.est_exécuté_en_parallèle())

    // 2. Let documentResource be entry's document state's resource.

    // 3. Let request be a new request, with
    request := loge(Request)
    //     url                            entry's URL
    request.définis_url(copie_url(entry.url))
    //     client                         sourceSnapshotParams's fetch client
    request.client = source_snapshot_params.fetch_client
    //     destination                    "document"
    request.destination = "document"
    //     credentials mode               "include"
    request.credentials_mode = "include"
    //     use-URL-credentials flag       set
    request.use_url_credentials = vrai
    //     redirect mode                  "manual"
    request.redirect_mode = "manual"
    // À FAIRE replaces_client_id
    //     replaces client id             navigable's active document's relevant settings object's id
    //     mode                           "navigate"
    request.mode = "navigate"
    //     referrer                       entry's document state's request referrer
    request.referrer = entry.document_state.request_referrer
    //     referrer policy                entry's document state's request referrer policy
    request.referrer_policy = entry.document_state.request_referrer_policy
    //     policy container               sourceSnapshotParams's source policy container
    request.policy_container = source_snapshot_params.source_policy_container
    //     traversable for user prompts   navigable's top-level traversable
    request.traversable_for_user_prompts = navigable.donne_top_level_traversable()

    // 4. If navigable is a top-level traversable, then set request's top-level navigation initiator origin to entry's document state's initiator origin.
    si navigable.est_top_level_traversable() {
        request.top_level_initiator_origin = entry.document_state.initiator_origin
    }

    // 5. If request's client is null:
    si request.client == nul {
        // 1. Set request's origin to a new opaque origin.
        request.origin = crée_nouvelle_origin_opaque()

        // 2. Set request's service-workers mode to "all".
        request.service_workers_mode = "all"

        // 3. Set request's referrer to "no-referrer".
        request.referrer = "no-referrer"
    }

    // 6. If documentResource is a POST resource, then:

        // 1. Set request's method to `POST`.

        // 2. Set request's body to documentResource's request body.

        // 3. Set `Content-Type` to documentResource's request content-type in request's header list.

    // 7. If entry's document state's reload pending is true, then set request's reload-navigation flag.
    si entry.document_state.reload_pending {
        request.reload_navigation = vrai
    }
    // 8. Otherwise, if entry's document state's ever populated is true, then set request's history-navigation flag.
    sinon si entry.document_state.ever_populated {
        request.history_navigation = vrai
    }

    // 9. If sourceSnapshotParams's has transient activation is true, then set request's user-activation to true.
    si source_snapshot_params.has_transient_activation {
        request.user_activation = vrai
    }

    // 10. If navigable's container is non-null:
    navigable_container := navigable.donne_container()
    si navigable_container {
        // 1. If the navigable's container has a browsing context scope origin, then set request's origin to that browsing context scope origin.
        imprimeln("À FAIRE : [% : navigable_container]", #nom_de_cette_fonction)

        // 2. Set request's destination to navigable's container's local name.

        // 3. If sourceSnapshotParams's fetch client is navigable's container document's relevant settings object, then set request's initiator type to navigable's container's local name.
    }

    // 11. Let response be null.
    response: *Response

    // 12. Let responseOrigin be null.
    response_origin: Optionnel(Origin)

    // 13. Let fetchController be null.
    fetch_controller: *FetchController

    // 14. Let coopEnforcementResult be a new cross-origin opener policy enforcement result, with
    coop_enforcement_result: CrossOriginOpenerPolicyEnforcementResult
    //     url navigable's active document's URL
    coop_enforcement_result.url = navigable.donne_active_document().url
    //     origin  navigable's active document's origin
    coop_enforcement_result.origin = navigable.donne_active_document().origin
    //     cross-origin opener policy  navigable's active document's cross-origin opener policy
    coop_enforcement_result.cross_origin_opener_policy = navigable.donne_active_document().cross_origin_opener_policy
    //     À FAIRE : current context is navigation source    true if navigable's active document's origin is same origin with entry's document state's initiator origin otherwise false

    // 15. Let finalSandboxFlags be an empty sandboxing flag set.
    final_sandboxing_flags: SandboxingFlags

    // 16. Let responsePolicyContainer be null.
    response_policy_container: *PolicyContainer

    // 17. Let responseCOOP be a new cross-origin opener policy.
    response_coop: CrossOriginOpenerPolicy

    // 18. Let locationURL be null.
    location_url: *URL

    // 19. Let currentURL be request's current URL.
    current_url := request.donne_url_courant()

    // 20. Let commitEarlyHints be null.
    commit_early_hints: *CommitEarlyHints

    // 21. While true:
    boucle {
        // 1. If request's reserved client is not null and currentURL's origin is not the same as request's reserved client's creation URL's origin, then:
        si request.reserved_client != nul && !sont_même_origine(current_url.donne_origin(), request.reserved_client.creation_url.donne_origin()) {
            imprimeln("À FAIRE : [% : request.reserved_client != nul]", #nom_de_cette_fonction)
            // 1. Run the environment discarding steps for request's reserved client.

            // 2. Set request's reserved client to null.
            request.reserved_client = nul

            // 3. Set commitEarlyHints to null.
            commit_early_hints = nul
        }
            
        // 2. If request's reserved client is null, then:
        si request.reserved_client == nul {
            // 1. Let topLevelCreationURL be currentURL.
            top_level_creation_url := current_url

            // 2. Let topLevelOrigin be null.
            top_level_origin: Optionnel(Origin)

            // 3. If navigable is not a top-level traversable, then:
            saufsi navigable.est_top_level_traversable() {
                // 1. Let parentEnvironment be navigable's parent's active document's relevant settings object.
                parent_environment := navigable.parent.donne_active_document().donne_relevant_settings_object()

                // 2. Set topLevelCreationURL to parentEnvironment's top-level creation URL.
                top_level_creation_url = parent_environment.top_level_creation_url

                // 3. Set topLevelOrigin to parentEnvironment's top-level origin.
                top_level_origin = parent_environment.top_level_origin
            }

            // 4. Set request's reserved client to a new environment whose...
            reserved_environment := loge(Environment)
            // ...id is a unique opaque string,
            // À FAIRE : opaque string
            reserved_environment.id = imprime_chaine("%", reserved_environment)
            // ...target browsing context is navigable's active browsing context,
            reserved_environment.target_browsing_context = navigable.donne_active_browsing_context()
            // ...creation URL is currentURL,
            reserved_environment.creation_url = copie_url(current_url)
            // ...top-level creation URL is topLevelCreationURL,
            reserved_environment.top_level_creation_url = copie_url(top_level_creation_url)
            // ...and top-level origin is topLevelOrigin.
            reserved_environment.top_level_origin = top_level_origin

            request.reserved_client = reserved_environment
        }

        // 3. If the result of should navigation request of type be blocked by Content Security Policy? given request and cspNavigationType is "Blocked",
        si should_navigation_request_be_blocked(request, csp_navigation_type) == "Blocked" {
            // then set response to a network error and break. [CSP]
            response = network_error(request)
            arrête
        }

        // 4. Set response to null.
        response = nul

        // 5. If fetchController is null, then set fetchController to the result of fetching request, with processEarlyHintsResponse set to processEarlyHintsResponse as defined below, processResponse set to processResponse as defined below, and useParallelQueue set to true.
        si fetch_controller == nul {
            // À FAIRE :    Let processEarlyHintsResponse be the following algorithm given a response earlyResponse:
            //     1. If commitEarlyHints is null, then set commitEarlyHints to the result of processing early hint headers given earlyResponse and request's reserved client.

            // Let processResponse be the following algorithm given a response fetchedResponse:
            //     1. Set response to fetchedResponse.
            RappelProcessResponse :: struct {
                empl base: BaseProcessResponse

                réponse: **Response
            }

            sur_rappel_process_response :: fonc (base: *BaseProcessResponse, réponse: *Response)
            {
                rappel := base comme *RappelProcessResponse
                mémoire(rappel.réponse) = réponse
            }

            sur_destruction_process_response :: fonc (base: *BaseProcessResponse)
            {
                rappel := base comme *RappelProcessResponse
                déloge(rappel)
            }

            process_response := loge(RappelProcessResponse)
            process_response.réponse = *response
            process_response.sur_rappel = sur_rappel_process_response
            process_response.sur_destruction = sur_destruction_process_response

            fetch_controller = fetch(user_agent, request, process_response = process_response)
        }
        // 6. Otherwise, process the next manual redirect for fetchController.
        sinon {
            panique("redirection non-implémentée")
        }

        // 7. Wait until either response is non-null, or navigable's ongoing navigation changes to no longer equal navigationId.
        //     If the latter condition occurs, then abort fetchController, and return.
        //     Otherwise, proceed onward.
        tantque response == nul && navigable.ongoing_navigation == navigation_id {
            continue
        }

        // 8. If request's body is null, then set entry's document state's resource to null.

        // 9. Set responsePolicyContainer to the result of creating a policy container from a fetch response given response and request's reserved client.

        // À FAIRE : 10. Set finalSandboxFlags to the union of targetSnapshotParams's sandboxing flags and responsePolicyContainer's CSP list's CSP-derived sandboxing flags.
        final_sandbox_flags: SandboxingFlags

        // 11. Set responseOrigin to the result of determining the origin given response's URL, finalSandboxFlags, and entry's document state's initiator origin.
        response_origin = détermine_origin(response.donne_url(), final_sandbox_flags, entry.document_state.initiator_origin)

        // 12. If navigable is a top-level traversable, then:
        si navigable.est_top_level_traversable() {
            imprime("À FAIRE : [navigation/COOP]\n")
            // 1. Set responseCOOP to the result of obtaining a cross-origin opener policy given response and request's reserved client.

            // 2. Set coopEnforcementResult to the result of enforcing the response's cross-origin opener policy given navigable's active browsing context, response's URL, responseOrigin, responseCOOP, coopEnforcementResult and request's referrer.

            // 3. If finalSandboxFlags is not empty and responseCOOP's value is not "unsafe-none", then set response to an appropriate network error and break.
        }

        // 13. If response is not a network error, navigable is a child navigable, and the result of performing a cross-origin resource policy check with navigable's container document's origin, navigable's container document's relevant settings object, request's destination, response, and true is blocked, then set response to a network error and break.

        // 14. Set locationURL to response's location URL given currentURL's fragment.
        location_url = donne_location_url(response, user_agent, current_url.fragment)

        // 15. If locationURL is failure or null, then break.
        si location_url == nul {
            arrête
        }

        // 16. Assert: locationURL is a URL.

        // À FAIRE : 17. Set entry's classic history API state to StructuredSerializeForStorage(null).

        // 18. Let oldDocState be entry's document state.
        old_doc_state := entry.document_state

        // 19. Set entry's document state to a new document state, with
        new_document_state := loge(DocumentState)
        //     history policy container    a clone of the oldDocState's history policy container if it is non-null; null otherwise
        new_document_state.history_policy_container = clone(old_doc_state.history_policy_container)
        //     request referrer    oldDocState's request referrer
        new_document_state.request_referrer = old_doc_state.request_referrer
        //     request referrer policy oldDocState's request referrer policy
        new_document_state.request_referrer_policy = old_doc_state.request_referrer_policy
        //     initiator origin    oldDocState's initiator origin
        new_document_state.initiator_origin = old_doc_state.initiator_origin
        //     origin  oldDocState's origin
        new_document_state.origin = old_doc_state.origin
        //     about base URL  oldDocState's about base URL
        si old_doc_state.about_base_url {
            new_document_state.about_base_url = copie_url(old_doc_state.about_base_url)
        }
        //  À FAIRE    resource    oldDocState's resource
        //     ever populated  oldDocState's ever populated
        new_document_state.ever_populated = old_doc_state.ever_populated
        //     navigable target name   oldDocState's navigable target name
        new_document_state.navigable_target_name = old_doc_state.navigable_target_name

        entry.document_state = new_document_state

        // 20. If locationURL's scheme is not an HTTP(S) scheme, then:
        saufsi is_http_scheme(location_url.scheme) {
            // 1. Set entry's document state's resource to null.

            // 2. Break.
            arrête
        }

        // 21. Set currentURL to locationURL.
        current_url = location_url

        // 22. Set entry's URL to currentURL.
        entry.url = current_url
    }

    // 22. If locationURL is a URL whose scheme is not a fetch scheme, then return a new non-fetch scheme navigation params, with
    //     id  navigationId
    //     navigable   navigable
    //     URL locationURL
    //     target snapshot sandboxing flags    targetSnapshotParams's sandboxing flags
    //     source snapshot has transient activation    sourceSnapshotParams's has transient activation
    //     initiator origin    responseOrigin
    //     navigation timing type  navTimingType

    // 23. If any of the following are true:
    //     response is a network error;
    //     locationURL is failure; or
    //     locationURL is a URL whose scheme is a fetch scheme,
    //     then return null.

    // 24. Assert: locationURL is null and response is not a network error.
    assert(location_url == nul && !est_network_error(response))

    // 25. Let resultPolicyContainer be the result of determining navigation params policy container
    //     given response's URL, entry's document state's history policy container, sourceSnapshotParams's source policy container, null, and responsePolicyContainer.
    result_policy_container := determine_navigation_params_policy_container(response.donne_url(), entry.document_state.history_policy_container, source_snapshot_params.source_policy_container, nul, response_policy_container)

    // 26. If navigable's container is an iframe, and response's timing allow passed flag is set, then set container's pending resource-timing start time to null.

    // 27. Return a new navigation params, with
    résultat := loge(NavigationParams)
    //     id  navigationId
    résultat.id = navigation_id
    //     navigable   navigable
    résultat.navigable = navigable
    //     request request
    résultat.request = request
    //     response    response
    résultat.response = response
    //     fetch controller    fetchController
    résultat.fetch_controller = fetch_controller
    //     commit early hints  commitEarlyHints
    résultat.commit_early_hints = commit_early_hints
    //     cross-origin opener policy  responseCOOP
    résultat.cross_origin_opener_policy = response_coop
    //     reserved environment    request's reserved client
    résultat.reserved_environment = request.reserved_client
    //     origin  responseOrigin
    résultat.origin = response_origin.Quelque
    //     policy container    resultPolicyContainer
    résultat.policy_container = result_policy_container
    //     final sandboxing flag set   finalSandboxFlags
    résultat.final_sandboxing_flag = final_sandboxing_flags
    //     COOP enforcement result coopEnforcementResult
    résultat.COOP_enforcement_result = coop_enforcement_result
    //     navigation timing type  navTimingType
    résultat.navigation_timing_type = nav_timing_type
    //     about base URL  entry's document state's about base URL
    résultat.about_base_url = copie_url(entry.document_state.about_base_url)
    retourne résultat
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#loading-a-document */
load_a_document :: fonc (user_agent: *UserAgent, navigation_params: *NavigationParams, source_snapshot_params: SourceSnapshotParams @inutilisée, initiator_origin: Origin @inutilisée) -> *Document
{
    // 1. Let type be the computed type of navigationParams's response.
    mime_type := navigation_params.response.donne_mime_type()

    // 2. If the user agent has been configured to process resources of the given
    //    type using some mechanism other than rendering the content in a navigable,
    //    then skip this step.
    //    Otherwise, if the type is one of the following types:

    // an HTML MIME type
    si mime_type == MIME_text_html {
        // Return the result of loading an HTML document, given navigationParams.
        retourne load_an_html_document(user_agent, navigation_params)
    }

    // an XML MIME type that is not an explicitly supported XML MIME type
    // Return the result of loading an XML document given navigationParams and type.

    // a JavaScript MIME type
    // a JSON MIME type that is not an explicitly supported JSON MIME type
    // "text/css"
    // "text/plain"
    // "text/vtt"
    si mime_type == MIME_text_css || mime_type == MIME_text_plain {
        // Return the result of loading a text document given navigationParams and type.
        retourne load_a_text_document(user_agent, navigation_params, mime_type)
    }

    // "multipart/x-mixed-replace"
    // Return the result of loading a multipart/x-mixed-replace document, given navigationParams, sourceSnapshotParams, and initiatorOrigin.

    // A supported image, video, or audio type
    // Return the result of loading a media document given navigationParams and type.

    // "application/pdf"
    // "text/pdf"
    // If the user agent's PDF viewer supported is true, return the result of creating
    // a document for inline content that doesn't have a DOM given navigationParams's navigable.
    
    // Otherwise, proceed onward.
    retourne nul
}

/* https://html.spec.whatwg.org/multipage/browsers.html#obtain-browsing-context-navigation */
obtain_a_browsing_context_for_a_navigation_response :: fonc (user_agent: *UserAgent, browsing_context: *BrowsingContext, sandbox_flags: SandboxingFlags @inutilisée, navigation_coop: CrossOriginOpenerPolicy @inutilisée, coop_enforcement_result: CrossOriginOpenerPolicyEnforcementResult) -> *BrowsingContext
{
    // 1. If browsingContext is not a top-level browsing context, then return browsingContext.
    saufsi browsing_context.est_top_level_browsing_context() {
        retourne browsing_context
    }

    // 2. If coopEnforcementResult's needs a browsing context group switch is false, then:
    si coop_enforcement_result.needs_a_browsing_context_group_switch == faux {
        // À FAIRE : 1. If coopEnforcementResult's would need a browsing context group switch due to report-only is true,
        // set browsing context's virtual browsing context group ID to a new unique identifier.

        // 2. Return browsingContext.
        retourne browsing_context
    }

    // 3. Let newBrowsingContext be the first return value of creating a new top-level browsing context and document.
    new_browsing_context, _ := crée_un_nouveau_top_level_browsing_context_et_document(user_agent)

    // À FAIRE : 4. If navigationCOOP's value is "same-origin-plus-COEP", then set newBrowsingContext's group's cross-origin isolation mode to either "logical" or "concrete". The choice of which is implementation-defined.

    // À FAIRE : 5. If sandboxFlags is not empty, then:

        // 1. Assert: navigationCOOP's value is "unsafe-none".

        // 2. Assert: newBrowsingContext's popup sandboxing flag set is empty.

        // 3. Set newBrowsingContext's popup sandboxing flag set to a clone of sandboxFlags.

    // 6. Return newBrowsingContext.
    retourne new_browsing_context
}

/** } */

/* ------------------------------------------------------------------------- */
/** \nom 7.4.6.1 Updating the traversable.
 * https://html.spec.whatwg.org/multipage/browsing-the-web.html#updating-the-traversable
 * \{ */

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#changing-navigable-continuation-state */
ChangingNavigableContinuationState :: struct {
    displayed_document: *Document
    target_entry: *SessionHistoryEntry
    populated_target_entry: *SessionHistoryEntry
    navigable: *Navigable
    update_only: bool
    populated_cloned_target_entry: bool
}

/* They return "initiator-disallowed", "canceled-by-beforeunload", "canceled-by-navigate", or "applied". */
HistoryApplication :: énum {
    Applied
    InitiatorDisallowed
    CanceledByBeforeunload
    CanceledByNavigate
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#apply-the-push/replace-history-step */
apply_the_push_replace_history_step :: fonc (user_agent: *UserAgent, step: n32, traversable: *TraversableNavigable, history_handling: NavigationHistoryBehavior, user_involvement: UserNavigationInvolvement) -> HistoryApplication
{
    assert(history_handling != NavigationHistoryBehavior.AUTO)

    navigation_type: NavigationType
    si history_handling == NavigationHistoryBehavior.PUSH {
        navigation_type = NavigationType.push
    }
    sinon {
        assert(history_handling == NavigationHistoryBehavior.REPLACE)
        navigation_type = NavigationType.replace
    }

    // 1. Return the result of applying the history step step to traversable given false, null, null, userInvolvement, and historyHandling.
    retourne apply_the_history_step(user_agent, step, traversable, faux, nul, nul, *user_involvement, *navigation_type)
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#apply-the-reload-history-step */
apply_the_reload_history_step :: fonc (user_agent: *UserAgent, traversable: *TraversableNavigable) -> HistoryApplication
{
    // 1. Let step be traversable's current session history step.
    step := traversable.current_session_history_entry_step

    // 2. Return the result of applying the history step step to traversable given true, null, null, null, and "reload".
    navigation_type := NavigationType.reload
    retourne apply_the_history_step(user_agent, step, traversable, vrai, nul, nul, nul, *navigation_type)
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#apply-the-traverse-history-step */
apply_the_traverse_history_step :: fonc (user_agent: *UserAgent, step: n32, traversable: *TraversableNavigable, source_snapshot_params: *SourceSnapshotParams, initiator_to_check: *Navigable, user_involvement: UserNavigationInvolvement) -> HistoryApplication
{
    // 1. Return the result of applying the history step step to traversable given true, sourceSnapshotParams, initiatorToCheck, userInvolvement, and "traverse".
    navigation_type := NavigationType.traverse
    retourne apply_the_history_step(user_agent, step, traversable, vrai, source_snapshot_params, initiator_to_check, *user_involvement, *navigation_type)
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#apply-the-history-step */
apply_the_history_step :: fonc (user_agent: *UserAgent,
                                step: n32,
                                traversable: *TraversableNavigable,
                                check_for_canceletion: bool,
                                source_snapshot_params: *SourceSnapshotParams,
                                initiator_to_check: *Navigable,
                                user_involvement_for_navigate_events: *UserNavigationInvolvement,
                                navigation_type: *NavigationType) -> HistoryApplication
{
    // 1. Assert: This is running within traversable's session history traversal queue.
    assert(user_agent.est_exécuté_sur_file_parallèle(traversable))

    // 2. Let targetStep be the result of getting the used step given traversable and step.
    target_step := get_the_used_step(user_agent, traversable, step)

    // 3. If initiatorToCheck is not null, then:
    si initiator_to_check {
        // 1. Assert: sourceSnapshotParams is not null.
        assert(source_snapshot_params != nul)

        // 2. For each navigable of get all navigables whose current session history entry will change or reload:
        //    if initiatorToCheck is not allowed by sandboxing to navigate navigable given sourceSnapshotParams,
        //    then return "initiator-disallowed".
        panique("initiator_to_check != nul non-implémenté")
    }

    // 4. Let navigablesCrossingDocuments be the result of getting all navigables that might experience a
    //    cross-document traversal given traversable and targetStep.
    navigables_crossing_documents := get_all_navigables_that_might_experience_a_cross_document_traversal(user_agent, traversable, target_step)
    diffère déloge(navigables_crossing_documents)

    // 5. If checkForCancelation is true, and the result of checking if unloading is canceled given navigablesCrossingDocuments, traversable, targetStep, and userInvolvementForNavigateEvents is not "continue", then return that result.
    si check_for_canceletion {
        result := check_if_unloading_is_canceled(navigables_crossing_documents, traversable, user_involvement_for_navigate_events)
        si result == "canceled-by-beforeunload" {
            retourne HistoryApplication.CanceledByBeforeunload
        }
        si result == "canceled-by-navigate" {
            retourne HistoryApplication.CanceledByNavigate
        }
    }

    // 6. Let changingNavigables be the result of get all navigables whose current session history entry will change or reload given traversable and targetStep.
    changing_navigables := get_all_navigables_whose_current_session_history_entry_will_change_or_reload(user_agent, traversable, target_step)
    diffère déloge(changing_navigables)

    // 7. Let nonchangingNavigablesThatStillNeedUpdates be the result of getting all navigables that only need history object length/index update given traversable and targetStep.
    nonchanging_navigables_that_still_need_updates := get_all_navigables_that_only_need_history_object_length_index_update(user_agent, traversable, target_step)
    diffère déloge(nonchanging_navigables_that_still_need_updates)

    // 8. For each navigable of changingNavigables:
    pour navigable dans changing_navigables {
        // 1. Let targetEntry be the result of getting the target history entry given navigable and targetStep.
        target_entry := get_the_target_history_entry(user_agent, navigable, target_step)

        // 2. Set navigable's current session history entry to targetEntry.
        navigable.current_session_history_entry = target_entry

        // 3. Set the ongoing navigation for navigable to "traversal".
        navigable.définis_ongoing_navigation("traversal")
    }

    // 9. Let totalChangeJobs be the size of changingNavigables.
    total_change_jobs := changing_navigables.taille

    // 10. Let completedChangeJobs be 0.
    completed_change_jobs := 0

    // 11. Let changingNavigableContinuations be an empty queue of changing navigable continuation states.
    changing_navigable_continuations: [..]ChangingNavigableContinuationState
    diffère déloge(changing_navigable_continuations)

    // 12. For each navigable of changingNavigables, queue a global task on the navigation and traversal task source of navigable's active window to run the steps:
    pour navigable dans changing_navigables {
        tâche := crée_tâche_pour_changing_navigable_continuations_steps(user_agent, navigable, traversable, navigation_type, source_snapshot_params, *changing_navigable_continuations)
        user_agent.queue_a_globask_task(SourceDeTâche.NavigationEtTraversée, navigable.donne_active_window(), tâche)
    }

    // 13. Let navigablesThatMustWaitBeforeHandlingSyncNavigation be an empty set.
    navigables_that_must_wait_before_handling_sync_navigation: [..]*Navigable
    diffère déloge(navigables_that_must_wait_before_handling_sync_navigation)

    // 14. While completedChangeJobs does not equal totalChangeJobs:
    décalage_défilement := 0
    tantque completed_change_jobs != total_change_jobs {
        // 1. If traversable's running nested apply history step is false, then:
        si traversable.running_nested_apply_history_step == faux {
            // À FAIRE : 1. While traversable's session history traversal queue's algorithm set contains one or more synchronous navigation steps with a target navigable not contained in navigablesThatMustWaitBeforeHandlingSyncNavigation:

                // 1. Let steps be the first item in traversable's session history traversal queue's algorithm set that is synchronous navigation steps with a target navigable not contained in navigablesThatMustWaitBeforeHandlingSyncNavigation.

                // 2. Remove steps from traversable's session history traversal queue's algorithm set.

                // 3. Set traversable's running nested apply history step to true.

                // 4. Run steps.

                // 5. Set traversable's running nested apply history step to false.
        }

        // 2. Let changingNavigableContinuation be the result of dequeuing from changingNavigableContinuations.
        // 3. If changingNavigableContinuation is nothing, then continue.
        si décalage_défilement >= changing_navigable_continuations.taille {
            continue
        }

        changing_navigable_continuation := changing_navigable_continuations[décalage_défilement]
        décalage_défilement += 1

        // 4. Let displayedDocument be changingNavigableContinuation's displayed document.
        displayed_document := changing_navigable_continuation.displayed_document

        // 5. Let targetEntry be changingNavigableContinuation's target entry.
        populated_target_entry := changing_navigable_continuation.populated_target_entry

        // 6. Let navigable be changingNavigableContinuation's navigable.
        navigable := changing_navigable_continuation.navigable

        // À FAIRE 7. Let (scriptHistoryLength, scriptHistoryIndex) be the result of getting the history object length and index given traversable and targetStep.
        script_history_length : n32 = 0
        script_history_index : n32 = 0

        // 8. Append navigable to navigablesThatMustWaitBeforeHandlingSyncNavigation.
        tableau_ajoute(*navigables_that_must_wait_before_handling_sync_navigation, navigable)

        // À FAIRE : 9. Let entriesForNavigationAPI be the result of getting session history entries for the navigation API given navigable and targetStep.
        entries_for_navigation_api: [..]*SessionHistoryEntry

        after_potential_unloads_params: AfterPotentialUnloadsParams
        after_potential_unloads_params.user_agent = user_agent
        after_potential_unloads_params.target_entry = changing_navigable_continuation.target_entry
        after_potential_unloads_params.populated_target_entry = populated_target_entry
        after_potential_unloads_params.populated_cloned_target_entry = changing_navigable_continuation.populated_cloned_target_entry
        after_potential_unloads_params.displayed_document = displayed_document
        after_potential_unloads_params.navigable = navigable
        after_potential_unloads_params.changing_navigable_continuation = changing_navigable_continuation
        after_potential_unloads_params.completed_change_jobs = *completed_change_jobs
        after_potential_unloads_params.script_history_length = script_history_length
        after_potential_unloads_params.script_history_index = script_history_index
        si navigation_type {
            after_potential_unloads_params.navigation_type = mémoire(navigation_type)
        }
        after_potential_unloads_params.entries_for_navigation_api = entries_for_navigation_api
        after_potential_unloads_params.displayed_entry = navigable.active_session_history_entry

        tâche_after_potential_unloads := crée_algorithm_pour_fonction(*after_potential_unloads_params, after_potential_unloads)

        // 10. If changingNavigableContinuation's update-only is true, or targetEntry's document is displayedDocument, then:
        si changing_navigable_continuation.update_only || populated_target_entry.donne_document() == displayed_document {
            // 1. Set the ongoing navigation for navigable to null.
            init_de(OngoingNavigationType)(*navigable.ongoing_navigation)

            // 2. Queue a global task on the navigation and traversal task source given navigable's active window to perform afterPotentialUnloads.
            user_agent.queue_a_globask_task(SourceDeTâche.NavigationEtTraversée, navigable.donne_active_window(), tâche_after_potential_unloads)
        }
        // 11. Otherwise:
        sinon {
            // 1. Assert: navigationType is not null.
            assert(navigation_type != nul)

            // 2. Deactivate displayedDocument, given userNavigationInvolvement, targetEntry, navigationType, and afterPotentialUnloads.
            deactivate_document_for_a_cross_document_navigation(user_agent, displayed_document, user_involvement_for_navigate_events, populated_target_entry, mémoire(navigation_type), tâche_after_potential_unloads)
        }

        // 12. In both cases, let afterPotentialUnloads be the following steps:
        // NOTE : définis dans #after_potential_unloads
    }

    // 15. Let totalNonchangingJobs be the size of nonchangingNavigablesThatStillNeedUpdates.
    total_non_chaging_jobs := nonchanging_navigables_that_still_need_updates.taille

    // 16. Let completedNonchangingJobs be 0.
    completed_non_changing_jobs := 0

    // À FAIRE : 17. Let (scriptHistoryLength, scriptHistoryIndex) be the result of getting the history object length and index given traversable and targetStep.

    // 18. For each navigable of nonchangingNavigablesThatStillNeedUpdates, queue a global task on the navigation and traversal task source given navigable's active window to run the steps:
    // À FAIRE : crée une tâche
    pour /* navigable dans */ nonchanging_navigables_that_still_need_updates {
        // 1. Let document be navigable's active document.

        // 2. Set document's history object's index to scriptHistoryIndex.

        // 3. Set document's history object's length to scriptHistoryLength.

        // 4. Increment completedNonchangingJobs.
        completed_non_changing_jobs += 1
    }

    // 19. Wait for completedNonchangingJobs to equal totalNonchangingJobs.
    tantque completed_non_changing_jobs != total_non_chaging_jobs {
        continue
    }

    // 20. Set traversable's current session history step to targetStep.
    traversable.current_session_history_entry_step = target_step

    // 21. Return "applied".
    retourne HistoryApplication.Applied
}

AfterPotentialUnloadsParams :: struct {
    user_agent: *UserAgent
    target_entry: *SessionHistoryEntry
    populated_target_entry: *SessionHistoryEntry
    populated_cloned_target_entry: bool
    displayed_document: *Document
    navigable: *Navigable
    changing_navigable_continuation: ChangingNavigableContinuationState
    completed_change_jobs: *z32
    script_history_length: n32
    script_history_index: n32
    navigation_type: Optionnel(NavigationType)
    entries_for_navigation_api: []*SessionHistoryEntry
    displayed_entry: *SessionHistoryEntry
}

after_potential_unloads :: fonc (params: *AfterPotentialUnloadsParams)
{
    target_entry := params.target_entry

    si params.populated_cloned_target_entry {
        // @fuite-de-mémoire
        target_entry.document_state = params.populated_target_entry.document_state
        target_entry.url = params.populated_target_entry.url
        // À FAIRE : autres données
    }

    // 1. If changingNavigableContinuation's update-only is false, then activate history entry targetEntry for navigable.
    saufsi params.changing_navigable_continuation.update_only {
        activate_histroy_entry(params.target_entry, params.navigable)
    }

    // 2. Let updateDocument be an algorithm step which performs update document for history step application given
    //    targetEntry's document, targetEntry, changingNavigableContinuation's update-only, scriptHistoryLength, scriptHistoryIndex, navigationType, entriesForNavigationAPI, and displayedEntry.
    document_update_params: DocumentUpdateParams
    document_update_params.document = target_entry.donne_document()
    document_update_params.entry = target_entry
    document_update_params.do_not_reactivate = params.changing_navigable_continuation.update_only
    document_update_params.script_history_length = params.script_history_length
    document_update_params.script_history_index = params.script_history_index
    document_update_params.navigation_type = params.navigation_type
    document_update_params.entries_for_navigation_api = params.entries_for_navigation_api
    document_update_params.previous_entry_for_activation = params.displayed_entry

    // 3. If targetEntry's document is equal to displayedDocument, then perform updateDocument.
    si target_entry.donne_document() == params.displayed_document {
        update_document_for_history_step_application(*document_update_params)
    }
    // 4. Otherwise, queue a global task on the navigation and traversal task source given targetEntry's document's relevant global object to perform updateDocument.
    sinon {
        // À FAIRE : relevant global object
        tâche := crée_algorithm_pour_fonction(*document_update_params, update_document_for_history_step_application)
        params.user_agent.queue_a_globask_task(SourceDeTâche.NavigationEtTraversée, target_entry.donne_document().donne_relevant_global_object(),  tâche)
    }

    // 5. Increment completedChangeJobs.
    mémoire(params.completed_change_jobs) += 1
}

crée_tâche_pour_changing_navigable_continuations_steps :: fonc (user_agent: *UserAgent,
                                                                navigable: *Navigable,
                                                                traversable: *TraversableNavigable,
                                                                navigation_type: *NavigationType,
                                                                source_snapshot_params: *SourceSnapshotParams,
                                                                changing_navigable_continuations: *[..]ChangingNavigableContinuationState) -> *Algorithm
{
    Tâche :: struct {
        empl base: Algorithm

        user_agent: *UserAgent
        navigable: *Navigable
        traversable: *TraversableNavigable
        navigation_type: *NavigationType
        source_snapshot_params: *SourceSnapshotParams
        changing_navigable_continuations: *[..]ChangingNavigableContinuationState
    }

    sur_run :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche

        user_agent := tâche.user_agent
        navigable := tâche.navigable
        traversable := tâche.traversable
        navigation_type := tâche.navigation_type
        source_snapshot_params := tâche.source_snapshot_params
        changing_navigable_continuations := tâche.changing_navigable_continuations

        changing_navigable_continuations_steps(user_agent, navigable, traversable, navigation_type, source_snapshot_params, changing_navigable_continuations)
    }

    tâche := crée_algorithm(sur_run, Tâche)
    tâche.user_agent = user_agent
    tâche.navigable = navigable
    tâche.traversable = traversable
    tâche.navigation_type = navigation_type
    tâche.source_snapshot_params = source_snapshot_params
    tâche.changing_navigable_continuations = changing_navigable_continuations
    retourne tâche
}

changing_navigable_continuations_steps :: fonc (user_agent: *UserAgent,
                                                navigable: *Navigable,
                                                traversable: *TraversableNavigable @inutilisée,
                                                navigation_type: *NavigationType,
                                                source_snapshot_params: *SourceSnapshotParams,
                                                changing_navigable_continuations: *[..]ChangingNavigableContinuationState)
{
    // 1. Let displayedEntry be navigable's active session history entry.
    displayed_entry := navigable.active_session_history_entry

    // 2. Let targetEntry be navigable's current session history entry.
    target_entry := navigable.current_session_history_entry

    // 3. Let changingNavigableContinuation be a changing navigable continuation state with:
    //    displayed document   displayedEntry's document
    //    target entry         targetEntry
    //    navigable            navigable
    //    update-only          false
    changing_navigable_continuation: ChangingNavigableContinuationState
    changing_navigable_continuation.displayed_document = displayed_entry.donne_document()
    changing_navigable_continuation.target_entry = target_entry
    changing_navigable_continuation.navigable = navigable
    changing_navigable_continuation.update_only = faux

    // 4. If displayedEntry is targetEntry and targetEntry's document state's reload pending is false, then:
    si displayed_entry == target_entry && target_entry.document_state.reload_pending == faux {
        // 1. Set changingNavigableContinuation's update-only to true.
        changing_navigable_continuation.update_only = vrai

        // 2. Enqueue changingNavigableContinuation on changingNavigableContinuations.
        tableau_ajoute(changing_navigable_continuations, changing_navigable_continuation)

        // 3. Abort these steps.
        retourne
    }

    // 5. Switch on navigationType:
    si navigation_type {
        discr mémoire(navigation_type) {
            reload {
                // "reload"
                // Assert: targetEntry's document state's reload pending is true.
                assert(target_entry.document_state.reload_pending == vrai)
            }
            traverse {
                // "traverse"
                // Assert: targetEntry's document state's ever populated is true.
                assert(target_entry.document_state.ever_populated == vrai)
            }
            replace {
                // "replace"
                // Assert: targetEntry's step is displayedEntry's step and targetEntry's document state's ever populated is false.
                assert(target_entry.step == displayed_entry.step)
                // assert(target_entry.document_state.ever_populated == faux)
            }
            push {
                // "push"
                // Assert: targetEntry's step is displayedEntry's step + 1 and targetEntry's document state's ever populated is false.
                assert(target_entry.step == displayed_entry.step + 1)
                // assert(target_entry.document_state.ever_populated == faux)
            }
        }
    }

    // 6. Let oldOrigin be targetEntry's document state's origin.
    // old_origin := target_entry.donne_document().origin

    // À FAIRE : 7. If all of the following are true:
    //    navigable is not traversable;
    //    targetEntry is not navigable's current session history entry; and
    //    oldOrigin is the same as navigable's current session history entry's document state's origin,
    //    then:
    {
        // 1. Assert: userInvolvementForNavigateEvents is not null.

        // 2. Let navigation be navigable's active window's navigation API.

        // 3. Fire a traverse navigate event at navigation given targetEntry and userInvolvementForNavigateEvents.
    }

    // 8. If targetEntry's document is null, or targetEntry's document state's reload pending is true, then:
    si target_entry.donne_document() == nul || target_entry.document_state.reload_pending == vrai {
        // 1. Let navTimingType be "back_forward" if targetEntry's document is null; otherwise "reload".
        nav_timing_type := si target_entry.donne_document() == nul {
            NavigationTimingType.back_forward
        }
        sinon {
            NavigationTimingType.reload
        }

        // 2. Let targetSnapshotParams be the result of snapshotting target snapshot params given navigable.
        target_snapshot_params := snapshot_target_snapshot_params(navigable)

        // 3. Let potentiallyTargetSpecificSourceSnapshotParams be sourceSnapshotParams.
        potentially_target_specific_source_snapshot_params: SourceSnapshotParams
        
        // 4. If potentiallyTargetSpecificSourceSnapshotParams is null, then set it to the result of snapshotting source snapshot params given navigable's active document.
        si source_snapshot_params == nul {
            potentially_target_specific_source_snapshot_params = snapshot_source_snapshot_params(navigable.donne_active_document())
        }

        // 5. Set targetEntry's document state's reload pending to false.
        target_entry.document_state.reload_pending = faux

        // 6. Let allowPOST be targetEntry's document state's reload pending.
        allow_post := target_entry.document_state.reload_pending

        // https://github.com/whatwg/html/issues/9869
        // Recharger requiers de peupler l'entrée active d'history de session, la rendant inactive.
        // Ceci résulte en un une situation où des tâches qui déchargent le document précédent et en
        // active un nouveau ne peuvent être exécutées. Pour résoudre ceci, l'entrée cible est clonée
        // avant d'être peuplée.
        // Après que la décharge du document précédent est complétée, toutes les rubriques potentiellement
        // affectées par le peuplement sont copiées depuis l'entrée clonée vers l'entrée cible.
        // @fuite-de-mémoire
        populated_target_entry := clone(target_entry)

        // 7. In parallel, attempt to populate the history entry's document for targetEntry, given navigable, potentiallyTargetSpecificSourceSnapshotParams, targetSnapshotParams, with allowPOST set to allowPOST and
        //   completionSteps set to queue a global task on the navigation and traversal task source given navigable's active window to run afterDocumentPopulated.

        tâche_after_document_populated := crée_tâche_pour_after_document_populated(populated_target_entry, vrai, navigable, changing_navigable_continuation, changing_navigable_continuations)
        // À FAIRE : navigable.active_window
        completion_steps := crée_tâche_pour_enfiler_tâche(user_agent, tâche_after_document_populated, SourceDeTâche.NavigationEtTraversée)

        history_entry_population_params: HistoryEntryPopulationParams
        history_entry_population_params.user_agent = user_agent
        history_entry_population_params.entry = populated_target_entry
        history_entry_population_params.navigable = navigable
        history_entry_population_params.source_snapshot_params = potentially_target_specific_source_snapshot_params
        history_entry_population_params.target_snapshot_params = target_snapshot_params
        history_entry_population_params.completion_steps = completion_steps
        history_entry_population_params.allow_post = allow_post
        history_entry_population_params.nav_timing_type = nav_timing_type

        tâche_pour_entry_population_attempt := crée_algorithm_pour_fonction(*history_entry_population_params, attempt_to_populate_the_history_entry_document)
        user_agent.lance_en_parallèle(tâche_pour_entry_population_attempt)
        retourne
    }

    // Otherwise, run afterDocumentPopulated immediately.
    after_document_populated(target_entry, faux, navigable, changing_navigable_continuation, changing_navigable_continuations)
}

crée_tâche_pour_after_document_populated :: fonc (target_entry: *SessionHistoryEntry,
                                                  populated_cloned_target_entry: bool,  
                                                  navigable: *Navigable,
                                                  changing_navigable_continuation: ChangingNavigableContinuationState,
                                                  changing_navigable_continuations: *[..]ChangingNavigableContinuationState) -> *Algorithm
{
    Tâche :: struct {
        empl base: Algorithm

        target_entry: *SessionHistoryEntry
        populated_cloned_target_entry: bool
        navigable: *Navigable
        changing_navigable_continuation: ChangingNavigableContinuationState
        changing_navigable_continuations: *[..]ChangingNavigableContinuationState
    }

    sur_run :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche

        target_entry := tâche.target_entry
        navigable := tâche.navigable
        changing_navigable_continuation := tâche.changing_navigable_continuation
        changing_navigable_continuations := tâche.changing_navigable_continuations
        populated_cloned_target_entry := tâche.populated_cloned_target_entry

        after_document_populated(target_entry, populated_cloned_target_entry, navigable, changing_navigable_continuation, changing_navigable_continuations)
    }

    tâche := crée_algorithm(sur_run, Tâche)
    tâche.target_entry = target_entry
    tâche.navigable = navigable
    tâche.populated_cloned_target_entry = populated_cloned_target_entry
    tâche.changing_navigable_continuation = changing_navigable_continuation
    tâche.changing_navigable_continuations = changing_navigable_continuations
    retourne tâche
}

after_document_populated :: fonc (target_entry: *SessionHistoryEntry,
                                  populated_cloned_target_entry: bool,
                                  navigable: *Navigable @inutilisée,
                                  changing_navigable_continuation: ChangingNavigableContinuationState,
                                  changing_navigable_continuations: *[..]ChangingNavigableContinuationState)
{
    changing_navigable_continuation.populated_target_entry = target_entry
    changing_navigable_continuation.populated_cloned_target_entry = populated_cloned_target_entry

    // 1. If targetEntry's document is null, then set changingNavigableContinuation's update-only to true.
    si target_entry.donne_document() == nul {
        changing_navigable_continuation.update_only = vrai
    }

    // À FAIRE : 2. If targetEntry's document's origin is not oldOrigin, then set targetEntry's classic history API state to StructuredSerializeForStorage(null).

    // À FAIRE : 3. If all of the following are true:
    //    navigable's parent is null;
    //    targetEntry's document's browsing context is not an auxiliary browsing context whose opener browsing context is non-null; and
    //    targetEntry's document's origin is not oldOrigin,
    //    then set targetEntry's document state's navigable target name to the empty string.

    // 4. Enqueue changingNavigableContinuation on changingNavigableContinuations.
    tableau_ajoute(changing_navigable_continuations, changing_navigable_continuation)
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#deactivate-a-document-for-a-cross-document-navigation */
deactivate_document_for_a_cross_document_navigation :: fonc (user_agent: *UserAgent,
                                                             displayed_document: *Document,
                                                             user_navigation_involvement: *UserNavigationInvolvement @inutilisée,
                                                             target_entry: *SessionHistoryEntry,
                                                             navigation_type: NavigationType @inutilisée,
                                                             after_potential_unloads: *Algorithm)
{
    // 1. Let navigable be displayedDocument's node navigable.
    navigable := displayed_document.donne_node_navigable()

    // 2. Let potentiallyTriggerViewTransition be false.
    potentially_trigger_view_transition := faux

    // 3. Let isBrowserUINavigation be true if userNavigationInvolvement is "browser UI"; otherwise false.
    // is_browser_ui_navigation := user_navigation_involvement != nul && mémoire(user_navigation_involvement) == UserNavigationInvolvement.BrowserUI

    // À FAIRE : 4. Set potentiallyTriggerViewTransition to the result of calling can navigation trigger a cross-document view-transition? given displayedDocument, targetEntry's document, navigationType, and isBrowserUINavigation.

    // 5. If potentiallyTriggerViewTransition is false, then:
    saufsi potentially_trigger_view_transition {
        // À FAIRE : 1. Let firePageSwapBeforeUnload be the following step:
        fire_page_swap_steps: *Algorithm

            // 1. Fire the pageswap event given displayedDocument, targetEntry, navigationType, and null.

        // 2. Set the ongoing navigation for navigable to null.
        init_de(OngoingNavigationType)(*navigable.ongoing_navigation)

        // 3. Unload a document and its descendants given displayedDocument, targetEntry's document, afterPotentialUnloads, and firePageSwapBeforeUnload.
        unload_a_document_and_its_descendants(user_agent, displayed_document, target_entry.donne_document(), after_potential_unloads, fire_page_swap_steps)

        retourne
    }

    // 6. Otherwise, queue a global task on the navigation and traversal task source given navigable's active window to run the steps:
    panique("continue ici")

        // 1. Let proceedWithNavigationAfterViewTransitionCapture be the following step:

            // 1. Append the following session history traversal steps to navigable's traversable navigable:

                // 1. Set the ongoing navigation for navigable to null.

                // 2. Unload a document and its descendants given displayedDocument, targetEntry's document, and afterPotentialUnloads.

        // 2. Let viewTransition be the result of setting up a cross-document view-transition given displayedDocument, targetEntry's document, navigationType, and proceedWithNavigationAfterViewTransitionCapture.

        // 3. Fire the pageswap event given displayedDocument, targetEntry, navigationType, and viewTransition.

        // 4. If viewTransition is null, then run proceedWithNavigationAfterViewTransitionCapture.
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#activate-history-entry */
activate_histroy_entry :: fonc (entry: *SessionHistoryEntry, navigable: *Navigable)
{
    // 1. Save persisted state to the navigable's active session history entry.
    save_persisted_state(navigable.active_session_history_entry)

    // 2. Let newDocument be entry's document.
    new_document := entry.donne_document()

    // 3. Assert: newDocument's is initial about:blank is false, i.e., we never traverse back to the initial about:blank Document because it always gets replaced when we navigate away from it.
    assert(new_document.is_initial_about_blank == faux)

    // 4. Set navigable's active session history entry to entry.
    navigable.définis_active_session_history_entry(entry)

    // 5. Make active newDocument.
    make_active(new_document)
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#getting-the-used-step */
get_the_used_step :: fonc (user_agent: *UserAgent, traversable: *TraversableNavigable, step: n32) -> n32
{
    // 1. Let steps be the result of getting all used history steps within traversable.
    steps := get_all_used_history_steps(user_agent, traversable)
    diffère déloge(steps)
 
    // 2. Return the greatest item in steps that is less than or equal to step.
    résultat: n32

    pour steps {
        si it > step {
            arrête
        }
        résultat = it
    }

    retourne résultat
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#get-all-navigables-whose-current-session-history-entry-will-change-or-reload */
get_all_navigables_whose_current_session_history_entry_will_change_or_reload :: fonc (user_agent: *UserAgent, traversable: *TraversableNavigable, target_step: n32) -> [..]*Navigable
{
    // 1. Let results be an empty list.
    results: [..]*Navigable

    // 2. Let navigablesToCheck be « traversable ».
    navigables_to_check: [..]*Navigable
    tableau_ajoute(*navigables_to_check, traversable)

    // 3. For each navigable of navigablesToCheck:
    tantque navigables_to_check.taille != 0 {
        navigable := enlève_dernier_élément(*navigables_to_check)

        // 1. Let targetEntry be the result of getting the target history entry given navigable and targetStep.
        target_entry := get_the_target_history_entry(user_agent, navigable, target_step)

        // 2. If targetEntry is not navigable's current session history entry or targetEntry's document state's reload pending is true,
        //    then append navigable to results.
        si target_entry != navigable.current_session_history_entry || target_entry.document_state.reload_pending {
            tableau_ajoute(*results, navigable)
        }

        // 3. If targetEntry's document is navigable's document, and targetEntry's document state's reload pending is false,
        //    then extend navigablesToCheck with the child navigables of navigable.
        document_navigable := navigable.donne_active_document()
        si document_navigable == target_entry.donne_document() && target_entry.document_state.reload_pending == faux {
            pour navigable.enfants {
                tableau_ajoute(*navigables_to_check, it)
            }
        }
    }

    // 4. Return results.
    retourne results
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#getting-all-navigables-that-only-need-history-object-length/index-update */
get_all_navigables_that_only_need_history_object_length_index_update :: fonc (user_agent: *UserAgent, traversable: *TraversableNavigable, target_step: n32) -> [..]*Navigable
{
    // 1. Let results be an empty list.
    results: [..]*Navigable

    // 2. Let navigablesToCheck be « traversable ».
    navigables_to_check: [..]*Navigable
    tableau_ajoute(*navigables_to_check, traversable)

    // 3. For each navigable of navigablesToCheck:
    tantque navigables_to_check.taille != 0 {
        navigable := enlève_dernier_élément(*navigables_to_check)

        // 1. Let targetEntry be the result of getting the target history entry given navigable and targetStep.
        target_entry := get_the_target_history_entry(user_agent, navigable, target_step)

        // 2. If targetEntry is navigable's current session history entry and targetEntry's document state's reload pending is false, then:
        si target_entry == navigable.current_session_history_entry && target_entry.document_state.reload_pending == faux {
            // 1. Append navigable to results.
            tableau_ajoute(*results, navigable)

            // 2. Extend navigablesToCheck with navigable's child navigables.
            pour navigable.enfants {
                tableau_ajoute(*navigables_to_check, it)
            }
        }
    }

    // Return results.
    retourne results
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#getting-the-target-history-entry */
get_the_target_history_entry :: fonc (user_agent: *UserAgent, navigable: *Navigable, step: n32) -> *SessionHistoryEntry
{
    // 1. Let entries be the result of getting session history entries for navigable.
    entries := donne_session_history_entries(user_agent, navigable)

    // 2. Return the item in entries that has the greatest step less than or equal to step.
    résultat: *SessionHistoryEntry

    plus_grand_step : n32 = 0

    pour mémoire(entries) {
        si it.step > step {
            continue
        }

        si it.step >= plus_grand_step {
            plus_grand_step = it.step
            résultat = it
        }
    }

    assert(résultat != nul)
    retourne résultat
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#clear-the-forward-session-history */
clear_the_forward_session_history :: fonc (user_agent: *UserAgent, navigable: *TraversableNavigable)
{
    // 1. Assert: this is running within navigable's session history traversal queue.
    assert(user_agent.est_exécuté_sur_file_parallèle(navigable))

    // 2. Let step be the navigable's current session history step.
    step := navigable.current_session_history_entry_step

    // 3. Let entryLists be the ordered set « navigable's session history entries ».
    entry_lists_à_visiter: [..]*[..]*SessionHistoryEntry
    diffère déloge(entry_lists_à_visiter)

    /* À FAIRE(langage) : utilisation d'un nombre entier car les pointeurs vers tableaux n'ont pas d'opérateurs. */
    entry_lists_visités: [..]n64
    diffère déloge(entry_lists_visités)

    tableau_ajoute(*entry_lists_à_visiter, *navigable.session_history_entries)

    // 4. For each entryList of entryLists:
    tantque entry_lists_à_visiter.taille != 0 {
        entry_list := entry_lists_à_visiter[entry_lists_à_visiter.taille - 1]
        entry_lists_à_visiter.taille -= 1

        si ensemble_possède(*entry_lists_visités, entry_list comme n64) {
            continue
        }

        ensemble_ajoute(*entry_lists_visités, entry_list comme n64)

        // 1. Remove every session history entry from entryList that has a step greater than step.
        pour entry_list.taille {
            entry := entry_list.pointeur[it]

            si entry.step > step {
                tableau_supprime_index(entry_list, it)
                détruit_session_history_entry(entry)
                reprends it
            }
        }

        // 2. For each entry of entryList:
        pour entry_list.taille {
            entry := entry_list.pointeur[it]
            // 1. For each nestedHistory of entry's document state's nested histories, append nestedHistory's entries list to entryLists.

            pour * nested_history dans entry.document_state.nested_histories {
                tableau_ajoute(*entry_lists_à_visiter, *nested_history.entries)
            }
        }
    }
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#getting-all-used-history-steps */
get_all_used_history_steps :: fonc (user_agent: *UserAgent, traversable: *TraversableNavigable) -> [..]n32
{
    // 1. Assert: this is running within traversable's session history traversal queue.
    assert(user_agent.est_exécuté_sur_file_parallèle(traversable))

    // 2. Let steps be an empty ordered set of non-negative integers.
    steps: [..]n32

    // NOTE : les étapes suivantes sont réalisées différemment
    // 3. Let entryLists be the ordered set « traversable's session history entries ».
    // 4. For each entryList of entryLists:
        // 1. For each entry of entryList:
            // 1. Append entry's step to steps.
            // 2. For each nestedHistory of entry's document state's nested histories, append nestedHistory's entries list to entryLists.

    entrées_à_visiter := tableau_copie(traversable.session_history_entries)
    diffère déloge(entrées_à_visiter)

    entrées_visitées: [..]*SessionHistoryEntry
    diffère déloge(entrées_visitées)

    tantque entrées_à_visiter.taille != 0 {
        entrée := enlève_dernier_élément(*entrées_à_visiter)

        si ensemble_possède(*entrées_visitées, entrée) {
            continue
        }
        ensemble_ajoute(*entrées_visitées, entrée)

        ensemble_ajoute(*steps, entrée.step)

        pour entrée_nichée dans entrée.document_state.nested_histories {
            pour she dans entrée_nichée.entries {
                tableau_ajoute(*entrées_à_visiter, she)
            }
        }
    }

    // 5. Return steps, sorted.
    retourne steps
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#getting-all-navigables-that-might-experience-a-cross-document-traversal */
get_all_navigables_that_might_experience_a_cross_document_traversal :: fonc (user_agent: *UserAgent, traversable: *TraversableNavigable, target_step: n32) -> [..]*Navigable
{
    // 1. Let results be an empty list.
    results: [..]*Navigable

    // 2. Let navigablesToCheck be « traversable ».
    navigables_to_check: [..]*Navigable
    tableau_ajoute(*navigables_to_check, traversable)

    // 3. For each navigable of navigablesToCheck:
    tantque navigables_to_check.taille != 0 {
        navigable := enlève_dernier_élément(*navigables_to_check)

        // 1. Let targetEntry be the result of getting the target history entry given navigable and targetStep.
        target_entry := get_the_target_history_entry(user_agent, navigable, target_step)

        // 2. If targetEntry's document is not navigable's document or targetEntry's document state's reload pending is true, then append navigable to results.
        document_navigable := navigable.donne_active_document()
        si document_navigable != target_entry.donne_document() || target_entry.document_state.reload_pending == vrai {
            tableau_ajoute(*results, navigable)
        }
        // 3. Otherwise, extend navigablesToCheck with navigable's child navigables.
        sinon {
            pour navigable.enfants {
                tableau_ajoute(*navigables_to_check, it)
            }
        }
    }

    // 4. Return results.
    retourne results
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#checking-if-unloading-is-canceled */
check_if_unloading_is_canceled :: fonc (navigables_crossing_documents: [..]*Navigable @inutilisée, traversable: *TraversableNavigable @inutilisée, user_involvement_for_navigate_events: *UserNavigationInvolvement @inutilisée) -> chaine
{
    imprime("À FAIRE : [%]\n", #nom_de_cette_fonction)
    retourne "continue"
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 7.4.6.2 Updating the document
 * https://html.spec.whatwg.org/multipage/browsing-the-web.html#updating-the-document
 * \{ */

DocumentUpdateParams :: struct {
    document: *Document
    entry: *SessionHistoryEntry
    do_not_reactivate: bool
    script_history_length: n32
    script_history_index: n32
    navigation_type: Optionnel(NavigationType)
    entries_for_navigation_api: []*SessionHistoryEntry
    previous_entry_for_activation: Optionnel(*SessionHistoryEntry)
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#update-document-for-history-step-application */
update_document_for_history_step_application :: fonc (empl params: *DocumentUpdateParams)
{
    // 1. Let documentIsNew be true if document's latest entry is null; otherwise false.
    document_is_new := document.latest_entry != nul

    // 2. Let documentsEntryChanged be true if document's latest entry is not entry; otherwise false.
    documents_entry_changed := document.latest_entry != entry

    // À FAIRE 3. Set document's history object's index to scriptHistoryIndex.

    // À FAIRE 4. Set document's history object's length to scriptHistoryLength.

    // À FAIRE 5. Let navigation be history's relevant global object's navigation API.

    // 6. If documentsEntryChanged is true, then:
    si documents_entry_changed {
        // 1. Let oldURL be document's latest entry's URL.
        // old_url: *URL
        // si document.latest_entry {
        //     document.latest_entry.url
        // }

        // 2. Set document's latest entry to entry.
        document.latest_entry = entry

        // 3. Restore the history object state given document and entry.
        restore_the_history_object_state(document, entry)

        // 4. If documentIsNew is false, then:
        saufsi document_is_new {
            // 1. Assert: navigationType is not null.
            assert(navigation_type.possède_valeur())

            // À FAIRE : 2. Update the navigation API entries for a same-document navigation given navigation, entry, and navigationType.

            // À FAIRE : 3. Fire an event named popstate at document's relevant global object, using PopStateEvent, with the state attribute initialized to document's history object's state and hasUAVisualTransition initialized to true if a visual transition, to display a cached rendered state of the latest entry, was done by the user agent.

            // 4. Restore persisted state given entry.
            restore_persisted_state(entry)

            // À FAIRE : 5. If oldURL's fragment is not equal to entry's URL's fragment, then queue a global task on the DOM manipulation task source given document's relevant global object to fire an event named hashchange at document's relevant global object, using HashChangeEvent, with the oldURL attribute initialized to the serialization of oldURL and the newURL attribute initialized to the serialization of entry's URL.
        }
        // 5. Otherwise:
        sinon {
            // À FAIRE : 1. Assert: entriesForNavigationAPI is given.

            // 2. Restore persisted state given entry.
            restore_persisted_state(entry)

            // À FAIRE : 3. Initialize the navigation API entries for a new document given navigation, entriesForNavigationAPI, and entry.
        }
    }

    // 7. If all the following are true:
    // previousEntryForActivation is given;
    // navigationType is non-null; and
    // navigationType is "reload" or previousEntryForActivation's document is not document,
    // then:
    si previous_entry_for_activation.possède_valeur() && navigation_type.possède_valeur() && (navigation_type.Quelque == NavigationType.reload || donne_document(previous_entry_for_activation.Quelque) != document) {
        // À FAIRE : 1. If navigation's activation is null, then set navigation's activation to a new NavigationActivation object in navigation's relevant realm.

        // 2. Let previousEntryIndex be the result of getting the navigation API entry index of previousEntryForActivation within navigation.

        // 3. If previousEntryIndex is non-negative, then set activation's old entry to navigation's entry list[previousEntryIndex].

        // 4. Otherwise, if all the following are true:
        // navigationType is "replace";
        // previousEntryForActivation's document state's origin is same origin with document's origin; and
        // previousEntryForActivation's document's initial about:blank is false,
        // then set activation's old entry to a new NavigationHistoryEntry in navigation's relevant realm, whose session history entry is previousEntryForActivation.

        // 5. Set activation's new entry to navigation's current entry.

        // 6. Set activation's navigation type to navigationType.
    }

    // 8. If documentIsNew is true, then:
    si document_is_new {
        // À FAIRE : 1. Try to scroll to the fragment for document.

        // À FAIRE : 2. At this point scripts may run for the newly-created document document.
    }
    // 9. Otherwise, if documentsEntryChanged is false and doNotReactivate is false, then:
    sinon {
        // À FAIRE : 1. Assert: entriesForNavigationAPI is given.

        // À FAIRE : 2. Reactivate document given entry and entriesForNavigationAPI.
    }
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#restore-the-history-object-state */
restore_the_history_object_state :: fonc (document: *Document @inutilisée, entry: *SessionHistoryEntry @inutilisée)
{
    imprime("À FAIRE : [%]\n", #nom_de_cette_fonction)
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#make-active */
make_active :: fonc (document: *Document)
{
    // 1. Let window be document's relevant global object.
    window := document.donne_relevant_global_object() comme *Window

    // 2. Set document's browsing context's WindowProxy's [[Window]] internal slot value to window.
    document.browsing_context.window_proxy.window = window

    // À FAIRE 3. Set document's visibility state to document's node navigable's traversable navigable's system visibility state.

    // 4. Queue a new VisibilityStateEntry whose visibility state is document's visibility state and whose timestamp is zero.

    // 5. Set window's relevant settings object's execution ready flag.
    settings := window.donne_relevant_settings_object()
    settings.execution_ready = vrai
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 7.4.6.4 Scrolling to a fragment
 * https://html.spec.whatwg.org/multipage/browsing-the-web.html#scrolling-to-a-fragment
 * \{ */

scroll_to_the_fragment :: fonc (user_agent: *UserAgent, document: *Document)
{
    // 1. If document's indicated part is null, then set document's target element to null.
    indicated_part := document.donne_indicated_part()
    saufsi indicated_part {
        document.target_element = nul
        retourne
    }

    // 2. Otherwise, if document's indicated part is top of the document, then:
    si indicated_part == donne_special_value_top_of_the_document() {
        // 1. Set document's target element to null.
        document.target_element = nul

        // 2. Scroll to the beginning of the document for document. [CSSOMVIEW]
        // À FAIRE : utilise CSSOMVIEW
        user_agent.défile_page_vers_fragment()

        // 3. Return.
        retourne
    }

    // 3. Otherwise:

    // 1. Assert: document's indicated part is an element.

    // 2. Let target be document's indicated part.
    target := indicated_part

    // 3. Set document's target element to target.
    document.target_element = target

    // À FAIRE 4. Run the ancestor details revealing algorithm on target.

    // 5. Run the ancestor hidden-until-found revealing algorithm on target.

    // 6. Scroll target into view, with behavior set to "auto", block set to "start", and inline set to "nearest". [CSSOMVIEW]
    user_agent.défile_page_vers_fragment()

    // 7. Run the focusing steps for target, with the Document's viewport as the fallback target.

    // 8. Move the sequential focus navigation starting point to target.
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#the-indicated-part-of-the-document */
donne_indicated_part :: fonc (document: *Document) -> *Élément
{
    assert(document.type == "html")
    retourne select_the_indicated_part(document, document.url)
}

#portée_module

__top_of_the_document: Élément = ---
donne_special_value_top_of_the_document :: fonc () -> *Élément
{
    retourne *__top_of_the_document
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#select-the-indicated-part */
select_the_indicated_part :: fonc (document: *Document, url: *URL) -> *Élément
{
    // 1. If document's URL does not equal url with exclude fragments set to true, then return null.
    saufsi equals(document.url, url, vrai) {
        retourne nul
    }

    // 2. Let fragment be url's fragment.
    fragment := url.donne_fragment_ou_chaine_vide()

    // 3. If fragment is the empty string, then return the special value top of the document.
    saufsi fragment {
        retourne donne_special_value_top_of_the_document()
    }

    // 4. Let potentialIndicatedElement be the result of finding a potential indicated element given document and fragment.
    potential_indiciated_element := find_a_potential_indicated_element(document, fragment)

    // 5. If potentialIndicatedElement is not null, then return potentialIndicatedElement.
    si potential_indiciated_element {
        retourne potential_indiciated_element
    }

    // À FAIRE 6. Let fragmentBytes be the result of percent-decoding fragment.

    // 7. Let decodedFragment be the result of running UTF-8 decode without BOM on fragmentBytes.

    // 8. Set potentialIndicatedElement to the result of finding a potential indicated element given document and decodedFragment.

    // 9. If potentialIndicatedElement is not null, then return potentialIndicatedElement.

    // 10. If decodedFragment is an ASCII case-insensitive match for the string top, then return the top of the document.

    // 11. Return null.
    retourne nul
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#find-a-potential-indicated-element */
find_a_potential_indicated_element :: fonc (document: *Document, fragment: chaine) -> *Élément
{
    pile: Pile(*Noeud)
    diffère détruit(pile)

    pile.empile(document)

    tantque !pile.est_vide() {
        noeud := pile.dépile()

        si noeud.est_élément() {
            élément := noeud comme *Élément

            // 1. If there is an element in the document tree whose root is document and
            //    that has an ID equal to fragment, then return the first such element in tree order.
            si élément.id.donne_chaine_utf16() == fragment {
                retourne élément
            }

            // 2. If there is an a element in the document tree whose root is document that has a
            //    name attribute whose value is equal to fragment, then return the first such element
            //    in tree order.
            si élément.local_name == TAG_a && donne_attribut_ou_chaine_vide(élément, ATTR_name).donne_chaine_utf16() == fragment {
                retourne élément
            }
        }

        pour > noeud.enfants {
            pile.empile(it)
        }
    }

    // 3. Return null.
    retourne nul
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 7.4.6.5 Persisted history entry state
 * https://html.spec.whatwg.org/multipage/browsing-the-web.html#persisted-user-state-restoration
 * \{ */

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#save-persisted-state */
save_persisted_state :: fonc (entry: *SessionHistoryEntry @inutilisée)
{
    imprime("À FAIRE : [%]\n", #nom_de_cette_fonction)
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#restore-persisted-state */
restore_persisted_state :: fonc (entry: *SessionHistoryEntry @inutilisée)
{
    imprime("À FAIRE : [%]\n", #nom_de_cette_fonction)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 7.5.1 Shared document creation infrastructure
 * https://html.spec.whatwg.org/multipage/document-lifecycle.html#shared-document-creation-infrastructure
 * \{ */

/* https://html.spec.whatwg.org/multipage/document-lifecycle.html#initialise-the-document-object */
create_and_initialize_a_document_object :: fonc (user_agent: *UserAgent, type: chaine,  content_type: chaine, navigation_params: *NavigationParams) -> *Document
{
    // 1. Let browsingContext be navigationParams's navigable's active browsing context.
    browsing_context := navigation_params.navigable.donne_active_browsing_context()

    // 2. Set browsingContext to the result of the obtaining a browsing context to use for a navigation response given browsingContext, navigationParams's final sandboxing flag set, navigationParams's cross-origin opener policy, and navigationParams's COOP enforcement result.
    browsing_context = obtain_a_browsing_context_for_a_navigation_response(user_agent, browsing_context, navigation_params.final_sandboxing_flag, navigation_params.cross_origin_opener_policy, navigation_params.COOP_enforcement_result)

    // À FAIRE 3. Let permissionsPolicy be the result of creating a permissions policy from a response given navigationParams's navigable's container, navigationParams's origin, and navigationParams's response. [PERMISSIONSPOLICY]

    // 4. Let creationURL be navigationParams's response's URL.
    creation_url := navigation_params.response.donne_url()

    // 5. If navigationParams's request is non-null, then set creationURL to navigationParams's request's current URL.
    si navigation_params.request {
        creation_url = navigation_params.request.donne_url_courant()
    }

    // 6. Let window be null.
    window: *Window

    // 7. If browsingContext's active document's is initial about:blank is true, and
    //    À FAIRE browsingContext's active document's origin is same origin-domain with navigationParams's origin,
    //    then set window to browsingContext's active window.
    si browsing_context.donne_active_document().is_initial_about_blank {
        window = browsing_context.donne_active_window()
    }
    // 8. Otherwise:
    sinon {
        // 1.  À FAIRE Let oacHeader be the result of getting a structured field value given `Origin-Agent-Cluster` and "item" from navigationParams's response's header list.

        // 2. Let requestsOAC be true if oacHeader is not null and oacHeader[0] is the boolean true; otherwise false.

        // 3. If navigationParams's reserved environment is a non-secure context, then set requestsOAC to false.
        request_oac := faux

        // 4. Let agent be the result of obtaining a similar-origin window agent given navigationParams's origin, browsingContext's group, and requestsOAC.
        agent := obtain_similar_origin_window_agent(navigation_params.origin, browsing_context.group, request_oac)

        // 5. Let realmExecutionContext be the result of creating a new realm given agent and the following customizations:
            // For the global object, create a new Window object.
            // For the global this binding, use browsingContext's WindowProxy object.
        ConfigurationRealmDocument :: struct {
            empl base: JS.ConfigurationRealm

            browsing_context: *BrowsingContext
            user_agent: *UserAgent
        }

        crée_objet_global :: fonc(base: *JS.ConfigurationRealm, realm: *JS.Realm) -> *JS.Object
        {
            configuration := base comme *ConfigurationRealmDocument
            tas_de_mémoire := JS.donne_tas_de_mémoire(realm)
            retourne crée_objet_window(configuration.user_agent, tas_de_mémoire, realm)
        }

        donne_this_binding_global :: fonc (base: *JS.ConfigurationRealm) -> *JS.Object
        {
            configuration := base comme *ConfigurationRealmDocument
            retourne configuration.browsing_context.window_proxy
        }

        configuration: ConfigurationRealmDocument
        configuration.crée_host_instrinsics = initialise_host_intrinsics
        configuration.browsing_context = browsing_context
        configuration.user_agent = user_agent
        configuration.crée_objet_global = crée_objet_global
        configuration.donne_this_binding_global = donne_this_binding_global

        realm_execution_context := crée_un_nouveau_realm(agent, *user_agent.mv, *configuration)

        // 6. Set window to the global object of realmExecutionContext's Realm component.
        window = realm_execution_context.realm.global_object comme *Window

        // 7. Let topLevelCreationURL be creationURL.
        top_level_creation_url := creation_url

        // 8. Let topLevelOrigin be navigationParams's origin.
        top_level_origin := navigation_params.origin

        // À FAIRE : 9. If navigable's container is not null, then:

            // 1. Let parentEnvironment be navigable's container's relevant settings object.

            // 2. Set topLevelCreationURL to parentEnvironment's top-level creation URL.

            // 3. Set topLevelOrigin to parentEnvironment's top-level origin.

        // 10. Set up a window environment settings object with creationURL, realmExecutionContext, navigationParams's reserved environment, topLevelCreationURL, and topLevelOrigin.
        set_up_window_environnement_context(creation_url, realm_execution_context, navigation_params.reserved_environment, top_level_creation_url, top_level_origin)
    }

    // À FAIRE 9. Let loadTimingInfo be a new document load timing info with its navigation start time set to navigationParams's response's timing info's start time.

    // 10. Let document be a new Document, with
    //     type type
    //     content type contentType
    //     origin navigationParams's origin
    //     browsing context browsingContext
    //     policy container navigationParams's policy container
    //     permissions policy permissionsPolicy
    //     active sandboxing flag set navigationParams's final sandboxing flag set
    //     cross-origin opener policy navigationParams's cross-origin opener policy
    //     load timing info loadTimingInfo
    //     was created via cross-origin redirects navigationParams's response's has cross-origin redirects
    //     during-loading navigation ID for WebDriver BiDi navigationParams's id
    //     URL creationURL
    //     current document readiness "loading"
    //     about base URL navigationParams's about base URL
    //     allow declarative shadow roots true
    document := crée_noeud_document(user_agent.donne_tas_de_mémoire(), window.realm)
    document.type = type
    document.type_contenu = content_type
    document.origin = navigation_params.origin
    document.browsing_context = browsing_context
    document.policy_container = navigation_params.policy_container
    //     permissions policy permissionsPolicy
    document.active_sandboxing_flags = navigation_params.final_sandboxing_flag
    document.cross_origin_opener_policy = navigation_params.cross_origin_opener_policy
    //     load timing info loadTimingInfo
    //     was created via cross-origin redirects navigationParams's response's has cross-origin redirects
    //     during-loading navigation ID for WebDriver BiDi navigationParams's id
    document.url = copie_url(creation_url)
    //     current document readiness "loading"
    document.about_base_url = navigation_params.about_base_url
    document.permets_racines_shadow_déclaratives = vrai

    // 11. Set window's associated Document to document.
    window.document = document

    // À FAIRE 12. Run CSP initialization for a Document given document. [CSP]

    // 13. If navigationParams's request is non-null, then:
    si navigation_params.request {
        imprime("À FAIRE : [document referrer]\n")
        // 1. Set document's referrer to the empty string.

        // 2. Let referrer be navigationParams's request's referrer.

        // 3. If referrer is a URL record, then set document's referrer to the serialization of referrer.
    }

    // 14. If navigationParams's fetch controller is not null, then:
    si navigation_params.fetch_controller {
        imprime("À FAIRE : [extract the full timing info from navigationParams's fetch controller]\n")
        // 1. Let fullTimingInfo be the result of extracting the full timing info from navigationParams's fetch controller.

        // 2. Let redirectCount be 0 if navigationParams's response's has cross-origin redirects is true; otherwise navigationParams's request's redirect count.

        // 3. Create the navigation timing entry for document, given fullTimingInfo, redirectCount, navigationTimingType, navigationParams's response's service worker timing info, and navigationParams's response's body info.
    }

    // À FAIRE 15. Create the navigation timing entry for document, with navigationParams's response's timing info, redirectCount, navigationParams's navigation timing type, and navigationParams's response's service worker timing info.

    // À FAIRE 16. If navigationParams's response has a `Refresh` header, then:

        // 1. Let value be the isomorphic decoding of the value of the header.

        // 2. Run the shared declarative refresh steps with document and value.

    // 17. If navigationParams's commit early hints is not null, then call navigationParams's commit early hints with document.
    si navigation_params.commit_early_hints {
        run(navigation_params.commit_early_hints, document)
    }

    // À FAIRE 18. Process link headers given document, navigationParams's response, and "pre-media".

    // 19. Return document.
    retourne document
}

/* https://html.spec.whatwg.org/multipage/document-lifecycle.html#populate-with-html/head/body */
populate_with_html_head_body :: fonc (document: *Document)
{
    // 1. Let html be the result of creating an element given document, html, and the HTML namespace.
    html := crée_élément_avec_tag(document, TAG_html)

    // 2. Let head be the result of creating an element given document, head, and the HTML namespace.
    head := crée_élément_avec_tag(document, TAG_head)

    // 3. Let body be the result of creating an element given document, body, and the HTML namespace.
    body := crée_élément_avec_tag(document, TAG_body)

    // 4. Append html to document.
    document.ajoute_enfant(html)

    // 5. Append head to html.
    html.ajoute_enfant(head)

    // 6. Append body to html.
    html.ajoute_enfant(body)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 7.5.2 Loading HTML documents
 * https://html.spec.whatwg.org/multipage/document-lifecycle.html#read-html
 * \{ */

/* https://html.spec.whatwg.org/multipage/document-lifecycle.html#navigate-html */
load_an_html_document :: fonc (user_agent: *UserAgent, navigation_params: *NavigationParams) -> *Document
{
    response := navigation_params.response

    // 1. Let document be the result of creating and initializing a Document object given "html", "text/html", and navigationParams.
    document := create_and_initialize_a_document_object(user_agent, "html", "text/html", navigation_params)

    // 2. If document's URL is about:blank, then populate with html/head/body given document.
    si document.url.est_about_blank() {
        populate_with_html_head_body(document)
    }
    // 3. Otherwise, create an HTML parser and associate it with the document. Each task that the networking task source places on the task queue while fetching runs must then fill the parser's input byte stream with the fetched bytes and cause the HTML parser to perform the appropriate processing of the input stream.
    sinon {
        parseuse := initialise_parseuse(user_agent.donne_tas_de_mémoire(), response.body.Quelque, document)
        diffère détruit_parseuse(*parseuse)

        // début := maintenant_précis()
        parse(*parseuse)
        // temps := début.temps_écoulé_microsecondes()

        // À FAIRE : The first task that the networking task source places on the task queue while fetching runs must process link headers given document, navigationParams's response, and "media", after the task has been processed by the HTML parser.
        // À FAIRE : Before any script execution occurs, the user agent must wait for scripts may run for the newly-created document to be true for document.
        // À FAIRE : When no more bytes are available, the user agent must queue a global task on the networking task source given document's relevant global object to have the parser process the implied EOF character, which eventually causes a load event to be fired.
    }

    // 4. Return document.
    retourne document
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 7.5.4 Loading text documents
 * https://html.spec.whatwg.org/multipage/document-lifecycle.html#read-text
 * \{ */

/* https://html.spec.whatwg.org/multipage/document-lifecycle.html#navigate-text */
load_a_text_document :: fonc (user_agent: *UserAgent, navigation_params: *NavigationParams, type: chaine) -> *Document
{
    // À FAIRE : standardise
    response := navigation_params.response

    document := create_and_initialize_a_document_object(user_agent, "html", type, navigation_params)

    populate_with_html_head_body(document)

    body := donne_élément_body(document)

    pre := crée_élément_avec_tag(document, TAG_pre)
    body.ajoute_enfant(pre)

    noeud_texte := crée_noeud_texte(document)
    noeud_texte.données = Chaine.crée_chaine_utf16(response.body)

    pre.ajoute_enfant(noeud_texte)

    // 4. Return document.
    retourne document
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 7.5.8 Finishing the loading process
 * https://html.spec.whatwg.org/multipage/document-lifecycle.html#loading-documents
 * \{ */

/* https://html.spec.whatwg.org/multipage/document-lifecycle.html#completely-finish-loading */
completely_finish_loading :: fonc (document: *Document)
{
    imprime("À FAIRE : [%]\n", #nom_de_cette_fonction)

    // 1. Assert: document's browsing context is non-null.
    assert(document.browsing_context != nul)

    // 2. Set document's completely loaded time to the current time.

    // 3. Let container be document's node navigable's container.

    // 4. If container is an iframe element, then queue an element task on the DOM manipulation task source given container to run the iframe load event steps given container.

    // 5. Otherwise, if container is non-null, then queue an element task on the DOM manipulation task source given container to fire an event named load at container.
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 7.5.9 Unloading documents
 * https://html.spec.whatwg.org/multipage/document-lifecycle.html#unloading-documents
 * \{ */

/* https://html.spec.whatwg.org/multipage/document-lifecycle.html#unload-a-document */
unload_a_document :: fonc (user_agent: *UserAgent, old_document: *Document @inutilisée, new_document : *Document = nul @inutilisée)
{
    imprime("À FAIRE : [%]\n", #nom_de_cette_fonction)

    // 1. Assert: this is running as part of a task queued on oldDocument's relevant agent's event loop.
    // À FAIRE : oldDocument's relevant agent's event loop
    assert(user_agent.est_exécuté_sur_fil_principal())

    // 2. Let unloadTimingInfo be a new document unload timing info.

    // 3. If newDocument is not given, then set unloadTimingInfo to null.

    // 4. Otherwise, if newDocument's event loop is not oldDocument's event loop, then the user agent may be unloading oldDocument in parallel. In that case, the user agent should set unloadTimingInfo to null.

    // 5. Let intendToKeepInBfcache be true if the user agent intends to keep oldDocument alive in a session history entry, such that it can later be used for history traversal.

    // 6. Let eventLoop be oldDocument's relevant agent's event loop.

    // 7. Increase eventLoop's termination nesting level by 1.

    // 8. Increase oldDocument's unload counter by 1.

    // 9. If intendToKeepInBfcache is false, then set oldDocument's salvageable state to false.

    // 10. If oldDocument's page showing is true:

        // 1. Set oldDocument's page showing to false.

        // 2. Fire a page transition event named pagehide at oldDocument's relevant global object with oldDocument's salvageable state.

        // 3. Update the visibility state of oldDocument to "hidden".

    // 11. If unloadTimingInfo is not null, then set unloadTimingInfo's unload event start time to the current high resolution time given newDocument's relevant global object, coarsened given oldDocument's relevant settings object's cross-origin isolated capability.

    // 12. If oldDocument's salvageable state is false, then fire an event named unload at oldDocument's relevant global object, with legacy target override flag set.

    // 13. If unloadTimingInfo is not null, then set unloadTimingInfo's unload event end time to the current high resolution time given newDocument's relevant global object, coarsened given oldDocument's relevant settings object's cross-origin isolated capability.

    // 14. Decrease eventLoop's termination nesting level by 1.

    // 15. Set oldDocument's suspension time to the current high resolution time given document's relevant global object.

    // 16. Set oldDocument's suspended timer handles to the result of getting the keys for the map of active timers.

    // 17. Set oldDocument's has been scrolled by the user to false.

    // 18. Run any unloading document cleanup steps for oldDocument that are defined by this specification and other applicable specifications.

    // 19. If oldDocument's node navigable is a top-level traversable, build not restored reasons for a top-level traversable and its descendants given oldDocument's node navigable.

    // 20. If oldDocument's salvageable state is false, then destroy oldDocument.

    // 21. Decrease oldDocument's unload counter by 1.

    // 22. If newDocument is given, newDocument's was created via cross-origin redirects is false, and newDocument's origin is the same as oldDocument's origin, then set newDocument's previous document unload timing to unloadTimingInfo.
}

/* https://html.spec.whatwg.org/multipage/document-lifecycle.html#unload-a-document-and-its-descendants */
unload_a_document_and_its_descendants :: fonc (user_agent: *UserAgent, document: *Document, new_document : *Document = nul, after_all_unloads : *Algorithm = nul, fire_page_swap_steps : *Algorithm = nul)
{
    // 1. Assert: this is running within document's node navigable's traversable navigable's session history traversal queue.
    traversable := document.donne_node_navigable().donne_traversable_navigable()
    assert(user_agent.est_exécuté_sur_file_parallèle(traversable))

    // 2. Let childNavigables be document's child navigables.
    child_navigables := traversable.enfants

    // 3. Let numberUnloaded be 0.
    number_unloaded := 0

    // 4. For each childNavigable of childNavigables,
    pour child_navigable dans child_navigables {
        // queue a global task on the navigation and traversal task source given childNavigable's active window to perform the following steps:
        tâche := crée_tâche_unload_étape_4(user_agent, child_navigable.donne_active_document(), *number_unloaded)
        user_agent.queue_a_globask_task(SourceDeTâche.NavigationEtTraversée, child_navigable.donne_active_window(), tâche)
    }

    // 5. Wait until numberUnloaded equals childNavigable's size.
    tantque number_unloaded != child_navigables.taille {
        continue
    }

    // 6. Queue a global task on the navigation and traversal task source given document's relevant global object to perform the following steps:
    tâche := crée_tâche_unload_étape_6(user_agent, document, new_document, after_all_unloads, fire_page_swap_steps)
    user_agent.queue_a_globask_task(SourceDeTâche.NavigationEtTraversée, document.donne_relevant_global_object(), tâche)
}

crée_tâche_unload_étape_4 :: fonc (user_agent: *UserAgent, document: *Document, number_unloaded: *z32) -> *Algorithm
{
    Tâche :: struct {
        empl base: Algorithm

        user_agent: *UserAgent
        document: *Document
        number_unloaded: *z32
    }

    sur_run :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche

        // 1. Let incrementUnloaded be an algorithm step which increments numberUnloaded.
        increment_unloaded := crée_tâche_incrément_entier(tâche.number_unloaded)

        // 2. Unload a document and its descendants given childNavigable's active document, null, and incrementUnloaded.
        unload_a_document_and_its_descendants(tâche.user_agent, tâche.document, nul, increment_unloaded)
    }

    tâche := crée_algorithm(sur_run, Tâche)
    tâche.user_agent = user_agent
    tâche.document = document
    tâche.number_unloaded = number_unloaded
    retourne tâche
}

crée_tâche_unload_étape_6 :: fonc (user_agent: *UserAgent, document: *Document, new_document: *Document, after_all_unloads: *Algorithm, fire_page_swap_steps: *Algorithm) -> *Algorithm
{
    Tâche :: struct {
        empl base: Algorithm

        user_agent: *UserAgent
        document: *Document
        new_document: *Document
        after_all_unloads: *Algorithm
        fire_page_swap_steps: *Algorithm
    }

    sur_run :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche

        // 1. If firePageSwapSteps is given, then run firePageSwapSteps.
        si tâche.fire_page_swap_steps {
            run(tâche.fire_page_swap_steps)
        }

        // 2. Unload document, passing along newDocument if it is not null.
        unload_a_document(tâche.user_agent, tâche.document, tâche.new_document)

        // 3. If afterAllUnloads was given, then run it.
        si tâche.after_all_unloads {
            run(tâche.after_all_unloads)
        }
    }

    tâche := crée_algorithm(sur_run, Tâche)
    tâche.user_agent = user_agent
    tâche.document = document
    tâche.new_document = new_document
    tâche.after_all_unloads = after_all_unloads
    tâche.fire_page_swap_steps = fire_page_swap_steps
    retourne tâche
}

crée_tâche_incrément_entier :: fonc (nombre: *z32) -> *Algorithm
{
    Tâche :: struct {
        empl base: Algorithm

        nombre: *z32
    }

    sur_run :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche
        mémoire(tâche.nombre) += 1
    }

    tâche := crée_algorithm(sur_run, Tâche)
    tâche.nombre = nombre
    retourne tâche
}

/** \} */
