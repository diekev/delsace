importe Ensemble
importe Fondation
importe GlibC
importe Sérialisation
importe SysFichier

Griffonier :: TamponFixe(T = z8, N = 128)

donne_nom_snake_case :: fonc (chn: chaine, griffonier: *Griffonier) -> chaine
{
    premier := vrai

    griffonier.curseur = 0

    curseur := 0

    tantque curseur < chn.taille {
        it := chn[curseur]

        si 'A' <= it <= 'Z' {
            saufsi premier {
                ajoute(griffonier, '_')
            }

            ajoute(griffonier, it - 'A' + 'a')

            si it == 'H' && curseur < chn.taille - 3 && sous_chaine(chn, curseur, curseur + 4) == "HTML" {
                ajoute(griffonier, 't')
                ajoute(griffonier, 'm')
                ajoute(griffonier, 'l')
                curseur += 3
            }
        }
        sinon {
            ajoute(griffonier, it)
        }

        premier = faux
        curseur += 1
    }

    retourne construit_chaine(*griffonier.données[0], griffonier.curseur)
}

NomEtIndex :: struct {
    nom: chaine
    index: z64
}

opérateur < :: fonc (a: NomEtIndex, b: NomEtIndex) -> bool
{
    retourne a.nom < b.nom
}

opérateur == :: fonc (a: NomEtIndex, b: NomEtIndex) -> bool
{
    retourne a.nom == b.nom
}

principale :: fonc () -> z32
{
    mémoire_début := mémoire_utilisée()
    diffère imprime("mémoire utilisée : %o\n", mémoire_utilisée() - mémoire_début)

    interfaces: [..]Interface
    diffère {
        pour interfaces {
            déloge(it.nom)
            déloge(it.parent)
        }
        déloge(interfaces)
    }

    noms_et_index_parents: [..]NomEtIndex
    diffère déloge(noms_et_index_parents)

    /* Interface pour réutiliser la mémoire entre les parsages. */
    interface_tampon: Interface
    diffère {
        déloge(interface_tampon.fonctions)
        déloge(interface_tampon.paramètres)
        déloge(interface_tampon.attributs)
    }

    enchaineuse: Enchaineuse
    initialise_enchaineuse(*enchaineuse)
    diffère détruit_tampons(*enchaineuse)

    pour ExploratriceFichier(CheminFichier("fichiers")) {
        saufsi it.extension() == ".idl" {
            continue
        }

        texte := contenu_fichier_texte(it)
        diffère déloge(texte)

        interface_tampon.nom = ""
        interface_tampon.parent = ""
        interface_tampon.paramètres.taille = 0
        interface_tampon.fonctions.taille = 0
        interface_tampon.attributs.taille = 0

        parse_interface(texte, *interface_tampon)
        
        // imprime_interface(*interface)

        génère_enveloppes_javascript(*enchaineuse, *interface_tampon)

        interface: Interface
        interface.nom = copie_chaine(interface_tampon.nom)
        interface.parent = copie_chaine(interface_tampon.parent)
        tableau_ajoute(*interfaces, interface)

        nom_et_index_parent: NomEtIndex
        nom_et_index_parent.nom = interface.nom

        saufsi ensemble_possède(*noms_et_index_parents, nom_et_index_parent) {
            nom_et_index_parent.index = interfaces.taille - 1
            ensemble_ajoute(*noms_et_index_parents, nom_et_index_parent)
        }
    }

    source := chaine_depuis_enchaineuse(*enchaineuse)
    imprime("%\n", source)
    déloge(source)

    détruit_tampons(*enchaineuse)
    initialise_enchaineuse(*enchaineuse)

    ajoute_au_tampon(*enchaineuse, "    tas_de_mémoire := JavaScript.donne_tas_de_mémoire(realm)\n\n")

    pour * interfaces {
        génère_création_prototype(*enchaineuse, interfaces, it, *noms_et_index_parents)
    }

    ajoute_au_tampon(*enchaineuse, "\n    tableau_redimensionne(realm.intrinsics.host_intrinsics, PrototypesPlatformObject.nombre_éléments)\n")

    pour interfaces {
        ajoute_au_tampon(*enchaineuse, "    realm.intrinsics.host_intrinsics[PrototypesPlatformObject.", it.nom, "] = ", it.nom, "_prototype\n")
    }

    source = chaine_depuis_enchaineuse(*enchaineuse)
    imprime("%\n", source)
    déloge(source)

    retourne 0
}

génère_création_prototype :: fonc (enchaineuse: *Enchaineuse, interfaces: []Interface, interface: *Interface, noms_et_index_parents: *[..]NomEtIndex)
{
    si interface.création_générée {
        retourne
    }

    interface.création_générée = vrai

    si interface.parent {
        nom_et_index_parent: NomEtIndex
        nom_et_index_parent.nom = interface.parent

        adresse_nom_et_index_parent := ensemble_possède_retourne_index(noms_et_index_parents, nom_et_index_parent)
        assert(adresse_nom_et_index_parent != -1)

        parent := *interfaces[noms_et_index_parents.pointeur[adresse_nom_et_index_parent].index]

        génère_création_prototype(enchaineuse, interfaces, parent, noms_et_index_parents)
    }

    ajoute_au_tampon(enchaineuse, "    ", interface.nom, "_prototype := crée_prototype_", interface.nom, "(tas_de_mémoire, ")
    si interface.parent {
        ajoute_au_tampon(enchaineuse, interface.parent, "_prototype)\n")
    }
    sinon {
        ajoute_au_tampon(enchaineuse, "realm.intrinsics.object_prototype)\n")
    }
}

Type :: struct {
    nom: chaine
    nulifiable: bool
}

Attribut :: struct {
    type: Type
    nom: chaine
    lecture_seule: bool
}

Paramètre :: struct {
    nom: chaine
    type: Type
}

Fonction :: struct {
    type_retour: Type
    nom: chaine

    premier_paramètre: z64
    dernier_paramètre: z64
}

Interface :: struct {
    nom: chaine
    parent: chaine
    paramètres: [..]Paramètre
    attributs: [..]Attribut
    fonctions: [..]Fonction

    création_générée := faux
}

donne_paramètres :: fonc (interface: *Interface, fonction: *Fonction) -> []Paramètre
{
    résultat: []Paramètre
    résultat.pointeur = interface.paramètres.pointeur + fonction.premier_paramètre
    résultat.taille = fonction.dernier_paramètre - fonction.premier_paramètre
    retourne résultat
}

imprime_interface :: fonc (interface: *Interface)
{
    imprime("interface % ", interface.nom)
    si interface.parent {
        imprime(": % ", interface.parent)
    }
    imprime("{\n")

    pour interface.fonctions {
        imprime("    ")
        imprime_type(*it.type_retour)
        imprime(" %", it.nom)

        virgule := "("

        pour param dans it.paramètres {
            imprime("%", virgule)
            imprime_type(*param.type)
            imprime(" %", param.nom)
            virgule = ", "
        }

        imprime(");\n")
    }

    imprime("\n")

    pour interface.attributs {
        imprime("    ")
        si it.lecture_seule {
            imprime("readonly ")
        }
        imprime("attribute ")
        imprime_type(*it.type)
        imprime(" %", it.nom)
        imprime(";\n")
    }

    imprime("}\n")
}

génère_enveloppes_javascript :: fonc (enchaineuse: *Enchaineuse, interface: *Interface)
{
    griffonier: Griffonier

    pour * interface.fonctions {
        génère_enveloppe_javascript(enchaineuse, interface, it, *griffonier)
    }

    pour * interface.attributs {
        génère_enveloppe_javascript_getter(enchaineuse, interface, it, *griffonier)

        saufsi it.lecture_seule {
            génère_enveloppe_javascript_setter(enchaineuse, interface, it, *griffonier)
        }
    }

    génère_création_prototype(enchaineuse, interface)
}

génère_création_prototype :: fonc (enchaineuse: *Enchaineuse, interface: *Interface)
{
    ajoute_au_tampon(enchaineuse, "crée_prototype_", interface.nom, " :: fonc (tas_de_mémoire: *JavaScript.TasDeMémoire, prototype: *JavaScript.Object) -> *JavaScript.Object\n")
    ajoute_au_tampon(enchaineuse, "{\n")

    ajoute_au_tampon(enchaineuse, "    résultat := JavaScript.crée_objet(tas_de_mémoire, prototype)\n")

    pour * interface.fonctions {
        ajoute_au_tampon(enchaineuse, "    JavaScript.ajoute_fonction_native(résultat, \"", it.nom, "\", ", interface.nom, "_", it.nom, ")\n")
    }

    pour * interface.attributs {
        ajoute_au_tampon(enchaineuse, "    JavaScript.ajoute_propriété(résultat, crée_chaine_utf16_unique(\"", it.nom, "\"), ")
        ajoute_au_tampon(enchaineuse, "get_", interface.nom, "_", it.nom, ", ")
        si it.lecture_seule {
            ajoute_au_tampon(enchaineuse, "nul, ")
        }
        sinon {
            ajoute_au_tampon(enchaineuse, "set_", interface.nom, "_", it.nom, ", ")
        }
        ajoute_au_tampon(enchaineuse, "JavaScript.DrapeauxPropriété.zéro)\n")
    }
    
    ajoute_au_tampon(enchaineuse, "    retourne résultat\n")
    ajoute_au_tampon(enchaineuse, "}\n")
}

/*

donne_platform_object :: fonc (interpréteuse: *JavaScript.Interpréteuse, value: Value, $Type: type_de_données)
{
    completion := JavaScript.vers_objet(value)
    saufsi JavaScript.est_normal(completion) {
        retourne completion;
    }
    object := JavaScript.donne_objet(completion.valeur.V)
    info_type := info_de(Type)
    saufsi est_struct_ou_employeuse_de(JavaScript.donne_info_type_cellule(object), info_type) {
        message := imprime_chaine("object is not a '%', info_type.nom)
        diffère déloge(message)
        retourne JavaScript.lance_type_error(interpréteuse, message)
    }
    retourne JavaScript.normal_completion(Valeur(Object = object));
}

*/

génère_enveloppe_javascript :: fonc (enchaineuse: *Enchaineuse, interface: *Interface, fonction: *Fonction, griffonier: *Griffonier)
{
    paramètres := interface.donne_paramètres(fonction)

    ajoute_au_tampon(enchaineuse, interface.nom, "_", fonction.nom, " :: fonc (empl params: *JavaScript.ParamètresObjectCall) -> JavaScript.CompletionRecord\n")
    ajoute_au_tampon(enchaineuse, "{\n")

    génère_code_conversion_this(enchaineuse, interface)

    // Validation et conversion des paramètres
    si paramètres.taille != 0 {
        ajoute_au_tampon(enchaineuse, "    si arguments.taille < ", paramètres.taille, " {\n")
        ajoute_au_tampon(enchaineuse, "        retourne JavaScript.lance_type_error(interpréteuse, \"", fonction.nom, " takes ", paramètres.taille, " arguments\")\n")
        ajoute_au_tampon(enchaineuse, "    }\n")
    }

    pour paramètres {
        génère_code_conversion_argument(enchaineuse, it.nom, index_it, *it.type)
    }

    // Appel de la fonction.
    ajoute_au_tampon(enchaineuse, "    ")
    si fonction.type_retour.nom != "undefined" {
        ajoute_au_tampon(enchaineuse, "résultat := ")
    }
    ajoute_au_tampon(enchaineuse, donne_nom_snake_case(fonction.nom, griffonier))

    virgule := "(object_this, "
    si paramètres.taille == 0 {
        ajoute_au_tampon(enchaineuse, "(object_this")
    }
    sinon pour paramètres {
        ajoute_au_tampon(enchaineuse, virgule, it.nom)
        virgule = ", "
    }
    ajoute_au_tampon(enchaineuse, ")\n")

    génère_code_conversion_résultat(enchaineuse, *fonction.type_retour)

    ajoute_au_tampon(enchaineuse, "}\n")
}

génère_enveloppe_javascript_getter :: fonc (enchaineuse: *Enchaineuse, interface: *Interface, attribut: *Attribut, griffonier: *Griffonier)
{
    ajoute_au_tampon(enchaineuse, "get_", interface.nom, "_", attribut.nom, " :: fonc (empl params: *JavaScript.ParamètresObjectCall) -> JavaScript.CompletionRecord\n")
    ajoute_au_tampon(enchaineuse, "{\n")

    génère_code_conversion_this(enchaineuse, interface)

    // Appel de la fonction
    ajoute_au_tampon(enchaineuse, "    résultat := donne_", donne_nom_snake_case(attribut.nom, griffonier), "(object_this)\n")

    génère_code_conversion_résultat(enchaineuse, *attribut.type)

    ajoute_au_tampon(enchaineuse, "}\n")
}

génère_enveloppe_javascript_setter :: fonc (enchaineuse: *Enchaineuse, interface: *Interface, attribut: *Attribut, griffonier: *Griffonier)
{
    ajoute_au_tampon(enchaineuse, "set_", interface.nom, "_", attribut.nom, " :: fonc (empl params: *JavaScript.ParamètresObjectCall) -> JavaScript.CompletionRecord\n")
    ajoute_au_tampon(enchaineuse, "{\n")

    génère_code_conversion_this(enchaineuse, interface)

    ajoute_au_tampon(enchaineuse, "    si arguments.taille != 1 {\n")
    ajoute_au_tampon(enchaineuse, "        retourne JavaScript.lance_type_error(interpréteuse, \"", attribut.nom, " takes 1 arguments\")\n")
    ajoute_au_tampon(enchaineuse, "    }\n")

    génère_code_conversion_argument(enchaineuse, attribut.nom, 0, *attribut.type)

    // Appel de la fonction
    ajoute_au_tampon(enchaineuse, "    définis_", donne_nom_snake_case(attribut.nom, griffonier), "(object_this, ", attribut.nom, ")\n")
    ajoute_au_tampon(enchaineuse, "    retourne JavaScript.normal_completion(JavaScript.js_undefined)\n")
    ajoute_au_tampon(enchaineuse, "}\n")
}

génère_code_conversion_this :: fonc (enchaineuse: *Enchaineuse, interface: *Interface)
{
    ajoute_au_tampon(enchaineuse, "    completion := donne_platform_object(interpréteuse, this_value, ", interface.nom, ")\n")
    ajoute_au_tampon(enchaineuse, "    saufsi JavaScript.est_normal(completion) {\n        retourne completion;\n    }\n")
    ajoute_au_tampon(enchaineuse, "    object_this := JavaScript.donne_objet(completion.valeur.V) comme *", interface.nom, "\n")
}

génère_code_conversion_argument :: fonc (enchaineuse: *Enchaineuse, nom: chaine, index: z64, type: *Type)
{
    ajoute_au_tampon(enchaineuse, "    valeur_", nom, " := arguments[", index, "]\n")
    si type.nom == "DOMString" {
        ajoute_au_tampon(enchaineuse, "    saufsi JavaScript.est_chaine(valeur_", nom, ") {\n")
        ajoute_au_tampon(enchaineuse, "        retourne JavaScript.lance_type_error(interpréteuse, \"argument ", index, " is not a String\")\n")
        ajoute_au_tampon(enchaineuse, "    }\n")
        ajoute_au_tampon(enchaineuse, "    ", nom, " := valeur_", nom, ".String.texte\n")
    }
    sinon si type.nom == "EventListener" {
        // Convertis entre callback et notre EventListener
        ajoute_au_tampon(enchaineuse, "    ", nom, " := loge(EventListener)\n")
        indentation := ""

        si type.nulifiable {
            ajoute_au_tampon(enchaineuse, "    saufsi JavaScript.est_nulle(valeur_", nom, ") {\n")
            indentation = "    "
        }

        ajoute_au_tampon(enchaineuse, indentation, "    saufsi JavaScript.is_callable(valeur_", nom, ") {\n")
        ajoute_au_tampon(enchaineuse, indentation, "        retourne JavaScript.lance_type_error(interpréteuse, \"argument ", index, " is not callable\")\n")
        ajoute_au_tampon(enchaineuse, indentation, "    }\n")
        ajoute_au_tampon(enchaineuse, indentation, "    ", nom, ".function = JavaScript.donne_objet(valeur_", nom, ")\n")

        si type.nulifiable {
            ajoute_au_tampon(enchaineuse, "    }\n")
        }
    }
    sinon {
        ajoute_au_tampon(enchaineuse, "    completion = donne_platform_object(interpréteuse, valeur_", nom, ", ", type.nom, ")\n")
        ajoute_au_tampon(enchaineuse, "    saufsi JavaScript.est_normal(completion) {\n        retourne completion;\n    }\n")
        ajoute_au_tampon(enchaineuse, "    ", nom, " := JavaScript.donne_objet(completion.valeur.V) comme *", type.nom, "\n")
    }
}

génère_code_conversion_résultat :: fonc (enchaineuse: *Enchaineuse, type: *Type)
{
    si type.nom == "undefined" {
        ajoute_au_tampon(enchaineuse, "    retourne JavaScript.normal_completion(JavaScript.js_undefined)\n")
    }
    sinon si type.nom == "DOMString" {
        ajoute_au_tampon(enchaineuse, "    str_unique: ChaineUTF16Unique\n")
        ajoute_au_tampon(enchaineuse, "    #si type_de(résultat) != type_de(ChaineUTF16Unique) {\n")
        ajoute_au_tampon(enchaineuse, "        str_unique = crée_chaine_utf16_unique(résultat)\n")
        ajoute_au_tampon(enchaineuse, "    }\n")
        ajoute_au_tampon(enchaineuse, "    sinon {\n")
        ajoute_au_tampon(enchaineuse, "        str_unique = résultat\n")
        ajoute_au_tampon(enchaineuse, "    }\n")
        ajoute_au_tampon(enchaineuse, "    str := JavaScript.crée_chaine(object_this.donne_tas_de_mémoire(), str_unique)\n")
        ajoute_au_tampon(enchaineuse, "    retourne JavaScript.normal_completion(JavaScript.Valeur(String = str))\n")
    }
    sinon {
        si type.nulifiable {
            ajoute_au_tampon(enchaineuse, "    saufsi résultat {\n")
            ajoute_au_tampon(enchaineuse, "        retourne JavaScript.normal_completion(JavaScript.js_null)\n")
            ajoute_au_tampon(enchaineuse, "    }\n")
        }

        ajoute_au_tampon(enchaineuse, "    retourne JavaScript.normal_completion(JavaScript.Valeur(Object = résultat))\n")
    }
}

imprime_type :: fonc (type: *Type)
{
    imprime("%", type.nom)
    si type.nulifiable {
        imprime("?")
    }
}

parse_interface :: fonc (texte: chaine, résultat: *Interface)
{
    parseuse := crée_parseuse(texte)

    lexème := donne_lexème_suivant(*parseuse)

    si lexème != "interface" {
        rapporte_erreur("attendu 'interface'", lexème)
    }

    résultat.nom = donne_lexème_suivant(*parseuse)

    si consomme_caractère(*parseuse, ':') {
        résultat.parent = donne_lexème_suivant(*parseuse)
    }

    saufsi consomme_caractère(*parseuse, '{') {
        rapporte_erreur("attendu '{'", donne_lexème_suivant(*parseuse))
    }

    boucle {
        si consomme_caractère(*parseuse, '}') {
            arrête
        }

        lexème = donne_lexème_suivant(*parseuse)
        si lexème == "readonly" || lexème == "attribute" {
            parse_un_attribut(*parseuse, résultat, lexème)
        }
        sinon {
            parse_une_fonction(*parseuse, résultat, lexème)
        }
    }
}

parse_une_fonction :: fonc (parseuse: *ParseuseInterface, interface: *Interface, lexème: chaine)
{
    type_retour: Type
    type_retour.nom = lexème
    type_retour.nulifiable = consomme_caractère(parseuse, '?')

    résultat: Fonction
    résultat.type_retour = type_retour
    résultat.nom = donne_lexème_suivant(parseuse)
    résultat.premier_paramètre = interface.paramètres.taille

    saufsi consomme_caractère(parseuse, '(') {
        rapporte_erreur("attendu '('", donne_lexème_suivant(parseuse))
    }

    boucle {
        si consomme_caractère(parseuse, ')') {
            arrête
        }

        type: Type
        type.nom = donne_lexème_suivant(parseuse)
        type.nulifiable = consomme_caractère(parseuse, '?')

        paramètre: Paramètre
        paramètre.type = type
        paramètre.nom = donne_lexème_suivant(parseuse)

        tableau_ajoute(*interface.paramètres, paramètre)

        si consomme_caractère(parseuse, ',') {
            continue
        }

        saufsi consomme_caractère(parseuse, ')') {
            rapporte_erreur("attendu ')", donne_lexème_suivant(parseuse))
        }

        arrête
    }

    résultat.dernier_paramètre = interface.paramètres.taille
    tableau_ajoute(*interface.fonctions, résultat)

    saufsi consomme_caractère(parseuse, ';') {
        rapporte_erreur("attendu ';", donne_lexème_suivant(parseuse))
    }
}

parse_un_attribut :: fonc (parseuse: *ParseuseInterface, interface: *Interface, lexème: chaine)
{
    résultat: Attribut

    si lexème == "readonly" {
        résultat.lecture_seule = vrai
        lexème = donne_lexème_suivant(parseuse)
    }

    saufsi lexème == "attribute" {
        rapporte_erreur("attendu 'attribute'", lexème)
    }

    lexème = donne_lexème_suivant(parseuse)
    résultat.type.nom = lexème
    résultat.type.nulifiable = consomme_caractère(parseuse, '?')

    lexème = donne_lexème_suivant(parseuse)

    résultat.nom = lexème

    tableau_ajoute(*interface.attributs, résultat)

    saufsi consomme_caractère(parseuse, ';') {
        rapporte_erreur("attendu ';", donne_lexème_suivant(parseuse))
    }
}

rapporte_erreur :: fonc (message: chaine, lexème_obtenu: chaine)
{
    imprime("%, obtenu %\n", message, lexème_obtenu)
    exit(1)
}

ParseuseInterface :: struct {
    début: *z8
    fin: *z8
}

crée_parseuse :: fonc (texte: chaine) -> ParseuseInterface
{
    résultat : ParseuseInterface = ---
    résultat.début = texte.pointeur
    résultat.fin = texte.pointeur + texte.taille
    retourne résultat
}

donne_lexème_suivant :: fonc (parseuse: *ParseuseInterface) -> chaine
{
    consomme_espaces_blanches(parseuse)

    si parseuse.début >= parseuse.fin {
        retourne ""
    }

    résultat : chaine = ---
    résultat.pointeur = parseuse.début
    résultat.taille = 0

    tantque parseuse.début < parseuse.fin {
        c := mémoire(parseuse.début)
        si ('a' <= c <= 'z') || ('A' <= c <= 'Z') {
            parseuse.début += 1
            résultat.taille += 1
            continue
        }

        arrête
    }

    retourne résultat
}

consomme_caractère :: fonc (parseuse: *ParseuseInterface, c: z8) -> bool
{
    consomme_espaces_blanches(parseuse)
    si parseuse.début >= parseuse.fin {
        retourne faux
    }

    caractère := mémoire(parseuse.début)
    si c != caractère {
        retourne faux
    }

    parseuse.début += 1
    retourne vrai
}

consomme_espaces_blanches :: fonc (parseuse: *ParseuseInterface)
{
    tantque parseuse.début < parseuse.fin {
        saufsi est_espace_blanc(mémoire(parseuse.début)) {
            retourne
        }

        parseuse.début += 1
    }
}
