importe Sérialisation

/* https://webidl.spec.whatwg.org/#abstract-opdef-integerpart */
integer_part :: fonc (n: r64) -> r64
{
    // 1. Let r be floor(abs(n)).
    r := plancher(abs(n))

    // 2. If n < 0, then return -1 × r.
    si n < 0.0 {
        retourne -1.0 * r
    }

    // 3. Otherwise, return r.
    retourne r
}

Signedness :: énum {
    Signed
    Unsigned
}

/* https://webidl.spec.whatwg.org/#abstract-opdef-converttoint */
convert_to_int :: fonc (interpréteuse: *JS.Interpréteuse, valeur: JS.Valeur, bit_length: n32 @inutilisée, signedness: Signedness @inutilisée) -> JS.Valeur
{
    // À FAIRE : complète
    // 1. If bitLength is 64, then:

        // 1. Let upperBound be 2^53 − 1.

        // 2. If signedness is "unsigned", then let lowerBound be 0.

        // 3. Otherwise let lowerBound be −2^53 + 1.

    // 2. Otherwise, if signedness is "unsigned", then:

        // 1. Let lowerBound be 0.

        // 2. Let upperBound be 2^bitLength − 1.

    // 3. Otherwise:

        // 1. Let lowerBound be -2^bitLength − 1.

        // 2. Let upperBound be 2^bitLength − 1 − 1.

    // 4. Let x be ? ToNumber(V).
    x := JS.to_number(interpréteuse, valeur)
    si JS.possède_exception(interpréteuse) {
        retourne JS.js_undefined
    }

    // 5. If x is −0, then set x to +0.
    si x == -0.0 {
        x = 0.0
    }

    // 6. If the conversion is to an IDL type associated with the [EnforceRange] extended attribute, then:

        // 1. If x is NaN, +∞, or −∞, then throw a TypeError.

        // 2. Set x to IntegerPart(x).

        // 3. If x < lowerBound or x > upperBound, then throw a TypeError.

        // 4. Return x.

    // 7. If x is not NaN and the conversion is to an IDL type associated with the [Clamp] extended attribute, then:

        // 1. Set x to min(max(x, lowerBound), upperBound).

        // 2. Round x to the nearest integer, choosing the even integer if it lies halfway between two, and choosing +0 rather than −0.

        // 3. Return x.

    // 8. If x is NaN, +0, +∞, or −∞, then return +0.
    si est_nan(x) || x == 0.0 || est_infini(x) {
        retourne 0.0 comme r64
    }

    // 9. Set x to IntegerPart(x).
    x = integer_part(x)

    // 10. Set x to x modulo 2^bitLength.

    // 11. If signedness is "signed" and x ≥ 2^bitLength − 1, then return x − 2^bitLength.

    // 12. Otherwise, return x.
    retourne x
}

#portée_fichier

Griffonier :: TamponFixe(T = z8, N = 128)

donne_nom_snake_case :: fonc (chn: chaine, griffonier: *Griffonier) -> chaine
{
    premier := vrai

    griffonier.curseur = 0

    curseur := 0

    tantque curseur < chn.taille {
        it := chn[curseur]

        si 'A' <= it <= 'Z' {
            saufsi premier {
                ajoute(griffonier, '_')
            }

            ajoute(griffonier, it - 'A' + 'a')

            si it == 'H' && curseur < chn.taille - 3 && sous_chaine(chn, curseur, curseur + 4) == "HTML" {
                ajoute(griffonier, 't')
                ajoute(griffonier, 'm')
                ajoute(griffonier, 'l')
                curseur += 3
            }
        }
        sinon {
            ajoute(griffonier, it)
        }

        premier = faux
        curseur += 1
    }

    retourne chaine(*griffonier.données[0], griffonier.curseur)
}

NomEtIndice :: struct {
    nom: chaine
    indice: z64
}

opérateur < :: (a: NomEtIndice, b: NomEtIndice) -> bool
{
    retourne a.nom < b.nom
}

opérateur == :: (a: NomEtIndice, b: NomEtIndice) -> bool
{
    retourne a.nom == b.nom
}

#portée_module

NOMBRE_DE_TYPES_MAX :: 256

Interfaces :: struct {
    interfaces: [..]Interface
    contenus_fichiers: [..]chaine
    noms_et_indice_parents: [..]NomEtIndice
    types : [NOMBRE_DE_TYPES_MAX]Type = ---
    nombre_de_types: z32
}

ajoute_type :: fonc (interfaces: *Interfaces) -> *Type
{
    résultat := *interfaces.types[interfaces.nombre_de_types]
    init_de(Type)(résultat)
    interfaces.nombre_de_types += 1
    retourne résultat
}

trouve_ou_ajoute_type :: fonc (interfaces: *Interfaces, nom: chaine, nulifiable: bool) -> *Type
{
    pour interfaces.nombre_de_types {
        type := *interfaces.types[it]
        si type.nom == nom && type.nulifiable == nulifiable {
            retourne type
        }
    }

    résultat := ajoute_type(interfaces)
    résultat.nom = nom
    résultat.nulifiable = nulifiable
    retourne résultat
}

crée_interface :: fonc (interfaces: *Interfaces, nom: chaine) -> *Interface
{
    résultat := tableau_ajoute_élément(*interfaces.interfaces)
    résultat.nom = nom

    nom_et_indice_parent: NomEtIndice
    nom_et_indice_parent.nom = résultat.nom

    saufsi ensemble_possède(*interfaces.noms_et_indice_parents, nom_et_indice_parent) {
        nom_et_indice_parent.indice = interfaces.interfaces.taille - 1
        ensemble_ajoute(*interfaces.noms_et_indice_parents, nom_et_indice_parent)
    }

    retourne résultat
}

donne_interface :: fonc (interfaces: *Interfaces, nom: chaine) -> *Interface
{
    pour * interfaces.interfaces {
        si it.nom == nom {
            retourne it
        }
    }
    retourne nul
}

détruit_données_interfaces :: fonc (interfaces: *Interfaces)
{
    pour interfaces.nombre_de_types {
        type := *interfaces.types[it]
        déloge(type.types_rubriques_union)
    }

    pour interfaces.interfaces {
        déloge(it.fonctions)
        déloge(it.constructors)
        déloge(it.paramètres)
        déloge(it.attributs)
        déloge(it.mixins)
    }
    déloge_tableau_et_ses_éléments(interfaces.contenus_fichiers)
    déloge(interfaces.interfaces)
    déloge(interfaces.noms_et_indice_parents)
}

ajoute_mixins_aux_interfaces :: fonc (interfaces: *Interfaces)
{
    pour * interfaces.interfaces {
        si it.est_mixin {
            continue
        }

        pour nom_mixin dans it.mixins {
            mixin := interfaces.donne_interface(nom_mixin)
            saufsi mixin {
                message_erreur := imprime_chaine("mixin '%' inconnu pour '%'", nom_mixin, it.nom)
                compilatrice_rapporte_erreur(message_erreur)
            }

            pour attribut dans mixin.attributs {
                tableau_ajoute(*it.attributs, attribut)
            }

            // À FAIRE : fonctions
        }
    }
}

compile_interfaces_idl :: fonc () -> chaine
{
    interfaces: Interfaces
    diffère détruit_données_interfaces(*interfaces)

    /* Interface pour réutiliser la mémoire entre les parsages. */
    enchaineuse: Enchaineuse
    initialise_enchaineuse(*enchaineuse)

    ajoute_au_tampon(*enchaineuse, "importe Chaine\n")
    ajoute_au_tampon(*enchaineuse, "JS :: importe JavaScript\n")

    ajoute_au_tampon(*enchaineuse, "#portée_module\n")

    chemin_fichier := CheminFichier(#chemin_de_ce_fichier)
    chemin_parent := chemin_fichier.chemin_parent()
    diffère détruit_chemin(chemin_parent)
    chemin := crée_chemin_absolu(chemin_parent, CheminFichier("fichiers"))
    diffère détruit_chemin(chemin)

    chemins := donne_fichiers_du_dossier(chemin)
    diffère déloge_tableau_et_ses_éléments(chemins)

    pour chemins {
        chm := CheminFichier(it)
        saufsi chm.extension() == ".idl" {
            continue
        }

        texte := contenu_fichier_texte(chm)
        tableau_ajoute(*interfaces.contenus_fichiers, texte)

        parse_fichier(chm, texte, *interfaces)
    }

    ajoute_mixins_aux_interfaces(*interfaces)

    pour * interfaces.interfaces {
        si it.est_mixin {
            continue
        }

        génère_enveloppes_javascript(*enchaineuse, it)
    }

    source := chaine_depuis_enchaineuse(*enchaineuse)
    ajoute_chaine_au_module(compilatrice_espace_courant(), compilatrice_module_courant(), source)
    déloge(source)

    ajoute_au_tampon(*enchaineuse, "    tas_de_mémoire := JS.donne_tas_de_mémoire(realm)\n\n")

    pour * interfaces.interfaces {
        si it.est_mixin {
            continue
        }
        génère_création_prototype(*enchaineuse, interfaces.interfaces, it, *interfaces.noms_et_indice_parents)
    }

    griffonier: Griffonier
    pour * interfaces.interfaces {
        saufsi it.constructors {
            continue
        }

        ajoute_au_tampon(*enchaineuse, "    ", it.nom, "_constructor := crée_", donne_nom_snake_case(it.nom, *griffonier), "_constructor(realm, ", it.nom, "_prototype)\n")
    }

    ajoute_au_tampon(*enchaineuse, "\n    si __table_indexage_prototypes.taille == 0 {\n")
    ajoute_au_tampon(*enchaineuse, "        tableau_redimensionne(__table_indexage_prototypes, ", interfaces.interfaces.taille, ")\n")
    pour interfaces.interfaces {
        si it.est_mixin {
            continue
        }
        ajoute_au_tampon(*enchaineuse, "        __table_indexage_prototypes[", indice_it, "] = IndicePrototype(", it.nom, ", ", indice_it, ")\n")
    }
    ajoute_au_tampon(*enchaineuse, "    }\n")

    nombres_intrinsèques := interfaces.interfaces.taille;
    pour interfaces.interfaces {
        si it.constructors {
            nombres_intrinsèques += 1
        }
    }

    ajoute_au_tampon(*enchaineuse, "\n    tableau_redimensionne(realm.intrinsics.host_intrinsics, ", nombres_intrinsèques, ")\n")

    pour interfaces.interfaces {
        si it.est_mixin {
            continue
        }
        ajoute_au_tampon(*enchaineuse, "    realm.intrinsics.host_intrinsics[", indice_it, "] = ", it.nom, "_prototype\n")
    }

    indice_intrinsèque := interfaces.interfaces.taille
    pour interfaces.interfaces {
        saufsi it.constructors {
            continue
        }

        ajoute_au_tampon(*enchaineuse, "    realm.intrinsics.host_intrinsics[", indice_intrinsèque, "] = ", it.nom, "_constructor\n")
        indice_intrinsèque += 1
    }

    nombre_de_constructros := indice_intrinsèque - interfaces.interfaces.taille
    indice_intrinsèque = interfaces.interfaces.taille

    ajoute_au_tampon(*enchaineuse, "    si __table_constructors.taille == 0 {\n")
    ajoute_au_tampon(*enchaineuse, "        tableau_redimensionne(__table_constructors, ", nombre_de_constructros, ")\n")
    indice_constructor := 0
    pour interfaces.interfaces {
        saufsi it.constructors {
            continue
        }

        ajoute_au_tampon(*enchaineuse, "        __table_constructors[", indice_constructor, "] = InfoConstructor(", indice_intrinsèque, ", crée_chaine_utf16_unique(\"", it.nom, "\"))\n")
        indice_intrinsèque += 1
    }
    ajoute_au_tampon(*enchaineuse, "    }\n")

    retourne chaine_depuis_enchaineuse(*enchaineuse)
}

#portée_fichier

génère_création_prototype :: fonc (enchaineuse: *Enchaineuse, interfaces: []Interface, interface: *Interface, noms_et_indice_parents: *[..]NomEtIndice)
{
    si interface.création_générée {
        retourne
    }

    interface.création_générée = vrai

    si interface.parent {
        nom_et_indice_parent: NomEtIndice
        nom_et_indice_parent.nom = interface.parent

        adresse_nom_et_indice_parent := ensemble_possède_retourne_indice(noms_et_indice_parents, nom_et_indice_parent)
        assert(adresse_nom_et_indice_parent != -1)

        parent := *interfaces[noms_et_indice_parents.pointeur[adresse_nom_et_indice_parent].indice]

        génère_création_prototype(enchaineuse, interfaces, parent, noms_et_indice_parents)
    }

    ajoute_au_tampon(enchaineuse, "    ", interface.nom, "_prototype := crée_prototype_", interface.nom, "(tas_de_mémoire, ")
    si interface.parent {
        ajoute_au_tampon(enchaineuse, interface.parent, "_prototype)\n")
    }
    sinon {
        ajoute_au_tampon(enchaineuse, "realm.intrinsics.object_prototype)\n")
    }
}

Type :: struct {
    nom: chaine
    nulifiable: bool
    est_union: bool
    est_énum: bool
    types_rubriques_union: [..]*Type
}

Attribut :: struct {
    type: *Type
    nom: chaine
    lecture_seule: bool
    reflect: bool
    est_rubrique: bool
    est_idl_event_handler: bool
    /* 'nom' de [Reflect=nom] */
    attribut_réfléchis: chaine
}

Paramètre :: struct {
    nom: chaine
    type: *Type
}

Fonction :: struct {
    type_retour: *Type
    nom: chaine

    premier_paramètre: z64
    dernier_paramètre: z64

    /* Voir indice properties et named properties https://webidl.spec.whatwg.org/#dfn-supported-property-indices */
    est_getter := faux
    est_setter := faux
}

Interface :: struct {
    nom: chaine
    parent: chaine
    paramètres: [..]Paramètre
    attributs: [..]Attribut
    fonctions: [..]Fonction
    constructors: [..]Fonction
    mixins: [..]chaine

    création_générée := faux
    /* vrai si nom == "Window" pour éviter de faire trop de comparaisons de chaines. */
    est_window := faux
    est_mixin := faux
}

donne_paramètres :: fonc (interface: *Interface, fonction: *Fonction) -> []Paramètre
{
    résultat: []Paramètre
    résultat.pointeur = interface.paramètres.pointeur + fonction.premier_paramètre
    résultat.taille = fonction.dernier_paramètre - fonction.premier_paramètre
    retourne résultat
}

imprime_interface :: fonc (interface: *Interface)
{
    imprime("interface % ", interface.nom)
    si interface.parent {
        imprime(": % ", interface.parent)
    }
    imprime("{\n")

    pour interface.fonctions {
        imprime("    ")
        imprime_type(*it.type_retour)
        imprime(" %", it.nom)

        virgule := "("

        pour param dans it.paramètres {
            imprime("%", virgule)
            imprime_type(*param.type)
            imprime(" %", param.nom)
            virgule = ", "
        }

        imprime(");\n")
    }

    imprime("\n")

    pour interface.attributs {
        imprime("    ")
        si it.lecture_seule {
            imprime("readonly ")
        }
        imprime("attribute ")
        imprime_type(it.type)
        imprime(" %", it.nom)
        imprime(";\n")
    }

    imprime("}\n")
}

génère_enveloppes_javascript :: fonc (enchaineuse: *Enchaineuse, interface: *Interface)
{
    griffonier: Griffonier

    interface.est_window = interface.nom == "Window"

    pour * interface.fonctions {
        génère_enveloppe_javascript(enchaineuse, interface, it, *griffonier)
    }

    génère_constructor(enchaineuse, interface, *griffonier)

    pour * interface.attributs {
        génère_enveloppe_javascript_getter(enchaineuse, interface, it, *griffonier)

        saufsi it.lecture_seule {
            génère_enveloppe_javascript_setter(enchaineuse, interface, it, *griffonier)
        }
    }

    génère_création_prototype(enchaineuse, interface)
}

génère_création_prototype :: fonc (enchaineuse: *Enchaineuse, interface: *Interface)
{
    ajoute_au_tampon(enchaineuse, "crée_prototype_", interface.nom, " :: fonc (tas_de_mémoire: *JS.TasDeMémoire, prototype: *JS.Object) -> *JS.Object\n")
    ajoute_au_tampon(enchaineuse, "{\n")

    ajoute_au_tampon(enchaineuse, "    résultat := JS.crée_objet(tas_de_mémoire, prototype)\n")

    pour * interface.fonctions {
        ajoute_au_tampon(enchaineuse, "    JS.ajoute_fonction_native(résultat, \"", it.nom, "\", ", interface.nom, "_", it.nom, ")\n")
    }

    pour * interface.attributs {
        ajoute_au_tampon(enchaineuse, "    JS.ajoute_propriété(résultat, crée_chaine_utf16_unique(\"", it.nom, "\"), ")
        ajoute_au_tampon(enchaineuse, "get_", interface.nom, "_", it.nom, ", ")
        si it.lecture_seule {
            ajoute_au_tampon(enchaineuse, "nul, ")
        }
        sinon {
            ajoute_au_tampon(enchaineuse, "set_", interface.nom, "_", it.nom, ", ")
        }
        ajoute_au_tampon(enchaineuse, "JS.DrapeauxPropriété.zéro)\n")
    }
    
    ajoute_au_tampon(enchaineuse, "    retourne résultat\n")
    ajoute_au_tampon(enchaineuse, "}\n")
}

génère_enveloppe_javascript :: fonc (enchaineuse: *Enchaineuse, interface: *Interface, fonction: *Fonction, griffonier: *Griffonier)
{
    paramètres := interface.donne_paramètres(fonction)

    ajoute_au_tampon(enchaineuse, interface.nom, "_", fonction.nom, " :: fonc (empl params: *JS.ParamètresObjectCall) -> JS.Valeur\n")
    ajoute_au_tampon(enchaineuse, "{\n")

    génère_code_conversion_this(enchaineuse, interface)

    type_union: *Type
    nom_param_union: chaine

    pour paramètres {
        si it.type.est_union {
            nom_param_union = it.nom
            type_union = it.type
            arrête
        }
    }

    pour paramètres {
        ajoute_au_tampon(enchaineuse, "    valeur_", it.nom, " := JS.donne_argument(params, ", indice_it, ")\n")
    }

    si type_union {
        pour type_union.types_rubriques_union {
            ajoute_au_tampon(enchaineuse, "si ")
            génère_comparaison_type_pour_rubrique_union(enchaineuse, nom_param_union, it)
            ajoute_au_tampon(enchaineuse, " {\n")
            génère_appel_fonction(enchaineuse, fonction, paramètres, indice_it, griffonier)
            ajoute_au_tampon(enchaineuse, "}\n")
        }
        ajoute_au_tampon(enchaineuse, "    retourne JS.lance_type_error(interpréteuse, \"Invalid type for argument ", nom_param_union, "\")\n")
    }
    sinon {
        génère_appel_fonction(enchaineuse, fonction, paramètres, -1, griffonier)
    }

    ajoute_au_tampon(enchaineuse, "}\n")
}
 
génère_appel_fonction :: fonc (enchaineuse: *Enchaineuse, fonction: *Fonction, paramètres: []Paramètre, indice_rubrique_union: z64, griffonier: *Griffonier)
{
    // Conversion des paramètres
    pour paramètres {
        type := it.type
        si type.est_union {
            type = type.types_rubriques_union[indice_rubrique_union]
        }

        génère_code_conversion_argument(enchaineuse, it.nom, indice_it, type)
    }

    // Appel de la fonction.
    ajoute_au_tampon(enchaineuse, "    ")
    si fonction.type_retour.nom != "undefined" {
        ajoute_au_tampon(enchaineuse, "résultat := ")
    }

    préfixe := ""
    si fonction.est_getter {
        préfixe = "donne_"
    }
    sinon si fonction.est_setter {
        préfixe = "définis_"
    }

    ajoute_au_tampon(enchaineuse, préfixe, donne_nom_snake_case(fonction.nom, griffonier))

    virgule := "(object_this, "
    si paramètres.taille == 0 {
        ajoute_au_tampon(enchaineuse, "(object_this")
    }
    sinon pour paramètres {
        ajoute_au_tampon(enchaineuse, virgule, it.nom)
        virgule = ", "
    }
    ajoute_au_tampon(enchaineuse, ")\n")

    génère_code_conversion_résultat(enchaineuse, fonction.type_retour)
}

génère_comparaison_type_pour_rubrique_union :: fonc (enchaineuse: *Enchaineuse, nom: chaine, type: *Type)
{
    si type.nom == "DOMString" || type.nom == "USVString" {
        ajoute_au_tampon(enchaineuse, "JS.est_chaine(valeur_", nom, ")")
    }
    sinon si type.nom == "ArrayBuffer" {
        ajoute_au_tampon(enchaineuse, "JS.est_object(valeur_", nom, ") && JS.donne_objet(valeur_", nom, ").table.classe == JS.", type.nom)
    }
    sinon {
        ajoute_au_tampon(enchaineuse, "JS.est_object(valeur_", nom, ") && JS.donne_objet(valeur_", nom, ").table.classe == ", type.nom)
    }
}

génère_constructor :: fonc (enchaineuse: *Enchaineuse, interface: *Interface, griffonier: *Griffonier)
{
    saufsi interface.constructors {
        retourne
    }

chaine_déclaration_constructor := «
\\(0)Constructor :: struct {
    empl builtin_function: JS.BuiltInFunction
    table = *table_virtuelle_\\(1)_constructor

    sur_call_or_construct = \\(1)_call_or_construct
}

crée_\\(1)_constructor :: fonc (realm: *JS.Realm, prototype: *JS.Object) -> *\\(0)Constructor
{
    // assert(prototype == realm.intrinsics.\\(1)_prototype)
    tas_de_mémoire := JS.donne_tas_de_mémoire(realm)
    résultat := JS.alloue(tas_de_mémoire, \\(0)Constructor)

    STR_\\(0) := crée_chaine_utf16_unique("\\(0)")

    JS.create_builtin_function(résultat, 1, STR_\\(0), realm, realm.intrinsics.function_prototype)

    JS.ajoute_propriété(résultat, JS.STR_prototype, JS.Valeur(Object = prototype), JS.DrapeauxPropriété.zéro)

    JS.ajoute_propriété(prototype, JS.STR_constructor, JS.Valeur(Object = résultat), JS.DrapeauxPropriété.zéro)

    retourne résultat
}

#portée_fichier

table_virtuelle_\\(1)_constructor := JS.TableVirtuelleBuiltinFunction(classe = \\(0)Constructor)

\\(1)_call_or_construct :: fonc (params: *JS.ParamètresCallOrConstruct) -> JS.Valeur
{
    realm := JS.donne_realm(params.interpréteuse)

    si JS.est_undefined(params.new_target) {
        retourne JS.lance_type_error(params.interpréteuse, "missing 'new' to construct \\(0)")
    }

    object_this := crée_platform_object(JS.donne_tas_de_mémoire(realm), realm, \\(0));
    interpréteuse := params.interpréteuse
»

    chaine_fin_constructor := «
}

#portée_export
»

    nom_snake_case := donne_nom_snake_case(interface.nom, griffonier)
    fmt_imprime_dans_enchaineuse(enchaineuse, chaine_déclaration_constructor, interface.nom, nom_snake_case)

    /* À FAIRE : plusieurs constructeurs */
    constructor := *interface.constructors[0]

    // Conversion des paramètres
    paramètres := interface.donne_paramètres(constructor)
    pour paramètres {
        ajoute_au_tampon(enchaineuse, "    valeur_", it.nom, " := JS.donne_argument(params, ", indice_it, ")\n")
        génère_code_conversion_argument(enchaineuse, it.nom, indice_it, it.type)
    }

    ajoute_au_tampon(enchaineuse, "    retourne ", nom_snake_case, "_construct")

    virgule := "(params.interpréteuse, object_this, "
    si paramètres.taille == 0 {
        ajoute_au_tampon(enchaineuse, "(params.interpréteuse, object_this")
    }
    sinon pour paramètres {
        ajoute_au_tampon(enchaineuse, virgule, it.nom)
        virgule = ", "
    }
    ajoute_au_tampon(enchaineuse, ")")

    fmt_imprime_dans_enchaineuse(enchaineuse, chaine_fin_constructor, interface.nom, nom_snake_case)
}

génère_enveloppe_javascript_getter :: fonc (enchaineuse: *Enchaineuse, interface: *Interface, attribut: *Attribut, griffonier: *Griffonier)
{
    nom_snake_case := donne_nom_snake_case(attribut.nom, griffonier)

    ajoute_au_tampon(enchaineuse, "get_", interface.nom, "_", attribut.nom, " :: fonc (empl params: *JS.ParamètresObjectCall) -> JS.Valeur\n")
    ajoute_au_tampon(enchaineuse, "{\n")

    génère_code_conversion_this(enchaineuse, interface)

    // Appel de la fonction
    si attribut.reflect {
        attribut_réfléchis := nom_snake_case
        si attribut.attribut_réfléchis {
            attribut_réfléchis = donne_nom_snake_case(attribut.attribut_réfléchis, griffonier)
        }
        ajoute_au_tampon(enchaineuse, "    résultat := get_an_attribute_value(object_this, ATTR_", attribut_réfléchis, ")\n")
    }
    sinon si attribut.est_rubrique {
        ajoute_au_tampon(enchaineuse, "    résultat := object_this.", nom_snake_case, "\n")
    }
    sinon si attribut.est_idl_event_handler {
        ajoute_au_tampon(enchaineuse, "    résultat := get_event_handler_idl_attribute(object_this, EVT_", attribut.nom, ");\n")
    }
    sinon {
        ajoute_au_tampon(enchaineuse, "    résultat := donne_", nom_snake_case, "(object_this)\n")
    }

    génère_code_conversion_résultat(enchaineuse, attribut.type)

    ajoute_au_tampon(enchaineuse, "}\n")
}

génère_enveloppe_javascript_setter :: fonc (enchaineuse: *Enchaineuse, interface: *Interface, attribut: *Attribut, griffonier: *Griffonier)
{
    nom_snake_case := donne_nom_snake_case(attribut.nom, griffonier)

    ajoute_au_tampon(enchaineuse, "set_", interface.nom, "_", attribut.nom, " :: fonc (empl params: *JS.ParamètresObjectCall) -> JS.Valeur\n")
    ajoute_au_tampon(enchaineuse, "{\n")

    génère_code_conversion_this(enchaineuse, interface)

    ajoute_au_tampon(enchaineuse, "    valeur_", attribut.nom, " := JS.donne_argument(params, ", 0, ")\n")

    génère_code_conversion_argument(enchaineuse, attribut.nom, 0, attribut.type)

    // Appel de la fonction
    si attribut.reflect {
        attribut_réfléchis := nom_snake_case
        si attribut.attribut_réfléchis {
            attribut_réfléchis = donne_nom_snake_case(attribut.attribut_réfléchis, griffonier)
        }
        ajoute_au_tampon(enchaineuse, "    set_an_attribute_value(object_this, ATTR_", attribut_réfléchis, ", ", attribut.nom, ")\n")
    }
    sinon si attribut.est_rubrique {
        ajoute_au_tampon(enchaineuse, "    object_this.", nom_snake_case, " =", attribut.nom, "\n")
    }
    sinon si attribut.est_idl_event_handler {
        ajoute_au_tampon(enchaineuse, "    set_event_handler_idl_attribute(object_this, EVT_", attribut.nom, ", ", attribut.nom, ");\n")
    }
    sinon {
        ajoute_au_tampon(enchaineuse, "    définis_", nom_snake_case, "(object_this, ", attribut.nom, ")\n")
    }

    ajoute_au_tampon(enchaineuse, "    retourne JS.js_undefined\n")
    ajoute_au_tampon(enchaineuse, "}\n")
}

génère_code_conversion_this :: fonc (enchaineuse: *Enchaineuse, interface: *Interface)
{
    si interface.est_window {
        /* Puisque Window est l'objet global, si this est undefined, nous utilisons l'objet global du realm courant. */
        ajoute_au_tampon(enchaineuse, "    si JS.est_undefined(this_value) {\n")
        ajoute_au_tampon(enchaineuse, "        realm := JS.donne_realm(interpréteuse)\n")
        ajoute_au_tampon(enchaineuse, "        this_value.Object = realm.global_object\n")
        ajoute_au_tampon(enchaineuse, "    }\n")
    }

    ajoute_au_tampon(enchaineuse, "    object_this := donne_platform_object(interpréteuse, this_value, ", interface.nom, ")\n")
    ajoute_au_tampon(enchaineuse, "    si JS.possède_exception(interpréteuse) {\n        retourne JS.js_undefined;\n    }\n")
}

génère_code_conversion_argument :: fonc (enchaineuse: *Enchaineuse, nom: chaine, indice: z64, type: *Type)
{
    si type.est_énum {
        ajoute_au_tampon(enchaineuse, "    saufsi JS.est_chaine(valeur_", nom, ") {\n        retourne JS.lance_type_error(interpréteuse,  \"argument is not a string\");\n    }\n")
        ajoute_au_tampon(enchaineuse, "    str := valeur_", nom, ".String.texte\n")
        ajoute_au_tampon(enchaineuse, "    str_native := converti_vers_chaine(str.donne_chaine_utf16())\n")
        ajoute_au_tampon(enchaineuse, "    diffère déloge(str_native)\n")
        ajoute_au_tampon(enchaineuse, "    valeur_énum, trouvée := donne_valeur_énum_pour_nom(info_de(", type.nom, "), str_native)\n")
        ajoute_au_tampon(enchaineuse, "    saufsi trouvée { retourne JS.lance_type_error(interpréteuse, \"invalid value\") }\n")
        ajoute_au_tampon(enchaineuse, "    ", nom, " := valeur_énum comme ", type.nom, "\n")
    }
    sinon si type.nom == "any" {
        ajoute_au_tampon(enchaineuse, "    ", nom, " := valeur_", nom, "\n")
    }
    sinon si type.nom == "DOMString" || type.nom == "USVString" {
        ajoute_au_tampon(enchaineuse, "    S_", nom, " := JS.to_string(interpréteuse, valeur_", nom, ")\n")
        ajoute_au_tampon(enchaineuse, "    si JS.possède_exception(interpréteuse) {\n        retourne JS.js_undefined;\n    }\n")
        ajoute_au_tampon(enchaineuse, "    ", nom, " := S_", nom, ".texte\n")
    }
    sinon si type.nom == "unsigned long" {
        ajoute_au_tampon(enchaineuse, "    ", nom, "_ul := convert_to_int(interpréteuse, valeur_", nom, ", 32, Signedness.Unsigned)\n")
        ajoute_au_tampon(enchaineuse, "    si JS.possède_exception(interpréteuse) {\n        retourne JS.js_undefined;\n    }\n")
        ajoute_au_tampon(enchaineuse, "    ", nom, " := ", nom, "_ul.Number comme n32\n")
    }
    sinon si type.nom == "long" {
        ajoute_au_tampon(enchaineuse, "    ", nom, "_l := convert_to_int(interpréteuse, valeur_", nom, ", 32, Signedness.Signed)\n")
        ajoute_au_tampon(enchaineuse, "    si JS.possède_exception(interpréteuse) {\n        retourne JS.js_undefined;\n    }\n")
        ajoute_au_tampon(enchaineuse, "    ", nom, " := ", nom, "_l.Number comme z32\n")
    }
    sinon si type.nom == "double" || type.nom == "unrestricted double" {
        ajoute_au_tampon(enchaineuse, "    ", nom, " := JS.to_number(interpréteuse, valeur_", nom, ")\n")
        ajoute_au_tampon(enchaineuse, "    si JS.possède_exception(interpréteuse) {\n        retourne JS.js_undefined;\n    }\n")
    }
    sinon si type.nom == "boolean" {
        ajoute_au_tampon(enchaineuse, "    ", nom, " := JS.to_boolean(valeur_", nom, ")\n")
    }
    sinon si type.nom == "EventListener" {
        ajoute_au_tampon(enchaineuse, "    saufsi JS.est_object(valeur_", nom, ") {\n")
        ajoute_au_tampon(enchaineuse, "        retourne JS.lance_type_error(interpréteuse, \"argument ", indice, " is not callable\")\n")
        ajoute_au_tampon(enchaineuse, "    }\n")
        ajoute_au_tampon(enchaineuse, "    ", nom, ":= crée_event_listener(JS.donne_objet(valeur_", nom, "))\n")
    }
    sinon si type.nom == "EventHandler" {
        ajoute_au_tampon(enchaineuse, "    saufsi JS.est_object(valeur_", nom, ") {\n")
        ajoute_au_tampon(enchaineuse, "        retourne JS.lance_type_error(interpréteuse, \"argument ", indice, " is not callable\")\n")
        ajoute_au_tampon(enchaineuse, "    }\n")
        ajoute_au_tampon(enchaineuse, "    ", nom, ":= crée_event_handler(JS.donne_objet(valeur_", nom, "))\n")
    }
    sinon si type.nom == "Function" {
        indentation := ""
        si type.nulifiable {
            ajoute_au_tampon(enchaineuse, "    saufsi JS.est_nulle(valeur_", nom, ") {\n")
            indentation = "    "
        }

        ajoute_au_tampon(enchaineuse, indentation, "    saufsi JS.is_callable(valeur_", nom, ") {\n")
        ajoute_au_tampon(enchaineuse, indentation, "        retourne JS.lance_type_error(interpréteuse, \"argument ", indice, " is not callable\")\n")
        ajoute_au_tampon(enchaineuse, indentation, "    }\n")
        ajoute_au_tampon(enchaineuse, indentation, "    ", nom, " := JS.donne_objet(valeur_", nom, ")\n")

        si type.nulifiable {
            ajoute_au_tampon(enchaineuse, "    }\n")
        }
    }
    sinon si type.nom == "ArrayBuffer" {
        ajoute_au_tampon(enchaineuse, "    ", nom, " := JS.to_array_buffer(interpréteuse, valeur_", nom, ")\n")
        ajoute_au_tampon(enchaineuse, "    si JS.possède_exception(interpréteuse) {\n        retourne JS.js_undefined;\n    }\n")
    }
    sinon {
        ajoute_au_tampon(enchaineuse, "    ", nom, " := donne_platform_object(interpréteuse, valeur_", nom, ", ", type.nom, ")\n")
        ajoute_au_tampon(enchaineuse, "    si JS.possède_exception(interpréteuse) {\n        retourne JS.js_undefined;\n    }\n")
    }
}

génère_code_conversion_résultat :: fonc (enchaineuse: *Enchaineuse, type: *Type)
{
    si type.est_énum {
        ajoute_au_tampon(enchaineuse, "    str_native := donne_nom_énum_pour_valeur(résultat)\n")
        ajoute_au_tampon(enchaineuse, "    str_unique := crée_chaine_utf16_unique(str_native)\n")
        ajoute_au_tampon(enchaineuse, "    retourne JS.crée_chaine(JS.donne_realm(interpréteuse), str_unique)\n")
    }
    sinon si type.nom == "any" {
        ajoute_au_tampon(enchaineuse, "    retourne résultat\n")
    }
    sinon si type.nom == "undefined" {
        ajoute_au_tampon(enchaineuse, "    retourne JS.js_undefined\n")
    }
    sinon si type.nom == "DOMString" || type.nom == "USVString" {
        ajoute_au_tampon(enchaineuse, "    str_unique: ChaineUTF16Unique\n")
        ajoute_au_tampon(enchaineuse, "    #si type_de(résultat) != type_de(ChaineUTF16Unique) {\n")
        ajoute_au_tampon(enchaineuse, "        str_unique = crée_chaine_utf16_unique(résultat)\n")
        ajoute_au_tampon(enchaineuse, "    }\n")
        ajoute_au_tampon(enchaineuse, "    sinon {\n")
        ajoute_au_tampon(enchaineuse, "        str_unique = résultat\n")
        ajoute_au_tampon(enchaineuse, "    }\n")
        ajoute_au_tampon(enchaineuse, "    retourne JS.crée_chaine(JS.donne_realm(interpréteuse), str_unique)\n")
    }
    sinon si type.nom == "unsigned long" || type.nom == "long" {
        ajoute_au_tampon(enchaineuse, "    retourne résultat comme r64\n")
    }
    sinon si type.nom == "double" || type.nom == "unrestricted double" {
        ajoute_au_tampon(enchaineuse, "    retourne résultat\n")
    }
    sinon si type.nom == "boolean" {
        ajoute_au_tampon(enchaineuse, "    retourne résultat\n")
    }
    sinon si type.nom == "EventHandler" {
        si type.nulifiable {
            ajoute_au_tampon(enchaineuse, "    saufsi résultat {\n")
            ajoute_au_tampon(enchaineuse, "        retourne JS.js_null\n")
            ajoute_au_tampon(enchaineuse, "    }\n")
        }

        ajoute_au_tampon(enchaineuse, "    retourne résultat.object\n")
    }
    sinon {
        si type.nulifiable {
            ajoute_au_tampon(enchaineuse, "    saufsi résultat {\n")
            ajoute_au_tampon(enchaineuse, "        retourne JS.js_null\n")
            ajoute_au_tampon(enchaineuse, "    }\n")
        }

        ajoute_au_tampon(enchaineuse, "    retourne résultat\n")
    }
}

imprime_type :: fonc (type: *Type)
{
    imprime("%", type.nom)
    si type.nulifiable {
        imprime("?")
    }
}

parse_fichier :: fonc (chemin: CheminFichier, texte: chaine, interfaces: *Interfaces)
{
    parseuse := crée_parseuse(chemin, texte)
    parseuse.interfaces = interfaces

    tantque parseuse.début < parseuse.fin {
        lexème := donne_lexème_suivant(*parseuse)

        si parseuse.début >= parseuse.fin {
            arrête
        }

        si lexème == "interface" {
            parse_interface(*parseuse, interfaces)
            continue
        }

        si lexème == "enum" {
            parse_énum(*parseuse)
            continue
        }

        interface := donne_interface(interfaces, lexème)
        si interface {
            lexème = donne_lexème_suivant(*parseuse)
            si lexème != "includes" {
                rapporte_erreur(*parseuse, "attendu 'includes'", lexème)
            }

            lexème = donne_lexème_suivant(*parseuse)
            tableau_ajoute(*interface.mixins, lexème)

            consomme_point_virgule(*parseuse)
            continue
        }

        rapporte_erreur(*parseuse, "lexème inattendu", lexème)
    }
}

parse_interface :: fonc (parseuse: *ParseuseInterface, interfaces: *Interfaces)
{
    lexème := donne_lexème_suivant(parseuse)

    est_mixin := faux
    si lexème == "mixin" {
        est_mixin = vrai
        lexème = donne_lexème_suivant(parseuse)
    }

    résultat := interfaces.crée_interface(lexème)
    résultat.est_mixin = est_mixin

    si consomme_caractère(parseuse, ':') {
        résultat.parent = donne_lexème_suivant(parseuse)
    }

    saufsi consomme_caractère(parseuse, '{') {
        rapporte_erreur(parseuse, "attendu '{'", donne_lexème_suivant(parseuse))
    }

    tantque parseuse.début < parseuse.fin {
        si consomme_caractère(parseuse, '}') {
            saufsi consomme_caractère(parseuse, ';') {
                rapporte_erreur(parseuse, "attendu ';'", parseuse.donne_lexème_suivant())
            }
            arrête
        }

        si apparie(parseuse, '[') || apparie(parseuse, "readonly") || apparie(parseuse, "attribute") {
            parse_un_attribut(parseuse, résultat)
        }
        sinon {
            parse_une_fonction(parseuse, résultat)
        }
    }
}

parse_une_fonction :: fonc (parseuse: *ParseuseInterface, interface: *Interface)
{
    résultat: Fonction

    si parseuse.apparie("getter") {
        résultat.est_getter = vrai
        _ := donne_lexème_suivant(parseuse)
    }
    sinon si parseuse.apparie("setter") {
        _ := donne_lexème_suivant(parseuse)
    }

    est_constructor := faux
    si parseuse.apparie("constructor") {
        est_constructor = vrai
        _ := parseuse.donne_lexème_suivant()
    }
    sinon {
        résultat.type_retour = parse_type(parseuse)
        résultat.nom = donne_lexème_suivant(parseuse)
        résultat.premier_paramètre = interface.paramètres.taille
    }

    saufsi consomme_caractère(parseuse, '(') {
        rapporte_erreur(parseuse, "attendu '('", donne_lexème_suivant(parseuse))
    }

    boucle {
        si consomme_caractère(parseuse, ')') {
            arrête
        }

        paramètre: Paramètre
        paramètre.type = parse_type(parseuse)
        paramètre.nom = donne_lexème_suivant(parseuse)

        tableau_ajoute(*interface.paramètres, paramètre)

        si consomme_caractère(parseuse, ',') {
            continue
        }

        saufsi consomme_caractère(parseuse, ')') {
            rapporte_erreur(parseuse, "attendu ')", donne_lexème_suivant(parseuse))
        }

        arrête
    }

    résultat.dernier_paramètre = interface.paramètres.taille

    si est_constructor {
        tableau_ajoute(*interface.constructors, résultat)
    }
    sinon {
        tableau_ajoute(*interface.fonctions, résultat)
    }

    consomme_point_virgule(parseuse)
}

parse_un_attribut :: fonc (parseuse: *ParseuseInterface, interface: *Interface)
{
    résultat: Attribut

    si parseuse.consomme_caractère('[') {
        lexème := donne_lexème_suivant(parseuse)
        si lexème == "Reflect" {
            résultat.reflect = vrai
        }
        sinon si lexème == "Member" {
            résultat.est_rubrique = vrai
        }
        sinon si lexème == "IDLEventHandler" {
            résultat.est_idl_event_handler = vrai
        }
        sinon {
            rapporte_erreur(parseuse, "attribut inconnu", lexème)
        }

        si parseuse.consomme_caractère('=') {
            résultat.attribut_réfléchis = parseuse.donne_lexème_suivant()
        }

        saufsi parseuse.consomme_caractère(']') {
            rapporte_erreur(parseuse, "attendu ']'", parseuse.donne_lexème_suivant())
        }
    }

    lexème := donne_lexème_suivant(parseuse)
    si lexème == "readonly" {
        résultat.lecture_seule = vrai
        lexème = donne_lexème_suivant(parseuse)
    }

    saufsi lexème == "attribute" {
        rapporte_erreur(parseuse, "attendu 'attribute'", lexème)
    }

    résultat.type = parse_type(parseuse)

    lexème = donne_lexème_suivant(parseuse)

    résultat.nom = lexème

    tableau_ajoute(*interface.attributs, résultat)

    consomme_point_virgule(parseuse)
}

parse_énum :: fonc (parseuse: *ParseuseInterface)
{
    nom := donne_lexème_suivant(parseuse)
    type := trouve_ou_ajoute_type(parseuse.interfaces, nom, faux)
    type.est_énum = vrai

    saufsi consomme_caractère(parseuse, '{') {
        rapporte_erreur(parseuse, "attendu '{'")
    }

    tantque parseuse.début < parseuse.fin {
        saufsi consomme_caractère(parseuse, '"') {
            rapporte_erreur(parseuse, "attendu '\"'")
        }

        /* Nous utilisons les InfoTypes du langage pour ça. */
        _ := parseuse.donne_lexème_suivant()

        saufsi consomme_caractère(parseuse, '"') {
            rapporte_erreur(parseuse, "attendu '\"'")
        }

        saufsi consomme_caractère(parseuse, ',') {
            arrête
        }
    }

    saufsi consomme_caractère(parseuse, '}') {
        rapporte_erreur(parseuse, "attendu '}'")
    }

    saufsi consomme_caractère(parseuse, ';') {
        rapporte_erreur(parseuse, "attendu ';'")
    }
}

rapporte_erreur :: fonc (parseuse: *ParseuseInterface, message: chaine)
{
    rapporte_erreur(parseuse, message, donne_lexème_suivant(parseuse))
}

rapporte_erreur :: fonc (parseuse: *ParseuseInterface, message: chaine, lexème_obtenu: chaine)
{
    message_erreur := imprime_chaine("%, obtenu '%'\n", message, lexème_obtenu)
    info := donne_info_erreur_pour_lexème(parseuse, lexème_obtenu)
    espace := compilatrice_espace_courant()
    compilatrice_rapporte_erreur_externe(espace, message_erreur, parseuse.chemin.chn, info.texte_ligne, info.numéro_ligne, info.indice_colonne, info.indice_colonne_début, info.indice_colonne_fin)
}

InfoErreur :: struct {
    texte_ligne := ""
    numéro_ligne := 0
    indice_colonne := -1
    indice_colonne_début := -1
    indice_colonne_fin := -1
}

donne_info_erreur_pour_lexème :: fonc (parseuse: *ParseuseInterface, lexème: chaine) -> InfoErreur
{
    résultat: InfoErreur
    résultat.numéro_ligne = 1

    début_texte := parseuse.texte.pointeur
    fin_texte := parseuse.texte.pointeur + parseuse.texte.taille
    début_lexème := lexème.pointeur

    it := début_texte
    pos_dernière_ligne := début_texte
    tantque it < début_lexème {
        si mémoire(it) == '\n' {
            résultat.numéro_ligne += 1
            pos_dernière_ligne = it + 1
        }
        it += 1
    }

    it = début_lexème
    tantque it < fin_texte {
        si mémoire(it) == '\n' {
            arrête
        }
        it += 1
    }

    résultat.texte_ligne = chaine(pos_dernière_ligne, it - pos_dernière_ligne)
    résultat.indice_colonne = (début_lexème - pos_dernière_ligne) comme z32
    résultat.indice_colonne_début = résultat.indice_colonne
    résultat.indice_colonne_fin = résultat.indice_colonne + lexème.taille comme z32

    retourne résultat
}

ParseuseInterface :: struct {
    début: *z8
    fin: *z8
    chemin: CheminFichier
    texte: chaine
    interfaces: *Interfaces
}

crée_parseuse :: fonc (chemin: CheminFichier, texte: chaine) -> ParseuseInterface
{
    résultat : ParseuseInterface = ---
    résultat.début = texte.pointeur
    résultat.fin = texte.pointeur + texte.taille
    résultat.chemin = chemin
    résultat.texte = texte
    retourne résultat
}

apparie :: fonc (parseuse: *ParseuseInterface, texte: chaine) -> bool
{
    consomme_espaces_blanches(parseuse)
    si parseuse.début >= parseuse.fin {
        retourne faux
    }

    taille := parseuse.fin - parseuse.début
    si taille < texte.taille {
        retourne faux
    }

    chn := chaine(parseuse.début, texte.taille)
    retourne chn == texte
}

apparie :: fonc (parseuse: *ParseuseInterface, c: z8) -> bool
{
    consomme_espaces_blanches(parseuse)
    si parseuse.début >= parseuse.fin {
        retourne faux
    }
    retourne mémoire(parseuse.début) == c
}

parse_type :: fonc (parseuse: *ParseuseInterface) -> *Type
{
    si parseuse.consomme_caractère('(') {
        retourne parse_type_union(parseuse)
    }

    retourne parse_type_simple(parseuse)
}

parse_type_union :: fonc (parseuse: *ParseuseInterface) -> *Type
{
    résultat := ajoute_type(parseuse.interfaces)
    résultat.est_union = vrai

    tantque parseuse.début < parseuse.fin {
        si parseuse.consomme_caractère(')') {
            arrête
        }

        type := parse_type_simple(parseuse)
        tableau_ajoute(*résultat.types_rubriques_union, type)

        parseuse.consomme_espaces_blanches()

        si parseuse.apparie("or") {
            _ := donne_lexème_suivant(parseuse)
            parseuse.consomme_espaces_blanches()
            continue
        }

        saufsi parseuse.consomme_caractère(')') {
            rapporte_erreur(parseuse, "attendu ')", parseuse.donne_lexème_suivant())
        }

        arrête
    }

    retourne résultat
}

parse_type_simple :: fonc (parseuse: *ParseuseInterface) -> *Type
{
    nom_type := donne_lexème_suivant(parseuse)

    si nom_type == "unsigned" {
        nom_mot := donne_lexème_suivant(parseuse)

        si nom_mot == "long" {
            nom_type = "unsigned long"
        }
        sinon {
            rapporte_erreur(parseuse, "attendu 'long'", nom_mot)
        }
    }
    sinon si nom_type == "unrestricted" {
        nom_mot := donne_lexème_suivant(parseuse)

        si nom_mot == "double" {
            nom_type = "unrestricted double"
        }
        sinon {
            rapporte_erreur(parseuse, "attendu 'double'", nom_mot)
        }
    }

    nulifiable := consomme_caractère(parseuse, '?')
    retourne trouve_ou_ajoute_type(parseuse.interfaces, nom_type, nulifiable)
}

donne_lexème_suivant :: fonc (parseuse: *ParseuseInterface) -> chaine
{
    consomme_espaces_blanches(parseuse)

    si parseuse.début >= parseuse.fin {
        retourne ""
    }

    résultat := chaine(parseuse.début, 0)

    tantque parseuse.début < parseuse.fin {
        c := mémoire(parseuse.début)
        si ('a' <= c <= 'z') || ('A' <= c <= 'Z') || ('0' <= c <= '9') {
            parseuse.début += 1
            résultat.taille += 1
            continue
        }

        arrête
    }

    retourne résultat
}

consomme_caractère :: fonc (parseuse: *ParseuseInterface, c: z8) -> bool
{
    consomme_espaces_blanches(parseuse)
    si parseuse.début >= parseuse.fin {
        retourne faux
    }

    caractère := mémoire(parseuse.début)
    si c != caractère {
        retourne faux
    }

    parseuse.début += 1
    retourne vrai
}

consomme_point_virgule :: fonc (parseuse: *ParseuseInterface)
{
    saufsi consomme_caractère(parseuse, ';') {
        rapporte_erreur(parseuse, "attendu ';", donne_lexème_suivant(parseuse))
    }
}

consomme_espaces_blanches :: fonc (parseuse: *ParseuseInterface)
{
    tantque parseuse.début < parseuse.fin {
        si est_espace_blanche(mémoire(parseuse.début)) {
            parseuse.début += 1
            continue
        }

        chn := chaine(parseuse.début, parseuse.fin - parseuse.début)

        si chn.commence_par("//") {
            parseuse.début += 2
            tantque parseuse.début < parseuse.fin {
                si mémoire(parseuse.début) == '\n' {
                    arrête
                }

                parseuse.début += 1
            }

            continue
        }

        si chn.commence_par("/*") {
            parseuse.début += 2
            chn = avance(chn, 2)
            tantque parseuse.début < parseuse.fin {
                si chn.commence_par("*/") {
                    chn = avance(chn, 2)
                    parseuse.début += 2
                    arrête
                }
                parseuse.début += 1
                chn = avance(chn, 1)
            }

            continue
        }

        arrête
    }
}
