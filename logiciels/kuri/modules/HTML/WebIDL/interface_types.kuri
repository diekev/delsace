
/* ------------------------------------------------------------------------- */
/** \nom DOMException
 * https://webidl.spec.whatwg.org/#idl-DOMException
 * https://webidl.spec.whatwg.org/#js-exceptions
 * \{ */

#portée_fichier

__table_virtuelle_dom_exception := TableVirtuellePlatformObject(classe = DOMException)

#portée_export

DOMException :: struct {
    empl platform_object: PlatformObject
    table = *__table_virtuelle_dom_exception

    name: DOMString
    message: DOMString

    js_message: *JS.PrimitiveChaine @slot "[[ErrorData]]"
}

crée_dom_exception :: fonc (realm: *JS.Realm, name: chaine, message: chaine) -> *DOMException
{
    tas_de_mémoire := JS.donne_tas_de_mémoire(realm)

    résultat := JS.alloue(tas_de_mémoire, DOMException)
    résultat.prototype = realm.intrinsics.error_prototype

    JS.initialise_error_object(realm, résultat, crée_chaine_utf16_unique(name), message)

    retourne résultat
}

throw_dom_exception :: fonc (interpréteuse: *JS.Interpréteuse, name: chaine, message: chaine)
{
    exception := crée_dom_exception(JS.donne_realm(interpréteuse), name, message)
    JS.définis_exception(interpréteuse, exception)
}

throw_dom_exception :: fonc (realm: *JS.Realm, name: chaine, message: chaine)
{
    exception := crée_dom_exception(realm, name, message)
    JS.définis_exception(realm, exception)
}

throw_dom_exception :: fonc (object: *PlatformObject, name: chaine, message: chaine)
{
    exception := crée_dom_exception(object.realm, name, message)
    JS.définis_exception(object.realm, exception)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Callbacks
 * https://webidl.spec.whatwg.org/#idl-callback-interface
 * \{ */

CallbackType :: struct {
    empl cellule: JS.Cellule

    object: *JS.Object
    callback_context: *EnvironmentSettings
}

/* https://webidl.spec.whatwg.org/#call-a-user-objects-operation
 * À FAIRE : args sont une "WebIDL arguments list" : https://webidl.spec.whatwg.org/#web-idl-arguments-list */
call_a_user_object_operation :: fonc (value: *CallbackType, op_name: chaine @inutilisée, args: []JS.Valeur, this_arg: JS.Valeur = JS.js_undefined) -> JS.Valeur
{
    // imprime("À FAIRE : [%]\n", #nom_de_cette_fonction)

    target := JS.donne_objet(this_arg) comme *PlatformObject

    realm := target.realm
    settings := JS.donne_données(realm.host_defined, EnvironmentSettings)

    prepare_to_run_script(settings)

    evaluation_status := JS.call(JS.donne_mv(realm), JS.Valeur(Object = value.object), this_arg, args)

    cleanup_after_running_script(settings)

    retourne evaluation_status

    /*
    // 1. Let completion be an uninitialized variable.
    completion := JS.js_undefined

    // 2. If thisArg was not given, let thisArg be undefined.
    // NOTE : fais dans le paramètre par défaut

    // 3. Let O be the JavaScript object corresponding to value.
    O := JS.vérifie_comme(value.object, PlatformObject)

    // 4. Let realm be O’s associated realm.
    realm := O.realm

    // 5. Let relevant settings be realm’s settings object.
    // relevant_settings := donne_settings_object(realm)
    relevant_settings := JS.donne_données(realm.host_defined, EnvironmentSettings)

    // 6. Let stored settings be value’s callback context.
    stored_settings := value.callback_context

    // 7. Prepare to run script with relevant settings.
    prepare_to_run_script(relevant_settings)

    // 8. Prepare to run a callback with stored settings.
    prepare_to_run_a_callback(stored_settings)

    // 9. Let X be O.
    X := O

    // 10. If IsCallable(O) is false, then:
    saufsi is_callable(O) {
        // 1. Let getResult be Completion(Get(O, opName)).

        // 2. If getResult is an abrupt completion, set completion to getResult and jump to the step labeled return.

        // 3. Set X to getResult.[[Value]].

        // 4. If IsCallable(X) is false, then set completion to Completion Record { [[Type]]: throw, [[Value]]: a newly created TypeError object, [[Target]]: empty }, and jump to the step labeled return.
        saufsi is_callable(X) {

        }

        // 5. Set thisArg to O (overriding the provided value).
        this_arg = O
    }

    // 11. À FAIRE : Let jsArgs be the result of converting args to a JavaScript arguments list.
    //     If this throws an exception, set completion to the completion value representing
    //     the thrown exception and jump to the step labeled return.
    js_args := args

    // 12. Let callResult be Completion(Call(X, thisArg, jsArgs)).
    call_result := JS.call(JS.donne_mv(realm), value, this_arg, js_args)

    // 13. If callResult is an abrupt completion, set completion to callResult and jump to the step labeled return.
    si JS.possède_exception(realm) {

    }

    // 14. À FAIRE : Set completion to the result of converting callResult.[[Value]] to an
    //     IDL value of the same type as the operation’s return type.
    //     If this throws an exception, set completion to the completion value
    //     representing the thrown exception.
    completion := call_result

    // 15. Return: at this point completion will be set to an IDL value or an abrupt completion.

    // 1. Clean up after running a callback with stored settings.
    cleanup_after_running_a_callback(stored_settings)

    // 2. Clean up after running script with relevant settings.
    cleanup_after_running_script(relevant_settings)

    // 3. If completion is an IDL value, return completion.
    saufsi JS.possède_exception(realm) {
        retourne completion
    }

    // 4. À FAIRE: If completion is an abrupt completion and the operation has a return type that is not a promise type, throw completion.[[Value]].

    // 5. Let rejectedPromise be ! Call(%Promise.reject%, %Promise%, «completion.[[Value]]»).

    // 6. Return the result of converting rejectedPromise to the operation’s return type.
    retourne completion
    */
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom PlatformObject
 * https://webidl.spec.whatwg.org/#dfn-platform-object
 * https://webidl.spec.whatwg.org/#es-platform-objects
 * \{ */

#portée_module

TableVirtuellePlatformObject :: struct {
    empl object: JS.TableVirtuelleObject

    sur_destruction = platform_object_sur_destruction
}

platform_object_sur_destruction :: fonc (base: *JS.Cellule)
{
    JS.sur_destruction_objet(base)
}

#portée_export

PlatformObject :: struct {
    empl objet: JS.Object
    realm: *JS.Realm
}

donne_tas_de_mémoire :: fonc (object: *PlatformObject) -> *JS.TasDeMémoire
{
    retourne JS.donne_tas_de_mémoire(object)
}

crée_platform_object :: fonc (référence: *PlatformObject, $T: type_de_données) -> *T
{
    retourne crée_platform_object(référence.donne_tas_de_mémoire(), référence.realm, T)
}

crée_platform_object :: fonc (tas_de_mémoire: *JS.TasDeMémoire, realm: *JS.Realm, $T: type_de_données) -> *T
{
    résultat := JS.alloue(tas_de_mémoire, T)
    résultat.realm = realm
    définis_prototype(résultat, T)
    retourne résultat
}

/* https://html.spec.whatwg.org/multipage/nav-history-apis.html#isplatformobjectsameorigin-(-o-) */
is_platform_object_same_origin :: fonc (object: *PlatformObject) -> bool
{
    // 1. Return true if the current settings object's origin is same origin-domain with O's relevant settings object's origin, and false otherwise.
    current := donne_current_settings_object(object)
    relevant := donne_relevant_settings_object(object)
    retourne sont_même_domaine_origine(current.donne_origin(), relevant.donne_origin())
}

/** \} */
