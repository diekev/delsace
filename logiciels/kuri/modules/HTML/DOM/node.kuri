/* ------------------------------------------------------------------------- */
/** \nom Node
 * https://dom.spec.whatwg.org/#node
 * \{ */

#portée_module

TableVirtuelleNoeud :: struct {
    empl base_event_target: TableVirtuelleEventTarget

    sur_get_the_parent = node_sur_get_the_parent

    /* Appelé quand le noeud est insérer dans un noeud parent. */
    sur_insertion: fonc(*Node)(rien)
    /* Appelé quand le noeud devinent connecté. */
    sur_connexion: fonc(*Node)(rien)
    /* Appelé quand le noeud devinent déconnecté. */
    sur_déconnexion: fonc(*Node)(rien)
    /* Appelé quand les enfants sont changés. */
    sur_changement_enfants: fonc(*Node)(rien)
    /* Appelé quand le document est devenu fully active. */
    sur_document_fully_active: fonc(*Node)(rien)
}

#portée_export

/* Ces valeurs sont tirées de la spécification. */
ELEMENT_NODE : n16 : 1
ATTRIBUTE_NODE : n16 : 2
TEXT_NODE : n16 : 3
CDATA_SECTION_NODE : n16 : 4
ENTITY_REFERENCE_NODE : n16 : 5 // legacy
ENTITY_NODE : n16 : 6 // legacy
PROCESSING_INSTRUCTION_NODE : n16 : 7
COMMENT_NODE : n16 : 8
DOCUMENT_NODE : n16 : 9
DOCUMENT_TYPE_NODE : n16 : 10
DOCUMENT_FRAGMENT_NODE : n16 : 11
NOTATION_NODE : n16 : 12 // legacy

GenreNoeud :: énum n16 {
    Element :: ELEMENT_NODE
    Attr :: ATTRIBUTE_NODE
    Texte :: TEXT_NODE
    Section_CDATA :: CDATA_SECTION_NODE
    ProcessingInstruction :: PROCESSING_INSTRUCTION_NODE
    Commentaire :: COMMENT_NODE
    Document :: DOCUMENT_NODE
    DocumentType :: DOCUMENT_TYPE_NODE
    DocumentFragment :: DOCUMENT_FRAGMENT_NODE
    ShadowRoot
}

Node :: struct {
    empl event_target: EventTarget

    genre: GenreNoeud

    parent: *Node
    enfants: [..]*Node

    attributs: [..]*Attr

    document: *Document
}

#portée_module

noeud_sur_destruction :: fonc (base: *JS.Cellule)
{
    event_target_sur_destruction(base)
    noeud := base comme *Node
    noeud_détruit_données(noeud)
}

noeud_sur_document_est_devenu_fully_active :: fonc (noeud: *Node) -> DécisionTraversée
{
    table := noeud.table comme *TableVirtuelleNoeud
    si table && table.sur_document_fully_active {
        table.sur_document_fully_active(noeud)
    }
    retourne DécisionTraversée.CONTINUE
}

node_sur_get_the_parent :: fonc (base: *EventTarget, event: *Event @inutilisée) -> *EventTarget
{
    noeud := base comme *Node
    // A node’s get the parent algorithm, given an event, returns the node’s assigned slot,
    // if node is assigned; otherwise node’s parent.
    // À FAIRE : assigned slot
    retourne noeud.parent
}

#portée_export

noeud_détruit_données :: fonc (noeud: *Node)
{
    déloge(noeud.attributs)
    déloge(noeud.enfants)
}

est_document :: fonc (noeud: *Node) -> bool
{
    retourne noeud.genre == GenreNoeud.Document
}

est_élément :: fonc (noeud: *Node) -> bool
{
    retourne noeud.genre == GenreNoeud.Element
}

est_élément_type :: fonc (noeud: *Node, type: chaine) -> *Element
{
    saufsi est_élément(noeud) {
        retourne nul
    }

    élément := noeud comme *Element

    si élément.local_name == type {
        retourne élément
    }

    retourne nul
}

est_élément_type :: fonc (noeud: *Node, tag: DOMString) -> *Element
{
    saufsi est_élément(noeud) {
        retourne nul
    }

    élément := noeud comme *Element

    si élément.local_name == tag {
        retourne élément
    }

    retourne nul
}

est_élément_script :: fonc (noeud: *Node) -> bool
{
    retourne est_élément_type(noeud, TAG_script) != nul
}

est_doctype :: fonc (noeud: *Node) -> bool
{
    retourne noeud.genre == GenreNoeud.DocumentType
}

est_texte :: fonc (noeud: *Node) -> bool
{
    retourne noeud.genre == GenreNoeud.Texte || noeud.genre == GenreNoeud.Section_CDATA
}

/* https://dom.spec.whatwg.org/#exclusive-text-node */
est_texte_exclusif :: fonc (noeud: *Node) -> bool
{
    retourne noeud.genre == GenreNoeud.Texte
}

est_commentaire :: fonc (noeud: *Node) -> bool
{
    retourne noeud.genre == GenreNoeud.Commentaire
}

possède_enfants :: fonc (noeud: *Node) -> bool
{
    retourne noeud.enfants.taille != 0
}

dernier_enfant :: fonc (noeud: *Node) -> *Node
{
    retourne noeud.enfants[noeud.enfants.taille - 1]
}

/* https://dom.spec.whatwg.org/#concept-node-insert */
insert :: fonc (node: *Node, parent: *Node, before_child: *Node @inutilisée, suppress_observers := faux @inutilisée)
{
    /* À FAIRE : standardise */
    ajoute_enfant(parent, node)
}

ajoute_enfant :: fonc (parent: *Node, enfant: *Node)
{
    enfant.parent = parent
    tableau_ajoute(*parent.enfants, enfant)

    si enfant.est_élément() {
        premier_élément_rencontré := faux

        pour parent.enfants {
            saufsi it.est_élément() {
                continue
            }

            élément := it comme *Element
            saufsi premier_élément_rencontré {
                premier_élément_rencontré = vrai
                élément.ajoute_pseudo_classe(CSS.PseudoClasses.FirstChild)
            }
            sinon {
                élément.enlève_pseudo_classe(CSS.PseudoClasses.FirstChild)
            }

            élément.enlève_pseudo_classe(CSS.PseudoClasses.LastChild)
        }

        élément := enfant comme *Element
        élément.ajoute_pseudo_classe(CSS.PseudoClasses.LastChild)
    }

    table := enfant.table comme *TableVirtuelleNoeud
    si table {
        si table.sur_insertion {
            table.sur_insertion(enfant)
        }
        si table.sur_connexion && enfant.est_connecté() {
            table.sur_connexion(enfant)
        }
    }

    table = parent.table comme *TableVirtuelleNoeud
    si table && table.sur_changement_enfants {
        table.sur_changement_enfants(parent)
    }
}

/* https://dom.spec.whatwg.org/#dom-node-parentnode */
donne_parent_node :: fonc (noeud: *Node) -> *Node
{
    retourne noeud.parent
}

/* https://dom.spec.whatwg.org/#get-text-content */
donne_text_content :: fonc (noeud: *Node @inutilisée) -> DOMString
{
    // À FAIRE : implémente
    retourne crée_chaine_utf16_unique_vide()
}

/* https://dom.spec.whatwg.org/#set-text-content */
définis_text_content :: fonc (noeud: *Node, valeur: DOMString)
{
    // À FAIRE : standardise
    assert(noeud.genre == GenreNoeud.Element)

    résultat := create_text_node(noeud.document, valeur)

    noeud.enfants.taille = 0
    tableau_ajoute(*noeud.enfants, résultat)
}

/* https://dom.spec.whatwg.org/#dom-node-appendchild */
append_child :: fonc (noeud: *Node, enfant: *Node) -> *Node
{
    retourne append(noeud, enfant)
}

/* https://dom.spec.whatwg.org/#dom-node-removechild */
remove_child :: fonc (node: *Node, child: *Node) -> *Node
{
    retourne pre_remove(node, child)
}

ajoute_attribut :: fonc (noeud: *Node, nom: DOMString, valeur: DOMString) -> *Attr
{
    résultat := crée_noeud_attr(noeud.document, nom, valeur)
    tableau_ajoute(*noeud.attributs, résultat)
    retourne résultat
}

possède_attribut :: fonc (noeud: *Node, nom: DOMString) -> bool
{
    retourne cherche_attribut(noeud.attributs, nom) != nul
}

cherche_attribut :: fonc (noeud: *Node, nom: DOMString) -> *Attr
{
    retourne cherche_attribut(noeud.attributs, nom)
}

donne_attribut :: fonc (noeud: *Node, nom_qualifié: DOMString) -> Optionnel(DOMString)
{
    attribut := cherche_attribut(noeud, nom_qualifié)
    saufsi attribut {
        retourne
    }
    retourne attribut.valeur
}

donne_attribut_ou_chaine_vide :: fonc (noeud: *Node, nom_qualifié: DOMString) -> DOMString
{
    attribut := cherche_attribut(noeud, nom_qualifié)
    saufsi attribut {
        retourne crée_chaine_utf16_unique_vide()
    }
    retourne attribut.valeur
}

/* https://dom.spec.whatwg.org/#concept-node-document */
donne_node_document :: fonc (noeud: *Node) -> *Document #enligne
{
    retourne noeud.document
}

/* Retourne le premier enfant ayant le tag donné, ou nul si le noeud n'a pas
 * d'enfants ou aucun enfant du tag donné. */
donne_premier_enfant_taggé :: fonc (noeud: *Node, tag: DOMString) -> *Node
{
    saufsi noeud {
        retourne nul
    }

    pour noeud.enfants {
        si it.est_élément_type(tag) {
            retourne it
        }
    }

    retourne nul
}

/* https://dom.spec.whatwg.org/#connected */
est_connecté :: fonc (noeud: *Node) -> bool
{
    retourne noeud.donne_racine_shadow_including().est_document()
}

/* https://dom.spec.whatwg.org/#concept-tree-root */
donne_racine :: fonc (noeud: *Node) -> *Node
{
    résultat := noeud
    tantque résultat.parent != nul {
        résultat = résultat.parent
    }
    retourne résultat
}

rassemble_texte_noeud :: fonc (noeud: *Node, rappel_pour_texte: fonc(*Text, eini)(rien), données: eini)
{
    pour noeud.enfants {
        si it.est_texte() {
            texte := it comme *Text
            rappel_pour_texte(texte, données)
        }
        sinon {
            rassemble_texte_noeud(it, rappel_pour_texte, données)
        }
    }
}

/* Fonction auxillaire pour extraire le texte d'un noeud et de ses enfants. */
extrait_texte_noeud :: fonc (noeud: *Node) -> chaine
{
    ExtractriceTexte :: struct {
        texte: ChaineUTF16
    }

    rappel_pour_extraction_texte :: fonc (noeud_texte: *Text, données: eini)
    {
        extractrice := mémoire(données.pointeur comme **ExtractriceTexte)

        tableau_réserve(*extractrice.texte.unités, noeud_texte.données.taille())

        pour noeud_texte.données.unités {
            tableau_ajoute(*extractrice.texte.unités, it)
        }
    }

    extractrice: ExtractriceTexte
    diffère détruit_chaine(extractrice.texte)

    rassemble_texte_noeud(noeud, rappel_pour_extraction_texte, *extractrice)

    retourne imprime_chaine("%", extractrice.texte)
}

/* https://dom.spec.whatwg.org/#concept-child-text-content */
donne_contenu_texte_enfant :: fonc (noeud: *Node) -> ChaineUTF16
{
    enchaineuse: EnchaineuseUTF16
    initialise_enchaineuse(enchaineuse)
    diffère détruit_tampons(enchaineuse)

    pour noeud.enfants {
        saufsi it.est_texte() {
            continue
        }

        texte := noeud comme *Text
        ajoute(enchaineuse, texte.données)
    }

    retourne chaine_depuis_enchaineuse(enchaineuse)
}

/* https://dom.spec.whatwg.org/#concept-descendant-text-content */
donne_contenu_texte_descandants :: fonc (noeud: *Node) -> ChaineUTF16
{
    rappel_pour_extraction_texte_descandants :: fonc (noeud: *Node, enchaineuse: &EnchaineuseUTF16) -> DécisionTraversée
    {
        si noeud.est_texte() {
            texte := noeud comme *Text
            ajoute(enchaineuse, texte.données)
        }

        retourne DécisionTraversée.CONTINUE
    }

    enchaineuse: EnchaineuseUTF16
    initialise_enchaineuse(enchaineuse)
    diffère détruit_tampons(enchaineuse)

    traverse_noeud(noeud, rappel_pour_extraction_texte_descandants, enchaineuse)

    retourne chaine_depuis_enchaineuse(enchaineuse)
}

/* https://dom.spec.whatwg.org/#concept-node-length */
donne_longueur :: fonc (noeud: *Node) -> z64
{
    discr noeud.genre {
        DocumentType {
            retourne 0
        }
        Commentaire,
        Texte,
        Section_CDATA,
        ProcessingInstruction {
            retourne texte.données.taille
        }
        sinon {
            retourne noeud.enfants.taille
        }
    }
}

/* https://dom.spec.whatwg.org/#concept-node-empty */
est_vide :: fonc (noeud: *Node) -> bool
{
    retourne noeud.donne_longueur() == 0
}

/* https://dom.spec.whatwg.org/#ref-for-dom-nonelementparentnode-getelementbyid%E2%91%A1 */
get_element_by_id :: fonc (noeud: *Node, chn: DOMString) -> *Element
{
    retourne get_element_by_id_recursive(noeud, chn)
}

get_element_by_id_recursive :: fonc (noeud: *Node, chn: DOMString) -> *Element
{
    si noeud.est_élément() {
        valeur := noeud.donne_attribut(ATTR_id)
        si valeur.possède_valeur() && valeur.Quelque == chn {
            retourne noeud comme *Element
        }
    }

    pour noeud.enfants {
        élément := get_element_by_id_recursive(it, chn)
        si élément {
            retourne élément
        }
    }

    retourne nul
}

/* https://dom.spec.whatwg.org/#concept-node-append */
append :: fonc (parent: *Node, node: *Node) -> *Node
{
    // À FAIRE : standardise
    node.parent = parent
    tableau_ajoute(*parent.enfants, node)

    pile: [..]*Node
    diffère déloge(pile)

    tableau_ajoute(*pile, node)

    tantque pile.taille != 0 {
        noeud := enlève_dernier_élément(*pile)
        noeud.document = parent.document

        pour noeud.enfants {
            tableau_ajoute(*pile, it)
        }
    }

    retourne node
}

/* https://dom.spec.whatwg.org/#concept-node-replace-all */
replace_all :: fonc (node: *Node, parent: *Node)
{
    // 1. Let removedNodes be parent’s children.
    // removed_nodes := parent.enfants

    // 2. Let addedNodes be the empty set.
    added_nodes: []*Node

    // 3. If node is a DocumentFragment node, then set addedNodes to node’s children.
    si node != nul && node.table.classe == DocumentFragment {
        added_nodes = node.enfants
    }
    // 4. Otherwise, if node is non-null, set addedNodes to « node ».
    sinon si node != nul {
        added_nodes.pointeur = *node
        added_nodes.taille = 1
    }

    // 5. Remove all parent’s children, in tree order, with the suppress observers flag set.
    pour parent.enfants {
        remove(it, vrai)
    }

    // 6. If node is non-null, then insert node into parent before null with the suppress observers flag set.
    si node {
        insert(node, parent, nul, vrai)
    }

    // À FAIRE : 7. If either addedNodes or removedNodes is not empty, then queue a tree mutation record for parent with addedNodes, removedNodes, null, and null.
}

/* https://dom.spec.whatwg.org/#concept-node-pre-remove */
pre_remove :: fonc (parent: *Node, child: *Node) -> *Node
{
    // 1. If child’s parent is not parent, then throw a "NotFoundError" DOMException.
    si child.parent != parent {
        throw_dom_exception(parent.realm, "NotFoundError", "Le noeud n'est pas enfant du parent")
        retourne nul
    }

    // 2. Remove child.
    remove(child)

    // 3. Return child.
    retourne child
}

/* https://dom.spec.whatwg.org/#concept-node-remove */
remove :: fonc (node: *Node, suppress_observers := faux @inutilisée)
{
    // À FAIRE : complète

    // 1. Let parent be node’s parent.
    parent := node.parent

    // 2. Assert: parent is non-null.
    assert(parent != nul)

    // 3. Run the live range pre-remove steps, given node.

    // 4. For each NodeIterator object iterator whose root’s node document is node’s node document, run the NodeIterator pre-remove steps given node and iterator.

    // 5. Let oldPreviousSibling be node’s previous sibling.

    // 6. Let oldNextSibling be node’s next sibling.

    // 7. Remove node from its parent’s children.
    pour parent.enfants {
        si it == node {
            tableau_supprime_indice(*parent.enfants, index_it)
            arrête
        }
    }

    // 8. If node is assigned, then run assign slottables for node’s assigned slot.

    // 9. If parent’s root is a shadow root, and parent is a slot whose assigned nodes is the empty list, then run signal a slot change for parent.

    // 10. If node has an inclusive descendant that is a slot:

        // 1. Run assign slottables for a tree with parent’s root.

        // 2. Run assign slottables for a tree with node.

    // 11. Run the removing steps with node and parent.

    // 12. Let isParentConnected be parent’s connected.

    // 13. If node is custom and isParentConnected is true, then enqueue a custom element callback reaction with node, callback name "disconnectedCallback", and « ».

    // 14. For each shadow-including descendant descendant of node, in shadow-including tree order:

        // 1. Run the removing steps with descendant and null.

        // 2. If descendant is custom and isParentConnected is true, then enqueue a custom element callback reaction with descendant, callback name "disconnectedCallback", and « ».

    // 15. For each inclusive ancestor inclusiveAncestor of parent, and then for each registered of inclusiveAncestor’s registered observer list, if registered’s options["subtree"] is true, then append a new transient registered observer whose observer is registered’s observer, options is registered’s options, and source is registered to node’s registered observer list.

    // 16. If suppress observers flag is unset, then queue a tree mutation record for parent with « », « node », oldPreviousSibling, and oldNextSibling.

    // 17. Run the children changed steps for parent.
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Interface
 * \{ */

/* https://dom.spec.whatwg.org/#dom-node-nodename */
donne_node_name :: fonc (noeud: *Node) -> DOMString
{
    discr noeud.genre {
        Element {
            // À FAIRE : Its HTML-uppercased qualified name.
            retourne (noeud comme *Element).local_name
        }
        Attr {
            // À FAIRE : Its qualified name.
            retourne (noeud comme *Attr).local_name
        }
        Texte {
            retourne crée_chaine_utf16_unique("#text")
        }
        Section_CDATA {
            retourne crée_chaine_utf16_unique("#cdata-section")
        }
        ProcessingInstruction {
            retourne crée_chaine_utf16_unique((noeud comme *NoeudProcessingInstruction).cible)
        }
        Commentaire {
            retourne crée_chaine_utf16_unique("#comment")
        }
        Document {
            retourne crée_chaine_utf16_unique("#document")
        }
        DocumentType {
            retourne (noeud comme *DocumentType).nom
        }
        DocumentFragment {  
            retourne crée_chaine_utf16_unique("#document-fragment")
        }
    }

    retourne crée_chaine_utf16_unique_vide()
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Hiérarchie
 * \{ */

donne_indice_dans_parent :: fonc (élément: *Element) -> n32
{
    parent := élément.parent
    assert(parent != nul)

    résultat : n32 = 1

    pour parent.enfants {
        saufsi est_élément(it) {
            continue
        }

        si it == élément {
            arrête
        }

        résultat += 1
    }

    retourne résultat
}

donne_indice_dans_parent_depuis_la_fin :: fonc (élément: *Element) -> n32
{
    parent := élément.parent
    assert(parent != nul)

    résultat : n32 = 1

    pour > parent.enfants {
        saufsi est_élément(it) {
            continue
        }

        si it == élément {
            arrête
        }

        résultat += 1
    }

    retourne résultat
}

donne_indice_de_même_type_dans_parent :: fonc (élément: *Element) -> n32
{
    parent := élément.parent
    assert(parent != nul)

    résultat : n32 = 1

    pour parent.enfants {
        saufsi est_élément(it) {
            continue
        }

        adelphe := it comme *Element
        saufsi adelphe.local_name == élément.local_name {
            continue
        }

        si it == élément {
            arrête
        }

        résultat += 1
    }

    retourne résultat
}

donne_indice_de_même_type_dans_parent_depuis_la_fin :: fonc (élément: *Element) -> n32
{
    parent := élément.parent
    assert(parent != nul)

    résultat : n32 = 1

    pour > parent.enfants {
        saufsi est_élément(it) {
            continue
        }

        adelphe := it comme *Element
        saufsi adelphe.local_name == élément.local_name {
            continue
        }

        si it == élément {
            arrête
        }

        résultat += 1
    }

    retourne résultat
}

est_avant_noeud_dans_l_arbre :: fonc (a: *Element, b: *Element) -> bool
{
    si a.parent == b.parent {
        indice_a := donne_indice_dans_parent(a)
        indice_b := donne_indice_dans_parent(b)
        retourne indice_a < indice_b
    }

    traversée: [..]*Node
    diffère déloge(traversée)

    pour > a.document.enfants {
        tableau_ajoute(*traversée, it)
    }

    tantque traversée.taille != 0 {
        noeud := traversée[traversée.taille - 1]
        traversée.taille -= 1

        si noeud == a {
            retourne vrai
        }

        si noeud == b {
            retourne faux
        }

        pour > noeud.enfants {
            tableau_ajoute(*traversée, it)
        }
    }

    retourne faux
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 4.2.1 Document Tree
 * https://dom.spec.whatwg.org/#document-trees
 * \{ */

/* https://dom.spec.whatwg.org/#in-a-document-tree */
is_in_a_document_tree :: fonc (node: *Node) -> bool
{
    root := node.donne_racine()
    si root {
        retourne root.genre == GenreNoeud.Document
    }
    retourne faux
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Attr.
 * https://dom.spec.whatwg.org/#interface-attr
 * \{ */

Attr :: struct {
    empl base_noeud: Node
    table = *table_virtuelle_attr

    namespace: Optionnel(DOMString)
    namespace_prefix: Optionnel(DOMString)
    local_name: DOMString
    valeur: DOMString
    élément: *Element
}

crée_noeud_attr :: fonc (document: *Document, nom: DOMString, valeur: DOMString) -> *Attr
{
    résultat := crée_platform_object(document.donne_tas_de_mémoire(), document.realm, Attr)
    résultat.document = document
    résultat.genre = GenreNoeud.Attr
    résultat.local_name = nom
    résultat.valeur = valeur
    retourne résultat
}

cherche_attribut :: fonc (attributs: []*Attr, nom: DOMString) -> *Attr
{
    pour attributs {
        si it.local_name == nom {
            retourne it
        }
    }

    retourne nul
}

/* https://dom.spec.whatwg.org/#set-an-existing-attribute-value */
définis_valeur :: fonc (attribut: *Attr, valeur: DOMString)
{
    // 1. If attribute’s element is null, then set attribute’s value to value.
    si attribut.élément == nul {
        attribut.valeur = valeur
    }
    // 2. Otherwise, change attribute to value.
    sinon {
        change_attribut(attribut, valeur)
    }
}

#portée_fichier

table_virtuelle_attr := TableVirtuelleNoeud(
    classe = Attr,
    sur_destruction = noeud_sur_destruction
)

#portée_export

/** \} */

