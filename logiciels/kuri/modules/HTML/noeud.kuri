importe Chaine
importe Fondation

GenreNoeud :: énum {
    Invalide
    Document
    Commentaire
    Élément
    Texte
    Doctype
}

Noeud :: struct {
    genre: GenreNoeud

    parent: *Noeud
    enfants: [..]*Noeud

    attributs: [..]Attribut

    document: *Document
}

est_document :: fonc (noeud: *Noeud) -> bool
{
    retourne noeud.genre == GenreNoeud.Document
}

est_élément :: fonc (noeud: *Noeud) -> bool
{
    retourne noeud.genre == GenreNoeud.Élément
}

est_élément_type :: fonc (noeud: *Noeud, type: chaine) -> *Élément
{
    saufsi est_élément(noeud) {
        retourne nul
    }

    élément := noeud comme *Élément

    si élément.texte == type {
        retourne élément
    }

    retourne nul
}

est_élément_type :: fonc (noeud: *Noeud, tag: *ChaineInternée) -> *Élément
{
    saufsi est_élément(noeud) {
        retourne nul
    }

    élément := noeud comme *Élément

    si élément.texte == tag {
        retourne élément
    }

    retourne nul
}

est_élément_script :: fonc (noeud: *Noeud) -> bool
{
    retourne est_élément_type(noeud, TAG_script) != nul
}

est_doctype :: fonc (noeud: *Noeud) -> bool
{
    retourne noeud.genre == GenreNoeud.Doctype
}

est_texte :: fonc (noeud: *Noeud) -> bool
{
    retourne noeud.genre == GenreNoeud.Texte
}

est_commentaire :: fonc (noeud: *Noeud) -> bool
{
    retourne noeud.genre == GenreNoeud.Commentaire
}

ajoute_enfant :: fonc (parent: *Noeud, enfant: *Noeud)
{
    enfant.parent = parent
    tableau_ajoute(*parent.enfants, enfant)
}

ajoute_enfant_dernier :: fonc (parent: *Noeud, enfant: *Noeud)
{
    enfant.parent = parent
    tableau_ajoute(*parent.enfants, enfant)
}

ajoute_attribut :: fonc (noeud: *Noeud @inutilisée, nom: chaine @inutilisée, valeur: chaine @inutilisée)
{
    // attribut := Attribut(nom = copie_chaine(nom), valeur = copie_chaine(valeur))
    // tableau_ajoute(*noeud.attributs, attribut)
}

ajoute_attribut :: fonc (noeud: *Noeud, nom: ChaineUTF16, valeur: ChaineUTF16)
{
    ajoute_attribut(*noeud.attributs, nom, valeur)
}

ajoute_attribut :: fonc (noeud: *Noeud @inutilisée, nom: chaine @inutilisée, valeur: *ChaineInternée @inutilisée)
{
    // attribut := Attribut(nom = copie_chaine(nom), valeur = valeur.chaine_native())
    // tableau_ajoute(*noeud.attributs, attribut)
}

possède_attribut :: fonc (noeud: *Noeud, nom: ChaineUTF16) -> bool
{
    retourne cherche_attribut(noeud.attributs, nom) != nul
}

cherche_attribut :: fonc (noeud: *Noeud, nom: chaine) -> *Attribut
{
    retourne cherche_attribut(noeud.attributs, nom)
}

cherche_attribut :: fonc (noeud: *Noeud, nom: ChaineUTF16) -> *Attribut
{
    retourne cherche_attribut(noeud.attributs, nom)
}

/* Retourne le premier enfant ayant le tag donné, ou nul si le noeud n'a pas
 * d'enfants ou aucun enfant du tag donné. */
donne_premier_enfant_taggé :: fonc (noeud: *Noeud, tag: *ChaineInternée) -> *Noeud
{
    saufsi noeud {
        retourne nul
    }

    pour noeud.enfants {
        si it.est_élément_type(tag) {
            retourne it
        }
    }

    retourne nul
}

/* https://dom.spec.whatwg.org/#connected */
est_connecté :: fonc (noeud: *Noeud) -> bool
{
    retourne noeud.donne_racine_shadow_including().est_document()
}

/* https://dom.spec.whatwg.org/#concept-tree-root */
donne_racine :: fonc (noeud: *Noeud) -> *Noeud
{
    résultat := noeud
    tantque résultat.parent != nul {
        résultat = résultat.parent
    }
    retourne résultat
}

/* https://dom.spec.whatwg.org/#concept-shadow-including-root */
donne_racine_shadow_including :: fonc (noeud: *Noeud) -> *Noeud
{
    racine := noeud.donne_racine()
    /* INCOMPLET : shadow root */
    retourne racine
}
