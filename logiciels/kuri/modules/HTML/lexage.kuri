importe Fondation

charge "attribut"
charge "point_de_code"

est_espace_blanc_html :: fonc (c: z8) -> bool
{
    retourne c == ' ' || c == '\t' || c == 0x0C || c == '\n'
}

est_espace_blanc_html :: fonc (c: n32) -> bool
{
    retourne c == 0x20 || c == 0x09 || c == 0x0C || c == 0x0A
}

GenreLexème :: énum {
    Doctype
    DébutTag
    FinTag
    Commentaire
    Caractère
    FinDeFichier
}

Léxème :: struct {
    genre: GenreLexème

    // général
    nom: chaine

    // doctype
    identifiant_public_doctype: chaine
    identifiant_système_doctype: chaine
    drapeau_force_quirks := faux

    // tag début ou fin
    auto_fermant := faux
    attributs: []Attribut

    // caractère
    point_de_code: n32

    // commentaire
    données: chaine

    attribut_courant : *Attribut
}

ajoute_attribut :: fonc (lexème: *Léxème)
{
    attribut : Attribut
    tableau_ajoute(@lexème.attributs, attribut)
    lexème.attribut_courant = @lexème.attributs[lexème.attributs.taille - 1]
}

détruit_lexème :: fonc (lexème: *Léxème)
{
    discr lexème.genre {
        Doctype {
            déloge lexème.nom
        }
        DébutTag {
            déloge lexème.nom

            pour lexème.attributs {
                déloge it.nom
                déloge it.valeur
            }

            déloge lexème.attributs
        }
        FinTag {
            déloge lexème.nom
        }
        Commentaire {
            déloge lexème.données
        }
        Caractère {
            // RÀF
        }
        FinDeFichier {
            // RÀF
        }
    }
}

// --------------------------------------------

FIN_DE_FICHIER :: 0xffffffff comme n32

ÉtatLexage :: énum {
    Data
    RCDATA
    RAWTEXT
    ScriptData
    PLAINTEXT
    TagOpen
    EndTagOpen
    TagName
    RCDATALessThanSign
    RCDATAEndTagOpen
    RCDATAEndTagName
    RAWTEXTLessThanSign
    RAWTEXTEndTagOpen
    RAWTEXTEndTagName
    ScriptDataLessThanSign
    ScriptDataEndTagOpen
    ScriptDataEndTagName
    ScriptDataEscapeStart
    ScriptDataEscapeStartDash
    ScriptDataEscaped
    ScriptDataEscapedDash
    ScriptDataEscapedDashDash
    ScriptDataEscapedLessThanSign
    ScriptDataEscapedEndTagOpen
    ScriptDataEscapedEndTagName
    ScriptDataDoubleEscapeStart
    ScriptDataDoubleEscaped
    ScriptDataDoubleEscapedDash
    ScriptDataDoubleEscapedDashDash
    ScriptDataDoubleEscapedLessThanSign
    ScriptDataDoubleEscapeEnd
    BeforeAttributeName
    AttributeName
    AfterAttributeName
    BeforeAttributeValue
    AttributeValueDoubleQuoted
    AttributeValueSingleQuoted
    AttributeValueUnquoted
    AfterAttributeValueQuoted
    SelfClosingStartTag
    BogusComment
    MarkupDeclarationOpen
    CommentStart
    CommentStartDash
    Comment
    CommentLessThanSign
    CommentLessThanSignBang
    CommentLessThanSignBangDash
    CommentLessThanSignBangDashDash
    CommentEndDash
    CommentEnd
    CommentEndBang
    DOCTYPE
    BeforeDOCTYPEName
    DOCTYPEName
    AfterDOCTYPEName
    AfterDOCTYPEPublicKeyword
    BeforeDOCTYPEPublicIdentifier
    DOCTYPEPublicIdentifierDoubleQuoted
    DOCTYPEPublicIdentifierSingleQuoted
    AfterDOCTYPEPublicIdentifier
    BetweenDOCTYPEPublicAndSystemIdentifiers
    AfterDOCTYPESystemKeyword
    BeforeDOCTYPESystemIdentifier
    DOCTYPESystemIdentifierDoubleQuoted
    DOCTYPESystemIdentifierSingleQuoted
    AfterDOCTYPESystemIdentifier
    BogusDOCTYPE
    CDATASection
    CDATASectionBracket
    CDATASectionEnd
    CharacterReference
    NamedCharacterReference
    AmbiguousAmpersand
    NumericCharacterReference
    HexadecimalCharacterReferenceStart
    DecimalCharacterReferenceStart
    HexadecimalCharacterReference
    DecimalCharacterReference
    NumericCharacterReferenceEnd
}

Lexeuse :: struct {
    état := ÉtatLexage.Data
    état_retour := ÉtatLexage.Data

    document: chaine
    curseur := 0

    lexème_courant : Léxème

    tampon_temporaire : chaine

    nom_dernier_tag_début : chaine

    code_référence_caractère : n32
}

initialise_lexeuse :: fonc (document: chaine) -> Lexeuse
{
    retourne Lexeuse(document = document)
}

détruit_lexeuse :: fonc (lexeuse: *Lexeuse)
{
    déloge lexeuse.tampon_temporaire
    déloge lexeuse.nom_dernier_tag_début
}

point_de_code_suivant :: fonc (lexeuse: *Lexeuse) -> n32
{
    si lexeuse.a_fini() {
        retourne 0xffffffff
    }

    position := lexeuse.curseur
    lexeuse.curseur += 1
    retourne lexeuse.document[position] comme n32
}

a_fini :: fonc (lexeuse: *Lexeuse) -> bool
{
    retourne lexeuse.curseur >= lexeuse.document.taille
}

crée_lexème :: fonc (lexeuse: *Lexeuse, genre : GenreLexème)
{
    lexeuse.lexème_courant = Léxème(genre = genre)
}

émet_léxème :: fonc (lexeuse: *Lexeuse) -> Léxème
{
    si lexeuse.lexème_courant.genre == GenreLexème.DébutTag {
        déloge lexeuse.nom_dernier_tag_début
        lexeuse.nom_dernier_tag_début = copie_chaine(lexeuse.lexème_courant.nom)
    }

    retourne lexeuse.lexème_courant
}

imprime_et_détruit_léxème :: fonc (lexème_courant: *Léxème)
{
    discr lexème_courant.genre {
        Doctype {
            imprime("DOCTYPE { nom : % }\n", lexème_courant.nom)
        }
        DébutTag {
            imprime("Début Tag { nom : %", lexème_courant.nom)

            si lexème_courant.attributs {
                imprime(", attributs : ")
                virgule := "{ "

                pour lexème_courant.attributs {
                    imprime("%% = %", virgule, it.nom, it.valeur)
                    virgule = ", "
                }

                imprime(" }")
            }

            imprime(" }\n")
        }
        FinTag {
            imprime("Fin Tag { nom : % }\n", lexème_courant.nom)
        }
        Commentaire {
            imprime("Commentaire\n")
        }
        Caractère {
            imprime("Caractère\n")
        }
        FinDeFichier {
            imprime("FinDeFichier\n")
        }
    }

    détruit_lexème(lexème_courant)
}

émet_léxème_fin_de_fichier :: fonc (lexeuse: *Lexeuse) -> Léxème
{
    lexeuse.crée_lexème(GenreLexème.FinDeFichier)
    retourne lexeuse.lexème_courant
}

émet_léxème_caractère :: fonc (lexeuse: *Lexeuse, point_de_code: n32) -> Léxème
{
    lexeuse.crée_lexème(GenreLexème.Caractère)
    lexeuse.lexème_courant.point_de_code = point_de_code
    retourne lexeuse.lexème_courant
}

léxème_suivant :: fonc (lexeuse: *Lexeuse) -> Léxème
{
    // À FAIRE : nous devrions vérifier si la parseuse est en pause, si oui, retourner

    boucle {
        c := lexeuse.point_de_code_suivant()

        discr lexeuse.état {
            Data {
                si c == ESPERLUETTE {
                    lexeuse.état_retour = ÉtatLexage.Data
                    lexeuse.état = ÉtatLexage.CharacterReference
                }
                sinon si c == CHEVRON_OUVRANT {
                    lexeuse.état = ÉtatLexage.TagOpen
                }
                sinon si c == NUL {
                    // @erreur unexpected-null-character parse error
                    retourne lexeuse.émet_léxème_caractère(c)
                }
                sinon si c == FIN_DE_FICHIER {
                    retourne lexeuse.émet_léxème_fin_de_fichier()
                }
                sinon {
                    retourne lexeuse.émet_léxème_caractère(c)
                }
            }
            TagOpen {
                si c == POINT_EXCLAMATION {
                    lexeuse.état = ÉtatLexage.MarkupDeclarationOpen
                }
                sinon si c == SLASH {
                    lexeuse.état = ÉtatLexage.EndTagOpen
                }
                sinon si est_ascii_alpha(c) {
                    lexeuse.crée_lexème(GenreLexème.DébutTag)
                    lexeuse.reconsomme_dans_état(ÉtatLexage.TagName)
                }
                sinon si c == POINT_INTERROGATION {
                    // @erreur unexpected-question-mark-instead-of-tag-name parse error
                    lexeuse.crée_lexème(GenreLexème.Commentaire)
                    lexeuse.reconsomme_dans_état(ÉtatLexage.BogusComment)
                }
                sinon si c == FIN_DE_FICHIER {
                    retourne lexeuse.émet_léxème_fin_de_fichier()
                }
                sinon {
                    // @erreur invalid-first-character-of-tag-name parse error
                    lexeuse.reconsomme_dans_état(ÉtatLexage.Data)
                    retourne lexeuse.émet_léxème_caractère(CHEVRON_OUVRANT)
                }
            }
            TagName {
                si est_espace_blanc_html(c) {
                    lexeuse.état = ÉtatLexage.BeforeAttributeName
                }
                sinon si c == SLASH {
                    lexeuse.état = ÉtatLexage.SelfClosingStartTag
                }
                sinon si c == CHEVRON_FERMANT {
                    lexeuse.état = ÉtatLexage.Data
                    retourne lexeuse.émet_léxème()
                }
                sinon si est_ascii_alpha_majuscule(c) {
                    chaine_ajoute(@lexeuse.lexème_courant.nom, c + 0x20)
                }
                sinon si c == NUL {
                    // @erreur unexpected-null-character parse error
                    chaine_ajoute(@lexeuse.lexème_courant.nom, CARACTÈRE_REMPLACEMENT)
                }
                sinon si c == FIN_DE_FICHIER {
                    retourne lexeuse.émet_léxème_fin_de_fichier()
                }
                sinon {
                    chaine_ajoute(@lexeuse.lexème_courant.nom, c)
                }
            }
            EndTagOpen {
                si est_ascii_alpha(c) {
                    lexeuse.crée_lexème(GenreLexème.FinTag)
                    lexeuse.reconsomme_dans_état(ÉtatLexage.TagName)
                }
                sinon si c == CHEVRON_FERMANT {
                    // @erreur missing-end-tag-name parse error
                    lexeuse.état = ÉtatLexage.Data
                }
                sinon si c == FIN_DE_FICHIER {
                    // @erreur eof-before-tag-name parse error.
                    // XXX - À FAIRE : émettre plusieurs léxèmes
                    _ := lexeuse.émet_léxème_caractère(SLASH)
                    retourne lexeuse.émet_léxème_fin_de_fichier()
                }
                sinon {
                    // @erreur invalid-first-character-of-tag-name parse error
                    lexeuse.crée_lexème(GenreLexème.Commentaire)
                    lexeuse.reconsomme_dans_état(ÉtatLexage.BogusComment)
                }
            }
            MarkupDeclarationOpen {
                // ne consomme pas
                lexeuse.curseur -= 1

                si lexeuse.apparie("DOCTYPE") {
                    lexeuse.curseur += 7
                    lexeuse.état = ÉtatLexage.DOCTYPE
                }
                sinon si lexeuse.apparie("--") {
                    lexeuse.curseur += 2
                    lexeuse.état = ÉtatLexage.CommentStart
                    lexeuse.crée_lexème(GenreLexème.Commentaire)
                }
                sinon {
                    panique("gestion caractère non implémenté")
                }
            }
            DOCTYPE {
                si est_espace_blanc_html(c) {
                    lexeuse.état = ÉtatLexage.BeforeDOCTYPEName
                }
                sinon si c == CHEVRON_FERMANT {
                    lexeuse.reconsomme_dans_état(ÉtatLexage.BeforeDOCTYPEName)
                }
                sinon si c == FIN_DE_FICHIER {
                    // @erreur eof-in-doctype parse error
                    // XXX - À FAIRE : émettre plusieurs léxèmes
                    lexeuse.crée_lexème(GenreLexème.Doctype)
                    lexeuse.lexème_courant.drapeau_force_quirks = vrai
                    _ := lexeuse.émet_léxème()

                    retourne lexeuse.émet_léxème_fin_de_fichier()
                }
                sinon {
                    // @erreur missing-whitespace-before-doctype-name parse error
                    lexeuse.reconsomme_dans_état(ÉtatLexage.DOCTYPEName)
                }
            }
            BeforeDOCTYPEName {
                si est_espace_blanc_html(c) {
                    // ignore
                }
                sinon si est_ascii_alpha_majuscule(c) {
                    lexeuse.crée_lexème(GenreLexème.Doctype)
                    chaine_ajoute(@lexeuse.lexème_courant.nom, c + 0x20)
                    lexeuse.état = ÉtatLexage.DOCTYPEName
                }
                sinon si c == NUL {
                    // @erreur unexpected-null-character parse error
                    lexeuse.crée_lexème(GenreLexème.Doctype)
                    chaine_ajoute(@lexeuse.lexème_courant.nom, CARACTÈRE_REMPLACEMENT)
                    lexeuse.état = ÉtatLexage.DOCTYPEName
                }
                sinon si c == CHEVRON_FERMANT {
                    // @erreur missing-doctype-name parse error
                    lexeuse.crée_lexème(GenreLexème.Doctype)
                    lexeuse.lexème_courant.drapeau_force_quirks = vrai
                    lexeuse.état = ÉtatLexage.Data
                }
                sinon si c == FIN_DE_FICHIER {
                    // @erreur eof-in-doctype parse error
                    // XXX - À FAIRE : émettre plusieurs léxèmes
                    lexeuse.crée_lexème(GenreLexème.Doctype)
                    lexeuse.lexème_courant.drapeau_force_quirks = vrai
                    _ := lexeuse.émet_léxème()

                    retourne lexeuse.émet_léxème_fin_de_fichier()
                }
                sinon {
                    lexeuse.crée_lexème(GenreLexème.Doctype)
                    chaine_ajoute(@lexeuse.lexème_courant.nom, c)
                    lexeuse.état = ÉtatLexage.DOCTYPEName
                }
            }
            DOCTYPEName {
                si est_espace_blanc_html(c) {
                    lexeuse.état = ÉtatLexage.AfterDOCTYPEName
                }
                sinon si c == CHEVRON_FERMANT {
                    lexeuse.état = ÉtatLexage.Data
                    retourne lexeuse.émet_léxème()
                }
                sinon si est_ascii_alpha_majuscule(c) {
                    chaine_ajoute(@lexeuse.lexème_courant.nom, c + 0x20)
                }
                sinon si c == NUL {
                    chaine_ajoute(@lexeuse.lexème_courant.nom, CARACTÈRE_REMPLACEMENT)
                }
                sinon si c == FIN_DE_FICHIER {
                    // @erreur eof-in-doctype parse error
                    // XXX - À FAIRE : émettre plusieurs léxèmes
                    lexeuse.lexème_courant.drapeau_force_quirks = vrai
                    _ := lexeuse.émet_léxème()

                    retourne lexeuse.émet_léxème_fin_de_fichier()
                }
                sinon {
                    chaine_ajoute(@lexeuse.lexème_courant.nom, c)
                }
            }
            AfterDOCTYPEName {
                si est_espace_blanc_html(c) {
                    // ignore
                }
                sinon si c == CHEVRON_FERMANT {
                    lexeuse.état = ÉtatLexage.Data
                    retourne lexeuse.émet_léxème()
                }
                sinon si c == FIN_DE_FICHIER {
                    // @erreur eof-in-doctype parse error
                    // XXX - À FAIRE : émettre plusieurs léxèmes
                    lexeuse.lexème_courant.drapeau_force_quirks = vrai
                    _ := lexeuse.émet_léxème()

                    retourne lexeuse.émet_léxème_fin_de_fichier()
                }
                sinon {
                    lexeuse.curseur -= 1

                    si lexeuse.apparie("PUBLIC") {
                        lexeuse.curseur += 6
                        lexeuse.état = ÉtatLexage.AfterDOCTYPEPublicKeyword
                    }
                    sinon si lexeuse.apparie("SYSTEM") {
                        lexeuse.curseur += 6
                        lexeuse.état = ÉtatLexage.AfterDOCTYPESystemKeyword
                    }
                    sinon {
                        // @erreur invalid-character-sequence-after-doctype-name parse error
                        lexeuse.lexème_courant.drapeau_force_quirks = vrai
                        lexeuse.état = ÉtatLexage.BogusDOCTYPE
                    }
                }
            }
            BeforeAttributeName {
                si est_espace_blanc_html(c) {
                    // ignore
                }
                sinon si c == SLASH || c == CHEVRON_FERMANT || c == FIN_DE_FICHIER {
                    lexeuse.reconsomme_dans_état(ÉtatLexage.AfterAttributeName)
                }
                sinon si c == EGAL {
                    lexeuse.état = ÉtatLexage.AttributeName

                    ajoute_attribut(@lexeuse.lexème_courant)
                    chaine_ajoute(@lexeuse.lexème_courant.attribut_courant.nom, c)
                }
                sinon {
                    lexeuse.reconsomme_dans_état(ÉtatLexage.AttributeName)

                    ajoute_attribut(@lexeuse.lexème_courant)
                }
            }
            AttributeName {
                si est_espace_blanc_html(c) || c == SLASH || c == CHEVRON_FERMANT || c == FIN_DE_FICHIER {
                    lexeuse.reconsomme_dans_état(ÉtatLexage.AfterAttributeName)
                }
                sinon si c == EGAL {
                    lexeuse.état = ÉtatLexage.BeforeAttributeValue
                }
                sinon si est_ascii_alpha_majuscule(c) {
                    chaine_ajoute(@lexeuse.lexème_courant.attribut_courant.nom, c + 0x20)
                }
                sinon si c == NUL {
                    chaine_ajoute(@lexeuse.lexème_courant.attribut_courant.nom, CARACTÈRE_REMPLACEMENT)
                }
                sinon si c == GUILLEMET || c == APOSTROPHE || c == CHEVRON_OUVRANT {
                    // @erreur unexpected-character-in-attribute-name parse error, ajoute quand même
                    chaine_ajoute(@lexeuse.lexème_courant.attribut_courant.nom, c)
                }
                sinon {
                    chaine_ajoute(@lexeuse.lexème_courant.attribut_courant.nom, c)
                }

                /* À FAIRE: quand nous quittons cet état, nous devons vérifier qu'un autre attribut
                 * de même nom n'existe pas déjà. Si c'est le cas, le nouvel attribut de même nom sera supprimé
                 * de la liste d'attribut, mais conservera quand même le status d'attribut courant
                 */
            }
            AfterAttributeName {
                si est_espace_blanc_html(c) {
                    // ignore
                }
                sinon si c == SLASH {
                    lexeuse.état = ÉtatLexage.SelfClosingStartTag
                }
                sinon si c == EGAL {
                    lexeuse.état = ÉtatLexage.BeforeAttributeValue
                }
                sinon si c == CHEVRON_FERMANT {
                    lexeuse.état = ÉtatLexage.Data
                    retourne lexeuse.émet_léxème()
                }
                sinon si c == FIN_DE_FICHIER {
                    // @erreur eof-in-tag parse error
                    retourne lexeuse.émet_léxème_fin_de_fichier()
                }
                sinon {
                    ajoute_attribut(@lexeuse.lexème_courant)
                    lexeuse.reconsomme_dans_état(ÉtatLexage.AttributeName)
                }
            }
            BeforeAttributeValue {
                si est_espace_blanc_html(c) {
                    // ignore
                }
                sinon si c == GUILLEMET {
                    lexeuse.état = ÉtatLexage.AttributeValueDoubleQuoted
                }
                sinon si c == APOSTROPHE {
                    lexeuse.état = ÉtatLexage.AttributeValueSingleQuoted
                }
                sinon si c == CHEVRON_FERMANT {
                    // @erreur missing-attribute-value parse error
                    lexeuse.état = ÉtatLexage.Data
                    retourne lexeuse.émet_léxème()
                }
                sinon {
                    lexeuse.reconsomme_dans_état(ÉtatLexage.AttributeValueUnquoted)
                }
            }
            AttributeValueDoubleQuoted {
                si c == GUILLEMET {
                    lexeuse.état = ÉtatLexage.AfterAttributeValueQuoted
                }
                sinon si c == ESPERLUETTE {
                    lexeuse.état = ÉtatLexage.CharacterReference
                    lexeuse.état_retour = ÉtatLexage.AttributeValueDoubleQuoted
                }
                sinon si c == NUL {
                    chaine_ajoute(@lexeuse.lexème_courant.attribut_courant.valeur, CARACTÈRE_REMPLACEMENT)
                }
                sinon si c == FIN_DE_FICHIER {
                    retourne lexeuse.émet_léxème_fin_de_fichier()
                }
                sinon {
                    chaine_ajoute(@lexeuse.lexème_courant.attribut_courant.valeur, c)
                }
            }
            AttributeValueSingleQuoted {
                si c == APOSTROPHE {
                    lexeuse.état = ÉtatLexage.AfterAttributeValueQuoted
                }
                sinon si c == ESPERLUETTE {
                    lexeuse.état = ÉtatLexage.CharacterReference
                    lexeuse.état_retour = ÉtatLexage.AttributeValueSingleQuoted
                }
                sinon si c == NUL {
                    chaine_ajoute(@lexeuse.lexème_courant.attribut_courant.valeur, CARACTÈRE_REMPLACEMENT)
                }
                sinon si c == FIN_DE_FICHIER {
                    retourne lexeuse.émet_léxème_fin_de_fichier()
                }
                sinon {
                    chaine_ajoute(@lexeuse.lexème_courant.attribut_courant.valeur, c)
                }
            }
            AttributeValueUnquoted {
                si est_espace_blanc_html(c) {
                    lexeuse.état = ÉtatLexage.BeforeAttributeName
                }
                sinon si c == ESPERLUETTE {
                    lexeuse.état = ÉtatLexage.CharacterReference
                    lexeuse.état_retour = ÉtatLexage.AttributeValueUnquoted
                }
                sinon si c == CHEVRON_FERMANT {
                    lexeuse.état = ÉtatLexage.Data
                    retourne lexeuse.émet_léxème()
                }
                sinon si c == NUL {
                    // @erreur unexpected-null-character parse error
                    chaine_ajoute(@lexeuse.lexème_courant.attribut_courant.valeur, CARACTÈRE_REMPLACEMENT)
                }
                sinon si c == FIN_DE_FICHIER {
                    // @erreur eof-in-tag parse error
                    retourne lexeuse.émet_léxème_fin_de_fichier()
                }
                sinon si c == APOSTROPHE || c == GUILLEMET || c == ACCENT_GRAVE || c == CHEVRON_OUVRANT || c == SLASH {
                    // @erreur unexpected-character-in-unquoted-attribute-value parse error
                    chaine_ajoute(@lexeuse.lexème_courant.attribut_courant.valeur, c)
                }
                sinon {
                    chaine_ajoute(@lexeuse.lexème_courant.attribut_courant.valeur, c)
                }
            }
            AfterAttributeValueQuoted {
                si est_espace_blanc_html(c) {
                    lexeuse.état = ÉtatLexage.BeforeAttributeName
                }
                sinon si c == SLASH {
                    lexeuse.état = ÉtatLexage.SelfClosingStartTag
                }
                sinon si c == CHEVRON_FERMANT {
                    lexeuse.état = ÉtatLexage.Data
                    retourne lexeuse.émet_léxème()
                }
                sinon si c == FIN_DE_FICHIER {
                    // @erreur eof-in-tag parse error
                    retourne lexeuse.émet_léxème_fin_de_fichier()
                }
                sinon {
                    // @erreur missing-whitespace-between-attributes parse error, reconsomme
                    lexeuse.reconsomme_dans_état(ÉtatLexage.BeforeAttributeName)
                }
            }
            SelfClosingStartTag {
                si c == CHEVRON_FERMANT {
                    lexeuse.lexème_courant.auto_fermant = vrai
                    lexeuse.état = ÉtatLexage.Data
                    retourne lexeuse.émet_léxème()
                }
                sinon si c == FIN_DE_FICHIER {
                    // @erreur eof-in-tag parse error
                    retourne lexeuse.émet_léxème_fin_de_fichier()
                }
                sinon {
                    // @erreur unexpected-solidus-in-tag parse error, reconsomme
                    lexeuse.reconsomme_dans_état(ÉtatLexage.BeforeAttributeName)
                }
            }
            RCDATA {
                si c == ESPERLUETTE {
                    lexeuse.état_retour = ÉtatLexage.RCDATA
                    lexeuse.état = ÉtatLexage.CharacterReference
                }
                sinon si c == CHEVRON_OUVRANT {
                    lexeuse.état = ÉtatLexage.RCDATALessThanSign
                }
                sinon si c == NUL {
                    retourne lexeuse.émet_léxème_caractère(0xFFFD)
                }
                sinon si c == FIN_DE_FICHIER {
                    retourne lexeuse.émet_léxème_fin_de_fichier()
                }
                sinon {
                    retourne lexeuse.émet_léxème_caractère(c)
                }
            }
            RAWTEXT {
                si c == CHEVRON_OUVRANT {
                    lexeuse.état = ÉtatLexage.RAWTEXTLessThanSign
                }
                sinon si c == NUL {
                    retourne lexeuse.émet_léxème_caractère(0xFFFD)
                }
                sinon si c == FIN_DE_FICHIER {
                    retourne lexeuse.émet_léxème_fin_de_fichier()
                }
                sinon {
                    retourne lexeuse.émet_léxème_caractère(c)
                }
            }
            RCDATALessThanSign {
                si c == SLASH {
                    déloge lexeuse.tampon_temporaire
                    lexeuse.état = ÉtatLexage.RCDATAEndTagOpen
                }
                sinon {
                    lexeuse.reconsomme_dans_état(ÉtatLexage.RCDATA)
                    retourne lexeuse.émet_léxème_caractère(CHEVRON_OUVRANT)
                }
            }
            RCDATAEndTagOpen {
                si est_ascii_alpha(c) {
                    lexeuse.crée_lexème(GenreLexème.FinTag)
                    lexeuse.reconsomme_dans_état(ÉtatLexage.RCDATAEndTagName)
                }
                sinon {
                    lexeuse.reconsomme_dans_état(ÉtatLexage.RCDATA)

                    // XXX - À FAIRE : émettre plusieurs léxèmes
                    _ := lexeuse.émet_léxème_caractère(CHEVRON_OUVRANT)
                    retourne lexeuse.émet_léxème_caractère(SLASH)
                }
            }
            RCDATAEndTagName {
                si lexeuse.nom_dernier_tag_début == lexeuse.lexème_courant.nom {
                    si est_espace_blanc_html(c) {
                        lexeuse.état = ÉtatLexage.BeforeAttributeName
                    }
                    sinon si c == SLASH {
                        lexeuse.état = ÉtatLexage.SelfClosingStartTag
                    }
                    sinon si c == CHEVRON_FERMANT {
                        lexeuse.état = ÉtatLexage.Data
                        retourne lexeuse.émet_léxème()
                    }
                }
                sinon si est_ascii_alpha_majuscule(c) {
                    chaine_ajoute(@lexeuse.lexème_courant.nom, c + 0x20)
                    chaine_ajoute(@lexeuse.tampon_temporaire, c)
                }
                sinon si est_ascii_alpha_minuscule(c) {
                    chaine_ajoute(@lexeuse.lexème_courant.nom, c)
                    chaine_ajoute(@lexeuse.tampon_temporaire, c)
                }
                sinon {
                    lexeuse.reconsomme_dans_état(ÉtatLexage.RCDATA)

                    // XXX - À FAIRE : émettre plusieurs léxèmes, dont un pour chaque caractère du tampon temporaire
                    _ := lexeuse.émet_léxème_caractère(CHEVRON_OUVRANT)
                    retourne lexeuse.émet_léxème_caractère(SLASH)
                }
            }
            RAWTEXTLessThanSign {
                si c == SLASH {
                    déloge lexeuse.tampon_temporaire
                    lexeuse.état = ÉtatLexage.RAWTEXTEndTagOpen
                }
                sinon {
                    lexeuse.reconsomme_dans_état(ÉtatLexage.RAWTEXT)
                    retourne lexeuse.émet_léxème_caractère(CHEVRON_OUVRANT)
                }
            }
            RAWTEXTEndTagOpen {
                si est_ascii_alpha(c) {
                    lexeuse.crée_lexème(GenreLexème.FinTag)
                    lexeuse.reconsomme_dans_état(ÉtatLexage.RAWTEXTEndTagName)
                }
                sinon {
                    lexeuse.reconsomme_dans_état(ÉtatLexage.RAWTEXT)

                    // XXX - À FAIRE : émettre plusieurs léxèmes
                    _ := lexeuse.émet_léxème_caractère(CHEVRON_OUVRANT)
                    retourne lexeuse.émet_léxème_caractère(SLASH)
                }
            }
            RAWTEXTEndTagName {
                si lexeuse.nom_dernier_tag_début == lexeuse.lexème_courant.nom {
                    si est_espace_blanc_html(c) {
                        lexeuse.état = ÉtatLexage.BeforeAttributeName
                    }
                    sinon si c == SLASH {
                        lexeuse.état = ÉtatLexage.SelfClosingStartTag
                    }
                    sinon si c == CHEVRON_FERMANT {
                        lexeuse.état = ÉtatLexage.Data
                        retourne lexeuse.émet_léxème()
                    }
                }
                sinon si est_ascii_alpha_majuscule(c) {
                    chaine_ajoute(@lexeuse.lexème_courant.nom, c + 0x20)
                    chaine_ajoute(@lexeuse.tampon_temporaire, c)
                }
                sinon si est_ascii_alpha_minuscule(c) {
                    chaine_ajoute(@lexeuse.lexème_courant.nom, c)
                    chaine_ajoute(@lexeuse.tampon_temporaire, c)
                }
                sinon {
                    lexeuse.reconsomme_dans_état(ÉtatLexage.RAWTEXT)

                    // XXX - À FAIRE : émettre plusieurs léxèmes, dont un pour chaque caractère du tampon temporaire
                    _ := lexeuse.émet_léxème_caractère(CHEVRON_OUVRANT)
                    retourne lexeuse.émet_léxème_caractère(SLASH)
                }
            }
            CommentStart {
                si c == MOINS {
                    lexeuse.état = ÉtatLexage.CommentStartDash
                }
                sinon si c == CHEVRON_FERMANT {
                    lexeuse.état = ÉtatLexage.Data
                    retourne lexeuse.émet_léxème()
                }
                sinon {
                    lexeuse.reconsomme_dans_état(ÉtatLexage.Comment)
                }
            }
            CommentStartDash {
                si c == MOINS {
                    lexeuse.état = ÉtatLexage.CommentEnd
                }
                sinon si c == CHEVRON_FERMANT {
                    lexeuse.état = ÉtatLexage.Data
                    retourne lexeuse.émet_léxème()
                }
                sinon si c == FIN_DE_FICHIER {
                    // XXX - À FAIRE
                    _ := lexeuse.émet_léxème()
                    retourne lexeuse.émet_léxème_fin_de_fichier()
                }
                sinon {
                    chaine_ajoute(@lexeuse.lexème_courant.données, '-')
                    lexeuse.reconsomme_dans_état(ÉtatLexage.Comment)
                }
            }
            Comment {
                si c == CHEVRON_OUVRANT {
                    chaine_ajoute(@lexeuse.lexème_courant.données, c)
                    lexeuse.état = ÉtatLexage.CommentLessThanSign
                }
                sinon si c == MOINS {
                    lexeuse.état = ÉtatLexage.CommentEndDash
                }
                sinon si c == NUL {
                    chaine_ajoute(@lexeuse.lexème_courant.données, CARACTÈRE_REMPLACEMENT)
                }
                sinon si c == FIN_DE_FICHIER {
                    // XXX - À FAIRE
                    _ := lexeuse.émet_léxème()
                    retourne lexeuse.émet_léxème_fin_de_fichier()
                }
                sinon {
                    chaine_ajoute(@lexeuse.lexème_courant.données, c)
                }
            }
            CommentLessThanSign {
                si c == POINT_EXCLAMATION {
                    chaine_ajoute(@lexeuse.lexème_courant.données, c)
                    lexeuse.état = ÉtatLexage.CommentLessThanSignBang
                }
                sinon si c == CHEVRON_OUVRANT {
                    chaine_ajoute(@lexeuse.lexème_courant.données, c)
                }
                sinon {
                    lexeuse.reconsomme_dans_état(ÉtatLexage.Comment)
                }
            }
            CommentLessThanSignBang {
                si c == MOINS {
                    lexeuse.état = ÉtatLexage.CommentLessThanSignBangDash
                }
                sinon {
                    lexeuse.reconsomme_dans_état(ÉtatLexage.Comment)
                }
            }
            CommentLessThanSignBangDash {
                si c == MOINS {
                    lexeuse.état = ÉtatLexage.CommentLessThanSignBangDashDash
                }
                sinon {
                    lexeuse.reconsomme_dans_état(ÉtatLexage.CommentEndDash)
                }
            }
            CommentLessThanSignBangDashDash {
                si c == CHEVRON_FERMANT || c == FIN_DE_FICHIER {
                    lexeuse.reconsomme_dans_état(ÉtatLexage.CommentEnd)
                }
                sinon {
                    // @erreur nested-comment parse error
                    lexeuse.reconsomme_dans_état(ÉtatLexage.CommentEnd)
                }
            }
            CommentEndDash {
                si c == MOINS {
                    lexeuse.état = ÉtatLexage.CommentEnd
                }
                sinon si c == FIN_DE_FICHIER {
                    // XXX - À FAIRE
                    _ := lexeuse.émet_léxème()
                    retourne lexeuse.émet_léxème_fin_de_fichier()
                }
                sinon {
                    chaine_ajoute(@lexeuse.lexème_courant.données, '-')
                    lexeuse.reconsomme_dans_état(ÉtatLexage.Comment)
                }
            }
            CommentEnd {
                si c == CHEVRON_FERMANT {
                    lexeuse.état = ÉtatLexage.Data
                    retourne lexeuse.émet_léxème()
                }
                sinon si c == POINT_EXCLAMATION {
                    lexeuse.état = ÉtatLexage.CommentEndBang
                }
                sinon si c == MOINS {
                    chaine_ajoute(@lexeuse.lexème_courant.données, '-')
                }
                sinon si c == FIN_DE_FICHIER {
                    // XXX - À FAIRE
                    _ := lexeuse.émet_léxème()
                    retourne lexeuse.émet_léxème_fin_de_fichier()
                }
                sinon {
                    chaine_ajoute(@lexeuse.lexème_courant.données, "--")
                    lexeuse.reconsomme_dans_état(ÉtatLexage.Comment)
                }
            }
            CommentEndBang {
                si c == MOINS {
                    chaine_ajoute(@lexeuse.lexème_courant.données, "--!")
                    lexeuse.état = ÉtatLexage.CommentEndDash
                }
                sinon si c == CHEVRON_FERMANT {
                    lexeuse.état = ÉtatLexage.Data
                    retourne lexeuse.émet_léxème()
                }
                sinon si c == FIN_DE_FICHIER {
                    // XXX - À FAIRE
                    _ := lexeuse.émet_léxème()
                    retourne lexeuse.émet_léxème_fin_de_fichier()
                }
                sinon {
                    chaine_ajoute(@lexeuse.lexème_courant.données, "--!")
                    lexeuse.reconsomme_dans_état(ÉtatLexage.Comment)
                }
            }
            CharacterReference {
                déloge lexeuse.tampon_temporaire
                chaine_ajoute(@lexeuse.tampon_temporaire, '&')

                si est_ascii_alphanumérique(c) {
                    lexeuse.reconsomme_dans_état(ÉtatLexage.NamedCharacterReference)
                }
                sinon si c == SIGNE_NOMBRE {
                    chaine_ajoute(@lexeuse.tampon_temporaire, c)
                    lexeuse.état  = ÉtatLexage.NumericCharacterReference
                }
                sinon {
                    lexeuse.reconsomme_dans_état(lexeuse.état_retour)

                    // détermine si nous somme dans un attribut
                    si lexeuse.état_retour == ÉtatLexage.AttributeValueDoubleQuoted || lexeuse.état_retour == ÉtatLexage.AttributeValueSingleQuoted || lexeuse.état == ÉtatLexage.AttributeValueUnquoted {
                        pour lexeuse.tampon_temporaire {
                            chaine_ajoute(@lexeuse.lexème_courant.attribut_courant.valeur, it)
                        }
                    }
                    sinon {
                        pour lexeuse.tampon_temporaire {
                            // XXX - À FAIRE : émet plusieurs léxèmes
                            retourne lexeuse.émet_léxème_caractère(it comme n32)
                        }
                    }
                }
            }
            NamedCharacterReference {
                panique("état non implémenté")
            }
            NumericCharacterReference {
                lexeuse.code_référence_caractère = 0

                si c == X_MINUSCULE || c == X_MAJUSCULE {
                    chaine_ajoute(@lexeuse.tampon_temporaire, c)
                    lexeuse.état = ÉtatLexage.HexadecimalCharacterReferenceStart
                }
                sinon {
                    lexeuse.reconsomme_dans_état(ÉtatLexage.DecimalCharacterReferenceStart)
                }
            }
            HexadecimalCharacterReferenceStart {
                si est_ascii_hexadecimal(c) {
                    lexeuse.reconsomme_dans_état(ÉtatLexage.HexadecimalCharacterReference)
                }
                sinon {
                    lexeuse.reconsomme_dans_état(lexeuse.état_retour)

                    // À FAIRE : déduplique
                    // détermine si nous somme dans un attribut
                    si lexeuse.état_retour == ÉtatLexage.AttributeValueDoubleQuoted || lexeuse.état_retour == ÉtatLexage.AttributeValueSingleQuoted || lexeuse.état == ÉtatLexage.AttributeValueUnquoted {
                        pour lexeuse.tampon_temporaire {
                            chaine_ajoute(@lexeuse.lexème_courant.attribut_courant.valeur, it)
                        }
                    }
                    sinon {
                        pour lexeuse.tampon_temporaire {
                            // XXX - À FAIRE : émet plusieurs léxèmes
                            retourne lexeuse.émet_léxème_caractère(it comme n32)
                        }
                    }
                }
            }
            DecimalCharacterReferenceStart {
                si est_ascii_chiffre(c) {
                    lexeuse.reconsomme_dans_état(ÉtatLexage.DecimalCharacterReference)
                }
                sinon {
                    lexeuse.reconsomme_dans_état(lexeuse.état_retour)

                    // À FAIRE : déduplique
                    // détermine si nous somme dans un attribut
                    si lexeuse.état_retour == ÉtatLexage.AttributeValueDoubleQuoted || lexeuse.état_retour == ÉtatLexage.AttributeValueSingleQuoted || lexeuse.état == ÉtatLexage.AttributeValueUnquoted {
                        pour lexeuse.tampon_temporaire {
                            chaine_ajoute(@lexeuse.lexème_courant.attribut_courant.valeur, it)
                        }
                    }
                    sinon {
                        pour lexeuse.tampon_temporaire {
                            // XXX - À FAIRE : émet plusieurs léxèmes
                            retourne lexeuse.émet_léxème_caractère(it comme n32)
                        }
                    }
                }
            }
            HexadecimalCharacterReference {
                si est_ascii_chiffre(c) {
                    lexeuse.code_référence_caractère *= 16
                    lexeuse.code_référence_caractère += (c - 0x30)
                }
                sinon si est_ascii_chiffre_hex_maj(c) {
                    lexeuse.code_référence_caractère *= 16
                    lexeuse.code_référence_caractère += (c - 0x37)
                }
                sinon si est_ascii_chiffre_hex_min(c) {
                    lexeuse.code_référence_caractère *= 16
                    lexeuse.code_référence_caractère += (c - 0x57)
                }
                sinon si c == POINT_VIRGULE {
                    lexeuse.état = ÉtatLexage.NumericCharacterReferenceEnd
                }
                sinon {
                    lexeuse.reconsomme_dans_état(ÉtatLexage.NumericCharacterReferenceEnd)
                }
            }
            DecimalCharacterReference {
                si est_ascii_chiffre(c) {
                    lexeuse.code_référence_caractère *= 10
                    lexeuse.code_référence_caractère += (c - 0x30)
                }
                sinon si c == POINT_VIRGULE {
                    lexeuse.état = ÉtatLexage.NumericCharacterReferenceEnd
                }
                sinon {
                    lexeuse.reconsomme_dans_état(ÉtatLexage.NumericCharacterReferenceEnd)
                }
            }
            NumericCharacterReferenceEnd {
                // ne consomme pas
                lexeuse.curseur -= 1

                si lexeuse.code_référence_caractère == 0x0 {
                    lexeuse.code_référence_caractère = CARACTÈRE_REMPLACEMENT
                }
                sinon si lexeuse.code_référence_caractère > 0x10FFFF {
                    lexeuse.code_référence_caractère = CARACTÈRE_REMPLACEMENT
                }
                sinon si 0xD800 <= lexeuse.code_référence_caractère <= 0xDFFF {
                    // surrogate
                    lexeuse.code_référence_caractère = CARACTÈRE_REMPLACEMENT
                }
                sinon si est_noncaractère(c) {
                    panique("état partiellement implémenté")
                }
                sinon si c == 0x0D || (est_controle(lexeuse.code_référence_caractère) && !est_ascii_espace_blanc(lexeuse.code_référence_caractère)) {
                    panique("état partiellement implémenté")
                }

                déloge lexeuse.tampon_temporaire
                chaine_ajoute(@lexeuse.tampon_temporaire, lexeuse.code_référence_caractère)

                lexeuse.état = lexeuse.état_retour

                // À FAIRE : déduplique
                // détermine si nous somme dans un attribut
                si lexeuse.état_retour == ÉtatLexage.AttributeValueDoubleQuoted || lexeuse.état_retour == ÉtatLexage.AttributeValueSingleQuoted || lexeuse.état == ÉtatLexage.AttributeValueUnquoted {
                    pour lexeuse.tampon_temporaire {
                        chaine_ajoute(@lexeuse.lexème_courant.attribut_courant.valeur, it)
                    }
                }
                sinon {
                    pour lexeuse.tampon_temporaire {
                        // XXX - À FAIRE : émet plusieurs léxèmes
                        retourne lexeuse.émet_léxème_caractère(it comme n32)
                    }
                }
            }
            ScriptData {
                si c == CHEVRON_OUVRANT {
                    lexeuse.état = ÉtatLexage.ScriptDataLessThanSign
                }
                sinon si c == NUL {
                    retourne lexeuse.émet_léxème_caractère(CARACTÈRE_REMPLACEMENT)
                }
                sinon si c == FIN_DE_FICHIER {
                    retourne lexeuse.émet_léxème_fin_de_fichier()
                }
                sinon {
                    retourne lexeuse.émet_léxème_caractère(c)
                }
            }
            ScriptDataLessThanSign {
                si c == SLASH {
                    déloge lexeuse.tampon_temporaire
                    lexeuse.état = ÉtatLexage.ScriptDataEndTagOpen
                }
                sinon si c == POINT_EXCLAMATION {
                    lexeuse.état = ÉtatLexage.ScriptDataEscapeStart
                    // XXX - À FAIRE
                    _ := lexeuse.émet_léxème_caractère(CHEVRON_OUVRANT)
                    retourne lexeuse.émet_léxème_caractère(POINT_EXCLAMATION)
                }
                sinon {
                    lexeuse.reconsomme_dans_état(ÉtatLexage.ScriptData)
                    retourne lexeuse.émet_léxème_caractère(CHEVRON_OUVRANT)
                }
            }
            ScriptDataEndTagOpen {
                si est_ascii_alpha(c) {
                    lexeuse.crée_lexème(GenreLexème.FinTag)
                    lexeuse.reconsomme_dans_état(ÉtatLexage.ScriptDataEndTagName)
                }
                sinon {
                    // XXX - À FAIRE
                    _ := lexeuse.émet_léxème_caractère(CHEVRON_OUVRANT)
                    retourne lexeuse.émet_léxème_caractère(SLASH)
                }
            }
            ScriptDataEndTagName {
                si lexeuse.nom_dernier_tag_début == lexeuse.lexème_courant.nom {
                    si est_espace_blanc_html(c) {
                        lexeuse.état = ÉtatLexage.BeforeAttributeName
                    }
                    sinon si c == SLASH {
                        lexeuse.état = ÉtatLexage.SelfClosingStartTag
                    }
                    sinon si c == CHEVRON_FERMANT {
                        lexeuse.état = ÉtatLexage.Data
                    }
                }
                sinon si est_ascii_alpha_majuscule(c) {
                    chaine_ajoute(@lexeuse.lexème_courant.nom, c + 0x20)
                    continue
                }
                sinon si est_ascii_alpha_minuscule(c) {
                    chaine_ajoute(@lexeuse.lexème_courant.nom, c)
                    continue
                }

                lexeuse.reconsomme_dans_état(ÉtatLexage.ScriptData)
                // XXX - À FAIRE, émet également un caractère pour chaque caractère dans le tampon temporaire
                _ := lexeuse.émet_léxème_caractère(CHEVRON_OUVRANT)
                retourne lexeuse.émet_léxème_caractère(SLASH)
            }
            ScriptDataEscapeStart {
                si c == MOINS {
                    lexeuse.état = ÉtatLexage.ScriptDataEscapeStartDash
                    retourne lexeuse.émet_léxème_caractère(MOINS)
                }
                sinon {
                    lexeuse.reconsomme_dans_état(ÉtatLexage.ScriptData)
                }
            }
            ScriptDataEscapeStartDash {
                si c == MOINS {
                    lexeuse.état = ÉtatLexage.ScriptDataEscapedDashDash
                    retourne lexeuse.émet_léxème_caractère(MOINS)
                }
                sinon {
                    lexeuse.reconsomme_dans_état(ÉtatLexage.ScriptData)
                }
            }
            ScriptDataEscaped {
                si c == MOINS {
                    lexeuse.état = ÉtatLexage.ScriptDataEscapedDash
                }
                sinon si c == CHEVRON_OUVRANT {
                    lexeuse.état = ÉtatLexage.ScriptDataEscapedLessThanSign
                }
                sinon si c == NUL {
                    retourne lexeuse.émet_léxème_caractère(CARACTÈRE_REMPLACEMENT)
                }
                sinon si c == FIN_DE_FICHIER {
                    retourne lexeuse.émet_léxème_fin_de_fichier()
                }
                sinon {
                    retourne lexeuse.émet_léxème_caractère(c)
                }
            }
            ScriptDataEscapedDash {
                si c == MOINS {
                    lexeuse.état = ÉtatLexage.ScriptDataEscapedDashDash
                    retourne lexeuse.émet_léxème_caractère(MOINS)
                }
                sinon si c == CHEVRON_OUVRANT {
                    lexeuse.état = ÉtatLexage.ScriptDataEscapedLessThanSign
                }
                sinon si c == NUL {
                    retourne lexeuse.émet_léxème_caractère(CARACTÈRE_REMPLACEMENT)
                }
                sinon si c == FIN_DE_FICHIER {
                    retourne lexeuse.émet_léxème_fin_de_fichier()
                }
                sinon {
                    lexeuse.état = ÉtatLexage.ScriptDataEscaped
                    retourne lexeuse.émet_léxème_caractère(c)
                }
            }
            ScriptDataEscapedDashDash {
                si c == MOINS {
                    retourne lexeuse.émet_léxème_caractère(MOINS)
                }
                sinon si c == CHEVRON_OUVRANT {
                    lexeuse.état = ÉtatLexage.ScriptDataEscapedLessThanSign
                }
                sinon si c == CHEVRON_FERMANT {
                    lexeuse.état = ÉtatLexage.ScriptData
                    retourne lexeuse.émet_léxème_caractère(CHEVRON_FERMANT)
                }
                sinon si c == NUL {
                    retourne lexeuse.émet_léxème_caractère(CARACTÈRE_REMPLACEMENT)
                }
                sinon si c == FIN_DE_FICHIER {
                    retourne lexeuse.émet_léxème_fin_de_fichier()
                }
                sinon {
                    lexeuse.état = ÉtatLexage.ScriptDataEscaped
                    retourne lexeuse.émet_léxème_caractère(c)
                }
            }
            ScriptDataEscapedLessThanSign {
                si c == SLASH {
                    déloge lexeuse.tampon_temporaire
                    lexeuse.état = ÉtatLexage.ScriptDataEscapedEndTagOpen
                }
                sinon si est_ascii_alpha(c) {
                    déloge lexeuse.tampon_temporaire
                    lexeuse.reconsomme_dans_état(ÉtatLexage.ScriptDataDoubleEscapeStart)
                    retourne lexeuse.émet_léxème_caractère(CHEVRON_OUVRANT)
                }
                sinon {
                    lexeuse.reconsomme_dans_état(ÉtatLexage.ScriptDataEscaped)
                    retourne lexeuse.émet_léxème_caractère(CHEVRON_OUVRANT)
                }
            }
            ScriptDataEscapedEndTagOpen {
                si est_ascii_alpha(c) {
                    lexeuse.crée_lexème(GenreLexème.FinTag)
                    lexeuse.reconsomme_dans_état(ÉtatLexage.ScriptDataEscapedEndTagName)
                }
                sinon {
                    lexeuse.reconsomme_dans_état(ÉtatLexage.ScriptDataEscaped)
                    // XXX - À FAIRE
                    _ := lexeuse.émet_léxème_caractère(CHEVRON_OUVRANT)
                    retourne lexeuse.émet_léxème_caractère(SLASH)
                }
            }
            ScriptDataEscapedEndTagName {

            }
            sinon {
                imprime("état : %\n", lexeuse.état)
                panique("état non implémenté")
            }
        }
    }

    retourne lexeuse.émet_léxème_fin_de_fichier()
}

reconsomme_dans_état :: fonc (lexeuse: *Lexeuse, état_cible: ÉtatLexage)
{
    lexeuse.curseur -= 1
    lexeuse.état = état_cible
}

apparie :: fonc (lexeuse: *Lexeuse, chn: chaine) -> bool
{
    pour chn {
        index := lexeuse.curseur + index_it

        si index >= lexeuse.document.taille {
            retourne faux
        }

        c := lexeuse.document[index]

        si 'a' <= c <= 'z' {
            c -= 0x20
        }

        si it != c {
            retourne faux
        }
    }

    retourne vrai
}
