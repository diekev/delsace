// Module de parsage de code HTML
// Spec : https://html.spec.whatwg.org/multipage/parsing.html

importe Chaine
importe Fondation
importe Temps

charge "élément"
charge "attribut"
charge "comparaison"
charge "document"
charge "entités"
charge "entropisation"
charge "formattage"
charge "formulaire"
charge "lexage"
charge "liste_éléments_actifs_formattage"
charge "noeud"
charge "outils"
charge "parsage"
charge "pile_éléments_ouverts"
charge "point_de_code"
charge "tags_html"

imprime_noeud :: fonc (noeud: *Noeud, tab : z32) -> rien
{
    pour 1 ... tab {
        imprime("  ")
    }

    si noeud.genre == GenreNoeud.Texte {
        texte := noeud comme *NoeudTexte
        imprime("%\n", texte.données)
    }
    sinon si noeud.genre == GenreNoeud.Élément {
        élément := noeud comme *Élément
        imprime("<%", élément.texte)

        pour élément.attributs {
            imprime(" %=%", it.nom, it.valeur)
        }

        imprime(">\n")
    }
    sinon si noeud.genre == GenreNoeud.Commentaire {
        commentaire := noeud comme *NoeudCommentaire
        imprime("<!--%-->\n", commentaire.données)
    }
    sinon {
        imprime("%\n", noeud.genre)
    }

    pour noeud.enfants {
        imprime_noeud(it, tab + 1)
    }
}

imprime_document :: fonc (document: *Document)
{
    imprime("============== Document ==============\n")

    pour document.enfants {
        imprime_noeud(it, 0)
    }
}

rassemble_texte_noeud :: fonc (noeud: *Noeud, rappel_pour_texte: fonc(*NoeudTexte,eini)(rien), données: eini)
{
    pour noeud.enfants {
        si it.genre == GenreNoeud.Texte {
            texte := it comme *NoeudTexte
            rappel_pour_texte(texte, données)
        }
        sinon {
            rassemble_texte_noeud(it, rappel_pour_texte, données)
        }
    }
}

traverse_noeud :: fonc (noeud: *Noeud, rappel_traverse: fonc(*Noeud, eini)(rien), données: eini)
{
    pour noeud.enfants {
        rappel_traverse(it, données)
        traverse_noeud(it, rappel_traverse, données)
    }
}

// ces fonctions devraient plutôt être dans noeud.kuri, mais nous avons des
// dépendances cycliques entre les modules que le langage ne sait pas encore gérer
détruit_noeud_selon_genre :: fonc (noeud: *Noeud)
{
    discr noeud.genre {
        Invalide {
            déloge(noeud)
        }
        Document {
            document := noeud comme *Document
            déloge(document)
        }
        Commentaire {
            commentaire := noeud comme *NoeudCommentaire
            détruit_chaine(commentaire.données)
            déloge(commentaire)
        }
        Élément {
            élément := noeud comme *Élément
            // Ne pas détruire le texte, c'est un pointeur partagé !
            déloge(élément)
        }
        Texte {
            texte := noeud comme *NoeudTexte
            détruit_chaine(texte.données)
            déloge(texte)
        }
        Doctype {
            type_document := noeud comme *DocumentType
            déloge(type_document)
        }
    }
}

détruit_noeud :: fonc (noeud: *Noeud)
{
    pour noeud.enfants {
        détruit_noeud(it)
    }

    détruit_attributs(noeud.attributs)

    déloge(noeud.enfants)
    détruit_noeud_selon_genre(noeud)
}

/* Résultat du parsage (« parsat », de « parser » + « -at ») d'un document HTML. */
ParsatHTML :: struct {
    /* Le document qui fut parsé. */
    document: *Document
    /* Les différentes erreurs parsage. */
    erreurs: []chaine
    /* Le temps de parsage du document, en microsecondes. */
    temps: z64
}

détruit :: fonc (parsat: &ParsatHTML)
{
    détruit_noeud(parsat.document)
    déloge(parsat.erreurs)
}

/* Parse un document HTML depuis une chaine de caractère. */
parse_document :: fonc (document: chaine) -> ParsatHTML
{
    parseuse := initialise_parseuse(document)
    diffère { détruit_parseuse(*parseuse) }

    début := maintenant_précis()
    parse(*parseuse)
    temps := début.temps_écoulé_microsecondes()

    parsat : ParsatHTML
    parsat.document = parseuse.document
    parsat.temps = temps
    parsat.erreurs = tableau_vole_mémoire(parseuse.erreurs)
    retourne parsat
}
