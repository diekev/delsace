importe Couleur
CSS :: importe CSS
importe Dessin
importe ÉditionTexte
importe Géométrie
importe Image
importe MIME
importe Unicode

est_tag_auto_fermant :: fonc (tag: DOMString) -> bool
{
    discr tag {
        TAG_area,
        TAG_base,
        TAG_br,
        TAG_col,
        TAG_embed,
        TAG_hr,
        TAG_img,
        TAG_input,
        TAG_link,
        TAG_meta,
        TAG_param,
        TAG_source,
        TAG_track,
        TAG_wbr {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

/* ------------------------------------------------------------------------- */
/** \nom Element
 * \{ */

html_element_sur_changement_attribut :: fonc (élément: *Element, local_name: DOMString, vieille_valeur: *DOMString, valeur: *DOMString, espace_de_nom: Optionnel(DOMString)) -> bool
{
    /* Nous devons faire ça même si l'ancienne et la nouvelle valeur sont les mêmes. */
    si gère_changement_attribut_event_handler(élément, local_name, valeur, espace_de_nom) {
        retourne vrai
    }

    si element_sur_changement_attribut(élément, local_name, vieille_valeur, valeur, espace_de_nom) {
        retourne vrai
    }

    si local_name == TAG_style {
        CSS.détruit_style_declaration(élément.style)

        si valeur == nul || mémoire(valeur).est_vide() {
            élément.style = nul
        }
        sinon si rendu_css_est_requis(élément) {
            valeur_texte := mémoire(valeur).donne_chaine_utf16()
            élément.style = CSS.parse_attribut_style(valeur_texte)
            élément.style.owner_node = élément
        }

        élément.document.invalide_style_depuis_élément(élément)
        retourne vrai
    }

    /* https://html.spec.whatwg.org/multipage/urls-and-fetching.html#cryptographicnonce */
    si local_name == ATTR_nonce {
        // 1. À FAIRE : If element does not include HTMLOrSVGElement, then return.

        // 2. If localName is not nonce or namespace is not null, then return.
        si espace_de_nom.possède_valeur() {
            retourne vrai
        }

        // 3. If value is null, then set element's [[CryptographicNonce]] to the empty string.
        si valeur == nul {
            élément.cryptographic_nonce = crée_chaine_utf16_unique_vide()
        }
        // 4. Otherwise, set element's [[CryptographicNonce]] to value.
        sinon {
            élément.cryptographic_nonce = mémoire(valeur)

            /* Elements that have a nonce content attribute ensure that the cryptographic nonce is 
             * only exposed to script (and not to side-channels like CSS attribute selectors) by
             * taking the value from the content attribute, moving it into an internal slot named
             * [[CryptographicNonce]], exposing it to script via the HTMLOrSVGElement interface mixin,
             * and setting the content attribute to the empty string. Unless otherwise specified,
             * the slot's value is the empty string. */
            attr := cherche_attribut(élément, ATTR_nonce)
            attr.valeur = crée_chaine_utf16_unique_vide()
        }
        retourne vrai
    }

    retourne faux
}

/* https://html.spec.whatwg.org/multipage/webappapis.html#event-handler-content-attributes */
gère_changement_attribut_event_handler :: fonc (élément: *Element, local_name: DOMString, valeur: *DOMString, espace_de_nom: Optionnel(DOMString)) -> bool
{
    user_agent := donne_user_agent(élément.document)
    saufsi user_agent {
        retourne faux
    }

    // 1. If namespace is not null, or localName is not the name of an event handler content attribute on element, then return.
    si espace_de_nom.possède_valeur() || !is_event_handler_content_attribute_name(local_name) {
        retourne faux
    }

    // 2. Let eventTarget be the result of determining the target of an event handler given element and localName.
    event_target := determine_the_target_of_an_event_handler(élément, local_name)

    // 3. If eventTarget is null, then return.
    si event_target == nul {
        retourne faux
    }

    // 4. If value is null, then deactivate an event handler given eventTarget and localName.
    si valeur == nul {
        deactivate_an_event_handler(event_target, local_name)
    }
    // 5. Otherwise:
    sinon {
        // 1. If the Should element's inline behavior be blocked by Content Security Policy? algorithm returns "Blocked" when executed upon element, "script attribute", and value, then return. [CSP]
        valeur_chaine := converti_vers_chaine(mémoire(valeur).donne_chaine_utf16())
        diffère déloge(valeur_chaine)

        bloqué := should_element_s_inline_behavior_be_blocked(élément, "script attribute", valeur_chaine)
        si bloqué == "Blocked" {
            retourne faux
        }

        // 2. Let handlerMap be eventTarget's event handler map.
        // 3. Let eventHandler be handlerMap[localName].
        event_handler := donne_event_handler(event_target, local_name)

        // À FAIRE : 4. Let location be the script location that triggered the execution of these steps.

        // 5. Set eventHandler's value to the internal raw uncompiled handler value/location.
        event_handler.type_valeur = TypeValeurEventHandler.InternalRawUncompiled
        event_handler.internal_raw_uncompiled = mémoire(valeur)

        // 6. Activate an event handler given eventTarget and localName.
        activate_an_event_handler(event_target, local_name)
    }

    retourne vrai
}

rendu_css_est_requis :: fonc (élément: *Element) -> bool
{
    document := élément.document
    saufsi document {
        retourne faux
    }

    // À FAIRE : pour les tests CSS nous devons avoir les styles qui ne sont pas traités sans UserAgent...
    // Désactivation de cette vérification dans l'attente d'un meilleur système pour détecter la nécessité des styles.
    // user_agent := donne_user_agent(document)
    // saufsi user_agent {
    //     retourne faux
    // }

    retourne vrai
}

#portée_export

initialise_élément :: fonc (élément: *Element, document: *Document, texte: DOMString) -> rien
{
    élément.genre = GenreNoeud.Element
    élément.document = document
    élément.local_name = texte
}

élément_fut_dépilé_de_la_pile_des_éléments_ouverts :: fonc (élément: *Element)
{
    saufsi élément.table {
        retourne
    }

    table_virtuelle := élément.table comme *TableVirtuelleElement    
    si table_virtuelle.sur_dépilement  {
        table_virtuelle.sur_dépilement(élément)
    }
}

est_compatible_html5 :: fonc (élément: *Element) -> bool
{
    discr élément.local_name {
        TAG_acronym,
        TAG_applet,
        TAG_basefont,
        TAG_big,
        TAG_center,
        TAG_dir,
        TAG_font,
        TAG_frame,
        TAG_frameset,
        TAG_noframes,
        TAG_strike,
        TAG_tt {
            retourne faux
        }
        sinon {
            retourne vrai
        }
    }
}

donne_referrerpolicy_content_attribute_state :: fonc (élément: *Element) -> ReferrerPolicy
{
    referrer_policy := élément.donne_attribut_ou_chaine_vide(ATTR_referrerpolicy)
    chn_referrer_policy := converti_vers_chaine(referrer_policy.donne_chaine_utf16())
    diffère déloge(chn_referrer_policy)

    si compare_ascii_insensible_à_la_casse(chn_referrer_policy, "no-referrer") {
        retourne ReferrerPolicy.NoReferrer
    }

    si compare_ascii_insensible_à_la_casse(chn_referrer_policy, "no-referrer-when-downgrade") {
        retourne ReferrerPolicy.NoReferrerWhenDowngrade
    }

    si compare_ascii_insensible_à_la_casse(chn_referrer_policy, "same-origin") {
        retourne ReferrerPolicy.SameOrigin
    }

    si compare_ascii_insensible_à_la_casse(chn_referrer_policy, "origin") {
        retourne ReferrerPolicy.Origin
    }

    si compare_ascii_insensible_à_la_casse(chn_referrer_policy, "strict-origin") {
        retourne ReferrerPolicy.StrictOrigin
    }

    si compare_ascii_insensible_à_la_casse(chn_referrer_policy, "origin-when-cross-origin") {
        retourne ReferrerPolicy.OriginWhenCrossOrigin
    }

    si compare_ascii_insensible_à_la_casse(chn_referrer_policy, "strict-origin-when-cross-origin") {
        retourne ReferrerPolicy.StrictOriginWhenCrossOrigin
    }

    si compare_ascii_insensible_à_la_casse(chn_referrer_policy, "unsafe-url") {
        retourne ReferrerPolicy.UnsafeUrl
    }

    retourne ReferrerPolicy.EmptyString
}

/* https://html.spec.whatwg.org/multipage/urls-and-fetching.html#cors-settings-attributes */
CORSAttributeState :: énum n8 {
    NO_CORS
    Anonymous
    UseCredentials
}

donne_cross_origin_content_attribute_state :: fonc (élément: *Element) -> CORSAttributeState
{
    crossorigin := élément.donne_attribut_ou_chaine_vide(ATTR_crossorigin)
    si crossorigin.est_vide() {
        retourne CORSAttributeState.NO_CORS
    }

    chn_crossorigin := converti_vers_chaine(crossorigin.donne_chaine_utf16())
    diffère déloge(chn_crossorigin)

    si compare_ascii_insensible_à_la_casse(chn_crossorigin, "anonymous") {
        retourne CORSAttributeState.Anonymous
    }

    si compare_ascii_insensible_à_la_casse(chn_crossorigin, "use-credentials") {
        retourne CORSAttributeState.UseCredentials
    }

    retourne CORSAttributeState.Anonymous
}

FetchPriorityState :: énum n8 {
    Auto
    High
    Low
}

donne_fetch_priority_content_attribute_state :: fonc (élément: *Element) -> FetchPriorityState
{
    fetchpriority := élément.donne_attribut_ou_chaine_vide(ATTR_fetchpriority)
    si fetchpriority.est_vide() {
        retourne FetchPriorityState.Auto
    }

    chn_fetchpriority := converti_vers_chaine(fetchpriority.donne_chaine_utf16())
    diffère déloge(chn_fetchpriority)

    si compare_ascii_insensible_à_la_casse(chn_fetchpriority, "high") {
        retourne FetchPriorityState.High
    }

    si compare_ascii_insensible_à_la_casse(chn_fetchpriority, "low") {
        retourne FetchPriorityState.Low
    }

    si compare_ascii_insensible_à_la_casse(chn_fetchpriority, "auto") {
        retourne FetchPriorityState.Auto
    }

    retourne FetchPriorityState.Auto
}

donne_request_priority :: fonc (state: FetchPriorityState) -> Request.Priority
{
    discr state {
        Auto {
            retourne Request.Priority.Auto
        }
        Low {
            retourne Request.Priority.Low
        }
        High {
            retourne Request.Priority.High
        }
    }
    retourne Request.Priority.Low
}

/** \} */

fait_partie_de_catégorie_spécial :: fonc (nom: DOMString) -> bool
{
    // À FAIRE : utilisation d'une recherche binaire
    retourne fait_partie_de(nom,
                            TAG_address, TAG_applet, TAG_area, TAG_article,
                            TAG_aside, TAG_base, TAG_basefont, TAG_bgsound,
                            TAG_blockquote, TAG_body, TAG_br, TAG_button,
                            TAG_caption, TAG_center, TAG_col, TAG_colgroup,
                            TAG_dd, TAG_details, TAG_dir, TAG_div, TAG_dl,
                            TAG_dt, TAG_embed, TAG_fieldset, TAG_figcaption,
                            TAG_figure, TAG_footer, TAG_form, TAG_frame,
                            TAG_frameset, TAG_h1, TAG_h2, TAG_h3, TAG_h4,
                            TAG_h5, TAG_h6, TAG_head, TAG_header, TAG_hgroup,
                            TAG_hr, TAG_html, TAG_iframe, TAG_img, TAG_input,
                            TAG_keygen, TAG_li, TAG_link, TAG_listing, TAG_main,
                            TAG_marquee, TAG_menu, TAG_meta, TAG_nav, TAG_noembed,
                            TAG_noframes, TAG_noscript, TAG_object, TAG_ol, TAG_p,
                            TAG_param, TAG_plaintext, TAG_pre, TAG_script,
                            TAG_section, TAG_select, TAG_source, TAG_style,
                            TAG_summary, TAG_table, TAG_tbody, TAG_td, TAG_template,
                            TAG_textarea, TAG_tfoot, TAG_th, TAG_thead, TAG_title,
                            TAG_tr, TAG_track, TAG_ul, TAG_wbr, TAG_xmp, TAG_mi,
                            TAG_mo, TAG_mn, TAG_ms, TAG_mtext, TAG_annotation_xml,
                            TAG_foreignObject, TAG_desc, TAG_title)
}

enfant_directe_avec_balise :: fonc (élément: *Element, balise: DOMString) -> *Element
{
    pour élément.enfants {
        saufsi it.genre == GenreNoeud.Element {
            continue
        }

        élément_enfant := (it comme *Element)
        si élément_enfant.local_name == balise {
            retourne élément_enfant
        }
    }

    retourne nul
}

/* ------------------------------------------------------------------------- */
/** \nom CSS
 * \{ */

ajoute_pseudo_classe :: fonc (élément: *Element, pseudo_classe: CSS.PseudoClasses)
{
    si (élément.pseudo_classes & pseudo_classe) == pseudo_classe {
        retourne
    }

    élément.pseudo_classes |= pseudo_classe
    assert(élément.document != nul)
    élément.document.invalide_style(élément, pseudo_classe)
}

enlève_pseudo_classe :: fonc (élément: *Element, pseudo_classe: CSS.PseudoClasses)
{
    si (élément.pseudo_classes & pseudo_classe) != pseudo_classe {
        retourne
    }

    élément.pseudo_classes &= ~pseudo_classe
    assert(élément.document != nul)
    élément.document.invalide_style(élément, pseudo_classe)
}

est_en_train_d_être_activé :: fonc (élément: *Element, ouinon: bool)
{
    /* À FAIRE : gère tous les cas/différencie les niveaux d'activation ?
     * https://html.spec.whatwg.org/multipage/semantics-other.html#concept-selector-active */
    si ouinon {
        élément.ajoute_pseudo_classe(CSS.PseudoClasses.Active)
    }
    sinon {
        élément.enlève_pseudo_classe(CSS.PseudoClasses.Active)
    }
}

applique_presentational_hints :: fonc (élément: *Element, résolveuse: *CSS.RésolveuseStyle)
{
    table := élément.table comme *TableVirtuelleElement
    saufsi table {
        retourne
    }
    saufsi table.sur_applique_presentational_hints {
        retourne
    }
    table.sur_applique_presentational_hints(élément, résolveuse)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 3.5 Render-blocking mechanisms
 * https://html.spec.whatwg.org/multipage/dom.html#render-blocking-mechanism
 * \{ */

/* https://html.spec.whatwg.org/multipage/dom.html#allows-adding-render-blocking-elements */
allows_adding_render_blocking_elements :: fonc (document: *Document) -> bool
{
    retourne document.type_contenu == "text/html" && donne_élément_body(document) == nul
}

/* https://html.spec.whatwg.org/multipage/dom.html#render-blocked */
is_render_blocked :: fonc (document: *Document) -> bool
{
    // document's render-blocking element set is non-empty, or document allows adding render-blocking elements.
    si document.render_blocking_elements.taille != 0 || document.allows_adding_render_blocking_elements() {
        retourne vrai
    }

    // À FAIRE The current high resolution time given document's relevant global object has not exceeded an implementation-defined timeout value.
    retourne faux
}

/* https://html.spec.whatwg.org/multipage/dom.html#render-blocking */
is_render_blocking :: fonc (el: *Element) -> bool
{
    retourne is_render_blocked(el.document) || tableau_possède_élément(el.document.render_blocking_elements, el)
}

/* https://html.spec.whatwg.org/multipage/dom.html#block-rendering */
block_rendering_on :: fonc (el: *Element)
{
    // 1. Let document be el's node document.
    document := el.document

    // 2. If document allows adding render-blocking elements,
    //    then append el to document's render-blocking element set.
    si document.allows_adding_render_blocking_elements() {
        tableau_ajoute(*document.render_blocking_elements, el)
    }
}

/* https://html.spec.whatwg.org/multipage/dom.html#unblock-rendering */
unblock_rendering_on :: fonc (el: *Element)
{
    // 1. Let document be el's node document.
    document := el.document

    // 2. Remove el from document's render-blocking element set.
    tableau_supprime_valeur(*document.render_blocking_elements, el)

    // @inspécifié
    si document.render_blocking_elements.taille == 0 {
        ua := document.donne_user_agent()
        si ua {
            requiers_rendu(ua)
        }
    }
}

/* https://html.spec.whatwg.org/multipage/urls-and-fetching.html#potentially-render-blocking */
is_potentially_render_blocking :: fonc (el: *Element) -> bool
{
    // À FAIRE : if its blocking tokens set contains "render"
    retourne is_implicitly_potentially_render_blocking(el)
}

/* https://html.spec.whatwg.org/multipage/urls-and-fetching.html#implicitly-potentially-render-blocking */
is_implicitly_potentially_render_blocking :: fonc (el: *Element) -> bool
{
    si el.table.classe == HTMLLinkElement {
        link := el comme *HTMLLinkElement
        // A link element of this type is implicitly potentially render-blocking if
        // the element was created by its node document's parser.
        si link.est_stylesheet {
            retourne link.fut_créé_par_parseuse
        }

        retourne faux
    }

    retourne faux
}

block_rendering_if_potentially_render_blocking :: fonc (el: *Element)
{
    saufsi is_potentially_render_blocking(el) {
        retourne
    }
    block_rendering_on(el)
}

// À FAIRE Whenever a render-blocking element el becomes
// browsing-context disconnected, or el's blocking attribute's value
// is changed so that el is no longer potentially render-blocking,
// then unblock rendering on el.

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Interface JavaScript
 * \{ */

#portée_export

/* https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#fragment-serializing-algorithm-steps */
fragment_serializing_algorithm_steps :: fonc (node: *Node, well_formed: bool @inutilisée) -> ChaineUTF16
{
    // À FAIRE assert : Document, DocumentFragment, Element

    // 1. Let context document be node's node document.
    context_document := node.document

    // 2. If context document is an HTML document, return the result of HTML fragment serialization algorithm with node, false, and « ».
    si context_document.type != "xml" {
        retourne HTML_fragment_serialization(node, faux)
    }

    // 3. Return the XML serialization of node given require well-formed.
    panique("XML non pris en charge")
}

/* https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#fragment-parsing-algorithm-steps */
fragment_parsing_algorithm_steps :: fonc (context: *Element, markup: ChaineUTF16) -> *DocumentFragment
{
    // À FAIRE(XML) : 1. Let algorithm be the HTML fragment parsing algorithm.

    // 2. If context's node document is an XML document, then set algorithm to the XML fragment parsing algorithm.

    // 3. Let new children be the result of invoking algorithm given markup, with context set to context.
    new_children := HTML_fragment_parsing(markup, context)

    // 4. Let fragment be a new DocumentFragment whose node document is context's node document.
    fragment := crée_noeud_fragment_document(context.document)

    // 5. Append each Node in new children to fragment (in tree order).
    pour new_children {
        _ := append(fragment, it)
    }

    // 6. Return fragment.
    retourne fragment
}

// https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-element-innerhtml
donne_inner_html :: fonc (élément: *Element) -> ChaineUTF16
{
    retourne fragment_serializing_algorithm_steps(élément, vrai)
}

définis_inner_html :: fonc (élément: *Element, texte: DOMString)
{
    // À FAIRE : 1. Let compliantString be the result of invoking the Get Trusted Type compliant string algorithm with TrustedHTML, this's relevant global object, the given value, "Element innerHTML", and "script".
    compliant_string := texte.donne_chaine_utf16()

    // 2. Let context be this.
    context : *Node = élément

    // 3. Let fragment be the result of invoking the fragment parsing algorithm steps with context and compliantString.
    fragment := fragment_parsing_algorithm_steps(élément, compliant_string)

    // 4. If context is a template element, then set context to the template element's template contents (a DocumentFragment).
    si context.table.classe == HTMLTemplateElement {
        context = (context comme *HTMLTemplateElement).content
    }

    // 5. Replace all with fragment within context.
    replace_all(fragment, context)

    // À FAIRE : reconstruction partielle de l'arbre
    élément.document.invalide_style()
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLElement
 * https://html.spec.whatwg.org/multipage/dom.html#htmlelement
 * \{ */

#portée_export

HTMLElement :: struct {
    empl base_élément: Element
    table = *table_virtuelle_html_element
}

#portée_fichier

table_virtuelle_html_element := TableVirtuelleElement(
    classe = HTMLElement,
    sur_changement_attribut = html_element_sur_changement_attribut
)

#portée_export

create_element_with_interface :: fonc (document: *Document, tag: DOMString, namespace: EspaceDeNom) -> *Element
{
    résultat: *Element
    
    si namespace == EspaceDeNom_HTML {
        résultat = create_html_element_with_interface(document, tag)
    }
    sinon {
        /* https://dom.spec.whatwg.org/#concept-element-interface */
        résultat = crée_platform_object(document, Element)
    }

    initialise_élément(résultat, document, tag)
    résultat.espace_de_nom = namespace

    si tag == TAG_template {
        // À FAIRE : généralise et utilise un rappel dans TableVirtuelle ?
        template_element_sur_création(résultat comme *HTMLTemplateElement)
    }

    retourne résultat
}

/* https://html.spec.whatwg.org/multipage/dom.html#elements-in-the-dom:element-interface */
create_html_element_with_interface :: fonc (document: *Document, name: DOMString) -> *Element
{
    // 1. If name is applet, bgsound, blink, isindex, keygen, multicol, nextid, or spacer, then return HTMLUnknownElement.
    unknown_names := [TAG_applet, TAG_bgsound, TAG_blink, TAG_isindex, TAG_keygen, TAG_multicol, TAG_nextid, TAG_spacer]
    si fait_partie_de(name, ...unknown_names) {
        retourne crée_platform_object(document, HTMLUnknownElement)
    }

    // 2. If name is acronym, basefont, big, center, nobr, noembed, noframes, plaintext, rb, rtc, strike, or tt, then return HTMLElement.
    element_names := [TAG_acronym, TAG_basefont, TAG_big, TAG_center, TAG_nobr, TAG_noembed, TAG_noframes, TAG_plaintext, TAG_rb, TAG_rtc, TAG_strike, TAG_tt]
    si fait_partie_de(name, ...element_names) {
        retourne crée_platform_object(document, HTMLElement)
    }

    // À FAIRE : 3. If name is listing or xmp, then return HTMLPreElement.

    // 4. Otherwise, if this specification defines an interface appropriate for the element type corresponding to the local name name, then return that interface.
    // 5. If other applicable specifications define an appropriate interface for name, then return the interface they define.
    si name == TAG_a {
        retourne crée_platform_object(document, HTMLAnchorElement)
    }
    si name == TAG_body {
        retourne crée_platform_object(document, HTMLBodyElement)
    }
    si name == TAG_button {
        retourne crée_platform_object(document, HTMLButtonElement)
    }
    si name == TAG_canvas {
        retourne crée_platform_object(document, HTMLCanvasElement)
    }
    si name == TAG_font {
        retourne crée_platform_object(document, HTMLFontElement)
    }
    si name == TAG_form {
        retourne crée_platform_object(document, HTMLFormElement)
    }
    si name == TAG_head {
        retourne crée_platform_object(document, HTMLHeadElement)
    }
    si name == TAG_h1 || name == TAG_h2 || name == TAG_h3 || name == TAG_h4 || name == TAG_h5 || name == TAG_h6 {
        retourne crée_platform_object(document, HTMLHeadingElement)
    }
    si name == TAG_hr {
        retourne crée_platform_object(document, HTMLHRElement)
    }
    si name == TAG_html {
        retourne crée_platform_object(document, HTMLHtmlElement)
    }
    si name == TAG_iframe {
        retourne crée_platform_object(document, HTMLIFrameElement)
    }
    si name == TAG_img {
        retourne crée_platform_object(document, HTMLImageElement)
    }
    si name == TAG_input {
        retourne crée_platform_object(document, HTMLInputElement)
    }
    si name == TAG_label {
        retourne crée_platform_object(document, HTMLLabelElement)
    }
    si name == TAG_link {
        retourne crée_platform_object(document, HTMLLinkElement)
    }
    si name == TAG_object {
        retourne crée_platform_object(document, HTMLObjectElement)
    }
    si name == TAG_option {
        retourne crée_platform_object(document, HTMLOptionElement)
    }
    si name == TAG_optgroup {
        retourne crée_platform_object(document, HTMLOptGroupElement)
    }
    si name == TAG_script {
        retourne crée_platform_object(document, HTMLScriptElement)
    }
    si name == TAG_select {
        retourne crée_platform_object(document, HTMLSelectElement)
    }
    si name == TAG_span {
        retourne crée_platform_object(document, HTMLSpanElement)
    }
    si name == TAG_style {
        retourne crée_platform_object(document, HTMLStyleElement)
    }
    si name == TAG_table {
        retourne crée_platform_object(document, HTMLTableElement)
    }
    si name == TAG_td || name == TAG_th {
        retourne crée_platform_object(document, HTMLTableCellElement)
    }
    si name == TAG_thead || name == TAG_tbody || name == TAG_tfoot {
        retourne crée_platform_object(document, HTMLTableSectionElement)
    }
    si name == TAG_tr {
        retourne crée_platform_object(document, HTMLTableRowElement)
    }
    si name == TAG_template {
        retourne crée_platform_object(document, HTMLTemplateElement)
    }
    si name == TAG_textarea {
        retourne crée_platform_object(document, HTMLTextAreaElement)
    }
    si name == TAG_video {
        retourne crée_platform_object(document, HTMLVideoElement)
    }

    // 6. If name is a valid custom element name, then return HTMLElement.
    si is_valid_custom_element_name(name) {
        retourne crée_platform_object(document, HTMLElement)
    }

    // 7. Return HTMLUnknownElement.
    retourne crée_platform_object(document, HTMLUnknownElement)
}

/* https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name */
is_valid_custom_element_name :: fonc (name: DOMString) -> bool
{
    // name is a valid element local name;
    saufsi is_valid_element_local_name(name) {
        retourne faux
    }

    chn := name.donne_chaine_utf16()
    assert(chn.taille() != 0)

    // name's 0th code point is an ASCII lower alpha;
    saufsi est_lettre_minuscule_ascii(chn.unités[0]) {
        retourne faux
    }

    // name does not contain any ASCII upper alphas;
    // name contains a U+002D (-); and
    possède_tiret: bool
    pour chn.unités {
        si est_lettre_majuscule_ascii(it) {
            retourne faux
        }
        si it == 0x2D {
            possède_tiret = vrai
        }
    }

    saufsi possède_tiret {
        retourne faux
    }

    // name is not one of the following:
    // "annotation-xml"
    // "color-profile"
    // "font-face"
    // "font-face-src"
    // "font-face-uri"
    // "font-face-format"
    // "font-face-name"
    // "missing-glyph"
    tag_spéciaux := [TAG_annotation_xml, TAG_color_profile, TAG_font_face, TAG_font_face_src, TAG_font_face_uri, TAG_font_face_format, TAG_font_face_name, TAG_missing_glyph]
    si fait_partie_de(name, ...tag_spéciaux) {
        retourne faux
    }

    retourne vrai
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLAnchorElement
 * https://html.spec.whatwg.org/multipage/text-level-semantics.html#htmlanchorelement
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLAnchorElement
 * \{ */

#portée_export

HTMLAnchorElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_anchor_element
}

est_hyperlien :: fonc (anchor: *HTMLAnchorElement) -> bool
{
    retourne anchor.donne_attribut(ATTR_href).possède_valeur()
}

donne_href :: fonc (anchor: *HTMLAnchorElement) -> DOMString
{
    retourne get_an_attribute_value(anchor, ATTR_href)
}

#portée_fichier

table_virtuelle_anchor_element := TableVirtuelleElement(
    classe = HTMLAnchorElement,
    sur_destruction = élément_sur_destruction,
    sur_activation_behavior = anchor_element_sur_activation_behavior,
    sur_changement_attribut = anchor_element_sur_changement_attribut
)

anchor_element_sur_changement_attribut :: fonc (base: *Element, local_name: DOMString, vieille_valeur: *DOMString, valeur: *DOMString, espace_de_nom: Optionnel(DOMString)) -> bool
{
    si html_element_sur_changement_attribut(base, local_name, vieille_valeur, valeur, espace_de_nom) {
        retourne vrai
    }

    anchor := base comme *HTMLAnchorElement

    si local_name == ATTR_href {
        si valeur == nul || mémoire(valeur).est_vide() {
            anchor.enlève_pseudo_classe(CSS.PseudoClasses.Link)
        }
        sinon {
            anchor.ajoute_pseudo_classe(CSS.PseudoClasses.Link)
        }

        retourne vrai
    }

    retourne faux
}

/* https://html.spec.whatwg.org/multipage/links.html#api-for-a-and-area-elements */
anchor_element_sur_activation_behavior :: fonc (target: *EventTarget, event: *Event)
{
    element := target comme *HTMLElement
    
    // 1. If element has no href attribute, then return.
    saufsi possède_attribut(element, ATTR_href) {
        retourne
    }

    // 2. Let hyperlinkSuffix be null.
    hyperlink_suffix := crée_chaine_utf16_unique_vide()

    // À FAIRE : 3. If element is an a element, and event's target is an img with an ismap attribute specified, then:

        // 1. Let x and y be 0.

        // 2. If event's isTrusted attribute is initialized to true, then set x to the distance in CSS pixels from the left edge of the image to the location of the click, and set y to the distance in CSS pixels from the top edge of the image to the location of the click.

        // 3. If x is negative, set x to 0.

        // 4. If y is negative, set y to 0.

        // 5. Set hyperlinkSuffix to the concatenation of U+003F (?), the value of x expressed as a base-ten integer using ASCII digits, U+002C (,), and the value of y expressed as a base-ten integer using ASCII digits.

    // 4. Let userInvolvement be event's user navigation involvement.
    user_involvement := donne_user_navigation_involvement(event)

    // À FAIRE : 5. If the user has expressed a preference to download the hyperlink, then set userInvolvement to "browser UI".

    // À FAIRE : 6. If element has a download attribute, or if the user has expressed a preference to download the hyperlink, then download the hyperlink created by element with hyperlinkSuffix set to hyperlinkSuffix and userInvolvement set to userInvolvement.

    // 7. Otherwise, follow the hyperlink created by element with hyperlinkSuffix set to hyperlinkSuffix and userInvolvement set to userInvolvement.
    follow_the_hyperlink(element, hyperlink_suffix, user_involvement)
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#event-uni */
donne_user_navigation_involvement :: fonc (event: *Event) -> UserNavigationInvolvement
{
    // 1. Assert: this algorithm is being called as part of an activation behavior definition.
    assert(event.est_dans_activation_behavior)

    // 2. Assert: event's type is "click".
    assert(event.type == EventType.click)

    // 3. If event's isTrusted is initialized to true, then return "activation".
    si event.is_trusted {
        retourne UserNavigationInvolvement.Activation
    }

    // 4. Return "none".
    retourne UserNavigationInvolvement.None
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 4.6.4 Following Hyperlinks
 * https://html.spec.whatwg.org/multipage/links.html#following-hyperlinks
 * \{ */

/* https://html.spec.whatwg.org/multipage/links.html#cannot-navigate */
cannot_navigate :: fonc (element: *Element) -> bool
{
    // element's node document is not fully active; or
    saufsi element.document.est_fully_active() {
        retourne vrai
    }

    // element is not an a element and is not connected.
    si element.local_name != TAG_a && !element.est_connecté() {
        retourne vrai
    }

    retourne faux
}

/* https://html.spec.whatwg.org/multipage/links.html#get-an-element's-noopener */
get_an_element_s_noopener :: fonc (element: *Element, target: DOMString) -> bool
{
    assert(element.local_name == TAG_a || element.local_name == TAG_area || element.local_name == TAG_form)

    link_types := donne_link_types(element)
    diffère déloge(link_types)

    // 1. If element's link types include the noopener or noreferrer keyword, then return true.
    si link_types_incluent(link_types, ATTR_noopener) || link_types_incluent(link_types, ATTR_noreferrer) {
        retourne vrai
    }

    // 2. If element's link types do not include the opener keyword and target is an ASCII
    //    case-insensitive match for "_blank", then return true.
    si !link_types_incluent(link_types, ATTR_opener) && compare_ascii_insensible_à_la_casse(target, ATTR__blank) {
        retourne vrai
    }

    // 3. Return false.
    retourne faux
}

/* https://html.spec.whatwg.org/multipage/links.html#following-hyperlinks-2 */
follow_the_hyperlink :: fonc (subject: *Element, hyperlink_suffix := crée_chaine_utf16_unique_vide(), user_involvement := UserNavigationInvolvement.None)
{
    // 1. If subject cannot navigate, then return.
    si cannot_navigate(subject) {
        imprime("[%] cannot_navigate\n", #nom_de_cette_fonction)
        retourne
    }

    // 2. Let replace be false.
    // replace := faux

    // 3. Let targetAttributeValue be the empty string.
    target_attribute_value := crée_chaine_utf16_unique_vide()

    // 4. If subject is an a or area element, then set targetAttributeValue to the result of getting an element's target given subject.
    si subject.local_name == TAG_a || subject.local_name == TAG_area {
        target_attribute_value = get_an_element_s_target(subject)
    }

    // 5. Let noopener be the result of getting an element's noopener with subject and targetAttributeValue.
    // noopener := get_an_element_s_noopener(subject, target_attribute_value)

    // À FAIRE : 6. Let targetNavigable be the first return value of applying the rules for choosing a navigable given targetAttributeValue, subject's node navigable, and noopener.
    target_navigable := donne_node_navigable(subject)

    // 7. If targetNavigable is null, then return.
    saufsi target_navigable {
        imprime("[%] pas de navigable\n", #nom_de_cette_fonction)
        retourne
    }

    // 8. Let urlString be the result of encoding-parsing-and-serializing a URL given subject's href attribute value, relative to subject's node document.
    chn_href := subject.donne_attribut_ou_chaine_vide(ATTR_href)
    opt_url_string := encoding_parse_and_serialize_a_url(chn_href, subject.document)

    // 9. If urlString is failure, then return.
    saufsi opt_url_string.possède_valeur() {
        retourne
    }
    url_string := opt_url_string.Quelque

    // 10. If hyperlinkSuffix is non-null, then append it to urlString.
    saufsi hyperlink_suffix.est_vide() {
        chn_hyperlink_suffix := converti_vers_chaine(hyperlink_suffix.donne_chaine_utf16())
        chaine_ajoute(*url_string, chn_hyperlink_suffix)
    }

    // 11. Let referrerPolicy be the current state of subject's referrerpolicy content attribute.
    referrer_policy := donne_referrerpolicy_content_attribute_state(subject)

    // 12. If subject's link types includes the noreferrer keyword, then set referrerPolicy to "no-referrer".
    link_types := donne_link_types(subject)
    diffère déloge(link_types)

    si link_types_incluent(link_types, ATTR_noreferrer) {
        referrer_policy = ReferrerPolicy.NoReferrer
    }

    // 13. Navigate targetNavigable to urlString using subject's node document, with referrerPolicy set to referrerPolicy and userInvolvement set to userInvolvement.
    source_document := subject.document
    user_agent := source_document.donne_user_agent()
    url := url_parser(user_agent, url_string)

    params: ParamètresNavigationNavigable
    params.url = url
    params.source_document = source_document
    params.referrer_policy = referrer_policy
    params.user_involvement = user_involvement
    navigate(user_agent, target_navigable, params)
}

/* https://html.spec.whatwg.org/multipage/semantics.html#get-an-element's-target */
get_an_element_s_target :: fonc (element: *Element, target := crée_chaine_utf16_unique_vide()) -> DOMString
{
    // 1. If target is null, then:
    si target.est_vide() {
        // 1. If element has a target attribute, then set target to that attribute's value.
        attr_target := element.donne_attribut(ATTR_target)
        si attr_target.possède_valeur() {
            target = attr_target.Quelque
        }
        // À FAIRE : 2. Otherwise, if element's node document contains a base element with a target attribute, set target to the value of the target attribute of the first such base element.
    }

    // 2. If target is not null, and contains an ASCII tab or newline and a U+003C (<), then set target to "_blank".
    saufsi target.est_vide() {
        chn_target := target.donne_chaine_utf16()
        si chn_target.taille() == 2 && (chn_target.unités[0] == '\t' comme n8 || chn_target.unités[0] == '\n' comme n8) && chn_target.unités[1] == '<' comme n8 {
            target = ATTR__blank
        }
    }

    // 3. Return target.
    retourne target
}

/* https://html.spec.whatwg.org/multipage/urls-and-fetching.html#encoding-parsing-and-serializing-a-url */
encoding_parse_and_serialize_a_url :: fonc (url: DOMString, document: *Document) -> Optionnel(chaine)
{
    // À FAIRE : standardise
    base_url := donne_base_url(document)

    url_src := url_parser(document.donne_user_agent(), url.donne_chaine_utf16(), base = base_url)
    diffère détruit_url(url_src)
    saufsi url_src {
        retourne
    }

    retourne url_serializer(url_src)
}

encoding_parse_a_url :: fonc (url: DOMString, document: *Document) -> *URL
{
    retourne encoding_parse_a_url(url.donne_chaine_utf16(), document)
}

encoding_parse_a_url :: fonc (url: ChaineUTF16, document: *Document) -> *URL
{
    // À FAIRE : standardise
    base_url := donne_base_url(document)
    retourne url_parser(document.donne_user_agent(), url, base = base_url)
}

encoding_parse_a_url :: fonc (user_agent: *UserAgent, url: DOMString, base_url: *URL) -> *URL
{
    // À FAIRE : standardise
    retourne url_parser(user_agent, url.donne_chaine_utf16(), base = base_url)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 4.6.7 Link Types
 * https://html.spec.whatwg.org/multipage/links.html#linkTypes
 * \{ */

donne_link_types :: fonc (element: *Element) -> [..]DOMString
{
    rel := element.donne_attribut_ou_chaine_vide(ATTR_rel)
    retourne run_ordered_set_parser(rel)
}

link_types_incluent :: fonc (link_types: []DOMString, chn: DOMString) -> bool
{
    pour link_types {
        si compare_ascii_insensible_à_la_casse(it, chn) {
            retourne vrai
        }
    }
    retourne faux
}

/** } */

/* ------------------------------------------------------------------------- */
/** \nom HTMLBodyElement
 * https://html.spec.whatwg.org/multipage/sections.html#the-body-element
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLBodyElement
 * \{ */

#portée_export

HTMLBodyElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_body_element
}

#portée_fichier

table_virtuelle_body_element := TableVirtuelleElement(
    classe = HTMLBodyElement,
    sur_destruction = élément_sur_destruction,
    sur_changement_attribut = html_element_sur_changement_attribut,
    sur_applique_presentational_hints = body_element_sur_applique_presentational_hints
)

/* https://html.spec.whatwg.org/multipage/rendering.html#the-page */
body_element_sur_applique_presentational_hints :: fonc (base: *Element, résolveuse: *CSS.RésolveuseStyle)
{
    ajoute_propriété_pour_legacy_colour_value(résolveuse, base, ATTR_bgcolor, CSS.PROP_background_color)
    ajoute_propriété_pour_legacy_colour_value(résolveuse, base, ATTR_text, CSS.PROP_color)

    /* À FAIRE : utilise les attributs. */
    ajoute_propriété_pour_nombre(résolveuse, CSS.PROP_margin_top, 8.0)
    ajoute_propriété_pour_nombre(résolveuse, CSS.PROP_margin_bottom, 8.0)
    ajoute_propriété_pour_nombre(résolveuse, CSS.PROP_margin_left, 8.0)
    ajoute_propriété_pour_nombre(résolveuse, CSS.PROP_margin_right, 8.0)
}

ajoute_propriété_pour_legacy_colour_value :: fonc (résolveuse: *CSS.RésolveuseStyle, élément: *Element, nom_attribut: DOMString, nom_propriété: CSS.CSSOMString)
{
    opt_attribut := élément.donne_attribut(nom_attribut)
    si opt_attribut.possède_valeur() {
        ajoute_propriété_pour_couleur(résolveuse, nom_propriété, opt_attribut.Quelque)
    }
}

ajoute_propriété_pour_couleur :: fonc (résolveuse: *CSS.RésolveuseStyle, nom_propriété: CSS.CSSOMString, texte: DOMString)
{
    opt_couleur := parse_a_legacy_colour_value(texte)
    saufsi opt_couleur.possède_valeur() {
        retourne
    }

    CSS.ajoute_presentational_hint(résolveuse, nom_propriété, CSS.crée_valeur_couleur(opt_couleur.Quelque))
}

ajoute_propriété_pour_mot_clé :: fonc (résolveuse: *CSS.RésolveuseStyle, nom_propriété: CSS.CSSOMString, mot_clé: CSS.CSSOMString)
{
    CSS.ajoute_presentational_hint(résolveuse, nom_propriété, CSS.crée_valeur_mot_clé(mot_clé))
}

ajoute_propriété_pour_dimension :: fonc (résolveuse: *CSS.RésolveuseStyle, élément: *Element, nom_attribut: DOMString, nom_propriété: CSS.CSSOMString)
{
    opt_attribut := élément.donne_attribut(nom_attribut)
    si opt_attribut.possède_valeur() {
        valeur := parse_a_dimension_value(opt_attribut.Quelque)
        si valeur.possède_valeur() {
            ajoute_propriété_pour_dimension(résolveuse, nom_propriété, valeur.Quelque)
        }
    }
}

ajoute_propriété_pour_pixel_length :: fonc (résolveuse: *CSS.RésolveuseStyle, élément: *Element, nom_attribut: DOMString, nom_propriété: CSS.CSSOMString)
{
    opt_attribut := élément.donne_attribut(nom_attribut)
    si opt_attribut.possède_valeur() {
        valeur := parse_a_non_negative_integer(opt_attribut.Quelque)
        si valeur.possède_valeur() {
            CSS.ajoute_presentational_hint(résolveuse, nom_propriété, CSS.crée_valeur_pixels(valeur.Quelque comme r64))
        }
    }
}

ajoute_propriété_pour_non_zero_dimension :: fonc (résolveuse: *CSS.RésolveuseStyle, élément: *Element, nom_attribut: DOMString, nom_propriété: CSS.CSSOMString)
{
    opt_attribut := élément.donne_attribut(nom_attribut)
    si opt_attribut.possède_valeur() {
        valeur := parse_a_non_zero_dimension(opt_attribut.Quelque)
        si valeur.possède_valeur() {
            ajoute_propriété_pour_dimension(résolveuse, nom_propriété, valeur.Quelque)
        }
    }
}

ajoute_propriété_pour_nombre :: fonc (résolveuse: *CSS.RésolveuseStyle, nom_propriété: CSS.CSSOMString, valeur: r64)
{
    CSS.ajoute_presentational_hint(résolveuse, nom_propriété, CSS.crée_valeur_number(valeur))
}

ajoute_propriété_pour_dimension :: fonc (résolveuse: *CSS.RésolveuseStyle, nom_propriété: CSS.CSSOMString, valeur: DimensionValue)
{
    discr valeur {
        Percentage(p) {
            CSS.ajoute_presentational_hint(résolveuse, nom_propriété, CSS.crée_valeur_percentage(p))
        }
        Length(l) {
            CSS.ajoute_presentational_hint(résolveuse, nom_propriété, CSS.crée_valeur_pixels(l))
        }
        sinon {}
    }
}

ajoute_presentational_hints_pour_bordure :: fonc (résolveuse: *CSS.RésolveuseStyle, couleur: CouleurRVBAN8, largeur: DimensionValue, style: CSS.CSSOMString)
{
    CSS.ajoute_presentational_hint(résolveuse, CSS.PROP_border_bottom_color, CSS.crée_valeur_couleur(couleur))
    CSS.ajoute_presentational_hint(résolveuse, CSS.PROP_border_top_color, CSS.crée_valeur_couleur(couleur))
    CSS.ajoute_presentational_hint(résolveuse, CSS.PROP_border_left_color, CSS.crée_valeur_couleur(couleur))
    CSS.ajoute_presentational_hint(résolveuse, CSS.PROP_border_right_color, CSS.crée_valeur_couleur(couleur))

    ajoute_propriété_pour_mot_clé(résolveuse, CSS.PROP_border_bottom_style, style)
    ajoute_propriété_pour_mot_clé(résolveuse, CSS.PROP_border_top_style, style)
    ajoute_propriété_pour_mot_clé(résolveuse, CSS.PROP_border_left_style, style)
    ajoute_propriété_pour_mot_clé(résolveuse, CSS.PROP_border_right_style, style)

    ajoute_propriété_pour_dimension(résolveuse, CSS.PROP_border_bottom_width, largeur)
    ajoute_propriété_pour_dimension(résolveuse, CSS.PROP_border_top_width, largeur)
    ajoute_propriété_pour_dimension(résolveuse, CSS.PROP_border_left_width, largeur)
    ajoute_propriété_pour_dimension(résolveuse, CSS.PROP_border_right_width, largeur)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLButtonElement
 * https://html.spec.whatwg.org/multipage/form-elements.html#the-button-element
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLButtonElement
 * \{ */

#portée_export

HTMLButtonElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_button_element
}

#portée_fichier

table_virtuelle_button_element := TableVirtuelleElement(
    classe = HTMLButtonElement,
    sur_destruction = élément_sur_destruction,
    sur_changement_attribut = html_element_sur_changement_attribut,
    sur_applique_presentational_hints = button_element_sur_applique_presentational_hints
)

button_element_sur_changement_attribut :: fonc (base: *Element, local_name: DOMString, vieille_valeur: *DOMString, valeur: *DOMString, espace_de_nom: Optionnel(DOMString)) -> bool
{
    si html_element_sur_changement_attribut(base, local_name, vieille_valeur, valeur, espace_de_nom) {
        retourne vrai
    }

    button := base comme *HTMLButtonElement

    si local_name == ATTR_disabled {
        si valeur == nul {
            button.enlève_pseudo_classe(CSS.PseudoClasses.Disabled)
        }
        sinon {
            button.ajoute_pseudo_classe(CSS.PseudoClasses.Disabled)
        }

        retourne vrai
    }

    retourne faux
}

button_element_sur_applique_presentational_hints :: fonc (base: *Element, résolveuse: *CSS.RésolveuseStyle)
{
    /* NOTE : la stylisation ne se retrouve dans aucun standard. Elle reprend le style par défaut de firefox. */

    couleur_bordure := CouleurRVBAN8(143, 143, 157, 255)
    style_bordure := CSS.PROP_solid // outset
    largeur_bordure := DimensionValue(Length = 2.0)
    rayon_bordure := DimensionValue(Length = 4.0)
    padding_inline := DimensionValue(Length = 4.0)
    padding_block := DimensionValue(Length = 1.0)

    couleur_arrière_plan := si base.pseudo_classes.Active {
        CouleurRVBAN8(177, 177, 185, 255)
    }
    sinon si base.pseudo_classes.Hover {
        CouleurRVBAN8(208, 208, 208, 215)
    }
    sinon {
        CouleurRVBAN8(233, 233, 237, 255)
    }

    CSS.ajoute_presentational_hint(résolveuse, CSS.PROP_color, CSS.donne_valeur_couleur_noire())

    CSS.ajoute_presentational_hint(résolveuse, CSS.PROP_background_color, CSS.crée_valeur_couleur(couleur_arrière_plan))

    ajoute_propriété_pour_mot_clé(résolveuse, CSS.PROP_display, CSS.PROP_inline_block)

    ajoute_propriété_pour_dimension(résolveuse, CSS.PROP_padding_inline_start, padding_inline)
    ajoute_propriété_pour_dimension(résolveuse, CSS.PROP_padding_inline_end, padding_inline)

    ajoute_propriété_pour_dimension(résolveuse, CSS.PROP_padding_block_start, padding_block)
    ajoute_propriété_pour_dimension(résolveuse, CSS.PROP_padding_block_end, padding_block)

    ajoute_presentational_hints_pour_bordure(résolveuse, couleur_bordure, largeur_bordure, style_bordure)

    ajoute_propriété_pour_dimension(résolveuse, CSS.PROP_border_bottom_left_radius, rayon_bordure)
    ajoute_propriété_pour_dimension(résolveuse, CSS.PROP_border_bottom_right_radius, rayon_bordure)
    ajoute_propriété_pour_dimension(résolveuse, CSS.PROP_border_top_left_radius, rayon_bordure)
    ajoute_propriété_pour_dimension(résolveuse, CSS.PROP_border_top_right_radius, rayon_bordure)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLCanvasElement
 * https://html.spec.whatwg.org/multipage/canvas.html#the-canvas-element
 * \{ */

#portée_export

HTMLCanvasElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_canvas_element

    ctx: *RenderingContext
    context_id: DOMString

    tampon_de_rendu: TamponDeRendu
}

#portée_fichier

table_virtuelle_canvas_element := TableVirtuelleElement(
    classe = HTMLCanvasElement,
    sur_destruction = canvas_element_sur_destruction
)

canvas_element_sur_destruction :: fonc (base: *JS.Cellule)
{
    élément_sur_destruction(base)
    canvas := base comme *HTMLCanvasElement
    détruit_tampon_de_rendu(*canvas.tampon_de_rendu)
}

#portée_export

get_context :: fonc (canvas: *HTMLCanvasElement, context_id: DOMString) -> *RenderingContext
{
    si context_id == canvas.context_id {
        retourne canvas.ctx
    }

    si context_id.donne_chaine_utf16() == "2d" {
        résultat := crée_canvas_rendering_context_2d(canvas)
        canvas.ctx = résultat
        canvas.context_id = context_id
        retourne résultat
    }

    retourne nul
}

donne_largeur_intrinsèque :: fonc (canvas: *HTMLCanvasElement) -> r64
{
    opt_attribut := canvas.donne_attribut(ATTR_width)
    si opt_attribut.possède_valeur() {
        valeur := parse_a_non_zero_dimension(opt_attribut.Quelque)
        si valeur.possède_valeur() {
            retourne valeur.Quelque.Length
        }
    }

    retourne 300
}

donne_hauteur_intrinsèque :: fonc (canvas: *HTMLCanvasElement) -> r64
{
    opt_attribut := canvas.donne_attribut(ATTR_height)
    si opt_attribut.possède_valeur() {
        valeur := parse_a_non_zero_dimension(opt_attribut.Quelque)
        si valeur.possède_valeur() {
            retourne valeur.Quelque.Length
        }
    }

    retourne 150
}

donne_tampon_de_rendu :: fonc (canvas: *HTMLCanvasElement) -> TamponDeRendu
{
    hauteur := canvas.donne_hauteur_intrinsèque()
    largeur := canvas.donne_largeur_intrinsèque()
    rect: RectanglePosDim(z32)
    rect.hauteur = hauteur comme z32
    rect.largeur = largeur comme z32

    si canvas.tampon_de_rendu.rect.largeur != rect.largeur || canvas.tampon_de_rendu.rect.hauteur != rect.hauteur {
        redimensionne_tampon_de_rendu(*canvas.tampon_de_rendu, rect)

        pour & canvas.tampon_de_rendu.données {
            it = CouleurRVBAN8(0, 0, 0, 0)
        }
    }

    retourne canvas.tampon_de_rendu
}

// À FAIRE : [Reflect]
donne_width :: fonc (canvas: *HTMLCanvasElement) -> n32
{
    retourne canvas.donne_largeur_intrinsèque() comme n32
}
définis_width :: fonc (canvas: *HTMLCanvasElement, valeur: n32)
{
    // À FAIRE : standardise "set bitmap dimensions"
    chn := imprime_chaine("%", valeur)
    diffère déloge(chn)
    set_an_attribute_value(canvas, ATTR_width, crée_chaine_utf16_unique(chn))
}
donne_height :: fonc (canvas: *HTMLCanvasElement) -> n32
{
    retourne canvas.donne_hauteur_intrinsèque() comme n32
}
définis_height :: fonc (canvas: *HTMLCanvasElement, valeur: n32)
{
    chn := imprime_chaine("%", valeur)
    diffère déloge(chn)
    set_an_attribute_value(canvas, ATTR_height, crée_chaine_utf16_unique(chn))
}

/** } */

/* ------------------------------------------------------------------------- */
/** \nom HTMLFontElement
 * https://html.spec.whatwg.org/multipage/obsolete.html#htmlfontelement
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLFontElement
 * \{ */

#portée_export

HTMLFontElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_font_element
}

#portée_fichier

table_virtuelle_font_element := TableVirtuelleElement(
    classe = HTMLFontElement,
    sur_destruction = élément_sur_destruction,
    sur_changement_attribut = html_element_sur_changement_attribut,
    sur_applique_presentational_hints = font_element_sur_applique_presentational_hints
)

/* https://html.spec.whatwg.org/multipage/rendering.html#phrasing-content-3 */
font_element_sur_applique_presentational_hints :: fonc (base: *Element, résolveuse: *CSS.RésolveuseStyle)
{
    font := base comme *HTMLFontElement

    opt_color := donne_attribut(font, ATTR_color)
    si opt_color.possède_valeur() {
        color := opt_color.Quelque
        ajoute_propriété_pour_couleur(résolveuse, CSS.PROP_color, color)
    }

    opt_size := donne_attribut(font, ATTR_size)
    si opt_size.possède_valeur() {
        opt_font_size := parse_a_legacy_font_size(opt_size.Quelque)
        si opt_font_size.possède_valeur() {
            ajoute_propriété_pour_mot_clé(résolveuse, CSS.PROP_font_size, opt_font_size.Quelque)
        }
    }

    /* À FAIRE : face. */
}

/* https://html.spec.whatwg.org/multipage/rendering.html#rules-for-parsing-a-legacy-font-size */
parse_a_legacy_font_size :: fonc (attribute_value: DOMString) -> Optionnel(CSS.CSSOMString)
{
    // 1. Let input be the attribute's value.
    input := attribute_value.donne_chaine_utf16()

    // 2. Let position be a pointer into input, initially pointing at the start of the string.
    position := PositionVariable(input.unités.pointeur)

    // 3. Skip ASCII whitespace within input given position.
    skip_ascii_whitespace(input, *position)

    // 4. If position is past the end of input, there is no presentational hint. Return.
    fin := input.unités.pointeur + input.taille()
    si position.position >= fin {
        retourne
    }

    // 5. If the character at position is a U+002B PLUS SIGN character (+), then let mode be
    //    relative-plus, and advance position to the next character. Otherwise, if the character
    //    at position is a U+002D HYPHEN-MINUS character (-), then let mode be relative-minus,
    //    and advance position to the next character. Otherwise, let mode be absolute.
    ModeFonte :: énum {
        Aucun
        RelativePlus
        RelativeMinus
    }
    mode := ModeFonte.Aucun
    si mémoire(position.position) == 0x2B {
        mode = ModeFonte.RelativePlus
        position.position += 1
    }
    sinon si mémoire(position.position) == 0x2D {
        mode = ModeFonte.RelativeMinus
        position.position += 1
    }

    // 6. Collect a sequence of code points that are ASCII digits from input given position, and let the resulting sequence be digits.
    digits := collect_a_sequence_of_code_points(input, *position, est_chiffre_ascii_n16)

    // 7. If digits is the empty string, there is no presentational hint. Return.
    si digits.est_vide() {
        retourne
    }

    // 8. Interpret digits as a base-ten integer. Let value be the resulting number.
    value: z32
    pour digits.unités {
        value *= 10
        value += (it - '0' comme n16) comme z32
    }

    // 9. If mode is relative-plus, then increment value by 3.
    //    If mode is relative-minus, then let value be the result of subtracting value from 3.
    si mode == ModeFonte.RelativePlus {
        value += 3
    }
    sinon si mode == ModeFonte.RelativeMinus {
        value = 3 - value
    }

    // 10. If value is greater than 7, let it be 7.
    si value > 7 {
        value = 7
    }

    // 11. If value is less than 1, let it be 1.
    si value < 1 {
        value = 1
    }

    // 12. Set 'font-size' to the keyword corresponding to the value of value according to the following table:
    table := [CSS.PROP_x_small, CSS.PROP_small, CSS.PROP_medium, CSS.PROP_large, CSS.PROP_x_large, CSS.PROP_xx_large, CSS.PROP_xxx_large]
    retourne table[value - 1]
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLFormElement
 * https://html.spec.whatwg.org/multipage/forms.html#htmlformelement
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement
 * \{ */

#portée_export

HTMLFormElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_form_element

    constructing_entry_list: bool
    firing_submission_events: bool
    planned_navigation: *Algorithm
}

#portée_fichier

table_virtuelle_form_element := TableVirtuelleElement(
    classe = HTMLFormElement,
    sur_destruction = élément_sur_destruction,
    sur_changement_attribut = html_element_sur_changement_attribut
)

/* https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#concept-form-submit */
submit :: fonc (form: *HTMLFormElement, submitter: *Element, submitted_from_submit_method := faux, user_involvement := UserNavigationInvolvement.None)
{
    // 1. If form cannot navigate, then return.
    si cannot_navigate(form) {
        imprime("[%] cannot_navigate\n", #nom_de_cette_fonction)
        retourne
    }

    // 2. If form's constructing entry list is true, then return.
    si form.constructing_entry_list {
        retourne
    }

    // 3. Let form document be form's node document.
    form_document := form.document

    // 4. If form document's active sandboxing flag set has its sandboxed forms browsing context flag set, then return.
    si form_document.active_sandboxing_flags.Forms {
        retourne
    }

    // 5. If submitted from submit() method is false, then:
    saufsi submitted_from_submit_method {
        // 1. If form's firing submission events is true, then return.
        si form.firing_submission_events {
            retourne
        }

        // 2. Set form's firing submission events to true.
        form.firing_submission_events = vrai

        // 3. For each element field in the list of submittable elements whose form owner is form, set field's user validity to true.

        // 4. If the submitter element's no-validate state is false, then interactively validate the constraints of form and examine the result. If the result is negative (i.e., the constraint validation concluded that there were invalid fields and probably informed the user of this), then:

            // 1. Set form's firing submission events to false.

            // 2. Return.

        // 5. Let submitterButton be null if submitter is form. Otherwise, let submitterButton be submitter.

        // 6. Let shouldContinue be the result of firing an event named submit at form using SubmitEvent, with the submitter attribute initialized to submitterButton, the bubbles attribute initialized to true, and the cancelable attribute initialized to true.

        // 7. Set form's firing submission events to false.
        form.firing_submission_events = faux

        // 8. If shouldContinue is false, then return.

        // 9. If form cannot navigate, then return.
        si cannot_navigate(form) {
            retourne
        }
    }

    // À FAIRE : 6. Let encoding be the result of picking an encoding for the form.

    // 7. Let entry list be the result of constructing the entry list with form, submitter, and encoding.
    // @fuite-de-mémoire (ceci est passé à navigate() via une tâche
    entry_list := construct_the_entry_list(form, submitter)

    // 8. Assert: entry list is not null.
    assert(entry_list != nul)

    // 9. If form cannot navigate, then return.
    si cannot_navigate(form) {
        retourne
    }

    // 10. Let method be the submitter element's method.
    method := donne_method(submitter)

    // 11. If method is dialog, then:
    si method == ATTR_dialog {
        imprime("[%] À FAIRE : dialog\n", #nom_de_cette_fonction)
        // If form does not have an ancestor dialog element, then return.

        // Let subject be form's nearest ancestor dialog element.

        // Let result be null.

        // If submitter is an input element whose type attribute is in the Image Button state, then:

        // Let (x, y) be the selected coordinate.

        // Set result to the concatenation of x, ",", and y.

        // Otherwise, if submitter has a value, then set result to that value.

        // Close the dialog subject with result.

        // Return.
        retourne
    }

    // 12. Let action be the submitter element's action.
    action := copie_chaine(donne_action(submitter).donne_chaine_utf16())
    diffère détruit_chaine(action)

    // 13. If action is the empty string, let action be the URL of the form document.
    si action.est_vide() {
        chn_action := url_serializer(form.document.url)
        action = crée_chaine_utf16(chn_action)
        déloge(chn_action)
    }

    // 14. Let parsed action be the result of encoding-parsing a URL given action, relative to submitter's node document.
    parsed_action := encoding_parse_a_url(action, submitter.document)

    // 15. If parsed action is failure, then return.
    saufsi parsed_action {
        retourne
    }

    // 16. Let scheme be the scheme of parsed action.

    // 17. Let enctype be the submitter element's enctype.

    // 18. Let formTarget be null.
    form_target := crée_chaine_utf16_unique_vide()

    // À FAIRE : 19. If the submitter element is a submit button and it has a formtarget attribute, then set formTarget to the formtarget attribute value.

    // 20. Let target be the result of getting an element's target given submitter's form owner and formTarget.
    target := get_an_element_s_target(donne_form_owner(submitter), form_target)
    // si ce n'est pas vide il faut implémenter les deux étapes suivantes
    assert(target.est_vide())

    // 21. Let noopener be the result of getting an element's noopener with form, parsed action, and target.

    // 22. Let targetNavigable be the first return value of applying the rules for choosing a navigable given target, form's node navigable, and noopener.
    target_navigable := form.donne_node_navigable()

    // 23. If targetNavigable is null, then return.
    saufsi target_navigable {
        retourne
    }

    // 24. Let historyHandling be "auto".
    history_handling := NavigationHistoryBehavior.AUTO

    // À FAIRE 25. If form document equals targetNavigable's active document, and form document has not yet completely loaded, then set historyHandling to "replace".

    // À FAIRE : 26. Select the appropriate row in the table below based on scheme as given by the first cell of each row. Then, select the appropriate cell on that row based on method as given in the first cell of each column. Then, jump to the steps named in that cell and defined below the table.
    assert(method == ATTR_get)

    params: ParamètresNavigationNavigable
    params.url = parsed_action
    params.source_document = form.document
    params.history_handling = history_handling
    params.user_involvement = user_involvement
    params.form_data_entry_list = entry_list
    mutate_action_url(form, entry_list, parsed_action, target_navigable, params)
}

#portée_module

/* https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#constructing-form-data-set */
EntryList :: struct {
    Entry :: struct {
        name: chaine
        value: chaine
    }

    entries: [..]Entry
}

détruit_entry_list :: fonc (entry_list: *EntryList)
{
    pour entry_list.entries {
        déloge(it.name)
        déloge(it.value)
    }

    déloge(entry_list.entries)
    déloge(entry_list)
}

#portée_fichier

/* https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#constructing-the-form-data-set */
construct_the_entry_list :: fonc (form: *HTMLFormElement, submitter : *Element = nul @inutilisée) -> *EntryList
{
    // 1. If form's constructing entry list is true, then return null.
    si form.constructing_entry_list {
        retourne nul
    }

    // 2. Set form's constructing entry list to true.
    form.constructing_entry_list = vrai

    // 3. Let controls be a list of all the submittable elements whose form owner is form, in tree order.
    controls := donne_submittable_elements(form)
    diffère déloge(controls)

    // 4. Let entry list be a new empty entry list.
    entry_list := loge(EntryList)

    // 5. For each element field in controls, in tree order:
    pour field dans controls {
        si field.table.classe == HTMLInputElement {
            name := field.donne_attribut_ou_chaine_vide(ATTR_name)
            saufsi name.est_vide() {
                entry := tableau_ajoute_élément(*entry_list.entries)
                entry.name = converti_vers_chaine(name.donne_chaine_utf16())
                entry.value = converti_vers_chaine(donne_value(field comme *HTMLInputElement))
            }
        }

        // À FAIRE If any of the following are true:

        // field has a datalist element ancestor;

        // field is disabled;

        // field is a button but it is not submitter;

        // field is an input element whose type attribute is in the Checkbox state and whose checkedness is false; or

        // field is an input element whose type attribute is in the Radio Button state and whose checkedness is false,

        // then continue.

        // If the field element is an input element whose type attribute is in the Image Button state, then:

        // If the field element is not submitter, then continue.

        // If the field element has a name attribute specified and its value is not the empty string, let name be that value followed by U+002E (.). Otherwise, let name be the empty string.

        // Let namex be the concatenation of name and U+0078 (x).

        // Let namey be the concatenation of name and U+0079 (y).

        // Let (x, y) be the selected coordinate.

        // Create an entry with namex and x, and append it to entry list.

        // Create an entry with namey and y, and append it to entry list.

        // Continue.

        // If the field is a form-associated custom element, then perform the entry construction algorithm given field and entry list, then continue.

        // If either the field element does not have a name attribute specified, or its name attribute's value is the empty string, then continue.

        // Let name be the value of the field element's name attribute.

        // If the field element is a select element, then for each option element in the select element's list of options whose selectedness is true and that is not disabled, create an entry with name and the value of the option element, and append it to entry list.

        // Otherwise, if the field element is an input element whose type attribute is in the Checkbox state or the Radio Button state, then:

        // If the field element has a value attribute specified, then let value be the value of that attribute; otherwise, let value be the string "on".

        // Create an entry with name and value, and append it to entry list.

        // Otherwise, if the field element is an input element whose type attribute is in the File Upload state, then:

        // If there are no selected files, then create an entry with name and a new File object with an empty name, application/octet-stream as type, and an empty body, and append it to entry list.

        // Otherwise, for each file in selected files, create an entry with name and a File object representing the file, and append it to entry list.

        // Otherwise, if the field element is an input element whose type attribute is in the Hidden state and name is an ASCII case-insensitive match for "_charset_":

        // Let charset be the name of encoding.

        // Create an entry with name and charset, and append it to entry list.

        // Otherwise, create an entry with name and the value of the field element, and append it to entry list.

        // If the element has a dirname attribute, that attribute's value is not the empty string, and the element is an auto-directionality form-associated element:

        // Let dirname be the value of the element's dirname attribute.

        // Let dir be the string "ltr" if the directionality of the element is 'ltr', and "rtl" otherwise (i.e., when the directionality of the element is 'rtl').

        // Create an entry with dirname and dir, and append it to entry list.
    }

    // À FAIRE 6. Let form data be a new FormData object associated with entry list.

    // 7. Fire an event named formdata at form using FormDataEvent, with the formData attribute initialized to form data and the bubbles attribute initialized to true.

    // 8. Set form's constructing entry list to false.
    form.constructing_entry_list = faux

    // 9. Return a clone of entry list.
    retourne entry_list
}

donne_submittable_elements :: fonc (form: *HTMLFormElement) -> [..]*Element
{
    résultat: [..]*Element

    traversée: [..]*Node
    diffère déloge(traversée)

    pour > form.enfants {
        tableau_ajoute(*traversée, it)
    }

    tantque traversée.taille != 0 {
        noeud := traversée[traversée.taille - 1]
        traversée.taille -= 1

        si noeud.est_élément() && is_submittable_element(noeud comme *Element) {
            élément := noeud comme *Element
            form_owner := donne_form_owner(élément)
            si form_owner == form {
                tableau_ajoute(*résultat, élément)
            }
        }

        pour > noeud.enfants {
            tableau_ajoute(*traversée, it)
        }
    }

    retourne résultat
}

/* https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#concept-fs-action */
donne_action :: fonc (élément: *Element) -> DOMString
{
    résultat := donne_attribut_ou_chaine_vide(élément, ATTR_formaction)
    si résultat.est_vide() {
        form_owner := donne_form_owner(élément)
        assert(form_owner != nul)
        résultat = donne_attribut_ou_chaine_vide(form_owner, ATTR_action)
    }
    retourne résultat
}

/* https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#concept-fs-method */
donne_method :: fonc (élément: *Element) -> DOMString
{
    résultat := donne_attribut_ou_chaine_vide(élément, ATTR_formmethod)
    si résultat.est_vide() {
        form_owner := donne_form_owner(élément)
        assert(form_owner != nul)
        résultat = donne_attribut_ou_chaine_vide(form_owner, ATTR_method)
    }

    /* https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#attr-fs-method */
    si résultat.est_vide() {
        retourne ATTR_get
    }

    si résultat != ATTR_get && résultat != ATTR_post && résultat != ATTR_dialog {
        retourne ATTR_get
    }

    retourne résultat
}

/* https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#submit-mutate-action */
mutate_action_url :: fonc (form: *HTMLFormElement, entry_list: *EntryList, parsed_action: *URL, target_navigable: *Navigable, params: ParamètresNavigationNavigable)
{
    assert(parsed_action == params.url)

    // À FAIRE Let pairs be the result of converting to a list of name-value pairs with entry list.
    enchaineuse: Enchaineuse
    initialise_enchaineuse(*enchaineuse)
    diffère détruit_tampons(*enchaineuse)

    séparateur := ""
    pour entry_list.entries {
        ajoute_au_tampon(*enchaineuse, séparateur, it.name, "=", it.value)
        séparateur = "&"
    }

    pairs := chaine_depuis_enchaineuse(*enchaineuse)

    // À FAIRE : Let query be the result of running the application/x-www-form-urlencoded serializer with pairs and encoding.
    query := pairs

    // Set parsed action's query component to query.
    parsed_action.query = query

    // Plan to navigate to parsed action.
    plan_to_navigate(form, target_navigable, params)
}

/* https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plan-to-navigate */
plan_to_navigate :: fonc (form: *HTMLFormElement, target_navigable: *Navigable, params: ParamètresNavigationNavigable)
{
    // À FAIRE 1. Let referrerPolicy be the empty string.

    // 2. If the form element's link types include the noreferrer keyword, then set referrerPolicy to "no-referrer".

    // 3. If the form has a non-null planned navigation, remove it from its task queue.
    assert(form.planned_navigation == nul)

    // 4. Queue an element task on the DOM manipulation task source given the form element and the following steps:
    Tâche :: struct {
        empl base: Algorithm

        form: *HTMLFormElement
        target_navigable: *Navigable
        params: ParamètresNavigationNavigable
    }

    sur_run :: fonc (base: *Algorithm)
    {
        empl tâche := base comme *Tâche

        // 1. Set the form's planned navigation to null.
        form.planned_navigation = nul

        // 2. Navigate targetNavigable to url using the form element's node document,
        //    with historyHandling set to historyHandling, userInvolvement set to userInvolvement,
        //    sourceElement set to submitter, referrerPolicy set to referrerPolicy,
        //    documentResource set to postResource, and formDataEntryList set to entry list.
        navigate(params.source_document.donne_user_agent(), target_navigable, params)
    }

    tâche := crée_algorithm(sur_run, Tâche)
    tâche.form = form
    tâche.target_navigable = target_navigable
    tâche.params = params

    user_agent := params.source_document.donne_user_agent()
    user_agent.queue_an_element_task(SourceDeTâche.ManipulationDOM, form, tâche)

    // 5. Set the form's planned navigation to the just-queued task.
    form.planned_navigation = tâche
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLHeadElement
 * https://html.spec.whatwg.org/multipage/dom.html#htmlheadelement
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLHeadElement
 * \{ */

#portée_export

HTMLHeadElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_head_element
}

#portée_fichier

table_virtuelle_head_element := TableVirtuelleElement(
    classe = HTMLHeadElement,
    sur_destruction = élément_sur_destruction,
    sur_changement_attribut = html_element_sur_changement_attribut
)

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLHeadingElement
 * https://html.spec.whatwg.org/multipage/sections.html#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLHeadingElement
 * \{ */

#portée_export

HTMLHeadingElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_heading_element
}

#portée_fichier

table_virtuelle_heading_element := TableVirtuelleElement(
    classe = HTMLHeadingElement,
    sur_destruction = élément_sur_destruction,
    sur_changement_attribut = html_element_sur_changement_attribut
)

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLHRElement
 * https://html.spec.whatwg.org/multipage/grouping-content.html#the-hr-element
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLHRElement
 * \{ */

#portée_export

HTMLHRElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_hr_element
}

#portée_fichier

table_virtuelle_hr_element := TableVirtuelleElement(
    classe = HTMLHRElement,
    sur_destruction = élément_sur_destruction,
    sur_changement_attribut = html_element_sur_changement_attribut
)

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLHtmlElement
 * https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLHtmlElement
 * \{ */

#portée_export

HTMLHtmlElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_html_html_element
}

#portée_fichier

table_virtuelle_html_html_element := TableVirtuelleElement(
    classe = HTMLHtmlElement,
    sur_destruction = élément_sur_destruction,
    sur_changement_attribut = html_element_sur_changement_attribut
)

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLIFrameElement
 * https://html.spec.whatwg.org/multipage/iframe-embed-object.html#the-iframe-element
 * \{ */

#portée_export

HTMLIFrameElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_iframe_element

    /* À FAIRE : remplis depuis l'attribut sandbox
     * https://html.spec.whatwg.org/multipage/browsers.html#iframe-sandboxing-flag-set */
    iframe_sandboxing_flags: SandboxingFlags
}

#portée_fichier

table_virtuelle_iframe_element := TableVirtuelleElement(
    classe = HTMLIFrameElement,
    sur_destruction = élément_sur_destruction,
    sur_changement_attribut = html_element_sur_changement_attribut
)

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLImageElement
 * https://html.spec.whatwg.org/multipage/embedded-content.html#htmlimageelement
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement
 * \{ */

#portée_export

HTMLImageElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_image_element

    image_data: NouvelleImage
}

donne_src :: fonc (image: *HTMLImageElement) -> DOMString
{
    retourne donne_attribut_ou_chaine_vide(image, ATTR_src)
}

donne_hauteur_intrinsèque :: fonc (image: *HTMLImageElement) -> z32 #enligne
{
    retourne image.image_data.desc.hauteur comme z32
}

donne_largeur_intrinsèque :: fonc (image: *HTMLImageElement) -> z32 #enligne
{
    retourne image.image_data.desc.largeur comme z32
}

donne_ratio_intrinsèque :: fonc (image: *HTMLImageElement) -> r32 #enligne
{
    si image.image_data.desc.hauteur == 0 {
        retourne 1.0
    }

    retourne image.image_data.desc.largeur comme r32 / image.image_data.desc.hauteur comme r32
}

ReprésentationImage :: énum {
    // L'élement représente l'image.
    IMAGE
    // L'élément représente le texte de l'attribut alt.
    TEXTE_ALT
    // L'élément ne représente rien.
    RIEN
}

donne_représentation_image :: fonc (img: *HTMLImageElement) -> ReprésentationImage
{
    attr_src := cherche_attribut(img, ATTR_src)
    attr_alt := cherche_attribut(img, ATTR_alt)

    si attr_src && !attr_src.valeur.est_vide() {
        si img.image_data.données {
            retourne ReprésentationImage.IMAGE
        }
    }
    
    si attr_alt && !attr_alt.valeur.est_vide() {
        retourne ReprésentationImage.TEXTE_ALT
    }

    retourne ReprésentationImage.RIEN
}

#portée_fichier

table_virtuelle_image_element := TableVirtuelleElement(
    classe = HTMLImageElement,
    sur_destruction = image_element_sur_destruction,
    sur_changement_attribut = image_element_sur_changement_attribut,
    sur_applique_presentational_hints = image_element_sur_applique_presentational_hints
)

image_element_sur_changement_attribut :: fonc (base: *Element, local_name: DOMString, vieille_valeur: *DOMString, valeur: *DOMString, espace_de_nom: Optionnel(DOMString)) -> bool
{
    si html_element_sur_changement_attribut(base, local_name, vieille_valeur, valeur, espace_de_nom) {
        retourne vrai
    }

    image := base comme *HTMLImageElement

    si local_name == ATTR_src {
        update_image_data(image)
        retourne vrai
    }

    retourne faux
}

image_element_sur_applique_presentational_hints :: fonc (base: *Element, résolveuse: *CSS.RésolveuseStyle)
{
    ajoute_propriété_pour_dimension(résolveuse, base, ATTR_width, CSS.PROP_width)
    ajoute_propriété_pour_dimension(résolveuse, base, ATTR_height, CSS.PROP_height)
}

image_element_sur_destruction :: fonc (base: *JS.Cellule)
{
    élément := base comme *HTMLImageElement
    élément_détruit_données(élément)
    détruit_données_image(*élément.image_data)
}

/* https://html.spec.whatwg.org/multipage/images.html#update-the-image-data */
update_image_data :: fonc (image: *HTMLImageElement)
{
    // À FAIRE : standardise
    document := image.document
    user_agent := document.donne_user_agent()
    saufsi user_agent {
        retourne
    }

    détruit_données_image(*image.image_data)
    image.image_data = NouvelleImage()

    src := image.donne_src()
    si src.est_vide() {
        document.invalide_style()
        retourne
    }

    base_url := donne_base_url(document)

    url_src := url_parser(user_agent, src.donne_chaine_utf16(), base = base_url)
    saufsi url_src {
        retourne
    }

    request := loge(Request)
    request.client = image.donne_relevant_settings_object()
    request.destination = Request.DestinationType.Image
    request.mode = Request.Mode.No_CORS
    request.redirect_mode = Request.RedirectMode.Follow
    request.définis_url(url_src)

    RappelProcessResponse :: struct {
        empl base: BaseProcessResponse

        request: *Request
        user_agent: *UserAgent
        image: *HTMLImageElement
    }

    sur_rappel_process_response :: fonc (base: *BaseProcessResponse, réponse: *Response)
    {
        diffère détruit_response(réponse)

        rappel := base comme *RappelProcessResponse

        saufsi réponse.body_info {
            enfile_une_tâche_pour_lancer_évènement_à_élément(rappel.user_agent, rappel.image, EventType.error)
            retourne
        }

        content_type := réponse.body_info.content_type
        saufsi est_type_mime_image(content_type) {
            enfile_une_tâche_pour_lancer_évènement_à_élément(rappel.user_agent, rappel.image, EventType.error)
            retourne
        }

        contenu := réponse.body.Quelque

        _ := décode_image(contenu, content_type, *rappel.image.image_data)

        invalide_style(rappel.image.document)
        enfile_une_tâche_pour_lancer_évènement_à_élément(rappel.user_agent, rappel.image, EventType.load)
    }

    sur_destruction_process_response :: fonc (base: *BaseProcessResponse)
    {
        rappel := base comme *RappelProcessResponse
        détruit_request(rappel.request)
        déloge(rappel)
    }

    process_response := loge(RappelProcessResponse)
    process_response.image = image
    process_response.user_agent = user_agent
    process_response.request = request
    process_response.sur_rappel = sur_rappel_process_response
    process_response.sur_destruction = sur_destruction_process_response

    fetch_controller := fetch(user_agent, request, process_response = process_response)
    diffère détruit_fetch_controller(fetch_controller)
}

#portée_export

décode_image :: fonc (contenu: chaine, content_type: chaine, résultat: *NouvelleImage) -> bool
{
    succès, image := décode_image(contenu, content_type)
    si succès {
        mémoire(résultat) = image
    }
    retourne succès
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLInputElement
 * https://html.spec.whatwg.org/multipage/input.html#htmlinputelement
 * \{ */

#portée_export

HTMLInputElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_input_element

    State :: énum {
        Hidden
        Text
        Search
        Telephone
        URL
        Email
        Password
        Date
        Month
        Week
        Time
        Local_Date_and_Time
        Number
        Range
        Color
        Checkbox
        Radio_Button
        File_Upload
        Submit_Button
        Image_Button
        Reset_Button
        Button
    }

    /* https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#concept-fe-dirty */
    dirty_value: bool

    /* https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#concept-fe-checked */
    checkedness: bool

    /* https://html.spec.whatwg.org/multipage/input.html#concept-input-checked-dirty-flag */
    dirty_checkedness: bool

    /* https://html.spec.whatwg.org/multipage/input.html#dom-input-indeterminate */
    indeterminate: bool

    éditrice: *ÉditriceTexte

    /* À FAIRE : déplace ceci dans CSS. */
    texte_mot_de_passe: ChaineUTF16
}

donne_state :: fonc (input: *HTMLInputElement) -> HTMLInputElement.State
{
    opt_type := donne_attribut(input, ATTR_type)
    saufsi opt_type.possède_valeur() {
        /* "The attribute's missing value default and invalid value default are both the Text state."
         * https://html.spec.whatwg.org/multipage/input.html#attr-input-type
         *
         * À FAIRE : détermine l'état de l'attribut :
         * https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#missing-value-default */
        retourne HTMLInputElement.State.Text
    }

    type := opt_type.Quelque

    si type == ATTR_hidden {
        retourne HTMLInputElement.State.Hidden
    }
    si type == ATTR_text {
        retourne HTMLInputElement.State.Text
    }
    si type == ATTR_submit {
        retourne HTMLInputElement.State.Submit_Button
    }
    si type == ATTR_reset {
        retourne HTMLInputElement.State.Reset_Button
    }
    si type == ATTR_button {
        retourne HTMLInputElement.State.Button
    }
    si type == ATTR_radio {
        retourne HTMLInputElement.State.Radio_Button
    }
    si type == ATTR_search {
        retourne HTMLInputElement.State.Search
    }
    si type == ATTR_tel {
        retourne HTMLInputElement.State.Telephone
    }
    si type == ATTR_url {
        retourne HTMLInputElement.State.URL
    }
    si type == ATTR_email {
        retourne HTMLInputElement.State.Email
    }
    si type == ATTR_password {
        retourne HTMLInputElement.State.Password
    }
    si type == ATTR_date {
        retourne HTMLInputElement.State.Date
    }
    si type == ATTR_month {
        retourne HTMLInputElement.State.Month
    }
    si type == ATTR_week {
        retourne HTMLInputElement.State.Week
    }
    si type == ATTR_time {
        retourne HTMLInputElement.State.Time
    }
    si type == ATTR_datetime_local {
        retourne HTMLInputElement.State.Local_Date_and_Time
    }
    si type == ATTR_number {
        retourne HTMLInputElement.State.Number
    }
    si type == ATTR_range {
        retourne HTMLInputElement.State.Range
    }
    si type == ATTR_color {
        retourne HTMLInputElement.State.Color
    }
    si type == ATTR_checkbox {
        retourne HTMLInputElement.State.Checkbox
    }
    si type == ATTR_file {
        retourne HTMLInputElement.State.File_Upload
    }
    si type == ATTR_image {
        retourne HTMLInputElement.State.Image_Button
    }

    retourne HTMLInputElement.State.Text
}

/* https://html.spec.whatwg.org/multipage/rendering.html#the-input-element-as-a-text-entry-widget */
is_text_entry_widget :: fonc (input: *HTMLInputElement) -> bool
{
    discr donne_state(input) {
        Text,
        Telephone,
        URL,
        Email,
        Search,
        Password {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

/* https://html.spec.whatwg.org/multipage/rendering.html#the-input-element-as-a-button */
is_button_widget :: fonc (input: *HTMLInputElement) -> bool
{
    discr donne_state(input) {
        Submit_Button,
        Reset_Button,
        Button {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

/* https://html.spec.whatwg.org/multipage/rendering.html#the-input-element-as-a-checkbox-and-radio-button-widgets */
is_radio_button_widget :: fonc (input: *HTMLInputElement) -> bool
{
    retourne donne_state(input) == HTMLInputElement.State.Radio_Button
}

is_checkbox_widget :: fonc (input: *HTMLInputElement) -> bool
{
    retourne donne_state(input) == HTMLInputElement.State.Checkbox
}

/* The checked IDL attribute allows scripts to manipulate the checkedness of an input element.
 * On getting, it must return the current checkedness of the element;
 * and on setting, it must set the element's checkedness to the new value and set the
 * element's dirty checkedness flag to true.
 * https://html.spec.whatwg.org/multipage/input.html#dom-input-checked */
donne_checked :: fonc (input: *HTMLInputElement) -> bool
{
    retourne input.checkedness
}

définis_checked :: fonc (input: *HTMLInputElement, valeur: bool)
{
    input.définis_checkedness(valeur)
    input.dirty_checkedness = vrai
}

définis_checkedness :: fonc (input: *HTMLInputElement, valeur: bool)
{
    input.checkedness = valeur

    si input.checkedness && input.is_radio_button_widget() {
        réinitialise_checkedness_radio_button_group(input)
    }
}

/* When any of the following phenomena occur, if the element's checkedness state is true after the occurrence,
 * the checkedness state of all the other elements in the same radio button group must be set to false:
 *
 * [X] The element's checkedness state is set to true (for whatever reason).
 * [ ] The element's name attribute is set, changed, or removed.
 * [ ] The element's form owner changes.
 * [ ] A type change is signalled for the element.
 * [ ] The element becomes connected.
 * https://html.spec.whatwg.org/multipage/input.html#radio-button-state-(type=radio) */
réinitialise_checkedness_radio_button_group :: fonc (racine: *HTMLInputElement)
{
    traverse_document_pour_radio_button_group :: fonc (noeud: *Node, input: *HTMLInputElement) -> DécisionTraversée
    {
        si noeud != input && noeud.table.classe == HTMLInputElement {
            noeud_input := noeud comme *HTMLInputElement
            si sont_dans_même_radio_button_group(input, noeud_input) {
                noeud_input.checkedness = faux
            }
        }

        retourne DécisionTraversée.CONTINUE
    }

    traverse_noeud(racine.document, traverse_document_pour_radio_button_group, racine)
}

/* https://html.spec.whatwg.org/multipage/input.html#radio-button-group */
sont_dans_même_radio_button_group :: fonc (a: *HTMLInputElement, b: *HTMLInputElement) -> bool
{
    // The input element b's type attribute is in the Radio Button state.
    saufsi b.is_radio_button_widget() {
        retourne faux
    }

    // Either a and b have the same form owner, or they both have no form owner.
    form_owner_a := donne_form_owner(a)
    form_owner_b := donne_form_owner(b)
    si form_owner_a != form_owner_b {
        retourne faux
    }

    // À FAIRE : Both a and b are in the same tree.

    // They both have a name attribute, their name attributes are not empty, and
    //  the value of a's name attribute equals the value of b's name attribute.
    name_a := a.donne_attribut_ou_chaine_vide(ATTR_name)
    name_b := b.donne_attribut_ou_chaine_vide(ATTR_name)

    si name_a != name_b {
        retourne faux
    }

    si name_a.est_vide() {
        retourne faux
    }

    retourne vrai
}

/* https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#form-owner */
donne_form_owner :: fonc (élément: *Element) -> *HTMLFormElement
{
    // À FAIRE : respecte le standard

    parent := élément.parent
    tantque parent != nul {
        si parent.table.classe == HTMLFormElement {
            retourne parent comme *HTMLFormElement
        }

        parent = parent.parent
    }

    retourne nul
}

/* https://html.spec.whatwg.org/multipage/input.html#dom-input-value */
définis_value :: fonc (input: *HTMLInputElement, value: DOMString)
{
    // À FAIRE : value à un "mode"
    // À FAIRE : 1. Let oldValue be the element's value.

    // 2. Set the element's value to the new value.
    crée_shadow_root_pour_édition(input)
    noeud_texte := input.donne_noeud_texte_value()
    détruit_chaine(noeud_texte.données)
    noeud_texte.données = copie_chaine(value.donne_chaine_utf16())

    // 3. Set the element's dirty value flag to true.
    input.dirty_value = vrai

    // 4. Invoke the value sanitization algorithm, if the element's type attribute's current state defines one.
    run_value_sanitization_algorithm(input)

    // 5. If the element's value (after applying the value sanitization algorithm) is different from oldValue, and the element has a text entry cursor position, move the text entry cursor position to the end of the text control, unselecting any selected text and resetting the selection direction to "none".
}

donne_value :: fonc (input: *HTMLInputElement) -> ChaineUTF16
{
    si input.shadow_root {
        noeud_texte := input.donne_noeud_texte_value()
        retourne noeud_texte.données
    }

    retourne donne_attribut_ou_chaine_vide(input, ATTR_value).donne_chaine_utf16()
}

crée_shadow_root_pour_édition :: fonc (input: *HTMLInputElement)
{
    si input.shadow_root {
        retourne
    }

    shadow_root := crée_shadow_root(input.document)
    noeud_texte := crée_noeud_texte(input.document)
    shadow_root.ajoute_enfant(noeud_texte)

    value := input.donne_attribut_ou_chaine_vide(ATTR_value).donne_chaine_utf16()
    noeud_texte.données = copie_chaine(value)

    input.shadow_root = shadow_root
    shadow_root.host = input
}

#portée_fichier

table_virtuelle_input_element := TableVirtuelleElement(
    classe = HTMLInputElement,
    sur_destruction = input_element_sur_destruction,
    sur_changement_attribut = input_element_sur_changement_attribut,
    sur_applique_presentational_hints = input_element_sur_applique_presentational_hints,
    sur_activation_behavior = input_element_sur_activation_behavior
)

input_element_sur_destruction :: fonc (base: *JS.Cellule)
{
    élément := base comme *HTMLInputElement
    élément_détruit_données(élément)
    détruit_chaine(élément.texte_mot_de_passe)
}

input_element_sur_applique_presentational_hints :: fonc (base: *Element, résolveuse: *CSS.RésolveuseStyle)
{
    si is_button_widget(base comme *HTMLInputElement) {
        button_element_sur_applique_presentational_hints(base, résolveuse)
        retourne
    }

    couleur_bordure := CouleurRVBAN8(143, 143, 157, 255)
    style_bordure := CSS.PROP_solid
    largeur_bordure := DimensionValue(Length = 1.0)
    ajoute_presentational_hints_pour_bordure(résolveuse, couleur_bordure, largeur_bordure, style_bordure)
}

input_element_sur_changement_attribut :: fonc (base: *Element, local_name: DOMString, vieille_valeur: *DOMString, valeur: *DOMString, espace_de_nom: Optionnel(DOMString)) -> bool
{
    si html_element_sur_changement_attribut(base, local_name, vieille_valeur, valeur, espace_de_nom) {
        retourne vrai
    }

    input := base comme *HTMLInputElement

    si local_name == ATTR_type {
        invalide_style_depuis_élément(input.document, input)
        retourne vrai
    }

    si local_name == ATTR_checked {
        /* The checked content attribute is a boolean attribute that gives the default checkedness
         * of the input element. When the checked content attribute is added, if the control does
         * not have dirty checkedness, the user agent must set the checkedness of the element to
         * true; when the checked content attribute is removed, if the control does not have dirty
         * checkedness, the user agent must set the checkedness of the element to false.
         * https://html.spec.whatwg.org/multipage/input.html#attr-input-checked */
        si valeur != nul {
            saufsi input.dirty_checkedness {
                input.définis_checkedness(vrai)
            }
        }
        sinon {
            saufsi input.dirty_checkedness {
                input.définis_checkedness(faux)
            }
        }
        retourne vrai
    }

    si local_name == ATTR_value {
        /* https://html.spec.whatwg.org/multipage/input.html#attr-input-value */
        saufsi input.dirty_value {
            si input.shadow_root {
                noeud_texte := input.donne_noeud_texte_value()
                détruit_chaine(noeud_texte.données)
                si valeur {
                    noeud_texte.données = copie_chaine(mémoire(valeur).donne_chaine_utf16())
                    run_value_sanitization_algorithm(input)
                }
            }
        }
        retourne vrai
    }

    retourne faux
}

/* https://html.spec.whatwg.org/multipage/input.html */
input_element_sur_activation_behavior :: fonc (target: *EventTarget, event: *Event)
{
    input := target comme *HTMLInputElement

    // À FAIRE 1. If element is not mutable, and element's type attribute is neither in the Checkbox nor in the Radio state, then return.

    // 2. Run element's input activation behavior, if any, and do nothing otherwise.
    run_input_activation_behavior(input, event)

    // 3. If element has a form owner and element's type attribute is not in the Button state, then return.

    // 4. Run the popover target attribute activation behavior given element and event's target.
}

run_input_activation_behavior :: fonc (input: *HTMLInputElement, event: *Event)
{
    state := donne_state(input)

    /* https://html.spec.whatwg.org/multipage/input.html#radio-button-state-(type=radio)
     * https://html.spec.whatwg.org/multipage/input.html#checkbox-state-(type=checkbox) */
    si state == HTMLInputElement.State.Radio_Button || state == HTMLInputElement.State.Checkbox {
        // 1. If the element is not connected, then return.
        saufsi est_connecté(input) {
            retourne
        }

        // 2. Fire an event named input at the element with the bubbles and composed attributes initialized to true.
        _ := fire_an_event(input, EventType.input, ConfigurationIDLAttributes(bubbles = vrai, composed = vrai))

        // 3. Fire an event named change at the element with the bubbles attribute initialized to true.
        _ := fire_an_event(input, EventType.change, ConfigurationIDLAttributes(bubbles = vrai))

        retourne
    }

    /* https://html.spec.whatwg.org/multipage/input.html#submit-button-state-(type=submit) */
    si state == HTMLInputElement.State.Submit_Button {
        // 1. If the element does not have a form owner, then return.
        form_owner := donne_form_owner(input)
        si form_owner == nul {
            imprime("[%] pas de form owner\n", #nom_de_cette_fonction)
            retourne
        }

        // 2. If the element's node document is not fully active, then return.
        saufsi input.document.est_fully_active() {
            imprime("[%] document non fully active\n", #nom_de_cette_fonction)
            retourne
        }

        // 3. Submit the element's form owner from the element with userInvolvement set to event's user navigation involvement.
        submit(form_owner, input, user_involvement = donne_user_navigation_involvement(event))
        retourne
    }
}

// The legacy-pre-activation behavior for input elements are these steps:
// The legacy-canceled-activation behavior for input elements are these steps:

/* https://html.spec.whatwg.org/multipage/input.html#value-sanitization-algorithm */
run_value_sanitization_algorithm :: fonc (input: *HTMLInputElement)
{
    state := donne_state(input)

    si state == HTMLInputElement.State.Text || state == HTMLInputElement.State.Search || state == HTMLInputElement.State.Telephone || state == HTMLInputElement.State.Password {
        noeud_texte := input.donne_noeud_texte_value()
        supprime_nouvelles_lignes_en_place(*noeud_texte.données)
        retourne
    }

    si state == HTMLInputElement.State.URL || state == HTMLInputElement.State.Email {
        noeud_texte := input.donne_noeud_texte_value()
        supprime_nouvelles_lignes_en_place(*noeud_texte.données)
        supprime_espace_blanches_autour_en_place(*noeud_texte.données)
        retourne
    }
}

#portée_export

donne_noeud_texte_value :: fonc (input: *HTMLInputElement) -> *Text
{
    assert(input.shadow_root != nul)
    assert(input.shadow_root.enfants.taille == 1)
    enfant := input.shadow_root.enfants[0]
    assert(enfant.genre == GenreNoeud.Texte)
    retourne enfant comme *Text
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLLabelElement
 * https://html.spec.whatwg.org/multipage/forms.html#the-label-element
 * \{ */

#portée_export

HTMLLabelElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_label_element
}

/* https://html.spec.whatwg.org/multipage/forms.html#dom-label-form */
donne_form :: fonc (label: *HTMLLabelElement) -> *HTMLFormElement
{
    // 1. If the label element has no labeled control, then return null.
    control := donne_control(label)
    saufsi control {
        retourne nul
    }

    // 2. If the label element's labeled control is not a form-associated element, then return null.
    saufsi is_form_associated_element(control) {
        retourne nul
    }

    // 3. Return the label element's labeled control's form owner (which can still be null).
    retourne donne_form_owner(control)
}

/* https://html.spec.whatwg.org/multipage/forms.html#dom-label-control */
donne_control :: fonc (label: *HTMLLabelElement) -> *Element
{
    retourne donne_labeled_control(label)
}

/* https://html.spec.whatwg.org/multipage/forms.html#labeled-control */
donne_labeled_control :: fonc (label: *HTMLLabelElement) -> *Element
{
    traversée: [..]*Node
    diffère déloge(traversée)

    for := label.donne_attribut_ou_chaine_vide(ATTR_for)
    saufsi for.est_vide() {
        tableau_ajoute(*traversée, label.document)

        tantque traversée.taille != 0 {
            noeud := traversée[traversée.taille - 1]
            traversée.taille -= 1

            si noeud.est_élément() {
                élément := noeud comme *Element
                si is_labelable_element(élément) && élément.id == for {
                    retourne élément
                }
            }

            pour > noeud.enfants {
                tableau_ajoute(*traversée, it)
            }
        }

        retourne nul
    }

    pour > label.enfants {
        tableau_ajoute(*traversée, it)
    }

    tantque traversée.taille != 0 {
        noeud := traversée[traversée.taille - 1]
        traversée.taille -= 1

        si noeud.est_élément() && is_labelable_element(noeud comme *Element) {
            retourne noeud comme *Element
        }

        pour > noeud.enfants {
            tableau_ajoute(*traversée, it)
        }
    }

    retourne nul
}

/* https://html.spec.whatwg.org/multipage/forms.html#form-associated-element */
is_form_associated_element :: fonc (élément: *Element) -> bool
{
    si fait_partie_de(élément.local_name, TAG_button, TAG_fieldset, TAG_input, TAG_object, TAG_output, TAG_select, TAG_textarea, TAG_img) {
        retourne vrai
    }

    retourne is_form_associated_custom_element(élément)
}

/* https://html.spec.whatwg.org/multipage/forms.html#category-label */
is_labelable_element :: fonc (élément: *Element) -> bool
{
    tags := [TAG_button, TAG_meter, TAG_output, TAG_progress, TAG_select, TAG_textarea]
    si fait_partie_de(élément.local_name, ...tags) {
        retourne vrai
    }

    si élément.local_name == TAG_input {
        type := donne_attribut_ou_chaine_vide(élément, ATTR_type)
        retourne type != ATTR_hidden
    }

    retourne is_form_associated_custom_element(élément)
}

/* https://html.spec.whatwg.org/multipage/forms.html#category-submit */
is_submittable_element :: fonc (élément: *Element) -> bool
{
    tags := [TAG_button, TAG_input, TAG_select, TAG_textarea]
    si fait_partie_de(élément.local_name, ...tags) {
        retourne vrai
    }

    retourne is_form_associated_custom_element(élément)
}

/* https://html.spec.whatwg.org/multipage/custom-elements.html#form-associated-custom-element */
is_form_associated_custom_element :: fonc (élément: *Element @inutilisée) -> bool
{
    // À FAIRE
    retourne faux
}

#portée_fichier

table_virtuelle_label_element := TableVirtuelleElement(
    classe = HTMLLabelElement,
    sur_destruction = élément_sur_destruction,
    sur_changement_attribut = html_element_sur_changement_attribut
)

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLLinkElement
 * https://html.spec.whatwg.org/multipage/semantics.html#the-link-element
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLLinkElement
 * \{ */

#portée_export

HTMLLinkElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_link_element

    est_stylesheet: bool
    est_alternate: bool
}

donne_href :: fonc (link: *HTMLLinkElement) -> DOMString
{
    retourne donne_attribut_ou_chaine_vide(link, ATTR_href)
}

donne_rel :: fonc (link: *HTMLLinkElement) -> DOMString
{
    retourne donne_attribut_ou_chaine_vide(link, ATTR_rel)
}

#portée_fichier

table_virtuelle_link_element := TableVirtuelleElement(
    classe = HTMLLinkElement,
    sur_destruction = élément_sur_destruction,
    sur_changement_attribut = link_element_sur_changement_attribut
)

link_element_sur_changement_attribut :: fonc (base: *Element, local_name: DOMString, vieille_valeur: *DOMString, valeur: *DOMString, espace_de_nom: Optionnel(DOMString)) -> bool
{
    si html_element_sur_changement_attribut(base, local_name, vieille_valeur, valeur, espace_de_nom) {
        retourne vrai
    }

    link := base comme *HTMLLinkElement

    si local_name == ATTR_href || local_name == ATTR_rel {
        process_link_element(link)
        retourne vrai
    }

    retourne faux
}

/* https://html.spec.whatwg.org/multipage/links.html */
process_link_element :: fonc (link: *HTMLLinkElement)
{
    rel := link.donne_rel()
    si rel.est_vide() {
        link.document.supprime_feuille_de_style_associée(link)
        retourne
    }

    href := link.donne_href()
    si href.est_vide() {
        link.document.supprime_feuille_de_style_associée(link)
        retourne
    }

    types := run_ordered_set_parser(rel)
    diffère déloge(types)

    pour types {
        si it == ATTR_stylesheet {
            link.est_stylesheet = vrai
        }
        sinon si it == ATTR_alternate {
            link.est_alternate = vrai
        }
    }

    fetch_and_process_linked_ressource(link.document.donne_user_agent(), link)
}

/* https://html.spec.whatwg.org/multipage/semantics.html#fetch-and-process-the-linked-resource */
fetch_and_process_linked_ressource :: fonc (user_agent: *UserAgent, el: *HTMLLinkElement)
{
    fetch_and_process_linked_ressource_default(user_agent, el)
}

/* https://html.spec.whatwg.org/multipage/semantics.html#default-fetch-and-process-the-linked-resource */
fetch_and_process_linked_ressource_default :: fonc (user_agent: *UserAgent, el: *HTMLLinkElement)
{
    // 1. Let options be the result of creating link options from el.
    options := create_link_options(el)

    // 2. Let request be the result of creating a link request given options.
    request := create_link_request(user_agent, *options)

    // 3. If request is null, then return.
    saufsi request {
        retourne
    }

    // 4. Set request's synchronous flag.
    request.drapeaux.SYNCHRONOUS = vrai

    // 5. Run the linked resource fetch setup steps, given el and request. If the result is false, then return.
    saufsi linked_resource_fetch_setup(el, request) {
        détruit_request(request)
        retourne
    }

    // 6. Set request's initiator type to "css" if el's rel attribute contains the keyword stylesheet; "link" otherwise.
    si el.est_stylesheet {
        request.initiator_type = Request.InitiatorType.CSS
    }

    // 7. Fetch request with processResponseConsumeBody set to the following steps given response response and null, failure, or a byte sequence bodyBytes:
    // À FAIRE : utilise processResponseConsumeBody

    RappelProcessResponse :: struct {
        empl base: BaseProcessResponse

        link: *HTMLLinkElement
        request: *Request
    }

    sur_rappel_process_response :: fonc (rappel: *RappelProcessResponse, réponse: *Response)
    {
        diffère détruit_response(réponse)

        body_bytes: chaine
        si réponse.body_info && réponse.body.possède_valeur() {
            body_bytes = réponse.body.Quelque
        }

        // 1. Let success be true.
        success := vrai

        // 2. If any of the following are true:
        //     bodyBytes is null or failure; or
        //     response's status is not an ok status,
        //    then set success to false.
        si body_bytes == "" || réponse.status != 200 {
            success = faux
        }

        // À FAIRE 3. Otherwise, wait for the link resource's critical subresources to finish loading.

        // 4. Process the linked resource given el, success, response, and bodyBytes.
        process_the_linked_resource(rappel.link, success, réponse, body_bytes)
    }

    sur_destruction_process_response :: fonc (base: *BaseProcessResponse)
    {
        rappel := base comme *RappelProcessResponse
        détruit_request(rappel.request)
        déloge(rappel)
    }

    process_response := loge(RappelProcessResponse)
    process_response.link = el
    process_response.request = request
    process_response.sur_rappel = sur_rappel_process_response
    process_response.sur_destruction = sur_destruction_process_response

    fetch_controller := fetch(user_agent, request, process_response = process_response)
    diffère détruit_fetch_controller(fetch_controller)
}

/* https://html.spec.whatwg.org/multipage/semantics.html#create-a-link-request */
create_link_request :: fonc (user_agent: *UserAgent, options: *LinkProcessingOptions) -> *Request
{
    // 1. Assert: options's href is not the empty string.
    assert(!options.href.est_vide())

    // 2. If options's destination is null, then return null.
    saufsi options.destination.possède_valeur() {
        retourne nul
    }

    // 3. Let url be the result of encoding-parsing a URL given options's href, relative to options's base URL.
    url := encoding_parse_a_url(user_agent, options.href, options.base_url)

    // 4. If url is failure, then return null.
    saufsi url {
        retourne nul
    }

    // 5. Let request be the result of creating a potential-CORS request given url, options's destination, and options's crossorigin.
    request := create_a_potential_cors_request(url, options.destination.Quelque, options.crossorigin)

    // 6. Set request's policy container to options's policy container.
    request.policy_container = options.policy_container

    // 7. Set request's integrity metadata to options's integrity.
    request.integrity_metadata = options.integrity

    // 8. Set request's cryptographic nonce metadata to options's cryptographic nonce metadata.
    request.cryptographic_nonce = options.cryptographic_nonce

    // 9. Set request's referrer policy to options's referrer policy.
    request.referrer_policy = options.referrer_policy

    // 10. Set request's client to options's environment.
    request.client = options.environment

    // 11. Set request's priority to options's fetch priority.
    request.priority = donne_request_priority(options.fetch_priority)

    // 12. Return request.
    retourne request
}

/* https://html.spec.whatwg.org/multipage/urls-and-fetching.html#create-a-potential-cors-request */
create_a_potential_cors_request :: fonc (url: *URL, destination: Request.DestinationType, cors_attribute_state: CORSAttributeState, same_origin_fallback_flag := faux) -> *Request
{
    // 1. Let mode be "no-cors" if corsAttributeState is No CORS, and "cors" otherwise.
    mode := si cors_attribute_state == CORSAttributeState.NO_CORS {
        Request.Mode.No_CORS
    }
    sinon {
        Request.Mode.CORS
    }

    // 2. If same-origin fallback flag is set and mode is "no-cors", set mode to "same-origin".
    si same_origin_fallback_flag && mode == Request.Mode.No_CORS {
        mode = Request.Mode.Same_Origin
    }

    // 3. Let credentialsMode be "include".
    credentials_mode := Request.CredentialsMode.Include

    // 4. If corsAttributeState is Anonymous, set credentialsMode to "same-origin".
    si cors_attribute_state == CORSAttributeState.Anonymous {
        credentials_mode = Request.CredentialsMode.Same_Origin
    }

    // 5. Return a new request whose URL is url, destination is destination, mode is mode, credentials mode is credentialsMode, and whose use-URL-credentials flag is set.
    request := loge(Request)
    request.définis_url(url)
    request.mode = mode
    request.destination = destination
    request.credentials_mode = credentials_mode
    request.drapeaux.USE_URL_CREDENTIALS = vrai
    retourne request
}

/* https://html.spec.whatwg.org/multipage/semantics.html#link-processing-options */
LinkProcessingOptions :: struct {
    destination: Optionnel(Request.DestinationType)
    crossorigin: CORSAttributeState
    referrer_policy: ReferrerPolicy
    fetch_priority: FetchPriorityState
    integrity: DOMString
    type: DOMString
    href: DOMString
    cryptographic_nonce: DOMString
    base_url: *URL
    origin: Origin
    environment: *EnvironmentSettings
    policy_container: *PolicyContainer
    document: *Document
}

/* https://html.spec.whatwg.org/multipage/semantics.html#create-link-options-from-element */
create_link_options :: fonc (el: *HTMLLinkElement) -> LinkProcessingOptions
{
    // 1. Let document be el's node document.
    document := el.document

    // 2. Let options be a new link processing options with
    options: LinkProcessingOptions
    // destination                  -> the result of translating the state of el's as attribute.
    si el.possède_attribut(ATTR_as) {
        options.destination = translate_a_preload_destination(el.donne_attribut_ou_chaine_vide(ATTR_as)) // XXX - state
    }
    sinon {
        options.destination = Request.DestinationType.EmptyString
    }
    // crossorigin                  -> the state of el's crossorigin content attribute
    options.crossorigin = el.donne_cross_origin_content_attribute_state()
    // referrer policy              -> the state of el's referrerpolicy content attribute
    options.referrer_policy = el.donne_referrerpolicy_content_attribute_state()
    // À FAIRE source set                   -> el's source set
    // base URL                     -> document's document base URL
    options.base_url = document.donne_base_url()
    // origin                       -> document's origin
    options.origin = document.origin
    // environment                  -> document's relevant settings object
    options.environment = document.donne_relevant_settings_object()
    // policy container             -> document's policy container
    options.policy_container = clone(document.policy_container) // @spec-bug ?
    // document                     -> document
    options.document = document
    // cryptographic nonce metadata -> The current value of el's [[CryptographicNonce]] internal slot
    options.cryptographic_nonce = el.cryptographic_nonce
    // fetch priority               -> the state of el's fetchpriority content attribute
    options.fetch_priority = el.donne_fetch_priority_content_attribute_state()

    // 3. If el has an href attribute, then set options's href to the value of el's href attribute.
    options.href = el.donne_attribut_ou_chaine_vide(ATTR_href)

    // 4. If el has an integrity attribute, then set options's integrity to the value of el's integrity content attribute.
    options.integrity = el.donne_attribut_ou_chaine_vide(ATTR_integrity)

    // 5. If el has a type attribute, then set options's type to the value of el's type attribute.
    options.type = el.donne_attribut_ou_chaine_vide(ATTR_type)

    // 6. Assert: options's href is not the empty string, or options's source set is not null.
    //    A link element with neither an href or an imagesrcset does not represent a link.

    // 7. Return options.
    retourne options
}

/* https://html.spec.whatwg.org/multipage/links.html#translate-a-preload-destination */
translate_a_preload_destination :: fonc (destination_: DOMString) -> Optionnel(Request.DestinationType)
{
    destination := converti_vers_chaine(destination_.donne_chaine_utf16())
    diffère déloge(destination)

    // 1. If destination is not "fetch", "font", "image", "script", "style", or "track", then return null.
    si destination != "fetch" && destination != "font" && destination != "image" && destination != "script" && destination != "style" && destination != "track" {
        retourne
    }

    // 2. Return the result of translating destination.
    retourne translate_a_potential_destination(destination_)
}

/* https://fetch.spec.whatwg.org/#concept-potential-destination-translate */
translate_a_potential_destination :: fonc (potential_destination_: DOMString) -> Request.DestinationType
{
    potential_destination := converti_vers_chaine(potential_destination_.donne_chaine_utf16())
    diffère déloge(potential_destination)

    // 1. If potentialDestination is "fetch", then return the empty string.
    si potential_destination == "fetch" {
        retourne Request.DestinationType.EmptyString
    }

    // 2. Assert: potentialDestination is a destination.
    info_destination_type := info_de(Request.DestinationType)
    pour info_destination_type.noms {
        si compare_ascii_insensible_à_la_casse(it, potential_destination) {
            // 3. Return potentialDestination.
            // À FAIRE(langage) : erreur de compilation
            // retourne donne_eini_valeur_énum_indice(info_destination_type, index_it) comme Request.DestinationType
            résultat := donne_eini_valeur_énum_indice(info_destination_type, index_it)
            retourne mémoire(résultat.pointeur comme *Request.DestinationType)
        }
    }

    imprimeln("potential_destination_ n'est pas une destination : %", potential_destination_)
    assert(faux)
    retourne Request.DestinationType.EmptyString
}

/* https://html.spec.whatwg.org/multipage/semantics.html#linked-resource-fetch-setup-steps */
linked_resource_fetch_setup :: fonc (el: *HTMLLinkElement, request: *Request) -> bool
{
    si el.est_stylesheet {
        si el.est_alternate {
            retourne faux
        }
        retourne linked_resource_fetch_setup_stylesheet(el, request)
    }

    retourne faux
}

linked_resource_fetch_setup_stylesheet :: fonc (el: *HTMLLinkElement, request: *Request) -> bool
{
    // 1. If el's disabled attribute is set, then return false.
    si possède_attribut(el, ATTR_disabled) {
        retourne faux
    }

    // À FAIRE 2. If el contributes a script-blocking style sheet, append el to its node document's script-blocking style sheet set.

    // À FAIRE(media) 3. If el's media attribute's value matches the environment and el is potentially render-blocking, then block rendering on el.
    si el.is_potentially_render_blocking() {
        block_rendering_on(el)
    }

    // 4. If el is currently render-blocking, then set request's render-blocking to true.
    si is_render_blocking(el) {
        request.drapeaux.RENDER_BLOCKING = vrai
    }

    // 5. Return true.
    retourne vrai
}

process_the_linked_resource :: fonc (el: *HTMLLinkElement, success: bool, réponse: *Response, body_bytes: chaine)
{
    si el.est_stylesheet {
        assert(!el.est_alternate)
        process_the_linked_resource_stylesheet(el, success, réponse, body_bytes)
    }
}

process_the_linked_resource_stylesheet :: fonc (el: *HTMLLinkElement, success: bool, réponse: *Response, body_bytes: chaine)
{
    // 1. If the resource's Content-Type metadata is not text/css, then set success to false.
    si réponse.body_info && réponse.body_info.content_type != MIME_text_css {
        success = faux
    }

    // À FAIRE : 2. If el no longer creates an external resource link that contributes to the styling processing model, or if, since the resource in question was fetched, it has become appropriate to fetch it again, then:
        // 1. Remove el from el's node document's script-blocking style sheet set.
        // 2. Return.

    // 3. If el has an associated CSS style sheet, remove the CSS style sheet.
    el.document.supprime_feuille_de_style_associée(el)

    // 4. If success is true, then:
    si success {
        // 1. Create a CSS style sheet with the following properties:
        feuille_de_style := loge(CSS.CSSStyleSheet)
        feuille_de_style.origine = CSS.OrigineCascade.Author
        // type                   -> text/css
        feuille_de_style.type = crée_chaine_utf16_unique(MIME_text_css)
        // location               -> response's URL list[0]
        feuille_de_style.location = copie_url(réponse.url_list[0])
        // owner node             -> el
        feuille_de_style.owner_node = el
        // À FAIRE media                  -> The media attribute of el.
        // title                  -> The title attribute of el, if el is in a document tree, or the empty string otherwise.
        si is_in_a_document_tree(el) {
            feuille_de_style.title = el.donne_attribut_ou_chaine_vide(ATTR_title)
        }

        // À FAIRE alternate flag         -> Set if the link is an alternative style sheet and el's explicitly enabled is false; unset otherwise.
        feuille_de_style.alternate = faux
        // À FAIRE origin-clean flag      -> Set if the resource is CORS-same-origin; unset otherwise.
        feuille_de_style.origin_clean = vrai
        // parent CSS style sheet -> null
        feuille_de_style.parent_style_sheet = nul
        // owner CSS rule         -> null
        feuille_de_style.owner_rule = nul
        // disabled flag          -> Left at its default value.
        // CSS rules              -> Left uninitialized.
        // Non-spécifié
        ctx: CSS.ContexteParsageFeuilleDeStyle
        diffère CSS.détruit_données_contexte(*ctx)
        CSS.parse_style_rules(*ctx, feuille_de_style, body_bytes)
        CSS.rapporte_propriétés_non_supportées(*ctx, #nom_de_cette_fonction)
        el.document.ajoute_feuille_de_style(feuille_de_style)

        // À FAIRE : The CSS environment encoding is the result of running the following steps: [CSSSYNTAX]
            // 1. If el has a charset attribute, get an encoding from that attribute's value. If that succeeds, return the resulting encoding. [ENCODING]
            // 2. Otherwise, return the document's character encoding. [DOM]

        // 2. Fire an event named load at el.
        _ := fire_an_event(el, EventType.load)
    }
    // 5. Otherwise, fire an event named error at el.
    sinon {
        _ := fire_an_event(el, EventType.error)
    }

    // À FAIRE 6. If el contributes a script-blocking style sheet, then:
    // Assert: el's node document's script-blocking style sheet set contains el.
    // Remove el from its node document's script-blocking style sheet set.

    // 7. Unblock rendering on el.
    unblock_rendering_on(el)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLMediaElement
 * https://html.spec.whatwg.org/multipage/media.html#htmlmediaelement
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement
 * \{ */

#portée_export

HTMLMediaElement :: struct {
    empl html_element: HTMLElement
}

donne_src :: fonc (media: *HTMLMediaElement) -> DOMString
{
    retourne donne_attribut_ou_chaine_vide(media, ATTR_src)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLVideoElement
 * https://html.spec.whatwg.org/multipage/media.html#htmlvideoelement
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement
 * \{ */

#portée_export

HTMLVideoElement :: struct {
    empl html_media: HTMLMediaElement
    table = *table_virtuelle_video_element
}

#portée_fichier

table_virtuelle_video_element := TableVirtuelleElement(
    classe = HTMLVideoElement,
    sur_destruction = élément_sur_destruction,
    sur_changement_attribut = html_element_sur_changement_attribut
)

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLObjectElement
 * https://html.spec.whatwg.org/multipage/iframe-embed-object.html#the-object-element
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLObjectElement
 * \{ */

#portée_export

ChoseReprésentée :: énum {
    /* L'élément représente ses descendants. */
    DESCENDANTS
    /* L'élément représente ses données. */
    DONNÉES
}

HTMLObjectElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_object_element

    chose_représentée: ChoseReprésentée
    image_data: NouvelleImage
}

donne_hauteur_intrinsèque :: fonc (object: *HTMLObjectElement) -> z32 #enligne
{
    retourne object.image_data.desc.hauteur comme z32
}

donne_largeur_intrinsèque :: fonc (object: *HTMLObjectElement) -> z32 #enligne
{
    retourne object.image_data.desc.largeur comme z32
}

donne_ratio_intrinsèque :: fonc (object: *HTMLObjectElement) -> r32 #enligne
{
    si object.image_data.desc.hauteur == 0 {
        retourne 1.0
    }

    retourne object.image_data.desc.largeur comme r32 / object.image_data.desc.hauteur comme r32
}

#portée_fichier

table_virtuelle_object_element := TableVirtuelleElement(
    classe = HTMLObjectElement,
    sur_destruction = object_element_sur_destruction,
    sur_document_fully_active = object_element_sur_document_fully_active,
    sur_dépilement = object_element_sur_dépilement,
    sur_changement_attribut = object_element_sur_changement_attribut
)

object_element_sur_destruction :: fonc (base: *JS.Cellule)
{
    élément := base comme *HTMLObjectElement
    élément_détruit_données(élément)
    détruit_données_image(*élément.image_data)
}

object_element_sur_document_fully_active :: fonc (base: *Node)
{
    object_element_ajourne(base comme *HTMLObjectElement)
}

object_element_sur_dépilement :: fonc (base: *Element)
{
    object_element_ajourne(base comme *HTMLObjectElement)
}

object_element_sur_changement_attribut :: fonc (base: *Element, local_name: DOMString, vieille_valeur: *DOMString, valeur: *DOMString, espace_de_nom: Optionnel(DOMString)) -> bool
{
    object := base comme *HTMLObjectElement

    si html_element_sur_changement_attribut(object, local_name, vieille_valeur, valeur, espace_de_nom) {
        retourne vrai
    }

    si local_name == ATTR_classid {
        object_element_ajourne(object)
        retourne vrai
    }

    si local_name == ATTR_data {
        saufsi possède_attribut(object, ATTR_classid) {
            object_element_ajourne(object)
        }
        retourne vrai
    }

    si local_name == ATTR_type {
        si !possède_attribut(object, ATTR_classid) && !possède_attribut(object, ATTR_data) {
            object_element_ajourne(object)
        }
        retourne vrai
    }

    retourne vrai
}

/* Whenever one of the following conditions occur:
 * [ ] the element is created,
 * [X] the element is popped off the stack of open elements of an HTML parser or XML parser,
 * [ ] the element is not on the stack of open elements of an HTML parser or XML parser, and it is either inserted into a document or removed from a document,
 * [X] the element's node document changes whether it is fully active,
 * [ ] one of the element's ancestor object elements changes to or from showing its fallback content,
 * [X] the element's classid attribute is set, changed, or removed,
 * [X] the element's classid attribute is not present, and its data attribute is set, changed, or removed,
 * [X] neither the element's classid attribute nor its data attribute are present, and its type attribute is set, changed, or removed,
 * [ ] the element changes from being rendered to not being rendered, or vice versa,
 *
 * ...the user agent must queue an element task on the DOM manipulation task source given
 * the object element to run the following steps to (re)determine what the object element
 * represents.
 * This task being queued or actively running must delay the load event of the element's node document.
 */
object_element_ajourne :: fonc (object: *HTMLObjectElement)
{
    document := object.document
    user_agent := document.donne_user_agent()
    saufsi user_agent {
        retourne
    }

    Tâche :: struct {
        empl base: Algorithm
        object: *HTMLObjectElement
    }

    sur_run :: fonc (base: *Algorithm)
    {
        tâche := base comme *Tâche
        détermine_ce_que_object_représente(tâche.object)
    }

    tâche := crée_algorithm(sur_run, Tâche)
    tâche.object = object

    document.things_that_delay_the_load_event += 1
    user_agent.queue_an_element_task(SourceDeTâche.ManipulationDOM, object, tâche)
}

détermine_ce_que_object_représente :: fonc (object: *HTMLObjectElement)
{
    // 1. If the user has indicated a preference that this object element's
    //    fallback content be shown instead of the element's usual behavior,
    //    then jump to the step below labeled fallback.

    // 2. If the element has an ancestor media element,
    //    or has an ancestor object element that is not showing its fallback content,

    //    or if the element is not in a document whose browsing context is non-null,

    //    or if the element's node document is not fully active,
    si object.document && !object.document.est_fully_active() {
        object_représente_fallback(object)
        retourne
    }

    //    or if the element is still in the stack of open elements of an HTML parser or XML parser,
    si object.est_sur_pile_éléments_ouvert {
        object_représente_fallback(object)
        retourne
    }

    //    or if the element is not being rendered, then jump to the step below labeled fallback.

    // 3. If the data attribute is present and its value is not the empty string, then:
    si possède_attribut(object, ATTR_data) && !donne_attribut_ou_chaine_vide(object, ATTR_data).est_vide() {
        object_représente_data(object, nul)
        retourne
    }

    // 4. Fallback. NOTE : ceci est fait via les appels à object_représente_fallback.
    object_représente_fallback(object)
}

définis_chose_représentée :: fonc (object: *HTMLObjectElement, chose: ChoseReprésentée)
{
    object.chose_représentée = chose
    object.document.invalide_style()
}

object_représente_fallback :: fonc (object: *HTMLObjectElement)
{
    détruit_données_image(*object.image_data)
    object.image_data = NouvelleImage()

    // The object element represents the element's children. This is the element's fallback content. Destroy a child navigable given the element.
    object.document.things_that_delay_the_load_event -= 1
    object.définis_chose_représentée(ChoseReprésentée.DESCENDANTS)
}

object_représente_data :: fonc (object: *HTMLObjectElement, réponse: *Response)
{
    saufsi réponse {
        // 1. If the type attribute is present and its value is not a type that the
        //    user agent supports, then the user agent may jump to the step below
        //    labeled fallback without fetching the content to examine its real type.

        // 2. Let url be the result of encoding-parsing a URL given the data
        //    attribute's value, relative to the element's node document.
        data := donne_attribut_ou_chaine_vide(object, ATTR_data)
        url := encoding_parse_a_url(data, object.document)

        // 3. If url is failure, then fire an event named error at the element and
        //    jump to the step below labeled fallback.
        saufsi url {
            queue_a_task_to_fire_error_at_element(object.document.donne_user_agent(), object)
            object_représente_fallback(object)
            retourne
        }

        // 4. Let request be a new request whose URL is url, client is the element's
        //    node document's relevant settings object, destination is "object",
        //    credentials mode is "include", mode is "navigate", initiator type is
        //    "object", and whose use-URL-credentials flag is set.
        request := loge(Request)
        request.client = object.document.donne_relevant_settings_object()
        request.destination = Request.DestinationType.Object
        request.credentials_mode = Request.CredentialsMode.Include
        request.mode = Request.Mode.Navigate
        request.initiator_type = Request.InitiatorType.Object
        request.drapeaux.USE_URL_CREDENTIALS = vrai
        request.définis_url(url)

        // 5. Fetch request.
        //    Fetching the resource must delay the load event of the element's node
        //    document until the task that is queued by the networking task source
        //    once the resource has been fetched (defined next) has been run.
        RappelProcessResponse :: struct {
            empl base: BaseProcessResponse

            object: *HTMLObjectElement
            request: *Request
        }

        sur_rappel_process_response :: fonc (base: *BaseProcessResponse, réponse: *Response)
        {
            rappel := base comme *RappelProcessResponse
            object_représente_data(rappel.object, réponse)
            détruit_response(réponse)
        }

        sur_destruction_process_response :: fonc (base: *BaseProcessResponse)
        {
            rappel := base comme *RappelProcessResponse
            détruit_request(rappel.request)
            déloge(rappel)
        }

        process_response := loge(RappelProcessResponse)
        process_response.object = object
        process_response.request = request
        process_response.sur_rappel = sur_rappel_process_response
        process_response.sur_destruction = sur_destruction_process_response

        fetch_controller := fetch(object.document.donne_user_agent(), request, process_response = process_response)
        diffère détruit_fetch_controller(fetch_controller)

        object.document.things_that_delay_the_load_event += 1

        // 6. If the resource is not yet available (e.g. because the resource was not
        //    available in the cache, so that loading the resource required making a
        //    request over the network), then jump to the step below labeled fallback.
        //    The task that is queued by the networking task source once the resource
        //    is available must restart this algorithm from this step.
        //    Resources can load incrementally; user agents may opt to consider a
        //    resource "available" whenever enough data has been obtained to begin
        //    processing the resource.
        object_représente_fallback(object)
        retourne
    }

    // 7. If the load failed (e.g. there was an HTTP 404 error, there was a DNS
    //    error), fire an event named error at the element, then jump to the step
    //    below labeled fallback.
    si réponse.status != 200 {
        queue_a_task_to_fire_error_at_element(object.document.donne_user_agent(), object)
        object_représente_fallback(object)
        retourne
    }

    // 8. Determine the resource type, as follows:
    // À FAIRE : complète
    saufsi réponse.body_info {
        object_représente_fallback(object)
        retourne
    }

    content_type := réponse.body_info.content_type
    saufsi est_type_mime_image(content_type) {
        object_représente_fallback(object)
        retourne
    }

    contenu := réponse.body.Quelque

    _ := décode_image(contenu, content_type, *object.image_data)

    object.définis_chose_représentée(ChoseReprésentée.DONNÉES)
    object.document.things_that_delay_the_load_event -= 1
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLOptionElement
 * https://html.spec.whatwg.org/multipage/form-elements.html#the-option-element
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLOptionElement
 *
 * À FAIRE : insertion steps (void document de <select>)
 * \{ */

#portée_export

HTMLOptionElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_option_element
}

#portée_fichier

table_virtuelle_option_element := TableVirtuelleElement(
    classe = HTMLOptionElement,
    sur_destruction = élément_sur_destruction,
    sur_changement_attribut = html_element_sur_changement_attribut
)

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLOptGroupElement
 * https://html.spec.whatwg.org/multipage/form-elements.html#the-optgroup-element
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLOptGroupElement
 * \{ */

#portée_export

HTMLOptGroupElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_optgroup_element
}

#portée_fichier

table_virtuelle_optgroup_element := TableVirtuelleElement(
    classe = HTMLOptGroupElement,
    sur_destruction = élément_sur_destruction,
    sur_changement_attribut = html_element_sur_changement_attribut
)

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLScriptElement
 * https://html.spec.whatwg.org/multipage/scripting.html#htmlscriptelement
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLScriptElement
 * \{ */

#portée_export

TypeScript :: énum {
    NUL
    CLASSIC
    MODULE
    IMPORTMAP
}

HTMLScriptElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_script_element

    document_parseur: *Document
    document_du_temps_de_préparation: *Document

    force_async := vrai // À FAIRE : doit être faux lors de l'ajout d'un attribut async
    provient_de_fichier_externe := faux
    prêt_à_être_exécuté_par_parseuse := faux
    déjà_commencé := faux
    temporise_évènement_de_charge := faux
    delaying_the_load_event := faux

    type: TypeScript
    // result : "uninitialized", null, scipt, import map parse result
    result: *Script

    steps_to_run_when_the_result_is_ready: fonc(*HTMLScriptElement)(rien)
}

donne_src :: fonc (script: *HTMLScriptElement) -> DOMString
{
    retourne donne_attribut_ou_chaine_vide(script, ATTR_src)
}

#portée_fichier

table_virtuelle_script_element := TableVirtuelleElement(
    classe = HTMLScriptElement,
    sur_destruction = élément_sur_destruction,
    sur_changement_attribut = html_element_sur_changement_attribut
)

#portée_export

/* https://html.spec.whatwg.org/multipage/scripting.html#prepare-the-script-element */
prépare :: fonc (el: *HTMLScriptElement)
{
    /* 1. */
    si el.déjà_commencé {
        retourne
    }

    /* 2. & 3. */
    document_parseur := el.document_parseur
    el.document_parseur = nul

    /* 4. */
    si document_parseur != nul && !el.possède_attribut(ATTR_async) {
        el.force_async = vrai
    }

    /* 5. */
    texte_source := extrait_texte_noeud(el)
    diffère déloge(texte_source)

    /* 6. */
    possède_attr_src := el.possède_attribut(ATTR_src)
    si !possède_attr_src && texte_source == "" {
        retourne
    }

    /* 7. */
    saufsi el.est_connecté() {
        retourne
    }

    /* 8. */
    type_bloc_script := détermine_type_block_script(el)
    
    /* 9. */
    si est_type_mime_javascript(type_bloc_script) {
        el.type = TypeScript.CLASSIC
    }
    /* 10. */
    sinon si compare_ascii_insensible_à_la_casse(type_bloc_script, ATTR_module) {
        el.type = TypeScript.MODULE
    }
    /* 11. */
    sinon si compare_ascii_insensible_à_la_casse(type_bloc_script, ATTR_importmap) {
        el.type = TypeScript.IMPORTMAP
    }
    /* 12. */
    sinon {
        retourne
    }

    /* 13. */
    si document_parseur != nul {
        el.document_parseur = document_parseur
        el.force_async = faux
    }

    /* 14. */
    el.déjà_commencé = vrai

    /* 15. */
    el.document_du_temps_de_préparation = el.document

    /* 16. */
    si document_parseur != nul && document_parseur != el.document_du_temps_de_préparation {
        retourne
    }

    /* 17. */
    si el.scripting_est_désactivé() {
        retourne
    }

    /* 18. */
    si el.possède_attribut(ATTR_nomodule) && el.type == TypeScript.CLASSIC {
        retourne
    }

    /* 19. */
    saufsi possède_attr_src {
        bloqué := should_element_s_inline_behavior_be_blocked(el, "script", texte_source)
        si bloqué == "Blocked" {
            retourne
        }
    }

    /* 20. */
    si el.type == TypeScript.CLASSIC && el.possède_attribut(ATTR_for) && el.possède_attribut(ATTR_event) {
        valeur_for := el.donne_attribut(ATTR_for).Quelque
        valeur_event := el.donne_attribut(ATTR_event).Quelque

        valeur_event = supprime_espace_blanches_autour(valeur_event)
        valeur_for = supprime_espace_blanches_autour(valeur_for)

        saufsi compare_ascii_insensible_à_la_casse(valeur_for, ATTR_window) {
            retourne
        }
    
        saufsi compare_ascii_insensible_à_la_casse(valeur_event, ATTR_onload) || compare_ascii_insensible_à_la_casse(valeur_event, "onload()") {
            retourne
        }
    }

    /* 21. INCOMPLET : charset */

    /* 22. Let classic script CORS setting be the current state of el's crossorigin content attribute. */
    classic_script_cors_setting := donne_cross_origin_content_attribute_state(el)

    /* 23. INCOMPLET */
    module_script_credentials: Request.CredentialsMode

    /* 24. INCOMPLET */
    cryptographic_nonce := el.cryptographic_nonce

    /* 25. INCOMPLET */
    integrity := crée_chaine_utf16_unique_vide()

    /* 26. Let referrer policy be the current state of el's referrerpolicy content attribute. */
    referrer_policy := donne_referrerpolicy_content_attribute_state(el)

    /* 27. Let fetch priority be the current state of el's fetchpriority content attribute. */
    fetch_priority := donne_fetch_priority_content_attribute_state(el)

    /* 28. */
    métadonnée_parseuse := si el.est_inséré_par_parseuse() {
        Request.ParserMetadata.Parser_Inserted
    }
    sinon {
        Request.ParserMetadata.Not_Parser_Inserted
    }

    /* 29. */
    options: OptionsFetchScript
    options.cryptographic_nonce = cryptographic_nonce
    options.integrity_metadata = integrity
    options.parser_metadata = métadonnée_parseuse
    options.credentials_mode = module_script_credentials
    options.referrer_policy = referrer_policy
    options.fetch_priority = fetch_priority

    /* 30. settings object */
    settings_object := donne_relevant_settings_object(el.document)

    user_agent := el.document.donne_user_agent()

    /* 31. */
    si possède_attr_src {
        // 1. If el's type is "importmap", then queue an element task on the DOM manipulation task source given el to fire an event named error at el, and return.
        si el.type == TypeScript.IMPORTMAP {
            queue_a_task_to_fire_error_at_element(user_agent, el)
            retourne
        }

        // 2. Let src be the value of el's src attribute.
        src := el.donne_src()

        // 3. If src is the empty string, then queue an element task on the DOM manipulation task source given el to fire an event named error at el, and return.
        si src.est_vide() {
            queue_a_task_to_fire_error_at_element(user_agent, el)
            retourne
        }

        // 4. Set el's from an external file to true.
        el.provient_de_fichier_externe = vrai

        // 5. Let url be the result of encoding-parsing a URL given src, relative to el's node document.
        url := encoding_parse_a_url(src, el.document)

        // 6. If url is failure, then queue an element task on the DOM manipulation task source given el to fire an event named error at el, and return.
        saufsi url {
            queue_a_task_to_fire_error_at_element(user_agent, el)
            retourne
        }

        // 7. If el is potentially render-blocking, then block rendering on el.
        block_rendering_if_potentially_render_blocking(el)

        // 8. Set el's delaying the load event to true.
        el.delaying_the_load_event = vrai

        // 9. If el is currently render-blocking, then set options's render-blocking to true.
        si is_render_blocking(el) {
            options.render_blocking = vrai
        }

        // 10. Let onComplete given result be the following steps:
        OnComplete :: struct {
            empl base: ScriptFetchComplete
            élément: *HTMLScriptElement
        }
        sur_run :: fonc (base: *ScriptFetchComplete, result: *Script)
        {
            on_complete := base comme *OnComplete
            // 1. Mark as ready el given result.
            mark_as_ready(on_complete.élément, result)
        }

        on_complete := crée_script_fetch_on_complete(OnComplete)
        on_complete.élément = el
        on_complete.sur_run = sur_run

        // 11. Switch on el's type:
        si el.type == TypeScript.CLASSIC {
            // Fetch a classic script given url, settings object, options, classic script CORS setting, encoding, and onComplete.
            fetch_a_classic_script(user_agent, url, settings_object, options, classic_script_cors_setting, on_complete)
        }
        sinon si el.type == TypeScript.MODULE {
            // If el does not have an integrity attribute, then set options's integrity metadata to the result of resolving a module integrity metadata with url and settings object.

            // Fetch an external module script graph given url, settings object, options, and onComplete.
            panique("module non-implémenté")
        }
    }
    /* 32. */
    sinon {
        // 1. Let base URL be el's node document's document base URL.
        base_url := el.document.donne_base_url()

        // 2. Switch on el's type:
        discr el.type {
            CLASSIC {
                // 1. Let script be the result of creating a classic script using source text, settings object, base URL, and options.
                script := create_a_classic_script(user_agent, texte_source, settings_object, base_url, options)

                // 2. Mark as ready el given script.
                mark_as_ready(el, script)
            }
            sinon {
                panique("non-implémenté")
            }
        }
    }

    /* 33. If el's type is "classic" and el has a src attribute, or el's type is "module": */
    si (el.type == TypeScript.CLASSIC && possède_attr_src) || el.type == TypeScript.MODULE {
        // 1. Assert: el's result is "uninitialized".
        assert(el.result == nul)

        // 2. If el has an async attribute or el's force async is true:
        si el.possède_attribut(ATTR_async) || el.force_async {
            // 1. Let scripts be el's preparation-time document's set of scripts that will execute as soon as possible.
            scripts := *el.document_du_temps_de_préparation.scripts_that_will_execute_as_soon_as_possible

            // 2. Append el to scripts.
            tableau_ajoute(scripts, el)

            // 3. Set el's steps to run when the result is ready to the following:
            steps_to_run_when_the_result_is_ready :: fonc (script: *HTMLScriptElement)
            {
                // 1. Execute the script element el.
                execute_the_script_element(script)

                // 2. Remove el from scripts.
                scripts := *script.document_du_temps_de_préparation.scripts_that_will_execute_as_soon_as_possible
                pour mémoire(scripts) {
                    si it == script {
                        tableau_supprime_indice(scripts, index_it)
                        arrête
                    }
                }
            }

            el.steps_to_run_when_the_result_is_ready = steps_to_run_when_the_result_is_ready
        }
        // 3. Otherwise, if el is not parser-inserted:
        sinon saufsi el.est_inséré_par_parseuse() {
            panique("saufsi el.est_inséré_par_parseuse()\n")
            // 1. Let scripts be el's preparation-time document's list of scripts that will execute in order as soon as possible.

            // 2. Append el to scripts.

            // 3. Set el's steps to run when the result is ready to the following:

                // 1. If scripts[0] is not el, then abort these steps.

                // 2. While scripts is not empty, and scripts[0]'s result is not "uninitialized":

                    // 1. Execute the script element scripts[0].

                    // 2. Remove scripts[0].
        }
        // 4. Otherwise, if el has a defer attribute or el's type is "module":
        sinon si el.possède_attribut(ATTR_defer) || el.type == TypeScript.MODULE {
            // 1. Append el to its parser document's list of scripts that will execute when the document has finished parsing.
            tableau_ajoute(*el.document.scripts_that_will_execute_when_the_document_has_finished_parsing, el)

            // 2. Set el's steps to run when the result is ready to the following: set el's ready to be parser-executed to true. (The parser will handle executing the script.)
            el.steps_to_run_when_the_result_is_ready = mark_script_as_ready_to_be_parser_executed
        }
        // 5. Otherwise:
        sinon {
            // 1. Set el's parser document's pending parsing-blocking script to el.
            el.document_parseur.pending_parsing_blocking_script = el

            // 2. Block rendering on el.
            block_rendering_on(el)

            // 3. Set el's steps to run when the result is ready to the following:
            //    set el's ready to be parser-executed to true. (The parser will handle executing the script.)
            el.steps_to_run_when_the_result_is_ready = mark_script_as_ready_to_be_parser_executed
        }
    }
    /* 34. Otherwise */
    sinon {
        // 1. Assert: el's result is not "uninitialized".
        assert(el.result != nul)

        // À FAIRE : 2. If all of the following are true:
        // el's type is "classic";
        // el is parser-inserted;
        // el's parser document has a style sheet that is blocking scripts; and
        // either the parser that created el is an XML parser, or it's an HTML parser whose script nesting level is not greater than one,
        // then:

            // 1. Set el's parser document's pending parsing-blocking script to el.

            // 2. Set el's ready to be parser-executed to true. (The parser will handle executing the script.)

        // 3. Otherwise, immediately execute the script element el, even if other scripts are already executing.
        execute_the_script_element(el)
    }
}

est_inséré_par_parseuse :: fonc (script: *HTMLScriptElement) -> bool
{
    retourne script.document_parseur != nul
}

mark_script_as_ready_to_be_parser_executed :: fonc (script: *HTMLScriptElement)
{
    script.prêt_à_être_exécuté_par_parseuse = vrai
}

détermine_type_block_script :: fonc (script: *HTMLScriptElement) -> DOMString
{
    attr_type := script.cherche_attribut(ATTR_type)
    attr_language := script.cherche_attribut(ATTR_language)

    si (attr_type != nul && attr_type.valeur.est_vide()) ||
         (attr_type == nul && attr_language != nul && attr_language.valeur.est_vide()) ||
         (attr_type == nul && attr_language == nul) {
        retourne crée_chaine_utf16_unique(MIME_text_javascript)
    }

    si attr_type {
        retourne supprime_espace_blanches_autour(attr_type.valeur)
    }

    assert(attr_language != nul)
    chn := imprime_chaine("text/%", attr_language.valeur)
    diffère déloge(chn)
    retourne crée_chaine_utf16_unique(chn)
}

/* https://html.spec.whatwg.org/multipage/scripting.html#execute-the-script-element */
execute_the_script_element :: fonc (el: *HTMLScriptElement)
{
    // 1. Let document be el's node document.
    document := el.document

    // 2. If el's preparation-time document is not equal to document, then return.
    si el.document_du_temps_de_préparation != document {
        retourne
    }

    // 3. Unblock rendering on el.
    unblock_rendering_on(el)

    // 4. If el's result is null, then fire an event named error at el, and return.
    si el.result == nul {
        _ := fire_an_event(el, EventType.error)
        retourne
    }

    // 5. If el's from an external file is true, or el's type is "module", then increment document's ignore-destructive-writes counter.
    ignore_destructive_writes_fut_incrémenté := faux 
    si el.provient_de_fichier_externe || el.type == TypeScript.MODULE {
        document.ignore_destructive_writes += 1
        ignore_destructive_writes_fut_incrémenté = vrai
    }

    // 6. Switch on el's type:
    discr el.type {
        CLASSIC {
            // 1. Let oldCurrentScript be the value to which document's currentScript object was most recently set.
            old_current_script := document.current_script

            // 2. If el's root is not a shadow root, then set document's currentScript attribute to el. Otherwise, set it to null.
            saufsi racine_est_shadow_root(el) {
                document.current_script = el
            }
            sinon {
                document.current_script = nul
            }

            // 3. Run the classic script given by el's result.
            _ := run_the_classic_script(el.result comme *ClassicScript)

            // 4. Set document's currentScript attribute to oldCurrentScript.
            document.current_script = old_current_script
        }
        MODULE {
            // 1. Assert: document's currentScript attribute is null.
            assert(document.current_script == nul)

            // 2. Run the module script given by el's result.
            panique("non-implémenté")
        }
        IMPORTMAP {
            panique("non-implémenté")
            // 1. Register an import map given el's relevant global object and el's result.
        }
        sinon {
            retourne
        }
    }

    // 7. Decrement the ignore-destructive-writes counter of document, if it was incremented in the earlier step.
    si ignore_destructive_writes_fut_incrémenté {
        document.ignore_destructive_writes -= 1
    }

    // 8. If el's from an external file is true, then fire an event named load at el.
    si el.provient_de_fichier_externe {
        _ := fire_an_event(el, EventType.load)
    }
}

/* https://html.spec.whatwg.org/multipage/scripting.html#mark-as-ready */
mark_as_ready :: fonc (el: *HTMLScriptElement, result : *Script = nul)
{
    // 1. Set el's result to result.
    el.result = result

    // 2. If el's steps to run when the result is ready are not null, then run them.
    si el.steps_to_run_when_the_result_is_ready {
        el.steps_to_run_when_the_result_is_ready(el)
    }

    // 3. Set el's steps to run when the result is ready to null.
    el.steps_to_run_when_the_result_is_ready = nul

    // 4. Set el's delaying the load event to false.
    el.delaying_the_load_event = faux
}

ScriptFetchComplete :: struct {
    sur_run: fonc(*ScriptFetchComplete, *Script)(rien)
    sur_destruction: fonc(*ScriptFetchComplete)(rien)
}

crée_script_fetch_on_complete :: fonc ($T: type_de_données) -> *T
{
    sur_destruction :: fonc (base: *ScriptFetchComplete)
    {
        on_complete := base comme *T
        déloge(on_complete)
    }

    résultat := loge(T)
    résultat.sur_destruction = sur_destruction
    retourne résultat
}

run :: fonc (on_complete: *ScriptFetchComplete, result: *rien)
{
    on_complete.sur_run(on_complete, result)
    on_complete.sur_destruction(on_complete)
}

/* https://html.spec.whatwg.org/multipage/webappapis.html#fetch-a-classic-script */
fetch_a_classic_script :: fonc (user_agent: *UserAgent, url: *URL, settings_object: *EnvironmentSettings, options: OptionsFetchScript, cors_setting: CORSAttributeState, on_complete: *ScriptFetchComplete)
{
    // 1. Let request be the result of creating a potential-CORS request given url, "script", and corsSetting.
    request := create_a_potential_cors_request(url, Request.DestinationType.Script, cors_setting)

    // 2. Set request's client to settingsObject.
    request.client = settings_object

    // 3. Set request's initiator type to "script".
    request.initiator_type = Request.InitiatorType.Script

    // 4. Set up the classic script request given request and options.
    set_up_the_classic_script_request(request, options)

    // 5. Fetch request with the following processResponseConsumeBody steps given response response and null, failure, or a byte sequence bodyBytes:

    RappelProcessResponse :: struct {
        empl base: BaseProcessResponseConsumeBody

        request: *Request
        user_agent: *UserAgent
        on_complete: *ScriptFetchComplete
        settings_object: *EnvironmentSettings
        options: OptionsFetchScript
    }

    sur_rappel_process_response :: fonc (base: *BaseProcessResponseConsumeBody, response: *Response, null_or_bytes: Optionnel([]octet))
    {
        rappel := base comme *RappelProcessResponse
        diffère détruit_response(response)

        // 1. Set response to response's unsafe response.
        response = response.donne_unsafe_response()

        // 2. If any of the following are true:
        //    bodyBytes is null or failure; or
        //    response's status is not an ok status,
        si !null_or_bytes.possède_valeur() || !is_ok_status(response.status) {
            // then run onComplete given null, and abort these steps.
            rappel.on_complete.run(nul)
            retourne
        }

        // À FAIRE : 3. Let potentialMIMETypeForEncoding be the result of extracting a MIME type given response's header list.

        // 4. Set encoding to the result of legacy extracting an encoding given potentialMIMETypeForEncoding and encoding.

        // 5. Let sourceText be the result of decoding bodyBytes to Unicode, using encoding as the fallback encoding.
        bytes := null_or_bytes.Quelque
        contenu := chaine(bytes.pointeur comme *z8, bytes.taille)

        // 6. Let mutedErrors be true if response was CORS-cross-origin, and false otherwise.

        // 7. Let script be the result of creating a classic script given sourceText, settingsObject, response's URL, options, mutedErrors, and url.
        url := copie_url(rappel.request.donne_url_courant())
        script := create_a_classic_script(rappel.user_agent, contenu, rappel.settings_object, url, rappel.options)

        // 8. Run onComplete given script.
        rappel.on_complete.run(script)
    }

    sur_destruction_process_response :: fonc (base: *BaseProcessResponseConsumeBody)
    {
        rappel := base comme *RappelProcessResponse
        détruit_request(rappel.request)
        déloge(rappel)
    }

    process_response := loge(RappelProcessResponse)
    process_response.user_agent = user_agent
    process_response.settings_object = settings_object
    process_response.on_complete = on_complete
    process_response.options = options
    process_response.request = request
    process_response.sur_rappel = sur_rappel_process_response
    process_response.sur_destruction = sur_destruction_process_response

    _ := fetch(user_agent, request, process_response_consume_body = process_response)
}

/* https://html.spec.whatwg.org/multipage/webappapis.html#set-up-the-classic-script-request */
set_up_the_classic_script_request :: fonc (request: *Request, options: OptionsFetchScript)
{
    // set request's cryptographic nonce metadata to options's cryptographic nonce,
    request.cryptographic_nonce = options.cryptographic_nonce

    // its integrity metadata to options's integrity metadata,
    request.integrity_metadata = options.integrity_metadata

    // its parser metadata to options's parser metadata,
    request.parser_metadata = options.parser_metadata

    // its referrer policy to options's referrer policy,
    request.referrer_policy = options.referrer_policy

    // its render-blocking to options's render-blocking,
    request.drapeaux.RENDER_BLOCKING = options.render_blocking

    // and its priority to options's fetch priority.
    request.priority = donne_request_priority(options.fetch_priority)
}


/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLSelectElement
 * https://html.spec.whatwg.org/multipage/form-elements.html#the-select-element
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLSelectElement
 * \{ */

#portée_export

HTMLSelectElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_select_element
}

#portée_fichier

table_virtuelle_select_element := TableVirtuelleElement(
    classe = HTMLSelectElement,
    sur_destruction = élément_sur_destruction,
    sur_changement_attribut = html_element_sur_changement_attribut
)

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLSpanElement
 * https://html.spec.whatwg.org/multipage/text-level-semantics.html#the-span-element
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLSpanElement
 * \{ */

#portée_export

HTMLSpanElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_span_element
}

#portée_fichier

table_virtuelle_span_element := TableVirtuelleElement(
    classe = HTMLSpanElement,
    sur_destruction = élément_sur_destruction,
    sur_changement_attribut = html_element_sur_changement_attribut
)

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLStyleElement
 * https://html.spec.whatwg.org/multipage/semantics.html#the-style-element
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLStyleElement
 * \{ */

#portée_export

HTMLStyleElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_style_element
}

#portée_fichier

table_virtuelle_style_element := TableVirtuelleElement(
    classe = HTMLStyleElement,
    sur_destruction = élément_sur_destruction,
    sur_connexion = style_element_sur_connexion_ou_déconnexion,
    sur_déconnexion = style_element_sur_connexion_ou_déconnexion,
    sur_dépilement = style_element_sur_dépilement,
    sur_changement_enfants = style_element_sur_changement_enfants
)

style_element_sur_connexion_ou_déconnexion :: fonc (base: *Node)
{
    style := base comme *HTMLStyleElement
    saufsi style.est_sur_pile_éléments_ouvert {
        ajourne_style_block(style)
    }
}

style_element_sur_dépilement :: fonc (base: *Element)
{
    style := base comme *HTMLStyleElement
    ajourne_style_block(style)
}

style_element_sur_changement_enfants :: fonc (base: *Node)
{
    style := base comme *HTMLStyleElement
    ajourne_style_block(style)
}

/* https://html.spec.whatwg.org/multipage/semantics.html#update-a-style-block
 *
 * The user agent must run the update a style block algorithm whenever any of the following conditions occur:
 *     The element is popped off the stack of open elements of an HTML parser or XML parser.
 *     The element is not on the stack of open elements of an HTML parser or XML parser, and it becomes connected or disconnected.
 *     The element's children changed steps run.
 */
ajourne_style_block :: fonc (style: *HTMLStyleElement)
{
    saufsi rendu_css_est_requis(style) {
        retourne
    }

    // 1. Let element be the style element.
    element := style

    // 2. If element has an associated CSS style sheet, remove the CSS style sheet
    //    in question.
    document := element.document
    document.supprime_feuille_de_style_associée(element)

    // 3. If element is not connected, then return.
    saufsi element.est_connecté() {
        retourne
    }

    // 4. If element's type attribute is present and its value is neither the
    //    empty string nor an ASCII case-insensitive match for "text/css", then
    //    return.
    mime_css := crée_chaine_utf16_unique(MIME_text_css)

    attr_type := element.cherche_attribut(ATTR_type)
    si attr_type && !(attr_type.valeur.est_vide() || compare_ascii_insensible_à_la_casse(attr_type.valeur, mime_css)) {
        retourne
    }

    // 5. If the Should element's inline behavior be blocked by Content Security Policy?
    //    algorithm returns "Blocked" when executed upon the style element, "style",
    //    and the style element's child text content, then return. [CSP]
    texte_source := extrait_texte_noeud(style)
    diffère déloge(texte_source)

    bloqué := should_element_s_inline_behavior_be_blocked(element, "style", texte_source)
    si bloqué == "Blocked" {
        retourne
    }

    // 6. Create a CSS style sheet with the following properties:
    feuille_de_style := loge(CSS.CSSStyleSheet)
    feuille_de_style.origine = CSS.OrigineCascade.Author
    feuille_de_style.type = mime_css
    feuille_de_style.owner_node = element
    // À FAIRE : media = The media attribute of element.
    // title = The title attribute of element, if element is in a document tree, or the empty string otherwise.
    si is_in_a_document_tree(element) {
        feuille_de_style.title = element.donne_attribut_ou_chaine_vide(ATTR_title)
    }
    feuille_de_style.alternate = faux
    feuille_de_style.origin_clean = vrai
    feuille_de_style.parent_style_sheet = nul
    feuille_de_style.owner_rule = nul

    //  À FAIRE : 7. If element contributes a script-blocking style sheet, append element
    //    to its node document's script-blocking style sheet set.

    // À FAIRE : 8. If element's media attribute's value matches the environment and
    //    element is potentially render-blocking, then block rendering on element.

    // Non-spécifié
    ctx: CSS.ContexteParsageFeuilleDeStyle
    diffère CSS.détruit_données_contexte(*ctx)
    CSS.parse_style_rules(*ctx, feuille_de_style, texte_source)
    CSS.rapporte_propriétés_non_supportées(*ctx, #nom_de_cette_fonction)
    document.ajoute_feuille_de_style(feuille_de_style)

    // À FAIRE : implémente la finalisation
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLTableElement
 * https://html.spec.whatwg.org/multipage/tables.html#the-table-element
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLTableElement
 * \{ */

#portée_export

HTMLTableElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_table_element
}

#portée_fichier

table_virtuelle_table_element := TableVirtuelleElement(
    classe = HTMLTableElement,
    sur_destruction = élément_sur_destruction,
    sur_changement_attribut = html_element_sur_changement_attribut,
    sur_applique_presentational_hints = table_element_sur_applique_presentational_hints
)

table_element_sur_applique_presentational_hints :: fonc (base: *Element, résolveuse: *CSS.RésolveuseStyle)
{
    ajoute_propriété_pour_legacy_colour_value(résolveuse, base, ATTR_bgcolor, CSS.PROP_background_color)
    ajoute_propriété_pour_non_zero_dimension(résolveuse, base, ATTR_width, CSS.PROP_width)
    ajoute_propriété_pour_dimension(résolveuse, base, ATTR_height, CSS.PROP_height)
    ajoute_propriété_pour_pixel_length(résolveuse, base, ATTR_cellspacing, CSS.PROP_border_spacing)

    border := donne_attribut_ou_chaine_vide(base, ATTR_border)
    saufsi border.est_vide() {
        valeur := parse_a_non_negative_integer(border)
        valeur_border : r64 = 0.0

        si valeur.possède_valeur() {
            valeur_border = valeur.Quelque comme r64
        }
        sinon {
            /* Nous devons utiliser une valeur de 1 si l'attribut existe, mais qu'il y a une erreur de parsage. */
            valeur_border = 1.0
        }

        valeur_de_style := CSS.crée_valeur_pixels(valeur_border)
        CSS.ajoute_presentational_hint(résolveuse, CSS.PROP_border_top_width, valeur_de_style)
        CSS.ajoute_presentational_hint(résolveuse, CSS.PROP_border_right_width, CSS.copie_valeur(valeur_de_style))
        CSS.ajoute_presentational_hint(résolveuse, CSS.PROP_border_bottom_width, CSS.copie_valeur(valeur_de_style))
        CSS.ajoute_presentational_hint(résolveuse, CSS.PROP_border_left_width, CSS.copie_valeur(valeur_de_style))

        /* À FAIRE : déplace ceci (voir Mozilla). */
        border_style := CSS.donne_valeur_solid()
        CSS.ajoute_presentational_hint(résolveuse, CSS.PROP_border_top_style, CSS.copie_valeur(border_style))
        CSS.ajoute_presentational_hint(résolveuse, CSS.PROP_border_right_style, CSS.copie_valeur(border_style))
        CSS.ajoute_presentational_hint(résolveuse, CSS.PROP_border_bottom_style, CSS.copie_valeur(border_style))
        CSS.ajoute_presentational_hint(résolveuse, CSS.PROP_border_left_style, CSS.copie_valeur(border_style))
    }

    border_color := donne_attribut_ou_chaine_vide(base, ATTR_bordercolor)
    saufsi border_color.est_vide() {
        valeur := parse_a_legacy_colour_value(border_color)
        si valeur.possède_valeur() {
            valeur_de_style := CSS.crée_valeur_couleur(valeur.Quelque)
            CSS.ajoute_presentational_hint(résolveuse, CSS.PROP_border_top_color, valeur_de_style)
            CSS.ajoute_presentational_hint(résolveuse, CSS.PROP_border_right_color, CSS.copie_valeur(valeur_de_style))
            CSS.ajoute_presentational_hint(résolveuse, CSS.PROP_border_bottom_color, CSS.copie_valeur(valeur_de_style))
            CSS.ajoute_presentational_hint(résolveuse, CSS.PROP_border_left_color, CSS.copie_valeur(valeur_de_style))
        }
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLTableCellElement
 * https://html.spec.whatwg.org/multipage/tables.html#the-td-element
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLTableCellElement
 * \{ */

#portée_export

HTMLTableCellElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_table_cell_element
}

#portée_fichier

table_virtuelle_table_cell_element := TableVirtuelleElement(
    classe = HTMLTableCellElement,
    sur_destruction = élément_sur_destruction,
    sur_changement_attribut = html_element_sur_changement_attribut,
    sur_applique_presentational_hints = table_cell_element_sur_applique_presentational_hints
)

table_cell_element_sur_applique_presentational_hints :: fonc (base: *Element, résolveuse: *CSS.RésolveuseStyle)
{
    ajoute_propriété_pour_legacy_colour_value(résolveuse, base, ATTR_bgcolor, CSS.PROP_background_color)
    ajoute_propriété_pour_non_zero_dimension(résolveuse, base, ATTR_width, CSS.PROP_width)
    ajoute_propriété_pour_non_zero_dimension(résolveuse, base, ATTR_height, CSS.PROP_height)
}

#portée_export

/* https://html.spec.whatwg.org/multipage/tables.html#attr-tdth-colspan */
donne_colspan :: fonc (élément: *Element) -> n32
{
    attr := donne_attribut_ou_chaine_vide(élément, ATTR_colspan)
    si attr.est_vide() {
        retourne 1
    }

    opt_résultat := parse_a_non_negative_integer(attr)
    saufsi opt_résultat.possède_valeur() {
        retourne 1
    }

    retourne opt_résultat.Quelque
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLTableRowElement
 * https://html.spec.whatwg.org/multipage/tables.html#the-tr-element
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLTableRowElement
 * \{ */

#portée_export

HTMLTableRowElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_table_row_element
}

#portée_fichier

table_virtuelle_table_row_element := TableVirtuelleElement(
    classe = HTMLTableRowElement,
    sur_destruction = élément_sur_destruction,
    sur_changement_attribut = html_element_sur_changement_attribut,
    sur_applique_presentational_hints = table_row_element_sur_applique_presentational_hints
)

table_row_element_sur_applique_presentational_hints :: fonc (base: *Element, résolveuse: *CSS.RésolveuseStyle)
{
    ajoute_propriété_pour_legacy_colour_value(résolveuse, base, ATTR_bgcolor, CSS.PROP_background_color)
    ajoute_propriété_pour_dimension(résolveuse, base, ATTR_height, CSS.PROP_height)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLTableSectionElement
 * https://html.spec.whatwg.org/multipage/tables.html#the-tbody-element
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLTableSectionElement
 * \{ */

#portée_export

HTMLTableSectionElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_table_section_element
}

#portée_fichier

table_virtuelle_table_section_element := TableVirtuelleElement(
    classe = HTMLTableSectionElement,
    sur_destruction = élément_sur_destruction,
    sur_changement_attribut = html_element_sur_changement_attribut,
    sur_applique_presentational_hints = table_section_element_sur_applique_presentational_hints
)

table_section_element_sur_applique_presentational_hints :: fonc (base: *Element, résolveuse: *CSS.RésolveuseStyle)
{
    ajoute_propriété_pour_legacy_colour_value(résolveuse, base, ATTR_bgcolor, CSS.PROP_background_color)
    ajoute_propriété_pour_dimension(résolveuse, base, ATTR_height, CSS.PROP_height)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLTemplateElement
 * https://html.spec.whatwg.org/multipage/scripting.html#the-template-element
 * \{ */

#portée_export

HTMLTemplateElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_template_element

    content: *DocumentFragment
}

/* https://html.spec.whatwg.org/multipage/scripting.html#template-contents */
donne_template_contents :: fonc (template: *HTMLTemplateElement) -> *DocumentFragment
{
    assert(template.content != nul)
    retourne template.content
}

#portée_fichier

table_virtuelle_template_element := TableVirtuelleElement(
    classe = HTMLTemplateElement,
    sur_destruction = élément_sur_destruction,
    sur_changement_attribut = html_element_sur_changement_attribut,
)

/* https://html.spec.whatwg.org/multipage/scripting.html#template-contents */
template_element_sur_création :: fonc (template: *HTMLTemplateElement)
{
    // 1. Let doc be the template element's node document's appropriate template contents owner document.
    doc := donne_appropriate_template_contents_owner_document(template.document)

    // 2. Create a DocumentFragment object whose node document is doc and host is the template element.
    fragment := crée_noeud_fragment_document(doc)
    fragment.host = template

    // 3. Set the template element's template contents to the newly created DocumentFragment object.
    template.content = fragment
}

/* https://html.spec.whatwg.org/multipage/scripting.html#appropriate-template-contents-owner-document */
donne_appropriate_template_contents_owner_document :: fonc (doc: *Document) -> *Document
{
    // 1. If doc is not a Document created by this algorithm, then:
    saufsi doc.créé_par_appropriate_template_contents_owner_document {
        // 1. If doc does not yet have an associated inert template document, then:
        saufsi doc.inert_template_document {
            // 1. Let new doc be a new Document (whose browsing context is null). This is "a Document created by this algorithm" for the purposes of the step above.
            new_doc := crée_noeud_document(JS.donne_tas_de_mémoire(doc), doc.realm)
            new_doc.créé_par_appropriate_template_contents_owner_document = vrai

            // 2. If doc is an HTML document, mark new doc as an HTML document also.
            new_doc.type = doc.type

            // 3. Set doc's associated inert template document to new doc.
            doc.inert_template_document = new_doc
        }

        // 2. Set doc to doc's associated inert template document.
        doc = doc.inert_template_document
    }

    // 2. Return doc.
    retourne doc
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLTextAreaElement
 * https://html.spec.whatwg.org/multipage/form-elements.html#the-textarea-element
 * \{ */

#portée_export

HTMLTextAreaElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_textarea_element
}

/* https://html.spec.whatwg.org/multipage/form-elements.html#attr-textarea-cols-value */
donne_cols :: fonc (textarea: *HTMLTextAreaElement) -> n32
{
    cols := donne_attribut_ou_chaine_vide(textarea, ATTR_cols)
    saufsi cols.est_vide() {
        opt_valeur := parse_a_non_negative_integer(cols)
        si opt_valeur.possède_valeur() && opt_valeur.Quelque > 0 {
            retourne opt_valeur.Quelque
        }
    }
    retourne 20
}

donne_character_width :: fonc (textarea: *HTMLTextAreaElement) -> n32
{
    retourne donne_cols(textarea)
}

/* https://html.spec.whatwg.org/multipage/form-elements.html#attr-textarea-rows-value */
donne_rows :: fonc (textarea: *HTMLTextAreaElement) -> n32
{
    rows := donne_attribut_ou_chaine_vide(textarea, ATTR_rows)
    saufsi rows.est_vide() {
        opt_valeur := parse_a_non_negative_integer(rows)
        si opt_valeur.possède_valeur() && opt_valeur.Quelque > 0 {
            retourne opt_valeur.Quelque
        }
    }
    retourne 2
}

donne_character_height :: fonc (textarea: *HTMLTextAreaElement) -> n32
{
    retourne donne_rows(textarea)
}

#portée_fichier

table_virtuelle_textarea_element := TableVirtuelleElement(
    classe = HTMLTextAreaElement,
    sur_destruction = élément_sur_destruction,
    sur_changement_attribut = html_element_sur_changement_attribut,
    sur_applique_presentational_hints = textarea_element_sur_applique_presentational_hints
)

textarea_element_sur_applique_presentational_hints :: fonc (base: *Element @inutilisée, résolveuse: *CSS.RésolveuseStyle)
{
    couleur_bordure := CouleurRVBAN8(143, 143, 157, 255)
    style_bordure := CSS.PROP_solid
    largeur_bordure := DimensionValue(Length = 1.0)
    ajoute_presentational_hints_pour_bordure(résolveuse, couleur_bordure, largeur_bordure, style_bordure)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLUnknownElement
 * https://html.spec.whatwg.org/multipage/dom.html#htmlunknownelement
 * \{ */

#portée_export

HTMLUnknownElement :: struct {
    empl base_élément: Element
    table = *table_virtuelle_html_unknown_element
}

#portée_fichier

table_virtuelle_html_unknown_element := TableVirtuelleElement(
    classe = HTMLUnknownElement,
    sur_changement_attribut = html_element_sur_changement_attribut
)

/** \} */
