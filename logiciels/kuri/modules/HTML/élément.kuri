importe Chaine
importe Couleur
importe #inemployé CSS
importe Fondation
importe Image
importe Internet
importe Numérique
importe Unicode

est_tag_auto_fermant :: fonc (tag: DOMString) -> bool
{
    discr tag {
        TAG_area,
        TAG_base,
        TAG_br,
        TAG_col,
        TAG_embed,
        TAG_hr,
        TAG_img,
        TAG_input,
        TAG_link,
        TAG_meta,
        TAG_param,
        TAG_source,
        TAG_track,
        TAG_wbr {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

/* ------------------------------------------------------------------------- */
/** \nom Élément
 * https://dom.spec.whatwg.org/#element
 * \{ */

#portée_module

TableVirtuelleÉlément :: struct {
    empl base: TableVirtuelleNoeud

    /* Appelé quand un élément fut dépilé de la pile des éléments ouverts. */
    sur_dépilement: fonc(*Élément)(rien)

    /* Appelé quand un attribut est ajouté, modifié, ou supprimé.
     * La fonction doit retourner si oui ou non l'attribut fut géré. */
    sur_changement_attribut: fonc(*Élément, DOMString, *DOMString, *DOMString, Optionnel(DOMString))(bool) = élément_sur_changement_attribut

    /* Appelé lors de la résolution des propriétés de style pour l'élément. */
    sur_applique_presentational_hints: fonc(*Élément, *CSS.RésolveuseStyle)(rien)
}

#portée_export

Élément :: struct {
    empl base: Noeud
    table = *table_virtuelle_élément

    id: DOMString

    /* Uniquement utilisé lors du parsage. */
    est_sur_pile_éléments_ouvert: bool

    espace_de_nom: chaine // DOMString @namespaceURI
    local_name: DOMString

    état_élément_custom: chaine
    définition_élément_custom: *rien

    pseudo_classes: CSS.PseudoClasses

    /* CSS */
    noeud_de_disposition: *CSS.NoeudDeDisposition
    /* https://html.spec.whatwg.org/multipage/dom.html#attr-style */
    style: *CSS.CSSStyleDeclaration

    /* Cache */
    liste_classes: [..]DOMString
}

#portée_fichier

table_virtuelle_élément := TableVirtuelleÉlément(
    sur_destruction = élément_sur_destruction,
    sur_changement_attribut = élément_sur_changement_attribut
)

élément_détruit_données :: fonc (élément: *Élément)
{
    CSS.détruit_style_declaration(élément.style)
    déloge(élément.liste_classes)
}

élément_sur_destruction :: fonc (base: *EventTarget)
{
    élément := base comme *Élément
    élément_détruit_données(élément)
    déloge(élément)
}

élément_sur_changement_attribut :: fonc (élément: *Élément, local_name: DOMString, vieille_valeur: *DOMString, valeur: *DOMString, espace_de_nom: Optionnel(DOMString)) -> bool
{
    si vieille_valeur && valeur && mémoire(vieille_valeur) == mémoire(valeur) {
        retourne vrai
    }

    /* https://dom.spec.whatwg.org/#concept-id */
    si local_name == ATTR_id && !espace_de_nom.possède_valeur() {
        // 1. If localName is id, namespace is null, and value is null or the empty string, then unset element’s ID.
        si valeur == nul || mémoire(valeur).est_vide() {
            élément.id = crée_chaine_utf16_unique_vide()
        }
        // 2. Otherwise, if localName is id, namespace is null, then set element’s ID to value.
        sinon {
            élément.id = mémoire(valeur)
        }

        retourne vrai
    }

    si local_name == TAG_style {
        CSS.détruit_style_declaration(élément.style)

        si valeur == nul || mémoire(valeur).est_vide() {
            élément.style = nul
        }
        sinon si rendu_css_est_requis(élément) {
            valeur_texte := mémoire(valeur).donne_chaine_utf16()
            élément.style = CSS.parse_attribut_style(valeur_texte)
            // À FAIRE(langage)
            // élément.style.owner_node = élément
        }

        élément.document.invalide_style_depuis_élément(élément)
        retourne vrai
    }

    si local_name == ATTR_class {
        déloge(élément.liste_classes)
        retourne vrai
    }

    retourne faux
}

rendu_css_est_requis :: fonc (élément: *Élément) -> bool
{
    document := élément.document
    saufsi document {
        retourne faux
    }

    user_agent := donne_user_agent(document)
    saufsi user_agent {
        retourne faux
    }

    retourne vrai
}

#portée_export

/* https://dom.spec.whatwg.org/#concept-element-attributes-append */
ajoute_attribut :: fonc (élément: *Élément, attribut_lexé: AttributLexé)
{
    // 1. Append attribute to element’s attribute list.
    attribut := ajoute_attribut(élément, attribut_lexé.nom, attribut_lexé.valeur)

    // 2. Set attribute’s element to element.
    attribut.élément = élément

    // 3. Handle attribute changes for attribute with element, null, and attribute’s value.
    gère_changement_attribute(attribut, élément, nul, *attribut.valeur)
}

/* https://dom.spec.whatwg.org/#concept-element-attributes-change */
change_attribut :: fonc (attribut: *Attr, valeur: DOMString)
{
    // 1. Let oldValue be attribute’s value.
    vieille_valeur := attr.valeur

    // 2. Set attribute’s value to value.
    attribut.valeur = valeur

    // 3. Handle attribute changes for attribute with attribute’s element, oldValue, and value.
    gère_changement_attribute(attribut, attribut.élément, vieille_valeur, valeur)
}

/* https://dom.spec.whatwg.org/#handle-attribute-changes */
gère_changement_attribute :: fonc (attribut: *Attr, élément: *Élément, vieille_valeur: *DOMString, nouvelle_valeur: *DOMString)
{
    // À FAIRE 1. Queue a mutation record of "attributes" for element with attribute’s local name,
    //    attribute’s namespace, oldValue, « », « », null, and null.

    // À FAIRE 2. If element is custom, then enqueue a custom element callback reaction with element,
    //    callback name "attributeChangedCallback", and an argument list containing attribute’s
    //    local name, oldValue, newValue, and attribute’s namespace.

    // 3. Run the attribute change steps with element, attribute’s local name, oldValue, newValue,
    //    and attribute’s namespace.
    table := élément.table comme *TableVirtuelleÉlément
    si table && table.sur_changement_attribut {
        _ := table.sur_changement_attribut(élément, attribut.local_name, vieille_valeur, nouvelle_valeur, attribut.namespace)
    }
}

initialise_élément :: fonc (élément: *Élément, document: *Document, texte: DOMString) -> rien
{
    élément.genre = GenreNoeud.Élément
    élément.document = document
    élément.local_name = texte
}

crée_élément_avec_tag :: fonc (document: *Document, tag: DOMString) -> *Élément
{
    // les éléments pour les balises SVG ne sont pas présents, espace de noms ?
    élément: *Élément
    si tag == TAG_a {
        élément = loge(HTMLAnchorElement)
    }
    sinon si tag == TAG_body {
        élément = loge(HTMLBodyElement)
    }
    sinon si tag == TAG_font {
        élément = loge(HTMLFontElement)
    }
    sinon si tag == TAG_form {
        élément = loge(HTMLFormElement)
    }
    sinon si tag == TAG_head {
        élément = loge(HTMLHeadElement)
    }
    sinon si tag == TAG_h1 || tag == TAG_h2 || tag == TAG_h3 || tag == TAG_h4 || tag == TAG_h5 || tag == TAG_h6 {
        élément = loge(HTMLHeadingElement)
    }
    sinon si tag == TAG_hr {
        élément = loge(HTMLHRElement)
    }
    sinon si tag == TAG_html {
        élément = loge(HTMLHtmlElement)
    }
    sinon si tag == TAG_img {
        élément = loge(HTMLImageElement)
    }
    sinon si tag == TAG_link {
        élément = loge(HTMLLinkElement)
    }
    sinon si tag == TAG_script {
        élément = loge(HTMLScriptElement)
    }
    sinon si tag == TAG_style {
        élément = loge(HTMLStyleElement)
    }
    sinon si tag == TAG_video {
        élément = loge(HTMLVideoElement)
    }
    sinon {
        élément = loge(Élément)
    }

    initialise_élément(élément, document, tag)
    retourne élément
}

élément_fut_dépilé_de_la_pile_des_éléments_ouverts :: fonc (élément: *Élément)
{
    saufsi élément.table {
        retourne
    }

    table_virtuelle := élément.table comme *TableVirtuelleÉlément    
    si table_virtuelle.sur_dépilement  {
        table_virtuelle.sur_dépilement(élément)
    }
}

est_compatible_html5 :: fonc (élément: *Élément) -> bool
{
    discr élément.local_name {
        TAG_acronym,
        TAG_applet,
        TAG_basefont,
        TAG_big,
        TAG_center,
        TAG_dir,
        TAG_font,
        TAG_frame,
        TAG_frameset,
        TAG_noframes,
        TAG_strike,
        TAG_tt {
            retourne faux
        }
        sinon {
            retourne vrai
        }
    }
}

/* https://dom.spec.whatwg.org/#concept-getelementsbyclassname */
get_elements_by_class_name :: fonc (élément: *Élément, class_names: DOMString) -> *HTMLCollection
{
    // 1. Let classes be the result of running the ordered set parser on classNames.
    classes := run_ordered_set_parser(class_names)

    // 2. If classes is the empty set, return an empty HTMLCollection.
    si classes.taille == 0 {
        retourne loge(HTMLCollection)
    }

    // 3. Return an HTMLCollection rooted at root, whose filter matches
    //    descendant elements that have all their classes in classes.
    //    The comparisons for the classes must be done in an ASCII
    //    case-insensitive manner if root’s node document’s mode is "quirks";
    //    otherwise in an identical to manner.
    résultat := loge(HTMLCollection)
    résultat.root = élément
    résultat.filter = crée_filtre_pour_class_name(classes)
    initialise_collection_pour_filtre(résultat)
    retourne résultat
}

/* https://dom.spec.whatwg.org/#concept-getelementsbytagname */
get_elements_by_tag_name :: fonc (élément: *Élément, qualified_name: DOMString) -> *HTMLCollection
{   
    résultat := loge(HTMLCollection)
    résultat.root = élément

    // 1. If qualifiedName is U+002A (*), then return an HTMLCollection rooted at root, whose filter matches only descendant elements.

    // 2. Otherwise, if root’s node document is an HTML document, return an HTMLCollection rooted at root, whose filter matches the following descendant elements:

    //     Whose namespace is the HTML namespace and whose qualified name is qualifiedName, in ASCII lowercase.

    //     Whose namespace is not the HTML namespace and whose qualified name is qualifiedName.

    // 3. Otherwise, return an HTMLCollection rooted at root, whose filter matches descendant elements whose qualified name is qualifiedName. 
    résultat.filter = crée_filtre_pour_tag_name(qualified_name)

    initialise_collection_pour_filtre(résultat)
    retourne résultat
}

donne_liste_classe :: fonc (élément: *Élément) -> []DOMString
{
    saufsi élément.liste_classes {
        valeur := donne_attribut(élément, ATTR_class)
        si valeur.possède_valeur() {
            élément.liste_classes = divise_sur_espaces_blanches_ascii(valeur.Quelque)
        }
    }

    retourne élément.liste_classes
}

/** \} */

fait_partie_de_catégorie_spécial :: fonc (nom: DOMString) -> bool
{
    // À FAIRE : utilisation d'une recherche binaire
    retourne fait_partie_de(nom,
                            TAG_address, TAG_applet, TAG_area, TAG_article,
                            TAG_aside, TAG_base, TAG_basefont, TAG_bgsound,
                            TAG_blockquote, TAG_body, TAG_br, TAG_button,
                            TAG_caption, TAG_center, TAG_col, TAG_colgroup,
                            TAG_dd, TAG_details, TAG_dir, TAG_div, TAG_dl,
                            TAG_dt, TAG_embed, TAG_fieldset, TAG_figcaption,
                            TAG_figure, TAG_footer, TAG_form, TAG_frame,
                            TAG_frameset, TAG_h1, TAG_h2, TAG_h3, TAG_h4,
                            TAG_h5, TAG_h6, TAG_head, TAG_header, TAG_hgroup,
                            TAG_hr, TAG_html, TAG_iframe, TAG_img, TAG_input,
                            TAG_keygen, TAG_li, TAG_link, TAG_listing, TAG_main,
                            TAG_marquee, TAG_menu, TAG_meta, TAG_nav, TAG_noembed,
                            TAG_noframes, TAG_noscript, TAG_object, TAG_ol, TAG_p,
                            TAG_param, TAG_plaintext, TAG_pre, TAG_script,
                            TAG_section, TAG_select, TAG_source, TAG_style,
                            TAG_summary, TAG_table, TAG_tbody, TAG_td, TAG_template,
                            TAG_textarea, TAG_tfoot, TAG_th, TAG_thead, TAG_title,
                            TAG_tr, TAG_track, TAG_ul, TAG_wbr, TAG_xmp, TAG_mi,
                            TAG_mo, TAG_mn, TAG_ms, TAG_mtext, TAG_annotation_xml,
                            TAG_foreignObject, TAG_desc, TAG_title)
}

enfant_directe_avec_balise :: fonc (élément: *Élément, balise: DOMString) -> *Élément
{
    pour élément.enfants {
        saufsi it.genre == GenreNoeud.Élément {
            continue
        }

        élément_enfant := (it comme *Élément)
        si élément_enfant.local_name == balise {
            retourne élément_enfant
        }
    }

    retourne nul
}

/* ------------------------------------------------------------------------- */
/** \nom CSS
 * \{ */

ajoute_pseudo_classe :: fonc (élément: *Élément, pseudo_classe: CSS.PseudoClasses)
{
    si (élément.pseudo_classes & pseudo_classe) == pseudo_classe {
        retourne
    }

    élément.pseudo_classes |= pseudo_classe
    assert(élément.document != nul)
    élément.document.invalide_style(élément, pseudo_classe)
}

enlève_pseudo_classe :: fonc (élément: *Élément, pseudo_classe: CSS.PseudoClasses)
{
    si (élément.pseudo_classes & pseudo_classe) != pseudo_classe {
        retourne
    }

    élément.pseudo_classes &= ~pseudo_classe
    assert(élément.document != nul)
    élément.document.invalide_style(élément, pseudo_classe)
}

est_en_train_d_être_activé :: fonc (élément: *Élément, ouinon: bool)
{
    /* À FAIRE : gère tous les cas/différencie les niveaux d'activation ?
     * https://html.spec.whatwg.org/multipage/semantics-other.html#concept-selector-active */
    si ouinon {
        élément.ajoute_pseudo_classe(CSS.PseudoClasses.Active)
    }
    sinon {
        élément.enlève_pseudo_classe(CSS.PseudoClasses.Active)
    }
}

applique_presentational_hints :: fonc (élément: *Élément, résolveuse: *CSS.RésolveuseStyle)
{
    table := élément.table comme *TableVirtuelleÉlément
    saufsi table {
        retourne
    }
    saufsi table.sur_applique_presentational_hints {
        retourne
    }
    table.sur_applique_presentational_hints(élément, résolveuse)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLElement
 * https://html.spec.whatwg.org/multipage/dom.html#htmlelement
 * \{ */

HTMLElement :: struct {
    empl base_élément: Élément
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLAnchorElement
 * https://html.spec.whatwg.org/multipage/text-level-semantics.html#htmlanchorelement
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLAnchorElement
 * \{ */

#portée_export

HTMLAnchorElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_anchor_element
}

est_hyperlien :: fonc (anchor: *HTMLAnchorElement) -> bool
{
    retourne anchor.donne_attribut(ATTR_href).possède_valeur()
}

donne_href :: fonc (anchor: *HTMLAnchorElement) -> DOMString
{
    retourne donne_attribut_ou_chaine_vide(anchor, ATTR_href)
}

#portée_fichier

table_virtuelle_anchor_element := TableVirtuelleÉlément(
    sur_destruction = anchor_element_sur_destruction,
    sur_activation_behavior = anchor_element_sur_activation_behavior,
    sur_changement_attribut = anchor_element_sur_changement_attribut
)

anchor_element_sur_destruction :: fonc (base: *EventTarget)
{
    élément := base comme *HTMLAnchorElement
    élément_détruit_données(élément)
    déloge(élément)
}

anchor_element_sur_changement_attribut :: fonc (base: *Élément, local_name: DOMString, vieille_valeur: *DOMString, valeur: *DOMString, espace_de_nom: Optionnel(DOMString)) -> bool
{
    si élément_sur_changement_attribut(base, local_name, vieille_valeur, valeur, espace_de_nom) {
        retourne vrai
    }

    anchor := base comme *HTMLAnchorElement

    si local_name == ATTR_href {
        si valeur == nul || mémoire(valeur).est_vide() {
            anchor.enlève_pseudo_classe(CSS.PseudoClasses.Link)
        }
        sinon {
            anchor.ajoute_pseudo_classe(CSS.PseudoClasses.Link)
        }

        retourne vrai
    }

    retourne faux
}

/* À FAIRE : standardise
 * https://html.spec.whatwg.org/multipage/links.html#api-for-a-and-area-elements */
anchor_element_sur_activation_behavior :: fonc (target: *EventTarget, event: *Event @inutilisée)
{
    anchor := target comme *HTMLAnchorElement
    imprime("[%] %\n", #nom_de_cette_fonction, anchor.donne_href())

    /* Follow the hyperlink.
     * https://html.spec.whatwg.org/multipage/links.html#following-hyperlinks-2 */
    navigable := donne_node_navigable(anchor)
    saufsi navigable {
        imprime("[%] pas de navigable\n", #nom_de_cette_fonction)
        retourne
    }

    chn_href := converti_vers_chaine(anchor.donne_href().donne_chaine_utf16())

    url := tente parse_uri_standard(chn_href) piège err {
        imprime("[%] impossible de parser l'URI : %\n", #nom_de_cette_fonction, err)
        diffère déloge(chn_href)
        retourne
    }

    source_document := anchor.document
    navigate(source_document.donne_user_agent(), navigable, url, source_document)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLBodyElement
 * https://html.spec.whatwg.org/multipage/sections.html#the-body-element
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLBodyElement
 * \{ */

#portée_export

HTMLBodyElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_body_element
}

#portée_fichier

table_virtuelle_body_element := TableVirtuelleÉlément(
    sur_destruction = body_element_sur_destruction,
    sur_applique_presentational_hints = body_element_sur_applique_presentational_hints
)

body_element_sur_destruction :: fonc (base: *EventTarget)
{
    élément := base comme *HTMLBodyElement
    élément_détruit_données(élément)
    déloge(élément)
}

/* https://html.spec.whatwg.org/multipage/rendering.html#the-page */
body_element_sur_applique_presentational_hints :: fonc (base: *Élément, résolveuse: *CSS.RésolveuseStyle)
{
    ajoute_propriété_pour_legacy_colour_value(résolveuse, base, ATTR_bgcolor, CSS.PROP_background_color)
    ajoute_propriété_pour_legacy_colour_value(résolveuse, base, ATTR_text, CSS.PROP_color)

    /* À FAIRE : utilise les attributs. */
    ajoute_propriété_pour_nombre(résolveuse, CSS.PROP_margin_top, 8.0)
    ajoute_propriété_pour_nombre(résolveuse, CSS.PROP_margin_bottom, 8.0)
    ajoute_propriété_pour_nombre(résolveuse, CSS.PROP_margin_left, 8.0)
    ajoute_propriété_pour_nombre(résolveuse, CSS.PROP_margin_right, 8.0)
}

ajoute_propriété_pour_legacy_colour_value :: fonc (résolveuse: *CSS.RésolveuseStyle, élément: *Élément, nom_attribut: DOMString, nom_propriété: CSS.CSSOMString)
{
    opt_attribut := élément.donne_attribut(nom_attribut)
    si opt_attribut.possède_valeur() {
        ajoute_propriété_pour_couleur(résolveuse, nom_propriété, opt_attribut.Quelque)
    }
}

ajoute_propriété_pour_couleur :: fonc (résolveuse: *CSS.RésolveuseStyle, nom_propriété: CSS.CSSOMString, texte: DOMString)
{
    opt_couleur := parse_a_legacy_colour_value(texte)
    saufsi opt_couleur.possède_valeur() {
        retourne
    }

    couleur := opt_couleur.Quelque
    value: [..]CSS.ValeurDeStyle
    tableau_ajoute(*value, CSS.ValeurDeStyle(couleur = couleur))

    /* À FAIRE : fuite de mémoire */
    déclaration := loge(CSS.DéclarationPropriété)
    déclaration.info = CSS.donne_info_type_pour_nom(nom_propriété)
    déclaration.property_name = nom_propriété
    déclaration.value = value

    CSS.ajoute_presentational_hint(résolveuse, déclaration)
}

ajoute_propriété_pour_mot_clé :: fonc (résolveuse: *CSS.RésolveuseStyle, nom_propriété: CSS.CSSOMString, mot_clé: CSS.CSSOMString)
{
    value: [..]CSS.ValeurDeStyle
    tableau_ajoute(*value, CSS.ValeurDeStyle(mot_clé = mot_clé))

    /* À FAIRE : fuite de mémoire */
    déclaration := loge(CSS.DéclarationPropriété)
    déclaration.info = CSS.donne_info_type_pour_nom(nom_propriété)
    déclaration.property_name = nom_propriété
    déclaration.value = value

    CSS.ajoute_presentational_hint(résolveuse, déclaration)
}

ajoute_propriété_pour_non_zero_dimension :: fonc (résolveuse: *CSS.RésolveuseStyle, élément: *Élément, nom_attribut: DOMString, nom_propriété: CSS.CSSOMString)
{
    opt_attribut := élément.donne_attribut(nom_attribut)
    si opt_attribut.possède_valeur() {
        valeur := parse_a_non_zero_dimension(opt_attribut.Quelque)
        si valeur.possède_valeur() {
            ajoute_propriété_pour_nombre(résolveuse, nom_propriété, valeur.Quelque)
        }
    }
}

ajoute_propriété_pour_nombre :: fonc (résolveuse: *CSS.RésolveuseStyle, nom_propriété: CSS.CSSOMString, valeur: r64)
{
    value: [..]CSS.ValeurDeStyle
    tableau_ajoute(*value, CSS.ValeurDeStyle(number = valeur))

    /* À FAIRE : fuite de mémoire */
    déclaration := loge(CSS.DéclarationPropriété)
    déclaration.info = CSS.donne_info_type_pour_nom(nom_propriété)
    déclaration.property_name = nom_propriété
    déclaration.value = value

    CSS.ajoute_presentational_hint(résolveuse, déclaration)
}

/* https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#rules-for-parsing-a-legacy-colour-value */
parse_a_legacy_colour_value :: fonc (string: DOMString) -> Optionnel(CouleurRVBAN8)
{
    // 1. Let input be the string being parsed.
    input := string.donne_chaine_utf16()

    // 2. If input is the empty string, then return an error.
    si input.est_vide() {
        retourne
    }

    // 3. Strip leading and trailing ASCII whitespace from input.
    input = supprime_espace_blanches_autour(input)

    // 4. If input is an ASCII case-insensitive match for the string "transparent", then return an error.
    si compare_ascii_insensible_à_la_casse(input, "transparent") {
        retourne
    }

    // 5. If input is an ASCII case-insensitive match for one of the named colors, then return the simple color corresponding to that keyword. [CSSCOLOR]
    // À FAIRE : n'utilise que les mots-clés appropriés
    opt_couleur := CSS.trouve_couleur_pour_mot_clé(crée_chaine_utf16_unique(input))
    si opt_couleur.possède_valeur() {
        retourne opt_couleur
    }

    // 6. If input's code point length is four, and the first character in input is U+0023 (#), and the last three characters of input are all ASCII hex digits, then:
    si input.taille() == 4 && input.unités[0] == 0x23 && est_chiffre_hexadecimal_ascii(input.unités[1]) && est_chiffre_hexadecimal_ascii(input.unités[2]) && est_chiffre_hexadecimal_ascii(input.unités[3]) {
        // 1. Let result be a simple color.
        result: CouleurRVBAN8
        result.a = 255

        // 2. Interpret the second character of input as a hexadecimal digit; let the red component of result be the resulting number multiplied by 17.
        result.r = CSS.valeur_hex_depuis_unité(input.unités[1]) * 17

        // 3. Interpret the third character of input as a hexadecimal digit; let the green component of result be the resulting number multiplied by 17.
        result.r = CSS.valeur_hex_depuis_unité(input.unités[2]) * 17

        // 4. Interpret the fourth character of input as a hexadecimal digit; let the blue component of result be the resulting number multiplied by 17.
        result.r = CSS.valeur_hex_depuis_unité(input.unités[3]) * 17

        // 5. Return result.
        retourne result
    }

    // À FAIRE : 7. Replace any code points greater than U+FFFF in input (i.e., any characters that are not in the basic multilingual plane) with the two-character string "00".

    // 8. If input's code point length is greater than 128, truncate input, leaving only the first 128 characters.
    // À FAIRE : utilise la taille en point de code
    si input.taille() > 128 {
        input.unités.taille = 128
    }

    // 9. If the first character in input is a U+0023 NUMBER SIGN character (#), remove it.
    si input.unités[0] == 0x23 {
        input.unités.pointeur += 1
        input.unités.taille -= 1
    }

    // 10. Replace any character in input that is not an ASCII hex digit with the character U+0030 DIGIT ZERO (0).
    pour & input.unités {
        point_de_code : n16 = it
        saufsi est_chiffre_hexadecimal_ascii(point_de_code) {
            it = 0x30
        }
    }

    // À FAIRE : continue
    assert(input.taille() == 6)

    // 11. While input's code point length is zero or not a multiple of three, append a U+0030 DIGIT ZERO (0) character to input.

    // 12. Split input into three strings of equal code point length, to obtain three components. Let length be the code point length that all of those components have (one third the code point length of input).

    // 13. If length is greater than 8, then remove the leading length-8 characters in each component, and let length be 8.

    // 14. While length is greater than two and the first character in each component is a U+0030 DIGIT ZERO (0) character, remove that character and reduce length by one.

    // 15. If length is still greater than two, truncate each component, leaving only the first two characters in each.

    // 16. Let result be a simple color.
    result: CouleurRVBAN8
    result.a = 255

    // 17. Interpret the first component as a hexadecimal number; let the red component of result be the resulting number.
    result.r = CSS.valeur_hex_depuis_unité(input.unités[0]) * 16 + CSS.valeur_hex_depuis_unité(input.unités[1])

    // 18. Interpret the second component as a hexadecimal number; let the green component of result be the resulting number.
    result.v = CSS.valeur_hex_depuis_unité(input.unités[2]) * 16 + CSS.valeur_hex_depuis_unité(input.unités[3])

    // 19. Interpret the third component as a hexadecimal number; let the blue component of result be the resulting number.
    result.b = CSS.valeur_hex_depuis_unité(input.unités[4]) * 16 + CSS.valeur_hex_depuis_unité(input.unités[5])

    // 20. Return result.
    retourne result
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLFontElement
 * https://html.spec.whatwg.org/multipage/obsolete.html#htmlfontelement
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLFontElement
 * \{ */

#portée_export

HTMLFontElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_font_element
}

#portée_fichier

table_virtuelle_font_element := TableVirtuelleÉlément(
    sur_destruction = font_element_sur_destruction,
    sur_applique_presentational_hints = font_element_sur_applique_presentational_hints
)

font_element_sur_destruction :: fonc (base: *EventTarget)
{
    élément := base comme *HTMLFontElement
    élément_détruit_données(élément)
    déloge(élément)
}

/* https://html.spec.whatwg.org/multipage/rendering.html#phrasing-content-3 */
font_element_sur_applique_presentational_hints :: fonc (base: *Élément, résolveuse: *CSS.RésolveuseStyle)
{
    font := base comme *HTMLFontElement

    opt_color := donne_attribut(font, ATTR_color)
    si opt_color.possède_valeur() {
        color := opt_color.Quelque
        ajoute_propriété_pour_couleur(résolveuse, CSS.PROP_color, color)
    }

    opt_size := donne_attribut(font, ATTR_size)
    si opt_size.possède_valeur() {
        opt_font_size := parse_a_legacy_font_size(opt_size.Quelque)
        si opt_font_size.possède_valeur() {
            ajoute_propriété_pour_mot_clé(résolveuse, CSS.PROP_font_size, opt_font_size.Quelque)
        }
    }

    /* À FAIRE : face. */
}

parse_a_legacy_font_size :: fonc (attribute_value: DOMString) -> Optionnel(CSS.CSSOMString)
{
    // 1. Let input be the attribute's value.
    input := attribute_value.donne_chaine_utf16()

    // 2. Let position be a pointer into input, initially pointing at the start of the string.
    position := input.unités.pointeur
    fin := position + input.taille()

    // 3. Skip ASCII whitespace within input given position.
    tantque position < fin {
        saufsi est_espace_blanche_ascii(mémoire(position)) {
            arrête
        }

        position += 1
    }

    // 4. If position is past the end of input, there is no presentational hint. Return.
    si position >= fin {
        retourne
    }

    // 5. If the character at position is a U+002B PLUS SIGN character (+), then let mode be
    //    relative-plus, and advance position to the next character. Otherwise, if the character
    //    at position is a U+002D HYPHEN-MINUS character (-), then let mode be relative-minus,
    //    and advance position to the next character. Otherwise, let mode be absolute.
    ModeFonte :: énum {
        Aucun
        RelativePlus
        RelativeMinus
    }
    mode := ModeFonte.Aucun
    si mémoire(position) == 0x2B {
        mode = ModeFonte.RelativePlus
        position += 1
    }
    sinon si mémoire(position) == 0x2D {
        mode = ModeFonte.RelativeMinus
        position += 1
    }

    // 6. Collect a sequence of code points that are ASCII digits from input given position, and let the resulting sequence be digits.
    //    https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points
    digits: ChaineUTF16

    tantque position < fin {
        saufsi est_chiffre_ascii(mémoire(position)) {
            arrête
        }

        chaine_ajoute(*digits, mémoire(position))
        position += 1
    }

    // 7. If digits is the empty string, there is no presentational hint. Return.
    si digits.est_vide() {
        retourne
    }
    diffère détruit_chaine(digits)

    // 8. Interpret digits as a base-ten integer. Let value be the resulting number.
    value: z32
    pour digits.unités {
        value *= 10
        value += (it - '0' comme n16) comme z32
    }

    // 9. If mode is relative-plus, then increment value by 3.
    //    If mode is relative-minus, then let value be the result of subtracting value from 3.
    si mode == ModeFonte.RelativePlus {
        value += 3
    }
    sinon si mode == ModeFonte.RelativeMinus {
        value -= 3
    }

    // 10. If value is greater than 7, let it be 7.
    si value > 7 {
        value = 7
    }

    // 11. If value is less than 1, let it be 1.
    si value < 1 {
        value = 1
    }

    // 12. Set 'font-size' to the keyword corresponding to the value of value according to the following table:
    table := [CSS.PROP_x_small, CSS.PROP_small, CSS.PROP_medium, CSS.PROP_large, CSS.PROP_x_large, CSS.PROP_xx_large, CSS.PROP_xxx_large]
    retourne table[value - 1]
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLFormElement
 * https://html.spec.whatwg.org/multipage/forms.html#htmlformelement
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement
 * \{ */

#portée_export

HTMLFormElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_form_element
}

#portée_fichier

table_virtuelle_form_element := TableVirtuelleÉlément(
    sur_destruction = form_element_sur_destruction
)

form_element_sur_destruction :: fonc (base: *EventTarget)
{
    élément := base comme *HTMLFormElement
    élément_détruit_données(élément)
    déloge(élément)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLHeadElement
 * https://html.spec.whatwg.org/multipage/dom.html#htmlheadelement
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLHeadElement
 * \{ */

#portée_export

HTMLHeadElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_head_element
}

#portée_fichier

table_virtuelle_head_element := TableVirtuelleÉlément(
    sur_destruction = head_element_sur_destruction
)

head_element_sur_destruction :: fonc (base: *EventTarget)
{
    élément := base comme *HTMLHeadElement
    élément_détruit_données(élément)
    déloge(élément)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLHeadingElement
 * https://html.spec.whatwg.org/multipage/sections.html#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLHeadingElement
 * \{ */

#portée_export

HTMLHeadingElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_heading_element
}

#portée_fichier

table_virtuelle_heading_element := TableVirtuelleÉlément(
    sur_destruction = heading_element_sur_destruction
)

heading_element_sur_destruction :: fonc (base: *EventTarget)
{
    élément := base comme *HTMLHeadingElement
    élément_détruit_données(élément)
    déloge(élément)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLHRElement
 * https://html.spec.whatwg.org/multipage/grouping-content.html#the-hr-element
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLHRElement
 * \{ */

#portée_export

HTMLHRElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_hr_element
}

#portée_fichier

table_virtuelle_hr_element := TableVirtuelleÉlément(
    sur_destruction = hr_element_sur_destruction
)

hr_element_sur_destruction :: fonc (base: *EventTarget)
{
    élément := base comme *HTMLHRElement
    élément_détruit_données(élément)
    déloge(élément)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLHtmlElement
 * https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLHtmlElement
 * \{ */

#portée_export

HTMLHtmlElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_html_element
}

#portée_fichier

table_virtuelle_html_element := TableVirtuelleÉlément(
    sur_destruction = html_element_sur_destruction
)

html_element_sur_destruction :: fonc (base: *EventTarget)
{
    élément := base comme *HTMLHtmlElement
    élément_détruit_données(élément)
    déloge(élément)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLAnchorElement
 * https://html.spec.whatwg.org/multipage/embedded-content.html#htmlimageelement
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement
 * \{ */

#portée_export

HTMLImageElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_image_element

    image_data: ImageIO
}

donne_src :: fonc (image: *HTMLImageElement) -> DOMString
{
    retourne donne_attribut_ou_chaine_vide(image, ATTR_src)
}

donne_hauteur_intrinsèque :: fonc (image: *HTMLImageElement) -> z32 #enligne
{
    retourne image.image_data.hauteur
}

donne_largeur_intrinsèque :: fonc (image: *HTMLImageElement) -> z32 #enligne
{
    retourne image.image_data.largeur
}

donne_ratio_intrinsèque :: fonc (image: *HTMLImageElement) -> r32 #enligne
{
    si image.image_data.hauteur == 0 {
        retourne 1.0
    }

    retourne image.image_data.largeur comme r32 / image.image_data.hauteur comme r32
}

#portée_fichier

table_virtuelle_image_element := TableVirtuelleÉlément(
    sur_destruction = image_element_sur_destruction,
    sur_changement_attribut = image_element_sur_changement_attribut,
    sur_applique_presentational_hints = image_element_sur_applique_presentational_hints
)

image_element_sur_changement_attribut :: fonc (base: *Élément, local_name: DOMString, vieille_valeur: *DOMString, valeur: *DOMString, espace_de_nom: Optionnel(DOMString)) -> bool
{
    si élément_sur_changement_attribut(base, local_name, vieille_valeur, valeur, espace_de_nom) {
        retourne vrai
    }

    image := base comme *HTMLImageElement

    si local_name == ATTR_src {
        update_image_data(image)
        retourne vrai
    }

    retourne faux
}

image_element_sur_applique_presentational_hints :: fonc (base: *Élément, résolveuse: *CSS.RésolveuseStyle)
{
    ajoute_propriété_pour_non_zero_dimension(résolveuse, base, ATTR_width, CSS.PROP_width)
    ajoute_propriété_pour_non_zero_dimension(résolveuse, base, ATTR_height, CSS.PROP_height)
}

/* https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#rules-for-parsing-non-zero-dimension-values */
parse_a_non_zero_dimension :: fonc (string: DOMString) -> Optionnel(r64)
{
    // À FAIRE : standardise

    chn := converti_vers_chaine(string.donne_chaine_utf16())
    diffère déloge(chn)

    résultat := tente extrait_r64(chn) piège _ {
        retourne
    }

    retourne résultat
}

image_element_sur_destruction :: fonc (base: *EventTarget)
{
    élément := base comme *HTMLImageElement
    élément_détruit_données(élément)
    IMG_detruit_image(*élément.image_data)
    déloge(élément)
}

/* https://html.spec.whatwg.org/multipage/images.html#update-the-image-data */
update_image_data :: fonc (image: *HTMLImageElement)
{
    // À FAIRE : standardise
    document := image.document
    user_agent := document.donne_user_agent()
    saufsi user_agent {
        retourne
    }

    IMG_detruit_image(*image.image_data)
    image.image_data = ImageIO()

    src := image.donne_src()
    si src.est_vide() {
        document.invalide_style()
        retourne
    }

    base_url := donne_base_url(document)
    url_document := convertis_uri_url(*base_url)

    url_src := basic_url_parser(src.donne_chaine_utf16(), base = url_document)
    saufsi url_src {
        retourne
    }

    url_string := url_serializer(url_src)
    // diffère déloge(url_string)

    // imprime("[%] %\n", #nom_de_cette_fonction, url_string)

    request := loge(Request)
    request.destination = "image"
    request.mode = "no-cors"
    request.redirect_mode = "follow"
    request.url = tente parse_uri_standard(url_string) piège nonatteignable

    RappelProcessResponse :: struct {
        empl base: BaseProcessResponse

        image: *HTMLImageElement
        url_src: *URL
    }

    sur_rappel_process_response :: fonc (base: *BaseProcessResponse, réponse: *Response)
    {
        diffère détruit_response(réponse)

        rappel := base comme *RappelProcessResponse

        saufsi réponse.body_info {
            retourne
        }

        saufsi est_type_mime_image(réponse.body_info.content_type) {
            retourne
        }

        contenu := réponse.body.Quelque

        proxy_image := IMG_cree_proxy_memoire(contenu.pointeur, contenu.taille comme n64)
        diffère IMG_detruit_proxy(proxy_image)

        chn_c_chemin := crée_chaine_c(rappel.url_src.path.Path[rappel.url_src.path.Path.taille - 1])
        diffère détruit_chaine_c(chn_c_chemin)

        résultat_lecture_image := IMG_ouvre_image_avec_proxy(chn_c_chemin, *rappel.image.image_data, proxy_image)
        si résultat_lecture_image != ResultatOperation.OK {
            imprime("Impossible de lire l'image : %\n", résultat_lecture_image)
        }

        invalide_style(rappel.image.document)
    }

    sur_destruction_process_response :: fonc (base: *BaseProcessResponse)
    {
        rappel := base comme *RappelProcessResponse
        déloge(rappel)
    }

    process_response := loge(RappelProcessResponse)
    process_response.image = image
    process_response.url_src = url_src
    process_response.sur_rappel = sur_rappel_process_response
    process_response.sur_destruction = sur_destruction_process_response

    fetch_controller := fetch(user_agent, request, process_response = process_response)
    diffère détruit_fetch_controller(fetch_controller)
}

est_type_mime_image :: fonc (content_type: chaine) -> bool
{
    retourne content_type == "image/jpeg" || content_type == "image/png"
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLLinkElement
 * https://html.spec.whatwg.org/multipage/semantics.html#the-link-element
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLLinkElement
 * \{ */

#portée_export

HTMLLinkElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_link_element
}

donne_href :: fonc (link: *HTMLLinkElement) -> DOMString
{
    retourne donne_attribut_ou_chaine_vide(link, ATTR_href)
}

donne_rel :: fonc (link: *HTMLLinkElement) -> DOMString
{
    retourne donne_attribut_ou_chaine_vide(link, ATTR_rel)
}

#portée_fichier

table_virtuelle_link_element := TableVirtuelleÉlément(
    sur_destruction = link_element_sur_destruction,
    sur_changement_attribut = link_element_sur_changement_attribut
)

link_element_sur_destruction :: fonc (base: *EventTarget)
{
    élément := base comme *HTMLLinkElement
    élément_détruit_données(élément)
    déloge(élément)
}

link_element_sur_changement_attribut :: fonc (base: *Élément, local_name: DOMString, vieille_valeur: *DOMString, valeur: *DOMString, espace_de_nom: Optionnel(DOMString)) -> bool
{
    si élément_sur_changement_attribut(base, local_name, vieille_valeur, valeur, espace_de_nom) {
        retourne vrai
    }

    link := base comme *HTMLLinkElement

    si local_name == ATTR_href || local_name == ATTR_rel {
        process_link_element(link)
        retourne vrai
    }

    retourne faux
}

/* https://html.spec.whatwg.org/multipage/links.html */
process_link_element :: fonc (link: *HTMLLinkElement)
{
    rel := link.donne_rel()
    si rel.est_vide() {
        link.document.supprime_feuille_de_style_associée(link)
        retourne
    }

    types := run_ordered_set_parser(rel)
    diffère déloge(types)

    est_stylesheet := faux
    est_alternate := faux

    pour types {
        si it == ATTR_stylesheet {
            est_stylesheet = vrai
        }
        sinon si it == ATTR_alternate {
            est_alternate = vrai
        }
    }

    si est_stylesheet && !est_alternate {
        process_stylesheet_link(link)
    }
}

process_stylesheet_link :: fonc (link: *HTMLLinkElement)
{
    // À FAIRE : standardise
    document := link.document
    user_agent := document.donne_user_agent()
    saufsi user_agent {
        retourne
    }

    document.supprime_feuille_de_style_associée(link)

    src := link.donne_href()
    si src.est_vide() {
        retourne
    }

    base_url := donne_base_url(document)
    url_document := convertis_uri_url(*base_url)

    url_src := basic_url_parser(src.donne_chaine_utf16(), base = url_document)
    saufsi url_src {
        retourne
    }

    url_string := url_serializer(url_src)

    request := loge(Request)
    request.destination = "style"
    request.mode = "no-cors"
    request.redirect_mode = "follow"
    request.url = tente parse_uri_standard(url_string) piège nonatteignable

    RappelProcessResponse :: struct {
        empl base: BaseProcessResponse

        link: *HTMLLinkElement
        url_src: *URL
        url_string: ChaineASCII
    }

    sur_rappel_process_response :: fonc (base: *BaseProcessResponse, réponse: *Response)
    {
        diffère détruit_response(réponse)

        rappel := base comme *RappelProcessResponse

        saufsi réponse.body_info {
            retourne
        }

        saufsi réponse.body_info.content_type == "text/css" {
            retourne
        }

        contenu := réponse.body.Quelque

        mime_css := crée_chaine_utf16_unique("text/css")

        feuille_de_style := loge(CSS.CSSStyleSheet)
        feuille_de_style.location.uri = rappel.url_string
        feuille_de_style.origine = CSS.OrigineCascade.Author
        feuille_de_style.type = mime_css
        feuille_de_style.owner_node = rappel.link
        feuille_de_style.alternate = faux
        feuille_de_style.origin_clean = vrai
        feuille_de_style.parent_style_sheet = nul
        feuille_de_style.owner_rule = nul

        // Non-spécifié
        ctx: CSS.ContexteParsageFeuilleDeStyle
        diffère CSS.détruit_données_contexte(*ctx)
        CSS.parse_style_rules(*ctx, feuille_de_style, contenu)
        CSS.rapporte_propriétés_non_supportées(*ctx, #nom_de_cette_fonction)
        rappel.link.document.ajoute_feuille_de_style(feuille_de_style)
    }

    sur_destruction_process_response :: fonc (base: *BaseProcessResponse)
    {
        rappel := base comme *RappelProcessResponse
        déloge(rappel)
    }

    process_response := loge(RappelProcessResponse)
    process_response.link = link
    process_response.url_string = url_string
    process_response.url_src = url_src
    process_response.sur_rappel = sur_rappel_process_response
    process_response.sur_destruction = sur_destruction_process_response

    fetch_controller := fetch(user_agent, request, process_response = process_response)
    diffère détruit_fetch_controller(fetch_controller)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLMediaElement
 * https://html.spec.whatwg.org/multipage/media.html#htmlmediaelement
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement
 * \{ */

#portée_export

HTMLMediaElement :: struct {
    empl html_element: HTMLElement
}

donne_src :: fonc (media: *HTMLMediaElement) -> DOMString
{
    retourne donne_attribut_ou_chaine_vide(media, ATTR_src)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLVideoElement
 * https://html.spec.whatwg.org/multipage/media.html#htmlvideoelement
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement
 * \{ */

#portée_export

HTMLVideoElement :: struct {
    empl html_media: HTMLMediaElement
    table = *table_virtuelle_video_element
}

#portée_fichier

table_virtuelle_video_element := TableVirtuelleÉlément(
    sur_destruction = video_element_sur_destruction
)

video_element_sur_destruction :: fonc (base: *EventTarget)
{
    élément := base comme *HTMLVideoElement
    élément_détruit_données(élément)
    déloge(élément)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLScriptElement
 * https://html.spec.whatwg.org/multipage/scripting.html#htmlscriptelement
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLScriptElement
 * \{ */

#portée_export

TypeScript :: énum {
    NUL
    CLASSIC
    MODULE
    IMPORTMAP
}

OptionsFetchScript :: struct {
    cryptographic_nonce: chaine
    integrity_metadata: chaine
    parser_metadata := "not-parser-inserted"
    credentials_mode := "same-origin"
    referrer_policy: chaine
    render_blocking: bool
    fetch_priority := "auto"
}

HTMLScriptElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_script_element

    document_parseur: *Document
    document_du_temps_de_préparation: *Document

    force_async := vrai // À FAIRE : doit être faux lors de l'ajout d'un attribut async
    provient_de_fichier_externe := faux
    prêt_à_être_exécuté_par_parseuse := faux
    déjà_commencé := faux
    temporise_évènement_de_charge := faux

    type: TypeScript
    // result : "uninitialized", null, scipt, import map parse result
}

donne_src :: fonc (script: *HTMLScriptElement) -> DOMString
{
    retourne donne_attribut_ou_chaine_vide(script, ATTR_src)
}

#portée_fichier

table_virtuelle_script_element := TableVirtuelleÉlément(
    sur_destruction = script_element_sur_destruction
)

script_element_sur_destruction :: fonc (base: *EventTarget)
{
    élément := base comme *HTMLScriptElement
    élément_détruit_données(élément)
    déloge(élément)
}

#portée_export

/* https://html.spec.whatwg.org/multipage/scripting.html#prepare-the-script-element */
prépare :: fonc (script: *HTMLScriptElement)
{
    /* 1. */
    si script.déjà_commencé {
        retourne
    }

    /* 2. & 3. */
    document_parseur := script.document_parseur
    script.document_parseur = nul

    /* 4. */
    si document_parseur != nul && !script.possède_attribut(ATTR_async) {
        script.force_async = vrai
    }

    /* 5. */
    texte_source := extrait_texte_noeud(script)
    diffère déloge(texte_source)

    /* 6. */
    possède_attr_src := script.possède_attribut(ATTR_src)
    si !possède_attr_src && texte_source == "" {
        retourne
    }

    /* 7. */
    saufsi script.est_connecté() {
        retourne
    }

    /* 8. */
    type_bloc_script := détermine_type_block_script(script)
    
    /* 9. */
    si est_type_mime_javascript(type_bloc_script) {
        script.type = TypeScript.CLASSIC
    }
    /* 10. */
    sinon si compare_ascii_insensible_à_la_casse(type_bloc_script, ATTR_module) {
        script.type = TypeScript.MODULE
    }
    /* 11. */
    sinon si compare_ascii_insensible_à_la_casse(type_bloc_script, ATTR_importmap) {
        script.type = TypeScript.IMPORTMAP
    }
    /* 12. */
    sinon {
        retourne
    }

    /* 13. */
    si document_parseur != nul {
        script.document_parseur = document_parseur
        script.force_async = faux
    }

    /* 14. */
    script.déjà_commencé = vrai

    /* 15. */
    script.document_du_temps_de_préparation = script.document

    /* 16. */
    si document_parseur != nul && document_parseur != script.document_du_temps_de_préparation {
        retourne
    }

    /* 17. */
    si script.scripting_est_désactivé() {
        retourne
    }

    /* 18. */
    si script.possède_attribut(ATTR_nomodule) && script.type == TypeScript.CLASSIC {
        retourne
    }

    /* 19. */
    saufsi possède_attr_src {
        bloqué := le_comportement_inline_de_l_élément_doit_être_bloqué_par_csp(script, "script", texte_source)
        si bloqué == "Blocked" {
            retourne
        }
    }

    /* 20. */
    si script.type == TypeScript.CLASSIC && script.possède_attribut(ATTR_for) && script.possède_attribut(ATTR_event) {
        valeur_for := script.donne_attribut(ATTR_for).Quelque
        valeur_event := script.donne_attribut(ATTR_event).Quelque

        valeur_event = supprime_espace_blanches_autour(valeur_event)
        valeur_for = supprime_espace_blanches_autour(valeur_for)

        saufsi compare_ascii_insensible_à_la_casse(valeur_for, ATTR_window) {
            retourne
        }
    
        saufsi compare_ascii_insensible_à_la_casse(valeur_event, ATTR_onload) || compare_ascii_insensible_à_la_casse(valeur_event, "onload()") {
            retourne
        }
    }

    /* 21. INCOMPLET : charset */

    /* 22. INCOMPLET */
    /* 23. INCOMPLET */
    module_script_credentials := ""

    /* 24. INCOMPLET */
    cryptographic_nonce := ""

    /* 25. INCOMPLET */
    integrity := ""

    /* 26. INCOMPLET */
    referrer_policy := ""

    /* 27. INCOMPLET */
    fetch_priority := ""

    /* 28. */
    métadonnée_parseuse := si script.est_inséré_par_parseuse() {
        "parser-inserted"
    }
    sinon {
        "not-parser-inserted"
    }

    /* 29. */
    options: OptionsFetchScript
    options.cryptographic_nonce = cryptographic_nonce
    options.integrity_metadata = integrity
    options.parser_metadata = métadonnée_parseuse
    options.credentials_mode = module_script_credentials
    options.referrer_policy = referrer_policy
    options.fetch_priority = fetch_priority

    /* 30. INCOMPLET settings object */

    /* 31. */
    si possède_attr_src {
        imprime("source\n")
    }
    /* 32. */
    sinon {
        imprime("pas de source\n")
        imprime("Texte source: %\n", texte_source)
    }

    /* 33. INCOMPLET */

    /* 34. INCOMPLET */
}

est_inséré_par_parseuse :: fonc (script: *HTMLScriptElement) -> bool
{
    retourne script.document_parseur != nul
}

/* https://html.spec.whatwg.org/multipage/webappapis.html#concept-n-noscript */
scripting_est_activé :: fonc (script: *HTMLScriptElement) -> bool
{
    node_document := script.donne_node_document()
    saufsi node_document {
        retourne faux
    }
    saufsi node_document.browsing_context {
        retourne faux
    }
    imprime("À FAIRE : [%]\n", #nom_de_cette_fonction)
    retourne faux
}

scripting_est_désactivé :: fonc (script: *HTMLScriptElement) -> bool
{
    retourne scripting_est_activé(script) == faux
}

détermine_type_block_script :: fonc (script: *HTMLScriptElement) -> DOMString
{
    attr_type := script.cherche_attribut(ATTR_type)
    attr_language := script.cherche_attribut(ATTR_language)

    si (attr_type != nul && attr_type.valeur.est_vide()) ||
         (attr_type == nul && attr_language != nul && attr_language.valeur.est_vide()) ||
         (attr_type == nul && attr_language == nul) {
        retourne crée_chaine_utf16_unique("text/javascript")
    }

    si attr_type {
        /* À FAIRE : supprime espace blanches */
        retourne supprime_espace_blanches_autour(attr_type.valeur)
    }

    assert(attr_language != nul)
    chn := imprime_chaine("text/%", attr_language.valeur)
    diffère déloge(chn)
    retourne crée_chaine_utf16_unique(chn)
}

/* https://mimesniff.spec.whatwg.org/#javascript-mime-type-essence-match */
est_type_mime_javascript :: fonc (chn: DOMString) -> bool
{
    mimes_possibles := [
        "application/ecmascript",
        "application/javascript",
        "application/x-ecmascript",
        "application/x-javascript",
        "text/ecmascript",
        "text/javascript",
        "text/javascript1.0",
        "text/javascript1.1",
        "text/javascript1.2",
        "text/javascript1.3",
        "text/javascript1.4",
        "text/javascript1.5",
        "text/jscript",
        "text/livescript",
        "text/x-ecmascript",
        "text/x-javascript"
    ]

    pour mimes_possibles {
        si compare_ascii_insensible_à_la_casse(chn, it) {
            retourne vrai
        }
    }

    retourne faux
}

/* https://w3c.github.io/webappsec-csp/#should-block-inline */
le_comportement_inline_de_l_élément_doit_être_bloqué_par_csp :: fonc (élément: *Élément, type: chaine @inutilisée, source: chaine @inutilisée) -> chaine
{
    assert(élément != nul)

    résultat := "Allowed"

    /* À FAIRE. */

    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLStyleElement
 * https://html.spec.whatwg.org/multipage/semantics.html#the-style-element
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLStyleElement
 * \{ */

#portée_export

HTMLStyleElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_style_element
}

#portée_fichier

table_virtuelle_style_element := TableVirtuelleÉlément(
    sur_destruction = style_element_sur_destruction,
    sur_connexion = style_element_sur_connexion_ou_déconnexion,
    sur_déconnexion = style_element_sur_connexion_ou_déconnexion,
    sur_dépilement = style_element_sur_dépilement,
    sur_changement_enfants = style_element_sur_changement_enfants
)

style_element_sur_destruction :: fonc (base: *EventTarget)
{
    élément := base comme *HTMLStyleElement
    élément_détruit_données(élément)
    déloge(élément)
}

style_element_sur_connexion_ou_déconnexion :: fonc (base: *Noeud)
{
    style := base comme *HTMLStyleElement
    saufsi style.est_sur_pile_éléments_ouvert {
        ajourne_style_block(style)
    }
}

style_element_sur_dépilement :: fonc (base: *Élément)
{
    style := base comme *HTMLStyleElement
    ajourne_style_block(style)
}

style_element_sur_changement_enfants :: fonc (base: *Noeud)
{
    style := base comme *HTMLStyleElement
    ajourne_style_block(style)
}

/* https://html.spec.whatwg.org/multipage/semantics.html#update-a-style-block
 *
 * The user agent must run the update a style block algorithm whenever any of the following conditions occur:
 *     The element is popped off the stack of open elements of an HTML parser or XML parser.
 *     The element is not on the stack of open elements of an HTML parser or XML parser, and it becomes connected or disconnected.
 *     The element's children changed steps run.
 */
ajourne_style_block :: fonc (style: *HTMLStyleElement)
{
    saufsi rendu_css_est_requis(style) {
        retourne
    }

    // 1. Let element be the style element.
    element := style

    // 2. If element has an associated CSS style sheet, remove the CSS style sheet
    //    in question.
    document := element.document
    document.supprime_feuille_de_style_associée(element)

    // 3. If element is not connected, then return.
    saufsi element.est_connecté() {
        retourne
    }

    // 4. If element's type attribute is present and its value is neither the
    //    empty string nor an ASCII case-insensitive match for "text/css", then
    //    return.
    mime_css := crée_chaine_utf16_unique("text/css")

    attr_type := element.cherche_attribut(ATTR_type)
    si attr_type && !(attr_type.valeur.est_vide() || compare_ascii_insensible_à_la_casse(attr_type.valeur, mime_css)) {
        retourne
    }

    // 5. If the Should element's inline behavior be blocked by Content Security Policy?
    //    algorithm returns "Blocked" when executed upon the style element, "style",
    //    and the style element's child text content, then return. [CSP]
    texte_source := extrait_texte_noeud(style)
    diffère déloge(texte_source)

    bloqué := le_comportement_inline_de_l_élément_doit_être_bloqué_par_csp(element, "style", texte_source)
    si bloqué == "Blocked" {
        retourne
    }

    // 6. Create a CSS style sheet with the following properties:
    feuille_de_style := loge(CSS.CSSStyleSheet)
    feuille_de_style.origine = CSS.OrigineCascade.Author
    feuille_de_style.type = mime_css
    feuille_de_style.owner_node = element
    // À FAIRE : media = The media attribute of element.
    // À FAIRE : title = The title attribute of element, if element is in a document tree, or the empty string otherwise.
    feuille_de_style.alternate = faux
    feuille_de_style.origin_clean = vrai
    feuille_de_style.parent_style_sheet = nul
    feuille_de_style.owner_rule = nul

    //  À FAIRE : 7. If element contributes a script-blocking style sheet, append element
    //    to its node document's script-blocking style sheet set.

    // À FAIRE : 8. If element's media attribute's value matches the environment and
    //    element is potentially render-blocking, then block rendering on element.

    // Non-spécifié
    ctx: CSS.ContexteParsageFeuilleDeStyle
    diffère CSS.détruit_données_contexte(*ctx)
    CSS.parse_style_rules(*ctx, feuille_de_style, texte_source)
    CSS.rapporte_propriétés_non_supportées(*ctx, #nom_de_cette_fonction)
    document.ajoute_feuille_de_style(feuille_de_style)

    // À FAIRE : implémente la finalisation
}

/** \} */
