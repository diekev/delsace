importe Chaine
importe Couleur
importe #inemployé CSS
importe Fondation
importe Image
importe Internet
importe #inemployé JavaScript
importe MIME
importe Unicode

est_tag_auto_fermant :: fonc (tag: DOMString) -> bool
{
    discr tag {
        TAG_area,
        TAG_base,
        TAG_br,
        TAG_col,
        TAG_embed,
        TAG_hr,
        TAG_img,
        TAG_input,
        TAG_link,
        TAG_meta,
        TAG_param,
        TAG_source,
        TAG_track,
        TAG_wbr {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

/* ------------------------------------------------------------------------- */
/** \nom Élément
 * https://dom.spec.whatwg.org/#element
 * \{ */

#portée_module

TableVirtuelleÉlément :: struct {
    empl base: TableVirtuelleNoeud

    /* Appelé quand un élément fut dépilé de la pile des éléments ouverts. */
    sur_dépilement: fonc(*Élément)(rien)

    /* Appelé quand un attribut est ajouté, modifié, ou supprimé.
     * La fonction doit retourner si oui ou non l'attribut fut géré. */
    sur_changement_attribut: fonc(*Élément, DOMString, *DOMString, *DOMString, Optionnel(DOMString))(bool) = élément_sur_changement_attribut

    /* Appelé lors de la résolution des propriétés de style pour l'élément. */
    sur_applique_presentational_hints: fonc(*Élément, *CSS.RésolveuseStyle)(rien)
}

#portée_export

Élément :: struct {
    empl base_noeud: Noeud
    table = *table_virtuelle_élément

    id: DOMString

    /* Uniquement utilisé lors du parsage. */
    est_sur_pile_éléments_ouvert: bool

    espace_de_nom: chaine // DOMString @namespaceURI
    local_name: DOMString

    état_élément_custom: chaine
    définition_élément_custom: *rien

    pseudo_classes: CSS.PseudoClasses

    /* CSS */
    noeud_de_disposition: *CSS.NoeudDeDisposition
    /* https://html.spec.whatwg.org/multipage/dom.html#attr-style */
    style: *CSS.CSSStyleDeclaration

    /* Cache */
    liste_classes: [..]DOMString
}

#portée_fichier

table_virtuelle_élément := TableVirtuelleÉlément(
    classe = Élément,
    sur_destruction = élément_sur_destruction,
    sur_changement_attribut = élément_sur_changement_attribut
)

élément_détruit_données :: fonc (élément: *Élément)
{
    noeud_détruit_données(élément)
    CSS.détruit_style_declaration(élément.style)
    si élément.noeud_de_disposition {
        si élément.noeud_de_disposition.type != CSS.NoeudDeDispositionNouvelleLigne {
            (élément.noeud_de_disposition comme *CSS.NoeudDeDispositionBloc).élément = nul
        }
        sinon {
            (élément.noeud_de_disposition comme *CSS.NoeudDeDispositionNouvelleLigne).élément = nul
        }
    }
    déloge(élément.liste_classes)
}

élément_sur_destruction :: fonc (base: *JavaScript.Cellule)
{
    élément := base comme *Élément
    élément_détruit_données(élément)
}

élément_sur_changement_attribut :: fonc (élément: *Élément, local_name: DOMString, vieille_valeur: *DOMString, valeur: *DOMString, espace_de_nom: Optionnel(DOMString)) -> bool
{
    si vieille_valeur && valeur && mémoire(vieille_valeur) == mémoire(valeur) {
        retourne vrai
    }

    /* https://dom.spec.whatwg.org/#concept-id */
    si local_name == ATTR_id && !espace_de_nom.possède_valeur() {
        // 1. If localName is id, namespace is null, and value is null or the empty string, then unset element’s ID.
        si valeur == nul || mémoire(valeur).est_vide() {
            élément.id = crée_chaine_utf16_unique_vide()
        }
        // 2. Otherwise, if localName is id, namespace is null, then set element’s ID to value.
        sinon {
            élément.id = mémoire(valeur)
        }

        élément.document.invalide_style_pour_id(élément, vieille_valeur, valeur)
        retourne vrai
    }

    si local_name == TAG_style {
        CSS.détruit_style_declaration(élément.style)

        si valeur == nul || mémoire(valeur).est_vide() {
            élément.style = nul
        }
        sinon si rendu_css_est_requis(élément) {
            valeur_texte := mémoire(valeur).donne_chaine_utf16()
            élément.style = CSS.parse_attribut_style(valeur_texte)
            élément.style.owner_node = élément
        }

        élément.document.invalide_style_depuis_élément(élément)
        retourne vrai
    }

    si local_name == ATTR_class {
        déloge(élément.liste_classes)
        // À FAIRE : invalide le style pour les classes
        retourne vrai
    }

    retourne faux
}

rendu_css_est_requis :: fonc (élément: *Élément) -> bool
{
    document := élément.document
    saufsi document {
        retourne faux
    }

    user_agent := donne_user_agent(document)
    saufsi user_agent {
        retourne faux
    }

    retourne vrai
}

#portée_export

/* https://dom.spec.whatwg.org/#concept-element-attributes-append */
ajoute_attribut :: fonc (élément: *Élément, attribut_lexé: AttributLexé)
{
    // 1. Append attribute to element’s attribute list.
    attribut := ajoute_attribut(élément, attribut_lexé.nom, attribut_lexé.valeur)

    // 2. Set attribute’s element to element.
    attribut.élément = élément

    // 3. Handle attribute changes for attribute with element, null, and attribute’s value.
    gère_changement_attribute(attribut, élément, nul, *attribut.valeur)
}

/* https://dom.spec.whatwg.org/#concept-element-attributes-change */
change_attribut :: fonc (attribut: *Attr, valeur: DOMString)
{
    // 1. Let oldValue be attribute’s value.
    vieille_valeur := attr.valeur

    // 2. Set attribute’s value to value.
    attribut.valeur = valeur

    // 3. Handle attribute changes for attribute with attribute’s element, oldValue, and value.
    gère_changement_attribute(attribut, attribut.élément, vieille_valeur, valeur)
}

/* https://dom.spec.whatwg.org/#handle-attribute-changes */
gère_changement_attribute :: fonc (attribut: *Attr, élément: *Élément, vieille_valeur: *DOMString, nouvelle_valeur: *DOMString)
{
    // À FAIRE 1. Queue a mutation record of "attributes" for element with attribute’s local name,
    //    attribute’s namespace, oldValue, « », « », null, and null.

    // À FAIRE 2. If element is custom, then enqueue a custom element callback reaction with element,
    //    callback name "attributeChangedCallback", and an argument list containing attribute’s
    //    local name, oldValue, newValue, and attribute’s namespace.

    // 3. Run the attribute change steps with element, attribute’s local name, oldValue, newValue,
    //    and attribute’s namespace.
    table := élément.table comme *TableVirtuelleÉlément
    si table && table.sur_changement_attribut {
        _ := table.sur_changement_attribut(élément, attribut.local_name, vieille_valeur, nouvelle_valeur, attribut.namespace)
    }

    élément.document.invalide_style_pour_attribut(élément, attribut.local_name)
}

initialise_élément :: fonc (élément: *Élément, document: *Document, texte: DOMString) -> rien
{
    élément.genre = GenreNoeud.Élément
    élément.document = document
    élément.local_name = texte
    initialise_interface(élément)
}

crée_élément_avec_tag :: fonc (document: *Document, tag: DOMString) -> *Élément
{
    // les éléments pour les balises SVG ne sont pas présents, espace de noms ?
    élément: *Élément
    si tag == TAG_a {
        élément = crée_platform_object(document, HTMLAnchorElement)
    }
    sinon si tag == TAG_body {
        élément = crée_platform_object(document, HTMLBodyElement)
    }
    sinon si tag == TAG_font {
        élément = crée_platform_object(document, HTMLFontElement)
    }
    sinon si tag == TAG_form {
        élément = crée_platform_object(document, HTMLFormElement)
    }
    sinon si tag == TAG_head {
        élément = crée_platform_object(document, HTMLHeadElement)
    }
    sinon si tag == TAG_h1 || tag == TAG_h2 || tag == TAG_h3 || tag == TAG_h4 || tag == TAG_h5 || tag == TAG_h6 {
        élément = crée_platform_object(document, HTMLHeadingElement)
    }
    sinon si tag == TAG_hr {
        élément = crée_platform_object(document, HTMLHRElement)
    }
    sinon si tag == TAG_html {
        élément = crée_platform_object(document, HTMLHtmlElement)
    }
    sinon si tag == TAG_iframe {
        élément = crée_platform_object(document, HTMLIFrameElement)
    }
    sinon si tag == TAG_img {
        élément = crée_platform_object(document, HTMLImageElement)
    }
    sinon si tag == TAG_input {
        élément = crée_platform_object(document, HTMLInputElement)
    }
    sinon si tag == TAG_link {
        élément = crée_platform_object(document, HTMLLinkElement)
    }
    sinon si tag == TAG_script {
        élément = crée_platform_object(document, HTMLScriptElement)
    }
    sinon si tag == TAG_style {
        élément = crée_platform_object(document, HTMLStyleElement)
    }
    sinon si tag == TAG_table {
        élément = crée_platform_object(document, HTMLTableElement)
    }
    sinon si tag == TAG_td || tag == TAG_th {
        élément = crée_platform_object(document, HTMLTableCellElement)
    }
    sinon si tag == TAG_thead || tag == TAG_tbody || tag == TAG_tfoot {
        élément = crée_platform_object(document, HTMLTableSectionElement)
    }
    sinon si tag == TAG_tr {
        élément = crée_platform_object(document, HTMLTableRowElement)
    }
    sinon si tag == TAG_textarea {
        élément = crée_platform_object(document, HTMLTextAreaElement)
    }
    sinon si tag == TAG_video {
        élément = crée_platform_object(document, HTMLVideoElement)
    }
    sinon {
        élément = crée_platform_object(document, Élément)
    }

    initialise_élément(élément, document, tag)
    retourne élément
}

élément_fut_dépilé_de_la_pile_des_éléments_ouverts :: fonc (élément: *Élément)
{
    saufsi élément.table {
        retourne
    }

    table_virtuelle := élément.table comme *TableVirtuelleÉlément    
    si table_virtuelle.sur_dépilement  {
        table_virtuelle.sur_dépilement(élément)
    }
}

est_compatible_html5 :: fonc (élément: *Élément) -> bool
{
    discr élément.local_name {
        TAG_acronym,
        TAG_applet,
        TAG_basefont,
        TAG_big,
        TAG_center,
        TAG_dir,
        TAG_font,
        TAG_frame,
        TAG_frameset,
        TAG_noframes,
        TAG_strike,
        TAG_tt {
            retourne faux
        }
        sinon {
            retourne vrai
        }
    }
}

/* https://dom.spec.whatwg.org/#concept-getelementsbyclassname */
get_elements_by_class_name :: fonc (élément: *Élément, class_names: DOMString) -> *HTMLCollection
{
    // 1. Let classes be the result of running the ordered set parser on classNames.
    classes := run_ordered_set_parser(class_names)

    // 2. If classes is the empty set, return an empty HTMLCollection.
    si classes.taille == 0 {
        retourne crée_html_collection(élément)
    }

    // 3. Return an HTMLCollection rooted at root, whose filter matches
    //    descendant elements that have all their classes in classes.
    //    The comparisons for the classes must be done in an ASCII
    //    case-insensitive manner if root’s node document’s mode is "quirks";
    //    otherwise in an identical to manner.
    résultat := crée_html_collection(élément)
    résultat.root = élément
    résultat.filter = crée_filtre_pour_class_name(classes)
    initialise_collection_pour_filtre(résultat)
    retourne résultat
}

/* https://dom.spec.whatwg.org/#concept-getelementsbytagname */
get_elements_by_tag_name :: fonc (élément: *Élément, qualified_name: DOMString) -> *HTMLCollection
{   
    résultat := crée_html_collection(élément)
    résultat.root = élément

    // 1. If qualifiedName is U+002A (*), then return an HTMLCollection rooted at root, whose filter matches only descendant elements.

    // 2. Otherwise, if root’s node document is an HTML document, return an  rooted at root, whose filter matches the following descendant elements:

    //     Whose namespace is the HTML namespace and whose qualified name is qualifiedName, in ASCII lowercase.

    //     Whose namespace is not the HTML namespace and whose qualified name is qualifiedName.

    // 3. Otherwise, return an HTMLCollection rooted at root, whose filter matches descendant elements whose qualified name is qualifiedName. 
    résultat.filter = crée_filtre_pour_tag_name(qualified_name)

    initialise_collection_pour_filtre(résultat)
    retourne résultat
}

donne_liste_classe :: fonc (élément: *Élément) -> []DOMString
{
    saufsi élément.liste_classes {
        valeur := donne_attribut(élément, ATTR_class)
        si valeur.possède_valeur() {
            élément.liste_classes = divise_sur_espaces_blanches_ascii(valeur.Quelque)
        }
    }

    retourne élément.liste_classes
}

donne_referrerpolicy_content_attribute_state :: fonc (élément: *Élément) -> ReferrerPolicy
{
    referrer_policy := élément.donne_attribut_ou_chaine_vide(ATTR_referrerpolicy)
    chn_referrer_policy := converti_vers_chaine(referrer_policy.donne_chaine_utf16())
    diffère déloge(chn_referrer_policy)

    si compare_ascii_insensible_à_la_casse(chn_referrer_policy, "no-referrer") {
        retourne ReferrerPolicy.NoReferrer
    }

    si compare_ascii_insensible_à_la_casse(chn_referrer_policy, "no-referrer-when-downgrade") {
        retourne ReferrerPolicy.NoReferrerWhenDowngrade
    }

    si compare_ascii_insensible_à_la_casse(chn_referrer_policy, "same-origin") {
        retourne ReferrerPolicy.SameOrigin
    }

    si compare_ascii_insensible_à_la_casse(chn_referrer_policy, "origin") {
        retourne ReferrerPolicy.Origin
    }

    si compare_ascii_insensible_à_la_casse(chn_referrer_policy, "strict-origin") {
        retourne ReferrerPolicy.StrictOrigin
    }

    si compare_ascii_insensible_à_la_casse(chn_referrer_policy, "origin-when-cross-origin") {
        retourne ReferrerPolicy.OriginWhenCrossOrigin
    }

    si compare_ascii_insensible_à_la_casse(chn_referrer_policy, "strict-origin-when-cross-origin") {
        retourne ReferrerPolicy.StrictOriginWhenCrossOrigin
    }

    si compare_ascii_insensible_à_la_casse(chn_referrer_policy, "unsafe-url") {
        retourne ReferrerPolicy.UnsafeUrl
    }

    retourne ReferrerPolicy.EmptyString
}

/** \} */

fait_partie_de_catégorie_spécial :: fonc (nom: DOMString) -> bool
{
    // À FAIRE : utilisation d'une recherche binaire
    retourne fait_partie_de(nom,
                            TAG_address, TAG_applet, TAG_area, TAG_article,
                            TAG_aside, TAG_base, TAG_basefont, TAG_bgsound,
                            TAG_blockquote, TAG_body, TAG_br, TAG_button,
                            TAG_caption, TAG_center, TAG_col, TAG_colgroup,
                            TAG_dd, TAG_details, TAG_dir, TAG_div, TAG_dl,
                            TAG_dt, TAG_embed, TAG_fieldset, TAG_figcaption,
                            TAG_figure, TAG_footer, TAG_form, TAG_frame,
                            TAG_frameset, TAG_h1, TAG_h2, TAG_h3, TAG_h4,
                            TAG_h5, TAG_h6, TAG_head, TAG_header, TAG_hgroup,
                            TAG_hr, TAG_html, TAG_iframe, TAG_img, TAG_input,
                            TAG_keygen, TAG_li, TAG_link, TAG_listing, TAG_main,
                            TAG_marquee, TAG_menu, TAG_meta, TAG_nav, TAG_noembed,
                            TAG_noframes, TAG_noscript, TAG_object, TAG_ol, TAG_p,
                            TAG_param, TAG_plaintext, TAG_pre, TAG_script,
                            TAG_section, TAG_select, TAG_source, TAG_style,
                            TAG_summary, TAG_table, TAG_tbody, TAG_td, TAG_template,
                            TAG_textarea, TAG_tfoot, TAG_th, TAG_thead, TAG_title,
                            TAG_tr, TAG_track, TAG_ul, TAG_wbr, TAG_xmp, TAG_mi,
                            TAG_mo, TAG_mn, TAG_ms, TAG_mtext, TAG_annotation_xml,
                            TAG_foreignObject, TAG_desc, TAG_title)
}

enfant_directe_avec_balise :: fonc (élément: *Élément, balise: DOMString) -> *Élément
{
    pour élément.enfants {
        saufsi it.genre == GenreNoeud.Élément {
            continue
        }

        élément_enfant := (it comme *Élément)
        si élément_enfant.local_name == balise {
            retourne élément_enfant
        }
    }

    retourne nul
}

/* ------------------------------------------------------------------------- */
/** \nom CSS
 * \{ */

ajoute_pseudo_classe :: fonc (élément: *Élément, pseudo_classe: CSS.PseudoClasses)
{
    si (élément.pseudo_classes & pseudo_classe) == pseudo_classe {
        retourne
    }

    élément.pseudo_classes |= pseudo_classe
    assert(élément.document != nul)
    élément.document.invalide_style(élément, pseudo_classe)
}

enlève_pseudo_classe :: fonc (élément: *Élément, pseudo_classe: CSS.PseudoClasses)
{
    si (élément.pseudo_classes & pseudo_classe) != pseudo_classe {
        retourne
    }

    élément.pseudo_classes &= ~pseudo_classe
    assert(élément.document != nul)
    élément.document.invalide_style(élément, pseudo_classe)
}

est_en_train_d_être_activé :: fonc (élément: *Élément, ouinon: bool)
{
    /* À FAIRE : gère tous les cas/différencie les niveaux d'activation ?
     * https://html.spec.whatwg.org/multipage/semantics-other.html#concept-selector-active */
    si ouinon {
        élément.ajoute_pseudo_classe(CSS.PseudoClasses.Active)
    }
    sinon {
        élément.enlève_pseudo_classe(CSS.PseudoClasses.Active)
    }
}

applique_presentational_hints :: fonc (élément: *Élément, résolveuse: *CSS.RésolveuseStyle)
{
    table := élément.table comme *TableVirtuelleÉlément
    saufsi table {
        retourne
    }
    saufsi table.sur_applique_presentational_hints {
        retourne
    }
    table.sur_applique_presentational_hints(élément, résolveuse)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Interface JavaScript
 * \{ */

#portée_module

initialise_interface :: fonc (élément: *Élément)
{
    noeud_initialise_interface(élément)

    JavaScript.ajoute_fonction_native(élément, "getElementsByClassName", fonction_native_get_element_by_class_name)
    JavaScript.ajoute_fonction_native(élément, "getElementsByTagName", fonction_native_get_element_by_tag_name)

    si élément.local_name == TAG_img {
        JavaScript.ajoute_propriété(élément, ATTR_src, fonction_get_pour_attribut_src, nul, JavaScript.DrapeauxPropriété.zéro)
    }
}

fonction_get_pour_attribut_src :: fonc (empl params: *JavaScript.ParamètresObjectCall) -> JavaScript.CompletionRecord
{
    élément := JavaScript.donne_objet(this_value) comme *Élément
    src := donne_attribut_ou_chaine_vide(élément, ATTR_src)
    str_src := JavaScript.crée_chaine(élément.donne_tas_de_mémoire(), src)
    retourne JavaScript.normal_completion(JavaScript.Valeur(String = str_src))
}

fonction_native_get_element_by_class_name :: fonc (empl params: *JavaScript.ParamètresObjectCall) -> JavaScript.CompletionRecord
{
    si arguments.taille == 0 {
        retourne JavaScript.lance_type_error(interpréteuse, "getElementsByClassName requiers 1 argument")
    }

    saufsi JavaScript.est_chaine(arguments[0]) {
        retourne JavaScript.lance_type_error(interpréteuse, "argument n'est pas une chaine")
    }

    texte := arguments[0].String.texte
    élément := JavaScript.donne_objet(this_value) comme *Élément
    collection := élément.get_elements_by_class_name(texte)
    retourne JavaScript.normal_completion(JavaScript.Valeur(Object = collection))
}

fonction_native_get_element_by_tag_name :: fonc (empl params: *JavaScript.ParamètresObjectCall) -> JavaScript.CompletionRecord
{
    si arguments.taille != 1 {
        retourne JavaScript.lance_type_error(interpréteuse, "getElementsByTagName requiers 1 argument")
    }

    saufsi JavaScript.est_chaine(arguments[0]) {
        retourne JavaScript.lance_type_error(interpréteuse, "argument n'est pas une chaine")
    }

    texte := arguments[0].String.texte
    élément := JavaScript.donne_objet(this_value) comme *Élément
    collection := élément.get_elements_by_tag_name(texte)
    retourne JavaScript.normal_completion(JavaScript.Valeur(Object = collection))
}

#portée_export

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLElement
 * https://html.spec.whatwg.org/multipage/dom.html#htmlelement
 * \{ */

HTMLElement :: struct {
    empl base_élément: Élément
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLAnchorElement
 * https://html.spec.whatwg.org/multipage/text-level-semantics.html#htmlanchorelement
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLAnchorElement
 * \{ */

#portée_export

HTMLAnchorElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_anchor_element
}

est_hyperlien :: fonc (anchor: *HTMLAnchorElement) -> bool
{
    retourne anchor.donne_attribut(ATTR_href).possède_valeur()
}

donne_href :: fonc (anchor: *HTMLAnchorElement) -> DOMString
{
    retourne donne_attribut_ou_chaine_vide(anchor, ATTR_href)
}

#portée_fichier

table_virtuelle_anchor_element := TableVirtuelleÉlément(
    classe = HTMLAnchorElement,
    sur_destruction = élément_sur_destruction,
    sur_activation_behavior = anchor_element_sur_activation_behavior,
    sur_changement_attribut = anchor_element_sur_changement_attribut
)

anchor_element_sur_changement_attribut :: fonc (base: *Élément, local_name: DOMString, vieille_valeur: *DOMString, valeur: *DOMString, espace_de_nom: Optionnel(DOMString)) -> bool
{
    si élément_sur_changement_attribut(base, local_name, vieille_valeur, valeur, espace_de_nom) {
        retourne vrai
    }

    anchor := base comme *HTMLAnchorElement

    si local_name == ATTR_href {
        si valeur == nul || mémoire(valeur).est_vide() {
            anchor.enlève_pseudo_classe(CSS.PseudoClasses.Link)
        }
        sinon {
            anchor.ajoute_pseudo_classe(CSS.PseudoClasses.Link)
        }

        retourne vrai
    }

    retourne faux
}

/* https://html.spec.whatwg.org/multipage/links.html#api-for-a-and-area-elements */
anchor_element_sur_activation_behavior :: fonc (target: *EventTarget, event: *Event)
{
    element := target comme *HTMLElement
    
    // 1. If element has no href attribute, then return.
    saufsi possède_attribut(element, ATTR_href) {
        retourne
    }

    // 2. Let hyperlinkSuffix be null.
    hyperlink_suffix := crée_chaine_utf16_unique_vide()

    // À FAIRE : 3. If element is an a element, and event's target is an img with an ismap attribute specified, then:

        // 1. Let x and y be 0.

        // 2. If event's isTrusted attribute is initialized to true, then set x to the distance in CSS pixels from the left edge of the image to the location of the click, and set y to the distance in CSS pixels from the top edge of the image to the location of the click.

        // 3. If x is negative, set x to 0.

        // 4. If y is negative, set y to 0.

        // 5. Set hyperlinkSuffix to the concatenation of U+003F (?), the value of x expressed as a base-ten integer using ASCII digits, U+002C (,), and the value of y expressed as a base-ten integer using ASCII digits.

    // 4. Let userInvolvement be event's user navigation involvement.
    user_involvement := donne_user_navigation_involvement(event)

    // À FAIRE : 5. If the user has expressed a preference to download the hyperlink, then set userInvolvement to "browser UI".

    // À FAIRE : 6. If element has a download attribute, or if the user has expressed a preference to download the hyperlink, then download the hyperlink created by element with hyperlinkSuffix set to hyperlinkSuffix and userInvolvement set to userInvolvement.

    // 7. Otherwise, follow the hyperlink created by element with hyperlinkSuffix set to hyperlinkSuffix and userInvolvement set to userInvolvement.
    follow_the_hyperlink(element, hyperlink_suffix, user_involvement)
}

/* https://html.spec.whatwg.org/multipage/browsing-the-web.html#event-uni */
donne_user_navigation_involvement :: fonc (event: *Event) -> UserNavigationInvolvement
{
    // 1. Assert: this algorithm is being called as part of an activation behavior definition.
    assert(event.est_dans_activation_behavior)

    // 2. Assert: event's type is "click".
    assert(event.type == EventType.click)

    // 3. If event's isTrusted is initialized to true, then return "activation".
    si event.is_trusted {
        retourne UserNavigationInvolvement.Activation
    }

    // 4. Return "none".
    retourne UserNavigationInvolvement.None
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 4.6.4 Following Hyperlinks
 * https://html.spec.whatwg.org/multipage/links.html#following-hyperlinks
 * \{ */

/* https://html.spec.whatwg.org/multipage/links.html#cannot-navigate */
cannot_navigate :: fonc (element: *Élément) -> bool
{
    // À FAIRE : element's node document is not fully active; or
    // saufsi element.document.est_fully_active() {
    //     retourne vrai
    // }

    // element is not an a element and is not connected.
    si element.local_name != TAG_a && !element.est_connecté() {
        retourne vrai
    }

    retourne faux
}

/* https://html.spec.whatwg.org/multipage/links.html#get-an-element's-noopener */
get_an_element_s_noopener :: fonc (element: *Élément, target: DOMString) -> bool
{
    assert(element.local_name == TAG_a || element.local_name == TAG_area || element.local_name == TAG_form)

    link_types := donne_link_types(element)
    diffère déloge(link_types)

    // 1. If element's link types include the noopener or noreferrer keyword, then return true.
    si link_types_incluent(link_types, ATTR_noopener) || link_types_incluent(link_types, ATTR_noreferrer) {
        retourne vrai
    }

    // 2. If element's link types do not include the opener keyword and target is an ASCII
    //    case-insensitive match for "_blank", then return true.
    si !link_types_incluent(link_types, ATTR_opener) && compare_ascii_insensible_à_la_casse(target, ATTR__blank) {
        retourne vrai
    }

    // 3. Return false.
    retourne faux
}

/* https://html.spec.whatwg.org/multipage/links.html#following-hyperlinks-2 */
follow_the_hyperlink :: fonc (subject: *Élément, hyperlink_suffix := crée_chaine_utf16_unique_vide(), user_involvement := UserNavigationInvolvement.None)
{
    // 1. If subject cannot navigate, then return.
    si cannot_navigate(subject) {
        imprime("[%] cannot_navigate\n", #nom_de_cette_fonction)
        retourne
    }

    // 2. Let replace be false.
    // replace := faux

    // 3. Let targetAttributeValue be the empty string.
    target_attribute_value := crée_chaine_utf16_unique_vide()

    // 4. If subject is an a or area element, then set targetAttributeValue to the result of getting an element's target given subject.
    si subject.local_name == TAG_a || subject.local_name == TAG_area {
        target_attribute_value = get_an_element_s_target(subject)
    }

    // 5. Let noopener be the result of getting an element's noopener with subject and targetAttributeValue.
    // noopener := get_an_element_s_noopener(subject, target_attribute_value)

    // À FAIRE : 6. Let targetNavigable be the first return value of applying the rules for choosing a navigable given targetAttributeValue, subject's node navigable, and noopener.
    target_navigable := donne_node_navigable(subject)

    // 7. If targetNavigable is null, then return.
    saufsi target_navigable {
        imprime("[%] pas de navigable\n", #nom_de_cette_fonction)
        retourne
    }

    // 8. Let urlString be the result of encoding-parsing-and-serializing a URL given subject's href attribute value, relative to subject's node document.
    chn_href := subject.donne_attribut_ou_chaine_vide(ATTR_href)
    opt_url_string := encoding_parse_and_serialize_a_url(chn_href, subject.document)

    // 9. If urlString is failure, then return.
    saufsi opt_url_string.possède_valeur() {
        retourne
    }
    url_string := opt_url_string.Quelque

    // 10. If hyperlinkSuffix is non-null, then append it to urlString.
    saufsi hyperlink_suffix.est_vide() {
        chn_hyperlink_suffix := converti_vers_chaine(hyperlink_suffix.donne_chaine_utf16())
        chaine_ajoute(*url_string, chn_hyperlink_suffix)
    }

    // 11. Let referrerPolicy be the current state of subject's referrerpolicy content attribute.
    referrer_policy := donne_referrerpolicy_content_attribute_state(subject)

    // 12. If subject's link types includes the noreferrer keyword, then set referrerPolicy to "no-referrer".
    link_types := donne_link_types(subject)
    diffère déloge(link_types)

    si link_types_incluent(link_types, ATTR_noreferrer) {
        referrer_policy = ReferrerPolicy.NoReferrer
    }

    // 13. Navigate targetNavigable to urlString using subject's node document, with referrerPolicy set to referrerPolicy and userInvolvement set to userInvolvement.
    url := tente parse_uri_standard(url_string) piège nonatteignable
    source_document := subject.document
    navigate(source_document.donne_user_agent(), target_navigable, url, source_document, referrer_policy = referrer_policy, user_involvement = user_involvement)
}

/* https://html.spec.whatwg.org/multipage/semantics.html#get-an-element's-target */
get_an_element_s_target :: fonc (element: *Élément, target := crée_chaine_utf16_unique_vide()) -> DOMString
{
    // 1. If target is null, then:
    si target.est_vide() {
        // 1. If element has a target attribute, then set target to that attribute's value.
        attr_target := element.donne_attribut(ATTR_target)
        si attr_target.possède_valeur() {
            target = attr_target.Quelque
        }
        // À FAIRE : 2. Otherwise, if element's node document contains a base element with a target attribute, set target to the value of the target attribute of the first such base element.
    }

    // 2. If target is not null, and contains an ASCII tab or newline and a U+003C (<), then set target to "_blank".
    saufsi target.est_vide() {
        chn_target := target.donne_chaine_utf16()
        si chn_target.taille() == 2 && (chn_target.unités[0] == '\t' comme n8 || chn_target.unités[0] == '\n' comme n8) && chn_target.unités[1] == '<' comme n8 {
            target = ATTR__blank
        }
    }

    // 3. Return target.
    retourne target
}

/* https://html.spec.whatwg.org/multipage/urls-and-fetching.html#encoding-parsing-and-serializing-a-url */
encoding_parse_and_serialize_a_url :: fonc (url: DOMString, document: *Document) -> Optionnel(chaine)
{
    // À FAIRE : standardise
    base_url := donne_base_url(document)
    url_document := convertis_uri_url(*base_url)
    diffère détruit_url(url_document)

    url_src := basic_url_parser(url.donne_chaine_utf16(), base = url_document)
    diffère détruit_url(url_src)
    saufsi url_src {
        retourne
    }

    retourne url_serializer(url_src)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 4.6.7 Link Types
 * https://html.spec.whatwg.org/multipage/links.html#linkTypes
 * \{ */

donne_link_types :: fonc (element: *Élément) -> [..]DOMString
{
    rel := element.donne_attribut_ou_chaine_vide(ATTR_rel)
    retourne run_ordered_set_parser(rel)
}

link_types_incluent :: fonc (link_types: []DOMString, chn: DOMString) -> bool
{
    pour link_types {
        si compare_ascii_insensible_à_la_casse(it, chn) {
            retourne vrai
        }
    }
    retourne faux
}

/** } */

/* ------------------------------------------------------------------------- */
/** \nom HTMLBodyElement
 * https://html.spec.whatwg.org/multipage/sections.html#the-body-element
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLBodyElement
 * \{ */

#portée_export

HTMLBodyElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_body_element
}

#portée_fichier

table_virtuelle_body_element := TableVirtuelleÉlément(
    classe = HTMLBodyElement,
    sur_destruction = élément_sur_destruction,
    sur_applique_presentational_hints = body_element_sur_applique_presentational_hints
)

/* https://html.spec.whatwg.org/multipage/rendering.html#the-page */
body_element_sur_applique_presentational_hints :: fonc (base: *Élément, résolveuse: *CSS.RésolveuseStyle)
{
    ajoute_propriété_pour_legacy_colour_value(résolveuse, base, ATTR_bgcolor, CSS.PROP_background_color)
    ajoute_propriété_pour_legacy_colour_value(résolveuse, base, ATTR_text, CSS.PROP_color)

    /* À FAIRE : utilise les attributs. */
    ajoute_propriété_pour_nombre(résolveuse, CSS.PROP_margin_top, 8.0)
    ajoute_propriété_pour_nombre(résolveuse, CSS.PROP_margin_bottom, 8.0)
    ajoute_propriété_pour_nombre(résolveuse, CSS.PROP_margin_left, 8.0)
    ajoute_propriété_pour_nombre(résolveuse, CSS.PROP_margin_right, 8.0)
}

ajoute_propriété_pour_legacy_colour_value :: fonc (résolveuse: *CSS.RésolveuseStyle, élément: *Élément, nom_attribut: DOMString, nom_propriété: CSS.CSSOMString)
{
    opt_attribut := élément.donne_attribut(nom_attribut)
    si opt_attribut.possède_valeur() {
        ajoute_propriété_pour_couleur(résolveuse, nom_propriété, opt_attribut.Quelque)
    }
}

ajoute_propriété_pour_couleur :: fonc (résolveuse: *CSS.RésolveuseStyle, nom_propriété: CSS.CSSOMString, texte: DOMString)
{
    opt_couleur := parse_a_legacy_colour_value(texte)
    saufsi opt_couleur.possède_valeur() {
        retourne
    }

    CSS.ajoute_presentational_hint(résolveuse, nom_propriété, CSS.ValeurDeStyle(couleur = opt_couleur.Quelque))
}

ajoute_propriété_pour_mot_clé :: fonc (résolveuse: *CSS.RésolveuseStyle, nom_propriété: CSS.CSSOMString, mot_clé: CSS.CSSOMString)
{
    CSS.ajoute_presentational_hint(résolveuse, nom_propriété, CSS.ValeurDeStyle(mot_clé = mot_clé))
}

ajoute_propriété_pour_non_zero_dimension :: fonc (résolveuse: *CSS.RésolveuseStyle, élément: *Élément, nom_attribut: DOMString, nom_propriété: CSS.CSSOMString)
{
    opt_attribut := élément.donne_attribut(nom_attribut)
    si opt_attribut.possède_valeur() {
        valeur := parse_a_non_zero_dimension(opt_attribut.Quelque)
        si valeur.possède_valeur() {
            ajoute_propriété_pour_nombre(résolveuse, nom_propriété, valeur.Quelque)
        }
    }
}

ajoute_propriété_pour_nombre :: fonc (résolveuse: *CSS.RésolveuseStyle, nom_propriété: CSS.CSSOMString, valeur: r64)
{
    CSS.ajoute_presentational_hint(résolveuse, nom_propriété, CSS.ValeurDeStyle(number = valeur))
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLFontElement
 * https://html.spec.whatwg.org/multipage/obsolete.html#htmlfontelement
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLFontElement
 * \{ */

#portée_export

HTMLFontElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_font_element
}

#portée_fichier

table_virtuelle_font_element := TableVirtuelleÉlément(
    classe = HTMLFontElement,
    sur_destruction = élément_sur_destruction,
    sur_applique_presentational_hints = font_element_sur_applique_presentational_hints
)

/* https://html.spec.whatwg.org/multipage/rendering.html#phrasing-content-3 */
font_element_sur_applique_presentational_hints :: fonc (base: *Élément, résolveuse: *CSS.RésolveuseStyle)
{
    font := base comme *HTMLFontElement

    opt_color := donne_attribut(font, ATTR_color)
    si opt_color.possède_valeur() {
        color := opt_color.Quelque
        ajoute_propriété_pour_couleur(résolveuse, CSS.PROP_color, color)
    }

    opt_size := donne_attribut(font, ATTR_size)
    si opt_size.possède_valeur() {
        opt_font_size := parse_a_legacy_font_size(opt_size.Quelque)
        si opt_font_size.possède_valeur() {
            ajoute_propriété_pour_mot_clé(résolveuse, CSS.PROP_font_size, opt_font_size.Quelque)
        }
    }

    /* À FAIRE : face. */
}

parse_a_legacy_font_size :: fonc (attribute_value: DOMString) -> Optionnel(CSS.CSSOMString)
{
    // 1. Let input be the attribute's value.
    input := attribute_value.donne_chaine_utf16()

    // 2. Let position be a pointer into input, initially pointing at the start of the string.
    position := input.unités.pointeur
    fin := position + input.taille()

    // 3. Skip ASCII whitespace within input given position.
    tantque position < fin {
        saufsi est_espace_blanche_ascii(mémoire(position)) {
            arrête
        }

        position += 1
    }

    // 4. If position is past the end of input, there is no presentational hint. Return.
    si position >= fin {
        retourne
    }

    // 5. If the character at position is a U+002B PLUS SIGN character (+), then let mode be
    //    relative-plus, and advance position to the next character. Otherwise, if the character
    //    at position is a U+002D HYPHEN-MINUS character (-), then let mode be relative-minus,
    //    and advance position to the next character. Otherwise, let mode be absolute.
    ModeFonte :: énum {
        Aucun
        RelativePlus
        RelativeMinus
    }
    mode := ModeFonte.Aucun
    si mémoire(position) == 0x2B {
        mode = ModeFonte.RelativePlus
        position += 1
    }
    sinon si mémoire(position) == 0x2D {
        mode = ModeFonte.RelativeMinus
        position += 1
    }

    // 6. Collect a sequence of code points that are ASCII digits from input given position, and let the resulting sequence be digits.
    //    https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points
    digits: ChaineUTF16

    tantque position < fin {
        saufsi est_chiffre_ascii(mémoire(position)) {
            arrête
        }

        chaine_ajoute(*digits, mémoire(position))
        position += 1
    }

    // 7. If digits is the empty string, there is no presentational hint. Return.
    si digits.est_vide() {
        retourne
    }
    diffère détruit_chaine(digits)

    // 8. Interpret digits as a base-ten integer. Let value be the resulting number.
    value: z32
    pour digits.unités {
        value *= 10
        value += (it - '0' comme n16) comme z32
    }

    // 9. If mode is relative-plus, then increment value by 3.
    //    If mode is relative-minus, then let value be the result of subtracting value from 3.
    si mode == ModeFonte.RelativePlus {
        value += 3
    }
    sinon si mode == ModeFonte.RelativeMinus {
        value -= 3
    }

    // 10. If value is greater than 7, let it be 7.
    si value > 7 {
        value = 7
    }

    // 11. If value is less than 1, let it be 1.
    si value < 1 {
        value = 1
    }

    // 12. Set 'font-size' to the keyword corresponding to the value of value according to the following table:
    table := [CSS.PROP_x_small, CSS.PROP_small, CSS.PROP_medium, CSS.PROP_large, CSS.PROP_x_large, CSS.PROP_xx_large, CSS.PROP_xxx_large]
    retourne table[value - 1]
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLFormElement
 * https://html.spec.whatwg.org/multipage/forms.html#htmlformelement
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement
 * \{ */

#portée_export

HTMLFormElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_form_element
}

#portée_fichier

table_virtuelle_form_element := TableVirtuelleÉlément(
    classe = HTMLFormElement,
    sur_destruction = élément_sur_destruction
)

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLHeadElement
 * https://html.spec.whatwg.org/multipage/dom.html#htmlheadelement
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLHeadElement
 * \{ */

#portée_export

HTMLHeadElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_head_element
}

#portée_fichier

table_virtuelle_head_element := TableVirtuelleÉlément(
    classe = HTMLHeadElement,
    sur_destruction = élément_sur_destruction
)

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLHeadingElement
 * https://html.spec.whatwg.org/multipage/sections.html#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLHeadingElement
 * \{ */

#portée_export

HTMLHeadingElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_heading_element
}

#portée_fichier

table_virtuelle_heading_element := TableVirtuelleÉlément(
    classe = HTMLHeadingElement,
    sur_destruction = élément_sur_destruction
)

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLHRElement
 * https://html.spec.whatwg.org/multipage/grouping-content.html#the-hr-element
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLHRElement
 * \{ */

#portée_export

HTMLHRElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_hr_element
}

#portée_fichier

table_virtuelle_hr_element := TableVirtuelleÉlément(
    classe = HTMLHRElement,
    sur_destruction = élément_sur_destruction
)

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLHtmlElement
 * https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLHtmlElement
 * \{ */

#portée_export

HTMLHtmlElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_html_element
}

#portée_fichier

table_virtuelle_html_element := TableVirtuelleÉlément(
    classe = HTMLHtmlElement,
    sur_destruction = élément_sur_destruction
)

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLIFrameElement
 * https://html.spec.whatwg.org/multipage/iframe-embed-object.html#the-iframe-element
 * \{ */

#portée_export

HTMLIFrameElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_iframe_element

    /* À FAIRE : remplis depuis l'attribut sandbox
     * https://html.spec.whatwg.org/multipage/browsers.html#iframe-sandboxing-flag-set */
    iframe_sandboxing_flags: SandboxingFlags
}

#portée_fichier

table_virtuelle_iframe_element := TableVirtuelleÉlément(
    classe = HTMLIFrameElement,
    sur_destruction = élément_sur_destruction
)

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLAnchorElement
 * https://html.spec.whatwg.org/multipage/embedded-content.html#htmlimageelement
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement
 * \{ */

#portée_export

HTMLImageElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_image_element

    image_data: ImageIO
}

donne_src :: fonc (image: *HTMLImageElement) -> DOMString
{
    retourne donne_attribut_ou_chaine_vide(image, ATTR_src)
}

donne_hauteur_intrinsèque :: fonc (image: *HTMLImageElement) -> z32 #enligne
{
    retourne image.image_data.hauteur
}

donne_largeur_intrinsèque :: fonc (image: *HTMLImageElement) -> z32 #enligne
{
    retourne image.image_data.largeur
}

donne_ratio_intrinsèque :: fonc (image: *HTMLImageElement) -> r32 #enligne
{
    si image.image_data.hauteur == 0 {
        retourne 1.0
    }

    retourne image.image_data.largeur comme r32 / image.image_data.hauteur comme r32
}

#portée_fichier

table_virtuelle_image_element := TableVirtuelleÉlément(
    classe = HTMLImageElement,
    sur_destruction = image_element_sur_destruction,
    sur_changement_attribut = image_element_sur_changement_attribut,
    sur_applique_presentational_hints = image_element_sur_applique_presentational_hints
)

image_element_sur_changement_attribut :: fonc (base: *Élément, local_name: DOMString, vieille_valeur: *DOMString, valeur: *DOMString, espace_de_nom: Optionnel(DOMString)) -> bool
{
    si élément_sur_changement_attribut(base, local_name, vieille_valeur, valeur, espace_de_nom) {
        retourne vrai
    }

    image := base comme *HTMLImageElement

    si local_name == ATTR_src {
        update_image_data(image)
        retourne vrai
    }

    retourne faux
}

image_element_sur_applique_presentational_hints :: fonc (base: *Élément, résolveuse: *CSS.RésolveuseStyle)
{
    ajoute_propriété_pour_non_zero_dimension(résolveuse, base, ATTR_width, CSS.PROP_width)
    ajoute_propriété_pour_non_zero_dimension(résolveuse, base, ATTR_height, CSS.PROP_height)
}

image_element_sur_destruction :: fonc (base: *JavaScript.Cellule)
{
    élément := base comme *HTMLImageElement
    élément_détruit_données(élément)
    IMG_detruit_image(*élément.image_data)
}

/* https://html.spec.whatwg.org/multipage/images.html#update-the-image-data */
update_image_data :: fonc (image: *HTMLImageElement)
{
    // À FAIRE : standardise
    document := image.document
    user_agent := document.donne_user_agent()
    saufsi user_agent {
        retourne
    }

    IMG_detruit_image(*image.image_data)
    image.image_data = ImageIO()

    src := image.donne_src()
    si src.est_vide() {
        document.invalide_style()
        retourne
    }

    base_url := donne_base_url(document)
    url_document := convertis_uri_url(*base_url)
    diffère détruit_url(url_document)

    url_src := basic_url_parser(src.donne_chaine_utf16(), base = url_document)
    saufsi url_src {
        retourne
    }

    url_string := url_serializer(url_src)
    // diffère déloge(url_string)

    // imprime("[%] %\n", #nom_de_cette_fonction, url_string)

    request := loge(Request)
    request.destination = "image"
    request.mode = "no-cors"
    request.redirect_mode = "follow"
    request.définis_url(tente parse_uri_standard(url_string) piège nonatteignable)

    RappelProcessResponse :: struct {
        empl base: BaseProcessResponse

        request: *Request
        image: *HTMLImageElement
        url_src: *URL
    }

    sur_rappel_process_response :: fonc (base: *BaseProcessResponse, réponse: *Response)
    {
        diffère détruit_response(réponse)

        rappel := base comme *RappelProcessResponse

        saufsi réponse.body_info {
            retourne
        }

        content_type := réponse.body_info.content_type
        saufsi est_type_mime_image(content_type) {
            retourne
        }

        contenu := réponse.body.Quelque

        // À FAIRE : prend le chemin de l'url si le schéma n'est pas "data"
        chemin_image := ""
        si content_type == "image/png" {
            chemin_image = "image.png"
        }
        sinon si content_type == "image/jpeg" {
            chemin_image = "image.jpeg"
        }
        sinon {
            panique("chemin image non résolvable")
        }

        proxy_image := IMG_cree_proxy_memoire(contenu.pointeur, contenu.taille comme n64)
        diffère IMG_detruit_proxy(proxy_image)

        chn_c_chemin := crée_chaine_c(chemin_image)
        diffère détruit_chaine_c(chn_c_chemin)

        résultat_lecture_image := IMG_ouvre_image_avec_proxy(chn_c_chemin, *rappel.image.image_data, proxy_image)
        si résultat_lecture_image != ResultatOperation.OK {
            imprime("Impossible de lire l'image : %\n", résultat_lecture_image)
        }

        invalide_style(rappel.image.document)
    }

    sur_destruction_process_response :: fonc (base: *BaseProcessResponse)
    {
        rappel := base comme *RappelProcessResponse
        détruit_url(rappel.url_src)
        détruit_request(rappel.request)
        déloge(rappel)
    }

    process_response := loge(RappelProcessResponse)
    process_response.image = image
    process_response.url_src = url_src
    process_response.request = request
    process_response.sur_rappel = sur_rappel_process_response
    process_response.sur_destruction = sur_destruction_process_response

    fetch_controller := fetch(user_agent, request, process_response = process_response)
    diffère détruit_fetch_controller(fetch_controller)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLInputElement
 * \{ */

#portée_export

HTMLInputElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_input_element
}

/* https://html.spec.whatwg.org/multipage/rendering.html#the-input-element-as-a-text-entry-widget */
is_text_entry_widget :: fonc (input: *HTMLInputElement) -> bool
{
    opt_type := donne_attribut(input, ATTR_type)
    saufsi opt_type.possède_valeur() {
        /* "The attribute's missing value default and invalid value default are both the Text state."
         * https://html.spec.whatwg.org/multipage/input.html#attr-input-type
         *
         * À FAIRE : détermine l'état de l'attribut :
         * https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#missing-value-default */
        retourne vrai
    }
    retourne opt_type.Quelque == ATTR_text
}

#portée_fichier

table_virtuelle_input_element := TableVirtuelleÉlément(
    classe = HTMLInputElement,
    sur_destruction = élément_sur_destruction,
    sur_changement_attribut = input_element_sur_changement_attribut
)

input_element_sur_changement_attribut :: fonc (base: *Élément, local_name: DOMString, vieille_valeur: *DOMString, valeur: *DOMString, espace_de_nom: Optionnel(DOMString)) -> bool
{
    si élément_sur_changement_attribut(base, local_name, vieille_valeur, valeur, espace_de_nom) {
        retourne vrai
    }

    input := base comme *HTMLInputElement

    si local_name == ATTR_type {
        invalide_style_depuis_élément(input.document, input)
        retourne vrai
    }

    retourne faux
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLLinkElement
 * https://html.spec.whatwg.org/multipage/semantics.html#the-link-element
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLLinkElement
 * \{ */

#portée_export

HTMLLinkElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_link_element
}

donne_href :: fonc (link: *HTMLLinkElement) -> DOMString
{
    retourne donne_attribut_ou_chaine_vide(link, ATTR_href)
}

donne_rel :: fonc (link: *HTMLLinkElement) -> DOMString
{
    retourne donne_attribut_ou_chaine_vide(link, ATTR_rel)
}

#portée_fichier

table_virtuelle_link_element := TableVirtuelleÉlément(
    classe = HTMLLinkElement,
    sur_destruction = élément_sur_destruction,
    sur_changement_attribut = link_element_sur_changement_attribut
)

link_element_sur_changement_attribut :: fonc (base: *Élément, local_name: DOMString, vieille_valeur: *DOMString, valeur: *DOMString, espace_de_nom: Optionnel(DOMString)) -> bool
{
    si élément_sur_changement_attribut(base, local_name, vieille_valeur, valeur, espace_de_nom) {
        retourne vrai
    }

    link := base comme *HTMLLinkElement

    si local_name == ATTR_href || local_name == ATTR_rel {
        process_link_element(link)
        retourne vrai
    }

    retourne faux
}

/* https://html.spec.whatwg.org/multipage/links.html */
process_link_element :: fonc (link: *HTMLLinkElement)
{
    rel := link.donne_rel()
    si rel.est_vide() {
        link.document.supprime_feuille_de_style_associée(link)
        retourne
    }

    types := run_ordered_set_parser(rel)
    diffère déloge(types)

    est_stylesheet := faux
    est_alternate := faux

    pour types {
        si it == ATTR_stylesheet {
            est_stylesheet = vrai
        }
        sinon si it == ATTR_alternate {
            est_alternate = vrai
        }
    }

    si est_stylesheet && !est_alternate {
        process_stylesheet_link(link)
    }
}

process_stylesheet_link :: fonc (link: *HTMLLinkElement)
{
    // À FAIRE : standardise
    document := link.document
    user_agent := document.donne_user_agent()
    saufsi user_agent {
        retourne
    }

    document.supprime_feuille_de_style_associée(link)

    src := link.donne_href()
    si src.est_vide() {
        retourne
    }

    base_url := donne_base_url(document)
    url_document := convertis_uri_url(*base_url)
    diffère détruit_url(url_document)

    url_src := basic_url_parser(src.donne_chaine_utf16(), base = url_document)
    saufsi url_src {
        retourne
    }

    url_string := url_serializer(url_src)

    request := loge(Request)
    request.destination = "style"
    request.mode = "no-cors"
    request.redirect_mode = "follow"
    request.définis_url(tente parse_uri_standard(url_string) piège nonatteignable)

    RappelProcessResponse :: struct {
        empl base: BaseProcessResponse

        link: *HTMLLinkElement
        request: *Request
        url_src: *URL
        url_string: ChaineASCII
    }

    sur_rappel_process_response :: fonc (base: *BaseProcessResponse, réponse: *Response)
    {
        diffère détruit_response(réponse)

        rappel := base comme *RappelProcessResponse

        saufsi réponse.body_info {
            retourne
        }

        saufsi réponse.body_info.content_type == MIME_text_css {
            retourne
        }

        contenu := réponse.body.Quelque

        mime_css := crée_chaine_utf16_unique(MIME_text_css)

        feuille_de_style := loge(CSS.CSSStyleSheet)
        feuille_de_style.location = tente parse_uri_standard(copie_chaine(rappel.url_string)) piège nonatteignable
        feuille_de_style.origine = CSS.OrigineCascade.Author
        feuille_de_style.type = mime_css
        feuille_de_style.owner_node = rappel.link
        feuille_de_style.alternate = faux
        feuille_de_style.origin_clean = vrai
        feuille_de_style.parent_style_sheet = nul
        feuille_de_style.owner_rule = nul

        // Non-spécifié
        ctx: CSS.ContexteParsageFeuilleDeStyle
        diffère CSS.détruit_données_contexte(*ctx)
        CSS.parse_style_rules(*ctx, feuille_de_style, contenu)
        CSS.rapporte_propriétés_non_supportées(*ctx, #nom_de_cette_fonction)
        rappel.link.document.ajoute_feuille_de_style(feuille_de_style)
    }

    sur_destruction_process_response :: fonc (base: *BaseProcessResponse)
    {
        rappel := base comme *RappelProcessResponse
        détruit_url(rappel.url_src)
        détruit_request(rappel.request)
        déloge(rappel)
    }

    process_response := loge(RappelProcessResponse)
    process_response.link = link
    process_response.request = request
    process_response.url_string = url_string
    process_response.url_src = url_src
    process_response.sur_rappel = sur_rappel_process_response
    process_response.sur_destruction = sur_destruction_process_response

    fetch_controller := fetch(user_agent, request, process_response = process_response)
    diffère détruit_fetch_controller(fetch_controller)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLMediaElement
 * https://html.spec.whatwg.org/multipage/media.html#htmlmediaelement
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement
 * \{ */

#portée_export

HTMLMediaElement :: struct {
    empl html_element: HTMLElement
}

donne_src :: fonc (media: *HTMLMediaElement) -> DOMString
{
    retourne donne_attribut_ou_chaine_vide(media, ATTR_src)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLVideoElement
 * https://html.spec.whatwg.org/multipage/media.html#htmlvideoelement
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement
 * \{ */

#portée_export

HTMLVideoElement :: struct {
    empl html_media: HTMLMediaElement
    table = *table_virtuelle_video_element
}

#portée_fichier

table_virtuelle_video_element := TableVirtuelleÉlément(
    classe = HTMLVideoElement,
    sur_destruction = élément_sur_destruction
)

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLScriptElement
 * https://html.spec.whatwg.org/multipage/scripting.html#htmlscriptelement
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLScriptElement
 * \{ */

#portée_export

TypeScript :: énum {
    NUL
    CLASSIC
    MODULE
    IMPORTMAP
}

HTMLScriptElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_script_element

    document_parseur: *Document
    document_du_temps_de_préparation: *Document

    force_async := vrai // À FAIRE : doit être faux lors de l'ajout d'un attribut async
    provient_de_fichier_externe := faux
    prêt_à_être_exécuté_par_parseuse := faux
    déjà_commencé := faux
    temporise_évènement_de_charge := faux
    delaying_the_load_event := faux

    type: TypeScript
    // result : "uninitialized", null, scipt, import map parse result
    result: *rien

    steps_to_run_when_the_result_is_ready: *Algorithm
}

donne_src :: fonc (script: *HTMLScriptElement) -> DOMString
{
    retourne donne_attribut_ou_chaine_vide(script, ATTR_src)
}

#portée_fichier

table_virtuelle_script_element := TableVirtuelleÉlément(
    classe = HTMLScriptElement,
    sur_destruction = élément_sur_destruction
)

#portée_export

/* https://html.spec.whatwg.org/multipage/scripting.html#prepare-the-script-element */
prépare :: fonc (el: *HTMLScriptElement)
{
    /* 1. */
    si el.déjà_commencé {
        retourne
    }

    /* 2. & 3. */
    document_parseur := el.document_parseur
    el.document_parseur = nul

    /* 4. */
    si document_parseur != nul && !el.possède_attribut(ATTR_async) {
        el.force_async = vrai
    }

    /* 5. */
    texte_source := extrait_texte_noeud(el)
    diffère déloge(texte_source)

    /* 6. */
    possède_attr_src := el.possède_attribut(ATTR_src)
    si !possède_attr_src && texte_source == "" {
        retourne
    }

    /* 7. */
    saufsi el.est_connecté() {
        retourne
    }

    /* 8. */
    type_bloc_script := détermine_type_block_script(el)
    
    /* 9. */
    si est_type_mime_javascript(type_bloc_script) {
        el.type = TypeScript.CLASSIC
    }
    /* 10. */
    sinon si compare_ascii_insensible_à_la_casse(type_bloc_script, ATTR_module) {
        el.type = TypeScript.MODULE
    }
    /* 11. */
    sinon si compare_ascii_insensible_à_la_casse(type_bloc_script, ATTR_importmap) {
        el.type = TypeScript.IMPORTMAP
    }
    /* 12. */
    sinon {
        retourne
    }

    /* 13. */
    si document_parseur != nul {
        el.document_parseur = document_parseur
        el.force_async = faux
    }

    /* 14. */
    el.déjà_commencé = vrai

    /* 15. */
    el.document_du_temps_de_préparation = el.document

    /* 16. */
    si document_parseur != nul && document_parseur != el.document_du_temps_de_préparation {
        retourne
    }

    /* 17. */
    si el.scripting_est_désactivé() {
        retourne
    }

    /* 18. */
    si el.possède_attribut(ATTR_nomodule) && el.type == TypeScript.CLASSIC {
        retourne
    }

    /* 19. */
    saufsi possède_attr_src {
        bloqué := le_comportement_inline_de_l_élément_doit_être_bloqué_par_csp(el, "script", texte_source)
        si bloqué == "Blocked" {
            retourne
        }
    }

    /* 20. */
    si el.type == TypeScript.CLASSIC && el.possède_attribut(ATTR_for) && el.possède_attribut(ATTR_event) {
        valeur_for := el.donne_attribut(ATTR_for).Quelque
        valeur_event := el.donne_attribut(ATTR_event).Quelque

        valeur_event = supprime_espace_blanches_autour(valeur_event)
        valeur_for = supprime_espace_blanches_autour(valeur_for)

        saufsi compare_ascii_insensible_à_la_casse(valeur_for, ATTR_window) {
            retourne
        }
    
        saufsi compare_ascii_insensible_à_la_casse(valeur_event, ATTR_onload) || compare_ascii_insensible_à_la_casse(valeur_event, "onload()") {
            retourne
        }
    }

    /* 21. INCOMPLET : charset */

    /* 22. INCOMPLET */
    /* 23. INCOMPLET */
    module_script_credentials := ""

    /* 24. INCOMPLET */
    cryptographic_nonce := ""

    /* 25. INCOMPLET */
    integrity := ""

    /* 26. INCOMPLET */
    referrer_policy := ""

    /* 27. INCOMPLET */
    fetch_priority := ""

    /* 28. */
    métadonnée_parseuse := si el.est_inséré_par_parseuse() {
        "parser-inserted"
    }
    sinon {
        "not-parser-inserted"
    }

    /* 29. */
    options: OptionsFetchScript
    options.cryptographic_nonce = cryptographic_nonce
    options.integrity_metadata = integrity
    options.parser_metadata = métadonnée_parseuse
    options.credentials_mode = module_script_credentials
    options.referrer_policy = referrer_policy
    options.fetch_priority = fetch_priority

    /* 30. settings object */
    settings_object := donne_relevant_settings_object(el.document)

    /* 31. */
    si possède_attr_src {
        imprime("source\n")
    }
    /* 32. */
    sinon {
        // 1. Let base URL be el's node document's document base URL.
        base_url := el.document.donne_base_url()

        // 2. Switch on el's type:
        discr el.type {
            CLASSIC {
                user_agent := el.document.donne_user_agent()
                // 1. Let script be the result of creating a classic script using source text, settings object, base URL, and options.
                script := create_a_classic_script(user_agent, texte_source, settings_object, base_url, options)

                // 2. Mark as ready el given script.
                mark_as_ready(el, script)
            }
            sinon {
                panique("non-implémenté")
            }
        }
    }

    /* 33. If el's type is "classic" and el has a src attribute, or el's type is "module": */
    si (el.type == TypeScript.CLASSIC && possède_attr_src) || el.type == TypeScript.MODULE {
        panique("non-implémenté")
    }
    /* 34. Otherwise */
    sinon {
        // À FAIRE : 1. Assert: el's result is not "uninitialized".

        // 2. If all of the following are true:
        // el's type is "classic";
        // el is parser-inserted;
        // el's parser document has a style sheet that is blocking scripts; and
        // either the parser that created el is an XML parser, or it's an HTML parser whose script nesting level is not greater than one,
        // then:

            // 1. Set el's parser document's pending parsing-blocking script to el.

            // 2. Set el's ready to be parser-executed to true. (The parser will handle executing the script.)

        // 3. Otherwise, immediately execute the script element el, even if other scripts are already executing.
        execute_the_script_element(el)
    }
}

est_inséré_par_parseuse :: fonc (script: *HTMLScriptElement) -> bool
{
    retourne script.document_parseur != nul
}

détermine_type_block_script :: fonc (script: *HTMLScriptElement) -> DOMString
{
    attr_type := script.cherche_attribut(ATTR_type)
    attr_language := script.cherche_attribut(ATTR_language)

    si (attr_type != nul && attr_type.valeur.est_vide()) ||
         (attr_type == nul && attr_language != nul && attr_language.valeur.est_vide()) ||
         (attr_type == nul && attr_language == nul) {
        retourne crée_chaine_utf16_unique(MIME_text_javascript)
    }

    si attr_type {
        retourne supprime_espace_blanches_autour(attr_type.valeur)
    }

    assert(attr_language != nul)
    chn := imprime_chaine("text/%", attr_language.valeur)
    diffère déloge(chn)
    retourne crée_chaine_utf16_unique(chn)
}

/* https://html.spec.whatwg.org/multipage/scripting.html#execute-the-script-element */
execute_the_script_element :: fonc (el: *HTMLScriptElement)
{
    // 1. Let document be el's node document.
    document := el.document

    // 2. If el's preparation-time document is not equal to document, then return.
    si el.document_du_temps_de_préparation != document {
        retourne
    }

    // À FAIRE 3. Unblock rendering on el.

    // 4. If el's result is null, then fire an event named error at el, and return.
    si el.result == nul {
        _ := fire_an_event(el, EventType.error)
        retourne
    }

    // 5. If el's from an external file is true, or el's type is "module", then increment document's ignore-destructive-writes counter.
    ignore_destructive_writes_fut_incrémenté := faux 
    si el.provient_de_fichier_externe || el.type == TypeScript.MODULE {
        document.ignore_destructive_writes += 1
        ignore_destructive_writes_fut_incrémenté = vrai
    }

    // 6. Switch on el's type:
    discr el.type {
        CLASSIC {
            // 1. Let oldCurrentScript be the value to which document's currentScript object was most recently set.
            old_current_script := document.current_script

            // À FAIRE : shadow root 2. If el's root is not a shadow root, then set document's currentScript attribute to el. Otherwise, set it to null.
            document.current_script = el

            // 3. Run the classic script given by el's result.
            run_the_classic_script(el.result comme *ClassicScript)

            // 4. Set document's currentScript attribute to oldCurrentScript.
            document.current_script = old_current_script
        }
        MODULE {
            // 1. Assert: document's currentScript attribute is null.
            assert(document.current_script == nul)

            // 2. Run the module script given by el's result.
            panique("non-implémenté")
        }
        IMPORTMAP {
            panique("non-implémenté")
            // 1. Register an import map given el's relevant global object and el's result.
        }
        sinon {
            retourne
        }
    }

    // 7. Decrement the ignore-destructive-writes counter of document, if it was incremented in the earlier step.
    si ignore_destructive_writes_fut_incrémenté {
        document.ignore_destructive_writes -= 1
    }

    // 8. If el's from an external file is true, then fire an event named load at el.
    si el.provient_de_fichier_externe {
        _ := fire_an_event(el, EventType.load)
    }
}

/* https://html.spec.whatwg.org/multipage/scripting.html#mark-as-ready */
mark_as_ready :: fonc (el: *HTMLScriptElement, result : *rien = nul)
{
    // 1. Set el's result to result.
    el.result = result

    // 2. If el's steps to run when the result is ready are not null, then run them.
    si el.steps_to_run_when_the_result_is_ready {
        run(el.steps_to_run_when_the_result_is_ready)
    }

    // 3. Set el's steps to run when the result is ready to null.
    el.steps_to_run_when_the_result_is_ready = nul

    // 4. Set el's delaying the load event to false.
    el.delaying_the_load_event = faux
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLStyleElement
 * https://html.spec.whatwg.org/multipage/semantics.html#the-style-element
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLStyleElement
 * \{ */

#portée_export

HTMLStyleElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_style_element
}

#portée_fichier

table_virtuelle_style_element := TableVirtuelleÉlément(
    classe = HTMLStyleElement,
    sur_destruction = élément_sur_destruction,
    sur_connexion = style_element_sur_connexion_ou_déconnexion,
    sur_déconnexion = style_element_sur_connexion_ou_déconnexion,
    sur_dépilement = style_element_sur_dépilement,
    sur_changement_enfants = style_element_sur_changement_enfants
)

style_element_sur_connexion_ou_déconnexion :: fonc (base: *Noeud)
{
    style := base comme *HTMLStyleElement
    saufsi style.est_sur_pile_éléments_ouvert {
        ajourne_style_block(style)
    }
}

style_element_sur_dépilement :: fonc (base: *Élément)
{
    style := base comme *HTMLStyleElement
    ajourne_style_block(style)
}

style_element_sur_changement_enfants :: fonc (base: *Noeud)
{
    style := base comme *HTMLStyleElement
    ajourne_style_block(style)
}

/* https://html.spec.whatwg.org/multipage/semantics.html#update-a-style-block
 *
 * The user agent must run the update a style block algorithm whenever any of the following conditions occur:
 *     The element is popped off the stack of open elements of an HTML parser or XML parser.
 *     The element is not on the stack of open elements of an HTML parser or XML parser, and it becomes connected or disconnected.
 *     The element's children changed steps run.
 */
ajourne_style_block :: fonc (style: *HTMLStyleElement)
{
    saufsi rendu_css_est_requis(style) {
        retourne
    }

    // 1. Let element be the style element.
    element := style

    // 2. If element has an associated CSS style sheet, remove the CSS style sheet
    //    in question.
    document := element.document
    document.supprime_feuille_de_style_associée(element)

    // 3. If element is not connected, then return.
    saufsi element.est_connecté() {
        retourne
    }

    // 4. If element's type attribute is present and its value is neither the
    //    empty string nor an ASCII case-insensitive match for "text/css", then
    //    return.
    mime_css := crée_chaine_utf16_unique(MIME_text_css)

    attr_type := element.cherche_attribut(ATTR_type)
    si attr_type && !(attr_type.valeur.est_vide() || compare_ascii_insensible_à_la_casse(attr_type.valeur, mime_css)) {
        retourne
    }

    // 5. If the Should element's inline behavior be blocked by Content Security Policy?
    //    algorithm returns "Blocked" when executed upon the style element, "style",
    //    and the style element's child text content, then return. [CSP]
    texte_source := extrait_texte_noeud(style)
    diffère déloge(texte_source)

    bloqué := le_comportement_inline_de_l_élément_doit_être_bloqué_par_csp(element, "style", texte_source)
    si bloqué == "Blocked" {
        retourne
    }

    // 6. Create a CSS style sheet with the following properties:
    feuille_de_style := loge(CSS.CSSStyleSheet)
    feuille_de_style.origine = CSS.OrigineCascade.Author
    feuille_de_style.type = mime_css
    feuille_de_style.owner_node = element
    // À FAIRE : media = The media attribute of element.
    // À FAIRE : title = The title attribute of element, if element is in a document tree, or the empty string otherwise.
    feuille_de_style.alternate = faux
    feuille_de_style.origin_clean = vrai
    feuille_de_style.parent_style_sheet = nul
    feuille_de_style.owner_rule = nul

    //  À FAIRE : 7. If element contributes a script-blocking style sheet, append element
    //    to its node document's script-blocking style sheet set.

    // À FAIRE : 8. If element's media attribute's value matches the environment and
    //    element is potentially render-blocking, then block rendering on element.

    // Non-spécifié
    ctx: CSS.ContexteParsageFeuilleDeStyle
    diffère CSS.détruit_données_contexte(*ctx)
    CSS.parse_style_rules(*ctx, feuille_de_style, texte_source)
    CSS.rapporte_propriétés_non_supportées(*ctx, #nom_de_cette_fonction)
    document.ajoute_feuille_de_style(feuille_de_style)

    // À FAIRE : implémente la finalisation
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLTableElement
 * https://html.spec.whatwg.org/multipage/tables.html#the-table-element
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLTableElement
 * \{ */

#portée_export

HTMLTableElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_table_element
}

#portée_fichier

table_virtuelle_table_element := TableVirtuelleÉlément(
    classe = HTMLTableElement,
    sur_destruction = élément_sur_destruction,
    sur_applique_presentational_hints = table_element_sur_applique_presentational_hints
)

table_element_sur_applique_presentational_hints :: fonc (base: *Élément, résolveuse: *CSS.RésolveuseStyle)
{
    ajoute_propriété_pour_legacy_colour_value(résolveuse, base, ATTR_bgcolor, CSS.PROP_background_color)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLTableCellElement
 * https://html.spec.whatwg.org/multipage/tables.html#the-td-element
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLTableCellElement
 * \{ */

#portée_export

HTMLTableCellElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_table_cell_element
}

#portée_fichier

table_virtuelle_table_cell_element := TableVirtuelleÉlément(
    classe = HTMLTableCellElement,
    sur_destruction = élément_sur_destruction,
    sur_applique_presentational_hints = table_cell_element_sur_applique_presentational_hints
)

table_cell_element_sur_applique_presentational_hints :: fonc (base: *Élément, résolveuse: *CSS.RésolveuseStyle)
{
    ajoute_propriété_pour_legacy_colour_value(résolveuse, base, ATTR_bgcolor, CSS.PROP_background_color)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLTableRowElement
 * https://html.spec.whatwg.org/multipage/tables.html#the-tr-element
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLTableRowElement
 * \{ */

#portée_export

HTMLTableRowElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_table_row_element
}

#portée_fichier

table_virtuelle_table_row_element := TableVirtuelleÉlément(
    classe = HTMLTableRowElement,
    sur_destruction = élément_sur_destruction,
    sur_applique_presentational_hints = table_row_element_sur_applique_presentational_hints
)

table_row_element_sur_applique_presentational_hints :: fonc (base: *Élément, résolveuse: *CSS.RésolveuseStyle)
{
    ajoute_propriété_pour_legacy_colour_value(résolveuse, base, ATTR_bgcolor, CSS.PROP_background_color)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLTableSectionElement
 * https://html.spec.whatwg.org/multipage/tables.html#the-tbody-element
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLTableSectionElement
 * \{ */

#portée_export

HTMLTableSectionElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_table_section_element
}

#portée_fichier

table_virtuelle_table_section_element := TableVirtuelleÉlément(
    classe = HTMLTableSectionElement,
    sur_destruction = élément_sur_destruction,
    sur_applique_presentational_hints = table_section_element_sur_applique_presentational_hints
)

table_section_element_sur_applique_presentational_hints :: fonc (base: *Élément, résolveuse: *CSS.RésolveuseStyle)
{
    ajoute_propriété_pour_legacy_colour_value(résolveuse, base, ATTR_bgcolor, CSS.PROP_background_color)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom HTMLTextAreaElement
 * https://html.spec.whatwg.org/multipage/form-elements.html#the-textarea-element
 * \{ */

#portée_export

HTMLTextAreaElement :: struct {
    empl html_element: HTMLElement
    table = *table_virtuelle_textarea_element
}

/* https://html.spec.whatwg.org/multipage/form-elements.html#attr-textarea-cols-value */
donne_cols :: fonc (textarea: *HTMLTextAreaElement) -> n32
{
    cols := donne_attribut_ou_chaine_vide(textarea, ATTR_cols)
    saufsi cols.est_vide() {
        opt_valeur := parse_a_non_negative_integer(cols)
        si opt_valeur.possède_valeur() && opt_valeur.Quelque > 0 {
            retourne opt_valeur.Quelque
        }
    }
    retourne 20
}

donne_character_width :: fonc (textarea: *HTMLTextAreaElement) -> n32
{
    retourne donne_cols(textarea)
}

/* https://html.spec.whatwg.org/multipage/form-elements.html#attr-textarea-rows-value */
donne_rows :: fonc (textarea: *HTMLTextAreaElement) -> n32
{
    rows := donne_attribut_ou_chaine_vide(textarea, ATTR_rows)
    saufsi rows.est_vide() {
        opt_valeur := parse_a_non_negative_integer(rows)
        si opt_valeur.possède_valeur() && opt_valeur.Quelque > 0 {
            retourne opt_valeur.Quelque
        }
    }
    retourne 2
}

donne_character_height :: fonc (textarea: *HTMLTextAreaElement) -> n32
{
    retourne donne_rows(textarea)
}

#portée_fichier

table_virtuelle_textarea_element := TableVirtuelleÉlément(
    classe = HTMLTextAreaElement,
    sur_destruction = élément_sur_destruction
)

/** \} */
