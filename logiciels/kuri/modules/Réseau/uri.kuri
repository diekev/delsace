// Bibliothèque de manipulation d'uri.

importe Fondation

// URI = schéma:[//autorité]chemin[?requête][#fragment]
// autorité = [info_usager@]hôte[:port]
URI :: struct {
	uri : chaine
	schéma : chaine
	autorité : chaine
	chemin : chaine
	requête : chaine
	fragment : chaine
	info_usager : chaine
	hôte : chaine
	port : chaine
}

est_valide :: fonc(uri : &URI) -> bool
{
    si est_vide(uri.schéma) {
		retourne faux
	}

    si !est_vide(uri.autorité) {
	    si est_vide(uri.hôte) {
			retourne faux
		}
	}

	retourne vrai
}

construit_uri :: fonc(chn : chaine) -> URI
{
	uri : URI
	uri.uri = chn

	// le schéma se trouve entre le début et ':'
	pos := trouve_caractère(chn, ':', 0)

	si pos != -1 {
		uri.schéma = construit_chaine(@chn[0], pos)
		pos += 1
	}
	sinon {
		pos = 0
	}

	si (chn[pos] == '/' && chn[pos + 1] == '/') {
		pos = pos + 2
		fin_autorité := trouve_caractère(chn, '/', pos)

        si (fin_autorité == -1) {
			fin_autorité = chn.taille
		}

		uri.autorité = construit_chaine(@chn[pos - 2], fin_autorité - pos + 2)

		fin_user_info := trouve_caractère(chn, '@', pos)

		// il est possible d'avoir un mot de passe : username:motdepasse
		si (fin_user_info != -1) {
			uri.info_usager = construit_chaine(@chn[pos], fin_user_info - (pos))

			pos = fin_user_info + 1
		}

		// il est possible d'avoir des addresse IPv6 entre []

		si (chn[pos] == '[') {
			fin_adresse := trouve_caractère(chn, ']', 0)
			uri.hôte = construit_chaine(@chn[pos], fin_adresse - pos + 1)

			si (chn[fin_adresse + 1] == ':') {
				uri.port = construit_chaine(@chn[fin_adresse + 2], fin_autorité - fin_adresse - 2)
			}
		}
		sinon {
			debut_port := trouve_caractère(chn, ':', pos)

			si (debut_port != -1) {
				uri.port = construit_chaine(@chn[debut_port + 1], fin_autorité - debut_port - 1)
				uri.hôte = construit_chaine(@chn[pos], debut_port - pos)
			}
			sinon {
				uri.hôte = construit_chaine(@chn[pos], fin_autorité - pos)
			}
		}

		pos = fin_autorité
	}

	pos_requête := trouve_caractère(chn, '?', 0)
	pos_fragment := trouve_caractère(chn, '#', 0)
	pos_fin_chemin := chn.taille

    si (pos_requête != -1) {
		pos_fin_chemin = pos_requête
	}
	sinon si (pos_fragment != -1) {
		pos_fin_chemin = pos_requête
	}

	uri.chemin = construit_chaine(@chn[pos], pos_fin_chemin - pos)

    si (pos_requête != -1) {
		si (pos_fragment == -1) {
			pos_fragment = chn.taille
		}

		uri.requête = construit_chaine(@chn[pos_requête], pos_fragment - pos_requête)
	}

	si (pos_fragment != -1 && pos_fragment < chn.taille) {
		uri.fragment = construit_chaine(@chn[pos_fragment], chn.taille - pos_fragment)
	}

	retourne uri
}

construit_uri_depuis_chemin_requête :: fonc (chn: chaine) -> URI
{
	uri : URI

	pos := 0
	pos_requête := trouve_caractère(chn, '?', 0)
	pos_fragment := trouve_caractère(chn, '#', 0)
	pos_fin_chemin := chn.taille

    si (pos_requête != -1) {
		pos_fin_chemin = pos_requête
	}
	sinon si (pos_fragment != -1) {
		pos_fin_chemin = pos_requête
	}

	uri.chemin = construit_chaine(@chn[pos], pos_fin_chemin - pos)

    si (pos_requête != -1) {
		si (pos_fragment == -1) {
			pos_fragment = chn.taille
		}

		uri.requête = construit_chaine(@chn[pos_requête], pos_fragment - pos_requête)
	}

	si (pos_fragment != -1 && pos_fragment < chn.taille) {
		uri.fragment = construit_chaine(@chn[pos_fragment], chn.taille - pos_fragment)
	}

	retourne uri
}

// Calcul une somme de controle, sur 64bit, pour un URI selon l'algorithme de Fletcher
// https://en.wikipedia.org/wiki/Fletcher%27s_checksum
somme_controle :: fonc(uri : &URI) -> n64
{
    // nous ne considérons que l'autorité, le chemin et la requête
    somme1 := 0;
    somme2 := 0;

    pour c dans uri.autorité {
        somme1 = (somme1 + transtype(c : z32)) % 0xffffffff
        somme2 = (somme1 + somme2) % 0xffffffff
    }

    pour c dans uri.chemin {
        somme1 = (somme1 + transtype(c : z32)) % 0xffffffff
        somme2 = (somme1 + somme2) % 0xffffffff
    }

    pour c dans uri.requête {
        somme1 = (somme1 + transtype(c : z32)) % 0xffffffff
        somme2 = (somme1 + somme2) % 0xffffffff
    }

    retourne (transtype(somme2 : n64) << 32) | transtype(somme1 : n64);
}

port_pour_uri :: fonc(uri : &URI) -> n16
{
    si uri.port.taille == 0 {
        si uri.schéma == "http" {
            retourne 80
        }

        si uri.schéma == "https" {
            retourne 443
        }
    }

    retourne transtype(extrait_nombre_entier(uri.port) : n16)
}
