/* Bibliothèque de parsage de données encodées au format URL.
 *
 * Le format URL est une chaine contenant des paires nom-valeur séparées par des esperluettes ('&').
 * Les noms et valeurs sont quant à séparés par un égal ('=') : la valeur est assignée au nom.
 *
 * Par exemple :
 *
 * video=IuK93dq3&temps=137
 *
 * possède un champs « video » de valeur « IuK93dq3 » et un champs « temps » de valeur « 137 ».
 */

importe CodecDonnées
importe Compilatrice
importe Fondation
importe Introspection

/* structure auxilliaire pour l'algorithme de parsage */
InfoDonnées :: struct {
    info : *InfoTypeMembreStructure
    ptr_résultat : *z8
    ptr_données : *bool
}

/* fonction auxilliaire pour l'algorithme de parsage */
trouve_info_données :: fonc (infos: []InfoDonnées, nom: chaine) -> *InfoDonnées
{
    pour * infos {
        si it.info.nom == nom {
            retourne it
        }
    }

    retourne nul
}

RésultatParsage :: énum {
    /* Tout c'est bien passé, le texte put être parsé avec succès. */
    Succès

    /* Le texte contient un champs dont le nom ne correspond à ancun membre de la structure
     * cible. */
    MembreInconnu

    /* Aucune fonction de parsage n'existe pour le type du membre de la structure cible. */
    FonctionParsageInexistante

    /* Une valeur ne put être parsée. */
    ÉchecParsageValeur

    /* Texte malformé, une valeur peut manqué, ou le texte contient un caractère '&' final. */
    TexteMalformé
}

/* Parse une chaine au format URL pour le type T précisé et retourne une structure de ce type
 * contenant les valeurs trouvées dans le texte, ainsi qu'une DonnéesRésultat pour le type T
 * contenant des renseignements sur quels membres ont été trouvés dans le texte. La fonction
 * retourne également un drapeau pour définir si une erreur est survenue.
 *
 * Les erreurs peuvent exister si le texte est malformé, ou si une valeur ne peut être parser,
 * ou encore si un nom dans le texte ne correspond pas à un membre du type T.
 *
 * Tout échappement URL du texte d'entrée est résolu avant le parsage.
 *
 * Le type T doit être une structure.
 */
parse_texte_format_url :: fonc (texte: chaine, $T: type_de_données) -> RésultatParsage, DonnéesRésultat(T = T), T
{
    #assert info_de(T).id == id_info.STRUCTURE

    parseuse := ParseuseChaine(texte)
    // À FAIRE : nous ne pouvons pas libérer la mémoire car les chaines ne sont pas copiées
    // À FAIRE : erreur quand nous différons ici

    données : DonnéesRésultat(T = T)
    résultat : T

    info := info_de(T)

    pointeurs : []InfoDonnées
    diffère { déloge(pointeurs) }

    pour info.membres {
        id : InfoDonnées = ---
        id.info = it
        id.ptr_résultat = (*résultat comme *z8 + it.décalage)

        tableau_ajoute(*pointeurs, id)
    }

    info_données := info_de(type_de(données))
    pour info_données.membres {
        id := trouve_info_données(pointeurs, it.nom)

        si id {
            id.ptr_données = (*données comme *bool + it.décalage)
        }
    }

    tantque !fini(*parseuse) {
        pos := trouve_prochain(*parseuse, '=')

        si pos <= 0 {
            retourne RésultatParsage.TexteMalformé, données, résultat
        }

        nom := sous_chaine_jusque_index(*parseuse, pos)
        résoud_échappement_url_localement(nom)

        positionne(*parseuse, pos + 1)

        si fini(*parseuse) {
            retourne RésultatParsage.TexteMalformé, données, résultat
        }

        pos = trouve_prochain(*parseuse, '&')

        si pos <= 0 {
            pos = parseuse.chn.taille
        }

        valeur := sous_chaine_jusque_index(*parseuse, pos)
        résoud_échappement_url_localement(valeur)

        positionne(*parseuse, pos + 1)

        id := trouve_info_données(pointeurs, nom)

        saufsi id {
            retourne RésultatParsage.MembreInconnu, données, résultat
        }

        fonction_parsage := trouve_fonction_pour_type(id.info.id)

        saufsi fonction_parsage {
            retourne RésultatParsage.FonctionParsageInexistante, données, résultat
        }

        tampon : []octet
        tampon.pointeur = id.ptr_résultat comme *octet
        tampon.taille = id.info.id.taille_en_octet comme z64

        // fonction_parsage.rappel ajournera le ptr_résultat via le tampon
        saufsi fonction_parsage.rappel(valeur, tampon) {
            retourne RésultatParsage.ÉchecParsageValeur, données, résultat
        }

        mémoire(id.ptr_données) = vrai
    }

    retourne RésultatParsage.Succès, données, résultat
} @IgnoreNASA

/* DonnéesRésultat
 *
 * Cette structure polymorphique est monomorphée à partir du type passé en paramètre
 * et possède un membre correspond pour chaque membre de ce dernier.
 *
 * Les membres sont de types bool et leurs valeurs sont ajournées lors du parsage du
 * texte : si le texte possède une valeur dont le nom est celui d'un membre, celui-ci
 * aura pour valeur « vrai » dans le résultat du parsage ; si le texte ne possède pas
 * un tel nom, ou si la valeur ne peut être parsée, le membre aura pour valeur « faux ».
 */
DonnéesRésultat :: struct ($T: type_de_données) #corps_texte {
    info := info_de(T)

    enchaineuse: Enchaineuse
    initialise_enchaineuse(*enchaineuse)

    si info.membres.taille == 0 {
        ajoute_au_tampon(*enchaineuse, "Alors que j'exécute le #corps_texte de DonnéesRésultat, j'ai obtenu un type sans membre : ")
        imprime_type(*enchaineuse, info)
        ajoute_au_tampon(*enchaineuse, "\nLe type doit avoir des membres afin de pouvoir générer le corps.")

        message := chaine_depuis_enchaineuse(*enchaineuse)
        diffère déloge(message)

        compilatrice_rapporte_erreur(message)
        retourne ""
    }

    pour info.membres {
        ajoute_au_tampon(*enchaineuse, it.nom)
        ajoute_au_tampon(*enchaineuse, ":= faux\n")
    }

    retourne chaine_depuis_enchaineuse(*enchaineuse)
}

tous_les_champs_sont_renseignés :: fonc (données: DonnéesRésultat($T)) -> bool
#corps_texte {
    info := info_de(T)

    enchaineuse: Enchaineuse
    initialise_enchaineuse(*enchaineuse)

    pour info.membres {
        ajoute_au_tampon(*enchaineuse, "si !données.", it.nom, "{\n")
        ajoute_au_tampon(*enchaineuse, "retourne faux\n")
        ajoute_au_tampon(*enchaineuse, "}\n")
    }

    ajoute_au_tampon(*enchaineuse, "retourne vrai\n")

    retourne chaine_depuis_enchaineuse(*enchaineuse)
}

/*
InformationConnexion :: struct {
    courriel: chaine
    mot_de_passe: chaine
}

#test {
    requête := "courriel=exemple@courriel.fr&mot_de_passe=M0tDeP4sS3"

    raison, résultat, info := parse_texte_format_url(requête, InformationConnexion)

    compilatrice_vérifie_égalité(raison, RésultatParsage.Succès)

    compilatrice_vérifie_égalité(résultat.courriel, vrai)
    compilatrice_vérifie_égalité(résultat.mot_de_passe, vrai)

    compilatrice_vérifie_égalité(info.courriel, "exemple@courriel.fr")
    compilatrice_vérifie_égalité(info.mot_de_passe, "M0tDeP4sS3")
}
*/

// ------------------------------------
// Fonctions de parsage

__fonctions_parsage_url : []FonctionParsage

/* Trouve une FonctionParsage pour l'InfoType précisé. Voir trouve_fonction_pour_type sur
 * []FonctionParsage pour plus de détail.
 */
trouve_fonction_pour_type :: fonc (info_type: *InfoType) -> *FonctionParsage
{
    retourne trouve_fonction_pour_type(__fonctions_parsage_url, info_type)
}

ajoute_fonction_de_parsage_url :: fonc (info: *InfoType, fonction: fonc(chaine, []octet)(bool))
{
    ajoute_fonction(*__fonctions_parsage_url, info, fonction)
}

issitialise_parsage_url :: fonc ()
{
	déloge(__fonctions_parsage_url)
}

génère_initialisation_parsage_url :: fonc ()
{
    fonctions_de_parsage := fonctions_parsées_avec_annotation("ParsageURL")
    diffère déloge(fonctions_de_parsage)

    saufsi fonctions_de_parsage {
        retourne
    }

	/*
		modèle fonction de parsage : fonc (chaine, []octet) (bool)
	 */

	enchaineuse : Enchaineuse
	initialise_enchaineuse(*enchaineuse)
	diffère détruit_tampons(*enchaineuse)

    // Il nous faut les modules.
    ajoute_au_tampon(*enchaineuse, "importe Fondation\n")
    ajoute_au_tampon(*enchaineuse, "importe Introspection\n")
    ajoute_au_tampon(*enchaineuse, "importe Réseau\n")

	modules_importés : []chaine
	tableau_ajoute(*modules_importés, "Fondation")

	/* Création des enveloppes pour les fonctions de parsage. */
    pour fonctions_de_parsage {
        // valide les types
        si it.params.taille != 1 {
            compilatrice_rapporte_erreur(it, "Impossible d'utiliser la fonction comme parseuse pour URL, elle ne doit avoir qu'un seul paramètre")
            retourne
        }

        type_premier_paramètre := it.params[0].type
        si type_premier_paramètre != info_de(chaine) {
            compilatrice_rapporte_erreur(it.params[0], "Fonction de parsage URL invalide, le paramètre doit être de type « chaine ».")
            retourne
        }

		si it.params_sorties.taille != 2 {
            compilatrice_rapporte_erreur(it, "Impossible d'utiliser la fonction comme parseuse pour URL, elle doit avoir deux paramètres de sortie : TypeÀFormatter et bool")
            retourne
		}

		type_première_sortie := it.params_sorties[0].type
		type_deuxième_sortie := it.params_sorties[1].type

		si type_première_sortie != info_de(bool) {
            compilatrice_rapporte_erreur(it.params[0], "Fonction de parsage URL invalide, le première paramètre de sortie doit être de type « bool ».")
            retourne
		}

		nom_module := compilatrice_module_pour_code(it)
		si nom_module {
			pour module_importé dans modules_importés {
				si module_importé == nom_module {
					arrête
				}
			}
			sansarrêt {
				ajoute_au_tampon(*enchaineuse, "importe ", nom_module, "\n")
				tableau_ajoute(*modules_importés, nom_module)
			}
		}

        ajoute_au_tampon(*enchaineuse, "parsage_url_", it.nom, " :: fonc (chn: chaine, tampon: []octet) -> bool\n")
        ajoute_au_tampon(*enchaineuse, "{\n")
        ajoute_au_tampon(*enchaineuse, "\tsuccès, valeur := ", it.nom, "(chn)\n")
		ajoute_au_tampon(*enchaineuse, "\tsaufsi succès {\n\t\tretourne faux\n\t}\n")
		ajoute_au_tampon(*enchaineuse, "\tcopie_mem_nonsur(src = *valeur, dst = tampon.pointeur, taille = tampon.taille)\n")
		ajoute_au_tampon(*enchaineuse, "\tretourne vrai\n")
        ajoute_au_tampon(*enchaineuse, "}\n")
    }

    /* Création de la fonction d'initialisation. */
    ajoute_au_tampon(*enchaineuse, "initialise_parsage_url :: fonc ()\n")
    ajoute_au_tampon(*enchaineuse, "{\n")
    ajoute_au_tampon(*enchaineuse, "\tinitalise_types_base(*__fonctions_parsage_url)\n")

    pour fonctions_de_parsage {
        type_deuxième_paramètre := it.params_sorties[1].type
        ajoute_au_tampon(*enchaineuse, "\tajoute_fonction_de_parsage_url(info_de(")
        imprime_type(*enchaineuse, type_deuxième_paramètre)
        ajoute_au_tampon(*enchaineuse, "), parsage_url_", it.nom, ")\n")
    }

    ajoute_au_tampon(*enchaineuse, "}\n")
    ajoute_au_tampon(*enchaineuse, "#ajoute_init initialise_parsage_url()\n")
    ajoute_au_tampon(*enchaineuse, "#ajoute_fini issitialise_parsage_url()\n")

    sources := chaine_depuis_enchaineuse(*enchaineuse)
    diffère déloge(sources)

    ajoute_chaine_à_la_compilation(compilatrice_espace_courant(), sources)
}

#pré_exécutable génère_initialisation_parsage_url()
