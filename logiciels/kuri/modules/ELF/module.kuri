importe Chaine
importe Flux
importe Fondation

charge "interface"

/* Module de travail et d'analyse de fichiers ELF.
 * Pour le moment, seuls les fichiers 64-bits sont supportés.
 *
 * Références :
 * http://refspecs.linuxbase.org/elf/elf.pdf
 * https://uclibc.org/docs/elf-64-gen.pdf
 */

/* ------------------------------------------------------------------------- */
/** \nom FichierELF
 * \{ */

FichierELF :: struct {
    contenu: []octet
}

/* Crée un fichier ELF à partir du contenu de fichier donné.
 *
 * NOTE : le code de ce module suppose que le contenu du fichier survie à
 * l'instance de FichierELF. */
crée_fichier_elf :: fonc (contenu: []octet) -> FichierELF
{
    retourne FichierELF(contenu)
}

initialise_fichier_elf :: fonc (fichier: *FichierELF, contenu: []octet)
{
    fichier.contenu = contenu
}

entête_fichier :: fonc (fichier: *FichierELF) -> *EntêteELF64
{
    retourne fichier.contenu.pointeur comme *EntêteELF64
}

entête_section :: fonc (fichier: *FichierELF, indice: Elf32_Half) -> *EntêteSectionELF64
{
    entête := fichier.entête_fichier()
    retourne (fichier.contenu.pointeur + entête.e_shoff + indice * taille_de(EntêteSectionELF64)) comme *EntêteSectionELF64
}

trouve_section :: fonc (fichier: *FichierELF, type: TypeSection) -> *EntêteSectionELF64
{
    entête := fichier.entête_fichier()
    table_symbole_entêtes := fichier.entête_section(entête.e_shstrndx)
    nombre_de_sections := entête.e_shnum

    pour nombre_de_sections {
        section := fichier.entête_section(it)
        si section.type == type {
            retourne section
        }
    }

    retourne nul
}

trouve_section :: fonc (fichier: *FichierELF, nom: chaine) -> *EntêteSectionELF64
{
    entête := fichier.entête_fichier()
    table_symbole_entêtes := fichier.entête_section(entête.e_shstrndx)
    nombre_de_sections := entête.e_shnum

    pour nombre_de_sections {
        section := fichier.entête_section(it)
        nom_section_c := (fichier.contenu.pointeur + table_symbole_entêtes.sh_offset + section.sh_name) comme *z8
        nom_section := convertis_chaine_c_statique(ChaineC(nom_section_c))

        si nom_section == nom {
            retourne section
        }
    }

    retourne nul
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Entête du fichier ELF64.
 * \{ */

/* Valeurs d'indice pour EntêteELF64.e_ident. */
IdentifiantELF :: énum {
    MAG0 :: 0
    MAG1 :: 1
    MAG2 :: 2
    MAG3 :: 3
    CLASS :: 4
    DATA :: 5
    VERSION :: 6
    OSABI :: 7
    ABIVERSION :: 8
    PAD :: 9

    NIDENT :: 16
}

EntêteELF64 :: Elf64_Ehdr

TypeFichierObjet :: énum Elf64_Half {
    /* Aucune type de fichier. */
    NONE :: 0
    /* Ficher réadressable. */
    REL :: 1
    /* Fichier exécutable. */
    EXEC :: 2
    /* Fichier partagé. */
    DYN :: 3
    /* Fichier coeur. */
    CORE :: 4
    /* Spécifique à l'environnement. */
    LOOS :: 0xFE00
    HIOS :: 0xFEFF
    /* Spécifique au processeur. */
    LOPROC :: 0xFF00
    HIPROC :: 0xFFFF
}

donne_type_fichier_objet :: fonc (entête: *EntêteELF64) -> TypeFichierObjet
{
    retourne entête.e_type comme TypeFichierObjet
}

ClasseFichier :: énum n8 {
    /* 32-bit. */
    ELFCLASS32 :: 1
    /* 64-bit. */
    ELFCLASS64 :: 2
}

donne_classe_fichier :: fonc (entête: *EntêteELF64) -> ClasseFichier
{
    retourne entête.e_ident[IdentifiantELF.CLASS] comme ClasseFichier
}

EncodageDonnées :: énum n8 {
    /* Petit boutisme. */
    ELFDATA2LSB :: 1
    /* Grand boutisme. */
    ELFDATA2MSB :: 2
}

donne_encodage_fichier :: fonc (entête: *EntêteELF64) -> EncodageDonnées
{
    retourne entête.e_ident[IdentifiantELF.DATA] comme EncodageDonnées
}

EV_CURRENT : n8 : 1

donne_version_fichier :: fonc (entête: *EntêteELF64) -> n8
{
    retourne entête.e_ident[IdentifiantELF.VERSION]
}

donne_chaine_ABI :: fonc (entête: *EntêteELF64) -> chaine
{
    retourne donne_chaine_ABI(entête.e_ident[IdentifiantELF.OSABI])
}

donne_chaine_ABI :: fonc (abi: n8) -> chaine
{
    discr abi {
        0 { retourne "UNIX System V" }
        1 { retourne "HP-UX" }
        2 { retourne "NetBSD" }
        3 { retourne "Linux" }
        6 { retourne "Sun Solaris" }
        7 { retourne "IBM AIX" }
        8 { retourne "SGI Irix" }
        9 { retourne "FreeBSD" }
        10 { retourne "Compaq TRU64" }
        11 { retourne "Novell Modesto" }
        12 { retourne "OpenBSD" }
        64 { retourne "ARM EABI" }
        97 { retourne "ARM" }
        255 { retourne "Standalone" }
        sinon {}
    }

    retourne "ABI inconnue"
}

donne_version_ABI :: fonc (entête: *EntêteELF64) -> n8
{
    retourne entête.e_ident[IdentifiantELF.ABIVERSION]
}

donne_architecture_cible :: fonc (entête: *EntêteELF64) -> Elf64_Half
{
    retourne entête.e_machine
}

donne_chaine_architecture_cible :: fonc (entête: *EntêteELF64) -> chaine
{
    discr entête.e_machine {
        0x00 { retourne "aucune architecture spécifique" }
        0x02 { retourne "SPARC" }
        0x03 { retourne "x86" }
        0x08 { retourne "MIPS" }
        0x14 { retourne "PowerPC" }
        0x16 { retourne "S390" }
        0x28 { retourne "ARM" }
        0x2A { retourne "SuperH" }
        0x32 { retourne "IA-64" }
        0x3E { retourne "Advanced Micro Devices X86-64" }
        0xB7 { retourne "AArch64" }
        0xF3 { retourne "RISC-V" }
        sinon {}
    }

    retourne "architecture cible inconnue."
}

donne_version_format_fichier_objet :: fonc (entête: *EntêteELF64) -> Elf64_Word
{
    retourne entête.e_version
}

donne_adresse_point_d_entrée :: fonc (entête: *EntêteELF64) -> Elf64_Addr
{
    retourne entête.e_entry
}

donne_début_entêtes_de_programme :: fonc (entête: *EntêteELF64) -> Elf64_Off
{
    retourne entête.e_phoff
}

donne_début_entêtes_de_section :: fonc (entête: *EntêteELF64) -> Elf64_Off
{
    retourne entête.e_shoff
}

donne_fanions_processeur :: fonc (entête: *EntêteELF64) -> Elf64_Word
{
    retourne entête.e_flags
}

donne_taille_entête :: fonc (entête: *EntêteELF64) -> Elf64_Half
{
    /* Doit être taille_de(EntêteELF64). */
    retourne entête.e_ehsize
}

donne_taille_entête_programme :: fonc (entête: *EntêteELF64) -> Elf64_Half
{
    retourne entête.e_phentsize
}

donne_nombre_entête_programme :: fonc (entête: *EntêteELF64) -> Elf64_Half
{
    retourne entête.e_phnum
}

donne_taille_entête_section :: fonc (entête: *EntêteELF64) -> Elf64_Half
{
    /* Doit être taille_de(EntêteSectionELF64) */
    retourne entête.e_shentsize
}

donne_nombre_entête_section :: fonc (entête: *EntêteELF64) -> Elf64_Half
{
    retourne entête.e_shnum
}

donne_index_section_table_des_chaines :: fonc (entête: *EntêteELF64) -> Elf64_Half
{
    retourne entête.e_shstrndx
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom EntêteSectionELF64
 * \{ */

EntêteSectionELF64 :: Elf64_Shdr

donne_type_section :: fonc (entête: *Elf64_Shdr) -> TypeSection
{
    retourne (entête.sh_type comme TypeSection)
}

TypeSection :: énum Elf64_Word {
    /* Marque une section inutilisée. */
    Nulle :: 0
    /* Contient les informations définies par le programme. */
    BitsProgramme :: 1
    /* Contient une table de symbole pour lieur. */
    TableSymbole :: 2
    /* Contient une table de chaines. */
    TableChaine :: 3
    /* Contient le type "Rela" de relocation. */
    Rela :: 4
    /* Contient une table de hachage de symbole. */
    HachageSymbole :: 5
    /* Contient les tables de liaison dynamique. */
    Dynamique :: 6
    /* Contient des informations de notes. */
    Note :: 7
    /* Contient de l'espace non-initialisé; qui n'occupe pas d'espace dans le fichier. */
    AucunBits :: 8
    /* Contient le type "Rel" de relocation. */
    Rel :: 9
    /* Réservé */
    ShLib :: 10
    /* Contient une table de symbole pour chargeur dynamique. */
    SymboleDynamique :: 11

    TableConstructeurs :: 0x0E
    TableDestructeurs :: 0x0F
    TablePréConstructeurs :: 0x10
    GroupeDeSection :: 0x11
    IndexSectionÉtendue :: 0x12

    NombreTypeDéfinis :: 0x13

    /* Usage spécifique au système d'exploitation. */
    SysExpBas :: 0x60000000
    SysExpHaut :: 0x6FFFFFFF

    /* Usage spécifique au processeur. */
    ProcBas :: 0x70000000
    ProcHaut :: 0x7FFFFFFF
}

DrapeauxSection :: énum_drapeau Elf64_Xword {
    WRITE :: 0x1
    ALLOC :: 0x2
    EXECINSTR :: 0x4
    MERGE :: 0x10
    STRINGS :: 0x20
    INFO_LINK :: 0x40
    LINK_ORDER :: 0x80
    OS_NONCONFORMING :: 0x100
    GROUP :: 0x200
    TLS :: 0x400
    MASKOS :: 0x0ff00000
    MASKPROC :: 0xf0000000
}

donne_drapeaux :: fonc (entête: *EntêteSectionELF64) -> DrapeauxSection
{
    retourne entête.sh_flags comme DrapeauxSection
}

/* Retourne la chaine après "SHT_" dans le nom du macro C du type de section. */
donne_nom_macro_type_section :: fonc (type_section: TypeSection) -> chaine
{
    discr type_section {
        Nulle { retourne "NULL" }
        BitsProgramme { retourne "PROGBITS" }
        TableSymbole { retourne "SYMTAB" }
        TableChaine { retourne "STRTAB" }
        Rela { retourne "RELA" }
        HachageSymbole { retourne "HASH" }
        Dynamique { retourne "DYNAMIC" }
        Note { retourne "NOTE" }
        AucunBits { retourne "NOBITS" }
        Rel { retourne "REL" }
        ShLib { retourne "SHLIB" }
        SymboleDynamique { retourne "DYNSYM" }
        TableConstructeurs { retourne "INIT_ARRAY" }
        TableDesctructeurs { retourne "FINI_ARRAY" }
        TablePréConstructeurs { retourne "À FAIRE" }
        GroupeDeSection { retourne "À FAIRE" }
        IndexSectionÉtendue { retourne "À FAIRE" }
        NombreTypeDéfinis { retourne "À FAIRE" }
        SysExpBas { retourne "LOOS" }
        SysExpHaut { retourne "HIOS" }
        ProcBas { retourne "LOPROC" }
        ProcHaut { retourne "HIPROC" }
        sinon { retourne "" }
    }

    retourne ""
}

donne_données_section :: fonc (fichier: *FichierELF, section: *EntêteSectionELF64) -> []octet
{
    résultat: []octet

    si section.sh_offset comme z64 < fichier.contenu.taille && (section.sh_offset + section.sh_size) comme z64 <= fichier.contenu.taille {
        données_section := fichier.contenu.pointeur + section.sh_offset
        résultat.pointeur = données_section
        résultat.taille = section.sh_size comme z64
    }
    sinon {
        imprimeln("Impossible de lire les données de la section, la taille du fichier est trop petite.")
    }

    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom SymboleELF64
 * \{ */

SymboleELF64 :: Elf64_Sym

TypeSymbole :: énum n8 {
    NOTYPE :: 0
    OBJECT :: 1
    FUNC :: 2
    SECTION :: 3
    FILE :: 4
    COMMON :: 5
    TLS :: 6
    NUM :: 7
    LOOS :: 10
    GNU_IFUNC :: 10
    HIOS :: 12
    LOPROC :: 13
    HIPROC :: 15
}

donne_type :: fonc (symbole: *SymboleELF64) -> TypeSymbole
{
    retourne (symbole.st_info & 0xf) comme TypeSymbole
}

LiaisonSymbole :: énum n8 {
    LOCAL :: 0
    GLOBAL :: 1
    WEAK :: 2
    LOOS :: 10
    HIOS :: 12
    LOPROC :: 13
    HIPROC :: 15
}

donne_liaison :: fonc (symbole: *SymboleELF64) -> LiaisonSymbole
{
    retourne (symbole.st_info >> 4) comme LiaisonSymbole
}

/* https://refspecs.linuxbase.org/elf/gabi4+/ch4.symtab.html#visibility */
VisibilitéSymbole :: énum n8 {
    DEFAULT :: 0
    INTERNAL :: 1
    HIDDEN :: 2
    PROTECTED :: 3
}

donne_visibilité :: fonc (symbole: *SymboleELF64) -> VisibilitéSymbole
{
    retourne (symbole.st_other & 0x3) comme VisibilitéSymbole
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Table de symboles.
 * \{ */

TableDesSymboles :: struct {
    fichier: *FichierELF
    table_des_chaines: *EntêteSectionELF64
    table_symbole: *EntêteSectionELF64
    table_symbole_entêtes: *EntêteSectionELF64
}

donne_table_des_symboles :: fonc (fichier: *FichierELF) -> Optionnel(TableDesSymboles)
{
    entête := fichier.entête_fichier()
    saufsi entête {
        retourne
    }

    // Pour trouver les noms des sections
    table_symbole_entêtes := fichier.entête_section(entête.e_shstrndx)

    entête_section_table_symbole: *EntêteSectionELF64
    table_des_chaines := fichier.trouve_section(".strtab")

    pour entête.e_shnum {
        section := fichier.entête_section(it)

        si donne_type_section(section) == TypeSection.TableSymbole {
            entête_section_table_symbole = section
            arrête
        }
    }

    saufsi entête_section_table_symbole && table_des_chaines {
        retourne
    }

    résultat: TableDesSymboles
    résultat.fichier = fichier
    résultat.table_des_chaines = table_des_chaines
    résultat.table_symbole = entête_section_table_symbole
    résultat.table_symbole_entêtes = table_symbole_entêtes
    retourne résultat
}

donne_nombre_de_symboles :: fonc (table: *TableDesSymboles) -> z64
{
    retourne (table.table_symbole.sh_size / taille_de(SymboleELF64)) comme z64
}

donne_symbole :: fonc (table: *TableDesSymboles, nom: chaine) -> *SymboleELF64
{
    nombre_de_symboles := donne_nombre_de_symboles(table)

    résultat: *SymboleELF64

    pour nombre_de_symboles {
        symbole := donne_symbole(table, it)
        nom_symbole := donne_nom_symbole(table, symbole)

        si nom_symbole == nom {
            résultat = symbole
            arrête
        }
    }

    retourne résultat
}

donne_symbole :: fonc (table: *TableDesSymboles, indice: z64) -> *SymboleELF64
{
    base := table.fichier.contenu.pointeur + table.table_symbole.sh_offset
    décalage := indice * taille_de(SymboleELF64) comme z64
    retourne (base comme z64 + décalage) comme *SymboleELF64
}

donne_nom_symbole :: fonc (empl table: *TableDesSymboles, symbole: *SymboleELF64) -> chaine
{
    base := fichier.contenu.pointeur + table_des_chaines.sh_offset + symbole.st_name
    retourne convertis_chaine_c_statique(ChaineC(base comme *z8))
}

donne_nom_table :: fonc (empl tabl: *TableDesSymboles) -> chaine
{
    base := fichier.contenu.pointeur + table_symbole_entêtes.sh_offset + table_symbole.sh_name
    retourne convertis_chaine_c_statique(ChaineC(base comme *z8))
}

donne_nom_section_symbole :: fonc (empl table: *TableDesSymboles, symbole: *SymboleELF64) -> chaine
{
    index_entête_section := symbole.st_shndx

    discr index_entête_section {
        0 {
            // SHN_UNDEF
            retourne "UND"
        }
        0xff00 {
            // SHN_LORESERVE ou SHN_LOPROC
            retourne "LOP"
        }
        0xff1f {
            // SHN_HIPROC
            retourne "HIP"
        }
        0xfff1 {
            // SHN_ABS
            retourne "ABS"
        }
        0xfff2 {
            // SHN_COMMON
            retourne "COM"
        }
        0xffff {
            // SHN_HIRESERVE
            retourne "HIR"
        }
        sinon {}
    }

    section := fichier.entête_section(index_entête_section)
    base := fichier.contenu.pointeur + table_symbole_entêtes.sh_offset + section.sh_name
    retourne convertis_chaine_c_statique(ChaineC(base comme *z8))
}

/** \} */

donne_entrées_section_dynamic :: fonc (fichier: *FichierELF) -> []Elf64_Dyn
{
    résultat: []Elf64_Dyn

    section_dynamic := trouve_section(fichier, ".dynamic")
    si section_dynamic {
        données_section := donne_données_section(fichier, section_dynamic)

        si données_section {
            si données_section.taille % taille_de(Elf64_Addr) comme z64 == 0 {
                résultat.pointeur = données_section.pointeur comme *Elf64_Dyn
                résultat.taille = données_section.taille / taille_de(Elf64_Addr) comme z64

                pour résultat {
                    si it.d_tag == DT_NULL {
                        résultat.taille = indice_it
                        arrête
                    }
                }
            }
            sinon {
                imprimeln("[%] la section .dynamic n'a pas une taille compatible avec Elf64_Addr", #nom_de_cette_fonction)
            }
        }
        sinon {
            imprimeln("[%] pas de données pour la section .dynamic", #nom_de_cette_fonction)
        }
    }
    sinon {
        imprimeln("[%] pas de section .dynamic", #nom_de_cette_fonction)
    }

    retourne résultat
}

/* Retourne vrai si Elf*_Dyn.d_val doit être utilisé. Sinon, Elf64_Dyn.d_ptr doit l'être.
 *
 * To make it simpler for tools to interpret the contents of dynamic section entries, the
 * value of each tag, except for those in two special compatibility ranges, will determine
 * the interpretation of the d_un union. A tag whose value is an even number indicates a
 * dynamic section entry that uses d_ptr. A tag whose value is an odd number indicates a
 * dynamic section entry that uses d_val or that uses neither d_ptr nor d_val.
 * Tags whose values are less than the special value DT_ENCODING and tags whose values fall
 * between DT_HIOS and DT_LOPROC do not follow these rules.
 *
 * https://refspecs.linuxbase.org/elf/gabi4+/ch5.dynamic.html
 */
doit_utiliser_valeur :: fonc (entrée: Elf64_Dyn) -> bool
{
    si entrée.d_tag % 2 == 0 {
        retourne faux
    }

    // À FAIRE : DT_ENCODING, DT_HIOS, DT_LOPROC
    retourne vrai
}

/* ------------------------------------------------------------------------- */
/** \nom Données pour .eh_frame
 * \{ */

CommonInformationEntry64 :: struct {
    length: n64
    cie_id: n32
    version: n8
    augmentation_string: chaine
    code_alignement_factor: n64
    data_alignement_factor: z64
    return_address_register: n8
    augmentation_data: []octet
    initial_instructions: []octet

    indice_premier_fde: z64
    un_après_indice_dernier_fde: z64
}

donne_fde_ptr_encoding :: fonc (cie: *CommonInformationEntry64) -> octet
{
    assert(cie.augmentation_string == "zR")
    assert(cie.augmentation_data.taille == 1)
    retourne cie.augmentation_data[0]
}

fde_possède_augmentation :: fonc (cie: *CommonInformationEntry64) -> bool
{
    retourne trouve_caractère_depuis_le_début(cie.augmentation_string, 'z') != -1
}

FrameDescriptionEntry64 :: struct {
    length: n64
    cie_pointer: n32
    pc_begin: PointeurEncodé
    pc_range: n64
    augmentation_data: []octet
    call_frame_instructions: []octet
}

DonnéesEHFrame :: struct {
    cies: [..]CommonInformationEntry64
    fdes: [..]FrameDescriptionEntry64
}

donne_fdes :: fonc (données: *DonnéesEHFrame, cie: *CommonInformationEntry64) -> []FrameDescriptionEntry64
{
    résultat: []FrameDescriptionEntry64
    résultat.pointeur = données.fdes.pointeur + cie.indice_premier_fde
    résultat.taille = cie.un_après_indice_dernier_fde - cie.indice_premier_fde
    retourne résultat
}

parse_données_eh_frame :: fonc (fichier: *FichierELF) -> (succès: bool, données: DonnéesEHFrame)
{
    succès = vrai
    résultat: DonnéesEHFrame

    entête := entête_fichier(fichier)

    si entête {
        section := trouve_section(fichier, ".eh_frame")
        si section {
            données_section := donne_données_section(fichier, section)

            flux := crée_flux_octets(données_section)
            diffère détruit(flux)

            tantque est_valide(flux) {
                length := parse_length_cie(flux)
                si length == 0 {
                    arrête
                }

                position_après_length := donne_position(flux).Début comme z64

                cie_id, _ := lis_petit_boutisme(flux, n32)
                si cie_id != 0 {
                    imprimeln("Erreur l'id d'une entrée CIE doit être de 0, obtenu %", cie_id)
                    succès = faux
                }

                version, _ := lis_petit_boutisme(flux, n8)
                si version != 1 {
                    imprimeln("Erreur la version d'une entrée CIE doit être de 1, obtenu %", version)
                    succès = faux
                }

                augmentation_string := lis_chaine_nul_terminée(flux)

                code_alignement_factor := décode_leb128_naturel(flux)

                data_alignement_factor := décode_leb128_relatif(flux)

                // uleb128 si version != 1
                return_address_register, _ := lis_petit_boutisme(flux, n8)

                augmentation_length := décode_leb128_naturel(flux)
                augmentation_data := lis_tranche_octet(flux, augmentation_length comme z64)

                position_flux := donne_position(flux)
                taille_lue := (position_flux.Début comme z64 - position_après_length)
                taille_restante := length comme z64 - taille_lue
                si taille_restante < 0 {
                    imprimeln("Erreur, nous avons lu trop de données pour le CIE : % / %", taille_lue, length)
                    succès = faux
                }

                initial_instructions := lis_tranche_octet(flux, taille_restante)

                cie := tableau_ajoute_élément(*résultat.cies)
                cie.length = length
                cie.cie_id = cie_id
                cie.version = version
                cie.augmentation_string = augmentation_string
                cie.code_alignement_factor = code_alignement_factor
                cie.data_alignement_factor = data_alignement_factor
                cie.return_address_register = return_address_register
                cie.augmentation_data = augmentation_data
                cie.initial_instructions = initial_instructions
                cie.indice_premier_fde = résultat.fdes.taille
                cie.un_après_indice_dernier_fde = cie.indice_premier_fde

                tantque est_valide(flux) {
                    length_fde := parse_length_cie(flux)
                    si length_fde == 0 {
                        arrête
                    }

                    position_après_length = donne_position(flux).Début comme z64

                    cie_pointer, _ := lis_petit_boutisme(flux, n32)
                    // si length == 0 => fini
                    assert(cie_pointer != 0)

                    encodage_pointeur := donne_fde_ptr_encoding(cie)
                    pc_begin := parse_pointer_encodé(flux, encodage_pointeur)
                    pc_range := parse_pointer_encodé(flux, encodage_pointeur)

                    augmentation_length_fde: n64
                    augmentation_data_fde: []octet

                    si fde_possède_augmentation(cie) {
                        augmentation_length_fde = décode_leb128_naturel(flux)
                        augmentation_data_fde = lis_tranche_octet(flux, augmentation_length_fde comme z64)
                    }

                    position_flux = donne_position(flux)
                    taille_lue = (position_flux.Début comme z64 - position_après_length)
                    taille_restante = length_fde comme z64 - taille_lue
                    si taille_restante < 0 {
                        imprimeln("Erreur, nous avons lu trop de données pour le FDE : % / %", taille_lue, length)
                        succès = faux
                    }

                    instructions_fde := lis_tranche_octet(flux, taille_restante)

                    fde := tableau_ajoute_élément(*résultat.fdes)
                    fde.length = length_fde
                    fde.cie_pointer = cie_pointer
                    fde.pc_begin = pc_begin
                    fde.pc_range = pc_range.données
                    fde.augmentation_data = augmentation_data_fde
                    fde.call_frame_instructions = instructions_fde

                    cie.un_après_indice_dernier_fde += 1
                }
            }
        }
    }

    retourne succès, résultat
}

parse_length_cie :: fonc (flux: *FluxOctets) -> n64
{
    length32, _ := lis_petit_boutisme(flux, n32)
    length: n64 = length32
    si length == 0xffffffff {
        extended_length, _ := lis_petit_boutisme(flux, n64)
        length = extended_length
    }
    retourne length
}

PointeurEncodé :: struct {
    Représentation :: énum n8 {
        INT_16
        INT_32
        INT_64
        UINT_16
        UINT_32
        UINT_64
    }

    Base :: énum n8 {
        NULLE
        PC
        TEXT
        DATA
        FUNC
    }

    Sémantique :: énum n8 {
        VOID_PTR
        VOID_PTR_PTR
    }

    représentation: Représentation
    base: Base
    sémantique: Sémantique
    données: n64
}

parse_pointer_encodé :: fonc (flux: *FluxOctets, encodage: octet) -> PointeurEncodé
{
    // Valeurs non-gérées pour le moment
    assert(encodage != 0xFF)
    assert(encodage != 0x50)

    encodage_valeur_pointeur := encodage & 0xF
    // Valeurs non-gérées pour le moment
    assert(encodage_valeur_pointeur != 0x0)
    assert(encodage_valeur_pointeur != 0x1)
    assert(encodage_valeur_pointeur != 0x9)

    résultat: PointeurEncodé

    si encodage_valeur_pointeur == 0x2 {
        temp, _ := lis_petit_boutisme(flux, n16)
        résultat.données = temp
        résultat.représentation = PointeurEncodé.Représentation.UINT_16
    }
    sinon si encodage_valeur_pointeur == 0x3 {
        temp, _ := lis_petit_boutisme(flux, n32)
        résultat.données = temp
        résultat.représentation = PointeurEncodé.Représentation.UINT_32
    }
    sinon si encodage_valeur_pointeur == 0x4 {
        temp, _ := lis_petit_boutisme(flux, n64)
        résultat.données = temp
        résultat.représentation = PointeurEncodé.Représentation.UINT_64
    }
    sinon si encodage_valeur_pointeur == 0xA {
        temp, _ := lis_petit_boutisme(flux, z16)
        résultat.données = temp comme n64
        résultat.représentation = PointeurEncodé.Représentation.INT_16
    }
    sinon si encodage_valeur_pointeur == 0xB {
        temp, _ := lis_petit_boutisme(flux, z32)
        résultat.données = temp comme n64
        résultat.représentation = PointeurEncodé.Représentation.INT_32
    }
    sinon si encodage_valeur_pointeur == 0xC {
        temp, _ := lis_petit_boutisme(flux, z64)
        résultat.données = temp comme n64
        résultat.représentation = PointeurEncodé.Représentation.INT_64
    }

    encodage_base := encodage & 0x70
    si encodage_base == 0x10 {
        résultat.base = PointeurEncodé.Base.PC
    }
    sinon si encodage_base == 0x20 {
        résultat.base = PointeurEncodé.Base.TEXT
    }
    sinon si encodage_base == 0x30 {
        résultat.base = PointeurEncodé.Base.DATA
    }
    sinon si encodage_base == 0x40 {
        résultat.base = PointeurEncodé.Base.FUNC
    }

    encodage_sémantique := encodage & 0x80
    si encodage_sémantique == 0x80 {
        résultat.sémantique = PointeurEncodé.Sémantique.VOID_PTR_PTR
    }

    retourne résultat
}

/** \} */
