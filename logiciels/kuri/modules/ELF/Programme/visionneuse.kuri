importe Allocatrices
importe BoiteFlexible
importe Chaine
importe CréationFenêtre
importe Couleur
importe DWARF
importe ELF
importe Flux
importe Fondation
importe Image
importe InfosInterface
importe Guettage
importe Krypto
importe Math
importe PeintureInterface
importe Périphériques
importe Sérialisation
importe SysFichier
importe Tabulation
importe Triage
importe Typographie

/*

À FAIRE :

 - cliquer sur un symbole pour afficher sa section (au bon décalage ?)
 - désassemblage des sections EXECINSTR
 - affichage des propriétés des sections dans une barre latérale
 - utilisation des bonnes sections de table de symboles, etc.
 - affichage des propriétés des sections
 - filtrage, triage des colonnes

*/

principale :: fonc ()
{
    TAILLE_ARÈNE_PERMANENTE :: 32 * 1024 * 1024
    TAILLE_ARÈNE_TRANSIENTE :: 32 * 1024 * 1024
    taille_mémoire_application := TAILLE_ARÈNE_TRANSIENTE + TAILLE_ARÈNE_PERMANENTE
    mémoire_application := loge_tableau(octet, taille_mémoire_application)

    visionneuse: VisionneuseELF
    diffère détruit_données(*visionneuse)

    mémoire_arène_permanente := mémoire_application.pointeur
    mémoire_arène_transiente := mémoire_application.pointeur + TAILLE_ARÈNE_PERMANENTE
    initialise_arène(*visionneuse.arène, mémoire_arène_permanente, TAILLE_ARÈNE_PERMANENTE comme n64)
    initialise_arène(*visionneuse.arène_transiente, mémoire_arène_transiente, TAILLE_ARÈNE_TRANSIENTE comme n64)

    args := tableau_avance(arguments_ligne_commande())
    pour args {
        si est_un_fichier_régulier(CheminFichier(it)) {
            ouvre_fichier_elf(*visionneuse, CheminFichier(it))
        }
    }

    visionneuse.fonte = donne_fonte_défaut(16.0)
    visionneuse.fonte_mono = donne_fonte("FiraCode-Regular", 14.0)

    fenêtre := crée_fenêtre(800, 600, "VisionneuseELF", vrai)

    doit_fermer := faux

    tantque !doit_fermer {
        évènements := ajourne_évènements_fenêtre(fenêtre)

        largeur, hauteur := donne_taille_fenêtre(fenêtre)

        pour évènements {
            si it.type == TypeÉvènement.Fermeture {
                doit_fermer = vrai
                arrête
            }

            si it.type == TypeÉvènement.Déposage {
                pour mime dans it.mimes {
                    si mime.type == "text/uri-list" {
                        fichiers := divise(mime.données, "\r\n")
                        diffère déloge(fichiers)
                        pour fichier dans fichiers {
                            schéma := "file://"
                            si commence_par(fichier, schéma) {
                                fichier = avance(fichier, schéma.taille)
                            }
                            ouvre_fichier_elf(*visionneuse, CheminFichier(fichier))
                        }
                    }
                }

                continue
            }

            // si app.guetteuse && gère_évènement(app.guetteuse, it) == ÉtatÉvènement.CONSOMMÉ {
            //     continue
            // }

            gère_évènement(*visionneuse.emboiteuse, it)
        }

        marque := donne_marque_stockage_temporaire()
        diffère définis_marque_stockage_temporaire(marque)

        dessine_fenêtre(*visionneuse, largeur, hauteur)

        permute_tampons_fenêtre(fenêtre)

        définis_curseur(fenêtre, donne_curseur(*visionneuse.emboiteuse))
    }
}

/* ------------------------------------------------------------------------- */
/** \nom Onglet
 * \{ */

Onglet :: struct {
    nom: chaine
    type_section: TypeSection
    tabuleuse: Tabuleuse
    image_binaire: NouvelleImage
}

donne_image_visualisation_binaire :: fonc (visionneuse: *VisionneuseELF, onglet: *Onglet, données: []octet) -> NouvelleImage
{
    si onglet.image_binaire.desc.largeur == 0 {
        desc: DescriptriceImage
        desc.largeur = 256
        desc.hauteur = 256
        desc.format = FormatPixel.Gris_8
        desc.direction = DirectionImage.BasEnHaut

        taille_pixels := donne_taille_données(*desc)

        pixels := loge_tableau(*visionneuse.arène, taille_pixels comme n32, octet)
        tableau_remplis_avec(pixels, 0)

        onglet.image_binaire.desc = desc
        onglet.image_binaire.données = pixels.pointeur
        onglet.image_binaire.source_données = SourceDonnéesImage.Externe

        mémoire_temporaire := commence_mémoire_temporaire(*visionneuse.arène_transiente)
        diffère termine_mémoire_temporaire(mémoire_temporaire)

        compteurs := loge_tableau(*visionneuse.arène_transiente, taille_pixels comme n32, n32)
        tableau_remplis_avec(compteurs, 0)
        compteur_max : n32 = 0

        ptr_octet1 := données.pointeur
        ptr_octet2 := ptr_octet1 + 1

        pour données.taille - 1 {
            octet1 := mémoire(ptr_octet1) comme n32
            octet2 := mémoire(ptr_octet2) comme n32

            indice := octet1 + octet2 * 256

            compteurs[indice] += 1

            si compteurs[indice] > compteur_max {
                compteur_max = compteurs[indice]
            }

            ptr_octet1 += 1
            ptr_octet2 += 1
        }

        si compteur_max >= 1 {
            log_compteur_max := log(compteur_max comme r32)

            pour compteurs {
                si it >= 1 {
                    valeur := log(it comme r32) / log_compteur_max
                    // À FAIRE(langage) : permet de convertir r32 vers octet
                    pixels[indice_it] = (valeur * 255.0 + 0.5) comme n8 comme octet
                }
            }
        }
    }

    retourne onglet.image_binaire
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom VisionneuseELF
 * \{ */

DonnéesFichier :: struct {
    chemin: CheminFichier
    fichier: *FichierELF
    contenu: [..]octet

    onglets: [..]Onglet

    onglet_courant: z32
}

détruit_données :: fonc (fichier: *DonnéesFichier)
{
    déloge(fichier.contenu)

    pour * fichier.onglets {
        détruit_tabuleuse(*it.tabuleuse)
    }
    déloge(fichier.onglets)
}

donne_tabuleuse_informations :: fonc (fichier: *DonnéesFichier, fonte: *Fonte, tabuleuse: *Tabuleuse)
{
    entête := entête_fichier(fichier.fichier)

    si entête && tabuleuse.lignes.taille == 0 {
        initialise_tabuleuse(tabuleuse, "Nom", "Valeur")
        tabuleuse.alignements[0] = Alignement.GAUCHE
        tabuleuse.alignements[1] = Alignement.DROITE

        ajoute_ligne(tabuleuse, "Classe", entête.donne_classe_fichier())
        ajoute_ligne(tabuleuse, "Données", entête.donne_encodage_fichier())
        ajoute_ligne(tabuleuse, "Version", entête.donne_version_fichier())
        ajoute_ligne(tabuleuse, "OS/ABI", entête.donne_chaine_ABI())
        ajoute_ligne(tabuleuse, "Version ABI", entête.donne_version_ABI())
        ajoute_ligne(tabuleuse, "Type", entête.donne_type_fichier_objet())
        ajoute_ligne(tabuleuse, "Machine", entête.donne_chaine_architecture_cible())
        ajoute_ligne(tabuleuse, "Version Fichier", entête.donne_version_format_fichier_objet())
        ajoute_ligne(tabuleuse, "Adresse du point d'entrée", entête.donne_adresse_point_d_entrée())
        ajoute_ligne(tabuleuse, "Début des en-têtes de programme", entête.donne_début_entêtes_de_programme())
        ajoute_ligne(tabuleuse, "Début des en-têtes de section", entête.donne_début_entêtes_de_section())
        ajoute_ligne(tabuleuse, "Fanions", entête.donne_fanions_processeur())
        ajoute_ligne(tabuleuse, "Taille de cet en-tête", entête.donne_taille_entête())
        ajoute_ligne(tabuleuse, "Taille de l'en-tête du programme", entête.donne_taille_entête_programme())
        ajoute_ligne(tabuleuse, "Nombre d'en-tête du programme", entête.donne_nombre_entête_programme())
        ajoute_ligne(tabuleuse, "Taille des en-têtes de section", entête.donne_taille_entête_section())
        ajoute_ligne(tabuleuse, "Nombre d'en-tête de section", entête.donne_nombre_entête_section())
        ajoute_ligne(tabuleuse, "Table d'indice des chaînes d'en-tête de section", entête.donne_index_section_table_des_chaines())

        initialise_tailles_max_colonnes(tabuleuse, fonte)
    }
}
 
initialise_tailles_max_colonnes :: fonc (tabuleuse: *Tabuleuse, fonte: *Fonte)
{
    pour ligne dans tabuleuse.lignes {
        pour cellule, indice_cellule dans ligne.colonnes {
            taille_cellule := donne_largeur_texte(fonte, cellule.texte)

            si tabuleuse.tailles_max_colonnes[indice_cellule] < taille_cellule {
                tabuleuse.tailles_max_colonnes[indice_cellule] = taille_cellule
            }
        }
    }
}

VisionneuseELF :: struct {
    fichiers: [..]DonnéesFichier

    arène: ArèneMémoire
    arène_transiente: ArèneMémoire
    fichier_courant: z32

    peintre: *Peintre
    fonte: *Fonte
    fonte_mono: *Fonte
    emboiteuse: Emboiteuse
}

détruit_données :: fonc (visionneuse: *VisionneuseELF)
{
    pour * visionneuse.fichiers {
        détruit_données(it)
    }

    déloge(visionneuse.fichiers)
}

ouvre_fichier_elf :: fonc (visionneuse: *VisionneuseELF, chemin: CheminFichier)
{
    pour visionneuse.fichiers {
        si it.chemin.chn == chemin.chn {
            visionneuse.fichier_courant = (indice_it comme z32)
            retourne
        }
    }

    succès, contenu := contenu_fichier_binaire(chemin)
    saufsi succès {
        rapporte_erreur(visionneuse, "Impossible de lire le fichier")
        retourne
    }

    saufsi est_fichier_elf(contenu) {
        rapporte_erreur(visionneuse, "Pas un fichier ELF")
        retourne
    }

    fichier := loge(*visionneuse.arène, FichierELF)
    initialise_fichier_elf(fichier, contenu)

    visionneuse.fichier_courant = (visionneuse.fichiers.taille comme z32)

    données_fichier := tableau_ajoute_élément(*visionneuse.fichiers)
    données_fichier.chemin = copie_chemin(chemin)
    données_fichier.fichier = fichier
    données_fichier.contenu = contenu

    onglet := tableau_ajoute_élément(*données_fichier.onglets)
    onglet.nom = "Informations"

    onglet = tableau_ajoute_élément(*données_fichier.onglets)
    onglet.nom = "Entêtes Programme"

    onglet = tableau_ajoute_élément(*données_fichier.onglets)
    onglet.nom = "Sections"
}

rapporte_erreur :: fonc (visionneuse: *VisionneuseELF @inutilisée, format: chaine, args: ...eini)
{
    // À FAIRE : affiche l'erreur dans l'interface
    imprimeln(format, ...args)
} @Imprimeuse

supprime_fichier_à_l_indice :: fonc (visionneuse: *VisionneuseELF, indice: z32)
{
    fichier := *visionneuse.fichiers[indice]
    détruit_données(fichier)
    tableau_supprime_indice(*visionneuse.fichiers, indice)
}

donne_fichier_courant :: fonc (visionneuse: *VisionneuseELF) -> *DonnéesFichier
{
    retourne *visionneuse.fichiers[visionneuse.fichier_courant]
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Dessine fenêtre
 * \{ */

COULEUR_FOND := vers_couleur_rvba(CouleurRVBAN8(18, 18, 18, 255))
COULEUR_ARRIÈRE_PLAN := vers_couleur_rvba(CouleurRVBAN8(22, 22, 22, 255))
COULEUR_ITEM_ACTIVE := vers_couleur_rvba(CouleurRVBAN8(32, 32, 32, 255))
COULEUR_TEXTE := vers_couleur_rvba(CouleurRVBAN8(205, 170, 125, 255))
COULEUR_TEXTE_SURVOLÉ := vers_couleur_rvba(CouleurRVBAN8(125, 170, 205, 255))

config_texte_défaut: ConfigurationTexte
config_texte_mono: ConfigurationTexte

dessine_fenêtre :: fonc (empl visionneuse: *VisionneuseELF, largeur: z32, hauteur: z32)
{
    taille_canevas := Taille(largeur = Largeur(largeur), hauteur = Hauteur(hauteur))
    saufsi peintre {
        peintre = crée_peintre_igumi(taille_canevas)
    }

    peintre.définis_taille_canevas(taille_canevas)
    peintre.efface_cible_rendu()

    commandes := crée_interface(visionneuse, largeur, hauteur)
    dessine_commandes(peintre, *commandes)
}

crée_interface :: fonc (empl visionneuse: *VisionneuseELF, largeur: z32, hauteur: z32) -> CommandesDeRendu
{
    réinitialise(*arène_transiente)

    commence_disposition(*emboiteuse, largeur, hauteur)

    config_texte_défaut = ConfigurationTexte(fonte, COULEUR_TEXTE)
    config_texte_mono = ConfigurationTexte(fonte_mono, COULEUR_TEXTE)

    espace: EspaceDisponible = ---
    espace.largeur = largeur comme n32
    espace.hauteur = hauteur comme n32

    dispose_rectangle()
    {
        définis_arrière_plan(COULEUR_ARRIÈRE_PLAN)

        si fichiers.taille == 0 {
            définis_disposition(cotation = Cotation(CROISSANTE(), CROISSANTE()), alignement_horizontal = AlignementEnfant.Milieu, alignement_vertical = AlignementEnfant.Milieu)
            dispose_texte("Glissez-déposez un ou plusieurs fichiers pour les ouvrir", config_texte_défaut)
        }
        sinon {
            définis_cotation(Cotation(CROISSANTE(), CROISSANTE()))
            définis_direction(Direction.Horizontale)

            espace_liste_fichiers := espace
            espace_liste_fichiers.largeur = 300

            // À FAIRE : barre de défilement
            // À FAIRE : permet de redimensionner
            // À FAIRE : affichage du chemin complet
            dispose_rectangle()
            {
                définis_cotation(donne_cotation(espace_liste_fichiers))
                définis_arrière_plan(COULEUR_ARRIÈRE_PLAN)
                définis_direction(Direction.Verticale)
                ajoute_bordure_droite(2.0, COULEUR_FOND)

                métriques := donne_métriques_fonte(config_texte_défaut.fonte)
                hauteur_de_ligne := métriques.donne_hauteur_ligne() comme z32
                rembourrage := 8
                hauteur_de_ligne += rembourrage * 2

                dispose_rectangle()
                {
                    définis_cotation(CROISSANTE(), FIXE(hauteur_de_ligne))
                    définis_rembourrage(RembourrageDifforme(rembourrage comme r32, rembourrage comme r32))
                    ajoute_bordure_bas(2.0, COULEUR_FOND)

                    texte := si visionneuse.fichiers.taille > 1 {
                        "Fichiers ouverts"
                    }
                    sinon {
                        "Fichier ouvert"
                    }

                    dispose_texte(texte, config_texte_défaut)
                }
                termine_rectangle()

                pour visionneuse.fichiers {
                    dispose_rectangle()
                    {
                        définis_cotation(CROISSANTE(), FIXE(hauteur_de_ligne))
                        définis_rembourrage(RembourrageDifforme(rembourrage comme r32, rembourrage comme r32))
                        ajoute_bordure_bas(2.0, COULEUR_FOND)

                        si indice_it == visionneuse.fichier_courant {
                            définis_arrière_plan(COULEUR_ITEM_ACTIVE)
                        }

                        sur_pression_souris(définis_fichier_courant, visionneuse, indice_it comme z32)

                        nom := nom_fichier_avec_extension(it.chemin)
                        dispose_texte(nom, config_texte_défaut)
                    }
                    termine_rectangle()
                }
            }
            termine_rectangle()

            espace.largeur = soustraction_sure(espace.largeur, espace_liste_fichiers.largeur)
            dessine_panneau_fichier(visionneuse, espace)
        }
    }
    termine_rectangle()

    retourne termine_disposition(*emboiteuse)
}

définis_fichier_courant :: fonc (vionneuse: *VisionneuseELF, souris: ClicSouris, id: n64 @inutilisée, indice_fichier: z32) -> ÉtatÉvènement
{
    résultat := ÉtatÉvènement.PASSE_AU_PARENT
    si souris.bouton == BoutonSouris.PRIMAIRE {
        si indice_fichier >= 0 && indice_fichier < vionneuse.fichiers.taille {
            vionneuse.fichier_courant = indice_fichier
            résultat = ÉtatÉvènement.CONSOMMÉ
        }
    }
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom PanneauFichier
 * \{ */

dessine_panneau_fichier :: fonc (visionneuse: *VisionneuseELF, espace: EspaceDisponible)
{
    config_texte := config_texte_défaut
    fonte := config_texte.fonte

    métriques := donne_métriques_fonte(fonte)
    hauteur_de_ligne := métriques.donne_hauteur_ligne() comme z32
    rembourrage := 8
    hauteur_de_ligne += rembourrage * 2

    fichier := donne_fichier_courant(visionneuse)

    dispose_rectangle()
    {
        définis_disposition(cotation = Cotation(CROISSANTE(), CROISSANTE()), direction = Direction.Verticale)

        dispose_rectangle()
        {
            définis_disposition(cotation = Cotation(CROISSANTE(), FIXE(hauteur_de_ligne)), direction = Direction.Horizontale)
            définis_arrière_plan(COULEUR_FOND)

            espace = enlève_hauteur(espace, hauteur_de_ligne comme n32)

            pour fichier.onglets {
                dispose_entête_panneau(fichier, it.nom, indice_it comme z32)
            }
        }
        termine_rectangle()

        onglet := *fichier.onglets[fichier.onglet_courant]

        dispose_rectangle()
        {
            définis_cotation(CROISSANTE(), CROISSANTE())
            espace = ajoute_rembourage(espace, rembourrage)

            si onglet.nom == "Informations" {
                définis_alignement(AlignementEnfant.Milieu)
                dessine_panneau_informations(visionneuse, fichier, onglet, espace)
            }
            sinon si onglet.nom == "Sections" {
                dessine_panneau_sections(visionneuse, fichier, onglet, espace)
            }
            sinon si onglet.nom == "Entêtes Programme" {
                dessine_panneau_entêtes_programme(visionneuse, fichier, onglet, espace)
            }
            sinon {
                dessine_onglet_section(visionneuse, fichier, onglet, espace)
            }
        }
        termine_rectangle()
    }
    termine_rectangle()
}

dispose_entête_panneau :: fonc (fichier: *DonnéesFichier, texte: chaine, indice: z32)
{
    config_texte := config_texte_défaut
    fonte := config_texte.fonte

    métriques := donne_métriques_fonte(fonte)
    hauteur_de_ligne := métriques.donne_hauteur_ligne() comme z32
    rembourrage := 8
    hauteur_de_ligne += rembourrage * 2

    dispose_rectangle()
    {
        largeur_texte := donne_largeur_texte(fonte, texte) comme z32
        définis_disposition(cotation = Cotation(FIXE(largeur_texte + rembourrage * 4), FIXE(hauteur_de_ligne)),
                            alignement_horizontal = AlignementEnfant.Milieu,
                            alignement_vertical = AlignementEnfant.Milieu)

        sur_pression_souris(définis_panneau_courant, fichier, indice)

        si fichier.onglet_courant == indice {
            définis_arrière_plan(COULEUR_ARRIÈRE_PLAN)
        }

        dispose_texte(texte, config_texte)
    }
    termine_rectangle()
}

définis_panneau_courant :: fonc (fichier: *DonnéesFichier, souris: ClicSouris, id: n64 @inutilisée, indice_panneau: z32) -> ÉtatÉvènement
{
    résultat := ÉtatÉvènement.PASSE_AU_PARENT
    si souris.bouton == BoutonSouris.PRIMAIRE {
        si indice_panneau >= 0 && indice_panneau < fichier.onglets.taille {
            fichier.onglet_courant = indice_panneau
            résultat = ÉtatÉvènement.CONSOMMÉ
        }
    }
    retourne résultat
}

/** } */

/* ------------------------------------------------------------------------- */
/** \name PanneauInformation
 * \{ */

dessine_panneau_informations :: fonc (visionneuse: *VisionneuseELF, fichier: *DonnéesFichier, onglet: *Onglet, espace: EspaceDisponible)
{
    donne_tabuleuse_informations(fichier, visionneuse.fonte, *onglet.tabuleuse)
    dessine_tabuleuse(visionneuse, *onglet.tabuleuse, faux, config_texte_défaut, espace, 0)
}

dessine_tabuleuse :: fonc (visionneuse: *VisionneuseELF, tabuleuse: *Tabuleuse, dessine_titres: bool, config_texte: ConfigurationTexte, espace: EspaceDisponible, décalage: r32)
{
    fonte := config_texte.fonte

    métriques := donne_métriques_fonte(fonte)
    hauteur_de_ligne := métriques.donne_hauteur_ligne()
    rembourrage := 8.0
    hauteur_de_ligne += rembourrage

    nombre_de_lignes_visibles := ((espace.hauteur comme r32) / hauteur_de_ligne) comme n32 + 2
    lignes: []LigneTabuleuse = tabuleuse.lignes
    saufsi dessine_titres {
        lignes = tableau_avance(lignes, 1)
    }
    nombre_de_lignes_visibles = min(nombre_de_lignes_visibles, lignes.taille comme n32)

    première_ligne_visible := (décalage / hauteur_de_ligne) comme n32
    dernière_ligne_visible := première_ligne_visible + nombre_de_lignes_visibles
    si dernière_ligne_visible > lignes.taille comme n32 {
        dernière_ligne_visible = lignes.taille comme n32
    }

    lignes_visibles: []LigneTabuleuse
    lignes_visibles.pointeur = lignes.pointeur + première_ligne_visible
    lignes_visibles.taille = (dernière_ligne_visible - première_ligne_visible) comme z64

    espace_avant_première_ligne := hauteur_de_ligne * première_ligne_visible comme r32
    espace_après_dernière_ligne := hauteur_de_ligne * (lignes.taille - dernière_ligne_visible comme z64) comme r32

    dispose_rectangle()
    {
        définis_disposition(direction = Direction.Verticale)

        si espace_avant_première_ligne > 0.0 {
            dispose_rectangle()
            {
                définis_cotation(CROISSANTE(), FIXE(espace_avant_première_ligne))
            }
            termine_rectangle()
        }

        pour * lignes_visibles {
            est_ligne_titre := dessine_titres && indice_it == 0 && première_ligne_visible == 0
            dessine_ligne_tabuleuse(visionneuse, tabuleuse, it, est_ligne_titre, config_texte)
        }

        si espace_après_dernière_ligne > 0.0 {
            dispose_rectangle()
            {
                définis_cotation(CROISSANTE(), FIXE(espace_après_dernière_ligne))
            }
            termine_rectangle()
        }
    }
    termine_rectangle()
}

InfoCommande :: struct {
    visionneuse: *VisionneuseELF
    commande: chaine
    métadonnée: chaine
}

dessine_ligne_tabuleuse :: fonc (visionneuse: *VisionneuseELF, tabuleuse: *Tabuleuse, ligne: *LigneTabuleuse, est_ligne_titre: bool, config_texte: ConfigurationTexte)
{
    fonte := config_texte.fonte

    métriques := donne_métriques_fonte(fonte)
    hauteur_de_ligne := métriques.donne_hauteur_ligne()
    rembourrage := 8.0
    hauteur_de_ligne += rembourrage

    dispose_rectangle()
    {
        définis_disposition(direction = Direction.Horizontale)
        
        pour ligne.colonnes {
            largeur_colonne := tabuleuse.tailles_max_colonnes[indice_it]
            largeur_colonne += rembourrage * 2.0
            alignement_colonne := tabuleuse.alignements[indice_it]

            dispose_rectangle()
            {
                définis_disposition(cotation = Cotation(FIXE(largeur_colonne), FIXE(hauteur_de_ligne)))
                définis_alignement_horizontal(alignement_colonne)
                définis_rembourrage(RembourrageDifforme(rembourrage, rembourrage * 0.5))

                si indice_it > 0 {
                    ajoute_bordure_gauche(1.0, config_texte.couleur)
                }

                si est_ligne_titre {
                    ajoute_bordure_bas(1.0, config_texte.couleur)
                }

                config := config_texte
                config.drapeaux.SANS_FRAGMENTS = vrai

                si it.commande {
                    si est_survolée() {
                        config.couleur = COULEUR_TEXTE_SURVOLÉ
                        définis_curseur(TypeCurseurSystème.MAIN_POINTANT)
                    }

                    info_commande := loge(*visionneuse.arène_transiente, InfoCommande)
                    info_commande.visionneuse = visionneuse
                    info_commande.commande = it.commande
                    info_commande.métadonnée = it.métadonnée

                    sur_pression_souris(sur_pression_entête_section, info_commande, 0)
                }

                dispose_texte(it.texte, config)
            }
            termine_rectangle()
        }
    }
    termine_rectangle()
}

sur_pression_entête_section :: fonc (empl info: *InfoCommande, clic: ClicSouris, id: n64 @inutilisée, indice: z32 @inutilisée) -> ÉtatÉvènement
{
    résultat := ÉtatÉvènement.PASSE_AU_PARENT

    si clic.bouton == BoutonSouris.PRIMAIRE {
        si commande == "affiche_données_section" {
            fichier := donne_fichier_courant(visionneuse)
            pour fichier.onglets {
                si it.nom == métadonnée {
                    fichier.onglet_courant = indice_it comme z32
                    arrête
                }
            }
            sansarrêt {
                onglet := tableau_ajoute_élément(*fichier.onglets)
                onglet.nom = métadonnée
                section := trouve_section(fichier.fichier, onglet.nom)
                onglet.type_section = donne_type_section(section)
                fichier.onglet_courant = fichier.onglets.taille comme z32 - 1
            }
        }
        sinon {
            // À FAIRE : interface pour les erreurs
            imprimeln("Commande inconnue : %", commande)
        }

        résultat = ÉtatÉvènement.CONSOMMÉ
    }

    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \name Entêtes de programme
 * \{ */

dessine_panneau_entêtes_programme :: fonc (visionneuse: *VisionneuseELF, fichier: *DonnéesFichier, onglet: *Onglet, espace: EspaceDisponible)
{
    donne_tabuleuse_entêtes_programme(fichier, visionneuse.fonte, *onglet.tabuleuse)

    _, barre := dispose_rectangle_défilable(espace, COULEUR_FOND)
    {
        dessine_tabuleuse(visionneuse, *onglet.tabuleuse, vrai, config_texte_défaut, espace, barre.défilage)
    }
    termine_rectangle_défilable()
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \name PanneauVueTables
 * \{ */

dessine_panneau_sections :: fonc (visionneuse: *VisionneuseELF, fichier: *DonnéesFichier, onglet: *Onglet, espace: EspaceDisponible)
{
    donne_tabuleuse_sections(fichier, visionneuse.fonte, *onglet.tabuleuse)

    _, barre := dispose_rectangle_défilable(espace, COULEUR_FOND)
    {
        dessine_tabuleuse(visionneuse, *onglet.tabuleuse, vrai, config_texte_défaut, espace, barre.défilage)
    }
    termine_rectangle_défilable()
}

dessine_onglet_section :: fonc (visionneuse: *VisionneuseELF, fichier: *DonnéesFichier, onglet: *Onglet, espace: EspaceDisponible)
{
    config_texte := config_texte_défaut
    données_hex := faux

    si onglet.type_section == SHT_SYMTAB || onglet.type_section == SHT_DYNSYM {
        donne_tabuleuse_symboles(fichier, visionneuse.fonte, *onglet.tabuleuse, onglet.nom)
    }
    sinon si onglet.type_section == TypeSection.BitsProgramme {
        si onglet.nom == ".comment" {
            donne_tabuleuse_comment(fichier, visionneuse.fonte, *onglet.tabuleuse)
        }
        sinon si onglet.nom == ".rodata" {
            donne_tabuleuse_données_hex(fichier, visionneuse.fonte_mono, *onglet.tabuleuse, ".rodata")
            config_texte = config_texte_mono
            données_hex = vrai
        }
        sinon si onglet.nom == ".eh_frame" {
            donne_tabuleuse_eh_frame(fichier, visionneuse.fonte_mono, *onglet.tabuleuse)
            config_texte = config_texte_mono
        }
        sinon si onglet.nom == ".debug_info" {
            donne_tabuleuse_debug_info(fichier, visionneuse.fonte_mono, *onglet.tabuleuse)
            config_texte = config_texte_mono
        }
        sinon si onglet.nom == ".debug_abbrev" {
            donne_tabuleuse_debug_abbrev(fichier, visionneuse.fonte_mono, *onglet.tabuleuse)
            config_texte = config_texte_mono
        }
        sinon si onglet.nom == ".debug_aranges" {
            donne_tabuleuse_debug_aranges(fichier, visionneuse.fonte_mono, *onglet.tabuleuse)
            config_texte = config_texte_mono
        }
        sinon si onglet.nom == ".debug_rnglists" {
            donne_tabuleuse_debug_rnglists(fichier, visionneuse.fonte_mono, *onglet.tabuleuse)
            config_texte = config_texte_mono
        }
        sinon si onglet.nom == ".debug_line" {
            donne_tabuleuse_debug_line(fichier, visionneuse.fonte_mono, *onglet.tabuleuse)
            config_texte = config_texte_mono
        }
        sinon si onglet.nom == ".debug_loclists" {
            donne_tabuleuse_debug_loclists(fichier, visionneuse.fonte_mono, *onglet.tabuleuse)
            config_texte = config_texte_mono
        }
        sinon si onglet.nom == ".debug_str" {
            donne_tabuleuse_table_chaines(fichier, visionneuse.fonte, *onglet.tabuleuse, onglet.nom)
        }
        sinon si onglet.nom == ".debug_line_str" {
            donne_tabuleuse_table_chaines(fichier, visionneuse.fonte, *onglet.tabuleuse, onglet.nom)
        }
        sinon {
            donne_tabuleuse_données_hex(fichier, visionneuse.fonte_mono, *onglet.tabuleuse, onglet.nom)
            config_texte = config_texte_mono
            données_hex = vrai
        }
    }
    sinon si onglet.type_section == TypeSection.Dynamique {
        donne_tabuleuse_dynamic(fichier, visionneuse.fonte, *onglet.tabuleuse)
    }
    sinon si onglet.type_section == TypeSection.Note {
        donne_tabuleuse_note(fichier, visionneuse.fonte, *onglet.tabuleuse, onglet.nom)
    }
    sinon si onglet.type_section == TypeSection.TableChaine {
        donne_tabuleuse_table_chaines(fichier, visionneuse.fonte, *onglet.tabuleuse, onglet.nom)
    }
    sinon si onglet.type_section == TypeSection.Rel {
        donne_tabuleuse_rel(fichier, visionneuse.fonte, *onglet.tabuleuse, onglet.nom)
    }
    sinon si onglet.type_section == TypeSection.Rela {
        donne_tabuleuse_rela(fichier, visionneuse.fonte, *onglet.tabuleuse, onglet.nom)
    }
    sinon {
        donne_tabuleuse_données_hex(fichier, visionneuse.fonte_mono, *onglet.tabuleuse, onglet.nom)
        config_texte = config_texte_mono
        données_hex = vrai
    }

    dispose_rectangle()
    {
        définis_direction(Direction.Horizontale)

        si données_hex {
            espace.largeur = soustraction_sure(espace.largeur, 300)
        }

        _, barre := dispose_rectangle_défilable(espace, COULEUR_FOND)
        {
            dessine_tabuleuse(visionneuse, *onglet.tabuleuse, vrai, config_texte, espace, barre.défilage)
        }
        termine_rectangle_défilable()

        si données_hex {
            espace.largeur = 300

            dispose_rectangle()
            {
                espace = ajoute_rembourage(espace, 8)
                définis_cotation(donne_cotation(espace))
                ajoute_bordure_gauche(2.0, COULEUR_FOND)
                définis_direction(Direction.Verticale)

                image_binaire: NouvelleImage

                entête := entête_fichier(fichier.fichier)
                si entête {
                    section := trouve_section(fichier.fichier, onglet.nom)

                    si section {
                        données := donne_données_section(fichier.fichier, section)
                        image_binaire = donne_image_visualisation_binaire(visionneuse, onglet, données)
                    }
                }

                dispose_texte("Visualisation binaire", config_texte_défaut)

                dispose_rectangle()
                {
                    définis_cotation(FIXE(espace.largeur), FIXE(284))
                    définis_alignement(Alignement.Milieu)
                    dispose_image(image_binaire, Cotation(FIXE(256), FIXE(256)))
                }
                termine_rectangle()
            }
            termine_rectangle()
        }
    }
    termine_rectangle()
}

/* ------------------------------------------------------------------------- */
/** \name Liste de toutes les entêtes de programme.
 * \{ */

donne_tabuleuse_entêtes_programme :: fonc (fichier: *DonnéesFichier, fonte: *Fonte, tabuleuse: *Tabuleuse)
{
    entêtes_programme := donne_entêtes_de_programme(fichier.fichier);

    si entêtes_programme && tabuleuse.lignes.taille == 0 {
        initialise_tabuleuse(tabuleuse, "Type", "Drapeaux", "Décalage", "Adr. Virtuelle", "Adr. Physique", "Taille Fichier", "Taille Mémoire", "Alignement")

        pour entêtes_programme {
            type := donne_chaine_pour_type_entête_programme(it.p_type);
            flags := donne_chaine_pour_drapeaux_entête_programme(it.p_flags);

            ajoute_ligne(tabuleuse,
                         type,
                         flags,
                         it.p_offset,
                         it.p_vaddr,
                         it.p_paddr,
                         it.p_filesz,
                         it.p_memsz,
                         it.p_align);
        }

        initialise_tailles_max_colonnes(tabuleuse, fonte);
    }
}

donne_chaine_pour_type_entête_programme :: fonc (type: Elf32_Word) -> chaine
{
    si type == PT_NULL { retourne "NULL" }
    si type == PT_LOAD { retourne "LOAD" }
    si type == PT_DYNAMIC { retourne "DYNAMIC" }
    si type == PT_INTERP { retourne "INTERP" }
    si type == PT_NOTE { retourne "NOTE" }
    si type == PT_SHLIB { retourne "SHLIB" }
    si type == PT_PHDR { retourne "PHDR" }
    si type == PT_TLS { retourne "TLS" }
    si type == PT_NUM { retourne "NUM" }
    si type == PT_LOOS { retourne "LOOS" }
    si type == PT_GNU_EH_FRAME { retourne "GNU_EH_FRAME" }
    si type == PT_GNU_STACK { retourne "GNU_STACK" }
    si type == PT_GNU_RELRO { retourne "GNU_RELRO" }
    si type == PT_GNU_PROPERTY { retourne "GNU_PROPERTY" }
    si type == PT_LOSUNW { retourne "LOSUNW" }
    si type == PT_SUNWBSS { retourne "SUNWBSS" }
    si type == PT_SUNWSTACK { retourne "SUNWSTACK" }
    si type == PT_HISUNW { retourne "HISUNW" }
    si type == PT_HIOS { retourne "HIOS" }
    si type == PT_LOPROC { retourne "LOPROC" }
    si type == PT_HIPROC { retourne "HIPROC" }

    retourne "INVALIDE"
}

donne_chaine_pour_drapeaux_entête_programme :: fonc (flag: Elf32_Word) -> chaine
{
    drapeaux := [
        "",
        "X",
        "W",
        "W | X",
        "R",
        "R | X",
        "R | W",
        "R | W | X",
    ];

    retourne drapeaux[flag & 0x7];
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \name Liste de toutes les sections.
 * \{ */

donne_tabuleuse_sections :: fonc (fichier: *DonnéesFichier, fonte: *Fonte, tabuleuse: *Tabuleuse)
{
    entête := entête_fichier(fichier.fichier)
    // nom = "Sections"

    si entête && tabuleuse.lignes.taille == 0 {
        initialise_tabuleuse(tabuleuse, "Nom", "Lien", "Adresse", "Décalage", "Taille", "Alignement", "Type", "Drapeaux")

        succès_table_symbole, table_symbole := donne_string_table(fichier.fichier, entête.e_shstrndx)
        saufsi succès_table_symbole {
            // À FAIRE : erreur
            retourne
        }

        indice_ligne : z64 = 1

        noms_entêtes: [..]chaine
        diffère déloge(noms_entêtes)

        nombre_de_sections := donne_nombre_de_sections(fichier.fichier) comme Elf64_Word
        pour nombre_de_sections {
            entête_section := donne_entête_section(fichier.fichier, indice_it)
            saufsi entête_section {
                // À FAIRE : erreur
                arrête
            }
            nom_section := donne_chaine(table_symbole, entête_section.sh_name)
            tableau_ajoute(*noms_entêtes, nom_section)
        }

        indices_entêtes: [..]n32
        diffère déloge(indices_entêtes)
        tableau_redimensionne(indices_entêtes, noms_entêtes.taille)
        tableau_iota(indices_entêtes, 0)

        tri_rapide(indices_entêtes, noms_entêtes, compare_chaine)

        pour indices_entêtes {
            entête_section := donne_entête_section(fichier.fichier, it)
            assert(entête_section != nul)
            nom_section := donne_chaine(table_symbole, entête_section.sh_name)

            si nom_section == "" {
                continue
            }

            nom_section_liée := "";
            entête_section_liée: *Elf64_Shdr;
            si entête_section.sh_link != 0 {
                entête_section_liée = donne_entête_section(fichier.fichier, entête_section.sh_link);
                si entête_section_liée {
                    nom_section_liée = donne_chaine(table_symbole, entête_section_liée.sh_name);
                }
                sinon {
                    // À FAIRE : erreur
                }
            }

            ajoute_ligne(tabuleuse,
                         nom_section,
                         nom_section_liée,
                         entête_section.sh_addr,
                         entête_section.sh_offset,
                         entête_section.sh_size,
                         entête_section.sh_addralign,
                         entête_section.sh_type,
                         entête_section.donne_drapeaux())

            si entête_section.sh_size != 0 && donne_type_section(entête_section) != TypeSection.AucunBits {
                définis_commande(tabuleuse, indice_ligne, 0, "affiche_données_section", nom_section)
            }

            si entête_section_liée && entête_section_liée.sh_size != 0 && donne_type_section(entête_section_liée) != TypeSection.AucunBits {
                définis_commande(tabuleuse, indice_ligne, 1, "affiche_données_section", nom_section_liée)
            }

            indice_ligne += 1
        }

        initialise_tailles_max_colonnes(tabuleuse, fonte)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \name Table Symboles.
 * \{ */

donne_tabuleuse_symboles :: fonc (fichier: *DonnéesFichier, fonte: *Fonte, tabuleuse: *Tabuleuse, nom_section: chaine)
{
    entête := entête_fichier(fichier.fichier);

    si entête && tabuleuse.lignes.taille == 0 {
        initialise_tabuleuse(tabuleuse, "Valeur", "Taille", "Type", "Lien", "Visibilité", "Section", "Nom")

        succès_table, table := donne_symbol_table(fichier.fichier, nom_section);
        saufsi succès_table {
            retourne;
        }

        succès_table_nom_section, table_nom_section := donne_string_table(fichier.fichier, entête.e_shstrndx);
        saufsi succès_table_nom_section {
            // À FAIRE : erreur
            retourne;
        }

        pour * table.symboles {
            nom_section_symbole := donne_nom_section_symbole(*table, it);
            nom_symbole := donne_chaine(table.string_table, it.st_name);
            ajoute_ligne(tabuleuse,
                         it.st_value,
                         it.st_size,
                         it.donne_type(),
                         it.donne_liaison(),
                         it.donne_visibilité(),
                         nom_section_symbole,
                         nom_symbole);
        }

        initialise_tailles_max_colonnes(tabuleuse, fonte)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \name Table Comment.
 * \{ */

donne_tabuleuse_comment :: fonc (fichier: *DonnéesFichier, fonte: *Fonte, tabuleuse: *Tabuleuse)
{
    entête := entête_fichier(fichier.fichier)

    si entête && tabuleuse.lignes.taille == 0 {
        section := trouve_section(fichier.fichier, ".comment")
        si section && (section.sh_flags & DrapeauxSection.STRINGS comme n64) != 0 {
            initialise_tabuleuse(tabuleuse, "Valeur")

            données_section := donne_données_section(fichier.fichier, section)
            chn_données := chaine(données_section.pointeur comme *z8, données_section.taille)

            chns := divise(chn_données, '\0')
            diffère déloge(chns)

            pour chns {
                ajoute_ligne(tabuleuse, it)
            }

            initialise_tailles_max_colonnes(tabuleuse, fonte)
        }
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \name Table Dynamic.
 * \{ */

donne_tabuleuse_dynamic :: fonc (fichier: *DonnéesFichier, fonte: *Fonte, tabuleuse: *Tabuleuse)
{
    entête := entête_fichier(fichier.fichier)

    si entête && tabuleuse.lignes.taille == 0 {
        entrées := donne_entrées_section_dynamic(fichier.fichier)
        initialise_tabuleuse(tabuleuse, "Tag", "Valeur")

        pour entrées {
            nom_tag := donne_chaine_pour_dynamic_tag(it.d_tag)
            valeur_entrée: chaine

            si doit_utiliser_valeur(it) {
                valeur_entrée = imprime_chaine_temp("%", it.d_un.d_val)
            }
            sinon {
                ctx := contexte()
                ctx.format_entier.base = 16
                pousse_contexte ctx {
                    valeur_entrée = imprime_chaine_temp("0x%", it.d_un.d_ptr)
                }
            }

            ajoute_ligne(tabuleuse, nom_tag, valeur_entrée)
        }

        initialise_tailles_max_colonnes(tabuleuse, fonte)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \name Table .note*
 * \{ */

donne_tabuleuse_note :: fonc (fichier: *DonnéesFichier, fonte: *Fonte, tabuleuse: *Tabuleuse, nom_section: chaine)
{
    entête := entête_fichier(fichier.fichier)

    si entête && tabuleuse.lignes.taille == 0 {
        section := trouve_section(fichier.fichier, nom_section)

        si section {
            données := donne_données_section(fichier.fichier, section)

            initialise_tabuleuse(tabuleuse, "Nom", "Description", "Type")

            curseur := données.pointeur

            tantque curseur < (données.pointeur + données.taille) {
                note := curseur comme *Elf64_Nhdr
                curseur += taille_de(Elf64_Nhdr)

                nom := chaine(curseur comme *z8, note.n_namesz)
                curseur += donne_taille_alignée(note.n_namesz comme z64, 4)
                si nom.taille != 0 && nom[nom.taille - 1] == '\0' {
                    nom.taille -= 1
                }

                desc := chaine(curseur comme *z8, note.n_descsz)
                curseur += donne_taille_alignée(note.n_descsz comme z64, 4)

                si note.n_type == NT_GNU_BUILD_ID {
                    condensat: Condensat
                    condensat.données.pointeur = desc.pointeur
                    condensat.données.taille = desc.taille

                    desc = donne_chaine_hex(condensat)
                }
                sinon si note.n_type == NT_GNU_PROPERTY_TYPE_0 {
                    enchaineuse: Enchaineuse
                    initialise_enchaineuse(*enchaineuse)

                    mots: []n32
                    mots.pointeur = desc.pointeur comme *n32
                    mots.taille = 4

                    si mots[0] == GNU_PROPERTY_X86_ISA_1_USED {
                        desc = "À FAIRE : GNU_PROPERTY_X86_ISA_1_USED"
                    }
                    sinon si mots[0] == GNU_PROPERTY_X86_ISA_1_NEEDED {
                        desc = "À FAIRE : GNU_PROPERTY_X86_ISA_1_NEEDED"
                    }
                    sinon si mots[0] == GNU_PROPERTY_X86_FEATURE_1_AND {
                        ajoute_au_tampon(*enchaineuse, "X86 Features: ")

                        si mots.taille > 1 {
                            si (mots[1] & GNU_PROPERTY_X86_ISA_1_V4) != 0 {
                                ajoute_au_tampon(*enchaineuse, "ISA V4")
                            }
                            sinon si (mots[1] & GNU_PROPERTY_X86_ISA_1_V3) != 0 {
                                ajoute_au_tampon(*enchaineuse, "ISA V4")
                            }
                            sinon si (mots[1] & GNU_PROPERTY_X86_ISA_1_V2) != 0 {
                                ajoute_au_tampon(*enchaineuse, "ISA V2")
                            }
                            sinon si (mots[1] & GNU_PROPERTY_X86_ISA_1_BASELINE) != 0 {
                                ajoute_au_tampon(*enchaineuse, "ISA BASELINE")
                            }
                        }

                        si mots.taille > 2 {
                            si (mots[2] & GNU_PROPERTY_X86_FEATURE_1_IBT) != 0 {
                                ajoute_au_tampon(*enchaineuse, ", IBT")
                            }
                            si (mots[2] & GNU_PROPERTY_X86_FEATURE_1_SHSTK) != 0 {
                                ajoute_au_tampon(*enchaineuse, ", SHSTK")
                            }
                        }

                        desc = chaine_depuis_enchaineuse(*enchaineuse)
                    }
                }

                ajoute_ligne(tabuleuse, nom, desc, donne_chaine_pour_note_type(note.n_type))
            }

            initialise_tailles_max_colonnes(tabuleuse, fonte)
        }
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \name Table pour .rodata et les sections non-traitées spécifiquement.
 * \{ */

donne_tabuleuse_données_hex :: fonc (fichier: *DonnéesFichier, fonte: *Fonte, tabuleuse: *Tabuleuse, nom_section: chaine)
{
    entête := entête_fichier(fichier.fichier)

    si entête && tabuleuse.lignes.taille == 0 {
        section := trouve_section(fichier.fichier, nom_section)

        si section {
            données := donne_données_section(fichier.fichier, section)

            initialise_tabuleuse(tabuleuse, "Décalage", "Données", "Texte")
            tabuleuse.alignements[0] = Alignement.Fin

            curseur := données.pointeur
            début := curseur
            fin := (données.pointeur + données.taille)

            hex_depuis_char :: fonc (hex: z8) -> z8
            {
                retourne "0123456789ABCDEF"[hex]
            }

            tantque curseur < fin {
                décalage := curseur - début

                taille_sure : z64 = 16
                si décalage + taille_sure > données.taille {
                    taille_sure = données.taille - décalage
                }

                tampon_texte_données: TamponFixe(z8, 16 * 2 + 15 + 3)
                texte := loge_chaine(taille_sure)

                pour taille_sure {
                    valeur := curseur[indice_it] comme z8

                    si 31 <= valeur comme n8 <= 127 {
                        texte[indice_it] = valeur
                    }
                    sinon {
                        texte[indice_it] = '.'
                    }

                    ajoute(*tampon_texte_données, hex_depuis_char(((valeur >> 4) & 0x0F)))
                    ajoute(*tampon_texte_données, hex_depuis_char(((valeur >> 0) & 0x0F)))

                    si indice_it < taille_sure - 1 {
                        si indice_it % 4 == 3 {
                            ajoute(*tampon_texte_données, ' ')
                        }
                        ajoute(*tampon_texte_données, ' ')
                    }
                }

                texte_données: chaine
                texte_données.pointeur = *tampon_texte_données.données[0]
                texte_données.taille = tampon_texte_données.curseur

                ajoute_ligne(tabuleuse, décalage, copie_chaine(texte_données), texte)
                curseur += taille_sure
            }

            initialise_tailles_max_colonnes(tabuleuse, fonte)
        }
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \name Table .strtab/.shstrtab
 * \{ */

donne_tabuleuse_table_chaines :: fonc (fichier: *DonnéesFichier, fonte: *Fonte, tabuleuse: *Tabuleuse, nom_section: chaine)
{
    entête := entête_fichier(fichier.fichier)

    si entête && tabuleuse.lignes.taille == 0 {
        section := trouve_section(fichier.fichier, nom_section)

        si section {
            données := donne_données_section(fichier.fichier, section)

            initialise_tabuleuse(tabuleuse, "Texte")

            texte := chaine(données.pointeur comme *z8, données.taille)

            chaines := divise(texte, '\0')
            diffère déloge(chaines)

            pour chaines {
                ajoute_ligne(tabuleuse, it)
            }

            initialise_tailles_max_colonnes(tabuleuse, fonte)
        }
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \name Table .rel
 * \{ */

donne_tabuleuse_rel :: fonc (fichier: *DonnéesFichier, fonte: *Fonte, tabuleuse: *Tabuleuse, nom_section: chaine)
{
    entête := entête_fichier(fichier.fichier)

    si entête && tabuleuse.lignes.taille == 0 {
        section := trouve_section(fichier.fichier, nom_section);
        si section {
            succès_table, table := donne_symbol_table(fichier.fichier, section.sh_link);
            si succès_table {
                relas := donne_données_section(fichier.fichier, section, Elf64_Rel);

                initialise_tabuleuse(tabuleuse, "Décalage", "Type", "Symbole");

                pour relas {
                    type := ELF64_R_TYPE(it.r_info);
                    indice_symbole := ELF64_R_SYM(it.r_info);

                    symbole := donne_symbole(*table, indice_symbole);
                    nom_symbole := donne_nom_symbole(*table, symbole);

                    ajoute_ligne(tabuleuse, it.r_offset, type, nom_symbole);
                }

                initialise_tailles_max_colonnes(tabuleuse, fonte);
            }
        }
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \name Table .rela
 * \{ */

donne_tabuleuse_rela :: fonc (fichier: *DonnéesFichier, fonte: *Fonte, tabuleuse: *Tabuleuse, nom_section: chaine)
{
    entête := entête_fichier(fichier.fichier)

    si entête && tabuleuse.lignes.taille == 0 {
        section := trouve_section(fichier.fichier, nom_section);
        si section {
            succès_table, table := donne_symbol_table(fichier.fichier, section.sh_link);
            si succès_table {
                relas := donne_données_section(fichier.fichier, section, Elf64_Rela);

                initialise_tabuleuse(tabuleuse, "Décalage", "Type", "Symbole", "Indice Sym.", "Section Sym.", "Addende");

                pour relas {
                    type := ELF64_R_TYPE(it.r_info);
                    indice_symbole := ELF64_R_SYM(it.r_info);

                    chn_type := donne_chaine_pour_réadressage_x86_64(type);

                    symbole := donne_symbole(*table, indice_symbole);
                    nom_symbole := donne_nom_symbole(*table, symbole);
                    nom_section_sym := donne_nom_section_symbole(*table, symbole);

                    ajoute_ligne(tabuleuse, it.r_offset, chn_type, nom_symbole, indice_symbole, nom_section_sym, it.r_addend);
                }

                initialise_tailles_max_colonnes(tabuleuse, fonte);
            }
        }
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Table .eh_frame
 * \{ */

donne_tabuleuse_eh_frame :: fonc (fichier: *DonnéesFichier, fonte: *Fonte, tabuleuse: *Tabuleuse)
{
    si tabuleuse.lignes.taille == 0 {
        succès, données_eh_frame := parse_données_eh_frame(fichier.fichier)
        si succès {
            initialise_tabuleuse(tabuleuse, "Titre", "Valeur")

            pour * cie dans données_eh_frame.cies {
                ajoute_ligne(tabuleuse, "Length", cie.length)
                ajoute_ligne(tabuleuse, "CIE ID", cie.cie_id)
                ajoute_ligne(tabuleuse, "Version", cie.version)
                ajoute_ligne(tabuleuse, "Augmentation String", cie.augmentation_string)
                ajoute_ligne(tabuleuse, "Code Alignment Factor", cie.code_alignement_factor)
                ajoute_ligne(tabuleuse, "Data Alignment Factor", cie.data_alignement_factor)
                ajoute_ligne(tabuleuse, "Return Address Register", cie.return_address_register)
                ajoute_ligne(tabuleuse, "Augmentation Data", cie.augmentation_data)
                ajoute_ligne(tabuleuse, "Initial Instructions", cie.initial_instructions)

                fdes := donne_fdes(*données_eh_frame, cie)

                pour * fde, indice_fde dans fdes {
                    ajoute_ligne(tabuleuse, "FDE", indice_fde)
                    ajoute_ligne(tabuleuse, "Length", fde.length)
                    ajoute_ligne(tabuleuse, "CIE Pointer", fde.cie_pointer)

                    discr fde.pc_begin.représentation {
                        INT_16 {
                            ajoute_ligne(tabuleuse, "PC Begin", fde.pc_begin.données comme z16)
                        }
                        INT_32 {
                            ajoute_ligne(tabuleuse, "PC Begin", fde.pc_begin.données comme z32)
                        }
                        INT_64 {
                            ajoute_ligne(tabuleuse, "PC Begin", fde.pc_begin.données comme z64)
                        }
                        UINT_16 {
                            ajoute_ligne(tabuleuse, "PC Begin", fde.pc_begin.données comme n16)
                        }
                        UINT_32 {
                            ajoute_ligne(tabuleuse, "PC Begin", fde.pc_begin.données comme n32)
                        }
                        UINT_64 {
                            ajoute_ligne(tabuleuse, "PC Begin", fde.pc_begin.données)
                        }
                    }

                    ajoute_ligne(tabuleuse, "PC End", fde.pc_range)
                    ajoute_ligne(tabuleuse, "Augmentation Data", fde.augmentation_data)
                    ajoute_ligne(tabuleuse, "Instructions", fde.call_frame_instructions)
                }
            }

            initialise_tailles_max_colonnes(tabuleuse, fonte)
        }
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Table .debug_info
 * \{ */

donne_tabuleuse_debug_info :: fonc (fichier: *DonnéesFichier, fonte: *Fonte, tabuleuse: *Tabuleuse)
{
    si tabuleuse.lignes.taille == 0 {

        table := parse_informations_débogage(fichier.fichier)

        si table {
            initialise_tabuleuse(tabuleuse, "Version", "Type", "Taille Adresse", "Abbréviations", "Attributs", "DIEs")

            pour * table.unités_de_compilation {
                attributs := donne_attributs(table, it)
                dies := donne_dies(table, it)
                ajoute_ligne(tabuleuse, it.version, it.unit_type, it.address_size, it.debug_abbrev_offset, attributs.taille, dies.taille)
            }

            initialise_tailles_max_colonnes(tabuleuse, fonte)
        }
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Table .debug_abbrev
 * \{ */

donne_tabuleuse_debug_abbrev :: fonc (fichier: *DonnéesFichier, fonte: *Fonte, tabuleuse: *Tabuleuse)
{
    si tabuleuse.lignes.taille == 0 {
        succès_table, table := parse_table_abbréviations(fichier.fichier)
        
        initialise_tabuleuse(tabuleuse, "Code", "Tag", "Attributs", "Nom Attribut", "Forme Attribut")

        pour * table.abbréviations {
            ajoute_ligne(tabuleuse, it.code, donne_chaine_pour_tag_abbréviation(it.tag), donne_taille(it.attributs), "", "")

            pour attribut dans donne_attributs(*table, it) {
                ajoute_ligne(tabuleuse, "", "", "", donne_chaine_pour_nom_attribut(attribut.nom), donne_chaine_pour_forme_attribut(attribut.forme))
            }
        }

        initialise_tailles_max_colonnes(tabuleuse, fonte)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Table .debug_aranges
 * \{ */

donne_tabuleuse_debug_aranges :: fonc (fichier: *DonnéesFichier, fonte: *Fonte, tabuleuse: *Tabuleuse)
{
    si tabuleuse.lignes.taille == 0 {
        table := parse_table_aranges(fichier.fichier)
        
        initialise_tabuleuse(tabuleuse, "Version", "Décalage .debug_info", "Taille Adresse", "Taille sélecteur segment", "Tuples", "Segment", "Adresse", "Longueur")

        pour * table.entrées {
            tuples := donne_tuples(table, it)
            ajoute_ligne(tabuleuse, it.version, it.debug_info_offset, it.address_size, it.segment_selector_size, tuples.taille, "", "", "")

            pour tuple dans tuples {
                ajoute_ligne(tabuleuse, "", "", "", "", "", tuple.segment, tuple.adresse, tuple.longueur)
            }
        }

        initialise_tailles_max_colonnes(tabuleuse, fonte)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Table .debug_rnglists
 * \{ */

donne_tabuleuse_debug_rnglists :: fonc (fichier: *DonnéesFichier, fonte: *Fonte, tabuleuse: *Tabuleuse)
{
    si tabuleuse.lignes.taille == 0 {
        table := parse_table_rnglists(fichier.fichier)
        
        initialise_tabuleuse(tabuleuse, "Version", "Taille Adresse", "Taille Sélecteur Segment", "Nombre de décalages", "Listes")

        pour table.tables {
            ajoute_ligne(tabuleuse, it.version, it.address_size, it.segment_selector_size, it.offset_entry_count, donne_taille(it.listes))
        }

        initialise_tailles_max_colonnes(tabuleuse, fonte)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Table .debug_loclists
 * \{ */

donne_tabuleuse_debug_loclists :: fonc (fichier: *DonnéesFichier, fonte: *Fonte, tabuleuse: *Tabuleuse)
{
    si tabuleuse.lignes.taille == 0 {
        table := parse_table_loclists(fichier.fichier)

        initialise_tabuleuse(tabuleuse, "Version", "Taille Adresse", "Taille Sélecteur Segment", "Nombre de décalages", "Listes")

        pour table.tables {
            ajoute_ligne(tabuleuse, it.version, it.address_size, it.segment_selector_size, it.offset_entry_count, donne_taille(it.listes))
        }

        initialise_tailles_max_colonnes(tabuleuse, fonte)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Table .debug_rnglists
 * \{ */

donne_tabuleuse_debug_line :: fonc (fichier: *DonnéesFichier, fonte: *Fonte, tabuleuse: *Tabuleuse)
{
    si tabuleuse.lignes.taille == 0 {
        table := parse_table_debug_line(fichier.fichier)
        
        initialise_tabuleuse(tabuleuse, "Version")

        pour table.tables {
            ajoute_ligne(tabuleuse, it.version)
        }

        initialise_tailles_max_colonnes(tabuleuse, fonte)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Utilitaires interface.
 * \{ */

dispose_rectangle_défilable :: fonc (espace_disponible: EspaceDisponible, couleur: CouleurRVBA, décalage_vertical := 0) -> (EspaceDisponible, *BarreDeDéfilement)
{
    /* Rectangle parent. */
    dispose_rectangle()
    définis_arrière_plan(couleur)
    définis_disposition(cotation = donne_cotation(espace_disponible))
    ajoute_défilage_vertical(*espace_disponible, 16, COULEUR_ARRIÈRE_PLAN)

    barre := donne_barre_défilage_verticale()

    si décalage_vertical > 0 {
        définis_défilage(barre, décalage_vertical comme r32)
    }

    /* Rectangle enfant. */
    dispose_rectangle()
    définis_cotation(Cotation(FIXE(espace_disponible.largeur comme z32), hauteur_min = espace_disponible.hauteur))

    retourne espace_disponible, barre
}

termine_rectangle_défilable :: fonc ()
{
    /* Rectangle enfant. */
    termine_rectangle()
    /* Rectangle parent. */
    termine_rectangle()
}

/** \} */
