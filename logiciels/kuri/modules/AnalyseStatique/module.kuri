// Module d'analyse statique du code selon différents modèles (NASA, Linux, Google, etc.)
// À FAIRE : préserve l'information qu'une fonction est marquée comme enlignée

importe Compilatrice
importe Fondation
importe GreffeMétaprogramme
importe LigneDeCommande
importe Triage

OptionsAnalyse :: struct {
    imprimeuses: bool = vrai @Aide "Vérifie les appels à toutes les fonctions @Imprimeuse afin de détecter les paramètres manquants."

    ligne_de_cache: bool @Aide "Vérifie qu'aucune rubrique de structure ne dépasse une ligne de cache."
    taille_cache: n8 = 64 @Aide "Précise la taille d'une ligne de cache en octets."

    rembourrage: bool @Aide "Vérifie que le rembourrage inséré entre les rubriques des structure n'est pas excessif."
    rembourrage_permis: n32 = 24 @Aide "Le rembourrage maximal permis."

    nasa: bool @Aide "Controle que le code respecte les instructions de codage de la NASA. Voir https://andrewbanks.com/wp-content/uploads/2019/07/JPL_Coding_Standard_C.pdf"
}

GreffonAnalyse :: struct {
    empl base: GreffonMétaprogramme

    options: OptionsAnalyse
}

donne_greffon :: fonc () -> *GreffonMétaprogramme
{
    résultat := loge(GreffonAnalyse)
    résultat.sur_message = greffon_analyse_sur_message
    résultat.sur_arguments = greffon_analyse_sur_arguments
    résultat.sur_destruction = greffon_analyse_sur_destruction
    retourne résultat
}

#portée_fichier

greffon_analyse_sur_message :: fonc (greffon: *GreffonAnalyse, message: *Message)
{
    si message.genre == GenreMessage.TYPAGE_CODE_TERMINÉ {
        message_typage := message comme *MessageTypageCodeTerminé
        si greffon.options.imprimeuses {
            vérifie_appels_imprimeuses(message.espace, message_typage.code)
        }
        si greffon.options.ligne_de_cache {
            vérifie_dépassement_ligne_de_cache(message_typage.code, greffon.options)
        }
        si greffon.options.rembourrage {
            vérifie_rembourrage_excessif(message_typage.code, greffon.options)
        }
        si greffon.options.nasa {
            vérifie_nasa(message.espace, message_typage.code)
        }
    }
}

greffon_analyse_sur_arguments :: fonc (greffon: *GreffonAnalyse, arguments: []chaine)
{
    /* Saute le nom du métaprogramme. */
    _ := consomme(*arguments)
    
    succès, options, _ := parse_ligne_de_commande(OptionsAnalyse, arguments)
    si succès {
        greffon.options = options
    }
}

greffon_analyse_sur_destruction :: fonc (greffon: *GreffonAnalyse)
{
    déloge(greffon)
}

vérifie_appels_imprimeuses :: fonc (espace: EspaceDeTravail, code: *NoeudCode)
{
    si code.genre != GenreNoeud.DÉCLARATION_CORPS_FONCTION {
        retourne
    }

    corps := code comme *NoeudCodeCorpsFonction
    pour noeud dans corps.noeuds {
        si noeud.genre == GenreNoeud.EXPRESSION_APPEL {
            appel := noeud comme *NoeudCodeAppel

            si appel.expression.genre != GenreNoeud.EXPRESSION_RÉFÉRENCE_DÉCLARATION {
                continue
            }

            référence := appel.expression comme *NoeudCodeRéférenceDéclaration
            entête_imprimeuse := est_fonction_imprimeuse(référence.déclaration_référée)
            saufsi entête_imprimeuse {
                continue
            }

            indice_arg_variadique : z64 = -1
            pour arg, indice_arg dans entête_imprimeuse.params {
                si arg.type.id == GenreInfoType.VARIADIQUE {
                    indice_arg_variadique = indice_arg
                    arrête
                }
            }
            sansarrêt {
                continue
            }

            si indice_arg_variadique == 0 {
                compilatrice_rapporte_avertissement(espace, entête_imprimeuse, "Une fonction est marquée @Imprimeuse alors que ses paramètres variadiques sont les premiers. Ils doivent être précédés par une chaine de formattage.")
                continue
            }

            indice_arg_formattage := indice_arg_variadique - 1
            param_formattage := entête_imprimeuse.params[indice_arg_formattage]
            si param_formattage.type.id != GenreInfoType.CHAINE {
                compilatrice_rapporte_avertissement(espace, entête_imprimeuse, "Une fonction est marquée @Imprimeuse alors que son paramètre de formattage n'est pas de type chaine.")
                continue
            }

            argument_format := appel.paramètres[indice_arg_formattage]
            si argument_format.genre != GenreNoeud.EXPRESSION_LITTÉRALE_CHAINE {
                continue
            }

            nombre_de_pourcentages := 0
            chn := (argument_format comme *NoeudCodeLittéraleChaine).valeur
            pour chn {
                si it == '%' {
                    nombre_de_pourcentages += 1
                }
            }

            nombre_de_paramètres_spécifiés := appel.paramètres.taille - indice_arg_variadique

            si nombre_de_paramètres_spécifiés < nombre_de_pourcentages {
                compilatrice_rapporte_erreur(espace, appel, "Paramètre manquant pour la fonction d'impression.")
            }
            sinon si nombre_de_paramètres_spécifiés > nombre_de_pourcentages {
                compilatrice_rapporte_erreur(espace, appel, "Trop de paramètres spécifiés pour la fonction d'impression.")
            }
        }
    }
}

est_fonction_imprimeuse :: fonc (code: *NoeudCode) -> *NoeudCodeEntêteFonction
{
    si code == nul {
        // À FAIRE : parfois nous avons une référence nulle
        retourne nul
    }

    si code.genre != GenreNoeud.DÉCLARATION_ENTÊTE_FONCTION {
        retourne nul
    }

    entête := code comme *NoeudCodeEntêteFonction
    saufsi fonction_possède_annotation(entête, "Imprimeuse") {
        retourne nul
    }

    retourne entête
}

vérifie_dépassement_ligne_de_cache :: fonc (code: *NoeudCode, options: OptionsAnalyse)
{
    si code.genre == GenreNoeud.DÉCLARATION_STRUCTURE && code.type {
        déclaration := code comme *NoeudCodeStructure
        type := déclaration.type comme *InfoTypeStructure

        pour type.rubriques {
            si it.drapeaux.EST_CONSTANTE || it.drapeaux.EST_IMPLICITE {
                continue
            }

            // À FAIRE : tableaux fixes, etc.
            reste_décalage := it.décalage % 64
            si reste_décalage comme n32 + it.id.taille_en_octet > options.taille_cache {
                avertissement := imprime_chaine("Dépassement d'une ligne de cache pour %", it.nom)
                compilatrice_rapporte_avertissement(code, avertissement)
                déloge(avertissement)
            }
        }
    }
}

vérifie_rembourrage_excessif :: fonc (code: *NoeudCode, options: OptionsAnalyse)
{
    si code.genre == GenreNoeud.DÉCLARATION_STRUCTURE && code.type {
        déclaration := code comme *NoeudCodeStructure
        type := déclaration.type comme *InfoTypeStructure

        types_rubriques: [..]*InfoType
        diffère déloge(types_rubriques)

        pour type.rubriques {
            si it.drapeaux.EST_CONSTANTE || it.drapeaux.EST_IMPLICITE {
                continue
            }
            tableau_ajoute(*types_rubriques, it.id)
        }

        rembourrage_courant := calcule_rembourrage(types_rubriques)
        tri_rapide(types_rubriques, tri_types_par_alignement_décroissant)
        rembourrage_optimal := calcule_rembourrage(types_rubriques)

        si rembourrage_courant > rembourrage_optimal && (rembourrage_courant - rembourrage_optimal) > options.rembourrage_permis {
            avertissement := imprime_chaine("Rembourrage excessif : % octets de rembourrage quand % est optimal", rembourrage_courant, rembourrage_optimal)
            compilatrice_rapporte_avertissement(code, avertissement)
            déloge(avertissement)
        }
    }
}

tri_types_par_alignement_décroissant :: fonc (a: *InfoType, b: *InfoType) -> z32
{
    si a.alignement > b.alignement {
        retourne 1
    }

    si b.alignement > a.alignement {
        retourne -1
    }

    retourne 0
}

calcule_rembourrage :: fonc (types: []*InfoType) -> n32
{
    résultat: n32
    taille_courante: n32

    alignement_max: n32

    pour types {
        si it.alignement != 0 {
            rembourrage := (it.alignement - taille_courante % it.alignement) % it.alignement
            résultat += rembourrage

            taille_courante += rembourrage
            taille_courante += it.taille_en_octet

            si it.alignement > alignement_max {
                alignement_max = it.alignement
            }
        }
    }

    si alignement_max != 0 {
        rembourrage := (alignement_max - taille_courante % alignement_max) % alignement_max
        résultat += rembourrage
    }

    retourne résultat
}

/*

    https://andrewbanks.com/wp-content/uploads/2019/07/JPL_Coding_Standard_C.pdf

    3. pas d'allocation dynamique après l'initialisation (en dehors de principale)

    5. minimum de deux assertions par fonction
       les assertions ne doivent pas avoir d'effets secondaires
       les assertions doivent avoir des actions associées en cas d'erreur (= si cond { } ?)

    6. les déclarations doivent avoir lieu au plus près de leurs utilisations

    7. la valeur de retour des fonctions doit être vérifiée par les appelants
       les paramètres des fonctions doivent être vérifées dans la fonction

*/

vérifie_nasa :: fonc (espace: EspaceDeTravail, code: *NoeudCode)
{
    si code.genre != GenreNoeud.DÉCLARATION_CORPS_FONCTION {
        retourne
    }

    corps := code comme *NoeudCodeCorpsFonction

    si est_fonction_trop_longue(corps, 60) {
        avertis_nasa(espace, corps.entête, ViolationNASA.FONCTION_LONGUE)
    }

    // À FAIRE : pour les boucles, vérification sur la présence d'un "arrête"
    pour corps.noeuds {
        // si it.genre == GenreNoeud.DÉCLARATION_VARIABLE && utilise_pointeur_de_fonction(it.type) {
        //     avertis_nasa(espace, it, ViolationNASA.POINTEUR_FONCTION)
        // }

        si it.genre == GenreNoeud.INSTRUCTION_BOUCLE {
            avertis_nasa(espace, it, ViolationNASA.BOUCLE_SANS_LIMITE)
        }
        sinon si it.genre == GenreNoeud.INSTRUCTION_TANTQUE {
            instruction := it comme *NoeudCodeTantque
            si est_littérale_bool_vrai(instruction.condition) {
                avertis_nasa(espace, it, ViolationNASA.BOUCLE_SANS_LIMITE)
            }
        }
        sinon si it.genre == GenreNoeud.INSTRUCTION_RÉPÈTE {
            instruction := it comme *NoeudCodeRépète
            si est_littérale_bool_vrai(instruction.condition) {
                avertis_nasa(espace, it, ViolationNASA.BOUCLE_SANS_LIMITE)
            }
        }
        sinon si it.genre == GenreNoeud.EXPRESSION_RÉFÉRENCE_RUBRIQUE {
            référence := it comme *NoeudCodeRéférenceRubrique
            type_accédé := référence.accédée.type
            si type_accédé && type_accédé.id == GenreInfoType.POINTEUR {
                si référence.accédée.genre == GenreNoeud.EXPRESSION_RÉFÉRENCE_RUBRIQUE {
                    référence = référence.accédée comme *NoeudCodeRéférenceRubrique
                    type_accédé = référence.accédée.type
                    si type_accédé && type_accédé.id == GenreInfoType.POINTEUR {
                        avertis_nasa(espace, it, ViolationNASA.DÉRÉFENCEMENTS_MULTIPLE_DE_POINTEUR)
                    }
                }
            }
        }
    }
}

est_littérale_bool_vrai :: fonc (code: *NoeudCode) -> bool
{
    si code.genre != GenreNoeud.EXPRESSION_LITTÉRALE_BOOLÉEN {
        retourne faux
    }
    littérale := code comme *NoeudCodeLittéraleBool
    retourne littérale.valeur
}

ViolationNASA :: énum {
    FONCTION_LONGUE
    BOUCLE_SANS_LIMITE
    POINTEUR_FONCTION
    DÉRÉFENCEMENTS_MULTIPLE_DE_POINTEUR
}

avertis_nasa :: fonc (espace: EspaceDeTravail, site: *NoeudCode, violation: ViolationNASA)
{
    discr violation {
        FONCTION_LONGUE {
            compilatrice_rapporte_avertissement(espace, site, "La fonction possède plus de 60 lignes, violation de la ligne directrice de la NASA n° 4")
        }
        BOUCLE_SANS_LIMITE {
            // À FAIRE(langage) : nous obtenons les expressions substituées...
            // compilatrice_rapporte_avertissement(espace, site, "Utilisation d'une boucle sans limite, violation de la ligne directrice de la NASA n° 2")
        }
        POINTEUR_FONCTION {
            compilatrice_rapporte_avertissement(espace, site, "Utilisation d'un pointeur de fonction, violation de la ligne directrice de la NASA n° 9")
        }
        DÉRÉFENCEMENTS_MULTIPLE_DE_POINTEUR {
            compilatrice_rapporte_avertissement(espace, site, "Plusieurs déréférencement de pointeurs, violation de la ligne directrice de la NASA n° 9")
        }
    }
}

est_fonction_trop_longue :: fonc (corps: *NoeudCodeCorpsFonction, lignes_max: n32) -> bool
{
    bloc := corps.bloc
    saufsi bloc && bloc.expressions {
        retourne faux
    }

    dernière_expression := bloc.expressions[bloc.expressions.taille - 1]
    début_bloc := bloc.numéro_ligne
    fin_bloc := dernière_expression.numéro_ligne

    // À FAIRE(langage) : nous pouvons avoir une ligne de fin inférieur à la ligne de début
    si fin_bloc < début_bloc {
        retourne faux
    }

    si (fin_bloc - début_bloc) comme n32 <= lignes_max {
        retourne faux
    }

    entête := corps.entête
    pour entête.annotations {
        si it.nom == "FonctionLongue" {
            retourne faux
        }
    }

    retourne vrai
}

utilise_pointeur_de_fonction :: fonc (type: *InfoType) -> bool
{
    saufsi type {
        retourne faux
    }

    discr type.id {
        STRUCTURE {
            type_structure := type comme *InfoTypeStructure
            pour type_structure.rubriques {
                si utilise_pointeur_de_fonction(it.id) {
                    retourne vrai
                }
            }
        }
        UNION {
            type_union := type comme *InfoTypeUnion
            pour type_union.rubriques {
                si utilise_pointeur_de_fonction(it.id) {
                    retourne vrai
                }
            }
        }
        FONCTION {
            retourne vrai
        }
        OPAQUE {
            type_opaque := type comme *InfoTypeOpaque
            retourne utilise_pointeur_de_fonction(type_opaque.type_opacifié)
        }
        POINTEUR {}
        RIEN {}
        ENTIER {}
        RÉEL {}
        BOOLÉEN {}
        OCTET {}
        TYPE_DE_DONNÉES {}
        TABLEAU,
        TABLEAU_FIXE {
            type_tableau := type comme *InfoTypeTableau
            retourne utilise_pointeur_de_fonction(type_tableau.type_pointé)
        }
        TRANCHE {}
        ÉNUM {}
        CHAINE {}
        EINI {}
        VARIADIQUE {
            type_variadique := type comme *InfoTypeVariadique
            retourne utilise_pointeur_de_fonction(type_variadique.type_élément)
        }
        ADRESSE_FONCTION {}
        POLYMORPHIQUE {}
    }

    retourne faux
}

/*

    Lignes directrices du kernel Linux
    https://www.kernel.org/doc/html/v4.10/process/coding-style.html

    1. pas plus de 80 caractères par lignes

    2. pas plus de 3 niveaux d'indentations (de profondeur, switch/case compte pour 1)

    3. pas d'expressions multiples sur une même ligne

    4. pas d'assignations multiples sur une même ligne

    5. pas de typedefs pour les structures et les pointeurs

    6. les fonctions ne doivent pas dépassée 24-48 lignes (en fonction de leurs complexité)

    7. entre 5 et 10 variables locales par fonction (7 est une bonne moyenne)

    8. utilisation de « inline » uniquement sur les fonctions courtes (3 lignes)

*/

/*
    Lignes directrices de Google
    https://google.github.io/styleguide/cppguide.html

    1. « inline » uniquement sur les fonctions courtes (10 lignes)
       à éviter sur les fonctions ayant des boucles ou des switchs

    2. Place a function's variables in the narrowest scope possible, and initialize variables in the declaration.

    3. éviter les opérateurs template

    4. fonctions < 40 lignes de préférence

    5. surcharge de fonctions uniquement si la sémantique de valeur est préservée
*/

/*

    Lignes directrices de Sean Parent

    1. no raw loops
       si la fonction possède plusieurs boucles

    2. no raw synchronization primitives

    3. avoid incident data structures

    4. human interfaces

*/
