importe Ensemble
importe EnsembleDeBits
importe Image
importe Math
importe MIME
importe Structures
importe Triage
importe Typographie

/* ------------------------------------------------------------------------- */
/** \nom BarreDeDéfilement
 * \{ */

BarreDeDéfilement :: struct {
    rect: RectanglePosDim(r32)
    est_cliqué: bool
    est_survolé: bool
    est_visible: bool
    pos_clic_y: r32
    hauteur: r32
    ratio : r32 = 1.0
}

crée_barre_de_défilement :: fonc (largeur_vue: r32, hauteur_vue: r32, hauteur_contenu: r32) -> *BarreDeDéfilement
{
    barre := loge(BarreDeDéfilement)
    ajourne(barre, largeur_vue, hauteur_vue, hauteur_contenu)    
    retourne barre
}

ajourne :: fonc (barre: *BarreDeDéfilement, largeur_vue: r32, hauteur_vue: r32, hauteur_contenu: r32)
{
    hauteur_barre := hauteur_vue * hauteur_vue / hauteur_contenu

    si barre.rect.hauteur == hauteur_barre {
        retourne
    }

    /* Ajourne la barre */
    largeur_barre := 12.0
    barre.ratio = hauteur_vue / hauteur_contenu

    rect_barre: RectanglePosDim(r32)
    rect_barre.x = largeur_vue - largeur_barre
    rect_barre.largeur = largeur_barre
    rect_barre.y = 0.0
    rect_barre.hauteur = hauteur_barre

    barre.hauteur = hauteur_vue

    barre.rect = rect_barre
}

détruit :: fonc (barre: *BarreDeDéfilement)
{
    déloge(barre)
}

définis_position_y :: fonc (barre: *BarreDeDéfilement, y: r32) -> bool
{
    vieil_y := barre.rect.y
    barre.rect.y = y

    si barre.rect.y < 0.0 {
        barre.rect.y = 0.0
    }
    sinon si (barre.rect.y + barre.rect.hauteur) > barre.hauteur {
        barre.rect.y = barre.hauteur - barre.rect.hauteur
    }

    retourne barre.rect.y != vieil_y
}

décale_par :: fonc (barre: *BarreDeDéfilement, delta: r32) -> bool
{
    retourne définis_position_y(barre, barre.rect.y + delta)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Arbre de disposition
 * \{ */

TamponID :: struct {
    données: [..]n32
    hauteur: z32
    largeur: z32
    fut_dessiné: bool
}

donne_indice_pour_position :: fonc (tampon: *TamponID, x: z32, y: z32) -> Optionnel(n32)
{
    saufsi tampon.fut_dessiné {
        retourne
    }

    saufsi 0 <= x < tampon.largeur && 0 <= y < tampon.hauteur {
        retourne
    }

    /* OpenGL est de bas en haut, donc inverse l'axe des y. */
    indice := (tampon.hauteur - y - 1) * tampon.largeur + x

    retourne tampon.données[indice]
}

ArbreDeDisposition :: struct {
    racine: *Box
    stacking_context: *StackingContext
    commandes: *CommandesDeRendu

    stacking_contexts: [..]*StackingContext

    boxes: [..]*Box
    lignes_tenantes: [..]*LignesTenante
    tampon_id: TamponID

    boxes_position_float: n32
    boxes_position_absolue: n32

    défilement_vertical: *BarreDeDéfilement
}

détruit_arbre :: fonc (arbre: *ArbreDeDisposition)
{
    saufsi arbre {
        retourne
    }

    pour arbre.boxes {
        déloge(it.enfants)
        si it.propriétés {
            détruit_propriétés(it.propriétés)
        }

        élément := it.donne_élément()
        si élément {
            élément.box = nul
        }
        sinon si it.noeud {
            assert(HTML.est_texte(it.noeud))
            noeud_texte := it.noeud comme *HTML.Text
            noeud_texte.box = nul
        }

        si it.table_virtuelle.type == BlockBox {
            bloc := it comme *BlockBox
            déloge(bloc)
        }
        sinon si it.table_virtuelle.type == InlineBox {
            box := it comme *InlineBox
            déloge(box)
        }
        sinon si it.table_virtuelle.type == TextBox {
            texte := it comme *TextBox
            détruit_chaine(texte.texte)
            déloge(texte.fragments)
            déloge(texte)
        }
        sinon si it.table_virtuelle.type == BreakBox {
            bris := it comme *BreakBox
            déloge(bris)
        }
        sinon si it.table_virtuelle.type == ReplacedBox {
            replaced := it comme *ReplacedBox
            déloge(replaced)
        }
        sinon si it.table_virtuelle.type == SelectBox {
            select := it comme *SelectBox
            détruit_chaine(select.texte)
            déloge(select.fragments)
            déloge(select)
        }
        sinon si it.table_virtuelle.type == TableWrapperBox {
            box := it comme *TableWrapperBox
            déloge(box)
        }
        sinon si it.table_virtuelle.type == TableBox {
            box := it comme *TableBox
            déloge(box)
        }
        sinon si it.table_virtuelle.type == TableColumnGroupBox {
            box := it comme *TableColumnGroupBox
            déloge(box)
        }
        sinon si it.table_virtuelle.type == TableColumnBox {
            box := it comme *TableColumnBox
            déloge(box)
        }
        sinon si it.table_virtuelle.type == TableFooterGroupBox {
            box := it comme *TableFooterGroupBox
            déloge(box)
        }
        sinon si it.table_virtuelle.type == TableHeaderGroupBox {
            box := it comme *TableHeaderGroupBox
            déloge(box)
        }
        sinon si it.table_virtuelle.type == TableRowGroupBox {
            box := it comme *TableRowGroupBox
            déloge(box)
        }
        sinon si it.table_virtuelle.type == TableRowBox {
            box := it comme *TableRowBox
            déloge(box)
        }
        sinon si it.table_virtuelle.type == TableCellBox {
            box := it comme *TableCellBox
            déloge(box)
        }
        sinon si it.table_virtuelle.type == CaptionBox {
            box := it comme *CaptionBox
            déloge(box)
        }
        sinon {
            imprime("box inconnu !")
            déloge(it)
        }
    }

    pour arbre.lignes_tenantes {
        détruit(it)
    }

    détruit_stacking_context(arbre.stacking_context)
    déloge(arbre.stacking_contexts)
    détruit_commandes(arbre.commandes)
    détruit(arbre.défilement_vertical)
    déloge(arbre.tampon_id.données)
    déloge(arbre.lignes_tenantes)
    déloge(arbre.boxes)
    déloge(arbre)
}

crée_box :: fonc (arbre: *ArbreDeDisposition, $TypeBox: type_de_données) -> *TypeBox
{
    résultat := loge(TypeBox)
    résultat.id = arbre.boxes.taille comme n32
    tableau_ajoute(*arbre.boxes, résultat)
    retourne résultat
}

donne_commandes_de_rendu :: fonc (arbre: *ArbreDeDisposition) -> *CommandesDeRendu
{
    saufsi arbre.commandes {
        arbre.commandes = loge(CommandesDeRendu)
    }
    retourne arbre.commandes
}

définis_taille_tampon_id :: fonc (arbre: *ArbreDeDisposition, largeur: z32, hauteur: z32)
{
    si arbre.tampon_id.largeur == largeur && arbre.tampon_id.hauteur == hauteur {
        retourne
    }

    arbre.tampon_id.largeur = largeur
    arbre.tampon_id.hauteur = hauteur

    arbre.tampon_id.fut_dessiné = faux
    tableau_redimensionne(arbre.tampon_id.données, largeur * hauteur)
}

donne_tampon_id :: fonc (arbre: *ArbreDeDisposition) -> *TamponID
{
    retourne *arbre.tampon_id
}

donne_taille_en_octet_boxes :: fonc (arbre: *ArbreDeDisposition) -> n32
{
    résultat: n32
    pour arbre.boxes {
        résultat += it.donne_taille_en_octet()
        résultat += (it.enfants.capacité * 8) comme n32
    }
    retourne résultat
}

donne_élément_pour_position :: fonc (arbre: *ArbreDeDisposition, x: z32, y: z32) -> *HTML.Element
{
    indice := donne_indice_pour_position(*arbre.tampon_id, x, y)
    saufsi indice.possède_valeur() {
        retourne nul
    }

    box := arbre.boxes[indice.Quelque]
    saufsi box {
        retourne nul
    }
    retourne box.donne_élément_récursif()
}

imprime_statistiques :: fonc (arbre: *ArbreDeDisposition)
{
    imprime("--------------------------------------------\n")
    imprime("             Statistiques Arbre\n")

    taille_octets_boxes := arbre.donne_taille_en_octet_boxes()
    nombre_de_boxes := arbre.boxes.taille

    imprime("Nombre de boxes        : %\n", nombre_de_boxes)
    imprime("Mémoire boxes          : %o\n", taille_octets_boxes)
    imprime("Mémoire par box       : %o\n", taille_octets_boxes comme r32 / nombre_de_boxes comme r32)
    imprime("Noeuds position float   : %\n", arbre.boxes_position_float)
    imprime("Noeuds position absolue : %\n", arbre.boxes_position_absolue)
}

imprime_arbre :: fonc (arbre: *ArbreDeDisposition)
{
    résultat := donne_chaine_impression_arbre(arbre)
    diffère déloge(résultat)

    imprime("%\n", résultat)
}

donne_chaine_impression_arbre :: fonc (arbre: *ArbreDeDisposition) -> chaine
{
    saufsi arbre.racine {
        retourne ""
    }

    enchaineuse: Enchaineuse
    initialise_enchaineuse(*enchaineuse)
    diffère détruit_tampons(*enchaineuse)

    imprime_arbre(*enchaineuse, arbre.racine, 0)

    ajoute_au_tampon(*enchaineuse, "\n")

    imprime_arbre_stacking_context(*enchaineuse, arbre.stacking_context, 0)

    retourne chaine_depuis_enchaineuse(*enchaineuse)
}

imprime_arbre :: fonc (enchaineuse: *Enchaineuse, racine: *Box, profondeur: n32)
{
    indentation := donne_chaine_indentation(profondeur comme z32)

    nom_classe := racine.donne_nom_classe_sans_suffixe()

    imprime_dans_enchaineuse(enchaineuse, "%%", indentation, nom_classe)

    élément := donne_élément(racine)
    si élément {
        imprime_dans_enchaineuse(enchaineuse, " <%", élément.local_name)

        saufsi élément.id.est_vide() {
            ajoute_au_tampon(enchaineuse, "#", élément.id)
        }

        classe := HTML.donne_attribut_ou_chaine_vide(élément, HTML.ATTR_class)
        saufsi classe.est_vide() {
            ajoute_au_tampon(enchaineuse, ".", classe)
        }

        ajoute_au_tampon(enchaineuse, ">")
    }
    sinon {
        ajoute_au_tampon(enchaineuse, " <(anonyme)>")
    }

    modèle := racine.modèle_de_boite

    /* Position. */
    imprime_dans_enchaineuse(enchaineuse, " <%, %>", modèle.bordure.x, modèle.bordure.y)

    /* Cotations horizontales. */
    cotations := donne_cotations_horizontales(modèle)
    ajoute_au_tampon(enchaineuse, " CH ")
    imprime_cotation(enchaineuse, *cotations)

    /* Cotations verticales. */
    cotations = donne_cotations_verticales(modèle)
    ajoute_au_tampon(enchaineuse, " CV ")
    imprime_cotation(enchaineuse, *cotations)
    ajoute_au_tampon(enchaineuse, "\n")

    imprime_fragments(enchaineuse, racine, profondeur + 1)

    pour racine.enfants {
        imprime_arbre(enchaineuse, it, profondeur + 1)
    }
}

imprime_fragments :: fonc (enchaineuse: *Enchaineuse, box: *Box, profondeur: n32)
{
    si box.table_virtuelle.type != BlockBox && box.table_virtuelle.type != InlineBox {
        retourne
    }

    indentation := donne_chaine_indentation(profondeur comme z32)
    indentation_texte := donne_chaine_indentation(profondeur comme z32 + 1)

    bloc := box comme *BlockBox
    saufsi bloc.lignes_tenante {
        retourne
    }

    pour bloc.lignes_tenante.fragments {
        ajoute_au_tampon(enchaineuse, indentation)
        nom_classe := it.box.donne_nom_classe_sans_suffixe()
        imprime_dans_enchaineuse(enchaineuse, "frag % % de % début % fin % rect (%,% %x%)", indice_it, it.type, nom_classe, it.indice_début, it.indice_fin, it.x, it.y, it.largeur, it.hauteur)

        si it.box.table_virtuelle.type == TextBox {
            text_box := it.box comme *TextBox
            fragment_texte := text_box.fragments[it.indice_début]
            ajoute_au_tampon(enchaineuse, "\n", indentation_texte, "\"", fragment_texte.texte, "\"")
        }

        ajoute_au_tampon(enchaineuse, "\n")
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom RésolveuseStyle.
 * \{ */

RègleAppariée :: struct {
    règle: *CSSStyleRule
    indice_feuille_de_style: z64
    indice_règle: z64
    origine: OrigineCascade
}

opérateur == :: (a: RègleAppariée, b: RègleAppariée) -> bool
{
    retourne a.règle == b.règle
}

opérateur != :: (a: RègleAppariée, b: RègleAppariée) -> bool
{
    retourne a.règle != b.règle
}

opérateur < :: (a: RègleAppariée, b: RègleAppariée) -> bool
{
    retourne a.règle < b.règle
}

RèglesParIdentifiant :: struct {
    ident: n32
    règles: [..]RègleAppariée
}

opérateur == :: (a: RèglesParIdentifiant, b: RèglesParIdentifiant) -> bool
{
    retourne a.ident == b.ident
}

opérateur != :: (a: RèglesParIdentifiant, b: RèglesParIdentifiant) -> bool
{
    retourne a.ident != b.ident
}

opérateur < :: (a: RèglesParIdentifiant, b: RèglesParIdentifiant) -> bool
{
    retourne a.ident < b.ident
}

RésolveuseStyle :: struct {
    globales: *GlobalesDessin
    document: *HTML.Document
    /* Pour MediaQuery et ContexteCalculStyle. */
    largeur_écran: r64
    hauteur_écran: r64
    longueurs_relative_fonte_racine: LongueursRelativesFonte
    feuilles_de_style: []*CSSStyleSheet

    /* Tampon réutilisé pour les cascades de propriétés. */
    déclarations_cascade: [..]DéclarationCascadée

    /* Style dont les propriétés sont toujours à leurs valeurs initiales.
     * Utilisé lors du calcul des valeurs. */
    valeurs_initiales: Style

    /* Cache. */
    pseudo_classes: PseudoClasses
    /* Les valeurs des ChaineUTF16Uniques des sélecteurs d'id.
     * Nous utilisons les valeurs et non les chaines car nous stockons les
     * données sous d'ensemble et il est plus rapide de comparer des nombres
     * que des chaines pour le stockage ordonné. */
    ids_connus: [..]n32
    attrs_connus: [..]n32
    classes_connues: [..]n32

    /* Ségrégation des règles pour accélérer leurs appariements. */
    règles_par_classe: [..]RèglesParIdentifiant
    autres_règles: [..]RègleAppariée

    /* Cache pour les hints de présentations. */
    presentational_hints: [..]*DéclarationPropriété
}

crée_résolveuse_style :: fonc (document: *HTML.Document, largeur: z32, hauteur: z32) -> *RésolveuseStyle
{
    résultat := loge(RésolveuseStyle)
    initialise_résolveuse(résultat)
    résultat.document = document
    résultat.globales = document.globales_dessin
    résultat.feuilles_de_style = document.feuilles_de_style
    résultat.largeur_écran = largeur comme r64
    résultat.hauteur_écran = hauteur comme r64
    initialise_cache(résultat)
    retourne résultat
}

initialise_résolveuse :: fonc (résolveuse: *RésolveuseStyle)
{
    initialise_style(*résolveuse.valeurs_initiales)
}

initialise_cache :: fonc (résolveuse: *RésolveuseStyle)
{
    résolveuse.pseudo_classes = PseudoClasses.zéro
    résolveuse.ids_connus.taille = 0
    résolveuse.attrs_connus.taille = 0
    résolveuse.classes_connues.taille = 0
    résolveuse.autres_règles.taille = 0
    résolveuse.règles_par_classe.taille = 0

    user_agent := HTML.donne_user_agent(résolveuse.document)

    ctx: ContexteÉvaluationMediaQuery
    /* user_agent peut être nul pour l'exécution des tests. */
    ctx.supporte_scripting = user_agent != nul && user_agent.supporte_scripting
    ctx.largeur = résolveuse.largeur_écran
    ctx.taille_fonte = résolveuse.globales.taille_fonte_défaut

    pour feuille, indice_feuille dans résolveuse.feuilles_de_style {
        indice_règle : z64 = 0
        pour règle dans feuille.rules {
            si règle.type == CSSRuleType.Style {
                règle_de_style := règle comme *CSSStyleRule
                ajoute_règle_aux_caches(résolveuse, règle_de_style, indice_feuille, indice_règle)
                indice_règle += 1
                continue
            }

            si règle.type == CSSRuleType.Media {
                règle_de_media := règle comme *CSSMediaRule
                saufsi évalue_media_list(*ctx, règle_de_media) {
                    continue
                }

                pour règle_média dans règle_de_media.css_rules {
                    si règle_média.type == CSSRuleType.Style {
                        règle_de_style := règle_média comme *CSSStyleRule
                        ajoute_règle_aux_caches(résolveuse, règle_de_style, indice_feuille, indice_règle)
                        indice_règle += 1
                    }
                }

                continue
            }
        }
    }
}

évalue_media_list :: fonc (ctx: *ContexteÉvaluationMediaQuery, règle_de_media: *CSSMediaRule) -> bool
{
    saufsi règle_de_media.media_list {
        retourne faux
    }

    pour règle_de_media.media_list.media_queries {
        saufsi évalue_media_query(ctx, it) {
            retourne faux
        }
    }

    retourne vrai
}

ajoute_règle_aux_caches :: fonc (résolveuse: *RésolveuseStyle, règle_de_style: *CSSStyleRule, indice_feuille: z64, indice_règle: z64)
{
    règle_ajoutée := faux

    règle_appariée: RègleAppariée
    règle_appariée.règle = règle_de_style
    règle_appariée.indice_feuille_de_style = indice_feuille
    règle_appariée.indice_règle = indice_règle

    pour complex dans règle_de_style.selector_list.complex_selectors {
        dernière_classe: Optionnel(CSSOMString)

        pour compound dans complex.compound_selectors {
            init_de(Optionnel(CSSOMString))(*dernière_classe)
            pour simple dans compound.simple_selectors {
                si simple.type == SimpleSelector.Type.PseudoClass {
                    résolveuse.pseudo_classes |= simple.pseudo_classe
                }
                sinon si simple.type == SimpleSelector.Type.ID {
                    ensemble_ajoute(*résolveuse.ids_connus, simple.ident.valeur)
                }
                sinon si simple.type == SimpleSelector.Type.Attrib {
                    ensemble_ajoute(*résolveuse.attrs_connus, simple.ident.valeur)
                }
                sinon si simple.type == SimpleSelector.Type.Class {
                    ensemble_ajoute(*résolveuse.classes_connues, simple.ident.valeur)
                    dernière_classe = simple.ident
                }
            }
        }

        si dernière_classe.possède_valeur() {
            ajoute_règle_pour_classe(résolveuse, dernière_classe.Quelque, règle_appariée)
        }
        sinon saufsi règle_ajoutée {
            règle_ajoutée = vrai
            tableau_ajoute(*résolveuse.autres_règles, règle_appariée)
        }
    }
}

ajoute_règle_pour_classe :: fonc (résolveuse: *RésolveuseStyle, classe: CSSOMString, règle: RègleAppariée)
{
    règle_par_identifiant: RèglesParIdentifiant
    règle_par_identifiant.ident = classe.valeur

    indice := ensemble_possède_retourne_indice(*résolveuse.règles_par_classe, règle_par_identifiant)
    si indice != -1 {
        règles_par_identifant := *résolveuse.règles_par_classe[indice]
        tableau_ajoute(*règles_par_identifant.règles, règle)
        retourne
    }

    tableau_ajoute(*règle_par_identifiant.règles, règle)
    ensemble_ajoute(*résolveuse.règles_par_classe, règle_par_identifiant)
}

donne_règles_pour_classe :: fonc (résolveuse: *RésolveuseStyle, classe: CSSOMString) -> [..]RègleAppariée
{
    règle_par_identifiant: RèglesParIdentifiant
    règle_par_identifiant.ident = classe.valeur

    indice := ensemble_possède_retourne_indice(*résolveuse.règles_par_classe, règle_par_identifiant)
    si indice != -1 {
        retourne résolveuse.règles_par_classe[indice].règles
    }

    résultat: [..]RègleAppariée
    retourne résultat
}

détruit_données_résolveuse :: fonc (résolveuse: *RésolveuseStyle)
{
    déloge(résolveuse.déclarations_cascade)
    déloge(résolveuse.ids_connus)
    déloge(résolveuse.attrs_connus)
    déloge(résolveuse.classes_connues)
    déloge(résolveuse.autres_règles)
    pour résolveuse.règles_par_classe {
        déloge(it.règles)
    }
    déloge(résolveuse.règles_par_classe)
    pour résolveuse.presentational_hints {
        détruit_déclaration(it)
    }
    déloge(résolveuse.presentational_hints)
}

détruit_résolveuse :: fonc (résolveuse: *RésolveuseStyle)
{
    saufsi résolveuse {
        retourne
    }
    détruit_données_résolveuse(résolveuse)
    déloge(résolveuse)
}

/* https://html.spec.whatwg.org/multipage/rendering.html#the-css-user-agent-style-sheet-and-presentational-hints */
ajoute_presentational_hint :: fonc (résolveuse: *RésolveuseStyle, nom_propriété: CSSOMString, value: *ValeurDeStyle)
{
    pour résolveuse.presentational_hints {
        si it.property_name != nom_propriété {
            continue
        }

        si it.value.taille != 1 {
            continue
        }

        saufsi sont_mêmes_valeurs(it.value[0], value) {
            continue
        }

        tableau_ajoute(*résolveuse.déclarations_cascade, DéclarationCascadée(it, Spécificité(0, 0, 0), OrigineCascade.Author))
        retourne
    }

    déclaration := loge(DéclarationPropriété)
    déclaration.info = donne_info_type_pour_nom(nom_propriété)
    déclaration.property_name = nom_propriété
    tableau_ajoute(*déclaration.value, value)

    tableau_ajoute(*résolveuse.déclarations_cascade, DéclarationCascadée(déclaration, Spécificité(0, 0, 0), OrigineCascade.Author))

    tableau_ajoute(*résolveuse.presentational_hints, déclaration)
}

possède_règle_avec_pseudo_classe :: fonc (résolveuse: *RésolveuseStyle, pseudo_classe: PseudoClasses) -> bool
{
    retourne (résolveuse.pseudo_classes & pseudo_classe) != PseudoClasses.zéro
}

possède_règle_avec_id :: fonc (résolveuse: *RésolveuseStyle, id: CSSOMString) -> bool
{
    si id.est_vide() {
        /* Si l'id est la chaine vide, nous devons vérifier que toutes les règles
         * s'appliquent, donc pas de court-circuitage. */
        retourne vrai
    }

    retourne ensemble_possède(*résolveuse.ids_connus, id.valeur)
}

possède_règle_avec_attribut :: fonc (résolveuse: *RésolveuseStyle, attr: CSSOMString) -> bool
{
    si attr.est_vide() {
        /* Si l'attribut est la chaine vide, nous devons vérifier que toutes les règles
         * s'appliquent, donc pas de court-circuitage. */
        retourne vrai
    }

    retourne ensemble_possède(*résolveuse.attrs_connus, attr.valeur)
}

donne_ajournement_pour_redimensionnement :: fonc (résolveuse: *RésolveuseStyle @inutilisée, largeur: z32 @inutilisée, hauteur: z32 @inutilisée) -> AjournementArbre
{
    /* À FAIRE : règles média, sauvegarde de l'ancienne taille */
    retourne AjournementArbre.Disposition
}

RègleEtSpécificité :: struct {
    règle: RègleAppariée
    /* La spécifité du sélecteur complexe ayant la hautissime spécifité ayant apparié l'élément. */
    spécificité: Spécificité
}

collecte_les_règles_appropriées :: fonc (résolveuse: *RésolveuseStyle, élément: *HTML.Element, pseudo_element: *PseudoElement) -> [..]RègleEtSpécificité
{
    temp: [..]RègleAppariée
    diffère déloge(temp)

    résultat: [..]RègleEtSpécificité

    classes := HTML.donne_liste_classe(élément)
    pour classes {
        règles_pour_classe := donne_règles_pour_classe(résolveuse, it)

        pour règle dans règles_pour_classe {
            ensemble_ajoute(*temp, règle)
        }
    }

    pour temp {
        apparie_règle(it, élément, pseudo_element, *résultat)
    }

    pour résolveuse.autres_règles {
        apparie_règle(it, élément, pseudo_element, *résultat)
    }

    retourne résultat
}

apparie_règle :: fonc (règle_de_style: RègleAppariée, élément: *HTML.Element, pseudo_element: *PseudoElement, résultat: *[..]RègleEtSpécificité)
{
    règle_appariée := faux
    spécificité: Spécificité

    pour complex dans règle_de_style.règle.selector_list.complex_selectors {
        saufsi apparie_sélecteur(complex.compound_selectors, complex.compound_selectors.taille - 1, élément, pseudo_element) {
            continue
        }

        spécificité_sélecteur := calcule_spécificité(*complex)
        si spécificité_sélecteur > spécificité {
            spécificité = spécificité_sélecteur
        }

        règle_appariée = vrai
    }

    si règle_appariée {
        tableau_ajoute(résultat, RègleEtSpécificité(règle_de_style, spécificité))
    }
}

résoud_style :: fonc (résolveuse: *RésolveuseStyle, élément: *HTML.Element, pseudo_element: *PseudoElement, propriétés_parent: *PropriétésDeStyle) -> *PropriétésDeStyle
{
    règles := collecte_les_règles_appropriées(résolveuse, élément, pseudo_element)
    diffère déloge(règles)
    // imprime("% règle(s) pour %\n", règles.taille, élément.local_name)

    si pseudo_element != nul && règles.taille == 0 {
        retourne nul
    }

    résolveuse.déclarations_cascade.taille = 0

    pour règles {
        // imprime_règle(it.règle)
        règle := it.règle.règle
        déclarations := règle.style.déclarations
        tableau_réserve(*résolveuse.déclarations_cascade, résolveuse.déclarations_cascade.taille + déclarations.taille)
        spécificité := it.spécificité
        si règle.parent_style_sheet && règle.parent_style_sheet.force_spécifité_zéro {
            spécificité = Spécificité(0, 0, 0)
        }
        origine := donne_origine_cascade(règle)

        position: PositionDéclaration
        position.indice_feuille = it.règle.indice_feuille_de_style
        position.indice_règle = it.règle.indice_règle

        pour déclaration, indice_déclaration dans déclarations {
            position.indice_déclaration = indice_déclaration
            tableau_ajoute(*résolveuse.déclarations_cascade, DéclarationCascadée(déclaration, spécificité, origine, position))
        }
    }

    si pseudo_element == nul {
        HTML.applique_presentational_hints(élément, résolveuse)

        si élément.style {
            /* https://drafts.csswg.org/css-style-attr/#style-attribute
            * "In the cascade, these declarations are considered to have author origin and a specificity higher than any selector." */
            tableau_réserve(*résolveuse.déclarations_cascade, résolveuse.déclarations_cascade.taille + élément.style.déclarations.taille)
            spécificité := donne_spécificité_max()
            pour élément.style.déclarations {
                tableau_ajoute(*résolveuse.déclarations_cascade, DéclarationCascadée(it, spécificité, OrigineCascade.Author))
            }
        }
    }

    tri_rapide(résolveuse.déclarations_cascade, compare_déclarations_pour_cascade)

    résultat := crée_propriétés_de_style(propriétés_parent)

    pour > résolveuse.déclarations_cascade {
        ajoute_déclaration(résultat, it.déclaration)
    }

    calcule_style(résolveuse, résultat, propriétés_parent)

    retourne résultat
}

AjournementArbre :: énum_drapeau {
    /* L'arbre doit être redessiné. */
    Dessin
    /* L'arbre doit être disposé. */
    Disposition
    /* L'arbre doit être construit. */
    Construction
    /* Les stacking contexts doivent être construit. */
    StackingContext
}

donne_ajournement_pour_changement_style :: fonc (résolveuse: *RésolveuseStyle, élément: *HTML.Element) -> AjournementArbre
{
    box := élément.box
    anciennes_propriétés: *PropriétésDeStyle
    propriétés_parent: *PropriétésDeStyle

    si box {
        anciennes_propriétés = box.propriétés
        assert(anciennes_propriétés != nul)
        propriétés_parent = anciennes_propriétés.parent
    }

    nouvelles_propriétés := résoud_style(résolveuse, élément, nul, propriétés_parent)
    diffère détruit_propriétés(nouvelles_propriétés)

    /* Vérifie si "display: none" reste "display: none". */
    display := nouvelles_propriétés.donne_valeur_calculée(IDPropriété.Display).donne_display()
    si display.outer_type == Display.Type.None {
        si box == nul {
            /* Nous restons sur "display: none". */
            retourne AjournementArbre.zéro
        }
        /* Nous sommes passé de "display: none" à autre chose, reconstruisons. */
        retourne AjournementArbre.Construction
    }

    si box == nul {
        /* Nous sommes passé de "display: none" à autre chose, reconstruisons. */
        retourne AjournementArbre.Construction
    }

    assert(anciennes_propriétés != nul)
    résultat: AjournementArbre

    pour * infos_types_propriétés_shorthand {
        résultat |= donne_ajournement_pour_différence_propriétés(nouvelles_propriétés, anciennes_propriétés, it)
    }

    pour * infos_types_propriétés {
        résultat |= donne_ajournement_pour_différence_propriétés(nouvelles_propriétés, anciennes_propriétés, it)
    }

    si résultat.Construction {
        retourne résultat
    }

    si résultat == AjournementArbre.zéro {
        retourne résultat
    }

    /* Sauvegarde les propriétés. */
    permute(nouvelles_propriétés, anciennes_propriétés)

    /* Puisque les rayons des bordures ne modifie pas les dimensions du box (et donc ne
     * requiers pas de recalcul du mis-en-page sur modification), nous devons les recalculer
     * au cas où ils seraient (re)devenus des pourcentages. */
    résoud_pourcentage_largeur_border_radius(box)

    retourne résultat
}

donne_ajournement_pour_différence_propriétés :: fonc (nouvelles_propriétés: *PropriétésDeStyle, anciennes_propriétés: *PropriétésDeStyle, info: *InfoTypePropriété) -> AjournementArbre
{
    nouvelle := nouvelles_propriétés.donne_déclaration(info.nom)
    ancienne := anciennes_propriétés.donne_déclaration(info.nom)

    si nouvelle == nul && ancienne == nul {
        retourne AjournementArbre.zéro
    }

    si nouvelle == nul || ancienne == nul {
        retourne donne_ajournement_arbre(info)
    }

    si nouvelle.value.taille != ancienne.value.taille {
        retourne donne_ajournement_arbre(info)
    }

    pour nouvelle.value {
        si sont_mêmes_valeurs(ancienne.value[indice_it], it) {
            continue
        }

        retourne donne_ajournement_arbre(info)
    }

    si nouvelle.important != ancienne.important {
        retourne donne_ajournement_arbre(info)
    }

    retourne AjournementArbre.zéro
}

donne_ajournement_arbre :: fonc (info: *InfoTypePropriété) -> AjournementArbre
{
    si info.drapeaux.AffecteDisposition {
        retourne AjournementArbre.Disposition
    }
    si info.drapeaux.AffecteConstructionArbre {
        retourne AjournementArbre.Construction
    }
    si info.drapeaux.AffecteStackingContext {
        retourne AjournementArbre.StackingContext
    }
    retourne AjournementArbre.Dessin
}

/* https://www.w3.org/TR/css-cascade/#origin */
OrigineCascade :: énum {
    Author
    User
    UserAgent
}

PositionDéclaration :: struct {
    indice_feuille: z64
    indice_règle: z64
    indice_déclaration: z64
}

opérateur < :: (a: PositionDéclaration, b: PositionDéclaration) -> bool
{
    si a.indice_feuille < b.indice_feuille {
        retourne vrai
    }

    si a.indice_feuille > b.indice_feuille {
        retourne faux
    }

    si a.indice_règle < b.indice_règle {
        retourne vrai
    }

    si a.indice_règle > b.indice_règle {
        retourne faux
    }

    retourne a.indice_déclaration < b.indice_déclaration
}

DéclarationCascadée :: struct {
    déclaration: *DéclarationPropriété
    spécificité: Spécificité
    origine: OrigineCascade
    position: PositionDéclaration
}

/* https://www.w3.org/TR/css-cascade/#cascade-sort */
compare_déclarations_pour_cascade :: fonc (a: DéclarationCascadée, b: DéclarationCascadée) -> z32
{
    /* Tri par importance. */
    si a.déclaration.important && !b.déclaration.important {
        retourne -1
    }
    si b.déclaration.important && !a.déclaration.important {
        retourne 1
    }

    /* Même importance -> tri par origine. */
    si a.origine != b.origine {
        retourne a.origine comme z32 - b.origine comme z32
    }

    /* Même importance et origine -> tri par spécifité. */
    si a.spécificité > b.spécificité {
        retourne -1
    }
    si b.spécificité > a.spécificité {
        retourne 1
    }

    /* Même importance, origine, et spécifité -> tri par position. */
    si a.position < b.position {
        retourne 1
    }
    si b.position < a.position {
        retourne -1
    }

    /* À FAIRE : contextes. */

    retourne 0
}

crée_style_pour_bloc_anonyme :: fonc (résolveuse: *RésolveuseStyle, bloc: *BlockBox, bloc_parent: *BlockBox, outer_display: Display.Type)
{
    display := crée_valeur_display(Display(outer_type = outer_display, inner_type = Display.Type.Flow)) comme *ValeurDeStyle

    /* Créons une fausse déclaration pour que le display soit proprement passé et appliqué aux valeurs utilisées. */
    déclaration_display: DéclarationPropriété
    déclaration_display.info = donne_info_type_pour_nom(PROP_display)
    déclaration_display.property_name = PROP_display
    déclaration_display.value.pointeur = *display
    déclaration_display.value.taille = 1

    ptr_déclaration_display := *déclaration_display

    résultat := crée_propriétés_de_style(bloc_parent.propriétés)
    résultat.déclarations.pointeur = *ptr_déclaration_display
    résultat.déclarations.taille = 1

    calcule_style(résolveuse, résultat, bloc_parent.propriétés)

    résultat.déclarations.pointeur = nul
    résultat.déclarations.taille = 0

    bloc.propriétés = résultat
}

ContexteParsageShorthandVariable :: struct {
    empl base: ContexteParsageShorthand

    ctx_calcul_style: *ContexteCalculStyle
}

contexte_parsage_shorthand_variable_ajoute_propriété :: fonc (ctx: *ContexteParsageShorthandVariable, nom: CSSOMString, valeur: *ValeurDeStyle)
{
    info := donne_info_type_pour_nom(nom)
    saufsi info {
        retourne
    }

    /// XXX - fuite de mémoire sur copie_valeur()
    v := copie_valeur(valeur)

    déclaration: DéclarationPropriété
    déclaration.info = info
    déclaration.property_name = nom
    déclaration.value.pointeur = *v
    déclaration.value.taille = 1

    calcule_valeur_propriété(ctx.ctx_calcul_style, info, *déclaration)
}

développe_variables :: fonc (propriétés: *PropriétésDeStyle, value: []ComponentValue) -> [..]ComponentValue
{
    résultat: [..]ComponentValue
    pour value {
        saufsi it.est_fonction(PROP_var) {
            tableau_ajoute(*résultat, it)
            continue
        }

        parseuse := initialise_une_parseuse(it.function.value)
        opt_variable := parse_variables_depuis_arguments(parseuse)
        saufsi opt_variable.possède_valeur() {
            continue
        }
        variable := opt_variable.Quelque.donne_variable()

        déclaration := donne_déclaration_propriété_personnalisée(propriétés, variable.nom)
        saufsi déclaration {
            continue
        }

        pour valeur_var dans déclaration.valeur_personnalisée {
            tableau_ajoute(*résultat, valeur_var)
        }

        // À FAIRE : fallback
        // À FAIRE : variables récursives
    }
    retourne résultat
}

calcule_style :: fonc (résolveuse: *RésolveuseStyle, propriétés: *PropriétésDeStyle, propriétés_parent: *PropriétésDeStyle)
{
    // À FAIRE(langage) #assert EnsembleDeBits.EnsembleDeBits.NOMBRE_DE_BITS >= IDPropriété.nombre_éléments
    assert(EnsembleDeBits.EnsembleDeBits.NOMBRE_DE_BITS >= IDPropriété.nombre_éléments)

    /* https://www.w3.org/TR/2011/REC-CSS2-20110607/cascade.html#computed-value */
    ctx_calcul_style: ContexteCalculStyle
    ctx_calcul_style.globales = résolveuse.globales
    ctx_calcul_style.document = résolveuse.document
    ctx_calcul_style.longueurs_relative_fonte_racine = résolveuse.longueurs_relative_fonte_racine
    ctx_calcul_style.propriétés = propriétés
    ctx_calcul_style.valeurs_initiales = *résolveuse.valeurs_initiales
    ctx_calcul_style.largeur_canevas = résolveuse.largeur_écran
    ctx_calcul_style.hauteur_canevas = résolveuse.hauteur_écran

    si propriétés_parent {
        initialise_métriques_fonte(*ctx_calcul_style.longueurs_relative_fonte, propriétés_parent, résolveuse.globales)
    }
    sinon {
        fonte := donne_fonte_défaut(résolveuse.globales)
        initialise_métriques_fonte(*ctx_calcul_style.longueurs_relative_fonte, fonte)
        initialise_métriques_fonte(*ctx_calcul_style.longueurs_relative_fonte_racine, fonte)
    }

    calcule_style(*ctx_calcul_style, ÉtapeCalculStyle.Font)

    /* Pour line-height, lh doit rester la valeur du parent. */
    lh_parent := ctx_calcul_style.longueurs_relative_fonte.lh
    initialise_métriques_fonte(*ctx_calcul_style.longueurs_relative_fonte, propriétés, résolveuse.globales)
    lh := ctx_calcul_style.longueurs_relative_fonte.lh
    ctx_calcul_style.longueurs_relative_fonte.lh = lh_parent

    calcule_style(*ctx_calcul_style, ÉtapeCalculStyle.LineHeight)
    ctx_calcul_style.longueurs_relative_fonte.lh = lh

    calcule_style(*ctx_calcul_style, ÉtapeCalculStyle.Autres)

    calcule_display_final(propriétés)

    /* Transfert les valeurs calculées aux valeurs utilisées. */
    pour propriétés.style.valeurs {
        propriétés.style_utilisée.valeurs[indice_it] = copie_valeur(it)
    }

    saufsi propriétés_parent {
        résolveuse.longueurs_relative_fonte_racine = ctx_calcul_style.longueurs_relative_fonte
    }
}

calcule_valeur_propriété :: fonc (ctx: *ContexteCalculStyle, info: *InfoTypePropriété, déclaration: *DéclarationPropriété)
{
    si info.sur_calcul_style {
        info.sur_calcul_style(déclaration, *ctx.propriétés.style, ctx)
    }
    sinon {
        calcule_valeur_propriété_générique(déclaration, *ctx.propriétés.style, ctx)
    }

    ctx.propriétés_calculées.active(info.id comme n16)
}

/* Corrige display en prenant en compte position et float.
 * https://www.w3.org/TR/2011/REC-CSS2-20110607/visuren.html#dis-pos-flo */
calcule_display_final :: fonc (propriétés: *PropriétésDeStyle)
{
    prop_display := propriétés.donne_valeur_calculée(IDPropriété.Display) comme *ValeurDisplay
    display := prop_display.donne_display()
    position := propriétés.donne_valeur_calculée(IDPropriété.Position)
    float := propriétés.donne_valeur_calculée(IDPropriété.Float)

    // 1. If 'display' has the value 'none', then 'position' and 'float' do not apply. In this case,
    // the element generates no box.
    si display.outer_type == Display.Type.None {
        retourne
    }

    // 2. Otherwise, if 'position' has the value 'absolute' or 'fixed', the box is absolutely positioned,
    // the computed value of 'float' is 'none', and display is set according to the table below.
    // The position of the box will be determined by the 'top', 'right', 'bottom' and 'left' properties
    // and the box's containing block.
    si position.est_mot_clé(PROP_absolute) || position.est_mot_clé(PROP_fixed) {
        propriétés.définis_valeur_calculée(IDPropriété.Float, donne_valeur_none())
        nouveau_display := crée_valeur_display(convertis_display_pour_position_ou_float(display))
        propriétés.définis_valeur_calculée(IDPropriété.Display, nouveau_display)
        retourne
    }

    // 3. Otherwise, if 'float' has a value other than 'none', the box is floated and 'display' is set
    // according to the table below.
    saufsi float.est_none() {
        nouveau_display := crée_valeur_display(convertis_display_pour_position_ou_float(display))
        propriétés.définis_valeur_calculée(IDPropriété.Display, nouveau_display)
        retourne
    }

    // 4. Otherwise, if the element is the root element, 'display' is set according to the table below,
    // except that it is undefined in CSS 2.1 whether a specified value of 'list-item' becomes a computed
    // value of 'block' or 'list-item'.
    // À FAIRE : test plus robuste pour définir l'élément racine.
    // À FAIRE : list-item.
    saufsi propriétés.parent {
        nouveau_display := crée_valeur_display(convertis_display_pour_position_ou_float(display))
        propriétés.définis_valeur_calculée(IDPropriété.Display, nouveau_display)
        retourne
    }

    // 5. Otherwise, the remaining 'display' property values apply as specified.

    /* The display value of a flex item is blockified: if the specified display of an in-flow child
     * of an element generating a flex container is an inline-level value, it computes to its block-level
     * equivalent. (See CSS2.1§9.7 [CSS21] and CSS Display [CSS3-DISPLAY] for details on this type of
     * display value conversion.) */
    display_parent := propriétés.parent.donne_valeur_calculée(IDPropriété.Display).donne_display()
    si display_parent.inner_type == Display.Type.Flex {
        nouveau_display := crée_valeur_display(blocify_display(display))
        propriétés.définis_valeur_calculée(IDPropriété.Display, nouveau_display)
    }
}

convertis_display_pour_position_ou_float :: fonc (spécifié: Display) -> Display
{
    // À FAIRE : display-internal
    résultat := spécifié

    si spécifié.outer_type == Display.Type.Inline {
        résultat.outer_type = Display.Type.Block

        /* Ignore également flex, https://www.w3.org/TR/css-flexbox-1/#flex-containers :
         * If an element’s specified display is inline-flex, then its display property computes to flex
         * in certain circumstances: the table in CSS 2.1 Section 9.7 is amended to contain an additional
         * row, with inline-flex in the "Specified Value" column and flex in the "Computed Value" column. */
        si spécifié.inner_type != Display.Type.Table && spécifié.inner_type != Display.Type.Flex {
            résultat.inner_type = Display.Type.FlowRoot
        }
    }

    retourne résultat
}

/* https://www.w3.org/TR/css-display-3/#blockify */
blocify_display :: fonc (spécifié: Display) -> Display
{
    si spécifié.outer_type == Display.Type.Inline {
        spécifié.outer_type = Display.Type.Block

        /* For legacy reasons, if an inline block box (inline flow-root) is blockified,
         * it becomes a block box (losing its flow-root nature). */
        si spécifié.inner_type == Display.Type.FlowRoot {
            spécifié.inner_type = Display.Type.Flow
        }
    }

    retourne spécifié
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Génération d'arbres de disposition.
 * \{ */

donne_arbre_de_disposition_ajourné :: fonc (document: *HTML.Document, largeur: z32, hauteur: z32) -> *ArbreDeDisposition
{
    ajournement := document.ajournement_arbre

    si document.arbre_de_disposition == nul || ajournement.Construction {
        si document.arbre_de_disposition {
            détruit_arbre(document.arbre_de_disposition)
            document.arbre_de_disposition = nul
        }
        crée_arbre_de_disposition(document, largeur, hauteur)
    }
    sinon si ajournement.Disposition {
        dispose_arbre(document.globales_dessin, document.arbre_de_disposition, largeur, hauteur)
    }
    sinon si ajournement.StackingContext {
        détruit_stacking_context(document.arbre_de_disposition.stacking_context)
        document.arbre_de_disposition.stacking_context = construit_arbre_de_stacking_contexts(document.arbre_de_disposition, document.arbre_de_disposition.racine)
    }

    document.ajournement_arbre = AjournementArbre.zéro

    retourne document.arbre_de_disposition
}

crée_arbre_de_disposition :: fonc (document: *HTML.Document, largeur: z32, hauteur: z32)
{
    html := HTML.donne_élément_html(document)
    saufsi html {
        retourne
    }

    saufsi document.feuille_de_style_agent {
        document.feuille_de_style_agent = HTML.donne_feuille_de_style_défaut()
        tableau_insère_indice(*document.feuilles_de_style, document.feuille_de_style_agent, 0)

        tableau_insère_indice(*document.feuilles_de_style, HTML.donne_feuille_de_style_presentational_hints(), 1)

        si HTML.est_en_mode_quirks(document) {
            tableau_insère_indice(*document.feuilles_de_style, HTML.donne_feuille_de_style_quirks(), 2)
        }
    }

    saufsi document.globales_dessin {
        document.globales_dessin = crée_globales_dessin()
    }

    saufsi document.résolveuse_style {
        document.résolveuse_style = crée_résolveuse_style(document, largeur, hauteur)
    }

    résultat := loge(ArbreDeDisposition)

    résolveuse := document.résolveuse_style

    /* À FAIRE : ceci peut changer mais comment est encore inconnue. */
    html.pseudo_classes.Root = vrai

    créatrice: CréatriceArbre
    créatrice.arbre = résultat
    créatrice.résolveuse = résolveuse

    crée_box_pour_élément(*créatrice, nul, html)
    résultat.racine = html.box

    // imprime("Créé % box(s)\n", résultat.boxes.taille)

    dispose_arbre(document.globales_dessin, résultat, largeur, hauteur)

    // imprime_arbre(résultat)

    si document.arbre_de_disposition {
        détruit_arbre(document.arbre_de_disposition)
        document.arbre_de_disposition = nul
    }

    document.arbre_de_disposition = résultat

    résultat.stacking_context = construit_arbre_de_stacking_contexts(résultat, résultat.racine)
}

dispose_arbre :: fonc (globales: *GlobalesDessin, arbre: *ArbreDeDisposition, largeur: z32, hauteur: z32)
{
    arbre.boxes_position_absolue = 0
    arbre.boxes_position_float = 0

    pour arbre.boxes {
        saufsi it.propriétés {
            continue
        }

        float := it.propriétés.donne_valeur_calculée(IDPropriété.Float)
        saufsi float.est_none() {
            arbre.boxes_position_float += 1
        }

        position := it.propriétés.donne_valeur_calculée(IDPropriété.Position)
        si position.est_mot_clé(PROP_absolute) || position.est_mot_clé(PROP_fixed) {
            arbre.boxes_position_absolue += 1
        }
    }

    initial_containing_block: ContainingBlock
    initial_containing_block.rect.hauteur = hauteur comme r32
    initial_containing_block.rect.largeur = largeur comme r32
    initial_containing_block.box = arbre.racine

    ctx: ContexteDeFormattage
    ctx.arbre = arbre
    ctx.globales = globales
    ctx.initial_containing_block = *initial_containing_block

    boites_absolues: GardeBoitesAbsolues
    diffère déloge(boites_absolues.boites)

    ctx.boites_absolues = *boites_absolues

    ctx_calcul_style: ContexteCalculStyle
    ctx_calcul_style.globales = globales
    initialise_métriques_fonte(*ctx_calcul_style.longueurs_relative_fonte_racine, arbre.racine.propriétés, globales)
    ctx_calcul_style.largeur_canevas = largeur comme r32
    ctx_calcul_style.hauteur_canevas = hauteur comme r32

    ctx.ctx_calcul_style = *ctx_calcul_style

    available: AvailableSpace
    available.width = AvailableSize(largeur comme r64)
    available.height = AvailableSize(hauteur comme r64)

    mesure(arbre.racine, *ctx, ModeDeFormattage.Normal, PersonnalisationCotation(), available)

    largeur_descendants, hauteur_descendants := donne_taille_descendants(arbre.racine)
    // imprime("taille arbre : %x%, descedants %x%\n", arbre.racine.modèle_de_boite.marge.largeur, arbre.racine.modèle_de_boite.marge.hauteur, largeur_descendants, hauteur_descendants)

    si hauteur_descendants > hauteur comme r32 {
        si arbre.défilement_vertical {
            ajourne(arbre.défilement_vertical, largeur comme r32, hauteur comme r32, hauteur_descendants)
        }
        sinon {
            arbre.défilement_vertical = crée_barre_de_défilement(largeur comme r32, hauteur comme r32, hauteur_descendants)
        }

        overflow := arbre.racine.propriétés.donne_valeur_utilisée(IDPropriété.OverflowY)
        arbre.défilement_vertical.est_visible = overflow.est_mot_clé(PROP_visible) || overflow.est_mot_clé(PROP_scroll)
    }
    sinon {
        détruit(arbre.défilement_vertical)
        arbre.défilement_vertical = nul
    }

    // imprime_statistiques(arbre)
}

donne_taille_descendants :: fonc (box: *Box) -> (largeur: r32, hauteur: r32)
{
    largeur = 0.0
    hauteur = 0.0

    pour ItératriceArbre(box) {
        si it.table_virtuelle.type == TextBox {
            continue
        }

        position_x := it.modèle_de_boite.marge.x + it.modèle_de_boite.marge.largeur
        position_y := it.modèle_de_boite.marge.y + it.modèle_de_boite.marge.hauteur

        // À FAIRE : prendre en compte le débordement des enfants du box courant

        si largeur < position_x {
            largeur = position_x
        }
        si hauteur < position_y {
            hauteur = position_y
        }
    }

    retourne largeur, hauteur
}

CréatriceArbre :: struct {
    résolveuse: *RésolveuseStyle
    arbre: *ArbreDeDisposition
}

crée_box_pour_élément :: fonc (empl créatrice: *CréatriceArbre, parent: *Box, noeud: *HTML.Node)
{
    si HTML.est_texte(noeud) {
        crée_box_pour_texte(créatrice, parent comme *BlockBox, (noeud comme *HTML.Text).données, noeud comme *HTML.Text)
        retourne
    }

    saufsi HTML.est_élément(noeud) {
        retourne
    }

    élément := noeud comme *HTML.Element

    propriétés_parent: *PropriétésDeStyle
    si parent {
        propriétés_parent = parent.propriétés
    }

    propriétés := résoud_style(résolveuse, élément, nul, propriétés_parent)

    display := propriétés.donne_valeur_calculée(IDPropriété.Display).donne_display()
    si display.outer_type == Display.Type.None {
        détruit_propriétés(propriétés)
        retourne
    }

    ignore_enfants := faux

    résultat: *Box
    si élément.local_name == HTML.TAG_img {
        img := élément comme *HTML.HTMLImageElement
        représentation_image := HTML.donne_représentation_image(img)

        si représentation_image == HTML.ReprésentationImage.RIEN {
            détruit_propriétés(propriétés)
            retourne
        }

        si représentation_image == HTML.ReprésentationImage.TEXTE_ALT {
            résultat = crée_box_pour_display(arbre, display, élément)
            crée_box_pour_texte(créatrice, résultat comme *BlockBox, HTML.donne_attribut(img, HTML.ATTR_alt).donne_chaine_utf16(), nul)
        }
        sinon {
            résultat = crée_image_box(arbre, img)
        }
    }
    sinon si élément.local_name == HTML.TAG_input {
        input_element := élément comme *HTML.HTMLInputElement
        si HTML.is_text_entry_widget(input_element) {
            résultat = crée_text_input_box(arbre, input_element)
        }
        sinon si HTML.is_button_widget(input_element) {
            résultat = crée_button_box(arbre, input_element)
        }
        sinon si HTML.is_radio_button_widget(input_element) {
            résultat = crée_radio_button_box(arbre, input_element)
        }
        sinon si HTML.is_checkbox_widget(input_element) {
            résultat = crée_checkbox_box(arbre, input_element)
        }
        sinon {
            résultat = crée_box_pour_display(arbre, display, élément)
        }
    }
    sinon si élément.local_name == HTML.TAG_textarea {
        résultat = crée_textarea_box(arbre, élément comme *HTML.HTMLTextAreaElement)
    }
    sinon si élément.local_name == HTML.TAG_canvas {
        résultat = crée_canvas_box(arbre, élément comme *HTML.HTMLCanvasElement)
    }
    sinon si élément.local_name == HTML.TAG_select {
        résultat = crée_select_box(arbre, élément comme *HTML.HTMLSelectElement)
        ignore_enfants = vrai
    }
    sinon si élément.local_name == HTML.TAG_object && (élément comme *HTML.HTMLObjectElement).chose_représentée == HTML.ChoseReprésentée.DONNÉES {
        résultat = crée_object_box(arbre, élément comme *HTML.HTMLObjectElement)
        ignore_enfants = vrai
    }
    sinon {
        résultat = crée_box_pour_display(arbre, display, élément)
    }

    table: *TableBox
    si résultat.table_virtuelle.type == TableWrapperBox {
        table = (résultat comme *TableWrapperBox).table
    }

    élément.box = résultat
    résultat.propriétés = propriétés
    si table {
        résultat.propriétés = résoud_style(résolveuse, élément, nul, propriétés_parent)

        /* The computed values of properties 'position', 'float', 'margin-*',
         * 'top', 'right', 'bottom', and 'left' on the table element are used
         * on the table wrapper box and not the table box
         * https://www.w3.org/TR/2011/REC-CSS2-20110607/tables.html#model */
        table.propriétés = propriétés

        ids := [
            IDPropriété.MarginBottom, IDPropriété.MarginTop, IDPropriété.MarginLeft, IDPropriété.MarginRight,
            IDPropriété.Top, IDPropriété.Bottom, IDPropriété.Left, IDPropriété.Right,
            IDPropriété.Position, IDPropriété.Float
        ]

        pour ids {
            table.propriétés.définis_valeur_calculée(it, résolveuse.valeurs_initiales.valeurs[it])
        }
    }

    si parent {
        parent.ajoute_enfant(résultat)
    }

    si ignore_enfants {
        retourne
    }

    nouveau_parent := résultat
    si table {
        nouveau_parent = table
    }

    crée_box_pour_pseudo_élément(créatrice, résultat, élément, PROP_before)

    pour noeud.enfants {
        crée_box_pour_élément(créatrice, nouveau_parent, it)
    }

    crée_box_pour_pseudo_élément(créatrice, résultat, élément, PROP_after)
    
    corrige_hiérarchie(résultat, créatrice)
}

crée_box_pour_texte :: fonc (empl créatrice: *CréatriceArbre, parent: *BlockBox, texte_original: ChaineUTF16, noeud: *HTML.Text)
{
    /* Les textes doivent une boite inline anonyme autour d'eux. */
    résultat := arbre.crée_box(InlineBox)
    résultat.est_boite_anonyme_pour_texte = vrai
    crée_style_pour_bloc_anonyme(résolveuse, résultat, parent, Display.Type.Inline)
    parent.ajoute_enfant(résultat)

    texte := arbre.crée_box(TextBox)
    texte.texte_original = texte_original
    texte.noeud = noeud
    si noeud {
        noeud.box = texte
    }
    résultat.ajoute_enfant(texte)
}

crée_box_pour_display :: fonc (arbre: *ArbreDeDisposition, display: Display, élément: *HTML.Element) -> *Box
{
    si display.inner_type == Display.Type.Table {
        wrapper_box := arbre.crée_box(TableWrapperBox)
        wrapper_box.noeud = élément

        box := arbre.crée_box(TableBox)
        wrapper_box.table = box

        wrapper_box.ajoute_enfant(box)
        retourne wrapper_box
    }
    si display.inner_type == Display.Type.TableCaption {
        box := arbre.crée_box(CaptionBox)
        box.noeud = élément
        retourne box
    }
    si display.inner_type == Display.Type.TableColumn {
        box := arbre.crée_box(TableColumnBox)
        box.noeud = élément
        retourne box
    }
    si display.inner_type == Display.Type.TableColumnGroup {
        box := arbre.crée_box(TableColumnGroupBox)
        box.noeud = élément
        retourne box
    }
    si display.inner_type == Display.Type.TableCell {
        box := arbre.crée_box(TableCellBox)
        box.noeud = élément
        retourne box
    }
    si display.inner_type == Display.Type.TableRow {
        box := arbre.crée_box(TableRowBox)
        box.noeud = élément
        retourne box
    }
    si display.inner_type == Display.Type.TableFooterGroup {
        box := arbre.crée_box(TableFooterGroupBox)
        box.noeud = élément
        retourne box
    }
    si display.inner_type == Display.Type.TableHeaderGroup {
        box := arbre.crée_box(TableHeaderGroupBox)
        box.noeud = élément
        retourne box
    }
    si display.inner_type == Display.Type.TableRowGroup {
        box := arbre.crée_box(TableRowGroupBox)
        box.noeud = élément
        retourne box
    }
    si display.outer_type == Display.Type.Block || display.inner_type == Display.Type.Flex {
        bloc := arbre.crée_box(BlockBox)
        bloc.noeud = élément
        retourne bloc
    }
    si élément && élément.local_name == HTML.TAG_br {
        bris := arbre.crée_box(BreakBox)
        bris.noeud = élément
        retourne bris
    }

    inline := arbre.crée_box(InlineBox)
    inline.noeud = élément
    retourne inline
}

crée_box_pour_pseudo_élément :: fonc (empl créatrice: *CréatriceArbre, parent: *Box, élément: *HTML.Element, ident_pseudo_element: CSSOMString)
{
    pseudo_element := PseudoElement(ident_pseudo_element)
    propriétés_pseudo := résoud_style(résolveuse, élément, *pseudo_element, parent.propriétés)
    saufsi propriétés_pseudo {
        retourne
    }

    display := propriétés_pseudo.donne_valeur_calculée(IDPropriété.Display).donne_display()
    si display.outer_type == Display.Type.None {
        détruit_propriétés(propriétés_pseudo)
        retourne
    }

    content := propriétés_pseudo.donne_valeur_calculée(IDPropriété.Content)
    si ident_pseudo_element == PROP_before || ident_pseudo_element == PROP_after {
        si content.est_mot_clé(PROP_none) || content.est_mot_clé(PROP_normal) {
            détruit_propriétés(propriétés_pseudo)
            retourne
        }
    }

    box := crée_box_pour_display(arbre, display, nul)
    box.propriétés = propriétés_pseudo
    box.est_pseudo_element = vrai

    si box.table_virtuelle.type == TableWrapperBox {
        table := (box comme *TableWrapperBox).table
        table.propriétés = résoud_style(résolveuse, élément, *pseudo_element, parent.propriétés)
    }

    ajoute_enfant(parent, box)

    si content.est_string() {
        crée_box_pour_texte(créatrice, box comme *BlockBox, content.donne_string().donne_chaine_utf16(), nul)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Requête image.
 * \{ */

donne_image_pour_url :: fonc (ctx: *ContexteDessin, url_string: chaine) -> Optionnel(NouvelleImage)
{
    données_image := HTML.donne_image_pour_url(ctx.document, url_string)

    si données_image.état == HTML.ÉtatRequêteImage.Succès {
        retourne données_image.données
    }

    si données_image.état == HTML.ÉtatRequêteImage.Échec {
        retourne
    }

    si données_image.état == HTML.ÉtatRequêteImage.EnCours {
        retourne
    }

    url_src := HTML.basic_url_parser(url_string)

    HTML.définis_état_requête_image(ctx.document, url_string, HTML.ÉtatRequêteImage.EnCours)

    RappelProcessResponse :: struct {
        empl base: HTML.BaseProcessResponse

        document: *HTML.Document
        request: *HTML.Request
        url_string: chaine
    }

    sur_rappel_process_response :: fonc (base: *HTML.BaseProcessResponse, réponse: *HTML.Response)
    {
        diffère HTML.détruit_response(réponse)

        rappel := base comme *RappelProcessResponse

        saufsi réponse.body_info {
            HTML.définis_état_requête_image(rappel.document, rappel.url_string, HTML.ÉtatRequêteImage.Échec)
            retourne
        }

        content_type := réponse.body_info.content_type
        saufsi est_type_mime_image(content_type) {
            HTML.définis_état_requête_image(rappel.document, rappel.url_string, HTML.ÉtatRequêteImage.Échec)
            retourne
        }

        contenu := réponse.body.Quelque

        image_data: NouvelleImage
        saufsi HTML.décode_image(contenu, content_type, *image_data) {
            HTML.définis_état_requête_image(rappel.document, rappel.url_string, HTML.ÉtatRequêteImage.Échec)
            retourne
        }

        HTML.définis_données_image(rappel.document, rappel.url_string, image_data)
        HTML.invalide_style_pour_image(rappel.document)
    }

    sur_destruction_process_response :: fonc (base: *HTML.BaseProcessResponse)
    {
        rappel := base comme *RappelProcessResponse
        HTML.détruit_request(rappel.request)
        déloge(rappel)
    }

    process_response := loge(RappelProcessResponse)
    process_response.document = ctx.document
    process_response.url_string = url_string
    process_response.sur_rappel = sur_rappel_process_response
    process_response.sur_destruction = sur_destruction_process_response

    request := loge(HTML.Request)
    request.client = HTML.donne_relevant_settings_object(ctx.document)
    request.destination = HTML.Request.DestinationType.Image
    request.mode = HTML.Request.Mode.No_CORS
    request.redirect_mode = HTML.Request.RedirectMode.Follow
    HTML.définis_url(request, url_src)
    process_response.request = request

    user_agent := HTML.donne_user_agent(ctx.document)
    fetch_controller := HTML.fetch(user_agent, request, process_response = process_response)
    diffère HTML.détruit_fetch_controller(fetch_controller)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Box
 * \{ */

ModèleDeBoite :: struct {
    marge: RectanglePosDim(r32)
    bordure: RectanglePosDim(r32)
    rembourrage: RectanglePosDim(r32)
    contenu: RectanglePosDim(r32)
}

décale_horizontalement :: fonc (modèle: &ModèleDeBoite, delta: r32)
{
    modèle.marge.x += delta
    modèle.bordure.x += delta
    modèle.rembourrage.x += delta
    modèle.contenu.x += delta
}

décale_verticalement :: fonc (modèle: &ModèleDeBoite, delta: r32)
{
    modèle.marge.y += delta
    modèle.bordure.y += delta
    modèle.rembourrage.y += delta
    modèle.contenu.y += delta
}

définis_hauteur_contenu :: fonc (modèle: &ModèleDeBoite, hauteur: r32)
{
    modèle.marge.hauteur = hauteur
    modèle.bordure.hauteur = hauteur
    modèle.contenu.hauteur = hauteur
    modèle.rembourrage.hauteur = hauteur
}

incrémente_hauteur_contenu :: fonc (modèle: &ModèleDeBoite, hauteur: r32)
{
    modèle.marge.hauteur += hauteur
    modèle.bordure.hauteur += hauteur
    modèle.contenu.hauteur += hauteur
    modèle.rembourrage.hauteur += hauteur
}

définis_largeur_contenu :: fonc (modèle: &ModèleDeBoite, largeur: r32)
{
    modèle.marge.largeur = largeur
    modèle.bordure.largeur = largeur
    modèle.contenu.largeur = largeur
    modèle.rembourrage.largeur = largeur
}

définis_largeur :: fonc (modèle: &ModèleDeBoite, largeur: r32)
{
    modèle.contenu.largeur = largeur
}

définis_hauteur :: fonc (modèle: &ModèleDeBoite, hauteur: r32)
{
    modèle.contenu.hauteur = hauteur
}

donne_ligne_de_base_marge :: fonc (modèle: ModèleDeBoite) -> InfoLigneDeBase
{
    résultat : InfoLigneDeBase = ---
    résultat.origine = modèle.marge.y
    résultat.position = modèle.marge.y + modèle.marge.hauteur
    retourne résultat
}

donne_ligne_de_base_contenu :: fonc (modèle: ModèleDeBoite) -> InfoLigneDeBase
{
    résultat : InfoLigneDeBase = ---
    résultat.origine = modèle.contenu.y
    résultat.position = modèle.contenu.y + modèle.contenu.hauteur
    retourne résultat
}

/* Représente les cotations pour un axe donné du modèle de boite. */
CotationModèleDeBoite :: struct {
    marge_début: r32
    bordure_début: r32
    rembourrage_début: r32
    contenu: r32
    rembourrage_fin: r32
    bordure_fin: r32
    marge_fin: r32
}

donne_cotations_horizontales :: fonc (modèle: &ModèleDeBoite) -> CotationModèleDeBoite
{
    résultat: CotationModèleDeBoite
    résultat.marge_début = modèle.bordure.x - modèle.marge.x
    résultat.bordure_début = modèle.rembourrage.x - modèle.bordure.x
    résultat.rembourrage_début = modèle.contenu.x - modèle.rembourrage.x
    résultat.contenu = modèle.contenu.largeur
    résultat.rembourrage_fin = (modèle.rembourrage.x + modèle.rembourrage.largeur) - (modèle.contenu.x + modèle.contenu.largeur)
    résultat.bordure_fin = (modèle.bordure.x + modèle.bordure.largeur) - (modèle.rembourrage.x + modèle.rembourrage.largeur)
    résultat.marge_fin = (modèle.marge.x + modèle.marge.largeur) - (modèle.bordure.x + modèle.bordure.largeur)
    retourne résultat
}

donne_cotations_verticales :: fonc (modèle: &ModèleDeBoite) -> CotationModèleDeBoite
{
    résultat: CotationModèleDeBoite
    résultat.marge_début = modèle.bordure.y - modèle.marge.y
    résultat.bordure_début = modèle.rembourrage.y - modèle.bordure.y
    résultat.rembourrage_début = modèle.contenu.y - modèle.rembourrage.y
    résultat.contenu = modèle.contenu.hauteur
    résultat.rembourrage_fin = (modèle.rembourrage.y + modèle.rembourrage.hauteur) - (modèle.contenu.y + modèle.contenu.hauteur)
    résultat.bordure_fin = (modèle.bordure.y + modèle.bordure.hauteur) - (modèle.rembourrage.y + modèle.rembourrage.hauteur)
    résultat.marge_fin = (modèle.marge.y + modèle.marge.hauteur) - (modèle.bordure.y + modèle.bordure.hauteur)
    retourne résultat
}

imprime_cotation :: fonc (enchaineuse: *Enchaineuse, cotation: *CotationModèleDeBoite)
{
    imprime_dans_enchaineuse(enchaineuse, "[% % %] % [% % %]", cotation.marge_début, cotation.bordure_début, cotation.rembourrage_début, cotation.contenu, cotation.rembourrage_fin, cotation.bordure_fin, cotation.marge_fin)
}

InfoLigneDeBase :: struct {
    /* L'origine de la boite fournissant la ligne de base ; utilisée pour calculer un delta. */
    origine: r32
    /* La position de la ligne de base. */
    position: r32
}

TableVirtuelleBox :: struct {
    type: type_de_données

    sur_mesure: fonc (*Box, *ContexteDeFormattage, ModeDeFormattage, PersonnalisationCotation, AvailableSpace)(rien)
    sur_dessin: fonc (*Box, *ContexteDessin)(rien)
    sur_dessin_fragment: fonc (*Box, *Fragment, *LignesTenante, *ContexteDessin)(rien)
    sur_dessin_tampon_id: fonc (*Box, *ContexteDessin)(rien)
    sur_dessin_fragment_tampon_id: fonc (*Box, *Fragment, *ContexteDessin)(rien)
    sur_divise_en_lignes: fonc (*Box, *Enligneuse, ModeDeFormattage)(rien)
    sur_correction_hiérarchie: fonc(*Box, *CréatriceArbre)(rien)
    sur_donne_baseline: fonc(*Box)(Optionnel(InfoLigneDeBase))
}

__table_box_base := TableVirtuelleBox(type = Box)

Box :: struct {
    table_virtuelle := *__table_box_base

    id: n32
    id_stacking_context: n32
    propriétés: *PropriétésDeStyle

    parent: *Box
    enfants: [..]*Box

    noeud: *HTML.Node

    modèle_de_boite: ModèleDeBoite
    traite_comme_display_none: bool
    est_pseudo_element: bool
    fut_dessiné: bool
    est_boite_anonyme_pour_texte: bool

    MémoireVive :: struct {
        min_content_width: Optionnel(r64)
        max_content_width: Optionnel(r64)
    }

    mémoire_vive: MémoireVive
}

donne_propriétés :: fonc (box: *Box) -> *PropriétésDeStyle
{
    si box.table_virtuelle.type == TextBox {
        retourne donne_propriétés(box comme *TextBox)
    }
    si box.est_boite_anonyme_pour_texte {
        box = box.parent
        tantque est_box_anonyme(box) {
            box = box.parent
        }
    }
    retourne box.propriétés
}

détermine_fonte :: fonc (box: *Box, ctx: *ContexteDeFormattage) -> *Fonte
{
    globales := ctx.globales
    assert(globales != nul)
    retourne détermine_fonte(box, globales)
}

détermine_fonte :: fonc (box: *Box, globales: *GlobalesDessin) -> *Fonte
{
    propriétés := box.donne_propriétés()

    résultat := détermine_fonte(propriétés, globales)
    si box.table_virtuelle.type == TextBox {
        text_box := box comme *TextBox
        text_box.fonte = résultat
    }
    sinon si box.table_virtuelle.type == SelectBox {
        select_box := box comme *SelectBox
        select_box.fonte = résultat
    }
    retourne résultat
}

détermine_fonte :: fonc (propriétés: *PropriétésDeStyle, globales: *GlobalesDessin) -> *Fonte
{
    style := "normal"
    taille_fonte := propriétés.donne_valeur_utilisée(IDPropriété.FontSize).donne_pixels() comme r32

    font_weight := propriétés.donne_valeur_utilisée(IDPropriété.FontWeight).donne_number()
    graisse := donne_graisse_fonte_depuis_poids(font_weight)

    font_style := propriétés.donne_valeur_utilisée(IDPropriété.FontStyle).donne_mot_clé()
    si font_style == PROP_italic {
        style = "italic"
    }

    prop_font_family := propriétés.donne_valeur_utilisée(IDPropriété.FontFamily)

    si prop_font_family.est_mot_clé() {
        font_family := prop_font_family.donne_mot_clé()
        retourne globales.donne_fonte(font_family, style, graisse, taille_fonte)
    }
    
    si prop_font_family.est_string() {
        font_family := prop_font_family.donne_string()
        retourne globales.donne_fonte(font_family, style, graisse, taille_fonte)
    }

    assert(prop_font_family.est_liste())
    liste_fontes := prop_font_family.donne_liste()

    pour liste_fontes {
        font_family := it.donne_string()
        fonte := globales.donne_fonte(font_family, style, graisse, taille_fonte, faux)
        si fonte {
            retourne fonte
        }
    }

    retourne globales.donne_fonte(PROP_serif, style, graisse, taille_fonte)
}

donne_rectangle_rembourrage :: fonc (box: *Box) -> RectanglePosDim(r32)
{
    retourne box.modèle_de_boite.rembourrage
}

donne_rectangle_bordure :: fonc (box: *Box) -> RectanglePosDim(r32)
{
    retourne box.modèle_de_boite.bordure
}

donne_rectangle_contenu :: fonc (box: *Box) -> RectanglePosDim(r32)
{
    retourne box.modèle_de_boite.contenu
}

est_box_anonyme :: fonc (box: *Box) -> bool
{
    si box.table_virtuelle.type != BlockBox && box.table_virtuelle.type != InlineBox {
        retourne faux
    }

    block_box := box comme *BlockBox
    retourne block_box.noeud == nul
}

est_box_non_anonyme :: fonc (box: *Box) -> bool
{
    retourne !est_box_anonyme(box)
}

est_block_level :: fonc (box: *Box) -> bool
{
    assert(box.propriétés != nul)
    retourne donne_display(box).outer_type == Display.Type.Block
}

est_inline_level :: fonc (box: *Box) -> bool
{
    assert(box.propriétés != nul)
    retourne donne_display(box).outer_type == Display.Type.Inline
}

est_inline_block :: fonc (box: *Box) -> bool
{
    assert(box.propriétés != nul)
    display := donne_display(box)
    retourne display.outer_type == Display.Type.Inline && display.inner_type == Display.Type.FlowRoot
}

est_in_flow :: fonc (box: *Box) -> bool
{
    position := box.propriétés.donne_valeur_calculée(IDPropriété.Position)
    si position.est_mot_clé(PROP_absolute) || position.est_mot_clé(PROP_fixed) {
        retourne faux
    }

    float := box.propriétés.donne_valeur_calculée(IDPropriété.Float)
    saufsi float.est_none() {
        retourne faux
    }

    retourne vrai
}

est_block_container :: fonc (box: *Box) -> bool
{
    si box.table_virtuelle.type == BlockBox || box.table_virtuelle.type == TableWrapperBox || box.table_virtuelle.type == TableCellBox {
        retourne vrai
    }

    si box.est_inline_block() {
        retourne vrai
    }

    retourne faux
}

donne_display :: fonc (box: *Box) -> Display
{
    assert(box.propriétés != nul)
    retourne box.propriétés.donne_valeur_utilisée(IDPropriété.Display).donne_display()
}

donne_line_height :: fonc (box: *Box, ctx: *ContexteDeFormattage) -> r32
{
    fonte := détermine_fonte(box, ctx)
    retourne donne_line_height(box.propriétés, fonte)
}

donne_line_height :: fonc (propriétés: *PropriétésDeStyle, fonte: *Fonte) -> r32
{
    line_height := propriétés.donne_valeur_utilisée(IDPropriété.LineHeight)
    si line_height.est_pixels() {
        retourne line_height.donne_pixels() comme r32
    }

    métriques := fonte.donne_métriques_fonte()

    si line_height.est_number() {
        retourne line_height.donne_number() comme r32 * métriques.donne_hauteur_ligne()
    }

    assert(line_height.est_mot_clé(PROP_normal))
    retourne métriques.donne_hauteur_ligne()
}

donne_décalage_top_pour_relative :: fonc (box: *Box) -> r32
{
    top := box.propriétés.donne_valeur_utilisée(IDPropriété.Top)
    bottom := box.propriétés.donne_valeur_utilisée(IDPropriété.Bottom)

    si top.est_auto() && bottom.est_auto() {
        retourne 0.0
    }

    si top.est_auto() {
        retourne -bottom.donne_pixels() comme r32
    }

    retourne top.donne_pixels() comme r32
}

donne_décalage_left_pour_relative :: fonc (box: *Box) -> r32
{
    left := box.propriétés.donne_valeur_utilisée(IDPropriété.Left)
    right := box.propriétés.donne_valeur_utilisée(IDPropriété.Right)

    si left.est_auto() && right.est_auto() {
        retourne 0.0
    }
    
    si left.est_auto() {
        retourne -right.donne_pixels() comme r32
    }

    retourne left.donne_pixels() comme r32
}

donne_baseline :: fonc (box: *Box) -> Optionnel(InfoLigneDeBase)
{
    si box.table_virtuelle.sur_donne_baseline {
        résultat := box.table_virtuelle.sur_donne_baseline(box)
        si résultat.possède_valeur() {
            retourne résultat
        }

        si box.table_virtuelle.type == TextBox {
            retourne
        }
    }

    // À FAIRE : est-ce la bonne valeur ?
    retourne donne_ligne_de_base_marge(box.modèle_de_boite)
}

donne_élément :: fonc (box: *Box) -> *HTML.Element
{
    si box.noeud == nul {
        retourne nul
    }

    noeud := box.noeud
    saufsi HTML.est_élément(noeud) {
        retourne nul
    }

    retourne noeud comme *HTML.Element
}

donne_élément_récursif :: fonc (box: *Box) -> *HTML.Element
{
    box_courant := box

    tantque box_courant != nul {
        élément := box_courant.donne_élément()
        si élément {
            retourne élément
        }

        box_courant = box_courant.parent
    }

    retourne nul
}

imprime_élément :: fonc (box: *Box, message := "", récursif := faux)
{
    enchaineuse: Enchaineuse
    initialise_enchaineuse(*enchaineuse)
    diffère détruit_tampons(*enchaineuse)

    imprime_élément(*enchaineuse, box, message, récursif)
    copie_dans_sortie_standarde(*enchaineuse)
}

imprime_élément :: fonc (enchaineuse: *Enchaineuse, box: *Box, message: chaine, récursif := faux)
{
    élément := si récursif {
        box.donne_élément_récursif()
    }
    sinon {
        box.donne_élément()
    }

    si message {
        ajoute_au_tampon(enchaineuse, message, " : ")
    }

    saufsi élément {
        ajoute_au_tampon(enchaineuse, "<anonyme>\n")
        retourne
    }

    ajoute_au_tampon(enchaineuse, élément.local_name)

    id := élément.id
    saufsi id.est_vide() {
        ajoute_au_tampon(enchaineuse, "#", id)
    }

    classes := HTML.donne_attribut_ou_chaine_vide(élément, HTML.ATTR_class)
    saufsi classes.est_vide() {
        ajoute_au_tampon(enchaineuse, ".", classes)
    }

    ajoute_au_tampon(enchaineuse, "\n")
}

définis_position :: fonc (box: *Box, x: r32, y: r32)
{
    dx := x - box.modèle_de_boite.marge.x
    dy := y - box.modèle_de_boite.marge.y
    décale_horizontalement(box.modèle_de_boite, dx)
    décale_verticalement(box.modèle_de_boite, dy)
}

décale_vers_position :: fonc (box: *Box, x: r32, y: r32)
{
    dx := x - box.modèle_de_boite.marge.x
    dy := y - box.modèle_de_boite.marge.y
    décale(box, dx, dy)
}

décale :: fonc (box: *Box, x: r32, y: r32)
{
    décale_horizontalement(box.modèle_de_boite, x)
    décale_verticalement(box.modèle_de_boite, y)
    décale_contenu(box, x, y)
}

décale_contenu :: fonc (box: *Box, x: r32, y: r32)
{
    pour box.enfants {
        it.décale(x, y)
    }

    si box.table_virtuelle.type == BlockBox || box.table_virtuelle.type == InlineBox || box.table_virtuelle.type == TableCellBox {
        bloc := box comme *BlockBox
        saufsi bloc.lignes_tenante {
            retourne
        }
        pour * bloc.lignes_tenante.fragments {
            it.x += x
            it.y += y
        }
    }
}

donne_nom_classe :: fonc (box: *Box) -> chaine
{
    infos := __table_des_types[box.table_virtuelle.type] comme *InfoTypeStructure
    retourne infos.nom
}

donne_taille_en_octet :: fonc (box: *Box) -> n32
{
    infos := __table_des_types[box.table_virtuelle.type] comme *InfoTypeStructure
    retourne infos.taille_en_octet
}

donne_nom_classe_sans_suffixe :: fonc (box: *Box) -> chaine
{
    résultat := box.donne_nom_classe()
    suffixe :: "Box"
    si résultat.fini_par(suffixe) {
        résultat = recule(résultat, suffixe.taille)
    }
    retourne résultat
}

mesure :: fonc (box: *Box, ctx: *ContexteDeFormattage, mode: ModeDeFormattage, personnalisation: PersonnalisationCotation, available: AvailableSpace)
{
    si box.table_virtuelle.sur_mesure {
        box.table_virtuelle.sur_mesure(box, ctx, mode, personnalisation, available)
    }
}

ajoute_enfant :: fonc (parent: *Box, enfant: *Box)
{
    si enfant.table_virtuelle.type == CaptionBox && parent.table_virtuelle.type == TableBox {
        ajoute_enfant(parent.parent, enfant)
        retourne
    }

    enfant.parent = parent
    tableau_ajoute(*parent.enfants, enfant)
}

donne_curseur :: fonc (box: *Box) -> CursorType
{
    saufsi box.propriétés {
        retourne CursorType.auto
    }
    retourne box.propriétés.donne_valeur_utilisée(IDPropriété.Cursor).donne_cursor_type()
}

divise_en_lignes :: fonc (box: *Box, enligneuse: *Enligneuse, mode: ModeDeFormattage)
{
    si (box.table_virtuelle.type == TextBox || box.donne_display().inner_type == Display.Type.Flow) {
        si box.table_virtuelle.sur_divise_en_lignes {
            box.table_virtuelle.sur_divise_en_lignes(box, enligneuse, mode)
            retourne
        }

        pour box.enfants {
            divise_en_lignes(it, enligneuse, mode)
        }

        retourne
    }

    // À FAIRE : available space
    available : AvailableSpace = ---
    available.width = crée_min_content_size()
    available.height = crée_indefinite_size()
    box.mesure(enligneuse.ctx, mode, PersonnalisationCotation(), available)
    _ := enligneuse.ajoute_fragment(box, box.modèle_de_boite.marge.hauteur, box.modèle_de_boite.marge.largeur, Fragment.Type.InlineBlock)
}

corrige_hiérarchie :: fonc (box: *Box, créatrice: *CréatriceArbre)
{
    si box.table_virtuelle.sur_correction_hiérarchie {
        box.table_virtuelle.sur_correction_hiérarchie(box, créatrice)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ContainingBlock
 * https://www.w3.org/TR/2011/REC-CSS2-20110607/visudet.html#containing-block-details
 * https://drafts.csswg.org/css-display/#containing-block
 * https://www.w3.org/TR/css-position-3/#def-cb
 * \{ */

ContainingBlock :: struct {
    rect: RectanglePosDim(r32)
    box: *Box
}

crée_containing_block_pour_contenu :: fonc (box: *Box) -> ContainingBlock
{
    résultat: ContainingBlock
    résultat.rect = box.modèle_de_boite.contenu
    résultat.box = box
    retourne résultat
}

crée_containing_block_pour_rembourrage :: fonc (box: *Box) -> ContainingBlock
{
    résultat: ContainingBlock
    résultat.rect = box.modèle_de_boite.rembourrage
    résultat.box = box
    retourne résultat
}

donne_x :: fonc (bloc: &ContainingBlock) -> r32
{
    retourne bloc.rect.x
}

donne_y :: fonc (bloc: &ContainingBlock) -> r32
{
    retourne bloc.rect.y
}

donne_largeur :: fonc (bloc: &ContainingBlock) -> r32
{
    retourne bloc.rect.largeur
}

donne_hauteur :: fonc (bloc: &ContainingBlock) -> r32
{
    retourne bloc.rect.hauteur
}

donne_containing_block :: fonc (box: *Box, ctx: *ContexteDeFormattage) -> ContainingBlock
{
    // 1. The containing block in which the root element lives is a rectangle called the initial containing block.
    // For continuous media, it has the dimensions of the viewport and is anchored at the canvas origin;
    // it is the page area for paged media.
    // The 'direction' property of the initial containing block is the same as for the root element.
    si box.parent == nul {
        retourne ctx.donne_initial_containing_block()
    }

    // 2. For other elements, if the element's position is 'relative' or 'static',
    // the containing block is formed by the content edge of the nearest block
    // container ancestor box.
    position := box.propriétés.donne_valeur_utilisée(IDPropriété.Position)
    si position.est_mot_clé(PROP_relative) || position.est_mot_clé(PROP_static) {
        parent := box.parent

        tantque parent != nul {
            si est_block_container(parent) {
                retourne crée_containing_block_pour_contenu(parent)
            }

            parent = parent.parent
        }
    }
    // 3. If the element has 'position: fixed', the containing block is established by the viewport
    // in the case of continuous media or the page area in the case of paged media.
    sinon si position.est_mot_clé(PROP_fixed) {
        retourne ctx.donne_initial_containing_block()
    }
    // 4. If the element has 'position: absolute', the containing block is established by the nearest
    // ancestor with a 'position' of 'absolute', 'relative' or 'fixed', in the following way:
    sinon si position.est_mot_clé(PROP_absolute) {
        ancêtre := box.parent

        tantque ancêtre != nul {
            position_parent := ancêtre.propriétés.donne_valeur_utilisée(IDPropriété.Position)
            si position_parent.est_mot_clé(PROP_relative) || position_parent.est_mot_clé(PROP_absolute) || position_parent.est_mot_clé(PROP_fixed) {
                arrête
            }

            ancêtre = ancêtre.parent
        }

        si ancêtre {
            // À FAIRE : 1. In the case that the ancestor is an inline element, the containing block is the bounding
            // box around the padding boxes of the first and the last inline boxes generated for that element.
            // In CSS 2.1, if the inline element is split across multiple lines, the containing block is undefined.

            // À FAIRE : 2. Otherwise, the containing block is formed by the padding edge of the ancestor.
            retourne crée_containing_block_pour_rembourrage(ancêtre)
        }
    }

    // If there is no such ancestor, the containing block is the initial containing block.
    retourne ctx.donne_initial_containing_block()
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom BoiteDeLigne
 * Boite pour tenir les fragments de chaque ligne pour les dispositions
 * « inline ».
 * https://www.w3.org/TR/2011/REC-CSS2-20110607/visuren.html#line-box
 * \{ */

Fragment :: struct {
    Type :: énum {
        Normal
        MargeDébut
        MargeFin
        RembourrageDébut
        RembourrageFin
        InlineBlock
        NouvelleLigne
    }

    box: *Box
    indice_début: z64
    indice_fin: z64
    type: Type

    x: r32
    y: r32
    hauteur: r32
    largeur: r32
}

donne_rectangle :: fonc (fragment: *Fragment) -> RectanglePosDim(r32)
{
    rect: RectanglePosDim(r32)
    rect.x = fragment.x
    rect.y = fragment.y
    rect.largeur = fragment.largeur
    rect.hauteur = fragment.hauteur
    retourne rect
}

BoiteDeLigne :: struct {
    largeur_max: r32
    position_x: r32
    position_y: r32

    premier_fragment: z64
    dernier_fragment: z64
    largeur_courante: r32
    hauteur_contenu: r32

    top: r64
    bottom: r64
    baseline: r64
}

peut_ajouter_fragment :: fonc (boite: *BoiteDeLigne, largeur: r32) -> bool
{
    retourne (boite.largeur_courante + largeur) <= boite.largeur_max
}

garantis_hauteur_minimale :: fonc (boite: *BoiteDeLigne, hauteur: r32)
{
    boite.hauteur_contenu = max(boite.hauteur_contenu, hauteur)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom LignesTenante
 * Structure pour tenir les BoiteDeLignes et leurs fragments d'un bloc.
 * \{ */

LignesTenante :: struct {
    bloc: *BlockBox
    lignes: [..]BoiteDeLigne
    fragments: [..]Fragment

    position_y_courante: r32
}

crée_lignes_tenante :: fonc (arbre: *ArbreDeDisposition) -> *LignesTenante
{
    résultat := loge(LignesTenante)
    tableau_ajoute(*arbre.lignes_tenantes, résultat)
    retourne résultat
}

réinitialise :: fonc (lignes_tenante: *LignesTenante)
{
    lignes_tenante.lignes.taille = 0
    lignes_tenante.fragments.taille = 0
}

détruit_données :: fonc (lignes_tenante: *LignesTenante)
{
    déloge(lignes_tenante.lignes)
    déloge(lignes_tenante.fragments)
}

détruit :: fonc (lignes_tenante: *LignesTenante)
{
    détruit_données(lignes_tenante)
    déloge(lignes_tenante)
}

donne_ligne_courante :: fonc (lignes_tenante: *LignesTenante, ctx: *ContexteDeFormattageInline) -> *BoiteDeLigne
{
    si lignes_tenante.lignes.taille == 0 {
        retourne ajoute_ligne(lignes_tenante, ctx)
    }

    retourne *lignes_tenante.lignes[lignes_tenante.lignes.taille - 1]
}

ajoute_ligne :: fonc (lignes_tenante: *LignesTenante, ctx: *ContexteDeFormattageInline) -> *BoiteDeLigne
{
    si lignes_tenante.lignes.taille {
        lignes_tenante.position_y_courante += lignes_tenante.lignes[lignes_tenante.lignes.taille - 1].hauteur_contenu
    }

    décalage_x := lignes_tenante.bloc.modèle_de_boite.contenu.x
    largeur_contenu := lignes_tenante.bloc.modèle_de_boite.contenu.largeur

    décalage_ligne, largeur_ligne := donne_position_et_largeur_ligne(ctx, décalage_x, décalage_x + largeur_contenu, lignes_tenante.position_y_courante)

    résultat := tableau_ajoute_élément(*lignes_tenante.lignes)
    résultat.position_x = décalage_ligne
    résultat.position_y = lignes_tenante.position_y_courante
    résultat.largeur_max = largeur_ligne

    résultat.premier_fragment = lignes_tenante.fragments.taille
    /* -1 pour que le calcul du nombre de fragments se fasse via "fin - début + 1", et
     * avoir un résultat correcte quand il n'y a aucun fragment dans la ligne. */
    résultat.dernier_fragment = lignes_tenante.fragments.taille - 1
    retourne résultat
}

ajoute_fragment :: fonc (lignes_tenante: *LignesTenante, fragment: &Fragment) -> z64
{
    résultat := lignes_tenante.fragments.taille
    tableau_ajoute(*lignes_tenante.fragments, fragment)
    retourne résultat
}

donne_fragments_ligne :: fonc (lignes_tenante: *LignesTenante, ligne: *BoiteDeLigne) -> []Fragment
{
    retourne donne_fragments(lignes_tenante, ligne.premier_fragment, ligne.dernier_fragment + 1)
}

donne_fragments :: fonc (lignes_tenante: *LignesTenante, premier_fragment: z64, dernier_fragment: z64) -> []Fragment
{
    résultat : []Fragment = ---
    résultat.pointeur = lignes_tenante.fragments.pointeur + premier_fragment
    résultat.taille = dernier_fragment - premier_fragment
    retourne résultat
}

donne_baseline :: fonc (lignes_tenante: *LignesTenante, indice: z64) -> InfoLigneDeBase
{
    ligne := lignes_tenante.lignes[indice]
    // À FAIRE : baseline de la fonte
    résultat : InfoLigneDeBase = ---
    résultat.origine = ligne.position_y
    résultat.position = ligne.hauteur_contenu
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Enligneuse
 * \{ */

Enligneuse :: struct {
    ctx: *ContexteDeFormattageInline
    bloc_contenant: *BlockBox
    ligne_courante: *BoiteDeLigne
    mode_de_formattage: ModeDeFormattage
}

divise_en_lignes :: fonc (enligneuse: *Enligneuse, bloc_contenant: *BlockBox, mode: ModeDeFormattage)
{
    réinitialise_lignes(bloc_contenant, enligneuse.ctx.arbre)
    enligneuse.bloc_contenant = bloc_contenant
    enligneuse.mode_de_formattage = mode
    bloc_contenant.lignes_tenante.bloc = bloc_contenant
    bloc_contenant.lignes_tenante.position_y_courante = bloc_contenant.modèle_de_boite.contenu.y

    pour bloc_contenant.enfants {
        divise_en_lignes(it, enligneuse, mode)
    }
}

donne_lignes_tenante :: fonc (empl enligneuse: *Enligneuse) -> *LignesTenante
{
    retourne bloc_contenant.lignes_tenante
}

ajoute_ligne :: fonc (empl enligneuse: *Enligneuse) -> *BoiteDeLigne
{
    ligne_courante = ajoute_ligne(enligneuse.bloc_contenant.lignes_tenante, ctx)
    retourne ligne_courante
}

peut_ajouter_fragment :: fonc (empl enligneuse: *Enligneuse, largeur: r32) -> bool
{
    discr mode_de_formattage {
        Normal {
            retourne ligne_courante.peut_ajouter_fragment(largeur)
        }
        ToutesLesBrisuresDeLigne {
            retourne faux
        }
        BrisureDeLigneExplicite {
            /* Les <br> ajouterons une ligne explicitement. */
            retourne vrai
        }
    }
    retourne faux
}

ajoute_fragment :: fonc (empl enligneuse: *Enligneuse, box: *Box, indice_début: z64, indice_fin: z64, hauteur: r32, largeur: r32, type := Fragment.Type.Normal) -> z64
{
    lignes_tenante := enligneuse.bloc_contenant.lignes_tenante

    ligne_courante = lignes_tenante.donne_ligne_courante(ctx)
    si mode_de_formattage == ModeDeFormattage.Normal && !ligne_courante.peut_ajouter_fragment(largeur) {
        ligne_courante = lignes_tenante.ajoute_ligne(ctx)
    }

    fragment: Fragment
    fragment.box = box
    fragment.indice_début = indice_début
    fragment.indice_fin = indice_fin
    fragment.hauteur = hauteur
    fragment.largeur = largeur
    fragment.x = ligne_courante.position_x + ligne_courante.largeur_courante
    fragment.y = ligne_courante.position_y
    fragment.type = type

    ligne_courante.largeur_courante += largeur
    ligne_courante.garantis_hauteur_minimale(hauteur)

    ligne_courante.dernier_fragment = ajoute_fragment(lignes_tenante, fragment)

    résultat := ligne_courante.dernier_fragment

    si fragment.type == Fragment.Type.NouvelleLigne {
        _ := lignes_tenante.ajoute_ligne(ctx)
    }

    retourne résultat
}

ajoute_fragment :: fonc (enligneuse: *Enligneuse, box: *Box, hauteur: r32, largeur: r32, type: Fragment.Type) -> z64
{
    retourne ajoute_fragment(enligneuse, box, 0, 0, hauteur, largeur, type)
}

garantis_hauteur_minimale :: fonc (enligneuse: *Enligneuse, hauteur: r32)
{
    enligneuse.ligne_courante.garantis_hauteur_minimale(hauteur)
}

peut_ignorer_espace_blanche_en_début_de_ligne :: fonc (empl enligneuse: *Enligneuse) -> bool
{
    /* La ligne peut être nulle dans certains cas quand nous n'avons pas encore disposé de fragments. */
    retourne ligne_courante == nul || ligne_courante.largeur_courante == 0.0
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom BlockBox
 * \{ */

#portée_fichier

__table_block_box := TableVirtuelleBox(
    type = BlockBox,
    sur_mesure = block_box_sur_mesure,
    sur_dessin = block_box_sur_dessin,
    sur_dessin_tampon_id = block_box_sur_dessin_tampon_id,
    sur_correction_hiérarchie = block_box_corrige_hiérarchie,
    sur_donne_baseline = block_box_donne_baseline)

#portée_export

/* Créé pour chaque box hors texte */
BlockBox :: struct {
    empl base: Box
    table_virtuelle = *__table_block_box

    lignes_tenante: *LignesTenante

    est_disposition_inline: bool
}

réinitialise_lignes :: fonc (box: *BlockBox, arbre: *ArbreDeDisposition)
{
    saufsi box.lignes_tenante {
        box.lignes_tenante = arbre.crée_lignes_tenante()
    }

    réinitialise(box.lignes_tenante)
}

détermine_disposition_interne :: fonc (box: *BlockBox)
{
    si box.enfants.taille == 0 || box.est_inline_block() {
        box.est_disposition_inline = faux
        retourne
    }

    /* Crée des blocs anonymes pour envelopper les blocs inlines si au moins un enfant est un bloc.
     * Voir définition de "block container box" :
     * https://www.w3.org/TR/2011/REC-CSS2-20110607/visuren.html#block-boxes */
    doit_formatter_en_blocs := faux

    pour box.enfants {
        si it.est_block_level() {
            doit_formatter_en_blocs = vrai
            arrête
        }
    }

    box.est_disposition_inline = doit_formatter_en_blocs == faux
}

MéthodeDeFormattage :: énum {
    Flex
    Bloc
    Inline
    DansContexteCourant
}

donne_méthode_de_formattage_intérieur :: fonc (box: *Box) -> MéthodeDeFormattage
{
    si box.table_virtuelle.type == InlineBox {
        si box.est_inline_block() {
            retourne MéthodeDeFormattage.Bloc
        }
        retourne MéthodeDeFormattage.Inline
    }

    si (box.table_virtuelle.type == BlockBox || box.table_virtuelle.type == TableCellBox || box.table_virtuelle.type == CaptionBox) {
        block_box := box comme *BlockBox
        si block_box.est_disposition_inline {
            retourne MéthodeDeFormattage.Inline
        }
    }

    si box.donne_display().inner_type == Display.Type.Flex {
        retourne MéthodeDeFormattage.Flex
    }

    si box.requiers_contexte_de_formattage_indépendant() {
        retourne MéthodeDeFormattage.Bloc
    }

    retourne MéthodeDeFormattage.DansContexteCourant
}

formatte_intérieur :: fonc (box: *BlockBox, ctx: *ContexteDeFormattage, mode: ModeDeFormattage, available: AvailableSpace)
{
    discr donne_méthode_de_formattage_intérieur(box) {
        Inline {
            ctx_local: ContexteDeFormattageInline
            initialise_depuis_parent(*ctx_local, ctx)

            /* Si nous devons générer un contexte indépendant, nous ignorons le parent 
             * afin que les boites flottantes de ce dernier n'influencent pas nos lignes.
             * (Ceci peut arriver quand un boite flottante établis un contexte de 
             * formattage inline.) */
            si box.requiers_contexte_de_formattage_indépendant() {
                ctx_local.parent = nul
            }

            ctx_local.racine = box
            ctx_local.doit_aligner_les_descendants = ctx.doit_aligner_les_descendants

            formatte(*ctx_local, box, mode, available)
        }
        Flex {
            ctx_local: ContexteDeFormattageFlex
            initialise_depuis_parent(*ctx_local, ctx)
            formatte(*ctx_local, box, mode, available)
        }
        Bloc {
            ctx_local: ContexteDeFormattageBloc
            initialise_depuis_parent(*ctx_local, ctx)
            diffère détruit_données_contexte(*ctx_local)
            ctx_local.racine = box
            ctx_local.doit_aligner_les_descendants = ctx.doit_aligner_les_descendants

            formatte(*ctx_local, box, mode, available)
        }
        DansContexteCourant {
            formatte(ctx, box, mode, available)
        }
    }
}

est_élément_avec_attribut_alignement_spécial :: fonc (élément: *HTML.Element) -> bool
{
    tags := [HTML.TAG_div, HTML.TAG_thead, HTML.TAG_tbody, HTML.TAG_tfoot, HTML.TAG_tr, HTML.TAG_td, HTML.TAG_th]

    pour tags {
        si élément.local_name == it {
            retourne vrai
        }
    }

    retourne faux
}

donne_alignement_descendants :: fonc (box: *BlockBox) -> Optionnel(AlignementTexte)
{
    élément := box.donne_élément()
    saufsi élément {
        retourne
    }

    si élément.local_name == HTML.TAG_center {
        retourne AlignementTexte.Centre
    }

    si est_élément_avec_attribut_alignement_spécial(élément) {
        attribut_align := HTML.donne_attribut(élément, HTML.ATTR_align)
        saufsi attribut_align.possède_valeur() {
            retourne
        }

        alignement := attribut_align.Quelque
        si compare_ascii_insensible_à_la_casse(alignement, PROP_center) || compare_ascii_insensible_à_la_casse(alignement, PROP_middle) {
            retourne AlignementTexte.Centre
        }

        si compare_ascii_insensible_à_la_casse(alignement, PROP_right) {
            retourne AlignementTexte.Droite
        }

        si compare_ascii_insensible_à_la_casse(alignement, PROP_left) {
            retourne AlignementTexte.Gauche
        }

        si compare_ascii_insensible_à_la_casse(alignement, PROP_justify) {
            retourne AlignementTexte.Justifié
        }

        retourne
    }
}

block_box_sur_mesure :: fonc (base: *Box, ctx: *ContexteDeFormattage, mode: ModeDeFormattage, personnalisation: PersonnalisationCotation, available: AvailableSpace)
{
    box := base comme *BlockBox

    containing_block := donne_containing_block(base, ctx)

    /* À FAIRE : utilise les bonnes formules.
     * https://www.w3.org/TR/2011/REC-CSS2-20110607/visudet.html#Computing_widths_and_margins */
    args := crée_arguments_dimensionnement_largeur(ctx, box, containing_block, personnalisation, mode)
    calcule_largeur_et_marges(*args)
    état_calcul_hauteur := calcule_hauteur_et_marges(*args)

    doit_aligner_les_descendants := ctx.doit_aligner_les_descendants
    alignement := donne_alignement_descendants(box)
    si alignement.possède_valeur() {
        ctx.doit_aligner_les_descendants = alignement
    }

    formatte_intérieur(box, ctx, mode, available)

    si état_calcul_hauteur == ÉtatCalculHauteur.HauteurDépendSurContenu {
        args.calcul_hauteur_après_contenu = vrai
        _ := calcule_hauteur_et_marges(*args)
    }

    ctx.doit_aligner_les_descendants = doit_aligner_les_descendants

    si mode == ModeDeFormattage.Normal && ctx.type != ContexteDeFormattageFlex {
        ctx.dispose_les_boites_absolues(box)
    }
}

block_box_corrige_hiérarchie :: fonc (base: *Box, créatrice: *CréatriceArbre)
{
    box := base comme *BlockBox
    détermine_disposition_interne(box)

    si box.est_disposition_inline {
        retourne
    }

    nouveaux_enfants: [..]*Box

    bloc_anonyme_courant: *BlockBox
    pour box.enfants {
        si it.est_block_level() {
            tableau_ajoute(*nouveaux_enfants, it)
            bloc_anonyme_courant = nul
            continue
        }

        si bloc_anonyme_courant == nul {
            bloc_anonyme_courant = créatrice.arbre.crée_box(BlockBox)
            bloc_anonyme_courant.parent = box
            bloc_anonyme_courant.est_disposition_inline = vrai
            crée_style_pour_bloc_anonyme(créatrice.résolveuse, bloc_anonyme_courant, box, Display.Type.Block)
            tableau_ajoute(*nouveaux_enfants, bloc_anonyme_courant)
        }

        bloc_anonyme_courant.ajoute_enfant(it)
    }

    déloge(box.enfants)
    box.enfants = nouveaux_enfants
}

block_box_donne_baseline :: fonc (base: *Box) -> Optionnel(InfoLigneDeBase)
{
    bloc := base comme *BlockBox

    // The baseline of an 'inline-block' is the baseline of its last line box in the normal flow,
    // unless it has either no in-flow line boxes or if its 'overflow' property has a computed
    // value other than 'visible', in which case the baseline is the bottom margin edge.
    // https://www.w3.org/TR/2011/REC-CSS2-20110607/visudet.html#propdef-vertical-align
    si est_inline_block(bloc) {
        overflow := bloc.propriétés.donne_valeur_utilisée(IDPropriété.OverflowY)
        si !overflow.est_mot_clé(PROP_visible) || bloc.lignes_tenante == nul {
            retourne donne_ligne_de_base_marge(bloc.modèle_de_boite)
        }

        si bloc.lignes_tenante.lignes.taille == 0 {
            retourne donne_ligne_de_base_marge(bloc.modèle_de_boite)
        }

        indice_ligne := bloc.lignes_tenante.lignes.taille - 1
        retourne bloc.lignes_tenante.donne_baseline(indice_ligne)
    }

    si bloc.lignes_tenante {
        si bloc.lignes_tenante.lignes.taille == 0 {
            retourne
        }

        retourne bloc.lignes_tenante.donne_baseline(0)
    }

    pour bloc.enfants {
        si it.table_virtuelle.type == TextBox {
            continue
        }

        saufsi est_in_flow(it) {
            continue
        }

        résultat := donne_baseline(it)
        si résultat.possède_valeur() {
            retourne résultat
        }
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom InlineBox
 * \{ */

#portée_fichier

__table_inline_box := TableVirtuelleBox(
    type = InlineBox,
    sur_mesure = inline_box_sur_mesure,
    sur_dessin = inline_box_sur_dessin,
    sur_dessin_fragment = inline_box_sur_dessin_fragment,
    sur_divise_en_lignes = inline_box_sur_divise_en_lignes,
    sur_dessin_tampon_id = inline_box_sur_dessin_tampon_id,
    sur_dessin_fragment_tampon_id = inline_box_sur_dessin_fragment_id,
    sur_correction_hiérarchie = inline_box_corrige_hiérarchie,
    sur_donne_baseline = block_box_donne_baseline)

#portée_export

/* Créé pour chaque box hors texte */
InlineBox :: struct {
    empl base_bloc: BlockBox
    table_virtuelle = *__table_inline_box
}

inline_box_sur_mesure :: fonc (base: *Box, ctx: *ContexteDeFormattage, mode: ModeDeFormattage, personnalisation: PersonnalisationCotation, available: AvailableSpace)
{
    box := base comme *InlineBox
    containing_block := donne_containing_block(base, ctx)
    args := crée_arguments_dimensionnement_largeur(ctx, box, containing_block, personnalisation, mode)
    calcule_largeur_et_marges(*args)
    état_calcul_hauteur := calcule_hauteur_et_marges(*args)

    formatte_intérieur(box, ctx, mode, available)

    si état_calcul_hauteur == ÉtatCalculHauteur.HauteurDépendSurContenu {
        args.calcul_hauteur_après_contenu = vrai
        _ := calcule_hauteur_et_marges(*args)
    }
}

inline_box_sur_divise_en_lignes :: fonc (base: *Box, enligneuse: *Enligneuse, mode: ModeDeFormattage)
{
    ctx := enligneuse.ctx
    box := base comme *InlineBox
    containing_block := donne_containing_block(box, ctx)
    args := crée_arguments_dimensionnement_largeur(ctx, box, containing_block, PersonnalisationCotation(), mode)
    calcule_largeur_et_marges(*args)
    _ := calcule_hauteur_et_marges(*args)

    propriétés := box.propriétés

    margin_left := propriétés.donne_valeur_utilisée(IDPropriété.MarginLeft).donne_pixels() comme r32
    padding_left := propriétés.donne_valeur_utilisée(IDPropriété.PaddingLeft).donne_pixels() comme r32
    padding_right := propriétés.donne_valeur_utilisée(IDPropriété.PaddingRight).donne_pixels() comme r32
    margin_right := propriétés.donne_valeur_utilisée(IDPropriété.MarginRight).donne_pixels() comme r32

    fragment_marge_début := enligneuse.ajoute_fragment(box, 0.0, margin_left, Fragment.Type.MargeDébut)
    fragment_rembourrage_début := enligneuse.ajoute_fragment(box, 0.0, padding_left, Fragment.Type.RembourrageDébut)

    pour box.enfants {
        divise_en_lignes(it, enligneuse, mode)
    }

    fragment_rembourrage_fin := enligneuse.ajoute_fragment(box, 0.0, padding_right, Fragment.Type.RembourrageFin)
    fragment_marge_fin := enligneuse.ajoute_fragment(box, 0.0, margin_right, Fragment.Type.MargeFin)

    lignes_tenante := enligneuse.donne_lignes_tenante()

    hauteur := 0.0
    pour fragment_rembourrage_début + 1 ... fragment_rembourrage_fin - 1 {
        fragment := lignes_tenante.fragments[it]
        hauteur = max(fragment.hauteur, hauteur)
    }

    indice_fragments := [fragment_marge_début, fragment_rembourrage_début, fragment_rembourrage_fin, fragment_marge_fin]
    pour indice_fragments {
        fragment := *lignes_tenante.fragments[it]
        fragment.hauteur = hauteur
    }
}

inline_box_corrige_hiérarchie :: fonc (base: *Box, créatrice: *CréatriceArbre)
{
    box := base comme *InlineBox
    détermine_disposition_interne(box)

    si box.est_inline_block() {
        block_box_corrige_hiérarchie(box, créatrice)
        retourne
    }

    si box.est_disposition_inline {
        retourne
    }

    assert(box.parent != nul)

    /* When an inline box contains an in-flow block-level box, the inline box (and its
     * inline ancestors within the same line box) are broken around the block-level
     * box (and any block-level siblings that are consecutive or separated only by
     * collapsible whitespace and/or out-of-flow elements), splitting the inline box
     * into two boxes (even if either side is empty), one on each side of the
     * block-level box(es). The line boxes before the break and after the break are
     * enclosed in anonymous block boxes, and the block-level box becomes a sibling of
     * those anonymous boxes. When such an inline box is affected by relative
     * positioning, any resulting translation also affects the block-level box
     * contained in the inline box.
     *
     * À FAIRE : récursion
     *
     * https://www.w3.org/TR/2011/REC-CSS2-20110607/visuren.html#anonymous-block-level */
    anciens_enfants := box.enfants
    diffère déloge(anciens_enfants)

    inline_box_courant := box
    inline_box_courant.enfants.pointeur = nul
    inline_box_courant.enfants.taille = 0
    inline_box_courant.enfants.capacité = 0

    pour anciens_enfants {
        si it.est_block_level() {
            box.parent.ajoute_enfant(it)
            inline_box_courant = nul
            continue
        }

        si inline_box_courant == nul {
            inline_box_courant = créatrice.arbre.crée_box(InlineBox)
            inline_box_courant.parent = box
            inline_box_courant.est_disposition_inline = vrai
            crée_style_pour_bloc_anonyme(créatrice.résolveuse, inline_box_courant, box, Display.Type.Inline)
            box.parent.ajoute_enfant(inline_box_courant)
        }

        inline_box_courant.ajoute_enfant(it)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom BreakBox
 * \{ */

#portée_fichier

__table_break_box := TableVirtuelleBox(
    type = BreakBox,
    sur_divise_en_lignes = break_box_sur_divise_en_lignes)

#portée_export

BreakBox :: struct {
    empl base_bloc: Box
    table_virtuelle = *__table_break_box
}

break_box_sur_divise_en_lignes :: fonc (base: *Box, enligneuse: *Enligneuse, mode: ModeDeFormattage @inutilisée)
{
    line_height := donne_line_height(base, enligneuse.ctx)

    base.propriétés.définis_valeur_utilisée(IDPropriété.Height, crée_valeur_pixels(line_height))

    ids_propriétés := [
        IDPropriété.BorderWidthLeft, IDPropriété.BorderWidthRight, IDPropriété.BorderWidthTop, IDPropriété.BorderWidthBottom,
        IDPropriété.MarginLeft, IDPropriété.MarginRight, IDPropriété.MarginTop, IDPropriété.MarginBottom,
        IDPropriété.PaddingLeft, IDPropriété.PaddingRight, IDPropriété.PaddingTop, IDPropriété.PaddingBottom,
        IDPropriété.Width 
    ]

    pour ids_propriétés {
        base.propriétés.définis_valeur_utilisée(it, donne_valeur_pixels_zéro())
    }

    ajourne_boite_pour_calcul_largeur(base)
    ajourne_boite_pour_calcul_hauteur(base)

    _ := enligneuse.ajoute_fragment(base, line_height, 0.0, Fragment.Type.NouvelleLigne)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom TextBox
 * \{ */

#portée_fichier

__table_text_box := TableVirtuelleBox(
    type = TextBox,
    sur_dessin_fragment = text_box_sur_dessin_fragment,
    sur_divise_en_lignes = text_box_sur_divise_en_lignes,
    sur_donne_baseline = text_box_sur_donne_baseline)

#portée_export

/* Créé pour chaque élément contenant du texte. */
TextBox :: struct {
    empl base: Box
    table_virtuelle = *__table_text_box

    texte_original: ChaineUTF16

    texte: ChaineUTF16
    fonte: *Fonte

    fragments: [..]FragmentTexte
}

donne_propriétés :: fonc (text_box: *TextBox) -> *PropriétésDeStyle
{
    parent := text_box.parent
    tantque est_box_anonyme(parent) {
        parent = parent.parent
    }
    retourne parent.propriétés
}

text_box_sur_donne_baseline :: fonc (base: *Box) -> Optionnel(InfoLigneDeBase)
{
    // À FAIRE : utilise la fonte
    retourne donne_ligne_de_base_marge(base.modèle_de_boite)
}

text_box_sur_divise_en_lignes :: fonc (base: *Box, enligneuse: *Enligneuse, mode: ModeDeFormattage)
{
    ctx := enligneuse.ctx
    box := base comme *TextBox

    propriétés := donne_propriétés(box)

    text_transform := propriétés.donne_valeur_utilisée(IDPropriété.TextTransform)
    si text_transform.est_mot_clé(PROP_uppercase) {
        box.texte = transforme_texte_en_majuscule(box.texte_original)
    }
    sinon si text_transform.est_mot_clé(PROP_lowercase) {
        box.texte = transforme_texte_en_minuscule(box.texte_original)
    }
    sinon {
        box.texte = copie_chaine(box.texte_original)
    }

    traite_espaces_blanches(box)

    fonte := détermine_fonte(box, ctx)
    métriques := fonte.donne_métriques_fonte()

    définis_hauteur_contenu(box.modèle_de_boite, métriques.donne_hauteur_ligne())

    /* "On a non-replaced inline element, line-height specifies the height that is used
     * in the calculation of the line box height."
     * https://drafts.csswg.org/css2/#propdef-line-height */
    hauteur_texte := donne_line_height(propriétés, fonte)

    // À FAIRE : traite proprement la hauteur de ligne pour les boxes interéléments.
    // La taille de fonte peut avoir été héritée de l'élément parent des boxes adelphes.
    si est_vide_ou_uniquement_espaces_blanches(box.texte) {
        hauteur_texte = 0.0
    }

    pour box.fragments {
        si it.ignore_mais_préserve_soft_wrap_opportunity {
            continue
        }

        si it.est_espace_blanche && it.texte.unités[0] == 0x0A {
            ligne := enligneuse.ajoute_ligne()
            ligne.garantis_hauteur_minimale(hauteur_texte)
            continue
        }

        largeur_morceau := fonte.donne_largeur_texte(it.texte)

        discr mode {
            Normal {
                si it.est_espace_blanche && enligneuse.peut_ignorer_espace_blanche_en_début_de_ligne() {
                    continue
                }

                _ := enligneuse.ajoute_fragment(box, indice_it, indice_it + 1, hauteur_texte, largeur_morceau comme r32)
            }
            ToutesLesBrisuresDeLigne {
                saufsi it.est_espace_blanche {
                    _ := enligneuse.ajoute_fragment(box, indice_it, indice_it + 1, hauteur_texte, largeur_morceau comme r32)
                }

                ligne := enligneuse.ajoute_ligne()
                ligne.garantis_hauteur_minimale(hauteur_texte)
            }
            BrisureDeLigneExplicite {
                si it.est_espace_blanche && enligneuse.peut_ignorer_espace_blanche_en_début_de_ligne() {
                    continue
                }

                _ := enligneuse.ajoute_fragment(box, indice_it, indice_it + 1, hauteur_texte, largeur_morceau comme r32)
            }
        }
    }
}

/* https://drafts.csswg.org/css-text/#white-space-phase-1 */
traite_espaces_blanches :: fonc (box: *TextBox)
{
    box.fragments.taille = 0
    fragmente_texte_avec_espaces_blanches_ascii(box.texte, *box.fragments)

    propriétés := donne_propriétés(box)
    white_space := propriétés.donne_valeur_utilisée(IDPropriété.WhiteSpace).donne_mot_clé()

    si white_space == PROP_normal || white_space == PROP_nowrap || white_space == PROP_pre_line {
        // 1. Any sequence of collapsible spaces and tabs immediately preceding or following a segment
        //    break is removed.
        collapse_séquences_d_espaces_blanches_autour_bris_segments(box.fragments)

        // 2. Collapsible segment breaks are transformed for rendering according to the segment break
        //    transformation rules.
        collapse_bris_segments(box.fragments, white_space)

        // 3. Every collapsible tab is converted to a collapsible space (U+0020).
        convertis_tabulations_en_espaces(box.fragments)

        // 4. Any collapsible space immediately following another collapsible space—​even one outside
        //    the boundary of the inline containing that space, provided both spaces are within the
        //    same inline formatting context—​is collapsed to have zero advance width. (It is invisible,
        //    but retains its soft wrap opportunity, if any.)
        // À FAIRE : collapse également (entre les boxes) lors de la disposition
        collapse_espaces_consécutives(box.fragments)
    }
    sinon {
        assert(white_space == PROP_wrap || white_space == PROP_pre || white_space == PROP_pre_wrap || white_space == PROP_break_spaces)
    }
}

FragmentTexte :: struct {
    texte: ChaineUTF16
    est_espace_blanche: bool
    ignore_mais_préserve_soft_wrap_opportunity: bool
}

/* Similaire à Chaine.divise_sur_espaces_blanches_ascii mais nous préservons les espaces. */
fragmente_texte_avec_espaces_blanches_ascii :: fonc (chn: ChaineUTF16, fragments: *[..]FragmentTexte)
{
    position := 0

    texte: ChaineUTF16

    tantque position < chn.taille() && est_ascii_espace_blanche(chn.unités.pointeur[position]) {
        texte.unités.pointeur = chn.unités.pointeur + position
        texte.unités.taille = 1
        tableau_ajoute(fragments, FragmentTexte(texte, vrai))

        position += 1
    }

    tantque position < chn.taille() {
        texte.unités.pointeur = chn.unités.pointeur + position
        texte.unités.taille = 0

        tantque position < chn.taille() && !est_ascii_espace_blanche(chn.unités.pointeur[position]) {
            texte.unités.taille += 1
            position += 1
        }

        si texte.taille() != 0 {
            tableau_ajoute(fragments, FragmentTexte(texte, faux))
        }

        texte.unités.pointeur = chn.unités.pointeur + position
        texte.unités.taille = 0

        tantque position < chn.taille() && est_ascii_espace_blanche(chn.unités.pointeur[position]) {
            texte.unités.pointeur = chn.unités.pointeur + position
            texte.unités.taille = 1
            tableau_ajoute(fragments, FragmentTexte(texte, vrai))

            position += 1
        }
    }
}

collapse_séquences_d_espaces_blanches_autour_bris_segments :: fonc (fragments: &[..]FragmentTexte)
{
    début := fragments.pointeur
    fin := fragments.pointeur + fragments.taille

    entrée := début
    sortie := début

    dernier_fragment_non_collapsible := entrée - 1

    tantque début < fin {
        si début.texte.unités[0] == 0x0A {
            sortie = dernier_fragment_non_collapsible + 1
            assert(sortie < fin)

            mémoire(sortie) = mémoire(début)
            dernier_fragment_non_collapsible = sortie
            début += 1
            sortie += 1

            tantque début < fin && début.est_espace_blanche {
                si début.texte.unités[0] == 0x0A {
                    arrête
                }
                début += 1
            }

            continue
        }

        saufsi début.est_espace_blanche {
            dernier_fragment_non_collapsible = sortie
        }

        mémoire(sortie) = mémoire(début)
        début += 1
        sortie += 1
    }

    fragments.taille = (sortie - entrée)
}

/* https://drafts.csswg.org/css-text/#line-break-transform */
collapse_bris_segments :: fonc (fragments: &[..]FragmentTexte, white_space: CSSOMString)
{
    // When white-space is pre, pre-wrap, break-spaces, or pre-line, segment breaks are
    // not collapsible and are instead transformed into a preserved line feed (U+000A).
    si white_space == PROP_pre || white_space == PROP_pre_wrap || white_space == PROP_break_spaces || white_space == PROP_pre_line {
        retourne
    }

    // 1. First, any collapsible segment break immediately following another collapsible
    // segment break is removed.
    début := fragments.pointeur
    fin := fragments.pointeur + fragments.taille

    entrée := début
    sortie := début

    dernier_fut_bris_segment := faux

    tantque début < fin {
        si début.texte.unités[0] == 0x0A {
            si dernier_fut_bris_segment {
                sortie -= 1
            }
            dernier_fut_bris_segment = vrai
        }
        sinon {
            dernier_fut_bris_segment = faux
        }

        mémoire(sortie) = mémoire(début)
        début += 1
        sortie += 1
    }

    fragments.taille = (sortie - entrée)

    // 2. Then any remaining segment break is either transformed into a space (U+0020)
    // or removed depending on the context before and after the break.
    // The rules for this operation are UA-defined in this level.
    chn_espace := crée_chaine_utf16_unique(" ").donne_chaine_utf16()

    début = fragments.pointeur
    tantque début < fin {
        si début.texte.unités[0] == 0x0A {
            début.texte = chn_espace
        }
        début += 1
    }
}

convertis_tabulations_en_espaces :: fonc (fragments: &[..]FragmentTexte)
{
    chn_espace := crée_chaine_utf16_unique(" ").donne_chaine_utf16()
    début := fragments.pointeur
    fin := fragments.pointeur + fragments.taille

    tantque début < fin {
        si début.texte.unités[0] == '\t' comme n32 {
            début.texte = chn_espace
        }
        début += 1
    }
}

collapse_espaces_consécutives :: fonc (fragments: &[..]FragmentTexte)
{
    début := fragments.pointeur
    fin := fragments.pointeur + fragments.taille

    dernier_fut_espace_blanche := faux

    tantque début < fin {
        si début.est_espace_blanche {
            si dernier_fut_espace_blanche {
                début.ignore_mais_préserve_soft_wrap_opportunity = vrai
            }
            dernier_fut_espace_blanche = vrai
        }
        sinon {
            dernier_fut_espace_blanche = faux
        }
        début += 1
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ReplacedBox
 * \{ */

#portée_fichier

__table_replaced_box := TableVirtuelleBox(
    type = ReplacedBox,
    sur_mesure = replaced_box_sur_mesure,
    sur_divise_en_lignes = replaced_box_sur_divise_en_lignes,
    sur_dessin_tampon_id = replaced_box_sur_dessin_tampon_id,
    sur_dessin_fragment = replaced_box_sur_dessin_fragment)

#portée_export

/* Créé pour chaque box hors texte */
ReplacedBox :: struct {
    empl base_bloc: BlockBox
    table_virtuelle = *__table_replaced_box

    /* Rappels spécifiques. */
    sur_calcul_dimensions_intrinsèques: fonc(*ReplacedBox,*ContexteDeFormattage)(rien)
    
    ratio_intrinsèque: Optionnel(r32)
    largeur_intrinsèque: Optionnel(r32)
    hauteur_intrinsèque: Optionnel(r32)

    fonte: *Fonte
}

possède_ratio_intrinsèque :: fonc (box: *ReplacedBox) -> bool
{
    retourne box.ratio_intrinsèque.possède_valeur()
}

possède_largeur_intrinsèque :: fonc (box: *ReplacedBox) -> bool
{
    retourne box.largeur_intrinsèque.possède_valeur()
}

possède_hauteur_intrinsèque :: fonc (box: *ReplacedBox) -> bool
{
    retourne box.hauteur_intrinsèque.possède_valeur()
}

donne_ratio_intrinsèque :: fonc (box: *ReplacedBox) -> r32
{
    retourne box.ratio_intrinsèque.Quelque
}

donne_largeur_intrinsèque :: fonc (box: *ReplacedBox) -> r32
{
    retourne box.largeur_intrinsèque.Quelque
}

donne_hauteur_intrinsèque :: fonc (box: *ReplacedBox) -> r32
{
    retourne box.hauteur_intrinsèque.Quelque
}

replaced_box_sur_mesure :: fonc (base: *Box, ctx: *ContexteDeFormattage, mode: ModeDeFormattage, personnalisation: PersonnalisationCotation @inutilisée, available: AvailableSpace)
{
    box := base comme *ReplacedBox

    box.sur_calcul_dimensions_intrinsèques(box, ctx)

    containing_block := donne_containing_block(box, ctx)

    width := box.propriétés.donne_valeur_calculée(IDPropriété.Width)
    height := box.propriétés.donne_valeur_calculée(IDPropriété.Height)

    personnalisation_boite: PersonnalisationCotation
    outrepas_largeur: OutrepasCotation
    outrepas_hauteur: OutrepasCotation

    si (available.width.est_max_content() || available.width.est_min_content()) && box.possède_largeur_intrinsèque() && !width.est_pixels() {
        outrepas_largeur = crée_outrepas_pour_coter_contenu(box.donne_largeur_intrinsèque())
        personnalisation_boite.outrepas_largeur = *outrepas_largeur
    }

    si (available.height.est_max_content() || available.height.est_min_content()) && box.possède_hauteur_intrinsèque() && !height.est_pixels() {
        outrepas_hauteur = crée_outrepas_pour_coter_contenu(box.donne_hauteur_intrinsèque())
        personnalisation_boite.outrepas_hauteur = *outrepas_hauteur
    }

    args := crée_arguments_dimensionnement_largeur(ctx, box, containing_block, personnalisation_boite, mode)

    calcule_largeur_et_marges(*args)
    _ := calcule_hauteur_et_marges(*args)
}

replaced_box_sur_divise_en_lignes :: fonc (base: *Box, enligneuse: *Enligneuse, mode: ModeDeFormattage)
{
    replaced_box_sur_mesure(base, enligneuse.ctx, mode, PersonnalisationCotation(), AvailableSpace())

    box := base comme *ReplacedBox
    largeur := box.modèle_de_boite.marge.largeur
    hauteur := box.modèle_de_boite.marge.hauteur

    _ := enligneuse.ajoute_fragment(box, 0, 0, hauteur, largeur, Fragment.Type.InlineBlock)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ReplacedBox pour image
 * \{ */

#portée_fichier

__table_image_box := TableVirtuelleBox(
    type = ReplacedBox,
    sur_dessin = image_box_sur_dessin,
    sur_mesure = replaced_box_sur_mesure,
    sur_divise_en_lignes = replaced_box_sur_divise_en_lignes,
    sur_dessin_tampon_id = replaced_box_sur_dessin_tampon_id,
    sur_dessin_fragment = replaced_box_sur_dessin_fragment)

crée_image_box :: fonc (arbre: *ArbreDeDisposition, élément: *HTML.HTMLImageElement) -> *ReplacedBox
{
    résultat := arbre.crée_box(ReplacedBox)
    résultat.table_virtuelle = *__table_image_box
    résultat.noeud = élément
    résultat.sur_calcul_dimensions_intrinsèques = image_box_calcul_dimensions_intrinsèques
    retourne résultat
}

image_box_calcul_dimensions_intrinsèques :: fonc (box: *ReplacedBox, ctx: *ContexteDeFormattage @inutilisée)
{
    élément := box.donne_élément() comme *HTML.HTMLImageElement
    assert(élément.local_name == HTML.TAG_img)

    si élément.image_data.données {
        box.ratio_intrinsèque = HTML.donne_ratio_intrinsèque(élément)
        box.largeur_intrinsèque = HTML.donne_largeur_intrinsèque(élément) comme r32
        box.hauteur_intrinsèque = HTML.donne_hauteur_intrinsèque(élément) comme r32
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ReplacedBox pour object
 * \{ */

#portée_fichier

__table_object_box := TableVirtuelleBox(
    type = ReplacedBox,
    sur_dessin = object_box_sur_dessin,
    sur_mesure = replaced_box_sur_mesure,
    sur_divise_en_lignes = replaced_box_sur_divise_en_lignes,
    sur_dessin_tampon_id = replaced_box_sur_dessin_tampon_id,
    sur_dessin_fragment = replaced_box_sur_dessin_fragment)

crée_object_box :: fonc (arbre: *ArbreDeDisposition, élément: *HTML.HTMLObjectElement) -> *ReplacedBox
{
    résultat := arbre.crée_box(ReplacedBox)
    résultat.table_virtuelle = *__table_object_box
    résultat.noeud = élément
    résultat.sur_calcul_dimensions_intrinsèques = object_box_calcul_dimensions_intrinsèques
    retourne résultat
}

object_box_calcul_dimensions_intrinsèques :: fonc (box: *ReplacedBox, ctx: *ContexteDeFormattage @inutilisée)
{
    élément := box.donne_élément() comme *HTML.HTMLObjectElement
    assert(élément.local_name == HTML.TAG_object)

    si élément.image_data.données {
        box.ratio_intrinsèque = HTML.donne_ratio_intrinsèque(élément)
        box.largeur_intrinsèque = HTML.donne_largeur_intrinsèque(élément) comme r32
        box.hauteur_intrinsèque = HTML.donne_hauteur_intrinsèque(élément) comme r32
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ReplacedBox pour input
 * \{ */

#portée_fichier

__table_text_input_box := TableVirtuelleBox(
    type = ReplacedBox,
    sur_dessin = text_input_box_sur_dessin,
    sur_mesure = replaced_box_sur_mesure,
    sur_divise_en_lignes = replaced_box_sur_divise_en_lignes,
    sur_dessin_tampon_id = replaced_box_sur_dessin_tampon_id,
    sur_dessin_fragment = replaced_box_sur_dessin_fragment)

crée_text_input_box :: fonc (arbre: *ArbreDeDisposition, élément: *HTML.HTMLInputElement) -> *ReplacedBox
{
    résultat := arbre.crée_box(ReplacedBox)
    résultat.table_virtuelle = *__table_text_input_box
    résultat.noeud = élément
    résultat.sur_calcul_dimensions_intrinsèques = text_input_box_dimensions_intrinsèques
    retourne résultat
}

text_input_box_dimensions_intrinsèques :: fonc (box: *ReplacedBox, ctx: *ContexteDeFormattage)
{
    assert(box.donne_élément().local_name == HTML.TAG_input)

    box.fonte = détermine_fonte(box, ctx)
    métriques := box.fonte.donne_métriques_fonte()
    hauteur_ligne := métriques.donne_hauteur_ligne()

    line_height := donne_line_height(box, ctx)

    /* For input elements whose type attribute is in one of the above states, the used value of the 'line-height'
     * property must be a length value that is no smaller than what the used value would be for 'line-height: normal'. */
    si line_height < hauteur_ligne {
        box.propriétés.définis_valeur_utilisée(IDPropriété.LineHeight, crée_valeur_pixels(hauteur_ligne))
        line_height = hauteur_ligne
    }

    box.largeur_intrinsèque = donne_inline_size_pour_text_input(box)
    box.hauteur_intrinsèque = line_height
}

/* https://html.spec.whatwg.org/multipage/rendering.html#the-input-element-as-a-text-entry-widget */
donne_inline_size_pour_text_input :: fonc (box: *ReplacedBox) -> r32
{
    métriques := box.fonte.donne_métriques_fonte()

    // À FAIRE : 1. If the 'field-sizing' property on the element has a computed value of 'content',
    // the inline size is determined by the text which the element shows. The text is either
    // a value or a short hint specified by the placeholder attribute. User agents may take
    // the text caret size into account in the inline size.

    // 2. If the element has a size attribute, and parsing that attribute's value using the
    // rules for parsing non-negative integers doesn't generate an error, return the value
    // obtained from applying the converting a character width to pixels algorithm to the value
    // of the attribute.
    size := HTML.donne_attribut_ou_chaine_vide(box.donne_élément(), HTML.ATTR_size)
    saufsi size.est_vide() {
        opt_value := HTML.parse_a_non_negative_integer(size)
        si opt_value.possède_valeur() {
            retourne convert_a_character_width_to_pixels(opt_value.Quelque comme r32, métriques)
        }
    }

    // 3. Otherwise, return the value obtained from applying the converting a character width to
    // pixels algorithm to the number 20.
    retourne convert_a_character_width_to_pixels(20.0, métriques)
}

/* https://html.spec.whatwg.org/multipage/rendering.html#converting-a-character-width-to-pixels */
convert_a_character_width_to_pixels :: fonc (size: r32, métriques: &MétriquesFonte) -> r32
{
    retourne (size - 1.0) * métriques.largeur_moyenne + métriques.largeur_maximale
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ReplacedBox pour input type=button
 * \{ */

#portée_fichier

__table_button_input_box := TableVirtuelleBox(
    type = ReplacedBox,
    sur_dessin = button_input_box_sur_dessin,
    sur_mesure = replaced_box_sur_mesure,
    sur_divise_en_lignes = replaced_box_sur_divise_en_lignes,
    sur_dessin_tampon_id = replaced_box_sur_dessin_tampon_id,
    sur_dessin_fragment = replaced_box_sur_dessin_fragment)

crée_button_box :: fonc (arbre: *ArbreDeDisposition, élément: *HTML.HTMLInputElement) -> *ReplacedBox
{
    résultat := arbre.crée_box(ReplacedBox)
    résultat.table_virtuelle = *__table_button_input_box
    résultat.noeud = élément
    résultat.sur_calcul_dimensions_intrinsèques = button_input_box_dimensions_intrinsèques
    retourne résultat
}

button_input_box_dimensions_intrinsèques :: fonc (box: *ReplacedBox, ctx: *ContexteDeFormattage)
{
    assert(box.donne_élément().local_name == HTML.TAG_input)
    box.fonte = détermine_fonte(box, ctx)
    line_height := donne_line_height(box, ctx)
    value := HTML.donne_attribut_ou_chaine_vide(box.donne_élément(), HTML.ATTR_value)
    box.largeur_intrinsèque = donne_largeur_texte(box.fonte, value) comme r32
    box.hauteur_intrinsèque = line_height
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ReplacedBox pour input type=radio
 * \{ */

#portée_fichier

__table_radio_button_box := TableVirtuelleBox(
    type = ReplacedBox,
    sur_dessin = radio_button_box_sur_dessin,
    sur_mesure = replaced_box_sur_mesure,
    sur_divise_en_lignes = replaced_box_sur_divise_en_lignes,
    sur_dessin_tampon_id = replaced_box_sur_dessin_tampon_id,
    sur_dessin_fragment = replaced_box_sur_dessin_fragment)

crée_radio_button_box :: fonc (arbre: *ArbreDeDisposition, élément: *HTML.HTMLInputElement) -> *ReplacedBox
{
    résultat := arbre.crée_box(ReplacedBox)
    résultat.table_virtuelle = *__table_radio_button_box
    résultat.noeud = élément
    résultat.sur_calcul_dimensions_intrinsèques = radio_button_box_dimensions_intrinsèques
    retourne résultat
}

radio_button_box_dimensions_intrinsèques :: fonc (box: *ReplacedBox, ctx: *ContexteDeFormattage @inutilisée)
{
    assert(box.donne_élément().local_name == HTML.TAG_input)
    box.largeur_intrinsèque = 14.0
    box.hauteur_intrinsèque = 14.0
}

/** \} */
/* ------------------------------------------------------------------------- */
/** \nom ReplacedBox pour input type=checkbox
 * \{ */

#portée_fichier

__table_checkbox_box := TableVirtuelleBox(
    type = ReplacedBox,
    sur_dessin = checkbox_box_sur_dessin,
    sur_mesure = replaced_box_sur_mesure,
    sur_divise_en_lignes = replaced_box_sur_divise_en_lignes,
    sur_dessin_tampon_id = replaced_box_sur_dessin_tampon_id,
    sur_dessin_fragment = replaced_box_sur_dessin_fragment)

crée_checkbox_box :: fonc (arbre: *ArbreDeDisposition, élément: *HTML.HTMLInputElement) -> *ReplacedBox
{
    résultat := arbre.crée_box(ReplacedBox)
    résultat.table_virtuelle = *__table_checkbox_box
    résultat.noeud = élément
    résultat.sur_calcul_dimensions_intrinsèques = checkbox_box_dimensions_intrinsèques
    retourne résultat
}

checkbox_box_dimensions_intrinsèques :: fonc (box: *ReplacedBox, ctx: *ContexteDeFormattage @inutilisée)
{
    assert(box.donne_élément().local_name == HTML.TAG_input)
    box.largeur_intrinsèque = 14.0
    box.hauteur_intrinsèque = 14.0
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ReplacedBox pour textarea
 * \{ */

#portée_fichier

__table_textarea_box := TableVirtuelleBox(
    type = ReplacedBox,
    sur_dessin = textarea_box_sur_dessin,
    sur_mesure = replaced_box_sur_mesure,
    sur_divise_en_lignes = replaced_box_sur_divise_en_lignes,
    sur_dessin_tampon_id = replaced_box_sur_dessin_tampon_id,
    sur_dessin_fragment = replaced_box_sur_dessin_fragment)

crée_textarea_box :: fonc (arbre: *ArbreDeDisposition, élément: *HTML.HTMLTextAreaElement) -> *ReplacedBox
{
    résultat := arbre.crée_box(ReplacedBox)
    résultat.table_virtuelle = *__table_textarea_box
    résultat.noeud = élément
    résultat.sur_calcul_dimensions_intrinsèques = textarea_box_dimensions_intrinsèques
    retourne résultat
}

textarea_box_dimensions_intrinsèques :: fonc (box: *ReplacedBox, ctx: *ContexteDeFormattage)
{
    assert(box.donne_élément().local_name == HTML.TAG_textarea)
    box.fonte = détermine_fonte(box, ctx)
    box.largeur_intrinsèque = donne_textarea_effective_width(box)
    box.hauteur_intrinsèque = donne_textarea_effective_height(box, ctx)
}

LARGEUR_BARRE_DE_DÉFILEMENT :: 16.0

/* https://html.spec.whatwg.org/multipage/rendering.html#textarea-effective-width */
donne_textarea_effective_width :: fonc (box: *ReplacedBox) -> r32
{
    élément := box.donne_élément() comme *HTML.HTMLTextAreaElement
    métriques := box.fonte.donne_métriques_fonte()
    character_width := HTML.donne_character_width(élément)
    retourne (character_width comme r32) * métriques.largeur_moyenne + LARGEUR_BARRE_DE_DÉFILEMENT
}

/* https://html.spec.whatwg.org/multipage/rendering.html#textarea-effective-height */
donne_textarea_effective_height :: fonc (box: *ReplacedBox, ctx: *ContexteDeFormattage) -> r32
{
    élément := box.donne_élément() comme *HTML.HTMLTextAreaElement
    character_height := HTML.donne_character_height(élément)
    line_height := donne_line_height(box, ctx)
    retourne character_height comme r32 * line_height
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ReplacedBox pour canvas
 * \{ */

#portée_fichier

__table_canvas_box := TableVirtuelleBox(
    type = ReplacedBox,
    sur_dessin = canvas_box_sur_dessin,
    sur_mesure = replaced_box_sur_mesure,
    sur_divise_en_lignes = replaced_box_sur_divise_en_lignes,
    sur_dessin_tampon_id = replaced_box_sur_dessin_tampon_id,
    sur_dessin_fragment = replaced_box_sur_dessin_fragment)

crée_canvas_box :: fonc (arbre: *ArbreDeDisposition, élément: *HTML.HTMLCanvasElement) -> *ReplacedBox
{
    résultat := arbre.crée_box(ReplacedBox)
    résultat.table_virtuelle = *__table_canvas_box
    résultat.noeud = élément
    résultat.sur_calcul_dimensions_intrinsèques = canvas_box_calcul_dimensions_intrinsèques
    retourne résultat
}

canvas_box_calcul_dimensions_intrinsèques :: fonc (box: *ReplacedBox, ctx: *ContexteDeFormattage @inutilisée)
{
    élément := box.donne_élément() comme *HTML.HTMLCanvasElement
    assert(élément.local_name == HTML.TAG_canvas)
    box.largeur_intrinsèque = HTML.donne_largeur_intrinsèque(élément) comme r32
    box.hauteur_intrinsèque = HTML.donne_hauteur_intrinsèque(élément) comme r32
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ReplacedBox pour select
 * \{ */

#portée_fichier

__table_select_box := TableVirtuelleBox(
    type = SelectBox,
    sur_dessin = select_box_sur_dessin,
    sur_mesure = replaced_box_sur_mesure,
    sur_divise_en_lignes = replaced_box_sur_divise_en_lignes,
    sur_dessin_tampon_id = replaced_box_sur_dessin_tampon_id,
    sur_dessin_fragment = replaced_box_sur_dessin_fragment)

#portée_export

SelectBox :: struct {
    empl replaced_box: ReplacedBox
    table_virtuelle = *__table_select_box

    texte: ChaineUTF16
    fragments: [..]FragmentTexte
}

#portée_fichier

réinitialise :: fonc (box: *SelectBox)
{
    détruit_chaine(box.texte)
    box.fragments.taille = 0
}

crée_select_box :: fonc (arbre: *ArbreDeDisposition, élément: *HTML.HTMLSelectElement) -> *ReplacedBox
{
    résultat := arbre.crée_box(SelectBox)
    résultat.noeud = élément
    résultat.sur_calcul_dimensions_intrinsèques = select_box_calcul_dimensions_intrinsèques
    retourne résultat
}

// À FAIRE : standardise (https://html.spec.whatwg.org/multipage/rendering.html#the-select-element-2)
donne_select_labels_width :: fonc (box: *SelectBox, ctx: *ContexteDeFormattage) -> r32
{
    réinitialise(box)

    select := box.donne_élément() comme *HTML.HTMLSelectElement

    option := donne_première_option(select)
    saufsi option {
        retourne 0.0
    }

    box.texte = HTML.donne_contenu_texte_descandants(option)
    si box.texte.taille() == 0 {
        retourne 0.0
    }

    fragmente_texte_avec_espaces_blanches_ascii(box.texte, *box.fragments)
    collapse_séquences_d_espaces_blanches_autour_bris_segments(box.fragments)
    collapse_bris_segments(box.fragments, PROP_normal)
    convertis_tabulations_en_espaces(box.fragments)
    collapse_espaces_consécutives(box.fragments)

    fonte := détermine_fonte(box, ctx)

    résultat := 0.0

    pour box.fragments {
        résultat += donne_largeur_texte(fonte, it.texte) comme r32
    }

    retourne résultat
}

donne_première_option :: fonc (select: *HTML.HTMLSelectElement) -> *HTML.HTMLOptionElement
{
    pour select.enfants {
        saufsi HTML.est_élément(it) {
            continue
        }

        élément := it comme *HTML.Element
        si élément.local_name != HTML.TAG_option {
            continue
        }

        retourne élément comme *HTML.HTMLOptionElement
    }

    retourne nul
}

select_box_calcul_dimensions_intrinsèques :: fonc (box: *SelectBox, ctx: *ContexteDeFormattage)
{
    élément := box.donne_élément() comme *HTML.HTMLSelectElement
    assert(élément.local_name == HTML.TAG_select)
    box.largeur_intrinsèque = donne_select_labels_width(box, ctx)
    box.hauteur_intrinsèque = donne_line_height(box, ctx)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ItératriceArbre
 * \{ */

ItératriceArbre :: struct {
    racine: *Box
}

opérateur pour :: (itératrice: ItératriceArbre) -> *Box
{
    pile: Pile(*Box)
    diffère détruit(pile)

    pile.empile(itératrice.racine)

    indice: z64

    tantque !pile.est_vide() {
        enfant := pile.dépile()

        `it = enfant
        `indice_it = indice

        #corps_boucle

        pour > enfant.enfants {
            pile.empile(it)
        }

        indice += 1
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom TableWrapperBox
 * \{ */

#portée_fichier

__table_table_wrapper_box := TableVirtuelleBox(
    type = TableWrapperBox,
    sur_mesure = table_wrapper_box_sur_mesure,
    sur_dessin = block_box_sur_dessin,
    sur_dessin_tampon_id = block_box_sur_dessin_tampon_id,
    sur_correction_hiérarchie = table_wrapper_box_corrige_hiérarchie)

#portée_module

TableWrapperBox :: struct {
    empl base_bloc: BlockBox
    table_virtuelle = *__table_table_wrapper_box

    table: *TableBox
}

table_wrapper_box_sur_mesure :: fonc (base: *Box, ctx: *ContexteDeFormattage, mode: ModeDeFormattage, personnalisation: PersonnalisationCotation, available: AvailableSpace)
{
    box := base comme *TableWrapperBox

    containing_block := donne_containing_block(base, ctx)

    args := crée_arguments_dimensionnement_largeur(ctx, box, containing_block, personnalisation, mode)
    calcule_largeur_et_marges(*args)
    _ := calcule_hauteur_et_marges(*args)

    ctx_local: ContexteDeFormattageBloc
    initialise_depuis_parent(*ctx_local, ctx)
    diffère détruit_données_contexte(*ctx_local)

    ctx_local.racine = box

    formatte(*ctx_local, box, mode, available)

    width := box.propriétés.donne_valeur_calculée(IDPropriété.Width)
    si width.est_auto() {
        largeur_final := crée_outrepas_pour_coter_contenu(box.table.modèle_de_boite.contenu.largeur)
        personnalisation_ := personnalisation
        personnalisation_.outrepas_largeur = *largeur_final
        args = crée_arguments_dimensionnement_largeur(ctx, box, containing_block, personnalisation_, mode)
        calcule_largeur_et_marges(*args)

        /* Si les marges ont changés la position, nous devons décaler les descendants. */
        si box.modèle_de_boite.contenu.x != box.table.modèle_de_boite.marge.x {
            box.table.décale_vers_position(box.modèle_de_boite.contenu.x, box.table.modèle_de_boite.marge.y)
        }
    }

    height := box.propriétés.donne_valeur_calculée(IDPropriété.Height)
    si height.est_auto() {
        hauteur_finale := crée_outrepas_pour_coter_contenu(box.table.propriétés.donne_valeur_utilisée(IDPropriété.Height).donne_pixels())
        personnalisation_ := personnalisation
        personnalisation_.outrepas_hauteur = *hauteur_finale
        args = crée_arguments_dimensionnement_hauteur(ctx, box, containing_block, personnalisation_)
        _ := calcule_hauteur_et_marges(*args)
    }
}

est_row_group_box :: fonc (box: *Box) -> bool
{
    // A 'table-row-group', 'table-header-group', or 'table-footer-group' 
    retourne box.table_virtuelle.type == TableRowGroupBox || box.table_virtuelle.type == TableHeaderGroupBox || box.table_virtuelle.type == TableFooterGroupBox
}

est_proper_table_child :: fonc (box: *Box) -> bool
{
    // A 'table-row' box, row group box, 'table-column' box, 'table-column-group' box, or 'table-caption' box. 
    retourne box.table_virtuelle.type == TableRowBox || est_row_group_box(box) || box.table_virtuelle.type == TableColumnBox || box.table_virtuelle.type == TableColumnGroupBox || box.table_virtuelle.type == CaptionBox
}

est_proper_table_row_parent :: fonc (box: *Box) -> bool
{
    // A 'table' or 'inline-table' box or row group box 
    retourne box.table_virtuelle.type == TableBox || est_row_group_box(box)
}

est_internal_table_box :: fonc (box: *Box) -> bool
{
    // A 'table-cell' box, 'table-row' box, row group box, 'table-column' box, or 'table-column-group' box. 
    retourne box.table_virtuelle.type == TableCellBox || box.table_virtuelle.type == TableRowBox || est_row_group_box(box) || box.table_virtuelle.type == TableColumnBox || box.table_virtuelle.type == TableColumnGroupBox
}

est_tabular_container :: fonc (box: *Box) -> bool
{
    // A 'table-row' box or proper table row parent 
    retourne box.table_virtuelle.type == TableRowBox || est_proper_table_row_parent(box)
}

sont_consecutifs :: fonc (a: *Box, b: *Box) -> bool
{
    // Two sibling boxes are consecutive if they have no intervening siblings
    // other than, optionally, an anonymous inline containing only white spaces.
    // A sequence of sibling boxes is consecutive if each box in the sequence is
    // consecutive to the one before it in the sequence. 
    si a.parent != b.parent {
        retourne faux
    }
}

table_wrapper_box_corrige_hiérarchie :: fonc (base: *Box, créatrice: *CréatriceArbre)
{
    // 1. Remove irrelevant boxes
    pour ItératriceArbre(base) {
        remove_irrelevant_boxes(it)
    }

    // 2. Generate missing child wrappers
    pour ItératriceArbre(base) {
        generate_missing_child_wrappers(it, créatrice)
    }

    // 3. Generate missing parents
    pour ItératriceArbre(base) {
        generate_missing_parents(it, créatrice)
    }
}

remove_irrelevant_boxes :: fonc (box: *Box)
{
    // 1. All child boxes of a 'table-column' parent are treated as if they had 'display: none'.
    si box.table_virtuelle.type == TableColumnBox {
        pour box.enfants {
            it.traite_comme_display_none = vrai
        }
    }

    // 2. If a child C of a 'table-column-group' parent is not a 'table-column' box,
    // then it is treated as if it had 'display: none'.
    si box.table_virtuelle.type == TableColumnGroupBox {
        si box.parent == nul || box.parent.table_virtuelle.type != TableColumnBox {
            box.traite_comme_display_none = vrai
        }
    }

    // 3. If a child C of a tabular container P is an anonymous inline box that
    // contains only white space, and its immediately preceding and following
    // siblings, if any, are proper table descendants of P and are either
    // 'table-caption' or internal table boxes, then it is treated as if it had
    // 'display: none'.
    si est_tabular_container(box) {
        pour box.enfants {
            saufsi est_espace_blanche_document(it) {
                continue
            }

            si indice_it > 0 {
                précédent := box.enfants[indice_it - 1]
                saufsi est_proper_table_descendant(box, précédent) {
                    continue
                }
            }

            si indice_it < box.enfants.taille - 1 {
                suivant := box.enfants[indice_it + 1]
                saufsi est_proper_table_descendant(box, suivant) {
                    continue
                }
            }

            it.traite_comme_display_none = vrai
        }

        premier := box.enfants.pointeur
        dernier := premier + box.enfants.taille

        insertion := premier

        tantque premier != dernier {
            si mémoire(premier).traite_comme_display_none {
                premier += 1
                continue
            }
            
            mémoire(insertion) = mémoire(premier)
            premier += 1
            insertion += 1
        }

        box.enfants.taille = insertion - box.enfants.pointeur
    }

    // 4. If a box B is an anonymous inline containing only white space, and is
    // between two immediate siblings each of which is either an internal table
    // box or a 'table-caption' box then B is treated as if it had 'display: none'.
    // À FAIRE
}

// A box D is a proper table descendant of A if D can be a descendant of A
// without causing the generation of any intervening 'table' or 'inline-table' boxes.
est_proper_table_descendant :: fonc (A: *Box, D: *Box) -> bool
{
    si A.table_virtuelle.type == TableRowBox {
        retourne D.table_virtuelle.type == TableCellBox
    }

    si A.table_virtuelle.type == TableBox {
        retourne est_proper_table_child(D)
    }

    assert(est_row_group_box(A))
    retourne D.table_virtuelle.type == TableRowBox
}

generate_missing_child_wrappers :: fonc (box: *Box, créatrice: *CréatriceArbre)
{
    // 1. If a child C of a 'table' or 'inline-table' box is not a proper table
    // child, then generate an anonymous 'table-row' box around C and all
    // consecutive siblings of C that are not proper table children.
    si box.table_virtuelle.type == TableBox {
        table := box comme *TableBox

        premier := box.enfants.pointeur
        dernier := premier + box.enfants.taille

        insertion := premier

        tantque premier != dernier {
            si mémoire(premier).traite_comme_display_none {
                premier += 1
                continue
            }
            
            si est_proper_table_child(mémoire(premier)) {
                mémoire(insertion) = mémoire(premier)
                premier += 1
                insertion += 1
                continue
            }

            table_row_box := créatrice.arbre.crée_box(TableRowBox)
            crée_style_pour_bloc_anonyme(créatrice.résolveuse, table_row_box, table, Display.Type.TableRow)
            table_row_box.est_pseudo_element = mémoire(premier).est_pseudo_element

            ajoute_enfant(table_row_box, mémoire(premier))
            mémoire(insertion) = table_row_box
            insertion += 1

            premier += 1

            tantque premier != dernier {
                si est_proper_table_child(mémoire(premier)) {
                    arrête
                }

                ajoute_enfant(table_row_box, mémoire(premier))
                premier += 1
            }
        }

        box.enfants.taille = insertion - box.enfants.pointeur
    }

    // 2. If a child C of a row group box is not a 'table-row' box, then
    // generate an anonymous 'table-row' box around C and all consecutive
    // siblings of C that are not 'table-row' boxes.
    si box.table_virtuelle.type == TableRowGroupBox {
        table_row_group := box comme *TableRowGroupBox

        pour table_row_group.enfants {
            si it.table_virtuelle.type != TableRowBox {
                table_row_box := créatrice.arbre.crée_box(TableRowBox)
                crée_style_pour_bloc_anonyme(créatrice.résolveuse, table_row_box, table_row_group, Display.Type.TableRow)
                table_row_box.est_pseudo_element = it.est_pseudo_element
                ajoute_enfant(table_row_box, it)

                table_row_group.enfants[indice_it] = table_row_box
            }
        }
    }

    // 3. If a child C of a 'table-row' box is not a 'table-cell', then
    // generate an anonymous 'table-cell' box around C and all consecutive
    // siblings of C that are not 'table-cell' boxes. 
    si box.table_virtuelle.type == TableRowBox {
        table_row_box := box comme *TableRowBox

        premier := box.enfants.pointeur
        dernier := premier + box.enfants.taille

        insertion := premier

        tantque premier != dernier {
            si mémoire(premier).traite_comme_display_none {
                premier += 1
                continue
            }

            si mémoire(premier).table_virtuelle.type == TableCellBox {
                mémoire(insertion) = mémoire(premier)
                insertion += 1
                premier += 1
                continue
            }

            table_cell := créatrice.arbre.crée_box(TableCellBox)
            crée_style_pour_bloc_anonyme(créatrice.résolveuse, table_cell, table_row_box, Display.Type.TableCell)
            table_cell.est_pseudo_element = mémoire(premier).est_pseudo_element

            ajoute_enfant(table_cell, mémoire(premier))
            mémoire(insertion) = table_cell
            insertion += 1

            premier += 1

            tantque premier != dernier {
                si mémoire(premier).table_virtuelle.type == TableCellBox {
                    arrête
                }

                ajoute_enfant(table_cell, mémoire(premier))
                premier += 1
            }
        }

        box.enfants.taille = insertion - box.enfants.pointeur
    }
}

generate_missing_parents :: fonc (box: *Box @inutilisée, créatrice: *CréatriceArbre @inutilisée)
{
    // À FAIRE
    // For each 'table-cell' box C in a sequence of consecutive internal table and 'table-caption' siblings, if C's parent is not a 'table-row' then generate an anonymous 'table-row' box around C and all consecutive siblings of C that are 'table-cell' boxes.
    // For each proper table child C in a sequence of consecutive proper table children, if C is misparented then generate an anonymous 'table' or 'inline-table' box T around C and all consecutive siblings of C that are proper table children. (If C's parent is an 'inline' box, then T must be an 'inline-table' box; otherwise it must be a 'table' box.)
        // A 'table-row' is misparented if its parent is neither a row group box nor a 'table' or 'inline-table' box.
        // A 'table-column' box is misparented if its parent is neither a 'table-column-group' box nor a 'table' or 'inline-table' box.
        // A row group box, 'table-column-group' box, or 'table-caption' box is misparented if its parent is neither a 'table' box nor an 'inline-table' box. 
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom TableBox
 * \{ */

#portée_fichier

__table_table_box := TableVirtuelleBox(
    type = TableBox,
    sur_mesure = table_box_sur_mesure,
    sur_dessin = table_box_sur_dessin,
    sur_dessin_tampon_id = block_box_sur_dessin_tampon_id,
    sur_correction_hiérarchie = block_box_corrige_hiérarchie)

#portée_module

TableBox :: struct {
    empl base_bloc: BlockBox
    table_virtuelle = *__table_table_box
}

table_box_sur_mesure :: fonc (base: *Box, ctx: *ContexteDeFormattage, mode: ModeDeFormattage @inutilisée, personnalisation: PersonnalisationCotation @inutilisée, available: AvailableSpace)
{
    box := base comme *TableBox

    ctx_local: ContexteDeFormattageTable
    initialise_depuis_parent(*ctx_local, ctx)

    formatte_table(*ctx_local, box, available)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom TableColumnGroupBox
 * \{ */

#portée_fichier

__table_table_column_group_box := TableVirtuelleBox(type = TableColumnGroupBox)

#portée_module

TableColumnGroupBox :: struct {
    empl base: Box
    table_virtuelle = *__table_table_column_group_box
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom TableColumnBox
 * \{ */

#portée_fichier

__table_table_column_box := TableVirtuelleBox(type = TableColumnBox)

#portée_module

TableColumnBox :: struct {
    empl base: Box
    table_virtuelle = *__table_table_column_box
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom TableFooterGroupBox
 * \{ */

#portée_fichier

__table_table_footer_group_box := TableVirtuelleBox(
    type = TableFooterGroupBox,
    sur_mesure = block_box_sur_mesure,
    sur_dessin = block_box_sur_dessin,
    sur_dessin_tampon_id = block_box_sur_dessin_tampon_id,
    sur_correction_hiérarchie = block_box_corrige_hiérarchie)

#portée_module

TableFooterGroupBox :: struct {
    empl base_bloc: BlockBox
    table_virtuelle = *__table_table_footer_group_box
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom TableHeaderGroupBox
 * \{ */

#portée_fichier

__table_table_header_group_box := TableVirtuelleBox(
    type = TableHeaderGroupBox,
    sur_mesure = block_box_sur_mesure,
    sur_dessin = block_box_sur_dessin,
    sur_dessin_tampon_id = block_box_sur_dessin_tampon_id,
    sur_correction_hiérarchie = block_box_corrige_hiérarchie)

#portée_module

TableHeaderGroupBox :: struct {
    empl base_bloc: BlockBox
    table_virtuelle = *__table_table_header_group_box
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom TableRowGroupBox
 * \{ */

#portée_fichier

__table_table_row_group_box := TableVirtuelleBox(
    type = TableRowGroupBox,
    sur_mesure = block_box_sur_mesure,
    sur_dessin = block_box_sur_dessin,
    sur_dessin_tampon_id = block_box_sur_dessin_tampon_id,
    sur_correction_hiérarchie = block_box_corrige_hiérarchie)

#portée_module

TableRowGroupBox :: struct {
    empl base_bloc: BlockBox
    table_virtuelle = *__table_table_row_group_box
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom TableRowBox
 * \{ */

#portée_fichier

__table_table_row_box := TableVirtuelleBox(
    type = TableRowBox,
    sur_mesure = block_box_sur_mesure,
    sur_dessin = block_box_sur_dessin,
    sur_dessin_tampon_id = block_box_sur_dessin_tampon_id,
    sur_correction_hiérarchie = block_box_corrige_hiérarchie)

#portée_module

TableRowBox :: struct {
    empl base_bloc: BlockBox
    table_virtuelle = *__table_table_row_box
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom TableCellBox
 * \{ */

#portée_fichier

__table_table_cell_box := TableVirtuelleBox(
    type = TableCellBox,
    sur_mesure = block_box_sur_mesure,
    sur_dessin = block_box_sur_dessin,
    sur_dessin_tampon_id = block_box_sur_dessin_tampon_id,
    sur_correction_hiérarchie = block_box_corrige_hiérarchie,
    sur_donne_baseline = table_cell_box_donne_baseline)

#portée_export

TableCellBox :: struct {
    empl base_bloc: BlockBox
    table_virtuelle = *__table_table_cell_box
}

/* Retourne la largeur pour le contenu de la cellule étant donné la largeur disponible. */
donne_largeur_contenu :: fonc (box: *TableCellBox, largeur_disponible: r64) -> r64
{
    propriétés := box.propriétés

    ids_propriétés := [IDPropriété.BorderWidthLeft, IDPropriété.BorderWidthRight, IDPropriété.PaddingLeft, IDPropriété.PaddingRight]

    pour ids_propriétés {
        prop := propriétés.donne_valeur_calculée(it)

        si prop.est_pixels() {
            largeur_disponible -= prop.donne_pixels()
        }
    }

    retourne largeur_disponible
}

table_cell_box_donne_baseline :: fonc (base: *Box) -> Optionnel(InfoLigneDeBase)
{
    // À FAIRE : The baseline of a cell is the baseline of the first in-flow line box in the cell,
    // or the first in-flow table-row in the cell, whichever comes first.
    résultat := block_box_donne_baseline(base)
    si résultat.possède_valeur() {
        info := résultat.Quelque
        si info.position != info.origine {
            /* Nous pouvons avoir une ligne de base nulle à cause de la logique de block_box_donne_baseline (p.e. un enfant in-flow n'ayant pas été dûment coté).
             * Dans ce cas, ne retournons que si la ligne de base n'est pas nulle.
             * À voir si ceci sera encore un problème lorsque nous aurons proprement implémenté le cas « à faire » plus haut. */
            retourne résultat
        }
    }

    // If there is no such line box or table-row, the baseline is the bottom of content edge of the cell box.
    retourne donne_ligne_de_base_contenu(base.modèle_de_boite)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom CaptionBox
 * \{ */

#portée_fichier

__table_table_caption_box := TableVirtuelleBox(
    type = CaptionBox,
    sur_mesure = block_box_sur_mesure,
    sur_dessin = block_box_sur_dessin,
    sur_dessin_tampon_id = block_box_sur_dessin_tampon_id,
    sur_correction_hiérarchie = block_box_corrige_hiérarchie,
    sur_donne_baseline = block_box_donne_baseline)

#portée_module

CaptionBox :: struct {
    empl base_bloc: BlockBox
    table_virtuelle = *__table_table_caption_box
}

/** \} */
