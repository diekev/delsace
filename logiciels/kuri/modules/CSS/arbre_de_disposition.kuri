importe Chaine
importe Couleur
importe Fondation
importe Géométrie
importe #inemployé HTML
importe Math
importe PeintureInterface
importe Typographie

/* ------------------------------------------------------------------------- */
/** \nom Arbre de disposition
 * \{ */

ArbreDeDisposition :: struct {
    racine: *NoeudDeDisposition

    noeuds: [..]*NoeudDeDisposition
}

détruit_arbre :: fonc (arbre: *ArbreDeDisposition)
{
    saufsi arbre {
        retourne
    }

    pour arbre.noeuds {
        déloge(it.enfants)

        si it.type == NoeudDeDispositionBloc {
            bloc := it comme *NoeudDeDispositionBloc
            déloge(bloc)
        }
        sinon si it.type == NoeudDeDispositionTexte {
            texte := it comme *NoeudDeDispositionTexte
            détruit_chaine(texte.texte)
            déloge(texte)
        }
        sinon {
            imprime("noeud inconnu !")
            déloge(it)
        }
    }

    déloge(arbre.noeuds)
    déloge(arbre)
}

crée_noeud :: fonc (arbre: *ArbreDeDisposition, $TypeNoeud: type_de_données) -> *TypeNoeud
{
    résultat := loge(TypeNoeud)
    tableau_ajoute(*arbre.noeuds, résultat)
    retourne résultat
}

donne_élément_pour_position :: fonc (arbre: *ArbreDeDisposition, x: z32, y: z32) -> *HTML.Élément
{
    noeud := donne_noeud_pour_position(arbre.racine, x, y)
    saufsi noeud {
        retourne nul
    }
    retourne noeud.donne_élément()
}

donne_noeud_pour_position :: fonc (noeud: *NoeudDeDisposition, x: z32, y: z32) -> *NoeudDeDisposition
{
    rect := noeud.donne_rectangle()
    saufsi rect.contient(x, y) {
        retourne nul
    }

    pour noeud.enfants {
        résultat := donne_noeud_pour_position(it, x, y)
        si résultat {
            retourne résultat
        }
    }

    retourne noeud
}

donne_curseur :: fonc (noeud: *NoeudDeDisposition) -> CursorType
{
    chn_cursor := crée_chaine_utf16("cursor")
    diffère détruit_chaine(chn_cursor)

    cursor := donne_déclaration(*noeud.propriétés, chn_cursor)
    saufsi cursor {
        retourne CursorType.auto
    }

    retourne donne_type_cursor(cursor.value[0].mot_clé)
}

ContexteDisposition :: struct {
    globales: *GlobalesDessin
    largeur_disponible: n32
}

ContexteDessin :: struct {
    globales: *GlobalesDessin
    peintre: *Peintre

    hauteur_vue: z32
}

donne_rectangle_corrigé :: fonc (ctx: *ContexteDessin, noeud: *NoeudDeDisposition) -> RectanglePosDim(z32)
{
    rect: RectanglePosDim(z32)
    rect.x = noeud.position_x comme z32
    /* Nous disposons les noeuds comme si leur origine était leur coin du haut
     * gauche mais nous devons les dessiner comme si leur origine était leur
     * coin du bas gauche.
     * De plus, nous devons nous assurer que l'origine du document est le bas
     * gauche de la page et non le haut gauche. */
    rect.y = ctx.hauteur_vue - noeud.position_y comme z32 - noeud.hauteur comme z32
    rect.largeur = noeud.largeur comme z32
    rect.hauteur = noeud.hauteur comme z32
    retourne rect
}

NoeudDeDisposition :: struct {
    type := #type_de_cette_structure

    propriétés: PropriétésDeStyle

    parent: *NoeudDeDisposition
    enfants: [..]*NoeudDeDisposition

    position_x: n32
    position_y: n32

    largeur: n32
    hauteur: n32

    sur_mesure: fonc (*NoeudDeDisposition, *ContexteDisposition)(rien)
    sur_dessin: fonc (*NoeudDeDisposition, *ContexteDessin)(rien)
}

donne_rectangle :: fonc (noeud: *NoeudDeDisposition) -> RectanglePosDim(z32)
{
    rect: RectanglePosDim(z32)
    rect.x = noeud.position_x comme z32
    rect.y = noeud.position_y comme z32
    rect.largeur = noeud.largeur comme z32
    rect.hauteur = noeud.hauteur comme z32
    retourne rect
}

donne_élément :: fonc (noeud: *NoeudDeDisposition) -> *HTML.Élément
{
    noeud_courant := noeud

    tantque noeud_courant != nul && noeud_courant.type != NoeudDeDispositionBloc {
        noeud_courant = noeud_courant.parent
    }

    si noeud_courant {
        retourne (noeud_courant comme *NoeudDeDispositionBloc).élément
    }

    retourne nul
}

décale :: fonc (noeud: *NoeudDeDisposition, x: n32, y: n32)
{
    noeud.position_x += x
    noeud.position_y += y

    pour noeud.enfants {
        it.décale(x, y)
    }
}

donne_nom_classe :: fonc (noeud: *NoeudDeDisposition) -> chaine
{
    infos := __table_des_types[noeud.type] comme *InfoTypeStructure
    retourne infos.nom
}

mesure :: fonc (noeud: *NoeudDeDisposition, ctx: *ContexteDisposition)
{
    si noeud.sur_mesure {
        noeud.sur_mesure(noeud, ctx)
    }
}

dessine :: fonc (noeud: *NoeudDeDisposition, ctx: *ContexteDessin)
{
    si noeud.largeur == 0 || noeud.hauteur == 0 {
        retourne
    }

    si noeud.sur_dessin {
        noeud.sur_dessin(noeud, ctx)
    }
}

ajoute_enfant :: fonc (parent: *NoeudDeDisposition, enfant: *NoeudDeDisposition)
{
    enfant.parent = parent
    tableau_ajoute(*parent.enfants, enfant)
}

/* Créé pour chaque noeud hors texte */
NoeudDeDispositionBloc :: struct {
    empl base: NoeudDeDisposition
    type = #type_de_cette_structure
    sur_mesure = noeud_disposition_bloc_sur_mesure
    sur_dessin = noeud_disposition_bloc_sur_dessin

    élément: *HTML.Élément
}

noeud_disposition_bloc_sur_mesure :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDisposition)
{
    noeud := base comme *NoeudDeDispositionBloc

    pour noeud.enfants {
        it.mesure(ctx)

        it.décale(0, noeud.hauteur)

        noeud.hauteur += it.hauteur
        noeud.largeur = max(noeud.largeur, it.largeur)
    }
}

noeud_disposition_bloc_sur_dessin :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDessin)
{
    noeud := base comme *NoeudDeDispositionBloc

    // rect := ctx.donne_rectangle_corrigé(noeud)

    // couleur := CouleurRVBA(0.5, 0.0, 0.5, 1.0)

    // peintre := ctx.peintre
    // peintre.dessine_rectangle(rect, couleur)

    pour noeud.enfants {
        dessine(it, ctx)
    }
}

/* Créé pour chaque élément contenant du texte. */
NoeudDeDispositionTexte :: struct {
    empl base: NoeudDeDisposition
    type = #type_de_cette_structure
    sur_mesure = noeud_disposition_texte_sur_mesure
    sur_dessin = noeud_disposition_texte_sur_dessin

    noeud_texte: *HTML.NoeudTexte
    texte: ChaineUTF16
    fonte: *Fonte
}

noeud_disposition_texte_sur_mesure :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDisposition)
{
    noeud := base comme *NoeudDeDispositionTexte

    si est_vide_ou_uniquement_espaces_blanches(noeud.noeud_texte.données) {
        noeud.hauteur = 0
        noeud.largeur = 0
        noeud.sur_dessin = nul
        retourne
    }

    globales := ctx.globales
    assert(globales != nul)
    famille_fonte := "sérif"
    style := "normal"
    graisse := GraisseFonte.Normal
    taille_fonte := globales.taille_fonte_défaut

    chn_font_weight := crée_chaine_utf16("font-weight")
    diffère détruit_chaine(chn_font_weight)

    propriétés := *noeud.parent.propriétés
    font_weight := donne_déclaration(propriétés, chn_font_weight)
    si font_weight {
        mot_clé := font_weight.value[0].mot_clé

        si mot_clé == "bold" {
            graisse = GraisseFonte.Gras
        }
    }

    chn_font_size := crée_chaine_utf16("font-size")
    diffère détruit_chaine(chn_font_size)

    font_size := donne_déclaration(propriétés, chn_font_size)
    si font_size {
        longueur := font_size.value[0].longueur

        discr longueur.unité {
            Em {
                taille_fonte *= longueur.valeur comme r32
            }
        }
    }

    fonte := globales.donne_fonte(famille_fonte, style, graisse, taille_fonte)
    noeud.fonte = fonte
    métriques := fonte.donne_métriques_fonte()

    /* À FAIRE : meilleur algorithme, respect du standard. */
    morceaux := divise_sur_espaces_blanches_ascii(noeud.noeud_texte.données)
    diffère déloge(morceaux)

    enchaineuse: EnchaineuseUTF16
    initialise_enchaineuse(enchaineuse)
    diffère détruit_tampons(enchaineuse)

    virgule := ChaineUTF16Unique(0x20).donne_chaine_utf16()
    pour morceaux {
        si index_it > 0 {
            ajoute(enchaineuse, virgule)
        }
        ajoute(enchaineuse, it)
    }

    texte := chaine_depuis_enchaineuse(enchaineuse)
    noeud.texte = texte

    noeud.hauteur = (métriques.donne_hauteur_ligne() + 0.5) comme n32
    noeud.largeur = fonte.donne_largeur_texte(texte) comme n32
}

noeud_disposition_texte_sur_dessin :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDessin)
{
    noeud := base comme *NoeudDeDispositionTexte

    rect := ctx.donne_rectangle_corrigé(noeud)

    propriétés := *noeud.parent.propriétés

    couleur := CouleurRVBAN8(0, 0, 0, 255)

    chn_color := crée_chaine_utf16("color")
    diffère détruit_chaine(chn_color)

    color := donne_déclaration(propriétés, chn_color)
    si color {
        couleur = color.value[0]
    }

    chn_text_decoration := crée_chaine_utf16("text-decoration")
    diffère détruit_chaine(chn_text_decoration)

    effets: EffetsTexte

    text_decoration := donne_déclaration(propriétés, chn_text_decoration)
    si text_decoration {
        pour text_decoration.value {
            si it.est_mot_clé(crée_chaine_utf16_unique("underline").donne_chaine_utf16()) {
                effets.souslignage = vrai
                effets.couleur_souslignage = vers_couleur_rvba(couleur)
            }
            sinon si it.est_mot_clé(crée_chaine_utf16_unique("overline").donne_chaine_utf16()) {
                effets.surlignage = vrai
                effets.couleur_surlignage = vers_couleur_rvba(couleur)
            }
            sinon si it.est_mot_clé(crée_chaine_utf16_unique("line-through").donne_chaine_utf16()) {
                effets.barrage = vrai
                effets.couleur_barrage = vers_couleur_rvba(couleur)
            }
        }
    }

    texte := noeud.texte

    peintre := ctx.peintre
    fonte := noeud.fonte
    assert(fonte != nul)
    peintre.dessine_texte(fonte, texte, rect, couleur, *effets)
}

est_display_none :: fonc (propriétés: *PropriétésDeStyle) -> bool
{
    chn_display := crée_chaine_utf16("display")
    diffère détruit_chaine(chn_display)

    display := donne_déclaration(propriétés, chn_display)
    saufsi display {
        /* Le défaut est inline. */
        retourne faux
    }

    chn_none := crée_chaine_utf16("none")
    diffère détruit_chaine(chn_none)
    retourne est_mot_clé(display.value[0], chn_none)
}

crée_arbre_de_disposition :: fonc (document: *HTML.Document)
{
    html := HTML.donne_élément_html(document)
    saufsi html {
        retourne
    }

    saufsi document.globales_dessin {
        document.globales_dessin = crée_globales_dessin()
    }

    résultat := loge(ArbreDeDisposition)

    feuille_de_style := document.feuilles_de_style[0]

    racine := résultat.crée_noeud(NoeudDeDispositionBloc)
    racine.élément = html
    html.noeud_de_disposition = racine

    résultat.racine = racine

    pour html.enfants {
        crée_noeud_pour_élément(feuille_de_style, résultat, résultat.racine, it)
    }

    imprime("Créé % noeud(s)\n", résultat.noeuds.taille)

    ctx: ContexteDisposition
    ctx.globales = document.globales_dessin

    mesure(racine, *ctx)

    imprime("taille arbre : %x%\n", résultat.racine.largeur, résultat.racine.hauteur)

    // imprime_arbre(résultat)

    si document.arbre_de_disposition {
        détruit_arbre(document.arbre_de_disposition)
    }

    document.arbre_de_disposition = résultat
}

imprime_arbre :: fonc (arbre: *ArbreDeDisposition)
{
    saufsi arbre.racine {
        retourne
    }

    enchaineuse: Enchaineuse
    initialise_enchaineuse(*enchaineuse)
    diffère détruit_tampons(*enchaineuse)

    imprime_arbre(*enchaineuse, arbre.racine, 0)

    résultat := chaine_depuis_enchaineuse(*enchaineuse)
    diffère déloge(résultat)

    imprime("%\n", résultat)
}

imprime_arbre :: fonc (enchaineuse: *Enchaineuse, racine: *NoeudDeDisposition, profondeur: n32)
{
    indentation := donne_chaine_indentation(profondeur comme z32)

    imprime_dans_enchaineuse(enchaineuse, "%%", indentation, racine.donne_nom_classe())
    si racine.type == NoeudDeDispositionBloc {
        bloc := racine comme *NoeudDeDispositionBloc
        imprime_dans_enchaineuse(enchaineuse, " %", bloc.élément.texte)
    }

    imprime_dans_enchaineuse(enchaineuse, " % % %x%\n", racine.position_x, racine.position_y, racine.largeur, racine.hauteur)

    pour racine.enfants {
        imprime_arbre(enchaineuse, it, profondeur + 1)
    }
}

crée_noeud_pour_élément :: fonc (stylesheet: *CSSStyleSheet, arbre: *ArbreDeDisposition, parent: *NoeudDeDisposition, noeud: *HTML.Noeud)
{
    si HTML.est_texte(noeud) {
        résultat := arbre.crée_noeud(NoeudDeDispositionTexte)
        résultat.noeud_texte = noeud comme *HTML.NoeudTexte
        parent.ajoute_enfant(résultat)
        retourne
    }

    saufsi HTML.est_élément(noeud) {
        retourne
    }

    élément := noeud comme *HTML.Élément

    règles := collecte_les_règles_appropriées(stylesheet, élément)
    diffère déloge(règles)

    imprime("% règle(s) pour %\n", règles.taille, élément.texte)

    propriétés: PropriétésDeStyle

    pour règles {
        imprime_règle(it)
        pour déclaration dans it.déclarations {
            ajoute_déclaration(*propriétés, déclaration)
        }
    }

    si est_display_none(*propriétés) {
        détruit_données_propriétés(*propriétés)
        retourne
    }

    résultat := arbre.crée_noeud(NoeudDeDispositionBloc)
    résultat.élément = élément
    élément.noeud_de_disposition = résultat
    résultat.propriétés = propriétés
    parent.ajoute_enfant(résultat)

    pour noeud.enfants {
        crée_noeud_pour_élément(stylesheet, arbre, résultat, it)
    }
}

/** \} */