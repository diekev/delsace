importe Aléa
importe Chaine
importe Couleur
importe Fondation
importe Géométrie
importe #inemployé HTML
importe IGUMI
importe Math
importe OpenGL
importe PeintureInterface
importe Triage
importe Typographie

/* ------------------------------------------------------------------------- */
/** \nom Arbre de disposition
 * \{ */

ArbreDeDisposition :: struct {
    racine: *NoeudDeDisposition

    noeuds: [..]*NoeudDeDisposition
    tampon_id: [..]n32
    largeur_vue: z32
    hauteur_vue: z32
}

détruit_arbre :: fonc (arbre: *ArbreDeDisposition)
{
    saufsi arbre {
        retourne
    }

    pour arbre.noeuds {
        déloge(it.enfants)
        si it.propriétés {
            détruit_propriétés(it.propriétés)
        }

        si it.type == NoeudDeDispositionBloc {
            bloc := it comme *NoeudDeDispositionBloc
            pour *boite dans bloc.lignes {
                détruit_données_boite_de_ligne(boite)
            }
            déloge(bloc.lignes)
            déloge(bloc)
        }
        sinon si it.type == NoeudDeDispositionInline {
            noeud := it comme *NoeudDeDispositionInline
            pour *boite dans noeud.lignes {
                détruit_données_boite_de_ligne(boite)
            }
            déloge(noeud.lignes)
            déloge(noeud)
        }
        sinon si it.type == NoeudDeDispositionTexte {
            texte := it comme *NoeudDeDispositionTexte
            détruit_chaine(texte.texte)
            déloge(texte)
        }
        sinon si it.type == NoeudDeDispositionNouvelleLigne {
            bris := it comme *NoeudDeDispositionNouvelleLigne
            déloge(bris)
        }
        sinon si it.type == NoeudDeDispositionRemplacement {
            remplacement := it comme *NoeudDeDispositionRemplacement
            déloge(remplacement)
        }
        sinon {
            imprime("noeud inconnu !")
            déloge(it)
        }
    }

    déloge(arbre.tampon_id)
    déloge(arbre.noeuds)
    déloge(arbre)
}

crée_noeud :: fonc (arbre: *ArbreDeDisposition, $TypeNoeud: type_de_données) -> *TypeNoeud
{
    résultat := loge(TypeNoeud)
    résultat.id = arbre.noeuds.taille comme n32
    tableau_ajoute(*arbre.noeuds, résultat)
    retourne résultat
}

donne_élément_pour_position :: fonc (arbre: *ArbreDeDisposition, x: z32, y: z32) -> *HTML.Élément
{
    saufsi 0 <= x < arbre.largeur_vue && 0 <= y < arbre.hauteur_vue {
        retourne nul
    }

    tampon_id := arbre.tampon_id
    /* OpenGL est de bas en haut, donc inverse l'axe des y. */
    index := (arbre.hauteur_vue - y - 1) * arbre.largeur_vue + x

    index_noeud := tampon_id[index]

    noeud := arbre.noeuds[index_noeud]
    saufsi noeud {
        retourne nul
    }
    retourne noeud.donne_élément()
}

imprime_arbre :: fonc (arbre: *ArbreDeDisposition)
{
    saufsi arbre.racine {
        retourne
    }

    enchaineuse: Enchaineuse
    initialise_enchaineuse(*enchaineuse)
    diffère détruit_tampons(*enchaineuse)

    imprime_arbre(*enchaineuse, arbre.racine, 0)

    résultat := chaine_depuis_enchaineuse(*enchaineuse)
    diffère déloge(résultat)

    imprime("%\n", résultat)
}

imprime_arbre :: fonc (enchaineuse: *Enchaineuse, racine: *NoeudDeDisposition, profondeur: n32)
{
    indentation := donne_chaine_indentation(profondeur comme z32)

    imprime_dans_enchaineuse(enchaineuse, "%%", indentation, racine.donne_nom_classe())
    si racine.type == NoeudDeDispositionBloc {
        bloc := racine comme *NoeudDeDispositionBloc
        imprime_dans_enchaineuse(enchaineuse, " %", bloc.élément.local_name)
    }

    imprime_dans_enchaineuse(enchaineuse, " % % %x%\n", racine.modèle_de_boite.marge.x, racine.modèle_de_boite.marge.y, racine.modèle_de_boite.marge.largeur, racine.modèle_de_boite.marge.hauteur)

    pour racine.enfants {
        imprime_arbre(enchaineuse, it, profondeur + 1)
    }
}

dessine :: fonc (arbre: *ArbreDeDisposition, ctx: *ContexteDessin)
{
    arbre.hauteur_vue = ctx.hauteur_vue
    arbre.largeur_vue = ctx.largeur_vue

    dessine(arbre.racine, ctx)

    /* Tampon ID. */

    fbo: GLuint
    glGenFramebuffers(1, *fbo)
    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, fbo)

    render_buf: GLuint
    glGenRenderbuffers(1, *render_buf)
    glBindRenderbuffer(GL_RENDERBUFFER, render_buf)
    glRenderbufferStorage(GL_RENDERBUFFER, GL_R32UI, ctx.largeur_vue, ctx.hauteur_vue)
    vérifie_erreur("glRenderbufferStorage")
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, render_buf)
    vérifie_erreur("glFramebufferRenderbuffer")

    dessine_tampon_id(arbre.racine, ctx)
    vérifie_erreur("dessine_tampon_id")

    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0)
    vérifie_erreur("glBindFramebuffer")

    glBindFramebuffer(GL_READ_FRAMEBUFFER, fbo)
    vérifie_erreur("glBindFramebuffer")

    tableau_redimensionne(arbre.tampon_id, ctx.largeur_vue * ctx.hauteur_vue)

    glReadBuffer(GL_COLOR_ATTACHMENT0)
    vérifie_erreur("glReadBuffer")
    glReadPixels(0, 0, ctx.largeur_vue, ctx.hauteur_vue, GL_RED_INTEGER, GL_UNSIGNED_INT, arbre.tampon_id.pointeur)
    vérifie_erreur("glReadPixels")

    glBindFramebuffer(GL_READ_FRAMEBUFFER, 0)

    glBindRenderbuffer(GL_RENDERBUFFER, 0)

    glDeleteFramebuffers(1, *fbo)
    glDeleteRenderbuffers(1, *render_buf)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom RésolveuseStyle.
 * \{ */

RésolveuseStyle :: struct {
    globales: *GlobalesDessin
    taille_fonte_racine: r64
    feuilles_de_style: []*CSSStyleSheet

    /* Tampon réutilisé pour les cascades de propriétés. */
    déclarations_cascade: [..]DéclarationCascadée

    /* Style dont les propriétés sont toujours à leurs valeurs initiales.
     * Utilisé lors du calcul des valeurs. */
    valeurs_initiales: Style
}

initialise_résolveuse :: fonc (résolveuse: *RésolveuseStyle)
{
    initialise_style(*résolveuse.valeurs_initiales)
}

/* https://html.spec.whatwg.org/multipage/rendering.html#the-css-user-agent-style-sheet-and-presentational-hints */
ajoute_presentational_hint :: fonc (résolveuse: *RésolveuseStyle, déclaration: *DéclarationPropriété)
{
    tableau_ajoute(*résolveuse.déclarations_cascade, DéclarationCascadée(déclaration, Spécificité(0, 0, 0), OrigineCascade.Author))
}

collecte_les_règles_appropriées :: fonc (résolveuse: *RésolveuseStyle, élément: *HTML.Élément) -> [..]*CSSStyleRule
{
    règles: [..]*CSSStyleRule

    pour stylesheet dans résolveuse.feuilles_de_style {
        pour règle dans stylesheet.rules {
            si règle.type != CSSRuleType.Style {
                continue
            }

            règle_de_style := règle comme *CSSStyleRule

            pour complex dans règle_de_style.selector_list.complex_selectors {
                si apparie_sélecteur(complex.compound_selectors, complex.compound_selectors.taille - 1, élément) {
                    tableau_ajoute(*règles, règle_de_style)
                    arrête
                }
            }
        }
    }

    retourne règles
}

résoud_style :: fonc (résolveuse: *RésolveuseStyle, élément: *HTML.Élément, propriétés_parent: *PropriétésDeStyle) -> *PropriétésDeStyle
{
    résultat := crée_propriétés_de_style(propriétés_parent)

    règles := collecte_les_règles_appropriées(résolveuse, élément)
    diffère déloge(règles)
    // imprime("% règle(s) pour %\n", règles.taille, élément.local_name)

    résolveuse.déclarations_cascade.taille = 0

    pour règles {
        // imprime_règle(it)
        tableau_réserve(*résolveuse.déclarations_cascade, résolveuse.déclarations_cascade.taille + it.style.déclarations.taille)
        spécificité := calcule_spécificité(*it.selector_list)
        origine := donne_origine_cascade(it)
        pour déclaration dans it.style.déclarations {
            tableau_ajoute(*résolveuse.déclarations_cascade, DéclarationCascadée(déclaration, spécificité, origine, index_it))
        }
    }

    HTML.applique_presentational_hints(élément, résolveuse)

    si élément.style {
        /* https://drafts.csswg.org/css-style-attr/#style-attribute
         * "In the cascade, these declarations are considered to have author origin and a specificity higher than any selector." */
        tableau_réserve(*résolveuse.déclarations_cascade, résolveuse.déclarations_cascade.taille + élément.style.déclarations.taille)
        spécificité := donne_spécificité_max()
        pour élément.style.déclarations {
            tableau_ajoute(*résolveuse.déclarations_cascade, DéclarationCascadée(it, spécificité, OrigineCascade.Author))
        }
    }
    tri_rapide(résolveuse.déclarations_cascade, compare_déclarations_pour_cascade)

    pour > résolveuse.déclarations_cascade {
        ajoute_déclaration(résultat, it.déclaration)
    }

    calcule_style(résolveuse, résultat, propriétés_parent)

    retourne résultat
}

/* https://www.w3.org/TR/css-cascade/#origin */
OrigineCascade :: énum {
    Author
    User
    UserAgent
}

DéclarationCascadée :: struct {
    déclaration: *DéclarationPropriété
    spécificité: Spécificité
    origine: OrigineCascade
    index_règle: z64
}

/* https://www.w3.org/TR/css-cascade/#cascade-sort */
compare_déclarations_pour_cascade :: fonc (a: DéclarationCascadée, b: DéclarationCascadée) -> z32
{
    /* Tri par importance. */
    si a.déclaration.important && !b.déclaration.important {
        retourne -1
    }
    si b.déclaration.important && !a.déclaration.important {
        retourne 1
    }

    /* Même importance -> tri par origine. */
    si a.origine != b.origine {
        retourne a.origine comme z32 - b.origine comme z32
    }

    /* Même importance et origine -> tri par spécifité. */
    si a.spécificité > b.spécificité {
        retourne -1
    }
    si b.spécificité > a.spécificité {
        retourne 1
    }

    /* Même importance, origine, et spécifité -> tri par position. */
    si a.index_règle < b.index_règle {
        retourne 1
    }
    si b.index_règle < a.index_règle {
        retourne -1
    }

    /* À FAIRE : contextes. */

    retourne 0
}

crée_style_pour_bloc_anonyme :: fonc (résolveuse: *RésolveuseStyle, bloc: *NoeudDeDispositionBloc, bloc_parent: *NoeudDeDispositionBloc)
{
    résultat := crée_propriétés_de_style(bloc_parent.propriétés)
    calcule_style(résolveuse, résultat, bloc_parent.propriétés)

    bloc.propriétés = résultat
}

calcule_style :: fonc (résolveuse: *RésolveuseStyle, propriétés: *PropriétésDeStyle, propriétés_parent: *PropriétésDeStyle)
{
    /* https://www.w3.org/TR/2011/REC-CSS2-20110607/cascade.html#computed-value */
    ctx_calcul_style: ContexteCalculStyle
    ctx_calcul_style.taille_fonte = résolveuse.globales.taille_fonte_défaut
    ctx_calcul_style.taille_fonte_racine = résolveuse.taille_fonte_racine
    ctx_calcul_style.propriétés = propriétés
    ctx_calcul_style.propriétés_parent = propriétés_parent
    ctx_calcul_style.valeurs_initiales = *résolveuse.valeurs_initiales

    /* À FAIRE : gère proprement l'héritage des valeurs (surtout pour ne pas les recalculer). */
    si propriétés_parent {
        propriétés.style.valeurs[IDPropriété.FontSize] = propriétés_parent.style.valeurs[IDPropriété.FontSize]
    }
    sinon {
        propriétés.style.valeurs[IDPropriété.FontSize] = ValeurDeStyle(number = ctx_calcul_style.taille_fonte)
    }

    pour propriétés.déclarations {
        si it.est_personnalisée {
            continue
        }
        info := it.info

        si info.sur_calcul_style {
            info.sur_calcul_style(it, *propriétés.style, *ctx_calcul_style)
        }
        sinon {
            calcule_valeur_propriété_générique(it, *propriétés.style, *ctx_calcul_style)
        }

        si info.id == IDPropriété.FontSize {
            ctx_calcul_style.taille_fonte = propriétés.style.valeurs[IDPropriété.FontSize].number
        }
    }

    si propriétés.style.valeurs[IDPropriété.BorderStyleLeft].line_style == LineStyle.None {
        propriétés.style.valeurs[IDPropriété.BorderWidthLeft] = ValeurDeStyle(number = 0.0)
    }
    si propriétés.style.valeurs[IDPropriété.BorderStyleTop].line_style == LineStyle.None {
        propriétés.style.valeurs[IDPropriété.BorderWidthTop] = ValeurDeStyle(number = 0.0)
    }
    si propriétés.style.valeurs[IDPropriété.BorderStyleRight].line_style == LineStyle.None {
        propriétés.style.valeurs[IDPropriété.BorderWidthRight] = ValeurDeStyle(number = 0.0)
    }
    si propriétés.style.valeurs[IDPropriété.BorderStyleBottom].line_style == LineStyle.None {
        propriétés.style.valeurs[IDPropriété.BorderWidthBottom] = ValeurDeStyle(number = 0.0)
    }
    saufsi propriétés.style.valeurs[IDPropriété.FontWeight].est_nombre() {
        propriétés.style.valeurs[IDPropriété.FontWeight] = calcule_valeur_propriété_générique(propriétés.style.valeurs[IDPropriété.FontWeight], GenreValeurCalculée.FontWeight, *propriétés.style, *ctx_calcul_style)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Génération d'arbres de disposition.
 * \{ */

crée_arbre_de_disposition :: fonc (document: *HTML.Document, largeur: z32, hauteur: z32)
{
    html := HTML.donne_élément_html(document)
    saufsi html {
        retourne
    }

    saufsi document.globales_dessin {
        document.globales_dessin = crée_globales_dessin()
    }

    résultat := loge(ArbreDeDisposition)

    résolveuse: RésolveuseStyle
    initialise_résolveuse(*résolveuse)
    résolveuse.taille_fonte_racine = document.globales_dessin.taille_fonte_défaut
    résolveuse.globales = document.globales_dessin
    résolveuse.feuilles_de_style = document.feuilles_de_style

    /* À FAIRE : ceci peut changer mais comment est encore inconnue. */
    html.pseudo_classes.Root = vrai

    crée_noeud_pour_élément(*résolveuse, résultat, nul, html)
    résultat.racine = html.noeud_de_disposition

    // imprime("Créé % noeud(s)\n", résultat.noeuds.taille)

    ctx: ContexteDisposition
    ctx.largeur_disponible = largeur comme r32
    ctx.hauteur_disponible = hauteur comme r32
    ctx.globales = document.globales_dessin

    mesure(résultat.racine, *ctx)

    // imprime("taille arbre : %x%\n", résultat.racine.largeur, résultat.racine.hauteur)

    // imprime_arbre(résultat)

    si document.arbre_de_disposition {
        détruit_arbre(document.arbre_de_disposition)
    }

    document.arbre_de_disposition = résultat
}

crée_noeud_pour_élément :: fonc (résolveuse: *RésolveuseStyle, arbre: *ArbreDeDisposition, parent: *NoeudDeDisposition, noeud: *HTML.Noeud)
{
    si HTML.est_texte(noeud) {
        /* Les textes doivent une boite inline anonyme autour d'eux. */
        résultat := arbre.crée_noeud(NoeudDeDispositionInline)
        crée_style_pour_bloc_anonyme(résolveuse, résultat, parent comme *NoeudDeDispositionBloc)
        parent.ajoute_enfant(résultat)

        texte := arbre.crée_noeud(NoeudDeDispositionTexte)
        texte.noeud_texte = noeud comme *HTML.NoeudTexte
        résultat.ajoute_enfant(texte)
        retourne
    }

    saufsi HTML.est_élément(noeud) {
        retourne
    }

    élément := noeud comme *HTML.Élément

    propriétés_parent: *PropriétésDeStyle
    si parent {
        propriétés_parent = parent.propriétés
    }

    propriétés := résoud_style(résolveuse, élément, propriétés_parent)

    display := propriétés.style.valeurs[IDPropriété.Display].display
    si display.outer_type == Display.Type.None {
        détruit_propriétés(propriétés)
        retourne
    }

    résultat: *NoeudDeDisposition
    si élément.local_name == HTML.TAG_img {
        remplacement := arbre.crée_noeud(NoeudDeDispositionRemplacement)
        remplacement.élément = élément
        résultat = remplacement
    }
    sinon si display.outer_type == Display.Type.Block {
        bloc := arbre.crée_noeud(NoeudDeDispositionBloc)
        bloc.élément = élément
        résultat = bloc
    }
    sinon si élément.local_name == HTML.TAG_br {
        bris := arbre.crée_noeud(NoeudDeDispositionNouvelleLigne)
        résultat = bris
    }
    sinon {
        inline := arbre.crée_noeud(NoeudDeDispositionInline)
        inline.élément = élément
        résultat = inline
    }

    si parent == nul {
        résolveuse.taille_fonte_racine = propriétés.style.valeurs[IDPropriété.FontSize].number
    }

    élément.noeud_de_disposition = résultat
    résultat.propriétés = propriétés

    si parent {
        parent.ajoute_enfant(résultat)
    }

    pour noeud.enfants {
        crée_noeud_pour_élément(résolveuse, arbre, résultat, it)
    }

    si résultat.type != NoeudDeDispositionBloc && résultat.type != NoeudDeDispositionInline {
        retourne
    }

    noeud_disposition := résultat comme *NoeudDeDispositionBloc

    /* Crée des blocs anonymes pour envelopper les blocs inlines si au moins un enfant est un bloc.
     * Voir définition de "block container box" :
     * https://www.w3.org/TR/2011/REC-CSS2-20110607/visuren.html#block-boxes */
    doit_formatter_en_blocs := faux

    pour noeud_disposition.enfants {
        si it.type == NoeudDeDispositionBloc {
            doit_formatter_en_blocs = vrai
            arrête
        }
    }

    noeud_disposition.est_disposition_inline = doit_formatter_en_blocs == faux

    saufsi noeud_disposition.est_disposition_inline {
        si noeud_disposition.type == NoeudDeDispositionInline {
            assert(parent != nul)

            /* When an inline box contains an in-flow block-level box, the inline box (and its
             * inline ancestors within the same line box) are broken around the block-level
             * box (and any block-level siblings that are consecutive or separated only by
             * collapsible whitespace and/or out-of-flow elements), splitting the inline box
             * into two boxes (even if either side is empty), one on each side of the
             * block-level box(es). The line boxes before the break and after the break are
             * enclosed in anonymous block boxes, and the block-level box becomes a sibling of
             * those anonymous boxes. When such an inline box is affected by relative
             * positioning, any resulting translation also affects the block-level box
             * contained in the inline box.
             *
             * À FAIRE : récursion
             *
             * https://www.w3.org/TR/2011/REC-CSS2-20110607/visuren.html#anonymous-block-level */
            anciens_enfants := noeud_disposition.enfants
            diffère déloge(anciens_enfants)

            noeud_inline_courant := noeud_disposition
            noeud_inline_courant.enfants.pointeur = nul
            noeud_inline_courant.enfants.taille = 0
            noeud_inline_courant.enfants.capacité = 0

            pour anciens_enfants {
                si it.type == NoeudDeDispositionBloc {
                    parent.ajoute_enfant(it)
                    noeud_inline_courant = nul
                    continue
                }

                si noeud_inline_courant == nul {
                    noeud_inline_courant = arbre.crée_noeud(NoeudDeDispositionInline)
                    noeud_inline_courant.parent = noeud_disposition
                    noeud_inline_courant.est_disposition_inline = vrai
                    crée_style_pour_bloc_anonyme(résolveuse, noeud_inline_courant, noeud_disposition)
                    noeud_inline_courant.propriétés = copie_propriétés(noeud_disposition.propriétés)
                    parent.ajoute_enfant(noeud_inline_courant)
                }

                noeud_inline_courant.ajoute_enfant(it)
            }
        }
        sinon {
            nouveaux_enfants: [..]*NoeudDeDisposition

            bloc_anonyme_courant: *NoeudDeDispositionBloc
            pour noeud_disposition.enfants {
                si it.type == NoeudDeDispositionBloc {
                    tableau_ajoute(*nouveaux_enfants, it)
                    bloc_anonyme_courant = nul
                    continue
                }

                si bloc_anonyme_courant == nul {
                    bloc_anonyme_courant = arbre.crée_noeud(NoeudDeDispositionBloc)
                    bloc_anonyme_courant.parent = noeud_disposition
                    bloc_anonyme_courant.est_disposition_inline = vrai
                    crée_style_pour_bloc_anonyme(résolveuse, bloc_anonyme_courant, noeud_disposition)
                    tableau_ajoute(*nouveaux_enfants, bloc_anonyme_courant)
                }

                bloc_anonyme_courant.ajoute_enfant(it)
            }

            déloge(noeud_disposition.enfants)
            noeud_disposition.enfants = nouveaux_enfants
        }
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ContexteDisposition
 * \{ */

ContexteDisposition :: struct {
    globales: *GlobalesDessin
    largeur_disponible: r32
    hauteur_disponible: r32
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ContexteDessin
 * \{ */

ContexteDessin :: struct {
    globales: *GlobalesDessin
    peintre: *Peintre
    fragment: *Fragment

    hauteur_vue: z32
    largeur_vue: z32

    décalage_y: r32
}

donne_rectangle_corrigé :: fonc (ctx: *ContexteDessin, rect: RectanglePosDim(r32)) -> RectanglePosDim(r32)
{
    /* Nous disposons les noeuds comme si leur origine était leur coin du haut
     * gauche mais nous devons les dessiner comme si leur origine était leur
     * coin du bas gauche.
     * De plus, nous devons nous assurer que l'origine du document est le bas
     * gauche de la page et non le haut gauche. */
    rect.y = ctx.hauteur_vue comme r32 + ctx.décalage_y - rect.y - rect.hauteur
    retourne rect
}

remplis_rectangle_id :: fonc (ctx: *ContexteDessin, noeud: *NoeudDeDisposition)
{
    // peintre := ctx.peintre

    // entropie := graine_aléatoire(noeud.id + 1)

    // couleur: CouleurRVBA
    // couleur.r = aléatoire_unilatérale(entropie)
    // couleur.v = aléatoire_unilatérale(entropie)
    // couleur.b = aléatoire_unilatérale(entropie)
    // couleur.a = 1.0

    rect := ctx.donne_rectangle_corrigé(noeud.donne_rectangle_bordure())
    // peintre.remplis_rectangle(rect, couleur)

    IGUMI.utilise_nuanceur(IGUMI.nuanceur_id)
    IGUMI.commence_immédiat_id()
    diffère IGUMI.termine_immédiat_id(IGUMI.ModeImmédiat.TRIANGLES)

    // imprime("[%] (% % % %) : %\n", #nom_de_cette_fonction, rect.x, rect.y, rect.largeur, rect.hauteur, noeud.id)

    IGUMI.quad_immédiat_id(rect.x, rect.y, rect.largeur, rect.hauteur, noeud.id)
}

remplis_rectangle_id :: fonc (ctx: *ContexteDessin, noeud: *NoeudDeDisposition, rect: RectanglePosDim(r32))
{
    // peintre := ctx.peintre

    // entropie := graine_aléatoire(noeud.id + 1)

    // couleur: CouleurRVBA
    // couleur.r = aléatoire_unilatérale(entropie)
    // couleur.v = aléatoire_unilatérale(entropie)
    // couleur.b = aléatoire_unilatérale(entropie)
    // couleur.a = 1.0

    rect = ctx.donne_rectangle_corrigé(rect)
    // peintre.remplis_rectangle(rect, couleur)

    IGUMI.utilise_nuanceur(IGUMI.nuanceur_id)
    IGUMI.commence_immédiat_id()
    diffère IGUMI.termine_immédiat_id(IGUMI.ModeImmédiat.TRIANGLES)

    // imprime("[%] (% % % %) : %\n", #nom_de_cette_fonction, rect.x, rect.y, rect.largeur, rect.hauteur, noeud.id)

    IGUMI.quad_immédiat_id(rect.x, rect.y, rect.largeur, rect.hauteur, noeud.id)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NoeudDeDisposition
 * \{ */

ModèleDeBoite :: struct {
    marge: RectanglePosDim(r32)
    bordure: RectanglePosDim(r32)
    rembourrage: RectanglePosDim(r32)
    contenu: RectanglePosDim(r32)
}

NoeudDeDisposition :: struct {
    type := #type_de_cette_structure

    id: n32
    propriétés: *PropriétésDeStyle

    parent: *NoeudDeDisposition
    enfants: [..]*NoeudDeDisposition

    modèle_de_boite: ModèleDeBoite

    sur_mesure: fonc (*NoeudDeDisposition, *ContexteDisposition)(rien)
    sur_dessin: fonc (*NoeudDeDisposition, *ContexteDessin)(rien)
    sur_dessin_tampon_id: fonc (*NoeudDeDisposition, *ContexteDessin)(rien)
    sur_divise_en_lignes: fonc (*NoeudDeDisposition, *NoeudDeDispositionBloc, *ContexteDisposition)(rien)
}

donne_rectangle_bordure :: fonc (noeud: *NoeudDeDisposition) -> RectanglePosDim(r32)
{
    retourne noeud.modèle_de_boite.bordure
}

donne_rectangle_contenu :: fonc (noeud: *NoeudDeDisposition) -> RectanglePosDim(r32)
{
    retourne noeud.modèle_de_boite.contenu
}

ajourne_boite_pour_calcul_largeur :: fonc (noeud: *NoeudDeDisposition)
{
    style := *noeud.propriétés.style

    margin_left := style.valeurs[IDPropriété.MarginLeft].number comme r32
    border_left_width := style.valeurs[IDPropriété.BorderWidthLeft].number comme r32
    padding_left := style.valeurs[IDPropriété.PaddingLeft].number comme r32
    width := style.valeurs[IDPropriété.Width].number comme r32
    padding_right := style.valeurs[IDPropriété.PaddingRight].number comme r32
    border_right_width := style.valeurs[IDPropriété.BorderWidthRight].number comme r32
    margin_right := style.valeurs[IDPropriété.MarginRight].number comme r32

    noeud.modèle_de_boite.marge.x = 0.0
    noeud.modèle_de_boite.marge.largeur = margin_left + border_left_width + padding_left + width + padding_right + border_right_width + margin_right

    noeud.modèle_de_boite.bordure.x = margin_left
    noeud.modèle_de_boite.bordure.largeur = border_left_width + padding_left + width + padding_right + border_right_width

    noeud.modèle_de_boite.rembourrage.x = margin_left + border_left_width
    noeud.modèle_de_boite.rembourrage.largeur =  padding_left + width + padding_right

    noeud.modèle_de_boite.contenu.x = margin_left + border_left_width + padding_left
    noeud.modèle_de_boite.contenu.largeur = width
}

ajourne_boite_pour_calcul_hauteur :: fonc (noeud: *NoeudDeDisposition)
{
    style := *noeud.propriétés.style

    margin_top := style.valeurs[IDPropriété.MarginTop].number comme r32
    border_top_height := style.valeurs[IDPropriété.BorderWidthTop].number comme r32
    padding_top := style.valeurs[IDPropriété.PaddingTop].number comme r32
    height := style.valeurs[IDPropriété.Height].number comme r32
    padding_bottom := style.valeurs[IDPropriété.PaddingBottom].number comme r32
    border_bottom_height := style.valeurs[IDPropriété.BorderWidthBottom].number comme r32
    margin_bottom := style.valeurs[IDPropriété.MarginBottom].number comme r32

    noeud.modèle_de_boite.marge.y = 0.0
    noeud.modèle_de_boite.marge.hauteur = margin_top + border_top_height + padding_top + height + padding_bottom + border_bottom_height + margin_bottom

    noeud.modèle_de_boite.bordure.y = margin_top
    noeud.modèle_de_boite.bordure.hauteur = border_top_height + padding_top + height + padding_bottom + border_bottom_height

    noeud.modèle_de_boite.rembourrage.y = margin_top + border_top_height
    noeud.modèle_de_boite.rembourrage.hauteur =  padding_top + height + padding_bottom

    noeud.modèle_de_boite.contenu.y = margin_top + border_top_height + padding_top
    noeud.modèle_de_boite.contenu.hauteur = height
}

donne_propriété_parent :: fonc (noeud_texte: *NoeudDeDisposition) -> *PropriétésDeStyle
{
    parent := noeud_texte.parent
    tantque !est_noeud_non_anonyme(parent) {
        parent = parent.parent
    }
    retourne parent.propriétés
}

est_noeud_non_anonyme :: fonc (noeud: *NoeudDeDisposition) -> bool
{
    si noeud.type != NoeudDeDispositionBloc && noeud.type != NoeudDeDispositionInline {
        retourne faux
    }

    noeud_bloc := noeud comme *NoeudDeDispositionBloc
    retourne noeud_bloc.élément != nul
}

donne_élément :: fonc (noeud: *NoeudDeDisposition) -> *HTML.Élément
{
    noeud_courant := noeud

    tantque noeud_courant != nul && !est_noeud_non_anonyme(noeud_courant) {
        noeud_courant = noeud_courant.parent
    }

    si noeud_courant {
        si noeud_courant.type == NoeudDeDispositionInline {
            retourne (noeud_courant comme *NoeudDeDispositionBloc).élément
        }
        si noeud_courant.type == NoeudDeDispositionRemplacement {
            retourne (noeud_courant comme *NoeudDeDispositionBloc).élément
        }
        retourne (noeud_courant comme *NoeudDeDispositionBloc).élément
    }

    retourne nul
}

décale :: fonc (noeud: *NoeudDeDisposition, x: r32, y: r32)
{
    noeud.modèle_de_boite.marge.x += x
    noeud.modèle_de_boite.bordure.x += x
    noeud.modèle_de_boite.rembourrage.x += x
    noeud.modèle_de_boite.contenu.x += x

    noeud.modèle_de_boite.marge.y += y
    noeud.modèle_de_boite.bordure.y += y
    noeud.modèle_de_boite.rembourrage.y += y
    noeud.modèle_de_boite.contenu.y += y

    pour noeud.enfants {
        it.décale(x, y)
    }

    si noeud.type == NoeudDeDispositionBloc || noeud.type == NoeudDeDispositionInline {
        bloc := noeud comme *NoeudDeDispositionBloc
        pour bloc.lignes {
            pour * fragment dans it.fragments {
                fragment.x += x
                fragment.y += y
            }
        }
    }
}

donne_nom_classe :: fonc (noeud: *NoeudDeDisposition) -> chaine
{
    infos := __table_des_types[noeud.type] comme *InfoTypeStructure
    retourne infos.nom
}

mesure :: fonc (noeud: *NoeudDeDisposition, ctx: *ContexteDisposition)
{
    si noeud.sur_mesure {
        noeud.sur_mesure(noeud, ctx)
    }
}

dessine :: fonc (noeud: *NoeudDeDisposition, ctx: *ContexteDessin)
{
    si noeud.sur_dessin {
        noeud.sur_dessin(noeud, ctx)
    }
}

dessine_tampon_id :: fonc (noeud: *NoeudDeDisposition, ctx: *ContexteDessin)
{
    si noeud.sur_dessin_tampon_id {
        noeud.sur_dessin_tampon_id(noeud, ctx)
    }
}

ajoute_enfant :: fonc (parent: *NoeudDeDisposition, enfant: *NoeudDeDisposition)
{
    enfant.parent = parent
    tableau_ajoute(*parent.enfants, enfant)
}

donne_curseur :: fonc (noeud: *NoeudDeDisposition) -> CursorType
{
    saufsi noeud.propriétés {
        retourne CursorType.auto
    }
    retourne noeud.propriétés.style.valeurs[IDPropriété.Cursor].cursor
}

divise_en_lignes :: fonc (noeud: *NoeudDeDisposition, bloc_contenant: *NoeudDeDispositionBloc, ctx: *ContexteDisposition)
{
    si noeud.sur_divise_en_lignes {
        noeud.sur_divise_en_lignes(noeud, bloc_contenant, ctx)
        retourne
    }

    pour noeud.enfants {
        divise_en_lignes(it, bloc_contenant, ctx)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom BoiteDeLigne
 * Boite pour tenir les fragments de chaque ligne pour les dispositions
 * « inline ».
 * https://www.w3.org/TR/2011/REC-CSS2-20110607/visuren.html#line-box
 * \{ */

Fragment :: struct {
    noeud: *NoeudDeDisposition
    index_début: z64
    index_fin: z64

    x: r32
    y: r32
    hauteur: r32
    largeur: r32
}

donne_rectangle :: fonc (fragment: *Fragment) -> RectanglePosDim(r32)
{
    rect: RectanglePosDim(r32)
    rect.x = fragment.x
    rect.y = fragment.y
    rect.largeur = fragment.largeur
    rect.hauteur = fragment.hauteur
    retourne rect
}

BoiteDeLigne :: struct {
    bloc: *NoeudDeDispositionBloc

    fragments: [..]Fragment
    largeur_courante: r32
}

détruit_données_boite_de_ligne :: fonc (boite: *BoiteDeLigne)
{
    déloge(boite.fragments)
}

peut_ajouter_fragment :: fonc (boite: *BoiteDeLigne, largeur: r32) -> bool
{
    retourne (boite.largeur_courante + largeur) < boite.bloc.propriétés.style.valeurs[IDPropriété.Width].number comme r32
}

ajoute_fragment :: fonc (boite: *BoiteDeLigne, noeud: *NoeudDeDisposition, index_début: z64, index_fin: z64, hauteur: r32, largeur: r32)
{
    fragment: Fragment
    fragment.noeud = noeud
    fragment.index_début = index_début
    fragment.index_fin = index_fin
    fragment.hauteur = hauteur
    fragment.largeur = largeur
    fragment.x = boite.largeur_courante

    boite.largeur_courante += largeur

    tableau_ajoute(*boite.fragments, fragment)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NoeudDeDispositionBloc
 * \{ */

/* Créé pour chaque noeud hors texte */
NoeudDeDispositionBloc :: struct {
    empl base: NoeudDeDisposition
    type = #type_de_cette_structure
    sur_mesure = noeud_disposition_bloc_sur_mesure
    sur_dessin = noeud_disposition_bloc_sur_dessin
    sur_dessin_tampon_id = noeud_disposition_bloc_sur_dessin_tampon_id

    élément: *HTML.Élément

    lignes: [..]BoiteDeLigne

    est_disposition_inline: bool
}

noeud_disposition_bloc_sur_mesure :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDisposition)
{
    noeud := base comme *NoeudDeDispositionBloc

    saufsi noeud.est_disposition_inline {
        dispose_enfants_block(noeud, ctx)
    }
    sinon {
        dispose_enfants_inline(noeud, ctx)
    }
}

noeud_disposition_bloc_sur_dessin :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDessin)
{
    noeud := base comme *NoeudDeDispositionBloc

    peintre := ctx.peintre

    si noeud.est_noeud_non_anonyme() {
        background_color := noeud.propriétés.style.valeurs[IDPropriété.BackgroundColor].couleur
        si background_color.a != 0 {
            rect_noeud: RectanglePosDim(r32)
            si base.parent == nul {
                /* L'arrière plan de l'élément racine doit s'appliquer au cannevas. */
                rect_noeud.hauteur = ctx.hauteur_vue comme r32
                rect_noeud.largeur = ctx.largeur_vue comme r32
            }
            sinon {
                rect_noeud = ctx.donne_rectangle_corrigé(noeud.donne_rectangle_bordure())
            }

            peintre.remplis_rectangle(rect_noeud, background_color)
        }
        sinon si noeud.parent == nul && noeud.élément && noeud.élément.local_name == HTML.TAG_html {
            /* Hérite de l'arrière-plan du "body".
             * https://www.w3.org/TR/CSS21/colors.html#background */
            body := HTML.donne_élément_body(noeud.élément.document)
            si body && body.noeud_de_disposition {
                background_color = body.noeud_de_disposition.propriétés.style.valeurs[IDPropriété.BackgroundColor].couleur
                si background_color.a != 0 {
                    /* À FAIRE : ne peint pas l'arrière-plan du "body" dans ce cas. */
                    rect_noeud: RectanglePosDim(r32)
                    rect_noeud.hauteur = ctx.hauteur_vue comme r32
                    rect_noeud.largeur = ctx.largeur_vue comme r32
                    peintre.remplis_rectangle(rect_noeud, background_color)
                }
            }
        }

        bordure := donne_bordure(*noeud.propriétés.style)

        pour bordure.style {
            si it == LineStyle.None || it == LineStyle.Hidden {
                continue
            }

            coté := index_it comme z32 comme BorderEdge

            couleur: CouleurRVBAN8

            si it == LineStyle.Inset {
                si coté == BorderEdge.Top || coté == BorderEdge.Left {
                    couleur = CouleurRVBAN8(154, 154, 154, 255)
                }
                sinon {
                    couleur = CouleurRVBAN8(238, 238, 238, 255)
                }
            }
            sinon si it == LineStyle.Outset {
                si coté == BorderEdge.Top || coté == BorderEdge.Left {
                    couleur = CouleurRVBAN8(238, 238, 238, 255)
                }
                sinon {
                    couleur = CouleurRVBAN8(154, 154, 154, 255)
                }
            }
            sinon {
                border_color := bordure.color[coté]
                /* À FAIRE : calcule la valeur même s'il n'y a pas de propriété. */
                si border_color.est_mot_clé(PROP_currentColor) {
                    couleur = noeud.propriétés.style.valeurs[IDPropriété.Color]
                }
                sinon {
                    couleur = bordure.color[coté].couleur
                }
            }

            largeur := bordure.width[coté].number comme r32

            rect: RectanglePosDim(r32)
            rect_bordure := noeud.donne_rectangle_bordure()

            si coté == BorderEdge.Top {
                rect.x = rect_bordure.x
                rect.y = rect_bordure.y
                rect.largeur = rect_bordure.largeur
                rect.hauteur = largeur
            }
            sinon si coté == BorderEdge.Bottom {
                rect.x = rect_bordure.x
                rect.y = rect_bordure.y + rect_bordure.hauteur - largeur
                rect.largeur = rect_bordure.largeur
                rect.hauteur = largeur
            }
            sinon si coté == BorderEdge.Left {
                rect.x = rect_bordure.x
                rect.y = rect_bordure.y
                rect.largeur = largeur
                rect.hauteur = rect_bordure.hauteur
            }
            sinon /* si coté == BorderEdge.Right */ {
                rect.x = rect_bordure.x + rect_bordure.largeur - largeur
                rect.y = rect_bordure.y
                rect.largeur = largeur
                rect.hauteur = rect_bordure.hauteur
            }

            rect = ctx.donne_rectangle_corrigé(rect)
            peintre.remplis_rectangle(rect, couleur)
        }
    }

    saufsi noeud.est_disposition_inline {
        dessine_enfants_block(noeud, ctx)
    }
    sinon {
        dessine_enfants_inline(noeud, ctx)
    }
}

noeud_disposition_bloc_sur_dessin_tampon_id :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDessin)
{
    noeud := base comme *NoeudDeDispositionBloc

    ctx.remplis_rectangle_id(noeud)

    saufsi noeud.est_disposition_inline {
        dessine_tampon_id_enfants_block(noeud, ctx)
    }
    sinon {
        dessine_tampon_id_enfants_inline(noeud, ctx)
    }
}

ajoute_ligne :: fonc (bloc: *NoeudDeDispositionBloc) -> *BoiteDeLigne
{
    ligne := tableau_ajoute_élément(*bloc.lignes)
    ligne.bloc = bloc
    retourne ligne
}

donne_ligne_courante :: fonc (bloc: *NoeudDeDispositionBloc) -> *BoiteDeLigne
{
    si bloc.lignes.taille == 0 {
        retourne ajoute_ligne(bloc)
    }

    retourne *bloc.lignes[bloc.lignes.taille - 1]
}

dispose_enfants_block :: fonc (noeud: *NoeudDeDispositionBloc, ctx: *ContexteDisposition)
{
    ctx_locale := mémoire(ctx)

    /* À FAIRE : utilise les bonnes formules.
     * https://www.w3.org/TR/2011/REC-CSS2-20110607/visudet.html#Computing_widths_and_margins */
    calcule_largeur_et_marges(noeud, ctx.largeur_disponible comme r64)
    calcule_hauteur_et_marges(noeud)
    ctx_locale.largeur_disponible = noeud.modèle_de_boite.contenu.largeur

    /* https://www.w3.org/TR/CSS2/box.html#collapsing-margins */
    décalage_x := noeud.modèle_de_boite.contenu.x
    décalage_y := noeud.modèle_de_boite.contenu.y

    // dernière_marge := marges[BorderEdge.Top]

    hauteur_contenu := 0.0

    pour noeud.enfants {
        it.mesure(*ctx_locale)

        position := it.propriétés.style.valeurs[IDPropriété.Position]
        /* À FAIRE : https://drafts.csswg.org/css-position/#abspos-layout */
        si position.est_mot_clé(PROP_absolute) {
            top := it.propriétés.style.valeurs[IDPropriété.Top]
            bottom := it.propriétés.style.valeurs[IDPropriété.Bottom]
            left := it.propriétés.style.valeurs[IDPropriété.Left]
            right := it.propriétés.style.valeurs[IDPropriété.Right]

            si left.est_auto() && right.est_auto() {
                left = ValeurDeStyle(number = 0.0)
            }
            sinon si left.est_auto() {
                left = ValeurDeStyle(number = -right.number)
            }

            si top.est_auto() && bottom.est_auto() {
                top = ValeurDeStyle(number = 0.0)
            }
            sinon si top.est_auto() {
                top = ValeurDeStyle(number = -bottom.number)
            }

            it.décale(décalage_x + left.number comme r32, décalage_y + hauteur_contenu + top.number comme r32)
            continue
        }

        hauteur_enfant := it.modèle_de_boite.marge.hauteur

        // marges_enfant := it.marges
        // marge_inter_enfant := max(marges_enfant[BorderEdge.Bottom], dernière_marge)
        // décalage_y := marge_inter_enfant comme r32

        it.décale(décalage_x, décalage_y + hauteur_contenu)

        // dernière_marge = marges_enfant[BorderEdge.Bottom]

        si index_it == 0 {
            hauteur_contenu += hauteur_enfant // + marges[BorderEdge.Top] comme r32
        }
        sinon si index_it == noeud.enfants.taille - 1 {
            hauteur_contenu += hauteur_enfant // + marges[BorderEdge.Bottom] comme r32
        }
        sinon {
            hauteur_contenu += hauteur_enfant // + dernière_marge comme r32
        }
    }

    pour noeud.enfants {
        position := it.propriétés.style.valeurs[IDPropriété.Position]
        /* À FAIRE : https://drafts.csswg.org/css-position/#relpos-insets */
        si position.est_mot_clé(PROP_relative) {
            top := it.propriétés.style.valeurs[IDPropriété.Top]
            bottom := it.propriétés.style.valeurs[IDPropriété.Bottom]
            left := it.propriétés.style.valeurs[IDPropriété.Left]
            right := it.propriétés.style.valeurs[IDPropriété.Right]

            si left.est_auto() && right.est_auto() {
                left = ValeurDeStyle(number = 0.0)
            }
            sinon si left.est_auto() {
                left = ValeurDeStyle(number = -right.number)
            }

            si top.est_auto() && bottom.est_auto() {
                top = ValeurDeStyle(number = 0.0)
            }
            sinon si top.est_auto() {
                top = ValeurDeStyle(number = -bottom.number)
            }

            it.décale(left.number comme r32, top.number comme r32)
        }
    }

    noeud.propriétés.style.valeurs[IDPropriété.Height] = ValeurDeStyle(number = hauteur_contenu)
    calcule_hauteur_et_marges(noeud)
}

calcule_largeur_et_marges :: fonc (noeud: *NoeudDeDispositionBloc, width_of_containing_block: r64)
{
    résoud_pourcentage_largeurs(noeud, width_of_containing_block)

    // À FAIRE : ne modifie pas les valeurs calculées
    sauvegarde_style := noeud.propriétés.style
    calcule_largeur_et_marges_block_level_normal_flow(noeud, width_of_containing_block)

    width := noeud.propriétés.style.valeurs[IDPropriété.Width]
    max_width := noeud.propriétés.style.valeurs[IDPropriété.MaxWidth]
    si max_width.est_nombre() && (width.number > max_width.number) {
        noeud.propriétés.style = sauvegarde_style
        noeud.propriétés.style.valeurs[IDPropriété.Width] = max_width
        calcule_largeur_et_marges_block_level_normal_flow(noeud, width_of_containing_block)
    }

    width = noeud.propriétés.style.valeurs[IDPropriété.Width]
    min_width := noeud.propriétés.style.valeurs[IDPropriété.MinWidth]
    si min_width.est_nombre() && (width.number < min_width.number) {
        noeud.propriétés.style = sauvegarde_style
        noeud.propriétés.style.valeurs[IDPropriété.Width] = min_width
        calcule_largeur_et_marges_block_level_normal_flow(noeud, width_of_containing_block)
    }

    ajourne_boite_pour_calcul_largeur(noeud)
}

calcule_pourcentage :: fonc (valeur: ValeurDeStyle, référence: r64) -> ValeurDeStyle
{
    saufsi valeur.est_percentage() {
        retourne valeur
    }

    retourne ValeurDeStyle(number = valeur.percentage * référence / 100.0)
}

résoud_pourcentage_largeurs :: fonc (noeud: *NoeudDeDispositionBloc, width_of_containing_block: r64)
{
    style := *noeud.propriétés.style

    margin_left := style.valeurs[IDPropriété.MarginLeft]
    border_left_width := style.valeurs[IDPropriété.BorderWidthLeft]
    padding_left := style.valeurs[IDPropriété.PaddingLeft]
    width := style.valeurs[IDPropriété.Width]
    padding_right := style.valeurs[IDPropriété.PaddingRight]
    border_right_width := style.valeurs[IDPropriété.BorderWidthRight]
    margin_right := style.valeurs[IDPropriété.MarginRight]

    style.valeurs[IDPropriété.MarginLeft] = calcule_pourcentage(margin_left, width_of_containing_block)
    style.valeurs[IDPropriété.BorderWidthLeft] = calcule_pourcentage(border_left_width, width_of_containing_block)
    style.valeurs[IDPropriété.PaddingLeft] = calcule_pourcentage(padding_left, width_of_containing_block)
    style.valeurs[IDPropriété.Width] = calcule_pourcentage(width, width_of_containing_block)
    style.valeurs[IDPropriété.PaddingRight] = calcule_pourcentage(padding_right, width_of_containing_block)
    style.valeurs[IDPropriété.BorderWidthRight] = calcule_pourcentage(border_right_width, width_of_containing_block)
    style.valeurs[IDPropriété.MarginRight] = calcule_pourcentage(margin_right, width_of_containing_block)
}

résoud_pourcentage_hauteur :: fonc (noeud: *NoeudDeDispositionBloc, height_of_containing_block: r64)
{
    style := *noeud.propriétés.style

    margin_top := style.valeurs[IDPropriété.MarginTop]
    border_top_width := style.valeurs[IDPropriété.BorderWidthTop]
    padding_top := style.valeurs[IDPropriété.PaddingTop]
    height := style.valeurs[IDPropriété.Height]
    padding_bottom := style.valeurs[IDPropriété.PaddingBottom]
    border_bottom_width := style.valeurs[IDPropriété.BorderWidthBottom]
    margin_bottom := style.valeurs[IDPropriété.MarginBottom]

    style.valeurs[IDPropriété.MarginTop] = calcule_pourcentage(margin_top, height_of_containing_block)
    style.valeurs[IDPropriété.BorderWidthTop] = calcule_pourcentage(border_top_width, height_of_containing_block)
    style.valeurs[IDPropriété.PaddingTop] = calcule_pourcentage(padding_top, height_of_containing_block)
    style.valeurs[IDPropriété.Height] = calcule_pourcentage(height, height_of_containing_block)
    style.valeurs[IDPropriété.PaddingBottom] = calcule_pourcentage(padding_bottom, height_of_containing_block)
    style.valeurs[IDPropriété.BorderWidthBottom] = calcule_pourcentage(border_bottom_width, height_of_containing_block)
    style.valeurs[IDPropriété.MarginBottom] = calcule_pourcentage(margin_bottom, height_of_containing_block)
}

calcule_hauteur_et_marges :: fonc (noeud: *NoeudDeDispositionBloc)
{
    style := *noeud.propriétés.style

    /* À FAIRE */
    margin_top := style.valeurs[IDPropriété.MarginTop]
    border_top_height := style.valeurs[IDPropriété.BorderWidthTop]
    padding_top := style.valeurs[IDPropriété.PaddingTop]
    height := style.valeurs[IDPropriété.Height]
    padding_bottom := style.valeurs[IDPropriété.PaddingBottom]
    border_bottom_height := style.valeurs[IDPropriété.BorderWidthBottom]
    margin_bottom := style.valeurs[IDPropriété.MarginBottom]

    saufsi margin_top.est_nombre() {
        margin_top = ValeurDeStyle(number = 0)
    }
    saufsi border_top_height.est_nombre() {
        border_top_height = ValeurDeStyle(number = 0)
    }
    saufsi padding_top.est_nombre() {
        padding_top = ValeurDeStyle(number = 0)
    }
    saufsi height.est_nombre() {
        height = ValeurDeStyle(number = 0)
    }
    saufsi padding_bottom.est_nombre() {
        padding_bottom = ValeurDeStyle(number = 0)
    }
    saufsi border_bottom_height.est_nombre() {
        border_bottom_height = ValeurDeStyle(number = 0)
    }
    saufsi margin_bottom.est_nombre() {
        margin_bottom = ValeurDeStyle(number = 0)
    }

    style.valeurs[IDPropriété.MarginTop] = margin_top
    style.valeurs[IDPropriété.BorderWidthTop] = border_top_height
    style.valeurs[IDPropriété.PaddingTop] = padding_top
    style.valeurs[IDPropriété.Height] = height
    style.valeurs[IDPropriété.PaddingBottom] = padding_bottom
    style.valeurs[IDPropriété.BorderWidthBottom] = border_bottom_height
    style.valeurs[IDPropriété.MarginBottom] = margin_bottom

    ajourne_boite_pour_calcul_hauteur(noeud)
}

/* https://www.w3.org/TR/2011/REC-CSS2-20110607/visudet.html#blockwidth */
calcule_largeur_et_marges_block_level_normal_flow :: fonc (noeud: *NoeudDeDispositionBloc, width_of_containing_block: r64)
{
    style := *noeud.propriétés.style

    margin_left := style.valeurs[IDPropriété.MarginLeft]
    border_left_width := style.valeurs[IDPropriété.BorderWidthLeft]
    padding_left := style.valeurs[IDPropriété.PaddingLeft]
    width := style.valeurs[IDPropriété.Width]
    padding_right := style.valeurs[IDPropriété.PaddingRight]
    border_right_width := style.valeurs[IDPropriété.BorderWidthRight]
    margin_right := style.valeurs[IDPropriété.MarginRight]

    // If 'width' is not 'auto' and 'border-left-width' + 'padding-left' + 'width' + 'padding-right'
    // + 'border-right-width' (plus any of 'margin-left' or 'margin-right' that are not 'auto') is
    // larger than the width of the containing block, then any 'auto' values for 'margin-left' or
    // 'margin-right' are, for the following rules, treated as zero.
    saufsi width.est_auto() {
        tmp : r64 = 0.0
        tmp += border_left_width.number
        tmp += padding_left.number
        tmp += width.number
        tmp += padding_right.number
        tmp += border_right_width.number

        saufsi margin_left.est_auto() {
            tmp += margin_left.number
        }
        saufsi margin_right.est_auto() {
            tmp += margin_right.number
        }

        si tmp > width_of_containing_block {
            si margin_left.est_auto() {
                margin_left = ValeurDeStyle(number = 0.0)
            }
            si margin_right.est_auto() {
                margin_right = ValeurDeStyle(number = 0.0)
            }
        }
    }

    // If all of the above have a computed value other than 'auto', the values are said to be "over-constrained"
    // and one of the used values will have to be different from its computed value.
    // If the 'direction' property of the containing block has the value 'ltr', the specified value of
    // 'margin-right' is ignored and the value is calculated so as to make the equality true.
    // If the value of 'direction' is 'rtl', this happens to 'margin-left' instead.
    surcontraint := 0
    surcontraint += margin_left.est_auto() comme z32
    surcontraint += border_left_width.est_auto() comme z32
    surcontraint += padding_left.est_auto() comme z32
    surcontraint += width.est_auto() comme z32
    surcontraint += padding_right.est_auto() comme z32
    surcontraint += border_right_width.est_auto() comme z32
    surcontraint += margin_right.est_auto() comme z32

    si surcontraint == 0 {
        // À FAIRE : direction
        margin_right = ValeurDeStyle(number = 0.0)
    }

    // If there is exactly one value specified as 'auto', its used value follows from the equality.
    si surcontraint == 1 {
        si margin_left.est_auto() {
            résultat := width_of_containing_block - (border_left_width.number + padding_left.number + width.number + padding_right.number + border_right_width.number + margin_right.number)
            margin_left = ValeurDeStyle(number = résultat)
        }
        sinon si border_left_width.est_auto() {
            résultat := width_of_containing_block - (margin_left.number + padding_left.number + width.number + padding_right.number + border_right_width.number + margin_right.number)
            border_left_width = ValeurDeStyle(number = résultat)
        }
        sinon si padding_left.est_auto() {
            résultat := width_of_containing_block - (margin_left.number + border_left_width.number + width.number + padding_right.number + border_right_width.number + margin_right.number)
            padding_left = ValeurDeStyle(number = résultat)
        }
        sinon si width.est_auto() {
            résultat := width_of_containing_block - (margin_left.number + border_left_width.number + padding_left.number + padding_right.number + border_right_width.number + margin_right.number)
            width = ValeurDeStyle(number = résultat)
        }
        sinon si padding_right.est_auto() {
            résultat := width_of_containing_block - (margin_left.number + border_left_width.number + padding_left.number + width.number + border_right_width.number + margin_right.number)
            padding_right = ValeurDeStyle(number = résultat)
        }
        sinon si border_right_width.est_auto() {
            résultat := width_of_containing_block - (margin_left.number + border_left_width.number + padding_left.number + width.number + padding_right.number + margin_right.number)
            border_right_width = ValeurDeStyle(number = résultat)
        }
        sinon si margin_right.est_auto() {
            résultat := width_of_containing_block - (margin_left.number + border_left_width.number + padding_left.number + width.number + padding_right.number + border_right_width.number)
            margin_right = ValeurDeStyle(number = résultat)
        }
    }

    // If 'width' is set to 'auto', any other 'auto' values become '0' and 'width' follows from the resulting equality.
    si width.est_auto() {
        si margin_left.est_auto() {
            margin_left = ValeurDeStyle(number = 0.0)
        }
        si border_left_width.est_auto() {
            border_left_width = ValeurDeStyle(number = 0.0)
        }
        si padding_left.est_auto() {
            padding_left = ValeurDeStyle(number = 0.0)
        }
        si padding_right.est_auto() {
            padding_right = ValeurDeStyle(number = 0.0)
        }
        si border_right_width.est_auto() {
            border_right_width = ValeurDeStyle(number = 0.0)
        }
        si margin_right.est_auto() {
            margin_right = ValeurDeStyle(number = 0.0)
        }

        résultat := width_of_containing_block - (margin_left.number + border_left_width.number + padding_left.number + padding_right.number + border_right_width.number + margin_right.number)
        width = ValeurDeStyle(number = résultat)
    }

    // If both 'margin-left' and 'margin-right' are 'auto', their used values are equal.
    // This horizontally centers the element with respect to the edges of the containing block.
    si margin_left.est_auto() && margin_right.est_auto() {
        résultat := width_of_containing_block - (border_left_width.number + padding_left.number + width.number + padding_right.number + border_right_width.number)
        résultat *= 0.5

        margin_left = ValeurDeStyle(number = résultat)
        margin_right = ValeurDeStyle(number = résultat)
    }

    style.valeurs[IDPropriété.MarginLeft] = margin_left
    style.valeurs[IDPropriété.BorderWidthLeft] = border_left_width
    style.valeurs[IDPropriété.PaddingLeft] = padding_left
    style.valeurs[IDPropriété.Width] = width
    style.valeurs[IDPropriété.PaddingRight] = padding_right
    style.valeurs[IDPropriété.BorderWidthRight] = border_right_width
    style.valeurs[IDPropriété.MarginRight] = margin_right
}

dessine_enfants_block :: fonc (noeud: *NoeudDeDispositionBloc, ctx: *ContexteDessin)
{
    // rect := ctx.donne_rectangle_corrigé(noeud)

    // couleur := CouleurRVBA(0.5, 0.0, 0.5, 1.0)

    // peintre := ctx.peintre
    // peintre.dessine_rectangle(rect, couleur)

    pour noeud.enfants {
        position := it.propriétés.style.valeurs[IDPropriété.Position]
        saufsi position.est_mot_clé(PROP_static) {
            continue
        }
        dessine(it, ctx)
    }

    pour noeud.enfants {
        position := it.propriétés.style.valeurs[IDPropriété.Position]
        si position.est_mot_clé(PROP_static) {
            continue
        }
        dessine(it, ctx)
    }
}

dessine_tampon_id_enfants_block :: fonc (noeud: *NoeudDeDispositionBloc, ctx: *ContexteDessin)
{
    pour noeud.enfants {
        dessine_tampon_id(it, ctx)
    }
}

AlignementTexte :: énum {
    Gauche
    Droite
    Centre
    Justifié
}

donne_alignement_texte :: fonc (noeud: *NoeudDeDispositionBloc) -> AlignementTexte
{
    style := *noeud.propriétés.style
    text_align := style.valeurs[IDPropriété.TextAlign]

    si text_align.est_mot_clé(PROP_start) {
        retourne AlignementTexte.Gauche
    }

    si text_align.est_mot_clé(PROP_end) {
        retourne AlignementTexte.Droite
    }

    si text_align.est_mot_clé(PROP_left) {
        retourne AlignementTexte.Gauche
    }

    si text_align.est_mot_clé(PROP_right) {
        retourne AlignementTexte.Droite
    }

    si text_align.est_mot_clé(PROP_center) {
        retourne AlignementTexte.Centre
    }

    si text_align.est_mot_clé(PROP_justify) {
        retourne AlignementTexte.Justifié
    }

    retourne AlignementTexte.Gauche
}

dispose_enfants_inline :: fonc (noeud: *NoeudDeDispositionBloc, ctx: *ContexteDisposition)
{
    ctx_locale := mémoire(ctx)

    calcule_largeur_et_marges(noeud, ctx.largeur_disponible comme r64)
    calcule_hauteur_et_marges(noeud)
    ctx_locale.largeur_disponible = noeud.modèle_de_boite.contenu.largeur

    décalage_x := noeud.modèle_de_boite.contenu.x
    décalage_y := noeud.modèle_de_boite.contenu.y

    pour noeud.enfants {
        divise_en_lignes(it, noeud, *ctx_locale)
    }

    hauteur_contenu := 0.0

    alignement := donne_alignement_texte(noeud)

    pour noeud.lignes {
        hauteur := 0.0
        décalage_pour_alignement := 0.0

        si alignement == AlignementTexte.Droite {
            décalage_pour_alignement = ctx_locale.largeur_disponible - it.largeur_courante
        }
        sinon si alignement == AlignementTexte.Centre {
            décalage_pour_alignement = (ctx_locale.largeur_disponible - it.largeur_courante) / 2.0
        }
        sinon si alignement == AlignementTexte.Justifié {
            /* À FAIRE : ignore l'espace finale. */
            décalage_pour_alignement = (ctx_locale.largeur_disponible - it.largeur_courante) / ((it.fragments.taille - 1) comme r32)
        }

        pour * fragment, index_fragment dans it.fragments {
            hauteur = max(fragment.hauteur, hauteur)

            si alignement == AlignementTexte.Justifié {
                si index_fragment != 0 && index_it != (noeud.lignes.taille - 1) {
                    fragment.x += décalage_pour_alignement * (index_fragment comme r32)
                }
            }
            sinon {
                fragment.x += décalage_pour_alignement
            }

            fragment.y = décalage_y
        }
        hauteur_contenu += hauteur
        décalage_y += hauteur
    }

    noeud.modèle_de_boite.marge.hauteur += hauteur_contenu
    noeud.modèle_de_boite.bordure.hauteur += hauteur_contenu
    noeud.modèle_de_boite.contenu.hauteur += hauteur_contenu
    noeud.modèle_de_boite.rembourrage.hauteur += hauteur_contenu

    si décalage_x != 0.0 || décalage_y != 0.0 {
        pour noeud.lignes {
            pour * fragment dans it.fragments {
                fragment.x += décalage_x
            }
        }
    }
}

dessine_enfants_inline :: fonc (noeud: *NoeudDeDispositionBloc, ctx: *ContexteDessin)
{
    ctx_locale := mémoire(ctx)
    pour noeud.lignes {
        pour * fragment dans it.fragments {
            ctx_locale.fragment = fragment
            dessine(fragment.noeud, *ctx_locale)
        }
    }
}

dessine_tampon_id_enfants_inline :: fonc (noeud: *NoeudDeDispositionBloc, ctx: *ContexteDessin)
{
    ctx_locale := mémoire(ctx)
    pour noeud.lignes {
        pour * fragment dans it.fragments {
            ctx_locale.fragment = fragment
            dessine_tampon_id(fragment.noeud, *ctx_locale)
        }
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NoeudDeDispositionInline
 * \{ */

/* Créé pour chaque noeud hors texte */
NoeudDeDispositionInline :: struct {
    empl base_bloc: NoeudDeDispositionBloc
    type = #type_de_cette_structure
    sur_mesure = noeud_disposition_inline_sur_mesure
    sur_dessin = noeud_disposition_inline_sur_dessin
    sur_dessin_tampon_id = noeud_disposition_inline_sur_dessin_tampon_id
}

noeud_disposition_inline_sur_mesure :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDisposition)
{
    noeud := base comme *NoeudDeDispositionInline
    dispose_enfants_inline(noeud, ctx)
}

noeud_disposition_inline_sur_dessin :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDessin)
{
    noeud := base comme *NoeudDeDispositionInline
    dessine_enfants_inline(noeud, ctx)
}

noeud_disposition_inline_sur_dessin_tampon_id :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDessin)
{
    noeud := base comme *NoeudDeDispositionInline
    ctx.remplis_rectangle_id(noeud)
    dessine_tampon_id_enfants_inline(noeud, ctx)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NoeudDeDispositionNouvelleLigne
 * \{ */

/* Créé pour chaque noeud hors texte */
NoeudDeDispositionNouvelleLigne :: struct {
    empl base_bloc: NoeudDeDisposition
    type = #type_de_cette_structure
    sur_divise_en_lignes = noeud_disposition_nouvelle_ligne_sur_divise_en_lignes
}

noeud_disposition_nouvelle_ligne_sur_divise_en_lignes :: fonc (base: *NoeudDeDisposition @inutilisée, bloc_contenant: *NoeudDeDispositionBloc, ctx: *ContexteDisposition @inutilisée)
{
    _ := bloc_contenant.ajoute_ligne()
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NoeudDeDispositionTexte
 * \{ */

/* Créé pour chaque élément contenant du texte. */
NoeudDeDispositionTexte :: struct {
    empl base: NoeudDeDisposition
    type = #type_de_cette_structure
    sur_mesure = noeud_disposition_texte_sur_mesure
    sur_dessin = noeud_disposition_texte_sur_dessin
    sur_divise_en_lignes = noeud_disposition_texte_sur_divise_en_lignes
    sur_dessin_tampon_id = noeud_disposition_texte_sur_dessin_tampon_id

    noeud_texte: *HTML.NoeudTexte
    texte: ChaineUTF16
    fonte: *Fonte

    morceaux: [..]ChaineUTF16
}

détermine_fonte :: fonc (noeud_texte: *NoeudDeDispositionTexte, ctx: *ContexteDisposition) -> *Fonte
{
    globales := ctx.globales
    assert(globales != nul)
    famille_fonte := "sérif"
    style := "normal"
    graisse := GraisseFonte.Normal
    propriétés := donne_propriété_parent(noeud_texte)
    taille_fonte := propriétés.style.valeurs[IDPropriété.FontSize].number comme r32

    font_family := propriétés.style.valeurs[IDPropriété.FontFamily].mot_clé
    si font_family == PROP_monospace {
        famille_fonte = "monospace"
    }
    sinon si font_family == PROP_sans_serif {
        famille_fonte = "sans-serif"
    }

    font_weight := propriétés.style.valeurs[IDPropriété.FontWeight].number
    si font_weight >= 700.0 {
        graisse = GraisseFonte.Gras
    }

    font_style := propriétés.style.valeurs[IDPropriété.FontStyle].mot_clé
    si font_style == PROP_italic {
        style = "italic"
    }

    fonte := globales.donne_fonte(famille_fonte, style, graisse, taille_fonte)
    noeud_texte.fonte = fonte
    retourne fonte
}

noeud_disposition_texte_sur_mesure :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDisposition)
{
    noeud := base comme *NoeudDeDispositionTexte

    si est_vide_ou_uniquement_espaces_blanches(noeud.noeud_texte.données) {
        noeud.sur_dessin = nul
        retourne
    }

    fonte := détermine_fonte(noeud, ctx)
    métriques := fonte.donne_métriques_fonte()

    /* À FAIRE : meilleur algorithme, respect du standard. */
    morceaux := divise_sur_espaces_blanches_ascii(noeud.noeud_texte.données)
    diffère déloge(morceaux)

    enchaineuse: EnchaineuseUTF16
    initialise_enchaineuse(enchaineuse)
    diffère détruit_tampons(enchaineuse)

    virgule := ChaineUTF16Unique(0x20).donne_chaine_utf16()
    pour morceaux {
        si index_it > 0 {
            ajoute(enchaineuse, virgule)
        }
        ajoute(enchaineuse, it)
    }

    texte := chaine_depuis_enchaineuse(enchaineuse)
    noeud.texte = texte

    /* XXX */
    noeud.modèle_de_boite.marge.hauteur = métriques.donne_hauteur_ligne()
    noeud.modèle_de_boite.bordure.hauteur = métriques.donne_hauteur_ligne()
    noeud.modèle_de_boite.contenu.hauteur = métriques.donne_hauteur_ligne()
    noeud.modèle_de_boite.rembourrage.hauteur = métriques.donne_hauteur_ligne()

    largeur_texte := fonte.donne_largeur_texte(texte) comme r32
    noeud.modèle_de_boite.marge.largeur = largeur_texte
    noeud.modèle_de_boite.bordure.largeur = largeur_texte
    noeud.modèle_de_boite.contenu.largeur = largeur_texte
    noeud.modèle_de_boite.rembourrage.largeur = largeur_texte
}

noeud_disposition_texte_sur_divise_en_lignes :: fonc (base: *NoeudDeDisposition, bloc_contenant: *NoeudDeDispositionBloc, ctx: *ContexteDisposition)
{
    noeud := base comme *NoeudDeDispositionTexte

    si est_vide_ou_uniquement_espaces_blanches(noeud.noeud_texte.données) {
        noeud.sur_dessin = nul
        retourne
    }

    fonte := détermine_fonte(noeud, ctx)
    métriques := fonte.donne_métriques_fonte()

    noeud.modèle_de_boite.marge.hauteur = métriques.donne_hauteur_ligne()
    noeud.modèle_de_boite.bordure.hauteur = métriques.donne_hauteur_ligne()
    noeud.modèle_de_boite.contenu.hauteur = métriques.donne_hauteur_ligne()
    noeud.modèle_de_boite.rembourrage.hauteur = métriques.donne_hauteur_ligne()

    /* À FAIRE : meilleur algorithme, respect du standard. */
    morceaux := divise_sur_espaces_blanches_ascii(noeud.noeud_texte.données)

    espace := ChaineUTF16Unique(' ' comme n32)
    index_espace := morceaux.taille
    largeur_espace := fonte.donne_largeur_texte(espace.donne_chaine_utf16())

    tableau_ajoute(*morceaux, espace.donne_chaine_utf16())

    ligne_courante := bloc_contenant.donne_ligne_courante()
    noeud.morceaux = morceaux

    hauteur_texte := métriques.donne_hauteur_ligne()

    pour morceaux {
        largeur_morceau := fonte.donne_largeur_texte(it)

        saufsi ligne_courante.peut_ajouter_fragment(largeur_morceau comme r32) {
            ligne_courante = bloc_contenant.ajoute_ligne()
        }

        ligne_courante.ajoute_fragment(noeud, index_it, index_it + 1, hauteur_texte, largeur_morceau comme r32)

        si index_it < index_espace - 1 {
            si ligne_courante.peut_ajouter_fragment(largeur_espace comme r32) {
                ligne_courante.ajoute_fragment(noeud, index_espace, index_espace + 1, hauteur_texte, largeur_espace comme r32)
            }
        }
    }
}

noeud_disposition_texte_sur_dessin :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDessin)
{
    noeud := base comme *NoeudDeDispositionTexte

    propriétés := donne_propriété_parent(noeud)

    effets: EffetsTexte

    line := propriétés.style.valeurs[IDPropriété.TextDecorationLine]
    saufsi line.est_mot_clé(PROP_none) {
        decoration := line.text_decoration_line
        couleur := vers_couleur_rvba(propriétés.style.valeurs[IDPropriété.TextDecorationColor].couleur)

        si decoration.UNDERLINE {
            effets.souslignage = vrai
            effets.couleur_souslignage = couleur
        }
        si decoration.OVERLINE {
            effets.surlignage = vrai
            effets.couleur_surlignage = couleur
        }
        si decoration.LINE_THROUGH {
            effets.barrage = vrai
            effets.couleur_barrage = couleur
        }
    }

    peintre := ctx.peintre
    fonte := noeud.fonte
    assert(fonte != nul)

    métriques := donne_métriques_fonte(fonte)
    couleur := propriétés.style.valeurs[IDPropriété.Color].couleur

    background_color := propriétés.style.valeurs[IDPropriété.BackgroundColor].couleur
    si background_color.a != 0 {
        rect_noeud: RectanglePosDim(r32)
        si ctx.fragment {
            fragment := ctx.fragment
            rect_noeud = ctx.donne_rectangle_corrigé(fragment.donne_rectangle())
        }
        sinon {
            rect_noeud = ctx.donne_rectangle_corrigé(noeud.donne_rectangle_contenu())
        }
        peintre.remplis_rectangle(rect_noeud, background_color)
    }

    si ctx.fragment {
        fragment := ctx.fragment
        rect := ctx.donne_rectangle_corrigé(fragment.donne_rectangle())
        rect.y -= métriques.jambage_inférieur

        // peintre.dessine_rectangle(rect, couleur)

        texte := noeud.morceaux[fragment.index_début]

        peintre.dessine_texte(fonte, texte, rect, couleur, *effets)
    }
    sinon {
        texte := noeud.texte
        rect := ctx.donne_rectangle_corrigé(noeud.donne_rectangle_contenu())
        rect.y -= métriques.jambage_inférieur
        peintre.dessine_texte(fonte, texte, rect, couleur, *effets)
    }
}

noeud_disposition_texte_sur_dessin_tampon_id :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDessin)
{
    noeud := base comme *NoeudDeDispositionTexte

    si ctx.fragment {
        fragment := ctx.fragment
        ctx.remplis_rectangle_id(noeud, fragment.donne_rectangle())
    }
    sinon {
        ctx.remplis_rectangle_id(noeud)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NoeudDeDispositionRemplacement
 * \{ */

/* Créé pour chaque noeud hors texte */
NoeudDeDispositionRemplacement :: struct {
    empl base_bloc: NoeudDeDispositionBloc
    type = #type_de_cette_structure
    sur_mesure = noeud_disposition_remplacement_sur_mesure
    sur_dessin = noeud_disposition_remplacement_sur_dessin
    sur_divise_en_lignes = noeud_disposition_remplacement_sur_divise_en_lignes
    sur_dessin_tampon_id = noeud_disposition_remplacement_sur_dessin_tampon_id
}

possède_ratio_intrinsèque :: fonc (noeud: *NoeudDeDispositionRemplacement) -> bool
{
    saufsi noeud.élément {
        retourne faux
    }

    élément := noeud.élément comme *HTML.HTMLImageElement
    assert(élément.local_name == HTML.TAG_img)

    retourne élément.image_data.donnees != nul
}

possède_largeur_intrinsèque :: fonc (noeud: *NoeudDeDispositionRemplacement) -> bool
{
    retourne possède_ratio_intrinsèque(noeud)
}

possède_hauteur_intrinsèque :: fonc (noeud: *NoeudDeDispositionRemplacement) -> bool
{
    retourne possède_ratio_intrinsèque(noeud)
}

donne_ratio_intrinsèque :: fonc (noeud: *NoeudDeDispositionRemplacement) -> r32
{
    élément := noeud.élément comme *HTML.HTMLImageElement
    assert(élément.local_name == HTML.TAG_img)
    retourne HTML.donne_ratio_intrinsèque(élément)
}

donne_largeur_intrinsèque :: fonc (noeud: *NoeudDeDispositionRemplacement) -> r32
{
    élément := noeud.élément comme *HTML.HTMLImageElement
    assert(élément.local_name == HTML.TAG_img)
    retourne HTML.donne_largeur_intrinsèque(élément) comme r32
}

donne_hauteur_intrinsèque :: fonc (noeud: *NoeudDeDispositionRemplacement) -> r32
{
    élément := noeud.élément comme *HTML.HTMLImageElement
    assert(élément.local_name == HTML.TAG_img)
    retourne HTML.donne_hauteur_intrinsèque(élément) comme r32
}

noeud_disposition_remplacement_sur_mesure :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDisposition)
{
    noeud := base comme *NoeudDeDispositionRemplacement

    assert(noeud.propriétés.style.valeurs[IDPropriété.Display].display.outer_type == Display.Type.Inline)

    résoud_pourcentage_largeurs(noeud, ctx.largeur_disponible)
    résoud_pourcentage_hauteur(noeud, ctx.hauteur_disponible)

    calcule_largeur_et_marges_inline_replaced_element(noeud)
    calcule_hauteur_et_marges_inline_replaced_element(noeud)
}

/* https://www.w3.org/TR/2011/REC-CSS2-20110607/visudet.html#inline-replaced-width */
calcule_largeur_et_marges_inline_replaced_element :: fonc (noeud: *NoeudDeDispositionRemplacement)
{
    style := *noeud.propriétés.style

    margin_left := style.valeurs[IDPropriété.MarginLeft]
    border_left_width := style.valeurs[IDPropriété.BorderWidthLeft]
    padding_left := style.valeurs[IDPropriété.PaddingLeft]
    width := style.valeurs[IDPropriété.Width]
    height := style.valeurs[IDPropriété.Height]
    padding_right := style.valeurs[IDPropriété.PaddingRight]
    border_right_width := style.valeurs[IDPropriété.BorderWidthRight]
    margin_right := style.valeurs[IDPropriété.MarginRight]

    // A computed value of 'auto' for 'margin-left' or 'margin-right' becomes a used value of '0'.
    si margin_left.est_auto() {
        margin_left = ValeurDeStyle(number = 0.0)
    }
    si margin_right.est_auto() {
        margin_right = ValeurDeStyle(number = 0.0)
    }

    // If 'height' and 'width' both have computed values of 'auto' and the element also has
    // an intrinsic width, then that intrinsic width is the used value of 'width'.
    si width.est_auto() && height.est_auto() && noeud.possède_largeur_intrinsèque() {
        width = ValeurDeStyle(number = noeud.donne_largeur_intrinsèque())
    }
    // If 'height' and 'width' both have computed values of 'auto' and the element has no
    // intrinsic width, but does have an intrinsic height and intrinsic ratio;
    // or if 'width' has a computed value of 'auto', 'height' has some other computed value,
    // and the element does have an intrinsic ratio; then the used value of 'width' is:
    //     (used height) * (intrinsic ratio)
    sinon si (width.est_auto() && height.est_auto() && !noeud.possède_largeur_intrinsèque()) ||
             (width.est_auto() && !height.est_auto() && noeud.possède_ratio_intrinsèque()) {
        si height.est_auto() {
            width = ValeurDeStyle(number = noeud.donne_hauteur_intrinsèque() * noeud.donne_ratio_intrinsèque())
        }
        sinon {
            width = ValeurDeStyle(number = height.number * noeud.donne_ratio_intrinsèque())
        }
    }

    // If 'height' and 'width' both have computed values of 'auto' and the element has
    // an intrinsic ratio but no intrinsic height or width, then the used value of 'width'
    // is undefined in CSS 2.1.
    // However, it is suggested that, if the containing block's width does not itself
    // depend on the replaced element's width, then the used value of 'width' is calculated
    // from the constraint equation used for block-level, non-replaced elements in normal flow.

    // Otherwise, if 'width' has a computed value of 'auto', and the element has an intrinsic width,
    // then that intrinsic width is the used value of 'width'.
    sinon si width.est_auto() && noeud.possède_largeur_intrinsèque() {
        width = ValeurDeStyle(number = noeud.donne_largeur_intrinsèque())
    }
    // Otherwise, if 'width' has a computed value of 'auto', but none of the conditions above are met,
    // then the used value of 'width' becomes 300px.
    // If 300px is too wide to fit the device, UAs should use the width of the largest rectangle that
    // has a 2:1 ratio and fits the device instead.
    sinon si width.est_auto() {
        width = ValeurDeStyle(number = 300.0)
    }

    style.valeurs[IDPropriété.MarginLeft] = margin_left
    style.valeurs[IDPropriété.BorderWidthLeft] = border_left_width
    style.valeurs[IDPropriété.PaddingLeft] = padding_left
    style.valeurs[IDPropriété.Width] = width
    style.valeurs[IDPropriété.PaddingRight] = padding_right
    style.valeurs[IDPropriété.BorderWidthRight] = border_right_width
    style.valeurs[IDPropriété.MarginRight] = margin_right
}

/* https://www.w3.org/TR/2011/REC-CSS2-20110607/visudet.html#inline-replaced-height */
calcule_hauteur_et_marges_inline_replaced_element :: fonc (noeud: *NoeudDeDispositionRemplacement)
{
    style := *noeud.propriétés.style

    margin_top := style.valeurs[IDPropriété.MarginTop]
    border_top_height := style.valeurs[IDPropriété.BorderWidthTop]
    padding_top := style.valeurs[IDPropriété.PaddingTop]
    height := style.valeurs[IDPropriété.Height]
    width := style.valeurs[IDPropriété.Width]
    padding_bottom := style.valeurs[IDPropriété.PaddingBottom]
    border_bottom_height := style.valeurs[IDPropriété.BorderWidthBottom]
    margin_bottom := style.valeurs[IDPropriété.MarginBottom]

    // If 'margin-top', or 'margin-bottom' are 'auto', their used value is 0.
    si margin_top.est_auto() {
        margin_top = ValeurDeStyle(number = 0.0)
    }
    si margin_bottom.est_auto() {
        margin_bottom = ValeurDeStyle(number = 0.0)
    }

    // If 'height' and 'width' both have computed values of 'auto' and the element also has
    // an intrinsic height, then that intrinsic height is the used value of 'height'.
    si width.est_auto() && height.est_auto() {
        panique("non-implémenté") // il faut préserver les valeurs calculées !
    }

    // Otherwise, if 'height' has a computed value of 'auto', and the element has an intrinsic
    // ratio then the used value of 'height' is:
    //      (used width) / (intrinsic ratio)
    si height.est_auto() && noeud.possède_ratio_intrinsèque() {
        height = ValeurDeStyle(number = width.number / noeud.donne_ratio_intrinsèque())
    }

    // Otherwise, if 'height' has a computed value of 'auto', and the element has an intrinsic height,
    // then that intrinsic height is the used value of 'height'.

    // Otherwise, if 'height' has a computed value of 'auto', but none of the conditions above are met,
    // then the used value of 'height' must be set to the height of the largest rectangle that has a
    // 2:1 ratio, has a height not greater than 150px, and has a width not greater than the device width.
    si height.est_auto() {
        height = ValeurDeStyle(number = width.number * 0.5)
    }

    style.valeurs[IDPropriété.MarginTop] = margin_top
    style.valeurs[IDPropriété.BorderWidthTop] = border_top_height
    style.valeurs[IDPropriété.PaddingTop] = padding_top
    style.valeurs[IDPropriété.Height] = height
    style.valeurs[IDPropriété.PaddingBottom] = padding_bottom
    style.valeurs[IDPropriété.BorderWidthBottom] = border_bottom_height
    style.valeurs[IDPropriété.MarginBottom] = margin_bottom
}

noeud_disposition_remplacement_sur_divise_en_lignes :: fonc (base: *NoeudDeDisposition, bloc_contenant: *NoeudDeDispositionBloc, ctx: *ContexteDisposition)
{
    noeud_disposition_remplacement_sur_mesure(base, ctx)

    noeud := base comme *NoeudDeDispositionRemplacement
    largeur := noeud.propriétés.style.valeurs[IDPropriété.Width].number comme r32
    hauteur := noeud.propriétés.style.valeurs[IDPropriété.Height].number comme r32

    ligne_courante := bloc_contenant.donne_ligne_courante()
    saufsi ligne_courante.peut_ajouter_fragment(largeur) {
        ligne_courante = bloc_contenant.ajoute_ligne()
    }

    ligne_courante.ajoute_fragment(noeud, 0, 0, hauteur, largeur)
}

noeud_disposition_remplacement_sur_dessin :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDessin)
{
    noeud := base comme *NoeudDeDispositionRemplacement
    
    rect: RectanglePosDim(r32)
    si ctx.fragment {
        rect = ctx.fragment.donne_rectangle()
    }
    sinon {
        rect = noeud.donne_rectangle_bordure()
    }

    rect = ctx.donne_rectangle_corrigé(rect)
    peintre := ctx.peintre

    assert(noeud.élément.local_name == HTML.TAG_img)
    image := noeud.élément comme *HTML.HTMLImageElement

    si image.image_data.donnees {
        peintre.dessine_image(image.image_data, rect)
    }
    sinon {
        /* À FAIRE : image nulle */
        peintre.remplis_rectangle(rect, CouleurRVBA(1.0, 0.0, 1.0, 1.0))
    }
}

noeud_disposition_remplacement_sur_dessin_tampon_id :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDessin)
{
    noeud := base comme *NoeudDeDispositionRemplacement

    si ctx.fragment {
        fragment := ctx.fragment
        ctx.remplis_rectangle_id(noeud, fragment.donne_rectangle())
    }
    sinon {
        ctx.remplis_rectangle_id(noeud)
    }
}

/** \} */
