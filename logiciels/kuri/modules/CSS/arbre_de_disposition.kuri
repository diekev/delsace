importe Aléa
importe Chaine
importe Couleur
importe Ensemble
importe Fondation
importe Géométrie
importe #inemployé HTML
importe IGUMI
importe Image
importe Internet
importe Math
importe MIME
importe OpenGL
importe PeintureInterface
importe Triage
importe Typographie

/* ------------------------------------------------------------------------- */
/** \nom Arbre de disposition
 * \{ */

ArbreDeDisposition :: struct {
    racine: *NoeudDeDisposition

    noeuds: [..]*NoeudDeDisposition
    tampon_id_fut_dessiné: bool
    tampon_id: [..]n32
    largeur_vue: z32
    hauteur_vue: z32
}

détruit_arbre :: fonc (arbre: *ArbreDeDisposition)
{
    saufsi arbre {
        retourne
    }

    pour arbre.noeuds {
        déloge(it.enfants)
        si it.propriétés {
            détruit_propriétés(it.propriétés)
        }

        élément := it.donne_élément()
        si élément {
            élément.noeud_de_disposition = nul
        }

        si it.type == NoeudDeDispositionBloc {
            bloc := it comme *NoeudDeDispositionBloc
            détruit_lignes(bloc)
            déloge(bloc)
        }
        sinon si it.type == NoeudDeDispositionInline {
            noeud := it comme *NoeudDeDispositionInline
            détruit_lignes(noeud)
            déloge(noeud)
        }
        sinon si it.type == NoeudDeDispositionTexte {
            texte := it comme *NoeudDeDispositionTexte
            détruit_chaine(texte.texte)
            déloge(texte.morceaux)
            déloge(texte)
        }
        sinon si it.type == NoeudDeDispositionNouvelleLigne {
            bris := it comme *NoeudDeDispositionNouvelleLigne
            déloge(bris)
        }
        sinon si it.type == NoeudDeDispositionRemplacement {
            remplacement := it comme *NoeudDeDispositionRemplacement
            déloge(remplacement)
        }
        sinon {
            imprime("noeud inconnu !")
            déloge(it)
        }
    }

    déloge(arbre.tampon_id)
    déloge(arbre.noeuds)
    déloge(arbre)
}

crée_noeud :: fonc (arbre: *ArbreDeDisposition, $TypeNoeud: type_de_données) -> *TypeNoeud
{
    résultat := loge(TypeNoeud)
    résultat.id = arbre.noeuds.taille comme n32
    tableau_ajoute(*arbre.noeuds, résultat)
    retourne résultat
}

donne_élément_pour_position :: fonc (arbre: *ArbreDeDisposition, x: z32, y: z32) -> *HTML.Élément
{
    saufsi arbre.tampon_id_fut_dessiné {
        retourne nul
    }

    saufsi 0 <= x < arbre.largeur_vue && 0 <= y < arbre.hauteur_vue {
        retourne nul
    }

    tampon_id := arbre.tampon_id
    /* OpenGL est de bas en haut, donc inverse l'axe des y. */
    index := (arbre.hauteur_vue - y - 1) * arbre.largeur_vue + x

    index_noeud := tampon_id[index]

    noeud := arbre.noeuds[index_noeud]
    saufsi noeud {
        retourne nul
    }
    retourne noeud.donne_élément_récursif()
}

imprime_arbre :: fonc (arbre: *ArbreDeDisposition)
{
    saufsi arbre.racine {
        retourne
    }

    enchaineuse: Enchaineuse
    initialise_enchaineuse(*enchaineuse)
    diffère détruit_tampons(*enchaineuse)

    imprime_arbre(*enchaineuse, arbre.racine, 0)

    résultat := chaine_depuis_enchaineuse(*enchaineuse)
    diffère déloge(résultat)

    imprime("%\n", résultat)
}

imprime_arbre :: fonc (enchaineuse: *Enchaineuse, racine: *NoeudDeDisposition, profondeur: n32)
{
    indentation := donne_chaine_indentation(profondeur comme z32)

    imprime_dans_enchaineuse(enchaineuse, "%%", indentation, racine.donne_nom_classe())
    si racine.type == NoeudDeDispositionBloc {
        bloc := racine comme *NoeudDeDispositionBloc
        imprime_dans_enchaineuse(enchaineuse, " %", bloc.élément.local_name)
    }

    imprime_dans_enchaineuse(enchaineuse, " % % %x%\n", racine.modèle_de_boite.marge.x, racine.modèle_de_boite.marge.y, racine.modèle_de_boite.marge.largeur, racine.modèle_de_boite.marge.hauteur)

    pour racine.enfants {
        imprime_arbre(enchaineuse, it, profondeur + 1)
    }
}

dessine :: fonc (arbre: *ArbreDeDisposition, ctx: *ContexteDessin)
{
    arbre.hauteur_vue = ctx.hauteur_vue
    arbre.largeur_vue = ctx.largeur_vue

    IGUMI.réinitialise_données()
    dessine(arbre.racine, ctx)
    ctx.peintre.termine_dessin()
}

dessine_tampon_id :: fonc (arbre: *ArbreDeDisposition, ctx: *ContexteDessin)
{
    /* Tampon ID. */

    IGUMI.réinitialise_données_id()
    fbo: GLuint
    glGenFramebuffers(1, *fbo)
    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, fbo)

    render_buf: GLuint
    glGenRenderbuffers(1, *render_buf)
    glBindRenderbuffer(GL_RENDERBUFFER, render_buf)
    glRenderbufferStorage(GL_RENDERBUFFER, GL_R32UI, ctx.largeur_vue, ctx.hauteur_vue)
    vérifie_erreur("glRenderbufferStorage")
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, render_buf)
    vérifie_erreur("glFramebufferRenderbuffer")

    dessine_tampon_id(arbre.racine, ctx)
    vérifie_erreur("dessine_tampon_id")
    IGUMI.termine_immédiat_id()

    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0)
    vérifie_erreur("glBindFramebuffer")

    glBindFramebuffer(GL_READ_FRAMEBUFFER, fbo)
    vérifie_erreur("glBindFramebuffer")

    tableau_redimensionne(arbre.tampon_id, ctx.largeur_vue * ctx.hauteur_vue)

    glReadBuffer(GL_COLOR_ATTACHMENT0)
    vérifie_erreur("glReadBuffer")
    glReadPixels(0, 0, ctx.largeur_vue, ctx.hauteur_vue, GL_RED_INTEGER, GL_UNSIGNED_INT, arbre.tampon_id.pointeur)
    vérifie_erreur("glReadPixels")

    glBindFramebuffer(GL_READ_FRAMEBUFFER, 0)

    glBindRenderbuffer(GL_RENDERBUFFER, 0)

    glDeleteFramebuffers(1, *fbo)
    glDeleteRenderbuffers(1, *render_buf)

    arbre.tampon_id_fut_dessiné = vrai
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom RésolveuseStyle.
 * \{ */

RègleAppariée :: struct {
    règle: *CSSStyleRule
    index_feuille_de_style: z64
    index_règle: z64
    origine: OrigineCascade
}

opérateur == :: fonc (a: RègleAppariée, b: RègleAppariée) -> bool
{
    retourne a.règle == b.règle
}

opérateur != :: fonc (a: RègleAppariée, b: RègleAppariée) -> bool
{
    retourne a.règle != b.règle
}

opérateur < :: fonc (a: RègleAppariée, b: RègleAppariée) -> bool
{
    retourne a.règle < b.règle
}

RèglesParIdentifiant :: struct {
    ident: n32
    règles: [..]RègleAppariée
}

opérateur == :: fonc (a: RèglesParIdentifiant, b: RèglesParIdentifiant) -> bool
{
    retourne a.ident == b.ident
}

opérateur != :: fonc (a: RèglesParIdentifiant, b: RèglesParIdentifiant) -> bool
{
    retourne a.ident != b.ident
}

opérateur < :: fonc (a: RèglesParIdentifiant, b: RèglesParIdentifiant) -> bool
{
    retourne a.ident < b.ident
}

RésolveuseStyle :: struct {
    globales: *GlobalesDessin
    document: *HTML.Document
    /* Pour MediaQuery. */
    largeur_écran: r64
    taille_fonte_racine: r64
    feuilles_de_style: []*CSSStyleSheet

    /* Tampon réutilisé pour les cascades de propriétés. */
    déclarations_cascade: [..]DéclarationCascadée

    /* Style dont les propriétés sont toujours à leurs valeurs initiales.
     * Utilisé lors du calcul des valeurs. */
    valeurs_initiales: Style

    /* Cache. */
    pseudo_classes: PseudoClasses
    /* Les valeurs des ChaineUTF16Uniques des sélecteurs d'id.
     * Nous utilisons les valeurs et non les chaines car nous stockons les
     * données sous d'ensemble et il est plus rapide de comparer des nombres
     * que des chaines pour le stockage ordonné. */
    ids_connus: [..]n32
    attrs_connus: [..]n32
    classes_connues: [..]n32

    /* Ségrégation des règles pour accélérer leurs appariements. */
    règles_par_classe: [..]RèglesParIdentifiant
    autres_règles: [..]RègleAppariée

    /* Cache pour les hints de présentations. */
    presentational_hints: [..]*DéclarationPropriété
}

crée_résolveuse_style :: fonc (document: *HTML.Document, largeur: z32) -> *RésolveuseStyle
{
    résultat := loge(RésolveuseStyle)
    initialise_résolveuse(résultat)
    résultat.document = document
    résultat.taille_fonte_racine = document.globales_dessin.taille_fonte_défaut
    résultat.globales = document.globales_dessin
    résultat.feuilles_de_style = document.feuilles_de_style
    résultat.largeur_écran = largeur comme r64
    initialise_cache(résultat)
    retourne résultat
}

initialise_résolveuse :: fonc (résolveuse: *RésolveuseStyle)
{
    initialise_style(*résolveuse.valeurs_initiales)
}

initialise_cache :: fonc (résolveuse: *RésolveuseStyle)
{
    résolveuse.pseudo_classes = PseudoClasses.zéro
    résolveuse.ids_connus.taille = 0
    résolveuse.attrs_connus.taille = 0
    résolveuse.classes_connues.taille = 0
    résolveuse.autres_règles.taille = 0
    résolveuse.règles_par_classe.taille = 0

    user_agent := HTML.donne_user_agent(résolveuse.document)
    assert(user_agent != nul)

    ctx: ContexteÉvaluationMediaQuery
    ctx.supporte_scripting = user_agent.supporte_scripting
    ctx.largeur = résolveuse.largeur_écran

    pour feuille, index_feuille dans résolveuse.feuilles_de_style {
        index_règle : z64 = 0
        pour règle dans feuille.rules {
            si règle.type == CSSRuleType.Style {
                règle_de_style := règle comme *CSSStyleRule
                ajoute_règle_aux_caches(résolveuse, règle_de_style, index_feuille, index_règle)
                index_règle += 1
                continue
            }

            si règle.type == CSSRuleType.Media {
                règle_de_media := règle comme *CSSMediaRule
                saufsi évalue_media_list(*ctx, règle_de_media) {
                    continue
                }

                pour règle_média dans règle_de_media.css_rules {
                    si règle_média.type == CSSRuleType.Style {
                        règle_de_style := règle_média comme *CSSStyleRule
                        ajoute_règle_aux_caches(résolveuse, règle_de_style, index_feuille, index_règle)
                        index_règle += 1
                    }
                }

                continue
            }
        }
    }
}

évalue_media_list :: fonc (ctx: *ContexteÉvaluationMediaQuery, règle_de_media: *CSSMediaRule) -> bool
{
    saufsi règle_de_media.media_list {
        retourne faux
    }

    pour règle_de_media.media_list.media_queries {
        saufsi évalue_media_query(ctx, it) {
            retourne faux
        }
    }

    retourne vrai
}

ajoute_règle_aux_caches :: fonc (résolveuse: *RésolveuseStyle, règle_de_style: *CSSStyleRule, index_feuille: z64, index_règle: z64)
{
    règle_ajoutée := faux

    règle_appariée: RègleAppariée
    règle_appariée.règle = règle_de_style
    règle_appariée.index_feuille_de_style = index_feuille
    règle_appariée.index_règle = index_règle

    pour complex dans règle_de_style.selector_list.complex_selectors {
        dernière_classe: Optionnel(CSSOMString)

        pour compound dans complex.compound_selectors {
            init_de(Optionnel(CSSOMString))(*dernière_classe)
            pour simple dans compound.simple_selectors {
                si simple.type == SimpleSelector.Type.PseudoClass {
                    résolveuse.pseudo_classes |= simple.pseudo_classe
                }
                sinon si simple.type == SimpleSelector.Type.ID {
                    ensemble_ajoute(*résolveuse.ids_connus, simple.ident.valeur)
                }
                sinon si simple.type == SimpleSelector.Type.Attrib {
                    ensemble_ajoute(*résolveuse.attrs_connus, simple.ident.valeur)
                }
                sinon si simple.type == SimpleSelector.Type.Class {
                    ensemble_ajoute(*résolveuse.classes_connues, simple.ident.valeur)
                    dernière_classe = simple.ident
                }
            }
        }

        si dernière_classe.possède_valeur() {
            ajoute_règle_pour_classe(résolveuse, dernière_classe.Quelque, règle_appariée)
        }
        sinon saufsi règle_ajoutée {
            règle_ajoutée = vrai
            tableau_ajoute(*résolveuse.autres_règles, règle_appariée)
        }
    }
}

ajoute_règle_pour_classe :: fonc (résolveuse: *RésolveuseStyle, classe: CSSOMString, règle: RègleAppariée)
{
    règle_par_identifiant: RèglesParIdentifiant
    règle_par_identifiant.ident = classe.valeur

    index := ensemble_possède_retourne_index(*résolveuse.règles_par_classe, règle_par_identifiant)
    si index != -1 {
        règles_par_identifant := *résolveuse.règles_par_classe[index]
        tableau_ajoute(*règles_par_identifant.règles, règle)
        retourne
    }

    tableau_ajoute(*règle_par_identifiant.règles, règle)
    ensemble_ajoute(*résolveuse.règles_par_classe, règle_par_identifiant)
}

donne_règles_pour_classe :: fonc (résolveuse: *RésolveuseStyle, classe: CSSOMString) -> [..]RègleAppariée
{
    règle_par_identifiant: RèglesParIdentifiant
    règle_par_identifiant.ident = classe.valeur

    index := ensemble_possède_retourne_index(*résolveuse.règles_par_classe, règle_par_identifiant)
    si index != -1 {
        retourne résolveuse.règles_par_classe[index].règles
    }

    résultat: [..]RègleAppariée
    retourne résultat
}

détruit_données_résolveuse :: fonc (résolveuse: *RésolveuseStyle)
{
    déloge(résolveuse.déclarations_cascade)
    déloge(résolveuse.ids_connus)
    déloge(résolveuse.attrs_connus)
    déloge(résolveuse.classes_connues)
    déloge(résolveuse.autres_règles)
    pour résolveuse.règles_par_classe {
        déloge(it.règles)
    }
    déloge(résolveuse.règles_par_classe)
    pour résolveuse.presentational_hints {
        détruit_déclaration(it)
    }
    déloge(résolveuse.presentational_hints)
}

détruit_résolveuse :: fonc (résolveuse: *RésolveuseStyle)
{
    saufsi résolveuse {
        retourne
    }
    détruit_données_résolveuse(résolveuse)
    déloge(résolveuse)
}

/* https://html.spec.whatwg.org/multipage/rendering.html#the-css-user-agent-style-sheet-and-presentational-hints */
ajoute_presentational_hint :: fonc (résolveuse: *RésolveuseStyle, nom_propriété: CSSOMString, value: ValeurDeStyle)
{
    pour résolveuse.presentational_hints {
        si it.property_name != nom_propriété {
            continue
        }

        si it.value.taille != 1 {
            continue
        }

        si it.value[0] != value {
            continue
        }

        tableau_ajoute(*résolveuse.déclarations_cascade, DéclarationCascadée(it, Spécificité(0, 0, 0), OrigineCascade.Author))
        retourne
    }

    déclaration := loge(DéclarationPropriété)
    déclaration.info = donne_info_type_pour_nom(nom_propriété)
    déclaration.property_name = nom_propriété
    tableau_ajoute(*déclaration.value, value)

    tableau_ajoute(*résolveuse.déclarations_cascade, DéclarationCascadée(déclaration, Spécificité(0, 0, 0), OrigineCascade.Author))

    tableau_ajoute(*résolveuse.presentational_hints, déclaration)
}

possède_règle_avec_pseudo_classe :: fonc (résolveuse: *RésolveuseStyle, pseudo_classe: PseudoClasses) -> bool
{
    retourne (résolveuse.pseudo_classes & pseudo_classe) != PseudoClasses.zéro
}

possède_règle_avec_id :: fonc (résolveuse: *RésolveuseStyle, id: CSSOMString) -> bool
{
    si id.est_vide() {
        /* Si l'id est la chaine vide, nous devons vérifier que toutes les règles
         * s'appliquent, donc pas de court-circuitage. */
        retourne vrai
    }

    retourne ensemble_possède(*résolveuse.ids_connus, id.valeur)
}

possède_règle_avec_attribut :: fonc (résolveuse: *RésolveuseStyle, attr: CSSOMString) -> bool
{
    si attr.est_vide() {
        /* Si l'attribut est la chaine vide, nous devons vérifier que toutes les règles
         * s'appliquent, donc pas de court-circuitage. */
        retourne vrai
    }

    retourne ensemble_possède(*résolveuse.attrs_connus, attr.valeur)
}

donne_ajournement_pour_redimensionnement :: fonc (résolveuse: *RésolveuseStyle @inutilisée, largeur: z32 @inutilisée, hauteur: z32 @inutilisée) -> AjournementArbre
{
    /* À FAIRE : règles média, sauvegarde de l'ancienne taille */
    retourne AjournementArbre.Disposition
}

RègleEtSpécificité :: struct {
    règle: RègleAppariée
    /* La spécifité du sélecteur complexe ayant la hautissime spécifité ayant apparié l'élément. */
    spécificité: Spécificité
}

collecte_les_règles_appropriées :: fonc (résolveuse: *RésolveuseStyle, élément: *HTML.Élément) -> [..]RègleEtSpécificité
{
    temp: [..]RègleAppariée
    diffère déloge(temp)

    résultat: [..]RègleEtSpécificité

    classes := HTML.donne_liste_classe(élément)
    pour classes {
        règles_pour_classe := donne_règles_pour_classe(résolveuse, it)

        pour règle dans règles_pour_classe {
            ensemble_ajoute(*temp, règle)
        }
    }

    pour temp {
        apparie_règle(it, élément, *résultat)
    }

    pour résolveuse.autres_règles {
        apparie_règle(it, élément, *résultat)
    }

    retourne résultat
}

apparie_règle :: fonc (règle_de_style: RègleAppariée, élément: *HTML.Élément, résultat: *[..]RègleEtSpécificité)
{
    règle_appariée := faux
    spécificité: Spécificité

    pour complex dans règle_de_style.règle.selector_list.complex_selectors {
        saufsi apparie_sélecteur(complex.compound_selectors, complex.compound_selectors.taille - 1, élément) {
            continue
        }

        spécificité_sélecteur := calcule_spécificité(*complex)
        si spécificité_sélecteur > spécificité {
            spécificité = spécificité_sélecteur
        }

        règle_appariée = vrai
    }

    si règle_appariée {
        tableau_ajoute(résultat, RègleEtSpécificité(règle_de_style, spécificité))
    }
}

résoud_style :: fonc (résolveuse: *RésolveuseStyle, élément: *HTML.Élément, propriétés_parent: *PropriétésDeStyle) -> *PropriétésDeStyle
{
    règles := collecte_les_règles_appropriées(résolveuse, élément)
    diffère déloge(règles)
    // imprime("% règle(s) pour %\n", règles.taille, élément.local_name)

    résolveuse.déclarations_cascade.taille = 0

    pour règles {
        // imprime_règle(it.règle)
        règle := it.règle.règle
        déclarations := règle.style.déclarations
        tableau_réserve(*résolveuse.déclarations_cascade, résolveuse.déclarations_cascade.taille + déclarations.taille)
        spécificité := it.spécificité
        origine := donne_origine_cascade(règle)

        position: PositionDéclaration
        position.index_feuille = it.règle.index_feuille_de_style
        position.index_règle = it.règle.index_règle

        pour déclaration, index_déclaration dans déclarations {
            position.index_déclaration = index_déclaration
            tableau_ajoute(*résolveuse.déclarations_cascade, DéclarationCascadée(déclaration, spécificité, origine, position))
        }
    }

    HTML.applique_presentational_hints(élément, résolveuse)

    si élément.style {
        /* https://drafts.csswg.org/css-style-attr/#style-attribute
         * "In the cascade, these declarations are considered to have author origin and a specificity higher than any selector." */
        tableau_réserve(*résolveuse.déclarations_cascade, résolveuse.déclarations_cascade.taille + élément.style.déclarations.taille)
        spécificité := donne_spécificité_max()
        pour élément.style.déclarations {
            tableau_ajoute(*résolveuse.déclarations_cascade, DéclarationCascadée(it, spécificité, OrigineCascade.Author))
        }
    }
    tri_rapide(résolveuse.déclarations_cascade, compare_déclarations_pour_cascade)

    résultat := crée_propriétés_de_style(propriétés_parent)

    pour > résolveuse.déclarations_cascade {
        ajoute_déclaration(résultat, it.déclaration)
    }

    calcule_style(résolveuse, résultat, propriétés_parent)

    retourne résultat
}

AjournementArbre :: énum_drapeau {
    /* L'arbre doit être redessiné. */
    Dessin
    /* L'arbre doit être disposé. */
    Disposition
    /* L'arbre doit être construit. */
    Construction
}

donne_ajournement_pour_changement_style :: fonc (résolveuse: *RésolveuseStyle, élément: *HTML.Élément) -> AjournementArbre
{
    noeud_de_disposition := élément.noeud_de_disposition
    anciennes_propriétés: *PropriétésDeStyle
    propriétés_parent: *PropriétésDeStyle

    si noeud_de_disposition {
        anciennes_propriétés = noeud_de_disposition.propriétés
        assert(anciennes_propriétés != nul)
        propriétés_parent = anciennes_propriétés.parent
    }

    nouvelles_propriétés := résoud_style(résolveuse, élément, propriétés_parent)
    diffère détruit_propriétés(nouvelles_propriétés)

    /* Vérifie si "display: none" reste "display: none". */
    display := nouvelles_propriétés.donne_valeur_calculée(IDPropriété.Display).display
    si display.outer_type == Display.Type.None {
        si noeud_de_disposition == nul {
            /* Nous restons sur "display: none". */
            retourne AjournementArbre.zéro
        }
        /* Nous sommes passé de "display: none" à autre chose, reconstruisons. */
        retourne AjournementArbre.Construction
    }

    si noeud_de_disposition == nul {
        /* Nous sommes passé de "display: none" à autre chose, reconstruisons. */
        retourne AjournementArbre.Construction
    }

    assert(anciennes_propriétés != nul)
    résultat: AjournementArbre

    pour * infos_types_propriétés_shorthand {
        résultat |= donne_ajournement_pour_différence_propriétés(nouvelles_propriétés, anciennes_propriétés, it)
    }

    pour * infos_types_propriétés {
        résultat |= donne_ajournement_pour_différence_propriétés(nouvelles_propriétés, anciennes_propriétés, it)
    }

    si résultat.Construction {
        retourne résultat
    }

    si résultat == AjournementArbre.zéro {
        retourne résultat
    }

    /* Sauvegarde les propriétés. */
    permute(nouvelles_propriétés, anciennes_propriétés)

    retourne résultat
}

donne_ajournement_pour_différence_propriétés :: fonc (nouvelles_propriétés: *PropriétésDeStyle, anciennes_propriétés: *PropriétésDeStyle, info: *InfoTypePropriété) -> AjournementArbre
{
    nouvelle := nouvelles_propriétés.donne_déclaration(info.nom)
    ancienne := anciennes_propriétés.donne_déclaration(info.nom)

    si nouvelle == nul && ancienne == nul {
        retourne AjournementArbre.zéro
    }

    si nouvelle == nul || ancienne == nul {
        retourne donne_ajournement_arbre(info)
    }

    si nouvelle.value.taille != ancienne.value.taille {
        retourne donne_ajournement_arbre(info)
    }

    pour nouvelle.value {
        si ancienne.value[index_it] == it {
            continue
        }

        retourne donne_ajournement_arbre(info)
    }

    si nouvelle.important != ancienne.important {
        retourne donne_ajournement_arbre(info)
    }

    retourne AjournementArbre.zéro
}

donne_ajournement_arbre :: fonc (info: *InfoTypePropriété) -> AjournementArbre
{
    si info.drapeaux.AffecteDisposition {
        retourne AjournementArbre.Disposition
    }
    si info.drapeaux.AffecteConstructionArbre {
        retourne AjournementArbre.Construction
    }
    retourne AjournementArbre.Dessin
}

/* https://www.w3.org/TR/css-cascade/#origin */
OrigineCascade :: énum {
    Author
    User
    UserAgent
}

PositionDéclaration :: struct {
    index_feuille: z64
    index_règle: z64
    index_déclaration: z64
}

opérateur < :: fonc (a: PositionDéclaration, b: PositionDéclaration) -> bool
{
    si a.index_feuille < b.index_feuille {
        retourne vrai
    }

    si a.index_feuille > b.index_feuille {
        retourne faux
    }

    si a.index_règle < b.index_règle {
        retourne vrai
    }

    si a.index_règle > b.index_règle {
        retourne faux
    }

    retourne a.index_déclaration < b.index_déclaration
}

DéclarationCascadée :: struct {
    déclaration: *DéclarationPropriété
    spécificité: Spécificité
    origine: OrigineCascade
    position: PositionDéclaration
}

/* https://www.w3.org/TR/css-cascade/#cascade-sort */
compare_déclarations_pour_cascade :: fonc (a: DéclarationCascadée, b: DéclarationCascadée) -> z32
{
    /* Tri par importance. */
    si a.déclaration.important && !b.déclaration.important {
        retourne -1
    }
    si b.déclaration.important && !a.déclaration.important {
        retourne 1
    }

    /* Même importance -> tri par origine. */
    si a.origine != b.origine {
        retourne a.origine comme z32 - b.origine comme z32
    }

    /* Même importance et origine -> tri par spécifité. */
    si a.spécificité > b.spécificité {
        retourne -1
    }
    si b.spécificité > a.spécificité {
        retourne 1
    }

    /* Même importance, origine, et spécifité -> tri par position. */
    si a.position < b.position {
        retourne 1
    }
    si b.position < a.position {
        retourne -1
    }

    /* À FAIRE : contextes. */

    retourne 0
}

crée_style_pour_bloc_anonyme :: fonc (résolveuse: *RésolveuseStyle, bloc: *NoeudDeDispositionBloc, bloc_parent: *NoeudDeDispositionBloc, outer_display: Display.Type)
{
    résultat := crée_propriétés_de_style(bloc_parent.propriétés)
    calcule_style(résolveuse, résultat, bloc_parent.propriétés)
    résultat.définis_valeur_calculée(IDPropriété.Display, Display(outer_type = outer_display, inner_type = Display.Type.Flow))

    bloc.propriétés = résultat
}

calcule_style :: fonc (résolveuse: *RésolveuseStyle, propriétés: *PropriétésDeStyle, propriétés_parent: *PropriétésDeStyle)
{
    /* https://www.w3.org/TR/2011/REC-CSS2-20110607/cascade.html#computed-value */
    ctx_calcul_style: ContexteCalculStyle
    ctx_calcul_style.document = résolveuse.document
    ctx_calcul_style.taille_fonte = résolveuse.globales.taille_fonte_défaut
    ctx_calcul_style.taille_fonte_racine = résolveuse.taille_fonte_racine
    ctx_calcul_style.propriétés = propriétés
    ctx_calcul_style.valeurs_initiales = *résolveuse.valeurs_initiales

    si propriétés_parent {
        ctx_calcul_style.taille_fonte = propriétés_parent.donne_valeur_calculée(IDPropriété.FontSize).pixels
    }

    pour propriétés.déclarations {
        si it.est_personnalisée {
            continue
        }
        info := it.info

        si info.sur_calcul_style {
            info.sur_calcul_style(it, *propriétés.style, *ctx_calcul_style)
        }
        sinon {
            calcule_valeur_propriété_générique(it, *propriétés.style, *ctx_calcul_style)
        }

        si info.id == IDPropriété.FontSize {
            ctx_calcul_style.taille_fonte = propriétés.donne_valeur_calculée(IDPropriété.FontSize).pixels
        }
    }

    si propriétés.style.valeurs[IDPropriété.BorderStyleLeft].line_style == LineStyle.None {
        propriétés.définis_valeur_calculée(IDPropriété.BorderWidthLeft, ValeurDeStyle(pixels = 0.0))
    }
    si propriétés.style.valeurs[IDPropriété.BorderStyleTop].line_style == LineStyle.None {
        propriétés.définis_valeur_calculée(IDPropriété.BorderWidthTop, ValeurDeStyle(pixels = 0.0))
    }
    si propriétés.style.valeurs[IDPropriété.BorderStyleRight].line_style == LineStyle.None {
        propriétés.définis_valeur_calculée(IDPropriété.BorderWidthRight, ValeurDeStyle(pixels = 0.0))
    }
    si propriétés.style.valeurs[IDPropriété.BorderStyleBottom].line_style == LineStyle.None {
        propriétés.définis_valeur_calculée(IDPropriété.BorderWidthBottom, ValeurDeStyle(pixels = 0.0))
    }
    saufsi propriétés.style.valeurs[IDPropriété.FontSize].est_pixels() {
        propriétés.définis_valeur_calculée(IDPropriété.FontSize, calcule_valeur_propriété_générique(propriétés.style.valeurs[IDPropriété.FontSize], GenreValeurCalculée.LongueurAbsolue | GenreValeurCalculée.FontSize, *propriétés.style, *ctx_calcul_style))
    }
    saufsi propriétés.style.valeurs[IDPropriété.FontWeight].est_nombre() {
        propriétés.définis_valeur_calculée(IDPropriété.FontWeight, calcule_valeur_propriété_générique(propriétés.style.valeurs[IDPropriété.FontWeight], GenreValeurCalculée.FontWeight, *propriétés.style, *ctx_calcul_style))
    }

    calcule_display_final(propriétés)

    /* Transfert les valeurs calculées aux valeurs utilisées. */
    propriétés.style_utilisée = propriétés.style
}

/* Corrige display en prenant en compte position et float.
 * https://www.w3.org/TR/2011/REC-CSS2-20110607/visuren.html#dis-pos-flo */
calcule_display_final :: fonc (propriétés: *PropriétésDeStyle)
{
    display := propriétés.donne_valeur_calculée(IDPropriété.Display).display
    position := propriétés.donne_valeur_calculée(IDPropriété.Position)
    float := propriétés.donne_valeur_calculée(IDPropriété.Float)

    // 1. If 'display' has the value 'none', then 'position' and 'float' do not apply. In this case,
    // the element generates no box.
    si display.outer_type == Display.Type.None {
        retourne
    }

    // 2. Otherwise, if 'position' has the value 'absolute' or 'fixed', the box is absolutely positioned,
    // the computed value of 'float' is 'none', and display is set according to the table below.
    // The position of the box will be determined by the 'top', 'right', 'bottom' and 'left' properties
    // and the box's containing block.
    si position.est_mot_clé(PROP_absolute) || position.est_mot_clé(PROP_fixed) {
        propriétés.définis_valeur_calculée(IDPropriété.Float, ValeurDeStyle(mot_clé = PROP_none))
        propriétés.définis_valeur_calculée(IDPropriété.Display, convertis_display_pour_position_ou_float(display))
        retourne
    }

    // 3. Otherwise, if 'float' has a value other than 'none', the box is floated and 'display' is set
    // according to the table below.
    saufsi float.est_none() {
        propriétés.définis_valeur_calculée(IDPropriété.Display, convertis_display_pour_position_ou_float(display))
        retourne
    }

    // 4. Otherwise, if the element is the root element, 'display' is set according to the table below,
    // except that it is undefined in CSS 2.1 whether a specified value of 'list-item' becomes a computed
    // value of 'block' or 'list-item'.
    // À FAIRE : test plus robuste pour définir l'élément racine.
    // À FAIRE : list-item.
    saufsi propriétés.parent {
        propriétés.définis_valeur_calculée(IDPropriété.Display, convertis_display_pour_position_ou_float(display))
        retourne
    }

    // 5. Otherwise, the remaining 'display' property values apply as specified.
}

convertis_display_pour_position_ou_float :: fonc (spécifié: Display) -> ValeurDeStyle
{
    // À FAIRE : display-internal
    résultat := spécifié

    si spécifié.outer_type == Display.Type.Inline {
        résultat.outer_type = Display.Type.Block

        si spécifié.inner_type != Display.Type.Table {
            résultat.inner_type = Display.Type.FlowRoot
        }
    }

    retourne ValeurDeStyle(display = résultat)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Génération d'arbres de disposition.
 * \{ */

donne_arbre_de_disposition_ajourné :: fonc (document: *HTML.Document, largeur: z32, hauteur: z32) -> *ArbreDeDisposition
{
    ajournement := document.ajournement_arbre

    si document.arbre_de_disposition == nul || ajournement.Construction {
        si document.arbre_de_disposition {
            détruit_arbre(document.arbre_de_disposition)
            document.arbre_de_disposition = nul
        }
        crée_arbre_de_disposition(document, largeur, hauteur)
    }
    sinon si ajournement.Disposition {
        dispose_arbre(document.globales_dessin, document.arbre_de_disposition, largeur, hauteur)
    }

    document.ajournement_arbre = AjournementArbre.zéro

    retourne document.arbre_de_disposition
}

crée_arbre_de_disposition :: fonc (document: *HTML.Document, largeur: z32, hauteur: z32)
{
    html := HTML.donne_élément_html(document)
    saufsi html {
        retourne
    }

    saufsi document.globales_dessin {
        document.globales_dessin = crée_globales_dessin()
    }

    saufsi document.résolveuse_style {
        document.résolveuse_style = crée_résolveuse_style(document, largeur)
    }

    résultat := loge(ArbreDeDisposition)

    résolveuse := document.résolveuse_style

    /* À FAIRE : ceci peut changer mais comment est encore inconnue. */
    html.pseudo_classes.Root = vrai

    créatrice: CréatriceArbre
    créatrice.arbre = résultat
    créatrice.résolveuse = résolveuse

    crée_noeud_pour_élément(*créatrice, nul, html)
    résultat.racine = html.noeud_de_disposition

    // imprime("Créé % noeud(s)\n", résultat.noeuds.taille)

    dispose_arbre(document.globales_dessin, résultat, largeur, hauteur)

    // imprime_arbre(résultat)

    si document.arbre_de_disposition {
        détruit_arbre(document.arbre_de_disposition)
        document.arbre_de_disposition = nul
    }

    document.arbre_de_disposition = résultat
}

dispose_arbre :: fonc (globales: *GlobalesDessin, arbre: *ArbreDeDisposition, largeur: z32, hauteur: z32)
{
    initial_containing_block: ContainingBlock
    initial_containing_block.rect.hauteur = hauteur comme r32
    initial_containing_block.rect.largeur = largeur comme r32
    initial_containing_block.noeud = arbre.racine

    ctx: ContexteDeFormattage
    ctx.globales = globales
    ctx.initial_containing_block = *initial_containing_block

    mesure(arbre.racine, *ctx, ModeDeFormattage.Normal)

    // imprime("taille arbre : %x%\n", résultat.racine.largeur, résultat.racine.hauteur)
}

CréatriceArbre :: struct {
    résolveuse: *RésolveuseStyle
    arbre: *ArbreDeDisposition
}

crée_noeud_pour_élément :: fonc (empl créatrice: *CréatriceArbre, parent: *NoeudDeDisposition, noeud: *HTML.Noeud)
{
    si HTML.est_texte(noeud) {
        /* Les textes doivent une boite inline anonyme autour d'eux. */
        résultat := arbre.crée_noeud(NoeudDeDispositionInline)
        crée_style_pour_bloc_anonyme(résolveuse, résultat, parent comme *NoeudDeDispositionBloc, Display.Type.Inline)
        parent.ajoute_enfant(résultat)

        texte := arbre.crée_noeud(NoeudDeDispositionTexte)
        texte.noeud_texte = noeud comme *HTML.NoeudTexte
        résultat.ajoute_enfant(texte)
        retourne
    }

    saufsi HTML.est_élément(noeud) {
        retourne
    }

    élément := noeud comme *HTML.Élément

    propriétés_parent: *PropriétésDeStyle
    si parent {
        propriétés_parent = parent.propriétés
    }

    propriétés := résoud_style(résolveuse, élément, propriétés_parent)

    display := propriétés.donne_valeur_calculée(IDPropriété.Display).display
    si display.outer_type == Display.Type.None {
        détruit_propriétés(propriétés)
        retourne
    }

    résultat: *NoeudDeDisposition
    si élément.local_name == HTML.TAG_img {
        résultat = crée_noeud_de_remplacement_image(arbre, élément comme *HTML.HTMLImageElement)
    }
    sinon si élément.local_name == HTML.TAG_input && HTML.is_text_entry_widget(élément comme *HTML.HTMLInputElement) {
        résultat = crée_noeud_de_remplacement_text_input(arbre, élément comme *HTML.HTMLInputElement)
    }
    sinon si élément.local_name == HTML.TAG_textarea {
        résultat = crée_noeud_de_remplacement_textarea(arbre, élément comme *HTML.HTMLTextAreaElement)
    }
    sinon si display.outer_type == Display.Type.Block {
        bloc := arbre.crée_noeud(NoeudDeDispositionBloc)
        bloc.élément = élément
        résultat = bloc
    }
    sinon si élément.local_name == HTML.TAG_br {
        bris := arbre.crée_noeud(NoeudDeDispositionNouvelleLigne)
        bris.élément = élément
        résultat = bris
    }
    sinon {
        inline := arbre.crée_noeud(NoeudDeDispositionInline)
        inline.élément = élément
        résultat = inline
    }

    si parent == nul {
        résolveuse.taille_fonte_racine = propriétés.donne_valeur_calculée(IDPropriété.FontSize).pixels
    }

    élément.noeud_de_disposition = résultat
    résultat.propriétés = propriétés

    si parent {
        parent.ajoute_enfant(résultat)
    }

    pour noeud.enfants {
        crée_noeud_pour_élément(créatrice, résultat, it)
    }

    corrige_hiérarchie(résultat, créatrice)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ContexteDessin
 * \{ */

ContexteDessin :: struct {
    document: *HTML.Document
    globales: *GlobalesDessin
    peintre: *Peintre

    hauteur_vue: z32
    largeur_vue: z32

    décalage_y: r32
}

donne_rectangle_corrigé :: fonc (ctx: *ContexteDessin, rect: RectanglePosDim(r32)) -> RectanglePosDim(r32)
{
    /* Nous disposons les noeuds comme si leur origine était leur coin du haut
     * gauche mais nous devons les dessiner comme si leur origine était leur
     * coin du bas gauche.
     * De plus, nous devons nous assurer que l'origine du document est le bas
     * gauche de la page et non le haut gauche. */
    rect.y = ctx.hauteur_vue comme r32 + ctx.décalage_y - rect.y - rect.hauteur
    retourne rect
}

remplis_rectangle_id :: fonc (ctx: *ContexteDessin, noeud: *NoeudDeDisposition)
{
    // peintre := ctx.peintre

    // entropie := graine_aléatoire(noeud.id + 1)

    // couleur: CouleurRVBA
    // couleur.r = aléatoire_unilatérale(entropie)
    // couleur.v = aléatoire_unilatérale(entropie)
    // couleur.b = aléatoire_unilatérale(entropie)
    // couleur.a = 1.0

    rect := ctx.donne_rectangle_corrigé(noeud.donne_rectangle_bordure())
    // peintre.remplis_rectangle(rect, couleur)

    IGUMI.commence_immédiat_id(IGUMI.ModeImmédiat.TRIANGLES, IGUMI.nuanceur_id)

    // imprime("[%] (% % % %) : %\n", #nom_de_cette_fonction, rect.x, rect.y, rect.largeur, rect.hauteur, noeud.id)

    IGUMI.quad_immédiat_id(rect.x, rect.y, rect.largeur, rect.hauteur, noeud.id)
}

remplis_rectangle_id :: fonc (ctx: *ContexteDessin, noeud: *NoeudDeDisposition, rect: RectanglePosDim(r32))
{
    // peintre := ctx.peintre

    // entropie := graine_aléatoire(noeud.id + 1)

    // couleur: CouleurRVBA
    // couleur.r = aléatoire_unilatérale(entropie)
    // couleur.v = aléatoire_unilatérale(entropie)
    // couleur.b = aléatoire_unilatérale(entropie)
    // couleur.a = 1.0

    rect = ctx.donne_rectangle_corrigé(rect)
    // peintre.remplis_rectangle(rect, couleur)

    IGUMI.commence_immédiat_id(IGUMI.ModeImmédiat.TRIANGLES, IGUMI.nuanceur_id)

    // imprime("[%] (% % % %) : %\n", #nom_de_cette_fonction, rect.x, rect.y, rect.largeur, rect.hauteur, noeud.id)

    IGUMI.quad_immédiat_id(rect.x, rect.y, rect.largeur, rect.hauteur, noeud.id)
}

dessine_image :: fonc (ctx: *ContexteDessin, image: ImageIO, rect: RectanglePosDim(r32))
{
    rect = ctx.donne_rectangle_corrigé(rect)
    peintre := ctx.peintre

    si image.donnees {
        peintre.dessine_image(image, rect)
    }
    sinon {
        /* À FAIRE : image nulle */
        peintre.remplis_rectangle(rect, CouleurRVBA(1.0, 0.0, 1.0, 1.0))
    }
}

donne_image_pour_url :: fonc (ctx: *ContexteDessin, url_string: chaine) -> Optionnel(ImageIO)
{
    données_image := HTML.donne_image_pour_url(ctx.document, url_string)

    si données_image.état == HTML.ÉtatRequêteImage.Succès {
        retourne données_image.données
    }

    si données_image.état == HTML.ÉtatRequêteImage.Échec {
        retourne
    }

    si données_image.état == HTML.ÉtatRequêteImage.EnCours {
        retourne
    }

    url_string_utf16 := crée_chaine_utf16(url_string)
    diffère détruit_chaine(url_string_utf16)

    url_src := HTML.basic_url_parser(url_string_utf16)

    HTML.définis_état_requête_image(ctx.document, url_string, HTML.ÉtatRequêteImage.EnCours)

    RappelProcessResponse :: struct {
        empl base: HTML.BaseProcessResponse

        document: *HTML.Document
        request: *HTML.Request
        url_src: *HTML.URL
        url_string: chaine
    }

    sur_rappel_process_response :: fonc (base: *HTML.BaseProcessResponse, réponse: *HTML.Response)
    {
        diffère HTML.détruit_response(réponse)

        rappel := base comme *RappelProcessResponse

        saufsi réponse.body_info {
            HTML.définis_état_requête_image(rappel.document, rappel.url_string, HTML.ÉtatRequêteImage.Échec)
            retourne
        }

        content_type := réponse.body_info.content_type
        saufsi est_type_mime_image(content_type) {
            HTML.définis_état_requête_image(rappel.document, rappel.url_string, HTML.ÉtatRequêteImage.Échec)
            retourne
        }

        // À FAIRE : prend le chemin de l'url si le schéma n'est pas "data"
        chemin_image := ""
        si content_type == "image/png" {
            chemin_image = "image.png"
        }
        sinon si content_type == "image/jpeg" {
            chemin_image = "image.jpeg"
        }
        sinon {
            panique("chemin image non résolvable")
        }

        contenu := réponse.body.Quelque

        proxy_image := IMG_cree_proxy_memoire(contenu.pointeur, contenu.taille comme n64)
        diffère IMG_detruit_proxy(proxy_image)

        chn_c_chemin := crée_chaine_c(chemin_image)
        diffère détruit_chaine_c(chn_c_chemin)

        image_data: ImageIO
        résultat_lecture_image := IMG_ouvre_image_avec_proxy(chn_c_chemin, *image_data, proxy_image)
        si résultat_lecture_image != ResultatOperation.OK {
            HTML.définis_état_requête_image(rappel.document, rappel.url_string, HTML.ÉtatRequêteImage.Échec)
            retourne
        }

        HTML.définis_données_image(rappel.document, rappel.url_string, image_data)
        HTML.invalide_style_pour_image(rappel.document)
    }

    sur_destruction_process_response :: fonc (base: *HTML.BaseProcessResponse)
    {
        rappel := base comme *RappelProcessResponse
        HTML.détruit_url(rappel.url_src)
        HTML.détruit_request(rappel.request)
        déloge(rappel)
    }

    process_response := loge(RappelProcessResponse)
    process_response.document = ctx.document
    process_response.url_src = url_src
    process_response.url_string = url_string
    process_response.sur_rappel = sur_rappel_process_response
    process_response.sur_destruction = sur_destruction_process_response

    request := loge(HTML.Request)
    request.destination = "image"
    request.mode = "no-cors"
    request.redirect_mode = "follow"
    HTML.définis_url(request, tente parse_uri_standard(copie_chaine(url_string)) piège nonatteignable)
    process_response.request = request

    user_agent := HTML.donne_user_agent(ctx.document)
    fetch_controller := HTML.fetch(user_agent, request, process_response = process_response)
    diffère HTML.détruit_fetch_controller(fetch_controller)
}

dessine_arrière_plan :: fonc (ctx: *ContexteDessin, noeud: *NoeudDeDispositionBloc)
{
    peintre := ctx.peintre

    background_color := noeud.propriétés.donne_valeur_utilisée(IDPropriété.BackgroundColor).couleur
    si background_color.a != 0 {
        rect_noeud: RectanglePosDim(r32)
        si noeud.parent == nul {
            /* L'arrière plan de l'élément racine doit s'appliquer au cannevas. */
            rect_noeud.hauteur = ctx.hauteur_vue comme r32
            rect_noeud.largeur = ctx.largeur_vue comme r32
        }
        sinon {
            rect_noeud = ctx.donne_rectangle_corrigé(noeud.donne_rectangle_bordure())
        }

        border_radius_top_left := noeud.propriétés.donne_valeur_utilisée(IDPropriété.BorderTopLeftRadius).pixels comme r32
        border_radius_top_right := noeud.propriétés.donne_valeur_utilisée(IDPropriété.BorderTopRightRadius).pixels comme r32
        border_radius_bottom_right := noeud.propriétés.donne_valeur_utilisée(IDPropriété.BorderBottomRightRadius).pixels comme r32
        border_radius_bottom_left := noeud.propriétés.donne_valeur_utilisée(IDPropriété.BorderBottomLeftRadius).pixels comme r32

        rayons := [ border_radius_top_left, border_radius_top_right, border_radius_bottom_right, border_radius_bottom_left ]
        peintre.remplis_rectangle_arrondi(rect_noeud, rayons, background_color)
    }
    sinon si noeud.parent == nul && noeud.élément && noeud.élément.local_name == HTML.TAG_html {
        /* Hérite de l'arrière-plan du "body".
            * https://www.w3.org/TR/CSS21/colors.html#background */
        body := HTML.donne_élément_body(noeud.élément.document)
        si body && body.noeud_de_disposition {
            background_color = body.noeud_de_disposition.propriétés.donne_valeur_utilisée(IDPropriété.BackgroundColor).couleur
            si background_color.a != 0 {
                /* À FAIRE : ne peint pas l'arrière-plan du "body" dans ce cas. */
                rect_noeud: RectanglePosDim(r32)
                rect_noeud.hauteur = ctx.hauteur_vue comme r32
                rect_noeud.largeur = ctx.largeur_vue comme r32
                peintre.remplis_rectangle(rect_noeud, background_color)
            }
        }
    }

    image := noeud.propriétés.donne_valeur_utilisée(IDPropriété.BackgroundImage)
    si image.est_none() {
        retourne
    }

    opt_image_data := ctx.donne_image_pour_url(image.url_absolu)
    saufsi opt_image_data.possède_valeur() {
        retourne
    }

    /* À FAIRE : parse la propriété "background-repeat". Ceci est la valeur défaut. */
    répétition: RépétitionImage
    répétition.x = GenreRépétitionImage.Normale
    répétition.y = GenreRépétitionImage.Normale

    image_data := opt_image_data.Quelque
    /* À FAIRE : background-clip */
    rect := noeud.donne_rectangle_bordure()

    rect_image := rect
    rect_image.largeur = image_data.largeur comme r32
    rect_image.hauteur = image_data.hauteur comme r32

    rect = ctx.donne_rectangle_corrigé(rect)
    rect_image = ctx.donne_rectangle_corrigé(rect_image)
    peintre.dessine_image(image_data, rect_image, rect, répétition)
}

dessine_bordure :: fonc (ctx: *ContexteDessin, noeud: *NoeudDeDispositionBloc)
{
    bordure := donne_bordure(*noeud.propriétés.style)
    peintre := ctx.peintre

    pour bordure.style {
        si it == LineStyle.None || it == LineStyle.Hidden {
            continue
        }

        coté := index_it comme z32 comme BorderEdge

        couleur: CouleurRVBAN8

        si it == LineStyle.Inset {
            si coté == BorderEdge.Top || coté == BorderEdge.Left {
                couleur = CouleurRVBAN8(154, 154, 154, 255)
            }
            sinon {
                couleur = CouleurRVBAN8(238, 238, 238, 255)
            }
        }
        sinon si it == LineStyle.Outset {
            si coté == BorderEdge.Top || coté == BorderEdge.Left {
                couleur = CouleurRVBAN8(238, 238, 238, 255)
            }
            sinon {
                couleur = CouleurRVBAN8(154, 154, 154, 255)
            }
        }
        sinon {
            border_color := bordure.color[coté]
            /* À FAIRE : calcule la valeur même s'il n'y a pas de propriété. */
            si border_color.est_mot_clé(PROP_currentColor) {
                couleur = noeud.propriétés.donne_valeur_utilisée(IDPropriété.Color)
            }
            sinon {
                couleur = bordure.color[coté].couleur
            }
        }

        largeur := bordure.width[coté].pixels comme r32

        rect: RectanglePosDim(r32)
        rect_bordure := noeud.donne_rectangle_bordure()

        si coté == BorderEdge.Top {
            rect.x = rect_bordure.x
            rect.y = rect_bordure.y
            rect.largeur = rect_bordure.largeur
            rect.hauteur = largeur
        }
        sinon si coté == BorderEdge.Bottom {
            rect.x = rect_bordure.x
            rect.y = rect_bordure.y + rect_bordure.hauteur - largeur
            rect.largeur = rect_bordure.largeur
            rect.hauteur = largeur
        }
        sinon si coté == BorderEdge.Left {
            rect.x = rect_bordure.x
            rect.y = rect_bordure.y
            rect.largeur = largeur
            rect.hauteur = rect_bordure.hauteur
        }
        sinon /* si coté == BorderEdge.Right */ {
            rect.x = rect_bordure.x + rect_bordure.largeur - largeur
            rect.y = rect_bordure.y
            rect.largeur = largeur
            rect.hauteur = rect_bordure.hauteur
        }

        rect = ctx.donne_rectangle_corrigé(rect)
        peintre.remplis_rectangle(rect, couleur)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NoeudDeDisposition
 * \{ */

ModèleDeBoite :: struct {
    marge: RectanglePosDim(r32)
    bordure: RectanglePosDim(r32)
    rembourrage: RectanglePosDim(r32)
    contenu: RectanglePosDim(r32)
}

décale_horizontalement :: fonc (modèle: &ModèleDeBoite, delta: r32)
{
    modèle.marge.x += delta
    modèle.bordure.x += delta
    modèle.rembourrage.x += delta
    modèle.contenu.x += delta
}

décale_verticalement :: fonc (modèle: &ModèleDeBoite, delta: r32)
{
    modèle.marge.y += delta
    modèle.bordure.y += delta
    modèle.rembourrage.y += delta
    modèle.contenu.y += delta
}

définis_hauteur_contenu :: fonc (modèle: &ModèleDeBoite, hauteur: r32)
{
    modèle.marge.hauteur = hauteur
    modèle.bordure.hauteur = hauteur
    modèle.contenu.hauteur = hauteur
    modèle.rembourrage.hauteur = hauteur
}

incrémente_hauteur_contenu :: fonc (modèle: &ModèleDeBoite, hauteur: r32)
{
    modèle.marge.hauteur += hauteur
    modèle.bordure.hauteur += hauteur
    modèle.contenu.hauteur += hauteur
    modèle.rembourrage.hauteur += hauteur
}

définis_largeur_contenu :: fonc (modèle: &ModèleDeBoite, largeur: r32)
{
    modèle.marge.largeur = largeur
    modèle.bordure.largeur = largeur
    modèle.contenu.largeur = largeur
    modèle.rembourrage.largeur = largeur
}

définis_largeur :: fonc (modèle: &ModèleDeBoite, largeur: r32)
{
    modèle.contenu.largeur = largeur
}

définis_hauteur :: fonc (modèle: &ModèleDeBoite, hauteur: r32)
{
    modèle.contenu.hauteur = hauteur
}

NoeudDeDisposition :: struct {
    type := #type_de_cette_structure

    id: n32
    propriétés: *PropriétésDeStyle

    parent: *NoeudDeDisposition
    enfants: [..]*NoeudDeDisposition

    modèle_de_boite: ModèleDeBoite

    sur_mesure: fonc (*NoeudDeDisposition, *ContexteDeFormattage, ModeDeFormattage)(rien)
    sur_dessin: fonc (*NoeudDeDisposition, *ContexteDessin)(rien)
    sur_dessin_fragment: fonc (*NoeudDeDisposition, *Fragment, *LignesTenante, *ContexteDessin)(rien)
    sur_dessin_tampon_id: fonc (*NoeudDeDisposition, *ContexteDessin)(rien)
    sur_dessin_fragment_tampon_id: fonc (*NoeudDeDisposition, *Fragment, *ContexteDessin)(rien)
    sur_divise_en_lignes: fonc (*NoeudDeDisposition, *Enligneuse, *ContexteDeFormattage, ModeDeFormattage)(rien)
    sur_correction_hiérarchie: fonc(*NoeudDeDisposition, *CréatriceArbre)(rien)
}

donne_propriétés :: fonc (noeud: *NoeudDeDisposition) -> *PropriétésDeStyle
{
    si noeud.type == NoeudDeDispositionTexte {
        retourne donne_propriété_parent(noeud comme *NoeudDeDispositionTexte)
    }
    retourne noeud.propriétés
}

détermine_fonte :: fonc (noeud: *NoeudDeDisposition, ctx: *ContexteDeFormattage) -> *Fonte
{
    globales := ctx.globales
    assert(globales != nul)
    famille_fonte := "sérif"
    style := "normal"
    graisse := GraisseFonte.Normal
    propriétés := noeud.donne_propriétés()
    taille_fonte := propriétés.donne_valeur_utilisée(IDPropriété.FontSize).pixels comme r32

    font_family := propriétés.donne_valeur_utilisée(IDPropriété.FontFamily).mot_clé
    si font_family == PROP_monospace {
        famille_fonte = "monospace"
    }
    sinon si font_family == PROP_sans_serif {
        famille_fonte = "sans-serif"
    }

    font_weight := propriétés.donne_valeur_utilisée(IDPropriété.FontWeight).number
    si font_weight >= 700.0 {
        graisse = GraisseFonte.Gras
    }

    font_style := propriétés.donne_valeur_utilisée(IDPropriété.FontStyle).mot_clé
    si font_style == PROP_italic {
        style = "italic"
    }

    résultat := globales.donne_fonte(famille_fonte, style, graisse, taille_fonte)
    si noeud.type == NoeudDeDispositionTexte {
        noeud_texte := noeud comme *NoeudDeDispositionTexte
        noeud_texte.fonte = résultat
    }
    retourne résultat
}

donne_rectangle_bordure :: fonc (noeud: *NoeudDeDisposition) -> RectanglePosDim(r32)
{
    retourne noeud.modèle_de_boite.bordure
}

donne_rectangle_contenu :: fonc (noeud: *NoeudDeDisposition) -> RectanglePosDim(r32)
{
    retourne noeud.modèle_de_boite.contenu
}

donne_propriété_parent :: fonc (noeud_texte: *NoeudDeDispositionTexte) -> *PropriétésDeStyle
{
    parent := noeud_texte.parent
    tantque est_noeud_anonyme(parent) {
        parent = parent.parent
    }
    retourne parent.propriétés
}

est_noeud_anonyme :: fonc (noeud: *NoeudDeDisposition) -> bool
{
    si noeud.type != NoeudDeDispositionBloc && noeud.type != NoeudDeDispositionInline {
        retourne faux
    }

    noeud_bloc := noeud comme *NoeudDeDispositionBloc
    retourne noeud_bloc.élément == nul
}

est_noeud_non_anonyme :: fonc (noeud: *NoeudDeDisposition) -> bool
{
    retourne !est_noeud_anonyme(noeud)
}

est_block_level :: fonc (noeud: *NoeudDeDisposition) -> bool
{
    assert(noeud.propriétés != nul)
    retourne donne_display(noeud).outer_type == Display.Type.Block
}

est_inline_level :: fonc (noeud: *NoeudDeDisposition) -> bool
{
    assert(noeud.propriétés != nul)
    retourne donne_display(noeud).outer_type == Display.Type.Inline
}

donne_display :: fonc (noeud: *NoeudDeDisposition) -> Display
{
    assert(noeud.propriétés != nul)
    retourne noeud.propriétés.donne_valeur_utilisée(IDPropriété.Display).display
}

donne_line_height :: fonc (noeud: *NoeudDeDisposition, ctx: *ContexteDeFormattage) -> r32
{
    fonte := détermine_fonte(noeud, ctx)
    retourne donne_line_height(noeud.propriétés, fonte)
}

donne_line_height :: fonc (propriétés: *PropriétésDeStyle, fonte: *Fonte) -> r32
{
    line_height := propriétés.donne_valeur_utilisée(IDPropriété.LineHeight)
    si line_height.est_pixels() {
        retourne line_height.pixels comme r32
    }

    métriques := fonte.donne_métriques_fonte()

    si line_height.est_nombre() {
        retourne line_height.number comme r32 * métriques.donne_hauteur_ligne()
    }

    assert(line_height.est_mot_clé(PROP_normal))
    retourne métriques.donne_hauteur_ligne()
}

donne_élément :: fonc (noeud: *NoeudDeDisposition) -> *HTML.Élément
{
    si noeud.type == NoeudDeDispositionInline {
        retourne (noeud comme *NoeudDeDispositionBloc).élément
    }
    si noeud.type == NoeudDeDispositionRemplacement {
        retourne (noeud comme *NoeudDeDispositionBloc).élément
    }
    si noeud.type == NoeudDeDispositionBloc {
        retourne (noeud comme *NoeudDeDispositionBloc).élément
    }
    si noeud.type == NoeudDeDispositionNouvelleLigne {
        retourne (noeud comme *NoeudDeDispositionNouvelleLigne).élément
    }
    retourne nul
}

donne_élément_récursif :: fonc (noeud: *NoeudDeDisposition) -> *HTML.Élément
{
    noeud_courant := noeud

    tantque noeud_courant != nul {
        élément := noeud_courant.donne_élément()
        si élément {
            retourne élément
        }

        noeud_courant = noeud_courant.parent
    }

    retourne nul
}

décale :: fonc (noeud: *NoeudDeDisposition, x: r32, y: r32)
{
    décale_horizontalement(noeud.modèle_de_boite, x)
    décale_verticalement(noeud.modèle_de_boite, y)

    pour noeud.enfants {
        it.décale(x, y)
    }

    si noeud.type == NoeudDeDispositionBloc || noeud.type == NoeudDeDispositionInline {
        bloc := noeud comme *NoeudDeDispositionBloc
        pour * bloc.lignes_tenante.fragments {
            it.x += x
            it.y += y
        }
    }
}

donne_nom_classe :: fonc (noeud: *NoeudDeDisposition) -> chaine
{
    infos := __table_des_types[noeud.type] comme *InfoTypeStructure
    retourne infos.nom
}

mesure :: fonc (noeud: *NoeudDeDisposition, ctx: *ContexteDeFormattage, mode: ModeDeFormattage)
{
    si noeud.sur_mesure {
        noeud.sur_mesure(noeud, ctx, mode)
    }
}

dessine :: fonc (noeud: *NoeudDeDisposition, ctx: *ContexteDessin)
{
    si noeud.sur_dessin {
        noeud.sur_dessin(noeud, ctx)
    }
}

dessine_fragment :: fonc (noeud: *NoeudDeDisposition, fragment: *Fragment, lignes_tenante: *LignesTenante, ctx: *ContexteDessin)
{
    noeud.sur_dessin_fragment(noeud, fragment, lignes_tenante, ctx)
}

dessine_tampon_id :: fonc (noeud: *NoeudDeDisposition, ctx: *ContexteDessin)
{
    si noeud.sur_dessin_tampon_id {
        noeud.sur_dessin_tampon_id(noeud, ctx)
    }
}

dessine_fragment_tampon_id :: fonc (noeud: *NoeudDeDisposition, fragment: *Fragment, ctx: *ContexteDessin)
{
    saufsi noeud.sur_dessin_fragment_tampon_id {
        ctx.remplis_rectangle_id(noeud, fragment.donne_rectangle())
        retourne
    }

    noeud.sur_dessin_fragment_tampon_id(noeud, fragment, ctx)
}

ajoute_enfant :: fonc (parent: *NoeudDeDisposition, enfant: *NoeudDeDisposition)
{
    enfant.parent = parent
    tableau_ajoute(*parent.enfants, enfant)
}

donne_curseur :: fonc (noeud: *NoeudDeDisposition) -> CursorType
{
    saufsi noeud.propriétés {
        retourne CursorType.auto
    }
    retourne noeud.propriétés.donne_valeur_utilisée(IDPropriété.Cursor).cursor
}

divise_en_lignes :: fonc (noeud: *NoeudDeDisposition, enligneuse: *Enligneuse, ctx: *ContexteDeFormattage, mode: ModeDeFormattage)
{
    si noeud.sur_divise_en_lignes {
        noeud.sur_divise_en_lignes(noeud, enligneuse, ctx, mode)
        retourne
    }

    pour noeud.enfants {
        divise_en_lignes(it, enligneuse, ctx, mode)
    }
}

corrige_hiérarchie :: fonc (noeud: *NoeudDeDisposition, créatrice: *CréatriceArbre)
{
    si noeud.sur_correction_hiérarchie {
        noeud.sur_correction_hiérarchie(noeud, créatrice)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ContainingBlock
 * https://www.w3.org/TR/2011/REC-CSS2-20110607/visudet.html#containing-block-details
 * https://drafts.csswg.org/css-display/#containing-block
 * https://www.w3.org/TR/css-position-3/#def-cb
 * \{ */

ContainingBlock :: struct {
    rect: RectanglePosDim(r32)
    noeud: *NoeudDeDisposition
}

crée_containing_block_pour_contenu :: fonc (noeud: *NoeudDeDisposition) -> ContainingBlock
{
    résultat: ContainingBlock
    résultat.rect = noeud.modèle_de_boite.contenu
    résultat.noeud = noeud
    retourne résultat
}

crée_containing_block_pour_rembourrage :: fonc (noeud: *NoeudDeDisposition) -> ContainingBlock
{
    résultat: ContainingBlock
    résultat.rect = noeud.modèle_de_boite.rembourrage
    résultat.noeud = noeud
    retourne résultat
}

donne_x :: fonc (bloc: &ContainingBlock) -> r32
{
    retourne bloc.rect.x
}

donne_y :: fonc (bloc: &ContainingBlock) -> r32
{
    retourne bloc.rect.y
}

donne_largeur :: fonc (bloc: &ContainingBlock) -> r32
{
    retourne bloc.rect.largeur
}

donne_hauteur :: fonc (bloc: &ContainingBlock) -> r32
{
    retourne bloc.rect.hauteur
}

donne_containing_block :: fonc (noeud: *NoeudDeDisposition, ctx: *ContexteDeFormattage) -> ContainingBlock
{
    // 1. The containing block in which the root element lives is a rectangle called the initial containing block.
    // For continuous media, it has the dimensions of the viewport and is anchored at the canvas origin;
    // it is the page area for paged media.
    // The 'direction' property of the initial containing block is the same as for the root element.
    si noeud.parent == nul {
        retourne ctx.donne_initial_containing_block()
    }

    // 2. For other elements, if the element's position is 'relative' or 'static',
    // the containing block is formed by the content edge of the nearest block
    // container ancestor box.
    position := noeud.propriétés.donne_valeur_utilisée(IDPropriété.Position)
    si position.est_mot_clé(PROP_relative) || position.est_mot_clé(PROP_static) {
        parent := noeud.parent

        tantque parent != nul {
            si parent.type == NoeudDeDispositionBloc {
                retourne crée_containing_block_pour_contenu(parent)
            }

            parent = parent.parent
        }
    }
    // 3. If the element has 'position: fixed', the containing block is established by the viewport
    // in the case of continuous media or the page area in the case of paged media.
    sinon si position.est_mot_clé(PROP_fixed) {
        retourne ctx.donne_initial_containing_block()
    }
    // 4. If the element has 'position: absolute', the containing block is established by the nearest
    // ancestor with a 'position' of 'absolute', 'relative' or 'fixed', in the following way:
    sinon si position.est_mot_clé(PROP_absolute) {
        ancêtre := noeud.parent

        tantque ancêtre != nul {
            position_parent := ancêtre.propriétés.donne_valeur_utilisée(IDPropriété.Position)
            si position_parent.est_mot_clé(PROP_relative) || position_parent.est_mot_clé(PROP_absolute) || position_parent.est_mot_clé(PROP_fixed) {
                arrête
            }

            ancêtre = ancêtre.parent
        }

        si ancêtre {
            // À FAIRE : 1. In the case that the ancestor is an inline element, the containing block is the bounding
            // box around the padding boxes of the first and the last inline boxes generated for that element.
            // In CSS 2.1, if the inline element is split across multiple lines, the containing block is undefined.

            // À FAIRE : 2. Otherwise, the containing block is formed by the padding edge of the ancestor.
            retourne crée_containing_block_pour_rembourrage(ancêtre)
        }
    }

    // If there is no such ancestor, the containing block is the initial containing block.
    retourne ctx.donne_initial_containing_block()
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom BoiteDeLigne
 * Boite pour tenir les fragments de chaque ligne pour les dispositions
 * « inline ».
 * https://www.w3.org/TR/2011/REC-CSS2-20110607/visuren.html#line-box
 * \{ */

Fragment :: struct {
    Type :: énum {
        Normal
        MargeDébut
        MargeFin
        RembourrageDébut
        RembourrageFin
    }

    noeud: *NoeudDeDisposition
    index_début: z64
    index_fin: z64
    type: Type

    x: r32
    y: r32
    hauteur: r32
    largeur: r32
}

donne_rectangle :: fonc (fragment: *Fragment) -> RectanglePosDim(r32)
{
    rect: RectanglePosDim(r32)
    rect.x = fragment.x
    rect.y = fragment.y
    rect.largeur = fragment.largeur
    rect.hauteur = fragment.hauteur
    retourne rect
}

BoiteDeLigne :: struct {
    bloc: *NoeudDeDispositionBloc

    premier_fragment: z64
    dernier_fragment: z64
    largeur_courante: r32
    hauteur_contenu: r32
}

détruit_données_boite_de_ligne :: fonc (boite: *BoiteDeLigne)
{
    déloge(boite.fragments)
}

peut_ajouter_fragment :: fonc (boite: *BoiteDeLigne, largeur: r32) -> bool
{
    retourne (boite.largeur_courante + largeur) < boite.bloc.propriétés.donne_valeur_utilisée(IDPropriété.Width).pixels comme r32
}

garantis_hauteur_minimale :: fonc (boite: *BoiteDeLigne, hauteur: r32)
{
    boite.hauteur_contenu = max(boite.hauteur_contenu, hauteur)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom LignesTenante
 * Structure pour tenir les BoiteDeLignes et leurs fragments d'un bloc.
 * \{ */

LignesTenante :: struct {
    bloc: *NoeudDeDispositionBloc
    lignes: [..]BoiteDeLigne
    fragments: [..]Fragment
}

réinitialise :: fonc (lignes_tenante: *LignesTenante)
{
    lignes_tenante.lignes.taille = 0
    lignes_tenante.fragments.taille = 0
}

détruit_données :: fonc (lignes_tenante: *LignesTenante)
{
    déloge(lignes_tenante.lignes)
    déloge(lignes_tenante.fragments)
}

donne_ligne_courante :: fonc (lignes_tenante: *LignesTenante) -> *BoiteDeLigne
{
    si lignes_tenante.lignes.taille == 0 {
        retourne ajoute_ligne(lignes_tenante)
    }

    retourne *lignes_tenante.lignes[lignes_tenante.lignes.taille - 1]
}

ajoute_ligne :: fonc (lignes_tenante: *LignesTenante) -> *BoiteDeLigne
{
    résultat := tableau_ajoute_élément(*lignes_tenante.lignes)
    résultat.bloc = lignes_tenante.bloc
    résultat.premier_fragment = lignes_tenante.fragments.taille
    /* -1 pour que le calcul du nombre de fragments se fasse via "fin - début + 1", et
     * avoir un résultat correcte quand il n'y a aucun fragment dans la ligne. */
    résultat.dernier_fragment = lignes_tenante.fragments.taille - 1
    retourne résultat
}

ajoute_fragment :: fonc (lignes_tenante: *LignesTenante, fragment: &Fragment) -> z64
{
    résultat := lignes_tenante.fragments.taille
    tableau_ajoute(*lignes_tenante.fragments, fragment)
    retourne résultat
}

donne_fragments_ligne :: fonc (lignes_tenante: *LignesTenante, ligne: *BoiteDeLigne) -> []Fragment
{
    résultat: []Fragment
    résultat.pointeur = lignes_tenante.fragments.pointeur + ligne.premier_fragment
    résultat.taille = ligne.dernier_fragment - ligne.premier_fragment + 1
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Enligneuse
 * \{ */

Enligneuse :: struct {
    bloc_contenant: *NoeudDeDispositionBloc
    ligne_courante: *BoiteDeLigne
    mode_de_formattage: ModeDeFormattage
}

divise_en_lignes :: fonc (enligneuse: *Enligneuse, bloc_contenant: *NoeudDeDispositionBloc, ctx: *ContexteDeFormattageInline, mode: ModeDeFormattage)
{
    réinitialise_lignes(bloc_contenant)
    enligneuse.bloc_contenant = bloc_contenant
    enligneuse.mode_de_formattage = mode
    bloc_contenant.lignes_tenante.bloc = bloc_contenant

    pour bloc_contenant.enfants {
        divise_en_lignes(it, enligneuse, ctx, mode)
    }
}

donne_lignes_tenante :: fonc (empl enligneuse: *Enligneuse) -> *LignesTenante
{
    retourne *bloc_contenant.lignes_tenante
}

ajoute_ligne :: fonc (empl enligneuse: *Enligneuse) -> *BoiteDeLigne
{
    ligne_courante = ajoute_ligne(*enligneuse.bloc_contenant.lignes_tenante)
    retourne ligne_courante
}

peut_ajouter_fragment :: fonc (empl enligneuse: *Enligneuse, largeur: r32) -> bool
{
    discr mode_de_formattage {
        Normal {
            retourne ligne_courante.peut_ajouter_fragment(largeur)
        }
        ToutesLesBrisuresDeLigne {
            retourne faux
        }
        BrisureDeLigneExplicite {
            /* Les <br> ajouterons une ligne explicitement. */
            retourne vrai
        }
    }
    retourne faux
}

ajoute_fragment :: fonc (empl enligneuse: *Enligneuse, noeud: *NoeudDeDisposition, index_début: z64, index_fin: z64, hauteur: r32, largeur: r32, type := Fragment.Type.Normal) -> z64
{
    lignes_tenante := *enligneuse.bloc_contenant.lignes_tenante

    ligne_courante = lignes_tenante.donne_ligne_courante()
    si mode_de_formattage == ModeDeFormattage.Normal && !ligne_courante.peut_ajouter_fragment(largeur) {
        ligne_courante = lignes_tenante.ajoute_ligne()
    }

    fragment: Fragment
    fragment.noeud = noeud
    fragment.index_début = index_début
    fragment.index_fin = index_fin
    fragment.hauteur = hauteur
    fragment.largeur = largeur
    fragment.x = ligne_courante.largeur_courante
    fragment.type = type

    ligne_courante.largeur_courante += largeur
    ligne_courante.garantis_hauteur_minimale(hauteur)

    ligne_courante.dernier_fragment = ajoute_fragment(lignes_tenante, fragment)
    retourne ligne_courante.dernier_fragment
}

ajoute_fragment :: fonc (enligneuse: *Enligneuse, noeud: *NoeudDeDisposition, hauteur: r32, largeur: r32, type: Fragment.Type) -> z64
{
    retourne ajoute_fragment(enligneuse, noeud, 0, 0, hauteur, largeur, type)
}

garantis_hauteur_minimale :: fonc (enligneuse: *Enligneuse, hauteur: r32)
{
    enligneuse.ligne_courante.garantis_hauteur_minimale(hauteur)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NoeudDeDispositionBloc
 * \{ */

/* Créé pour chaque noeud hors texte */
NoeudDeDispositionBloc :: struct {
    empl base: NoeudDeDisposition
    type = #type_de_cette_structure
    sur_mesure = noeud_disposition_bloc_sur_mesure
    sur_dessin = noeud_disposition_bloc_sur_dessin
    sur_dessin_tampon_id = noeud_disposition_bloc_sur_dessin_tampon_id
    sur_correction_hiérarchie = noeud_disposition_bloc_corrige_hiérarchie

    élément: *HTML.Élément

    lignes_tenante: LignesTenante

    est_disposition_inline: bool
}

détruit_lignes :: fonc (noeud: *NoeudDeDispositionBloc)
{
    détruit_données(*noeud.lignes_tenante)
}

réinitialise_lignes :: fonc (noeud: *NoeudDeDispositionBloc)
{
    réinitialise(*noeud.lignes_tenante)
}

détermine_disposition_interne :: fonc (noeud: *NoeudDeDispositionBloc)
{
    /* Crée des blocs anonymes pour envelopper les blocs inlines si au moins un enfant est un bloc.
     * Voir définition de "block container box" :
     * https://www.w3.org/TR/2011/REC-CSS2-20110607/visuren.html#block-boxes */
    doit_formatter_en_blocs := faux

    pour noeud.enfants {
        si it.est_block_level() {
            doit_formatter_en_blocs = vrai
            arrête
        }
    }

    noeud.est_disposition_inline = doit_formatter_en_blocs == faux
}

formatte_intérieur :: fonc (noeud: *NoeudDeDispositionBloc, ctx: *ContexteDeFormattage, mode: ModeDeFormattage)
{
    si (noeud.type == NoeudDeDispositionBloc && noeud.est_disposition_inline) || noeud.type == NoeudDeDispositionInline {
        ctx_local: ContexteDeFormattageInline
        ctx_local.racine = noeud
        ctx_local.globales = ctx.globales
        ctx_local.doit_aligner_les_descendants = ctx.doit_aligner_les_descendants
        ctx_local.initial_containing_block = ctx.initial_containing_block

        formatte(*ctx_local, noeud, mode)
    }
    sinon si noeud.donne_display().inner_type == Display.Type.Flex {
        ctx_local: ContexteDeFormattageFlex
        ctx_local.globales = ctx.globales
        ctx_local.initial_containing_block = ctx.initial_containing_block
        formatte(*ctx_local, noeud, mode)
    }
    sinon {
        si noeud.requiers_contexte_de_formattage_indépendant() {
            ctx_local: ContexteDeFormattageBloc
            diffère détruit_données_contexte(*ctx_local)
            ctx_local.racine = noeud
            ctx_local.globales = ctx.globales
            ctx_local.doit_aligner_les_descendants = ctx.doit_aligner_les_descendants
            ctx_local.initial_containing_block = ctx.initial_containing_block

            formatte(*ctx_local, noeud, mode)
            retourne
        }

        formatte(ctx, noeud, mode)
    }
}

est_élément_avec_attribut_alignement_spécial :: fonc (élément: *HTML.Élément) -> bool
{
    tags := [HTML.TAG_div, HTML.TAG_thead, HTML.TAG_tbody, HTML.TAG_tfoot, HTML.TAG_tr, HTML.TAG_td, HTML.TAG_th]

    pour tags {
        si élément.local_name == it {
            retourne vrai
        }
    }

    retourne faux
}

donne_alignement_descendants :: fonc (noeud: *NoeudDeDispositionBloc) -> Optionnel(AlignementTexte)
{
    saufsi noeud.élément {
        retourne
    }

    si noeud.élément.local_name == HTML.TAG_center {
        retourne AlignementTexte.Centre
    }

    si est_élément_avec_attribut_alignement_spécial(noeud.élément) {
        attribut_align := HTML.donne_attribut(noeud.élément, HTML.ATTR_align)
        saufsi attribut_align.possède_valeur() {
            retourne
        }

        alignement := attribut_align.Quelque
        si compare_ascii_insensible_à_la_casse(alignement, PROP_center) || compare_ascii_insensible_à_la_casse(alignement, PROP_middle) {
            retourne AlignementTexte.Centre
        }

        si compare_ascii_insensible_à_la_casse(alignement, PROP_right) {
            retourne AlignementTexte.Droite
        }

        si compare_ascii_insensible_à_la_casse(alignement, PROP_left) {
            retourne AlignementTexte.Gauche
        }

        si compare_ascii_insensible_à_la_casse(alignement, PROP_justify) {
            retourne AlignementTexte.Justifié
        }

        retourne
    }
}

noeud_disposition_bloc_sur_mesure :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDeFormattage, mode: ModeDeFormattage)
{
    noeud := base comme *NoeudDeDispositionBloc

    containing_block := donne_containing_block(base, ctx)

    modifie_marges_pour_alignement_forcé(ctx, noeud)

    /* À FAIRE : utilise les bonnes formules.
     * https://www.w3.org/TR/2011/REC-CSS2-20110607/visudet.html#Computing_widths_and_margins */
    calcule_largeur_et_marges(ctx, noeud, containing_block)
    calcule_hauteur_et_marges(noeud, containing_block)

    doit_aligner_les_descendants := ctx.doit_aligner_les_descendants
    alignement := donne_alignement_descendants(noeud)
    si alignement.possède_valeur() {
        ctx.doit_aligner_les_descendants = alignement
    }

    formatte_intérieur(noeud, ctx, mode)

    saufsi noeud.est_disposition_inline {
        /* À FAIRE : une disposition inline interfère avec la hauteur du bloc.
         * Il faudra réviser l'interaction entre la disposition inline et le type de noeud (block ou inline). */
        calcule_hauteur_et_marges(noeud, containing_block)
    }

    ctx.doit_aligner_les_descendants = doit_aligner_les_descendants
}

noeud_disposition_bloc_sur_dessin :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDessin)
{
    noeud := base comme *NoeudDeDispositionBloc

    si noeud.est_noeud_non_anonyme() {
        dessine_arrière_plan(ctx, noeud)
        dessine_bordure(ctx, noeud)
    }

    saufsi noeud.est_disposition_inline {
        dessine_enfants_block(noeud, ctx)
    }
    sinon {
        dessine_enfants_inline(noeud, ctx)
    }
}

noeud_disposition_bloc_sur_dessin_tampon_id :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDessin)
{
    noeud := base comme *NoeudDeDispositionBloc

    ctx.remplis_rectangle_id(noeud)

    saufsi noeud.est_disposition_inline {
        dessine_tampon_id_enfants_block(noeud, ctx)
    }
    sinon {
        dessine_tampon_id_enfants_inline(noeud, ctx)
    }
}

dessine_enfants_block :: fonc (noeud: *NoeudDeDispositionBloc, ctx: *ContexteDessin)
{
    // rect := ctx.donne_rectangle_corrigé(noeud)

    // couleur := CouleurRVBA(0.5, 0.0, 0.5, 1.0)

    // peintre := ctx.peintre
    // peintre.dessine_rectangle(rect, couleur)

    pour noeud.enfants {
        position := it.propriétés.donne_valeur_utilisée(IDPropriété.Position)
        saufsi position.est_mot_clé(PROP_static) {
            continue
        }
        dessine(it, ctx)
    }

    pour noeud.enfants {
        position := it.propriétés.donne_valeur_utilisée(IDPropriété.Position)
        si position.est_mot_clé(PROP_static) {
            continue
        }
        dessine(it, ctx)
    }
}

dessine_tampon_id_enfants_block :: fonc (noeud: *NoeudDeDispositionBloc, ctx: *ContexteDessin)
{
    pour noeud.enfants {
        dessine_tampon_id(it, ctx)
    }
}

dessine_enfants_inline :: fonc (noeud: *NoeudDeDispositionBloc, ctx: *ContexteDessin)
{
    lignes_tenante := *noeud.lignes_tenante
    pour * lignes_tenante.fragments {
        dessine_fragment(it.noeud, it, lignes_tenante, ctx)
    }
}

dessine_tampon_id_enfants_inline :: fonc (noeud: *NoeudDeDispositionBloc, ctx: *ContexteDessin)
{
    pour * noeud.lignes_tenante.fragments {
        dessine_fragment_tampon_id(it.noeud, it, ctx)
    }
}

noeud_disposition_bloc_corrige_hiérarchie :: fonc (base: *NoeudDeDisposition, créatrice: *CréatriceArbre)
{
    noeud := base comme *NoeudDeDispositionBloc
    détermine_disposition_interne(noeud)

    si noeud.est_disposition_inline {
        retourne
    }

    nouveaux_enfants: [..]*NoeudDeDisposition

    bloc_anonyme_courant: *NoeudDeDispositionBloc
    pour noeud.enfants {
        si it.est_block_level() {
            tableau_ajoute(*nouveaux_enfants, it)
            bloc_anonyme_courant = nul
            continue
        }

        si bloc_anonyme_courant == nul {
            bloc_anonyme_courant = créatrice.arbre.crée_noeud(NoeudDeDispositionBloc)
            bloc_anonyme_courant.parent = noeud
            bloc_anonyme_courant.est_disposition_inline = vrai
            crée_style_pour_bloc_anonyme(créatrice.résolveuse, bloc_anonyme_courant, noeud, Display.Type.Block)
            tableau_ajoute(*nouveaux_enfants, bloc_anonyme_courant)
        }

        bloc_anonyme_courant.ajoute_enfant(it)
    }

    déloge(noeud.enfants)
    noeud.enfants = nouveaux_enfants
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NoeudDeDispositionInline
 * \{ */

/* Créé pour chaque noeud hors texte */
NoeudDeDispositionInline :: struct {
    empl base_bloc: NoeudDeDispositionBloc
    type = #type_de_cette_structure
    sur_mesure = noeud_disposition_inline_sur_mesure
    sur_dessin = noeud_disposition_inline_sur_dessin
    sur_dessin_fragment = noeud_disposition_inline_sur_dessin_fragment
    sur_divise_en_lignes = noeud_disposition_inline_sur_divise_en_lignes
    sur_dessin_tampon_id = noeud_disposition_inline_sur_dessin_tampon_id
    sur_correction_hiérarchie = noeud_disposition_inline_corrige_hiérarchie
}

noeud_disposition_inline_sur_mesure :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDeFormattage, mode: ModeDeFormattage)
{
    noeud := base comme *NoeudDeDispositionInline
    containing_block := donne_containing_block(base, ctx)
    calcule_largeur_et_marges(ctx, noeud, containing_block)
    calcule_hauteur_et_marges(noeud, containing_block)
    formatte_intérieur(noeud, ctx, mode)
    calcule_hauteur_et_marges(noeud, containing_block)
}

noeud_disposition_inline_sur_divise_en_lignes :: fonc (base: *NoeudDeDisposition, enligneuse: *Enligneuse, ctx: *ContexteDeFormattage, mode: ModeDeFormattage)
{
    noeud := base comme *NoeudDeDispositionInline
    containing_block := donne_containing_block(noeud, ctx)
    calcule_largeur_et_marges(ctx, noeud, containing_block)
    calcule_hauteur_et_marges(noeud, containing_block)

    propriétés := noeud.propriétés

    margin_left := propriétés.donne_valeur_utilisée(IDPropriété.MarginLeft).pixels comme r32
    padding_left := propriétés.donne_valeur_utilisée(IDPropriété.PaddingLeft).pixels comme r32
    padding_right := propriétés.donne_valeur_utilisée(IDPropriété.PaddingRight).pixels comme r32
    margin_right := propriétés.donne_valeur_utilisée(IDPropriété.MarginRight).pixels comme r32

    fragment_marge_début := enligneuse.ajoute_fragment(noeud, 0.0, margin_left, Fragment.Type.MargeDébut)
    fragment_rembourrage_début := enligneuse.ajoute_fragment(noeud, 0.0, padding_left, Fragment.Type.RembourrageDébut)

    pour noeud.enfants {
        divise_en_lignes(it, enligneuse, ctx, mode)
    }

    fragment_rembourrage_fin := enligneuse.ajoute_fragment(noeud, 0.0, padding_right, Fragment.Type.RembourrageFin)
    fragment_marge_fin := enligneuse.ajoute_fragment(noeud, 0.0, margin_right, Fragment.Type.MargeFin)

    lignes_tenante := enligneuse.donne_lignes_tenante()

    hauteur := 0.0
    pour fragment_rembourrage_début + 1 ... fragment_rembourrage_fin - 1 {
        fragment := lignes_tenante.fragments[it]
        hauteur = max(fragment.hauteur, hauteur)
    }

    index_fragments := [fragment_marge_début, fragment_rembourrage_début, fragment_rembourrage_fin, fragment_marge_fin]
    pour index_fragments {
        fragment := *lignes_tenante.fragments[it]
        fragment.hauteur = hauteur
    }
}

noeud_disposition_inline_sur_dessin :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDessin)
{
    noeud := base comme *NoeudDeDispositionInline
    dessine_enfants_inline(noeud, ctx)
}

noeud_disposition_inline_sur_dessin_fragment :: fonc (base: *NoeudDeDisposition, fragment: *Fragment, lignes_tenante: *LignesTenante, ctx: *ContexteDessin)
{
    si fragment.type == Fragment.Type.MargeDébut || fragment.type == Fragment.Type.MargeFin {
        retourne
    }

    si fragment.type == Fragment.Type.RembourrageDébut {
        propriétés := base.propriétés

        background_color := propriétés.donne_valeur_utilisée(IDPropriété.BackgroundColor).couleur

        /* Le rembourrage vertical n'affecte pas la taille mais doit être inclus dans le dessin. */
        padding_top := propriétés.donne_valeur_utilisée(IDPropriété.PaddingTop).pixels comme r32
        padding_bottom := propriétés.donne_valeur_utilisée(IDPropriété.PaddingBottom).pixels comme r32

        si background_color.a != 0 {
            border_radius_top_left := propriétés.donne_valeur_utilisée(IDPropriété.BorderTopLeftRadius).pixels comme r32
            border_radius_top_right := propriétés.donne_valeur_utilisée(IDPropriété.BorderTopRightRadius).pixels comme r32
            border_radius_bottom_right := propriétés.donne_valeur_utilisée(IDPropriété.BorderBottomRightRadius).pixels comme r32
            border_radius_bottom_left := propriétés.donne_valeur_utilisée(IDPropriété.BorderBottomLeftRadius).pixels comme r32

            premier_fragment := fragment
            dernier_fragment := lignes_tenante.fragments.pointeur + lignes_tenante.fragments.taille
            tantque fragment != dernier_fragment {
                rect_noeud := ctx.donne_rectangle_corrigé(fragment.donne_rectangle())
                rect_noeud.y -= padding_top
                rect_noeud.hauteur += padding_top + padding_bottom

                est_premier_fragment := fragment == premier_fragment
                est_dernier_fragment := fragment.type == Fragment.Type.RembourrageFin && fragment.noeud == base

                si est_premier_fragment {
                    rayons := [border_radius_top_left, 0.0, 0.0, border_radius_bottom_left]
                    ctx.peintre.remplis_rectangle_arrondi(rect_noeud, rayons, background_color)
                }
                sinon si est_dernier_fragment {
                    rayons := [0.0, border_radius_top_right, border_radius_bottom_right, 0.0]
                    ctx.peintre.remplis_rectangle_arrondi(rect_noeud, rayons, background_color)
                }
                sinon {
                    ctx.peintre.remplis_rectangle(rect_noeud, background_color)
                }

                si est_dernier_fragment {
                    arrête
                }

                fragment += 1
            }
        }
    }
}

noeud_disposition_inline_sur_dessin_tampon_id :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDessin)
{
    noeud := base comme *NoeudDeDispositionInline
    ctx.remplis_rectangle_id(noeud)
    dessine_tampon_id_enfants_inline(noeud, ctx)
}

noeud_disposition_inline_corrige_hiérarchie :: fonc (base: *NoeudDeDisposition, créatrice: *CréatriceArbre)
{
    noeud := base comme *NoeudDeDispositionInline
    détermine_disposition_interne(noeud)

    si noeud.est_disposition_inline {
        retourne
    }

    assert(noeud.parent != nul)

    /* When an inline box contains an in-flow block-level box, the inline box (and its
     * inline ancestors within the same line box) are broken around the block-level
     * box (and any block-level siblings that are consecutive or separated only by
     * collapsible whitespace and/or out-of-flow elements), splitting the inline box
     * into two boxes (even if either side is empty), one on each side of the
     * block-level box(es). The line boxes before the break and after the break are
     * enclosed in anonymous block boxes, and the block-level box becomes a sibling of
     * those anonymous boxes. When such an inline box is affected by relative
     * positioning, any resulting translation also affects the block-level box
     * contained in the inline box.
     *
     * À FAIRE : récursion
     *
     * https://www.w3.org/TR/2011/REC-CSS2-20110607/visuren.html#anonymous-block-level */
    anciens_enfants := noeud.enfants
    diffère déloge(anciens_enfants)

    noeud_inline_courant := noeud
    noeud_inline_courant.enfants.pointeur = nul
    noeud_inline_courant.enfants.taille = 0
    noeud_inline_courant.enfants.capacité = 0

    pour anciens_enfants {
        si it.est_block_level() {
            noeud.parent.ajoute_enfant(it)
            noeud_inline_courant = nul
            continue
        }

        si noeud_inline_courant == nul {
            noeud_inline_courant = créatrice.arbre.crée_noeud(NoeudDeDispositionInline)
            noeud_inline_courant.parent = noeud
            noeud_inline_courant.est_disposition_inline = vrai
            crée_style_pour_bloc_anonyme(créatrice.résolveuse, noeud_inline_courant, noeud, Display.Type.Inline)
            noeud.parent.ajoute_enfant(noeud_inline_courant)
        }

        noeud_inline_courant.ajoute_enfant(it)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NoeudDeDispositionNouvelleLigne
 * \{ */

/* Créé pour chaque noeud hors texte */
NoeudDeDispositionNouvelleLigne :: struct {
    empl base_bloc: NoeudDeDisposition
    type = #type_de_cette_structure
    élément: *HTML.Élément
    sur_divise_en_lignes = noeud_disposition_nouvelle_ligne_sur_divise_en_lignes
}

noeud_disposition_nouvelle_ligne_sur_divise_en_lignes :: fonc (base: *NoeudDeDisposition, enligneuse: *Enligneuse, ctx: *ContexteDeFormattage, mode: ModeDeFormattage @inutilisée)
{
    ligne := enligneuse.ajoute_ligne()
    line_height := donne_line_height(base, ctx)
    ligne.garantis_hauteur_minimale(line_height)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NoeudDeDispositionTexte
 * \{ */

/* Créé pour chaque élément contenant du texte. */
NoeudDeDispositionTexte :: struct {
    empl base: NoeudDeDisposition
    type = #type_de_cette_structure
    sur_mesure = noeud_disposition_texte_sur_mesure
    sur_dessin_fragment = noeud_disposition_texte_sur_dessin_fragment
    sur_divise_en_lignes = noeud_disposition_texte_sur_divise_en_lignes

    noeud_texte: *HTML.NoeudTexte
    texte: ChaineUTF16
    fonte: *Fonte

    morceaux: [..]ChaineUTF16
}

noeud_disposition_texte_sur_mesure :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDeFormattage, mode: ModeDeFormattage @inutilisée)
{
    noeud := base comme *NoeudDeDispositionTexte

    si est_vide_ou_uniquement_espaces_blanches(noeud.noeud_texte.données) {
        noeud.sur_dessin = nul
        retourne
    }

    fonte := détermine_fonte(noeud, ctx)
    métriques := fonte.donne_métriques_fonte()

    /* À FAIRE : meilleur algorithme, respect du standard. */
    morceaux := divise_sur_espaces_blanches_ascii(noeud.noeud_texte.données)
    diffère déloge(morceaux)

    enchaineuse: EnchaineuseUTF16
    initialise_enchaineuse(enchaineuse)
    diffère détruit_tampons(enchaineuse)

    virgule := ChaineUTF16Unique(0x20).donne_chaine_utf16()
    pour morceaux {
        si index_it > 0 {
            ajoute(enchaineuse, virgule)
        }
        ajoute(enchaineuse, it)
    }

    texte := chaine_depuis_enchaineuse(enchaineuse)
    noeud.texte = texte

    /* XXX */
    définis_hauteur_contenu(noeud.modèle_de_boite, métriques.donne_hauteur_ligne())

    largeur_texte := fonte.donne_largeur_texte(texte) comme r32
    définis_largeur_contenu(noeud.modèle_de_boite, largeur_texte)
}

noeud_disposition_texte_sur_divise_en_lignes :: fonc (base: *NoeudDeDisposition, enligneuse: *Enligneuse, ctx: *ContexteDeFormattage, mode: ModeDeFormattage)
{
    noeud := base comme *NoeudDeDispositionTexte
    déloge(noeud.morceaux)

    fonte := détermine_fonte(noeud, ctx)
    métriques := fonte.donne_métriques_fonte()

    définis_hauteur_contenu(noeud.modèle_de_boite, métriques.donne_hauteur_ligne())

    si est_vide_ou_uniquement_espaces_blanches(noeud.noeud_texte.données) {
        espace := ChaineUTF16Unique(' ' comme n32)
        largeur_espace := fonte.donne_largeur_texte(espace.donne_chaine_utf16())

        tableau_ajoute(*noeud.morceaux, espace.donne_chaine_utf16())

        /* À FAIRE : hauteur du contenu */
        _ := enligneuse.ajoute_fragment(noeud, 0, 1, 0.0, largeur_espace comme r32)
        retourne
    }

    /* À FAIRE : meilleur algorithme, respect du standard. */
    morceaux := divise_sur_espaces_blanches_ascii(noeud.noeud_texte.données)

    espace := ChaineUTF16Unique(' ' comme n32)
    index_espace := morceaux.taille
    largeur_espace := fonte.donne_largeur_texte(espace.donne_chaine_utf16())

    tableau_ajoute(*morceaux, espace.donne_chaine_utf16())

    noeud.morceaux = morceaux

    hauteur_texte := métriques.donne_hauteur_ligne()

    propriétés := donne_propriété_parent(noeud)
    line_height := donne_line_height(propriétés, fonte)
    /* line-height définis la hauteur minimale. */
    hauteur_texte = max(hauteur_texte, line_height)

    pour morceaux {
        largeur_morceau := fonte.donne_largeur_texte(it)

        _ := enligneuse.ajoute_fragment(noeud, index_it, index_it + 1, hauteur_texte, largeur_morceau comme r32)

        si index_it >= index_espace - 1 {
            continue
        }

        discr mode {
            Normal {
                si enligneuse.peut_ajouter_fragment(largeur_espace comme r32) {
                    _ := enligneuse.ajoute_fragment(noeud, index_espace, index_espace + 1, hauteur_texte, largeur_espace comme r32)
                }
            }
            ToutesLesBrisuresDeLigne {
                ligne := enligneuse.ajoute_ligne()
                ligne.garantis_hauteur_minimale(hauteur_texte)
            }
            BrisureDeLigneExplicite {
                _ := enligneuse.ajoute_fragment(noeud, index_espace, index_espace + 1, hauteur_texte, largeur_espace comme r32)
            }
        }
    }
}

noeud_disposition_texte_sur_dessin_fragment :: fonc (base: *NoeudDeDisposition, fragment: *Fragment, lignes_tenante: *LignesTenante @inutilisée, ctx: *ContexteDessin)
{
    noeud := base comme *NoeudDeDispositionTexte

    propriétés := donne_propriété_parent(noeud)

    effets: EffetsTexte

    line := propriétés.donne_valeur_utilisée(IDPropriété.TextDecorationLine)
    saufsi line.est_mot_clé(PROP_none) {
        decoration := line.text_decoration_line
        couleur := vers_couleur_rvba(propriétés.donne_valeur_utilisée(IDPropriété.TextDecorationColor).couleur)

        si decoration.UNDERLINE {
            effets.souslignage = vrai
            effets.couleur_souslignage = couleur
        }
        si decoration.OVERLINE {
            effets.surlignage = vrai
            effets.couleur_surlignage = couleur
        }
        si decoration.LINE_THROUGH {
            effets.barrage = vrai
            effets.couleur_barrage = couleur
        }
    }

    peintre := ctx.peintre
    fonte := noeud.fonte
    assert(fonte != nul)

    métriques := donne_métriques_fonte(fonte)
    couleur := propriétés.donne_valeur_utilisée(IDPropriété.Color).couleur

    rect := ctx.donne_rectangle_corrigé(fragment.donne_rectangle())
    rect.y -= métriques.jambage_inférieur

    // peintre.dessine_rectangle(rect, couleur)

    texte := noeud.morceaux[fragment.index_début]

    peintre.dessine_texte(fonte, texte, rect, couleur, *effets)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NoeudDeDispositionRemplacement
 * \{ */

/* Créé pour chaque noeud hors texte */
NoeudDeDispositionRemplacement :: struct {
    empl base_bloc: NoeudDeDispositionBloc
    type = #type_de_cette_structure
    sur_mesure = noeud_disposition_remplacement_sur_mesure
    sur_divise_en_lignes = noeud_disposition_remplacement_sur_divise_en_lignes
    sur_dessin_tampon_id = noeud_disposition_remplacement_sur_dessin_tampon_id
    sur_correction_hiérarchie = nul

    /* Rappels spécifiques. */
    sur_calcul_dimensions_intrinsèques: fonc(*NoeudDeDispositionRemplacement,*ContexteDeFormattage)(rien)
    
    ratio_intrinsèque: Optionnel(r32)
    largeur_intrinsèque: Optionnel(r32)
    hauteur_intrinsèque: Optionnel(r32)

    fonte: *Fonte
}

possède_ratio_intrinsèque :: fonc (noeud: *NoeudDeDispositionRemplacement) -> bool
{
    retourne noeud.ratio_intrinsèque.possède_valeur()
}

possède_largeur_intrinsèque :: fonc (noeud: *NoeudDeDispositionRemplacement) -> bool
{
    retourne noeud.largeur_intrinsèque.possède_valeur()
}

possède_hauteur_intrinsèque :: fonc (noeud: *NoeudDeDispositionRemplacement) -> bool
{
    retourne noeud.hauteur_intrinsèque.possède_valeur()
}

donne_ratio_intrinsèque :: fonc (noeud: *NoeudDeDispositionRemplacement) -> r32
{
    retourne noeud.ratio_intrinsèque.Quelque
}

donne_largeur_intrinsèque :: fonc (noeud: *NoeudDeDispositionRemplacement) -> r32
{
    retourne noeud.largeur_intrinsèque.Quelque
}

donne_hauteur_intrinsèque :: fonc (noeud: *NoeudDeDispositionRemplacement) -> r32
{
    retourne noeud.hauteur_intrinsèque.Quelque
}

noeud_disposition_remplacement_sur_mesure :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDeFormattage, mode: ModeDeFormattage @inutilisée)
{
    noeud := base comme *NoeudDeDispositionRemplacement

    noeud.sur_calcul_dimensions_intrinsèques(noeud, ctx)

    containing_block := donne_containing_block(noeud, ctx)

    modifie_marges_pour_alignement_forcé(ctx, noeud)

    calcule_largeur_et_marges(ctx, noeud, containing_block)
    calcule_hauteur_et_marges(noeud, containing_block)
}

noeud_disposition_remplacement_sur_divise_en_lignes :: fonc (base: *NoeudDeDisposition, enligneuse: *Enligneuse, ctx: *ContexteDeFormattage, mode: ModeDeFormattage)
{
    noeud_disposition_remplacement_sur_mesure(base, ctx, mode)

    noeud := base comme *NoeudDeDispositionRemplacement
    largeur := noeud.propriétés.donne_valeur_utilisée(IDPropriété.Width).pixels comme r32
    hauteur := noeud.propriétés.donne_valeur_utilisée(IDPropriété.Height).pixels comme r32

    _ := enligneuse.ajoute_fragment(noeud, 0, 0, hauteur, largeur)
}

noeud_disposition_remplacement_sur_dessin_tampon_id :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDessin)
{
    noeud := base comme *NoeudDeDispositionRemplacement
    ctx.remplis_rectangle_id(noeud)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NoeudDeDispositionRemplacement pour image
 * \{ */

#portée_fichier

crée_noeud_de_remplacement_image :: fonc (arbre: *ArbreDeDisposition, élément: *HTML.HTMLImageElement) -> *NoeudDeDispositionRemplacement
{
    résultat := arbre.crée_noeud(NoeudDeDispositionRemplacement)
    résultat.élément = élément
    résultat.sur_dessin = noeud_image_sur_dessin
    résultat.sur_dessin_fragment = noeud_image_sur_dessin_fragment
    résultat.sur_calcul_dimensions_intrinsèques = noeud_image_calcul_dimensions_intrinsèques
    retourne résultat
}

noeud_image_calcul_dimensions_intrinsèques :: fonc (noeud: *NoeudDeDispositionRemplacement, ctx: *ContexteDeFormattage @inutilisée)
{
    élément := noeud.élément comme *HTML.HTMLImageElement
    assert(élément.local_name == HTML.TAG_img)

    si élément.image_data.donnees {
        noeud.ratio_intrinsèque = HTML.donne_ratio_intrinsèque(élément)
        noeud.largeur_intrinsèque = HTML.donne_largeur_intrinsèque(élément) comme r32
        noeud.hauteur_intrinsèque = HTML.donne_hauteur_intrinsèque(élément) comme r32
    }
}

noeud_image_sur_dessin :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDessin)
{
    noeud := base comme *NoeudDeDispositionRemplacement
    assert(noeud.élément.local_name == HTML.TAG_img)
    image := noeud.élément comme *HTML.HTMLImageElement
    dessine_image(ctx, image.image_data, noeud.donne_rectangle_bordure())
}

noeud_image_sur_dessin_fragment :: fonc (base: *NoeudDeDisposition, fragment: *Fragment, lignes_tenante: *LignesTenante @inutilisée, ctx: *ContexteDessin)
{
    noeud := base comme *NoeudDeDispositionRemplacement
    assert(noeud.élément.local_name == HTML.TAG_img)
    image := noeud.élément comme *HTML.HTMLImageElement
    dessine_image(ctx, image.image_data, fragment.donne_rectangle())
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NoeudDeDispositionRemplacement pour input
 * \{ */

#portée_fichier

crée_noeud_de_remplacement_text_input :: fonc (arbre: *ArbreDeDisposition, élément: *HTML.HTMLInputElement) -> *NoeudDeDispositionRemplacement
{
    résultat := arbre.crée_noeud(NoeudDeDispositionRemplacement)
    résultat.élément = élément
    résultat.sur_dessin = noeud_text_input_sur_dessin
    résultat.sur_dessin_fragment = noeud_text_input_sur_dessin_fragment
    résultat.sur_calcul_dimensions_intrinsèques = noeud_text_input_dimensions_intrinsèques
    retourne résultat
}

noeud_text_input_dimensions_intrinsèques :: fonc (noeud: *NoeudDeDispositionRemplacement, ctx: *ContexteDeFormattage)
{
    assert(noeud.élément.local_name == HTML.TAG_input)

    noeud.fonte = détermine_fonte(noeud, ctx)
    métriques := noeud.fonte.donne_métriques_fonte()
    hauteur_ligne := métriques.donne_hauteur_ligne()

    line_height := donne_line_height(noeud, ctx)

    /* For input elements whose type attribute is in one of the above states, the used value of the 'line-height'
     * property must be a length value that is no smaller than what the used value would be for 'line-height: normal'. */
    si line_height < hauteur_ligne {
        noeud.propriétés.définis_valeur_utilisée(IDPropriété.LineHeight, ValeurDeStyle(pixels = hauteur_ligne))
        line_height = hauteur_ligne
    }

    noeud.largeur_intrinsèque = donne_inline_size_pour_text_input(noeud)
    noeud.hauteur_intrinsèque = line_height
}

/* https://html.spec.whatwg.org/multipage/rendering.html#the-input-element-as-a-text-entry-widget */
donne_inline_size_pour_text_input :: fonc (noeud: *NoeudDeDispositionRemplacement) -> r32
{
    métriques := noeud.fonte.donne_métriques_fonte()

    // À FAIRE : 1. If the 'field-sizing' property on the element has a computed value of 'content',
    // the inline size is determined by the text which the element shows. The text is either
    // a value or a short hint specified by the placeholder attribute. User agents may take
    // the text caret size into account in the inline size.

    // 2. If the element has a size attribute, and parsing that attribute's value using the
    // rules for parsing non-negative integers doesn't generate an error, return the value
    // obtained from applying the converting a character width to pixels algorithm to the value
    // of the attribute.
    size := HTML.donne_attribut_ou_chaine_vide(noeud.élément, HTML.ATTR_size)
    saufsi size.est_vide() {
        opt_value := HTML.parse_a_non_negative_integer(size)
        si opt_value.possède_valeur() {
            retourne convert_a_character_width_to_pixels(opt_value.Quelque comme r32, métriques)
        }
    }

    // 3. Otherwise, return the value obtained from applying the converting a character width to
    // pixels algorithm to the number 20.
    retourne convert_a_character_width_to_pixels(20.0, métriques)
}

/* https://html.spec.whatwg.org/multipage/rendering.html#converting-a-character-width-to-pixels */
convert_a_character_width_to_pixels :: fonc (size: r32, métriques: &MétriquesFonte) -> r32
{
    retourne (size - 1.0) * métriques.largeur_moyenne + métriques.largeur_maximale
}

noeud_text_input_sur_dessin :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDessin)
{
    noeud := base comme *NoeudDeDispositionRemplacement
    assert(noeud.élément.local_name == HTML.TAG_input)

    dessine_arrière_plan(ctx, noeud)

    /* À FAIRE : considère toutes les propriétés de bordure. */
    border_declaration := donne_déclaration(noeud.propriétés, PROP_border)
    si border_declaration {
        dessine_bordure(ctx, noeud)
    }
    sinon {
        /* Dessine une bordure par défaut. */
        rect := ctx.donne_rectangle_corrigé(noeud.donne_rectangle_bordure())
        couleur := CouleurRVBAN8(0, 0, 0, 255)
        ctx.peintre.dessine_rectangle(rect, couleur)
    }

    élément := noeud.élément comme *HTML.HTMLInputElement
    couleur := noeud.propriétés.donne_valeur_utilisée(IDPropriété.Color).couleur
    value := HTML.donne_attribut_ou_chaine_vide(élément, HTML.ATTR_value).donne_chaine_utf16()

    si value.est_vide() {
        value = HTML.donne_attribut_ou_chaine_vide(élément, HTML.ATTR_placeholder).donne_chaine_utf16()
        couleur.a = 128
    }

    saufsi value.est_vide() {
        métriques := donne_métriques_fonte(noeud.fonte)

        rect_texte := ctx.donne_rectangle_corrigé(noeud.donne_rectangle_contenu())
        rect_texte.y -= métriques.jambage_inférieur

        ctx.peintre.dessine_texte(noeud.fonte, value, rect_texte, couleur, nul)
    }
}

noeud_text_input_sur_dessin_fragment :: fonc (base: *NoeudDeDisposition, fragment: *Fragment, lignes_tenante: *LignesTenante @inutilisée, ctx: *ContexteDessin)
{
    /* XXX - ceci devrait sans doute être fait lors de la disposition. */
    x := fragment.x - base.modèle_de_boite.contenu.x
    y := fragment.y - base.modèle_de_boite.contenu.y

    décale_horizontalement(base.modèle_de_boite, x)
    décale_verticalement(base.modèle_de_boite, y)

    noeud_text_input_sur_dessin(base, ctx)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NoeudDeDispositionRemplacement pour textarea
 * \{ */

#portée_fichier

crée_noeud_de_remplacement_textarea :: fonc (arbre: *ArbreDeDisposition, élément: *HTML.HTMLTextAreaElement) -> *NoeudDeDispositionRemplacement
{
    résultat := arbre.crée_noeud(NoeudDeDispositionRemplacement)
    résultat.élément = élément
    résultat.sur_dessin = noeud_textarea_sur_dessin
    résultat.sur_dessin_fragment = noeud_textarea_sur_dessin_fragment
    résultat.sur_calcul_dimensions_intrinsèques = noeud_textarea_dimensions_intrinsèques
    retourne résultat
}

noeud_textarea_dimensions_intrinsèques :: fonc (noeud: *NoeudDeDispositionRemplacement, ctx: *ContexteDeFormattage)
{
    assert(noeud.élément.local_name == HTML.TAG_textarea)
    noeud.fonte = détermine_fonte(noeud, ctx)
    noeud.largeur_intrinsèque = donne_textarea_effective_width(noeud)
    noeud.hauteur_intrinsèque = donne_textarea_effective_height(noeud, ctx)
}

LARGEUR_BARRE_DE_DÉFILEMENT :: 16.0

/* https://html.spec.whatwg.org/multipage/rendering.html#textarea-effective-width */
donne_textarea_effective_width :: fonc (noeud: *NoeudDeDispositionRemplacement) -> r32
{
    élément := noeud.élément comme *HTML.HTMLTextAreaElement
    métriques := noeud.fonte.donne_métriques_fonte()
    character_width := HTML.donne_character_width(élément)
    retourne (character_width comme r32) * métriques.largeur_moyenne + LARGEUR_BARRE_DE_DÉFILEMENT
}

/* https://html.spec.whatwg.org/multipage/rendering.html#textarea-effective-height */
donne_textarea_effective_height :: fonc (noeud: *NoeudDeDispositionRemplacement, ctx: *ContexteDeFormattage) -> r32
{
    élément := noeud.élément comme *HTML.HTMLTextAreaElement
    character_height := HTML.donne_character_height(élément)
    line_height := donne_line_height(noeud, ctx)
    retourne character_height comme r32 * line_height
}

noeud_textarea_sur_dessin :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDessin)
{
    noeud := base comme *NoeudDeDispositionRemplacement
    assert(noeud.élément.local_name == HTML.TAG_textarea)

    dessine_arrière_plan(ctx, noeud)

    /* À FAIRE : considère toutes les propriétés de bordure. */
    border_declaration := donne_déclaration(noeud.propriétés, PROP_border)
    si border_declaration {
        dessine_bordure(ctx, noeud)
    }
    sinon {
        /* Dessine une bordure par défaut. */
        rect := ctx.donne_rectangle_corrigé(noeud.donne_rectangle_bordure())
        couleur := CouleurRVBAN8(0, 0, 0, 255)
        ctx.peintre.dessine_rectangle(rect, couleur)
    }

    élément := noeud.élément comme *HTML.HTMLTextAreaElement
    couleur := noeud.propriétés.donne_valeur_utilisée(IDPropriété.Color).couleur
    value := HTML.donne_attribut_ou_chaine_vide(élément, HTML.ATTR_value).donne_chaine_utf16()

    si value.est_vide() {
        value = HTML.donne_attribut_ou_chaine_vide(élément, HTML.ATTR_placeholder).donne_chaine_utf16()
        couleur.a = 128
    }

    saufsi value.est_vide() {
        métriques := donne_métriques_fonte(noeud.fonte)

        rect_texte := ctx.donne_rectangle_corrigé(noeud.donne_rectangle_contenu())
        rect_texte.y -= métriques.jambage_inférieur

        ctx.peintre.dessine_texte(noeud.fonte, value, rect_texte, couleur, nul)
    }
}

noeud_textarea_sur_dessin_fragment :: fonc (base: *NoeudDeDisposition, fragment: *Fragment, lignes_tenante: *LignesTenante @inutilisée, ctx: *ContexteDessin)
{
    /* XXX - ceci devrait sans doute être fait lors de la disposition. */
    x := fragment.x - base.modèle_de_boite.contenu.x
    y := fragment.y - base.modèle_de_boite.contenu.y

    décale_horizontalement(base.modèle_de_boite, x)
    décale_verticalement(base.modèle_de_boite, y)

    noeud_textarea_sur_dessin(base, ctx)
}

/** \} */
