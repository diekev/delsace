importe Chaine
importe Couleur
importe Fondation
importe Géométrie
importe #inemployé HTML
importe Math
importe PeintureInterface
importe Typographie

/* ------------------------------------------------------------------------- */
/** \nom Arbre de disposition
 * \{ */

ArbreDeDisposition :: struct {
    racine: *NoeudDeDisposition

    noeuds: [..]*NoeudDeDisposition
}

détruit_arbre :: fonc (arbre: *ArbreDeDisposition)
{
    saufsi arbre {
        retourne
    }

    pour arbre.noeuds {
        déloge(it.enfants)

        si it.type == NoeudDeDispositionBloc {
            bloc := it comme *NoeudDeDispositionBloc
            pour *boite dans bloc.lignes {
                détruit_données_boite_de_ligne(boite)
            }
            déloge(bloc.lignes)
            déloge(bloc)
        }
        sinon si it.type == NoeudDeDispositionInline {
            noeud := it comme *NoeudDeDispositionInline
            pour *boite dans noeud.lignes {
                détruit_données_boite_de_ligne(boite)
            }
            déloge(noeud.lignes)
            déloge(noeud)
        }
        sinon si it.type == NoeudDeDispositionTexte {
            texte := it comme *NoeudDeDispositionTexte
            détruit_chaine(texte.texte)
            déloge(texte)
        }
        sinon si it.type == NoeudDeDispositionNouvelleLigne {
            bris := it comme *NoeudDeDispositionNouvelleLigne
            déloge(bris)
        }
        sinon {
            imprime("noeud inconnu !")
            déloge(it)
        }
    }

    déloge(arbre.noeuds)
    déloge(arbre)
}

crée_noeud :: fonc (arbre: *ArbreDeDisposition, $TypeNoeud: type_de_données) -> *TypeNoeud
{
    résultat := loge(TypeNoeud)
    tableau_ajoute(*arbre.noeuds, résultat)
    retourne résultat
}

donne_élément_pour_position :: fonc (arbre: *ArbreDeDisposition, x: z32, y: z32) -> *HTML.Élément
{
    noeud := donne_noeud_pour_position(arbre.racine, x, y)
    saufsi noeud {
        retourne nul
    }
    retourne noeud.donne_élément()
}

imprime_arbre :: fonc (arbre: *ArbreDeDisposition)
{
    saufsi arbre.racine {
        retourne
    }

    enchaineuse: Enchaineuse
    initialise_enchaineuse(*enchaineuse)
    diffère détruit_tampons(*enchaineuse)

    imprime_arbre(*enchaineuse, arbre.racine, 0)

    résultat := chaine_depuis_enchaineuse(*enchaineuse)
    diffère déloge(résultat)

    imprime("%\n", résultat)
}

imprime_arbre :: fonc (enchaineuse: *Enchaineuse, racine: *NoeudDeDisposition, profondeur: n32)
{
    indentation := donne_chaine_indentation(profondeur comme z32)

    imprime_dans_enchaineuse(enchaineuse, "%%", indentation, racine.donne_nom_classe())
    si racine.type == NoeudDeDispositionBloc {
        bloc := racine comme *NoeudDeDispositionBloc
        imprime_dans_enchaineuse(enchaineuse, " %", bloc.élément.texte)
    }

    imprime_dans_enchaineuse(enchaineuse, " % % %x%\n", racine.position_x, racine.position_y, racine.largeur, racine.hauteur)

    pour racine.enfants {
        imprime_arbre(enchaineuse, it, profondeur + 1)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Génération d'arbres de disposition.
 * \{ */

crée_arbre_de_disposition :: fonc (document: *HTML.Document, largeur: z32)
{
    html := HTML.donne_élément_html(document)
    saufsi html {
        retourne
    }

    saufsi document.globales_dessin {
        document.globales_dessin = crée_globales_dessin()
    }

    résultat := loge(ArbreDeDisposition)

    feuille_de_style := document.feuilles_de_style[0]

    racine := résultat.crée_noeud(NoeudDeDispositionBloc)
    racine.élément = html
    html.noeud_de_disposition = racine

    résultat.racine = racine

    pour html.enfants {
        crée_noeud_pour_élément(feuille_de_style, résultat, résultat.racine, it)
    }

    imprime("Créé % noeud(s)\n", résultat.noeuds.taille)

    ctx: ContexteDisposition
    ctx.largeur_disponible = largeur comme n32
    ctx.globales = document.globales_dessin

    mesure(racine, *ctx)

    imprime("taille arbre : %x%\n", résultat.racine.largeur, résultat.racine.hauteur)

    // imprime_arbre(résultat)

    si document.arbre_de_disposition {
        détruit_arbre(document.arbre_de_disposition)
    }

    document.arbre_de_disposition = résultat
}

crée_noeud_pour_élément :: fonc (stylesheet: *CSSStyleSheet, arbre: *ArbreDeDisposition, parent: *NoeudDeDisposition, noeud: *HTML.Noeud)
{
    si HTML.est_texte(noeud) {
        résultat := arbre.crée_noeud(NoeudDeDispositionTexte)
        résultat.noeud_texte = noeud comme *HTML.NoeudTexte
        parent.ajoute_enfant(résultat)
        retourne
    }

    saufsi HTML.est_élément(noeud) {
        retourne
    }

    élément := noeud comme *HTML.Élément

    règles := collecte_les_règles_appropriées(stylesheet, élément)
    diffère déloge(règles)

    imprime("% règle(s) pour %\n", règles.taille, élément.texte)

    propriétés: PropriétésDeStyle

    pour règles {
        imprime_règle(it)
        pour déclaration dans it.déclarations {
            ajoute_déclaration(*propriétés, déclaration)
        }
    }

    display := donne_display(*propriétés)

    si display.outer_type == Display.Type.None {
        détruit_données_propriétés(*propriétés)
        retourne
    }

    résultat: *NoeudDeDisposition
    si display.outer_type == Display.Type.Block {
        bloc := arbre.crée_noeud(NoeudDeDispositionBloc)
        bloc.élément = élément
        résultat = bloc
    }
    sinon si élément.texte == HTML.TAG_br {
        bris := arbre.crée_noeud(NoeudDeDispositionNouvelleLigne)
        résultat = bris
    }
    sinon {
        inline := arbre.crée_noeud(NoeudDeDispositionInline)
        inline.élément = élément
        résultat = inline
    }

    élément.noeud_de_disposition = résultat
    résultat.propriétés = propriétés
    parent.ajoute_enfant(résultat)

    pour noeud.enfants {
        crée_noeud_pour_élément(stylesheet, arbre, résultat, it)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ContexteDisposition
 * \{ */

ContexteDisposition :: struct {
    globales: *GlobalesDessin
    largeur_disponible: n32
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ContexteDessin
 * \{ */

ContexteDessin :: struct {
    globales: *GlobalesDessin
    peintre: *Peintre
    fragment: *Fragment

    hauteur_vue: z32
    décalage_y: r32
}

donne_rectangle_corrigé :: fonc (ctx: *ContexteDessin, noeud: *NoeudDeDisposition) -> RectanglePosDim(z32)
{
    rect: RectanglePosDim(z32)
    rect.x = noeud.position_x comme z32
    /* Nous disposons les noeuds comme si leur origine était leur coin du haut
     * gauche mais nous devons les dessiner comme si leur origine était leur
     * coin du bas gauche.
     * De plus, nous devons nous assurer que l'origine du document est le bas
     * gauche de la page et non le haut gauche. */
    rect.y = ctx.hauteur_vue - noeud.position_y comme z32 - noeud.hauteur comme z32 + ctx.décalage_y comme z32
    rect.largeur = noeud.largeur comme z32
    rect.hauteur = noeud.hauteur comme z32
    retourne rect
}

donne_rectangle_corrigé :: fonc (ctx: *ContexteDessin, rect: RectanglePosDim(r32)) -> RectanglePosDim(r32)
{
    /* Nous disposons les noeuds comme si leur origine était leur coin du haut
     * gauche mais nous devons les dessiner comme si leur origine était leur
     * coin du bas gauche.
     * De plus, nous devons nous assurer que l'origine du document est le bas
     * gauche de la page et non le haut gauche. */
    rect.y = ctx.hauteur_vue comme r32 + ctx.décalage_y - rect.y - rect.hauteur
    retourne rect
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NoeudDeDisposition
 * \{ */

NoeudDeDisposition :: struct {
    type := #type_de_cette_structure

    propriétés: PropriétésDeStyle

    parent: *NoeudDeDisposition
    enfants: [..]*NoeudDeDisposition

    position_x: n32
    position_y: n32

    largeur: n32
    hauteur: n32

    sur_mesure: fonc (*NoeudDeDisposition, *ContexteDisposition)(rien)
    sur_dessin: fonc (*NoeudDeDisposition, *ContexteDessin)(rien)
    sur_divise_en_lignes: fonc (*NoeudDeDisposition, *NoeudDeDispositionBloc, *ContexteDisposition)(rien)
}

donne_rectangle :: fonc (noeud: *NoeudDeDisposition) -> RectanglePosDim(z32)
{
    rect: RectanglePosDim(z32)
    rect.x = noeud.position_x comme z32
    rect.y = noeud.position_y comme z32
    rect.largeur = noeud.largeur comme z32
    rect.hauteur = noeud.hauteur comme z32
    retourne rect
}

donne_élément :: fonc (noeud: *NoeudDeDisposition) -> *HTML.Élément
{
    noeud_courant := noeud

    tantque noeud_courant != nul && (noeud_courant.type != NoeudDeDispositionBloc && noeud_courant.type != NoeudDeDispositionInline) {
        noeud_courant = noeud_courant.parent
    }

    si noeud_courant {
        si noeud_courant.type == NoeudDeDispositionInline {
            retourne (noeud_courant comme *NoeudDeDispositionBloc).élément
        }
        retourne (noeud_courant comme *NoeudDeDispositionBloc).élément
    }

    retourne nul
}

décale :: fonc (noeud: *NoeudDeDisposition, x: n32, y: n32)
{
    noeud.position_x += x
    noeud.position_y += y

    pour noeud.enfants {
        it.décale(x, y)
    }

    si noeud.type == NoeudDeDispositionBloc || noeud.type == NoeudDeDispositionInline {
        bloc := noeud comme *NoeudDeDispositionBloc
        pour bloc.lignes {
            pour * fragment dans it.fragments {
                fragment.x += x comme r32
                fragment.y += y comme r32
            }
        }
    }
}

donne_nom_classe :: fonc (noeud: *NoeudDeDisposition) -> chaine
{
    infos := __table_des_types[noeud.type] comme *InfoTypeStructure
    retourne infos.nom
}

mesure :: fonc (noeud: *NoeudDeDisposition, ctx: *ContexteDisposition)
{
    si noeud.sur_mesure {
        noeud.sur_mesure(noeud, ctx)
    }
}

dessine :: fonc (noeud: *NoeudDeDisposition, ctx: *ContexteDessin)
{
    si noeud.sur_dessin {
        noeud.sur_dessin(noeud, ctx)
    }
}

ajoute_enfant :: fonc (parent: *NoeudDeDisposition, enfant: *NoeudDeDisposition)
{
    enfant.parent = parent
    tableau_ajoute(*parent.enfants, enfant)
}

donne_noeud_pour_position :: fonc (noeud: *NoeudDeDisposition, x: z32, y: z32) -> *NoeudDeDisposition
{
    rect := noeud.donne_rectangle()
    saufsi rect.contient(x, y) {
        retourne nul
    }

    pour noeud.enfants {
        résultat := donne_noeud_pour_position(it, x, y)
        si résultat {
            retourne résultat
        }
    }

    retourne noeud
}

donne_curseur :: fonc (noeud: *NoeudDeDisposition) -> CursorType
{
    cursor := donne_déclaration(*noeud.propriétés, PROP_cursor)
    saufsi cursor {
        retourne CursorType.auto
    }

    retourne donne_type_cursor(cursor.value[0].mot_clé)
}

divise_en_lignes :: fonc (noeud: *NoeudDeDisposition, bloc_contenant: *NoeudDeDispositionBloc, ctx: *ContexteDisposition)
{
    si noeud.sur_divise_en_lignes {
        noeud.sur_divise_en_lignes(noeud, bloc_contenant, ctx)
        retourne
    }

    pour noeud.enfants {
        divise_en_lignes(it, bloc_contenant, ctx)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom BoiteDeLigne
 * Boite pour tenir les fragments de chaque ligne pour les dispositions
 * « inline ».
 * https://www.w3.org/TR/2011/REC-CSS2-20110607/visuren.html#line-box
 * \{ */

Fragment :: struct {
    noeud: *NoeudDeDisposition
    index_début: z64
    index_fin: z64

    x: r32
    y: r32
    hauteur: r32
    largeur: r32
}

BoiteDeLigne :: struct {
    bloc: *NoeudDeDispositionBloc

    fragments: [..]Fragment
    largeur_courante: r32
}

détruit_données_boite_de_ligne :: fonc (boite: *BoiteDeLigne)
{
    déloge(boite.fragments)
}

peut_ajouter_fragment :: fonc (boite: *BoiteDeLigne, largeur: r32) -> bool
{
    retourne (boite.largeur_courante + largeur) < (boite.bloc.largeur comme r32)
}

ajoute_fragment :: fonc (boite: *BoiteDeLigne, noeud: *NoeudDeDisposition, index_début: z64, index_fin: z64, hauteur: r32, largeur: r32)
{
    fragment: Fragment
    fragment.noeud = noeud
    fragment.index_début = index_début
    fragment.index_fin = index_fin
    fragment.hauteur = hauteur
    fragment.largeur = largeur
    fragment.x = boite.largeur_courante

    boite.largeur_courante += largeur

    tableau_ajoute(*boite.fragments, fragment)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NoeudDeDispositionBloc
 * \{ */

/* Créé pour chaque noeud hors texte */
NoeudDeDispositionBloc :: struct {
    empl base: NoeudDeDisposition
    type = #type_de_cette_structure
    sur_mesure = noeud_disposition_bloc_sur_mesure
    sur_dessin = noeud_disposition_bloc_sur_dessin

    élément: *HTML.Élément

    lignes: [..]BoiteDeLigne

    est_disposition_inline: bool
}

noeud_disposition_bloc_sur_mesure :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDisposition)
{
    noeud := base comme *NoeudDeDispositionBloc
    noeud.largeur = ctx.largeur_disponible

    /* À FAIRE : génère des noeuds anonymes, etc. */
    doit_formatter_en_blocs := faux

    pour noeud.enfants {
        si it.type == NoeudDeDispositionBloc {
            doit_formatter_en_blocs = vrai
            arrête
        }
    }

    noeud.est_disposition_inline = doit_formatter_en_blocs == faux

    si doit_formatter_en_blocs {
        dispose_enfants_block(noeud, ctx)
    }
    sinon {
        dispose_enfants_inline(noeud, ctx)
    }
}

noeud_disposition_bloc_sur_dessin :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDessin)
{
    noeud := base comme *NoeudDeDispositionBloc

    // rect := ctx.donne_rectangle_corrigé(noeud)
    // couleur := CouleurRVBA(1.0, 0.5, 0.5, 1.0)
    // peintre := ctx.peintre
    // peintre.remplis_rectangle(rect, couleur)

    saufsi noeud.est_disposition_inline {
        dessine_enfants_block(noeud, ctx)
    }
    sinon {
        dessine_enfants_inline(noeud, ctx)
    }
}

ajoute_ligne :: fonc (bloc: *NoeudDeDispositionBloc) -> *BoiteDeLigne
{
    ligne := tableau_ajoute_élément(*bloc.lignes)
    ligne.bloc = bloc
    retourne ligne
}

donne_ligne_courante :: fonc (bloc: *NoeudDeDispositionBloc) -> *BoiteDeLigne
{
    si bloc.lignes.taille == 0 {
        retourne ajoute_ligne(bloc)
    }

    retourne *bloc.lignes[bloc.lignes.taille - 1]
}

dispose_enfants_block :: fonc (noeud: *NoeudDeDispositionBloc, ctx: *ContexteDisposition)
{
    ctx_locale := mémoire(ctx)
    ctx_locale.largeur_disponible = ctx.largeur_disponible

    pour noeud.enfants {
        it.mesure(*ctx_locale)

        it.décale(0, noeud.hauteur)

        noeud.hauteur += it.hauteur
        noeud.largeur = max(noeud.largeur, it.largeur)
    }
}

dessine_enfants_block :: fonc (noeud: *NoeudDeDispositionBloc, ctx: *ContexteDessin)
{
    // rect := ctx.donne_rectangle_corrigé(noeud)

    // couleur := CouleurRVBA(0.5, 0.0, 0.5, 1.0)

    // peintre := ctx.peintre
    // peintre.dessine_rectangle(rect, couleur)

    pour noeud.enfants {
        dessine(it, ctx)
    }
}

dispose_enfants_inline :: fonc (noeud: *NoeudDeDispositionBloc, ctx: *ContexteDisposition)
{
    ctx_locale := mémoire(ctx)
    ctx_locale.largeur_disponible = ctx.largeur_disponible

    pour noeud.enfants {
        divise_en_lignes(it, noeud, *ctx_locale)
    }

    pour noeud.lignes {
        hauteur := 0.0
        pour * fragment dans it.fragments {
            hauteur = max(fragment.hauteur, hauteur)
            fragment.y = noeud.hauteur comme r32
        }
        noeud.hauteur += hauteur comme n32
    }

    // pour noeud.enfants {
    //     it.mesure(ctx)

    //     it.décale(noeud.largeur, 0)

    //     noeud.largeur += it.largeur
    //     noeud.hauteur = max(noeud.hauteur, it.hauteur)
    // }
}

dessine_enfants_inline :: fonc (noeud: *NoeudDeDispositionBloc, ctx: *ContexteDessin)
{
    ctx_locale := mémoire(ctx)
    pour noeud.lignes {
        pour * fragment dans it.fragments {
            ctx_locale.fragment = fragment
            dessine(fragment.noeud, *ctx_locale)
        }
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NoeudDeDispositionInline
 * \{ */

/* Créé pour chaque noeud hors texte */
NoeudDeDispositionInline :: struct {
    empl base_bloc: NoeudDeDispositionBloc
    type = #type_de_cette_structure
    sur_mesure = noeud_disposition_inline_sur_mesure
    sur_dessin = noeud_disposition_inline_sur_dessin
}

noeud_disposition_inline_sur_mesure :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDisposition)
{
    noeud := base comme *NoeudDeDispositionInline
    noeud.largeur = ctx.largeur_disponible
    dispose_enfants_inline(noeud, ctx)
}

noeud_disposition_inline_sur_dessin :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDessin)
{
    noeud := base comme *NoeudDeDispositionInline
    dessine_enfants_inline(noeud, ctx)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NoeudDeDispositionNouvelleLigne
 * \{ */

/* Créé pour chaque noeud hors texte */
NoeudDeDispositionNouvelleLigne :: struct {
    empl base_bloc: NoeudDeDisposition
    type = #type_de_cette_structure
    sur_mesure = noeud_disposition_nouvelle_ligne_sur_mesure
    sur_divise_en_lignes = noeud_disposition_nouvelle_ligne_sur_divise_en_lignes
}

noeud_disposition_nouvelle_ligne_sur_mesure :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDisposition)
{
    noeud := base comme *NoeudDeDispositionInline
    noeud.largeur = ctx.largeur_disponible
    dispose_enfants_inline(noeud, ctx)
}

noeud_disposition_nouvelle_ligne_sur_divise_en_lignes :: fonc (base: *NoeudDeDisposition @inutilisée, bloc_contenant: *NoeudDeDispositionBloc, ctx: *ContexteDisposition)
{
    _ := bloc_contenant.ajoute_ligne()
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NoeudDeDispositionTexte
 * \{ */

/* Créé pour chaque élément contenant du texte. */
NoeudDeDispositionTexte :: struct {
    empl base: NoeudDeDisposition
    type = #type_de_cette_structure
    sur_mesure = noeud_disposition_texte_sur_mesure
    sur_dessin = noeud_disposition_texte_sur_dessin
    sur_divise_en_lignes = noeud_disposition_texte_sur_divise_en_lignes

    noeud_texte: *HTML.NoeudTexte
    texte: ChaineUTF16
    fonte: *Fonte

    morceaux: [..]ChaineUTF16
}

détermine_fonte :: fonc (noeud_texte: *NoeudDeDispositionTexte, ctx: *ContexteDisposition) -> *Fonte
{
    globales := ctx.globales
    assert(globales != nul)
    famille_fonte := "sérif"
    style := "normal"
    graisse := GraisseFonte.Normal
    taille_fonte := globales.taille_fonte_défaut

    propriétés := *noeud_texte.parent.propriétés
    font_weight := donne_déclaration(propriétés, PROP_font_weight)
    si font_weight {
        mot_clé := font_weight.value[0].mot_clé

        si mot_clé == PROP_bold {
            graisse = GraisseFonte.Gras
        }
    }

    font_size := donne_déclaration(propriétés, PROP_font_size)
    si font_size {
        longueur := font_size.value[0].longueur

        discr longueur.unité {
            Em {
                taille_fonte *= longueur.valeur comme r32
            }
        }
    }

    fonte := globales.donne_fonte(famille_fonte, style, graisse, taille_fonte)
    noeud_texte.fonte = fonte
    retourne fonte
}

noeud_disposition_texte_sur_mesure :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDisposition)
{
    noeud := base comme *NoeudDeDispositionTexte

    si est_vide_ou_uniquement_espaces_blanches(noeud.noeud_texte.données) {
        noeud.hauteur = 0
        noeud.largeur = 0
        noeud.sur_dessin = nul
        retourne
    }

    fonte := détermine_fonte(noeud, ctx)
    métriques := fonte.donne_métriques_fonte()

    /* À FAIRE : meilleur algorithme, respect du standard. */
    morceaux := divise_sur_espaces_blanches_ascii(noeud.noeud_texte.données)
    diffère déloge(morceaux)

    enchaineuse: EnchaineuseUTF16
    initialise_enchaineuse(enchaineuse)
    diffère détruit_tampons(enchaineuse)

    virgule := ChaineUTF16Unique(0x20).donne_chaine_utf16()
    pour morceaux {
        si index_it > 0 {
            ajoute(enchaineuse, virgule)
        }
        ajoute(enchaineuse, it)
    }

    texte := chaine_depuis_enchaineuse(enchaineuse)
    noeud.texte = texte

    noeud.hauteur = (métriques.donne_hauteur_ligne() + 0.5) comme n32
    noeud.largeur = fonte.donne_largeur_texte(texte) comme n32
}

noeud_disposition_texte_sur_divise_en_lignes :: fonc (base: *NoeudDeDisposition, bloc_contenant: *NoeudDeDispositionBloc, ctx: *ContexteDisposition)
{
    noeud := base comme *NoeudDeDispositionTexte

    si est_vide_ou_uniquement_espaces_blanches(noeud.noeud_texte.données) {
        noeud.hauteur = 0
        noeud.largeur = 0
        noeud.sur_dessin = nul
        retourne
    }

    fonte := détermine_fonte(noeud, ctx)
    métriques := fonte.donne_métriques_fonte()

    noeud.hauteur = (métriques.donne_hauteur_ligne() + 0.5) comme n32

    /* À FAIRE : meilleur algorithme, respect du standard. */
    morceaux := divise_sur_espaces_blanches_ascii(noeud.noeud_texte.données)

    espace := ChaineUTF16Unique(' ' comme n32)
    index_espace := morceaux.taille
    largeur_espace := fonte.donne_largeur_texte(espace.donne_chaine_utf16())

    tableau_ajoute(*morceaux, espace.donne_chaine_utf16())

    ligne_courante := bloc_contenant.donne_ligne_courante()
    noeud.morceaux = morceaux

    hauteur_texte := métriques.donne_hauteur_ligne()

    pour morceaux {
        largeur_morceau := fonte.donne_largeur_texte(it)

        saufsi ligne_courante.peut_ajouter_fragment(largeur_morceau comme r32) {
            ligne_courante = bloc_contenant.ajoute_ligne()
        }

        ligne_courante.ajoute_fragment(noeud, index_it, index_it + 1, hauteur_texte, largeur_morceau comme r32)

        si index_it < index_espace - 1 {
            si ligne_courante.peut_ajouter_fragment(largeur_espace comme r32) {
                ligne_courante.ajoute_fragment(noeud, index_espace, index_espace + 1, hauteur_texte, largeur_espace comme r32)
            }
        }
    }
}

noeud_disposition_texte_sur_dessin :: fonc (base: *NoeudDeDisposition, ctx: *ContexteDessin)
{
    noeud := base comme *NoeudDeDispositionTexte

    propriétés := *noeud.parent.propriétés

    couleur := CouleurRVBAN8(0, 0, 0, 255)

    color := donne_déclaration(propriétés, PROP_color)
    si color {
        couleur = color.value[0]
    }

    effets: EffetsTexte

    text_decoration := donne_déclaration(propriétés, PROP_text_decoration)
    si text_decoration {
        pour text_decoration.value {
            si it.est_mot_clé(PROP_underline) {
                effets.souslignage = vrai
                effets.couleur_souslignage = vers_couleur_rvba(couleur)
            }
            sinon si it.est_mot_clé(PROP_overline) {
                effets.surlignage = vrai
                effets.couleur_surlignage = vers_couleur_rvba(couleur)
            }
            sinon si it.est_mot_clé(PROP_line_through) {
                effets.barrage = vrai
                effets.couleur_barrage = vers_couleur_rvba(couleur)
            }
        }
    }

    peintre := ctx.peintre
    fonte := noeud.fonte
    assert(fonte != nul)

    si ctx.fragment {
        fragment := ctx.fragment

        rect: RectanglePosDim(r32)
        rect.x = fragment.x
        rect.y = fragment.y
        rect.largeur = fragment.largeur
        rect.hauteur = fragment.hauteur

        rect = ctx.donne_rectangle_corrigé(rect)

        // peintre.dessine_rectangle(rect, couleur)

        texte := noeud.morceaux[fragment.index_début]

        peintre.dessine_texte(fonte, texte, rect, couleur, *effets)
    }
    sinon {
        texte := noeud.texte
        rect := ctx.donne_rectangle_corrigé(noeud)
        peintre.dessine_texte(fonte, texte, rect, couleur, *effets)
    }
}

/** \} */
