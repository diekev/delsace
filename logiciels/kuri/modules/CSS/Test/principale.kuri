importe Chaine
importe CSS
importe Ensemble
importe Fondation
HTML :: importe HTML
importe SysFichier

principale :: fonc ()
{
    // test_collection_règles()
    // test_fragmentation_texte()
    test_parsage_propriété()
}

test_parsage_propriété :: fonc ()
{
    entrée := "background: url(\"chess.png\") 40% / 10em gray round fixed border-box;"
    sortie := "background-position: 40% 50%;
               background-color: gray;
               background-size: 10em auto;
               background-clip: border-box;
               background-origin: border-box;
               background-attachment: fixed;
               background-image: url(chess.png);
               background-repeat: round;"

    style_entrée := parse_css_style_declaration(entrée)
    style_sortie := parse_css_style_declaration(sortie)

    saufsi sont_équivalents(style_entrée, style_sortie) {
        imprimeln("Les styles ne sont pas équivalents")
    }
}

sont_équivalents :: fonc (style1: *CSSStyleDeclaration, style2: *CSSStyleDeclaration) -> bool
{
    si style1.déclarations.taille != style2.déclarations.taille {
        retourne faux
    }

    pour décl1 dans style1.déclarations {
        décl2 := donne_déclaration(style2, décl1.property_name)
        si décl2 == nul {
            retourne faux
        }

        saufsi sont_équivalents(décl1, décl2) {
            imprime_déclaration(décl1)
            imprime_déclaration(décl2)
            retourne faux
        }
    }

    retourne vrai
}

sont_équivalents :: fonc (décl1: *DéclarationPropriété, décl2: *DéclarationPropriété) -> bool
{
    si décl1.est_personnalisée || décl2.est_personnalisée {
        // À FAIRE
        retourne faux
    }

    si décl1.value.taille != décl2.value.taille {
        retourne faux
    }

    pour valeur1, index dans décl1.value {
        saufsi sont_mêmes_valeurs(valeur1, décl2.value[index]) {
            retourne faux
        }
    }

    retourne vrai
}

parse_css_style_declaration :: fonc (texte: chaine) -> *CSSStyleDeclaration
{
    lexèmes := lèxe_style(texte)
    diffère détruit_lexèmes(*lexèmes)

    components := parse_a_list_of_component_values(lexèmes)
    diffère déloge(components)

    parseuse_decl := initialise_une_parseuse(components)

    content := consomme_une_liste_de_déclarations(parseuse_decl)
    si content.decls.taille == 0 {
        imprimeln("Impossible de préparser la déclaration : %", texte)
        exit(1)
    }

    ctx: ContexteParsageFeuilleDeStyle
    diffère détruit_données_contexte(*ctx)

    retourne parse_css_style_declaration(*ctx, content.decls)
}

test_collection_règles :: fonc ()
{
    stylesheet := HTML.donne_feuille_de_style_défaut()

    élément := crée_chaine_utf16("p")

    propriétés: PropriétésDeStyle

    règles := collecte_les_règles_appropriées(stylesheet, élément)

    imprime("% règle(s) pour %\n", règles.taille, élément)
    // pour règles {
    //     imprime_règle(it)
    // }

    pour règles {
        pour déclaration dans it.déclarations {
            ajoute_déclaration(*propriétés, déclaration)
        }
    }

    imprime("% déclaration(s)\n", propriétés.déclarations.taille)
}

test_fragmentation_texte :: fonc ()
{
    // texte := "début   test  \t   test   \t   \n  \n   \n \t   test \t  fin"
    texte := "The     \n Effects of CRTs"
    texte_utf16 := crée_chaine_utf16(texte)

    fragments: [..]FragmentTexte
    fragmente_texte_avec_espaces_blanches_ascii(texte_utf16, *fragments)
    imprime_fragments(fragments, "fragmente_texte_avec_espaces_blanches_ascii")

    collapse_séquences_d_espaces_blanches_autour_bris_segments(fragments)
    imprime_fragments(fragments, "collapse_séquences_d_espaces_blanches_autour_bris_segments")

    collapse_bris_segments(fragments, PROP_normal)
    imprime_fragments(fragments, "collapse_bris_segments")

    convertis_tabulations_en_espaces(fragments)
    imprime_fragments(fragments, "convertis_tabulations_en_espaces")

    collapse_espaces_consécutives(fragments)
    imprime_fragments(fragments, "collapse_espaces_consécutives")
}

imprime_fragments :: fonc (fragments: []FragmentTexte, message: chaine)
{
    imprime("%\n", message)
    pour fragments {
        si it.ignore_mais_préserve_soft_wrap_opportunity {
            continue
        }

        si it.est_espace_blanche && it.texte.unités[0] == 0x0A {
            imprime("'\\n'\n")
            continue
        }
        si it.est_espace_blanche && it.texte.unités[0] == '\t' comme n32 {
            imprime("'\\t'\n")
            continue
        }
        
        imprime("'%'\n", it.texte)
    }
}
