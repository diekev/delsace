importe Math

/* Calculs des largeurs, hauteurs, et marges des noeuds. */

ajourne_boite_pour_calcul_largeur :: fonc (noeud: *NoeudDeDisposition)
{
    propriétés := noeud.propriétés

    margin_left := propriétés.donne_valeur_utilisée(IDPropriété.MarginLeft).pixels comme r32
    border_left_width := propriétés.donne_valeur_utilisée(IDPropriété.BorderWidthLeft).pixels comme r32
    padding_left := propriétés.donne_valeur_utilisée(IDPropriété.PaddingLeft).pixels comme r32
    width := propriétés.donne_valeur_utilisée(IDPropriété.Width).pixels comme r32
    padding_right := propriétés.donne_valeur_utilisée(IDPropriété.PaddingRight).pixels comme r32
    border_right_width := propriétés.donne_valeur_utilisée(IDPropriété.BorderWidthRight).pixels comme r32
    margin_right := propriétés.donne_valeur_utilisée(IDPropriété.MarginRight).pixels comme r32

    noeud.modèle_de_boite.marge.x = 0.0
    noeud.modèle_de_boite.marge.largeur = margin_left + border_left_width + padding_left + width + padding_right + border_right_width + margin_right

    noeud.modèle_de_boite.bordure.x = margin_left
    noeud.modèle_de_boite.bordure.largeur = border_left_width + padding_left + width + padding_right + border_right_width

    noeud.modèle_de_boite.rembourrage.x = margin_left + border_left_width
    noeud.modèle_de_boite.rembourrage.largeur =  padding_left + width + padding_right

    noeud.modèle_de_boite.contenu.x = margin_left + border_left_width + padding_left
    noeud.modèle_de_boite.contenu.largeur = width
}

ajourne_boite_pour_calcul_hauteur :: fonc (noeud: *NoeudDeDisposition)
{
    propriétés := noeud.propriétés

    margin_top := propriétés.donne_valeur_utilisée(IDPropriété.MarginTop).pixels comme r32
    border_top_height := propriétés.donne_valeur_utilisée(IDPropriété.BorderWidthTop).pixels comme r32
    padding_top := propriétés.donne_valeur_utilisée(IDPropriété.PaddingTop).pixels comme r32
    height := propriétés.donne_valeur_utilisée(IDPropriété.Height).pixels comme r32
    padding_bottom := propriétés.donne_valeur_utilisée(IDPropriété.PaddingBottom).pixels comme r32
    border_bottom_height := propriétés.donne_valeur_utilisée(IDPropriété.BorderWidthBottom).pixels comme r32
    margin_bottom := propriétés.donne_valeur_utilisée(IDPropriété.MarginBottom).pixels comme r32

    noeud.modèle_de_boite.marge.y = 0.0
    noeud.modèle_de_boite.marge.hauteur = margin_top + border_top_height + padding_top + height + padding_bottom + border_bottom_height + margin_bottom

    noeud.modèle_de_boite.bordure.y = margin_top
    noeud.modèle_de_boite.bordure.hauteur = border_top_height + padding_top + height + padding_bottom + border_bottom_height

    noeud.modèle_de_boite.rembourrage.y = margin_top + border_top_height
    noeud.modèle_de_boite.rembourrage.hauteur =  padding_top + height + padding_bottom

    noeud.modèle_de_boite.contenu.y = margin_top + border_top_height + padding_top
    noeud.modèle_de_boite.contenu.hauteur = height
}

calcule_largeur_et_marges :: fonc (ctx: *ContexteDeFormattage, noeud: *NoeudDeDisposition, containing_block: &ContainingBlock)
{
    résoud_pourcentage_largeurs(noeud, containing_block)
    width_of_containing_block := containing_block.donne_largeur()

    fonction_de_calcul := donne_fonction_calcul_largeur_et_marges(noeud)

    fonction_de_calcul(ctx, noeud, width_of_containing_block, nul)

    width := noeud.propriétés.donne_valeur_utilisée(IDPropriété.Width)

    max_width := noeud.propriétés.donne_valeur_calculée(IDPropriété.MaxWidth)
    si max_width.est_pixels() && (width.pixels > max_width.pixels) {
        fonction_de_calcul(ctx, noeud, width_of_containing_block, *max_width)
    }

    width = noeud.propriétés.donne_valeur_utilisée(IDPropriété.Width)
    min_width := noeud.propriétés.donne_valeur_calculée(IDPropriété.MinWidth)
    si min_width.est_pixels() && min_width.pixels > 0.0 && (width.pixels < min_width.pixels) {
        fonction_de_calcul(ctx, noeud, width_of_containing_block, *min_width)
    }

    ajourne_boite_pour_calcul_largeur(noeud)
    résoud_pourcentage_largeur_border_radius(noeud)
}

donne_fonction_calcul_largeur_et_marges :: fonc (noeud: *NoeudDeDisposition) -> fonc(*ContexteDeFormattage, *NoeudDeDisposition,r64,*ValeurDeStyle)(rien)
{
    propriétés := noeud.propriétés
    display := propriétés.donne_valeur_calculée(IDPropriété.Display).display
    float := propriétés.donne_valeur_utilisée(IDPropriété.Float)
    position := propriétés.donne_valeur_utilisée(IDPropriété.Position)

    si noeud.type == NoeudDeDispositionRemplacement {
        // 10.3.2 Inline, replaced elements
        // 10.3.10 'Inline-block', replaced elements in normal flow
        si display.outer_type == Display.Type.Inline {
            retourne calcule_largeur_et_marges_inline_replaced_element
        }

        // 10.3.6 Floating, replaced elements
        saufsi float.est_none() {
            retourne calcule_largeur_et_marges_float_replaced_element
        }

        // 10.3.8 Absolutely positioned, replaced elements
        si position.est_mot_clé(PROP_absolute) {
            retourne calcule_largeur_et_marges_abosolutely_positionned_replaced_element
        }

        // 10.3.4 Block-level, replaced elements in normal flow
        retourne calcule_largeur_et_marges_block_level_replaced_element
    }

    // 10.3.1 Inline, non-replaced elements
    si display.outer_type == Display.Type.Inline && (display.inner_type == Display.Type.Flow || display.inner_type == Display.Type.FlowRoot) {
        // 10.3.9 'Inline-block', non-replaced elements in normal flow
        si display.inner_type == Display.Type.FlowRoot {
            retourne calcule_largeur_et_marges_inline_block_non_replaced_element
        }
        retourne calcule_largeur_et_marges_inline_non_replaced_element
    }

    // 10.3.7 Absolutely positioned, non-replaced elements
    si position.est_mot_clé(PROP_absolute) || position.est_mot_clé(PROP_fixed) {
        retourne calcule_largeur_et_marges_abosolutely_positionned_non_replaced_element
    }

    // 10.3.5 Floating, non-replaced elements
    saufsi float.est_none() {
        retourne calcule_largeur_et_marges_floated_non_replaced_element
    }

    // 10.3.3 Block-level, non-replaced elements in normal flow
    retourne calcule_largeur_et_marges_block_level_normal_flow
}

calcule_pourcentage :: fonc (valeur: ValeurDeStyle, référence: r64) -> ValeurDeStyle
{
    saufsi valeur.est_percentage() {
        retourne valeur
    }

    retourne ValeurDeStyle(pixels = valeur.percentage * référence / 100.0)
}

résoud_pourcentage_largeurs :: fonc (noeud: *NoeudDeDisposition, containing_block: &ContainingBlock)
{
    width_of_containing_block := containing_block.donne_largeur()

    propriétés := noeud.propriétés
    propriétés.résoud_pourcentage(IDPropriété.MinWidth, width_of_containing_block)
    propriétés.résoud_pourcentage(IDPropriété.MaxWidth, width_of_containing_block)
    propriétés.résoud_pourcentage(IDPropriété.MarginLeft, width_of_containing_block)
    propriétés.résoud_pourcentage(IDPropriété.PaddingLeft, width_of_containing_block)
    propriétés.résoud_pourcentage(IDPropriété.Width, width_of_containing_block)
    propriétés.résoud_pourcentage(IDPropriété.PaddingRight, width_of_containing_block)
    propriétés.résoud_pourcentage(IDPropriété.MarginRight, width_of_containing_block)
}

résoud_pourcentage_largeur_border_radius :: fonc (noeud: *NoeudDeDisposition)
{
    largeur := noeud.modèle_de_boite.bordure.largeur
    propriétés := noeud.propriétés

    empl IDPropriété

    pour [BorderBottomLeftRadius, BorderBottomRightRadius, BorderTopLeftRadius, BorderTopRightRadius] {
        propriétés.résoud_pourcentage(it, largeur)
        propriétés.copie_valeur_calculée_vers_utilisée(it)
    }
}

résoud_pourcentage_hauteur :: fonc (noeud: *NoeudDeDisposition, containing_block: &ContainingBlock)
{
    width_of_containing_block := containing_block.donne_largeur()
    height_of_containing_block := containing_block.donne_hauteur()

    // À FAIRE : pourcentage min-height, max-height
    propriétés := noeud.propriétés
    propriétés.résoud_pourcentage(IDPropriété.MarginTop, width_of_containing_block)
    propriétés.résoud_pourcentage(IDPropriété.PaddingTop, width_of_containing_block)
    propriétés.résoud_pourcentage(IDPropriété.Height, height_of_containing_block)
    propriétés.résoud_pourcentage(IDPropriété.PaddingBottom, width_of_containing_block)
    propriétés.résoud_pourcentage(IDPropriété.MarginBottom, width_of_containing_block)
}

résoud_pourcentage_insets :: fonc (noeud: *NoeudDeDisposition, ctx: *ContexteDeFormattage)
{
    containing_block := donne_containing_block(noeud, ctx)

    noeud.propriétés.résoud_pourcentage(IDPropriété.Top, containing_block.donne_hauteur())
    noeud.propriétés.résoud_pourcentage(IDPropriété.Bottom, containing_block.donne_hauteur())

    noeud.propriétés.résoud_pourcentage(IDPropriété.Left, containing_block.donne_largeur())
    noeud.propriétés.résoud_pourcentage(IDPropriété.Right, containing_block.donne_largeur())

    pour [IDPropriété.Top, IDPropriété.Bottom, IDPropriété.Left, IDPropriété.Right] {
        noeud.propriétés.définis_valeur_utilisée(it, noeud.propriétés.donne_valeur_calculée(it))
    }
}

calcule_hauteur_et_marges :: fonc (noeud: *NoeudDeDisposition, containing_block: &ContainingBlock)
{
    résoud_pourcentage_hauteur(noeud, containing_block)

    fonction_de_calcul := donne_fonction_calcul_hauteur_et_marges(noeud)

    fonction_de_calcul(noeud, nul)

    height := noeud.propriétés.donne_valeur_utilisée(IDPropriété.Height)
    max_height := noeud.propriétés.donne_valeur_calculée(IDPropriété.MaxHeight)
    si max_height.est_pixels() && (height.pixels > max_height.pixels) {
        fonction_de_calcul(noeud, *max_height)
    }

    height = noeud.propriétés.donne_valeur_utilisée(IDPropriété.Height)
    min_height := noeud.propriétés.donne_valeur_calculée(IDPropriété.MinHeight)
    si min_height.est_pixels() && (height.pixels < min_height.pixels) {
        fonction_de_calcul(noeud, *min_height)
    }

    ajourne_boite_pour_calcul_hauteur(noeud)
}

donne_fonction_calcul_hauteur_et_marges :: fonc (noeud: *NoeudDeDisposition) -> fonc(*NoeudDeDisposition,*ValeurDeStyle)(rien)
{
    propriétés := noeud.propriétés
    display := propriétés.donne_valeur_calculée(IDPropriété.Display).display

    si noeud.type == NoeudDeDispositionRemplacement {
       // 10.6.2 Inline replaced elements, block-level replaced elements in normal flow, 'inline-block' replaced elements in normal flow and floating replaced elements
        retourne calcule_hauteur_et_marges_inline_replaced_element

        // À FAIRE 10.6.5 Absolutely positioned, replaced elements
    }

    si display.outer_type == Display.Type.Inline {
        // 10.6.1 Inline, non-replaced elements
        retourne calcule_hauteur_et_marges_inline_non_replaced_element
    }

    // 10.6.3 Block-level non-replaced elements in normal flow when 'overflow' computes to 'visible'
    // À FAIRE : overflow
    retourne calcule_hauteur_et_marges_block_level_normal_flow

    // À FAIRE : 10.6.6 Complicated cases
    // À FAIRE : 10.6.7 'Auto' heights for block formatting context roots
}

calcule_hauteur_et_marges_block_level_normal_flow :: fonc (base: *NoeudDeDisposition, outrepas_hauteur: *ValeurDeStyle)
{
    noeud := base comme *NoeudDeDispositionBloc
    propriétés := noeud.propriétés

    /* À FAIRE */
    margin_top := propriétés.donne_valeur_calculée(IDPropriété.MarginTop)
    border_top_height := propriétés.donne_valeur_calculée(IDPropriété.BorderWidthTop)
    padding_top := propriétés.donne_valeur_calculée(IDPropriété.PaddingTop)
    height := propriétés.donne_valeur_calculée(IDPropriété.Height)
    si outrepas_hauteur {
        height = mémoire(outrepas_hauteur)
    }
    padding_bottom := propriétés.donne_valeur_calculée(IDPropriété.PaddingBottom)
    border_bottom_height := propriétés.donne_valeur_calculée(IDPropriété.BorderWidthBottom)
    margin_bottom := propriétés.donne_valeur_calculée(IDPropriété.MarginBottom)

    box_sizing := propriétés.donne_valeur_calculée(IDPropriété.BoxSizing)
    si box_sizing.est_mot_clé(PROP_border_box) && !height.est_auto() {
        height.pixels -= border_top_height.pixels + padding_top.pixels + padding_bottom.pixels + border_bottom_height.pixels
        si height.pixels < 0 {
            height.pixels = 0
        }
    }

    saufsi margin_top.est_pixels() {
        margin_top = ValeurDeStyle(pixels = 0)
    }
    saufsi border_top_height.est_pixels() {
        border_top_height = ValeurDeStyle(pixels = 0)
    }
    saufsi padding_top.est_pixels() {
        padding_top = ValeurDeStyle(pixels = 0)
    }
    saufsi height.est_pixels() {
        height = ValeurDeStyle(pixels = 0)
    }
    saufsi padding_bottom.est_pixels() {
        padding_bottom = ValeurDeStyle(pixels = 0)
    }
    saufsi border_bottom_height.est_pixels() {
        border_bottom_height = ValeurDeStyle(pixels = 0)
    }
    saufsi margin_bottom.est_pixels() {
        margin_bottom = ValeurDeStyle(pixels = 0)
    }

    propriétés.définis_valeur_utilisée(IDPropriété.MarginTop, margin_top)
    propriétés.définis_valeur_utilisée(IDPropriété.BorderWidthTop, border_top_height)
    propriétés.définis_valeur_utilisée(IDPropriété.PaddingTop, padding_top)
    propriétés.définis_valeur_utilisée(IDPropriété.Height, height)
    propriétés.définis_valeur_utilisée(IDPropriété.PaddingBottom, padding_bottom)
    propriétés.définis_valeur_utilisée(IDPropriété.BorderWidthBottom, border_bottom_height)
    propriétés.définis_valeur_utilisée(IDPropriété.MarginBottom, margin_bottom)
}

/* https://www.w3.org/TR/2011/REC-CSS2-20110607/visudet.html#blockwidth */
calcule_largeur_et_marges_block_level_normal_flow :: fonc (ctx: *ContexteDeFormattage @inutilisée, base: *NoeudDeDisposition, width_of_containing_block: r64, outrepas_largeur: *ValeurDeStyle)
{
    noeud := base comme *NoeudDeDispositionBloc
    propriétés := noeud.propriétés

    margin_left := propriétés.donne_valeur_calculée(IDPropriété.MarginLeft)
    border_left_width := propriétés.donne_valeur_calculée(IDPropriété.BorderWidthLeft)
    padding_left := propriétés.donne_valeur_calculée(IDPropriété.PaddingLeft)
    width := propriétés.donne_valeur_calculée(IDPropriété.Width)
    si outrepas_largeur {
        width = mémoire(outrepas_largeur)
    }
    padding_right := propriétés.donne_valeur_calculée(IDPropriété.PaddingRight)
    border_right_width := propriétés.donne_valeur_calculée(IDPropriété.BorderWidthRight)
    margin_right := propriétés.donne_valeur_calculée(IDPropriété.MarginRight)

    box_sizing := propriétés.donne_valeur_calculée(IDPropriété.BoxSizing)
    si box_sizing.est_mot_clé(PROP_border_box) && !width.est_auto() {
        width.pixels -= border_left_width.pixels + padding_left.pixels + padding_right.pixels + border_right_width.pixels
        si width.pixels < 0 {
            width.pixels = 0
        }
    }

    // If 'width' is not 'auto' and 'border-left-width' + 'padding-left' + 'width' + 'padding-right'
    // + 'border-right-width' (plus any of 'margin-left' or 'margin-right' that are not 'auto') is
    // larger than the width of the containing block, then any 'auto' values for 'margin-left' or
    // 'margin-right' are, for the following rules, treated as zero.
    saufsi width.est_auto() {
        tmp : r64 = 0.0
        tmp += border_left_width.pixels
        tmp += padding_left.pixels
        tmp += width.pixels
        tmp += padding_right.pixels
        tmp += border_right_width.pixels

        saufsi margin_left.est_auto() {
            tmp += margin_left.pixels
        }
        saufsi margin_right.est_auto() {
            tmp += margin_right.pixels
        }

        si tmp > width_of_containing_block {
            si margin_left.est_auto() {
                margin_left = ValeurDeStyle(pixels = 0.0)
            }
            si margin_right.est_auto() {
                margin_right = ValeurDeStyle(pixels = 0.0)
            }
        }
    }

    // If all of the above have a computed value other than 'auto', the values are said to be "over-constrained"
    // and one of the used values will have to be different from its computed value.
    // If the 'direction' property of the containing block has the value 'ltr', the specified value of
    // 'margin-right' is ignored and the value is calculated so as to make the equality true.
    // If the value of 'direction' is 'rtl', this happens to 'margin-left' instead.
    surcontraint := 0
    surcontraint += margin_left.est_auto() comme z32
    surcontraint += border_left_width.est_auto() comme z32
    surcontraint += padding_left.est_auto() comme z32
    surcontraint += width.est_auto() comme z32
    surcontraint += padding_right.est_auto() comme z32
    surcontraint += border_right_width.est_auto() comme z32
    surcontraint += margin_right.est_auto() comme z32

    margin_right_pour_équation := margin_right
    si surcontraint == 0 {
        // À FAIRE : direction
        margin_right_pour_équation = ValeurDeStyle(pixels = 0.0)
    }

    // If there is exactly one value specified as 'auto', its used value follows from the equality.
    si surcontraint == 1 {
        si margin_left.est_auto() {
            résultat := width_of_containing_block - (border_left_width.pixels + padding_left.pixels + width.pixels + padding_right.pixels + border_right_width.pixels + margin_right_pour_équation.pixels)
            margin_left = ValeurDeStyle(pixels = résultat)
        }
        sinon si border_left_width.est_auto() {
            résultat := width_of_containing_block - (margin_left.pixels + padding_left.pixels + width.pixels + padding_right.pixels + border_right_width.pixels + margin_right_pour_équation.pixels)
            border_left_width = ValeurDeStyle(pixels = résultat)
        }
        sinon si padding_left.est_auto() {
            résultat := width_of_containing_block - (margin_left.pixels + border_left_width.pixels + width.pixels + padding_right.pixels + border_right_width.pixels + margin_right_pour_équation.pixels)
            padding_left = ValeurDeStyle(pixels = résultat)
        }
        sinon si width.est_auto() {
            résultat := width_of_containing_block - (margin_left.pixels + border_left_width.pixels + padding_left.pixels + padding_right.pixels + border_right_width.pixels + margin_right_pour_équation.pixels)
            width = ValeurDeStyle(pixels = résultat)
        }
        sinon si padding_right.est_auto() {
            résultat := width_of_containing_block - (margin_left.pixels + border_left_width.pixels + padding_left.pixels + width.pixels + border_right_width.pixels + margin_right_pour_équation.pixels)
            padding_right = ValeurDeStyle(pixels = résultat)
        }
        sinon si border_right_width.est_auto() {
            résultat := width_of_containing_block - (margin_left.pixels + border_left_width.pixels + padding_left.pixels + width.pixels + padding_right.pixels + margin_right_pour_équation.pixels)
            border_right_width = ValeurDeStyle(pixels = résultat)
        }
        sinon si margin_right.est_auto() {
            résultat := width_of_containing_block - (margin_left.pixels + border_left_width.pixels + padding_left.pixels + width.pixels + padding_right.pixels + border_right_width.pixels)
            margin_right = ValeurDeStyle(pixels = résultat)
        }
    }

    // If 'width' is set to 'auto', any other 'auto' values become '0' and 'width' follows from the resulting equality.
    si width.est_auto() {
        si margin_left.est_auto() {
            margin_left = ValeurDeStyle(pixels = 0.0)
        }
        si border_left_width.est_auto() {
            border_left_width = ValeurDeStyle(pixels = 0.0)
        }
        si padding_left.est_auto() {
            padding_left = ValeurDeStyle(pixels = 0.0)
        }
        si padding_right.est_auto() {
            padding_right = ValeurDeStyle(pixels = 0.0)
        }
        si border_right_width.est_auto() {
            border_right_width = ValeurDeStyle(pixels = 0.0)
        }
        si margin_right.est_auto() {
            margin_right = ValeurDeStyle(pixels = 0.0)
        }

        résultat := width_of_containing_block - (margin_left.pixels + border_left_width.pixels + padding_left.pixels + padding_right.pixels + border_right_width.pixels + margin_right.pixels)
        width = ValeurDeStyle(pixels = résultat)
    }

    // If both 'margin-left' and 'margin-right' are 'auto', their used values are equal.
    // This horizontally centers the element with respect to the edges of the containing block.
    si margin_left.est_auto() && margin_right.est_auto() {
        résultat := width_of_containing_block - (border_left_width.pixels + padding_left.pixels + width.pixels + padding_right.pixels + border_right_width.pixels)
        résultat *= 0.5

        margin_left = ValeurDeStyle(pixels = résultat)
        margin_right = ValeurDeStyle(pixels = résultat)
    }

    propriétés.définis_valeur_utilisée(IDPropriété.MarginLeft, margin_left)
    propriétés.définis_valeur_utilisée(IDPropriété.BorderWidthLeft, border_left_width)
    propriétés.définis_valeur_utilisée(IDPropriété.PaddingLeft, padding_left)
    propriétés.définis_valeur_utilisée(IDPropriété.Width, width)
    propriétés.définis_valeur_utilisée(IDPropriété.PaddingRight, padding_right)
    propriétés.définis_valeur_utilisée(IDPropriété.BorderWidthRight, border_right_width)
    propriétés.définis_valeur_utilisée(IDPropriété.MarginRight, margin_right)
}

/* https://www.w3.org/TR/2011/REC-CSS2-20110607/visudet.html#abs-non-replaced-width */
calcule_largeur_et_marges_abosolutely_positionned_non_replaced_element :: fonc (ctx: *ContexteDeFormattage, base: *NoeudDeDisposition, width_of_containing_block: r64, outrepas_largeur: *ValeurDeStyle)
{
    noeud := base comme *NoeudDeDispositionBloc
    résoud_pourcentage_insets(noeud, ctx)

    propriétés := noeud.propriétés

    left := propriétés.donne_valeur_calculée(IDPropriété.Left)
    margin_left := propriétés.donne_valeur_calculée(IDPropriété.MarginLeft)
    border_left_width := propriétés.donne_valeur_calculée(IDPropriété.BorderWidthLeft)
    padding_left := propriétés.donne_valeur_calculée(IDPropriété.PaddingLeft)
    width := propriétés.donne_valeur_calculée(IDPropriété.Width)
    si outrepas_largeur {
        width = mémoire(outrepas_largeur)
    }
    padding_right := propriétés.donne_valeur_calculée(IDPropriété.PaddingRight)
    border_right_width := propriétés.donne_valeur_calculée(IDPropriété.BorderWidthRight)
    margin_right := propriétés.donne_valeur_calculée(IDPropriété.MarginRight)
    right := propriétés.donne_valeur_calculée(IDPropriété.Right)

    box_sizing := propriétés.donne_valeur_calculée(IDPropriété.BoxSizing)
    si box_sizing.est_mot_clé(PROP_border_box) && !width.est_auto() {
        width.pixels -= border_left_width.pixels + padding_left.pixels + padding_right.pixels + border_right_width.pixels
        si width.pixels < 0 {
            width.pixels = 0
        }
    }

    // If all three of 'left', 'width', and 'right' are 'auto': First set any 'auto' values
    // for 'margin-left' and 'margin-right' to 0. Then, if the 'direction' property of the
    // element establishing the static-position containing block is 'ltr' set 'left' to the
    // static position and apply rule number three below; otherwise, set 'right' to the static
    // position and apply rule number one below.
    si left.est_auto() && right.est_auto() && width.est_auto() {
        // À FAIRE : direction
        si margin_left.est_auto() {
            margin_left.pixels = 0.0
        }
        si margin_right.est_auto() {
            margin_right.pixels = 0.0
        }

        left.pixels =  0.0

        right.pixels = 0.0
        available_width := width_of_containing_block - left.pixels - margin_left.pixels - border_left_width.pixels - padding_left.pixels - padding_right.pixels - border_right_width.pixels - margin_right.pixels - right.pixels
        width.pixels = calcule_shrink_to_fit_width(ctx, noeud, available_width)
        right.pixels = width_of_containing_block - left.pixels - margin_left.pixels - border_left_width.pixels - padding_left.pixels - width.pixels - padding_right.pixels - border_right_width.pixels - margin_right.pixels
    }
    sinon si !left.est_auto() && !right.est_auto() && !width.est_auto() {
        // If none of the three is 'auto': If both 'margin-left' and 'margin-right' are 'auto',
        // solve the equation under the extra constraint that the two margins get equal values,
        // unless this would make them negative, in which case when direction of the containing
        // block is 'ltr' ('rtl'), set 'margin-left' ('margin-right') to zero and solve for
        // 'margin-right' ('margin-left').
        si margin_left.est_auto() && margin_right.est_auto() {
            taille_marges := width_of_containing_block - left.pixels - border_left_width.pixels - padding_left.pixels - width.pixels - padding_right.pixels - border_right_width.pixels - right.pixels
            si taille_marges < 0.0 {
                // À FAIRE : direction
                margin_left.pixels = 0.0
                margin_right.pixels = taille_marges
            }
            sinon {
                taille_marges *= 0.5

                margin_left.pixels = taille_marges
                margin_right.pixels = taille_marges
            }
        }
        // If one of 'margin-left' or 'margin-right' is 'auto', solve the equation for that value.
        sinon si margin_left.est_auto() {
            margin_left.pixels = width_of_containing_block - left.pixels - border_left_width.pixels - padding_left.pixels - width.pixels - padding_right.pixels - border_right_width.pixels - margin_right.pixels - right.pixels
        }
        sinon si margin_right.est_auto() {
            margin_right.pixels = width_of_containing_block - margin_left.pixels - border_left_width.pixels - padding_left.pixels - width.pixels - padding_right.pixels - border_right_width.pixels - right.pixels
        }
        // If the values are over-constrained, ignore the value for 'left' (in case the 'direction'
        // property of the containing block is 'rtl') or 'right' (in case 'direction' is 'ltr') and
        // solve for that value.
        sinon {
            // À FAIRE : direction
            left.pixels = width_of_containing_block - margin_left.pixels - border_left_width.pixels - padding_left.pixels - width.pixels - padding_right.pixels - border_right_width.pixels - margin_right.pixels - right.pixels
        }
    }
    sinon {
        si margin_left.est_auto() {
            margin_left.pixels = 0.0
        }
        si margin_right.est_auto() {
            margin_right.pixels = 0.0
        }

        // 1. 'left' and 'width' are 'auto' and 'right' is not 'auto', then the width is shrink-to-fit.
        //     Then solve for 'left'
        si left.est_auto() && width.est_auto() && !right.est_auto() {
            left.pixels = 0.0
            available_width := width_of_containing_block - left.pixels - margin_left.pixels - border_left_width.pixels - padding_left.pixels - padding_right.pixels - border_right_width.pixels - margin_right.pixels - right.pixels
            width.pixels = calcule_shrink_to_fit_width(ctx, noeud, available_width)
            left.pixels = width_of_containing_block - margin_left.pixels - border_left_width.pixels - padding_left.pixels - width.pixels - padding_right.pixels - border_right_width.pixels - margin_right.pixels - right.pixels
        }

        // 2. 'left' and 'right' are 'auto' and 'width' is not 'auto', then if the 'direction' property of
        //    the element establishing the static-position containing block is 'ltr' set 'left' to the static position, otherwise set 'right' to the static position. Then solve for 'left' (if 'direction is 'rtl') or 'right' (if 'direction' is 'ltr').
        sinon si left.est_auto() && right.est_auto() && !width.est_auto() {
            // À FAIRE : direction
            left.pixels = 0.0
            right.pixels = width_of_containing_block - left.pixels - margin_left.pixels - border_left_width.pixels - padding_left.pixels - width.pixels - padding_right.pixels - border_right_width.pixels - margin_right.pixels
        }

        // 3. 'width' and 'right' are 'auto' and 'left' is not 'auto', then the width is shrink-to-fit.
        //    Then solve for 'right'
        sinon si width.est_auto() && right.est_auto() && !left.est_auto() {
            right.pixels = 0.0
            available_width := width_of_containing_block - left.pixels - margin_left.pixels - border_left_width.pixels - padding_left.pixels - padding_right.pixels - border_right_width.pixels - margin_right.pixels - right.pixels
            width.pixels = calcule_shrink_to_fit_width(ctx, noeud, available_width)
            right.pixels = width_of_containing_block - left.pixels - margin_left.pixels - border_left_width.pixels - padding_left.pixels - width.pixels - padding_right.pixels - border_right_width.pixels - margin_right.pixels
        }

        // 4. 'left' is 'auto', 'width' and 'right' are not 'auto', then solve for 'left'
        sinon si left.est_auto() && !width.est_auto() && !right.est_auto() {
            left.pixels = width_of_containing_block - margin_left.pixels - border_left_width.pixels - padding_left.pixels - width.pixels - padding_right.pixels - border_right_width.pixels - margin_right.pixels - right.pixels
        }
        
        // 5. 'width' is 'auto', 'left' and 'right' are not 'auto', then solve for 'width'
        sinon si width.est_auto() && !left.est_auto() && !right.est_auto() {
            width.pixels = width_of_containing_block - left.pixels - margin_left.pixels - border_left_width.pixels - padding_left.pixels - padding_right.pixels - border_right_width.pixels - margin_right.pixels - right.pixels
        }
        
        // 6. 'right' is 'auto', 'left' and 'width' are not 'auto', then solve for 'right'
        sinon si right.est_auto() && !left.est_auto() && !width.est_auto() {
            right.pixels = width_of_containing_block - left.pixels - margin_left.pixels - border_left_width.pixels - padding_left.pixels - width.pixels - padding_right.pixels - border_right_width.pixels - margin_right.pixels
        }
    }

    propriétés.définis_valeur_utilisée(IDPropriété.Left, left)
    propriétés.définis_valeur_utilisée(IDPropriété.MarginLeft, margin_left)
    propriétés.définis_valeur_utilisée(IDPropriété.BorderWidthLeft, border_left_width)
    propriétés.définis_valeur_utilisée(IDPropriété.PaddingLeft, padding_left)
    propriétés.définis_valeur_utilisée(IDPropriété.Width, width)
    propriétés.définis_valeur_utilisée(IDPropriété.PaddingRight, padding_right)
    propriétés.définis_valeur_utilisée(IDPropriété.BorderWidthRight, border_right_width)
    propriétés.définis_valeur_utilisée(IDPropriété.MarginRight, margin_right)
    propriétés.définis_valeur_utilisée(IDPropriété.Right, right)

    ajourne_boite_pour_calcul_largeur(noeud)
}

/* https://www.w3.org/TR/2011/REC-CSS2-20110607/visudet.html#float-width */
calcule_largeur_et_marges_floated_non_replaced_element :: fonc (ctx: *ContexteDeFormattage, base: *NoeudDeDisposition, width_of_containing_block: r64, outrepas_largeur: *ValeurDeStyle)
{
    noeud := base comme *NoeudDeDispositionRemplacement

    propriétés := noeud.propriétés

    margin_left := propriétés.donne_valeur_calculée(IDPropriété.MarginLeft)
    border_left_width := propriétés.donne_valeur_calculée(IDPropriété.BorderWidthLeft)
    padding_left := propriétés.donne_valeur_calculée(IDPropriété.PaddingLeft)
    width := propriétés.donne_valeur_calculée(IDPropriété.Width)
    si outrepas_largeur {
        width = mémoire(outrepas_largeur)
    }
    padding_right := propriétés.donne_valeur_calculée(IDPropriété.PaddingRight)
    border_right_width := propriétés.donne_valeur_calculée(IDPropriété.BorderWidthRight)
    margin_right := propriétés.donne_valeur_calculée(IDPropriété.MarginRight)

    box_sizing := propriétés.donne_valeur_calculée(IDPropriété.BoxSizing)
    si box_sizing.est_mot_clé(PROP_border_box) && !width.est_auto() {
        width.pixels -= border_left_width.pixels + padding_left.pixels + padding_right.pixels + border_right_width.pixels
        si width.pixels < 0 {
            width.pixels = 0
        }
    }

    // If 'margin-left', or 'margin-right' are computed as 'auto', their used value is '0'.
    si margin_left.est_auto() {
        margin_left.pixels = 0.0
    }
    si margin_right.est_auto() {
        margin_right.pixels = 0.0
    }

    // If 'width' is computed as 'auto', the used value is the "shrink-to-fit" width.
    si width.est_auto() {
        // Calculation of the shrink-to-fit width is similar to calculating the width of a table
        // cell using the automatic table layout algorithm. Roughly: calculate the preferred width
        // by formatting the content without breaking lines other than where explicit line breaks
        // occur, and also calculate the preferred minimum width, e.g., by trying all possible line
        // breaks. CSS 2.1 does not define the exact algorithm.
        // Thirdly, find the available width: in this case, this is the width of the containing
        // block minus the used values of 'margin-left', 'border-left-width', 'padding-left',
        // 'padding-right', 'border-right-width', 'margin-right', and the widths of any relevant
        // scroll bars.
        available_width := width_of_containing_block - margin_left.pixels - border_left_width.pixels - padding_left.pixels - padding_right.pixels - border_right_width.pixels - margin_right.pixels
        width.pixels = calcule_shrink_to_fit_width(ctx, noeud, available_width)
    }

    propriétés.définis_valeur_utilisée(IDPropriété.MarginLeft, margin_left)
    propriétés.définis_valeur_utilisée(IDPropriété.BorderWidthLeft, border_left_width)
    propriétés.définis_valeur_utilisée(IDPropriété.PaddingLeft, padding_left)
    propriétés.définis_valeur_utilisée(IDPropriété.Width, width)
    propriétés.définis_valeur_utilisée(IDPropriété.PaddingRight, padding_right)
    propriétés.définis_valeur_utilisée(IDPropriété.BorderWidthRight, border_right_width)
    propriétés.définis_valeur_utilisée(IDPropriété.MarginRight, margin_right)

    ajourne_boite_pour_calcul_largeur(noeud)
}

calcule_shrink_to_fit_width :: fonc (ctx: *ContexteDeFormattage, noeud: *NoeudDeDisposition, available_width: r64) -> r64
{
    formatte_intérieur(noeud comme *NoeudDeDispositionBloc, ctx, ModeDeFormattage.BrisureDeLigneExplicite)
    preferred_width := noeud.propriétés.donne_valeur_utilisée(IDPropriété.Width).pixels

    formatte_intérieur(noeud comme *NoeudDeDispositionBloc, ctx, ModeDeFormattage.ToutesLesBrisuresDeLigne)
    minimum_width := noeud.propriétés.donne_valeur_utilisée(IDPropriété.Width).pixels

    résultat := min(max(minimum_width, preferred_width), available_width)
    retourne résultat
}

/* https://www.w3.org/TR/2011/REC-CSS2-20110607/visudet.html#inline-replaced-width */
calcule_largeur_et_marges_inline_replaced_element :: fonc (ctx: *ContexteDeFormattage @inutilisée, base: *NoeudDeDisposition, width_of_containing_block: r64 @inutilisée, outrepas_largeur: *ValeurDeStyle)
{
    noeud := base comme *NoeudDeDispositionRemplacement

    propriétés := noeud.propriétés

    margin_left := propriétés.donne_valeur_calculée(IDPropriété.MarginLeft)
    border_left_width := propriétés.donne_valeur_calculée(IDPropriété.BorderWidthLeft)
    padding_left := propriétés.donne_valeur_calculée(IDPropriété.PaddingLeft)
    width := propriétés.donne_valeur_calculée(IDPropriété.Width)
    si outrepas_largeur {
        width = mémoire(outrepas_largeur)
    }
    height := propriétés.donne_valeur_calculée(IDPropriété.Height)
    padding_right := propriétés.donne_valeur_calculée(IDPropriété.PaddingRight)
    border_right_width := propriétés.donne_valeur_calculée(IDPropriété.BorderWidthRight)
    margin_right := propriétés.donne_valeur_calculée(IDPropriété.MarginRight)

    // A computed value of 'auto' for 'margin-left' or 'margin-right' becomes a used value of '0'.
    si margin_left.est_auto() {
        margin_left = ValeurDeStyle(pixels = 0.0)
    }
    si margin_right.est_auto() {
        margin_right = ValeurDeStyle(pixels = 0.0)
    }

    // If 'height' and 'width' both have computed values of 'auto' and the element also has
    // an intrinsic width, then that intrinsic width is the used value of 'width'.
    si width.est_auto() && height.est_auto() && noeud.possède_largeur_intrinsèque() {
        width = ValeurDeStyle(pixels = noeud.donne_largeur_intrinsèque())
    }
    // If 'height' and 'width' both have computed values of 'auto' and the element has no
    // intrinsic width, but does have an intrinsic height and intrinsic ratio;
    // or if 'width' has a computed value of 'auto', 'height' has some other computed value,
    // and the element does have an intrinsic ratio; then the used value of 'width' is:
    //     (used height) * (intrinsic ratio)
    sinon si (width.est_auto() && height.est_auto() && !noeud.possède_largeur_intrinsèque() && noeud.possède_ratio_intrinsèque()) ||
             (width.est_auto() && !height.est_auto() && noeud.possède_ratio_intrinsèque()) {
        si height.est_auto() {
            width = ValeurDeStyle(pixels = noeud.donne_hauteur_intrinsèque() * noeud.donne_ratio_intrinsèque())
        }
        sinon {
            width = ValeurDeStyle(pixels = height.pixels * noeud.donne_ratio_intrinsèque())
        }
    }

    // If 'height' and 'width' both have computed values of 'auto' and the element has
    // an intrinsic ratio but no intrinsic height or width, then the used value of 'width'
    // is undefined in CSS 2.1.
    // However, it is suggested that, if the containing block's width does not itself
    // depend on the replaced element's width, then the used value of 'width' is calculated
    // from the constraint equation used for block-level, non-replaced elements in normal flow.

    // Otherwise, if 'width' has a computed value of 'auto', and the element has an intrinsic width,
    // then that intrinsic width is the used value of 'width'.
    sinon si width.est_auto() && noeud.possède_largeur_intrinsèque() {
        width = ValeurDeStyle(pixels = noeud.donne_largeur_intrinsèque())
    }
    // Otherwise, if 'width' has a computed value of 'auto', but none of the conditions above are met,
    // then the used value of 'width' becomes 300px.
    // If 300px is too wide to fit the device, UAs should use the width of the largest rectangle that
    // has a 2:1 ratio and fits the device instead.
    sinon si width.est_auto() {
        width = ValeurDeStyle(pixels = 300.0)
    }

    propriétés.définis_valeur_utilisée(IDPropriété.MarginLeft, margin_left)
    propriétés.définis_valeur_utilisée(IDPropriété.BorderWidthLeft, border_left_width)
    propriétés.définis_valeur_utilisée(IDPropriété.PaddingLeft, padding_left)
    propriétés.définis_valeur_utilisée(IDPropriété.Width, width)
    propriétés.définis_valeur_utilisée(IDPropriété.PaddingRight, padding_right)
    propriétés.définis_valeur_utilisée(IDPropriété.BorderWidthRight, border_right_width)
    propriétés.définis_valeur_utilisée(IDPropriété.MarginRight, margin_right)

    ajourne_boite_pour_calcul_largeur(noeud)
}

/* https://www.w3.org/TR/2011/REC-CSS2-20110607/visudet.html#inline-replaced-height */
calcule_hauteur_et_marges_inline_replaced_element :: fonc (base: *NoeudDeDisposition, outrepas_hauteur: *ValeurDeStyle)
{
    noeud := base comme *NoeudDeDispositionRemplacement
    propriétés := noeud.propriétés

    margin_top := propriétés.donne_valeur_calculée(IDPropriété.MarginTop)
    border_top_height := propriétés.donne_valeur_calculée(IDPropriété.BorderWidthTop)
    padding_top := propriétés.donne_valeur_calculée(IDPropriété.PaddingTop)
    height := propriétés.donne_valeur_calculée(IDPropriété.Height)
    si outrepas_hauteur {
        height = mémoire(outrepas_hauteur)
    }
    width := propriétés.donne_valeur_calculée(IDPropriété.Width)
    padding_bottom := propriétés.donne_valeur_calculée(IDPropriété.PaddingBottom)
    border_bottom_height := propriétés.donne_valeur_calculée(IDPropriété.BorderWidthBottom)
    margin_bottom := propriétés.donne_valeur_calculée(IDPropriété.MarginBottom)

    // If 'margin-top', or 'margin-bottom' are 'auto', their used value is 0.
    si margin_top.est_auto() {
        margin_top = ValeurDeStyle(pixels = 0.0)
    }
    si margin_bottom.est_auto() {
        margin_bottom = ValeurDeStyle(pixels = 0.0)
    }

    // If 'height' and 'width' both have computed values of 'auto' and the element also has
    // an intrinsic height, then that intrinsic height is the used value of 'height'.
    si width.est_auto() && height.est_auto() && noeud.possède_hauteur_intrinsèque() {
        height = ValeurDeStyle(pixels = noeud.donne_hauteur_intrinsèque())
    }

    // Otherwise, if 'height' has a computed value of 'auto', and the element has an intrinsic
    // ratio then the used value of 'height' is:
    //      (used width) / (intrinsic ratio)
    sinon si height.est_auto() && noeud.possède_ratio_intrinsèque() {
        largeur_utilisée := propriétés.donne_valeur_utilisée(IDPropriété.Width)
        height = ValeurDeStyle(pixels = largeur_utilisée.pixels / noeud.donne_ratio_intrinsèque())
    }

    // Otherwise, if 'height' has a computed value of 'auto', and the element has an intrinsic height,
    // then that intrinsic height is the used value of 'height'.
    sinon si height.est_auto() && noeud.possède_hauteur_intrinsèque() {
        height = ValeurDeStyle(pixels = noeud.donne_hauteur_intrinsèque())
    }

    // Otherwise, if 'height' has a computed value of 'auto', but none of the conditions above are met,
    // then the used value of 'height' must be set to the height of the largest rectangle that has a
    // 2:1 ratio, has a height not greater than 150px, and has a width not greater than the device width.
    sinon si height.est_auto() {
        largeur_utilisée := propriétés.donne_valeur_utilisée(IDPropriété.Width)
        height = ValeurDeStyle(pixels = largeur_utilisée.pixels * 0.5)
    }

    propriétés.définis_valeur_utilisée(IDPropriété.MarginTop, margin_top)
    propriétés.définis_valeur_utilisée(IDPropriété.BorderWidthTop, border_top_height)
    propriétés.définis_valeur_utilisée(IDPropriété.PaddingTop, padding_top)
    propriétés.définis_valeur_utilisée(IDPropriété.Height, height)
    propriétés.définis_valeur_utilisée(IDPropriété.PaddingBottom, padding_bottom)
    propriétés.définis_valeur_utilisée(IDPropriété.BorderWidthBottom, border_bottom_height)
    propriétés.définis_valeur_utilisée(IDPropriété.MarginBottom, margin_bottom)

    ajourne_boite_pour_calcul_hauteur(noeud)
}

/* https://www.w3.org/TR/2011/REC-CSS2-20110607/visudet.html#float-replaced-width */
calcule_largeur_et_marges_float_replaced_element :: fonc (ctx: *ContexteDeFormattage, base: *NoeudDeDisposition, width_of_containing_block: r64, outrepas_largeur: *ValeurDeStyle)
{
    // If 'margin-left' or 'margin-right' are computed as 'auto', their used value is '0'.
    // The used value of 'width' is determined as for inline replaced elements.
    // NOTE : 'margin-left' et 'margin-right' sont aussi gérés dans le cas inline.
    calcule_largeur_et_marges_inline_replaced_element(ctx, base, width_of_containing_block, outrepas_largeur)
}

/* https://www.w3.org/TR/2011/REC-CSS2-20110607/visudet.html#abs-replaced-width */
calcule_largeur_et_marges_abosolutely_positionned_replaced_element :: fonc (ctx: *ContexteDeFormattage, base: *NoeudDeDisposition, width_of_containing_block: r64, outrepas_largeur: *ValeurDeStyle)
{
    noeud := base comme *NoeudDeDispositionBloc
    propriétés := noeud.propriétés
    left := propriétés.donne_valeur_calculée(IDPropriété.Left)
    margin_left := propriétés.donne_valeur_calculée(IDPropriété.MarginLeft)
    border_left_width := propriétés.donne_valeur_calculée(IDPropriété.BorderWidthLeft)
    padding_left := propriétés.donne_valeur_calculée(IDPropriété.PaddingLeft)
    width := propriétés.donne_valeur_calculée(IDPropriété.Width)
    si outrepas_largeur {
        width = mémoire(outrepas_largeur)
    }
    padding_right := propriétés.donne_valeur_calculée(IDPropriété.PaddingRight)
    border_right_width := propriétés.donne_valeur_calculée(IDPropriété.BorderWidthRight)
    margin_right := propriétés.donne_valeur_calculée(IDPropriété.MarginRight)
    right := propriétés.donne_valeur_calculée(IDPropriété.Right)

    box_sizing := propriétés.donne_valeur_calculée(IDPropriété.BoxSizing)
    si box_sizing.est_mot_clé(PROP_border_box) && !width.est_auto() {
        width.pixels -= border_left_width.pixels + padding_left.pixels + padding_right.pixels + border_right_width.pixels
        si width.pixels < 0 {
            width.pixels = 0
        }
    }

    // 1. The used value of 'width' is determined as for inline replaced elements.
    //    If 'margin-left' or 'margin-right' is specified as 'auto' its used value
    //    is determined by the rules below.
    calcule_largeur_et_marges_inline_replaced_element(ctx, base, width_of_containing_block, outrepas_largeur)
    width.pixels = propriétés.donne_valeur_utilisée(IDPropriété.Width).pixels

    // 2. If both 'left' and 'right' have the value 'auto', then if the 'direction'
    //    property of the element establishing the static-position containing block
    //    is 'ltr', set 'left' to the static position; else if 'direction' is 'rtl',
    //    set 'right' to the static position.
    // À FAIRE : direction
    si left.est_auto() && right.est_auto() {
        left.pixels = 0.0
    }

    // 3. If 'left' or 'right' are 'auto', replace any 'auto' on 'margin-left' or
    //    'margin-right' with '0'.
    si left.est_auto() || right.est_auto() {
        si margin_left.est_auto() {
            margin_left.pixels = 0.0
        }
        si margin_right.est_auto() {
            margin_right.pixels = 0.0
        }
    }

    // 4. If at this point both 'margin-left' and 'margin-right' are still 'auto',
    //    solve the equation under the extra constraint that the two margins must get
    //    equal values, unless this would make them negative, in which case when the
    //    direction of the containing block is 'ltr' ('rtl'), set 'margin-left'
    //    ('margin-right') to zero and solve for 'margin-right' ('margin-left').
    si margin_left.est_auto() && margin_right.est_auto() {
        taille_marges := width_of_containing_block - left.pixels - border_left_width.pixels - padding_left.pixels - width.pixels - padding_right.pixels - border_right_width.pixels - right.pixels
        taille_marges *= 0.5
        margin_left.pixels = taille_marges
        margin_right.pixels = taille_marges
    }

    // 5. If at this point there is an 'auto' left, solve the equation for that value.
    si left.est_auto() {
        left.pixels = width_of_containing_block - margin_left.pixels - border_left_width.pixels - padding_left.pixels - width.pixels - padding_right.pixels - border_right_width.pixels - margin_right.pixels - right.pixels
    }
    sinon si right.est_auto() {
        right.pixels = width_of_containing_block - left.pixels - margin_left.pixels - border_left_width.pixels - padding_left.pixels - width.pixels - padding_right.pixels - border_right_width.pixels - margin_right.pixels
    }
    sinon si margin_right.est_auto() {
        margin_right.pixels = width_of_containing_block - left.pixels - margin_left.pixels - border_left_width.pixels - padding_left.pixels - width.pixels - padding_right.pixels - border_right_width.pixels - right.pixels
    }
    sinon si margin_left.est_auto() {
        margin_left.pixels = width_of_containing_block - left.pixels - border_left_width.pixels - padding_left.pixels - width.pixels - padding_right.pixels - border_right_width.pixels - margin_right.pixels - right.pixels
    }

    // 6. If at this point the values are over-constrained, ignore the value for either
    //    'left' (in case the 'direction' property of the containing block is 'rtl') or
    //    'right' (in case 'direction' is 'ltr') and solve for that value.
    // À FAIRE : comprendre ce qui est incomplet/surcontraint

    propriétés.définis_valeur_utilisée(IDPropriété.Left, left)
    propriétés.définis_valeur_utilisée(IDPropriété.MarginLeft, margin_left)
    propriétés.définis_valeur_utilisée(IDPropriété.BorderWidthLeft, border_left_width)
    propriétés.définis_valeur_utilisée(IDPropriété.PaddingLeft, padding_left)
    propriétés.définis_valeur_utilisée(IDPropriété.Width, width)
    propriétés.définis_valeur_utilisée(IDPropriété.PaddingRight, padding_right)
    propriétés.définis_valeur_utilisée(IDPropriété.BorderWidthRight, border_right_width)
    propriétés.définis_valeur_utilisée(IDPropriété.MarginRight, margin_right)
    propriétés.définis_valeur_utilisée(IDPropriété.Right, right)
}

/* https://www.w3.org/TR/2011/REC-CSS2-20110607/visudet.html#block-replaced-width */
calcule_largeur_et_marges_block_level_replaced_element :: fonc (ctx: *ContexteDeFormattage, base: *NoeudDeDisposition, width_of_containing_block: r64, outrepas_largeur: *ValeurDeStyle)
{
    noeud := base comme *NoeudDeDispositionRemplacement

    // The used value of 'width' is determined as for inline replaced elements.
    calcule_largeur_et_marges_inline_replaced_element(ctx, noeud, width_of_containing_block, outrepas_largeur)
    width := noeud.propriétés.donne_valeur_utilisée(IDPropriété.Width)

    // Then the rules for non-replaced block-level elements are applied to determine the margins.
    calcule_largeur_et_marges_block_level_normal_flow(ctx, noeud, width_of_containing_block, *width)
}

/* https://www.w3.org/TR/2011/REC-CSS2-20110607/visudet.html#inline-width */
calcule_largeur_et_marges_inline_non_replaced_element :: fonc (ctx: *ContexteDeFormattage @inutilisée, base: *NoeudDeDisposition, width_of_containing_block: r64 @inutilisée, outrepas_largeur: *ValeurDeStyle)
{
    noeud := base comme *NoeudDeDispositionBloc
    propriétés := noeud.propriétés
    margin_left := propriétés.donne_valeur_calculée(IDPropriété.MarginLeft)
    border_left_width := propriétés.donne_valeur_calculée(IDPropriété.BorderWidthLeft)
    padding_left := propriétés.donne_valeur_calculée(IDPropriété.PaddingLeft)
    width := propriétés.donne_valeur_calculée(IDPropriété.Width)
    si outrepas_largeur {
        width = mémoire(outrepas_largeur)
    }
    padding_right := propriétés.donne_valeur_calculée(IDPropriété.PaddingRight)
    border_right_width := propriétés.donne_valeur_calculée(IDPropriété.BorderWidthRight)
    margin_right := propriétés.donne_valeur_calculée(IDPropriété.MarginRight)

    si margin_left.est_auto() {
        margin_left = ValeurDeStyle(pixels = 0.0)
    }

    si margin_right.est_auto() {
        margin_right = ValeurDeStyle(pixels = 0.0)
    }

    /* width ne s'applique pas, mais pour éviter des problèmes plus tard, remettons la valeur à zéro */
    si width.est_auto() {
        width = ValeurDeStyle(pixels = 0.0)
    }

    propriétés.définis_valeur_utilisée(IDPropriété.MarginLeft, margin_left)
    propriétés.définis_valeur_utilisée(IDPropriété.BorderWidthLeft, border_left_width)
    propriétés.définis_valeur_utilisée(IDPropriété.PaddingLeft, padding_left)
    propriétés.définis_valeur_utilisée(IDPropriété.Width, width)
    propriétés.définis_valeur_utilisée(IDPropriété.PaddingRight, padding_right)
    propriétés.définis_valeur_utilisée(IDPropriété.BorderWidthRight, border_right_width)
    propriétés.définis_valeur_utilisée(IDPropriété.MarginRight, margin_right)
}

/* https://www.w3.org/TR/2011/REC-CSS2-20110607/visudet.html#inline-non-replaced */
calcule_hauteur_et_marges_inline_non_replaced_element :: fonc (base: *NoeudDeDisposition, outrepas_hauteur: *ValeurDeStyle)
{
    // À FAIRE : ceci est une copie des calculs pour la largeur
    noeud := base comme *NoeudDeDispositionBloc
    propriétés := noeud.propriétés
    margin_top := propriétés.donne_valeur_calculée(IDPropriété.MarginTop)
    border_top_height := propriétés.donne_valeur_calculée(IDPropriété.BorderWidthTop)
    padding_top := propriétés.donne_valeur_calculée(IDPropriété.PaddingTop)
    height := propriétés.donne_valeur_calculée(IDPropriété.Height)
    si outrepas_hauteur {
        height = mémoire(outrepas_hauteur)
    }
    padding_bottom := propriétés.donne_valeur_calculée(IDPropriété.PaddingBottom)
    border_bottom_height := propriétés.donne_valeur_calculée(IDPropriété.BorderWidthBottom)
    margin_bottom := propriétés.donne_valeur_calculée(IDPropriété.MarginBottom)

    si margin_top.est_auto() {
        margin_top = ValeurDeStyle(pixels = 0.0)
    }

    si margin_bottom.est_auto() {
        margin_bottom = ValeurDeStyle(pixels = 0.0)
    }

    /* height ne s'applique pas, mais pour éviter des problèmes plus tard, remettons la valeur à zéro */
    si height.est_auto() {
        height = ValeurDeStyle(pixels = 0.0)
    }

    propriétés.définis_valeur_utilisée(IDPropriété.MarginTop, margin_top)
    propriétés.définis_valeur_utilisée(IDPropriété.BorderWidthTop, border_top_height)
    propriétés.définis_valeur_utilisée(IDPropriété.PaddingTop, padding_top)
    propriétés.définis_valeur_utilisée(IDPropriété.Height, height)
    propriétés.définis_valeur_utilisée(IDPropriété.PaddingBottom, padding_bottom)
    propriétés.définis_valeur_utilisée(IDPropriété.BorderWidthBottom, border_bottom_height)
    propriétés.définis_valeur_utilisée(IDPropriété.MarginBottom, margin_bottom)
}

/* https://www.w3.org/TR/2011/REC-CSS2-20110607/visudet.html#inlineblock-width */
calcule_largeur_et_marges_inline_block_non_replaced_element :: fonc (ctx: *ContexteDeFormattage, base: *NoeudDeDisposition, width_of_containing_block: r64, outrepas_largeur: *ValeurDeStyle)
{
    noeud := base comme *NoeudDeDispositionBloc
    propriétés := noeud.propriétés
    margin_left := propriétés.donne_valeur_calculée(IDPropriété.MarginLeft)
    border_left_width := propriétés.donne_valeur_calculée(IDPropriété.BorderWidthLeft)
    padding_left := propriétés.donne_valeur_calculée(IDPropriété.PaddingLeft)
    width := propriétés.donne_valeur_calculée(IDPropriété.Width)
    si outrepas_largeur {
        width = mémoire(outrepas_largeur)
    }
    padding_right := propriétés.donne_valeur_calculée(IDPropriété.PaddingRight)
    border_right_width := propriétés.donne_valeur_calculée(IDPropriété.BorderWidthRight)
    margin_right := propriétés.donne_valeur_calculée(IDPropriété.MarginRight)

    box_sizing := propriétés.donne_valeur_calculée(IDPropriété.BoxSizing)
    si box_sizing.est_mot_clé(PROP_border_box) && !width.est_auto() {
        width.pixels -= border_left_width.pixels + padding_left.pixels + padding_right.pixels + border_right_width.pixels
        si width.pixels < 0 {
            width.pixels = 0
        }
    }

    /* A computed value of 'auto' for 'margin-left' or 'margin-right' becomes a used value of '0'. */
    si margin_left.est_auto() {
        margin_left = ValeurDeStyle(pixels = 0.0)
    }
    si margin_right.est_auto() {
        margin_right = ValeurDeStyle(pixels = 0.0)
    }

    /* If 'width' is 'auto', the used value is the shrink-to-fit width as for floating elements. */
    si width.est_auto() {
        available_width := width_of_containing_block - margin_left.pixels - border_left_width.pixels - padding_left.pixels - padding_right.pixels - border_right_width.pixels - margin_right.pixels
        width.pixels = calcule_shrink_to_fit_width(ctx, noeud, available_width)
    }

    propriétés.définis_valeur_utilisée(IDPropriété.MarginLeft, margin_left)
    propriétés.définis_valeur_utilisée(IDPropriété.BorderWidthLeft, border_left_width)
    propriétés.définis_valeur_utilisée(IDPropriété.PaddingLeft, padding_left)
    propriétés.définis_valeur_utilisée(IDPropriété.Width, width)
    propriétés.définis_valeur_utilisée(IDPropriété.PaddingRight, padding_right)
    propriétés.définis_valeur_utilisée(IDPropriété.BorderWidthRight, border_right_width)
    propriétés.définis_valeur_utilisée(IDPropriété.MarginRight, margin_right)
}
