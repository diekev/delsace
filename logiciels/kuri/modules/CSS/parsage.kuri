importe Chaine
importe Couleur
importe Ensemble
importe Fondation
importe Internet

/* ------------------------------------------------------------------------- */
/** \nom 5. Parsing
 * https://www.w3.org/TR/css-syntax-3/#parsing
 * \{ */

ParsedStyleSheet :: struct {
    location: URI
    value: [..]*ParsedRule
}

détruit_données_stylesheet :: fonc (stylesheet: *ParsedStyleSheet)
{
    imprime("[%] : % value(s)\n", #nom_de_cette_fonction, stylesheet.value.taille)
    pour stylesheet.value {
        détruit_tableau_component_value(*it.prelude)
        détruit_données_bloc(*it.bloc)
        
        si it.type == ParsedQualifiedRule {
            qualified := it comme *ParsedQualifiedRule
            déloge(qualified)
        }
        sinon si it.type == ParsedAtRule {
            at := it comme *ParsedAtRule
            déloge(at)
        }
        sinon {
            déloge(it)
        }
    }

    déloge(stylesheet.value)
}

ParsedRule :: struct {
    type: type_de_données
    prelude: [..]ComponentValue
    bloc: ParsedSimpleBlock
}

ParsedAtRule :: struct {
    empl rule: ParsedRule
    type = #type_de_cette_structure
    name: CSSOMString
}

ParsedQualifiedRule :: struct {
    empl rule: ParsedRule
    type = #type_de_cette_structure
}

ParsedSimpleBlock :: struct {
    token: Lexème
    value: [..]ComponentValue
}

détruit_données_bloc :: fonc (bloc: *ParsedSimpleBlock)
{
    détruit_tableau_component_value(*bloc.value)
}

ParsedDeclaration :: struct {
    name: CSSOMString
    value: [..]ComponentValue
    important: bool
}

détruit_données_déclaration :: fonc (déclaration: *ParsedDeclaration)
{
    détruit_tableau_component_value(*déclaration.value)
}

ParsedFunction :: struct {
    name: CSSOMString
    value: [..]ComponentValue
}

détruit_données_function :: fonc (function: *ParsedFunction)
{
    détruit_tableau_component_value(*function.value)
}

ComponentValue :: union {
    lexème: Lexème
    function: ParsedFunction
    bloc: ParsedSimpleBlock
}

détruit_tableau_component_value :: fonc (value: *[..]ComponentValue)
{
    tmp := mémoire(value)
    pour tmp {
        discr it {
            function(f) {
                détruit_données_function(*f)
            }
            bloc(b) {
                détruit_données_bloc(*b)
            }
            sinon {}
        }
    }

    déloge(tmp)
    mémoire(value) = tmp
}

donne_texte :: fonc (value: ComponentValue) -> CSSOMString #enligne
{
    retourne value.lexème.valeur
}

est_simple_bloc_de_genre :: fonc (value: ComponentValue, genre: GenreLexème) -> bool
{
    discr value {
        bloc(b) {
            retourne b.token.genre == genre
        }
        sinon {
            retourne faux
        }
    }
}

donne_bloc_simple :: fonc (value: ComponentValue) -> ParsedSimpleBlock
{
    retourne value.bloc
}

est_fonction :: fonc (value: ComponentValue) -> bool
{
    discr value {
        function {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_lexème_de_genre :: fonc (value: ComponentValue, genre: GenreLexème) -> bool
{
    discr value {
        lexème(l) {
            retourne est_lexème_de_genre(l, genre)
        }
        sinon {
            retourne faux
        }
    }
}

est_lexème_delim :: fonc (value: ComponentValue, point_de_code: n32) -> bool
{
    discr value {
        lexème(l) {
            retourne est_lexème_delim(l, point_de_code)
        }
        sinon {
            retourne faux
        }
    }
}

Parseuse :: struct ($T: type_de_données) {
    lexèmes: [..]T
    curseur: z64
    curseur_sauvegardé: z64
}

initialise_une_parseuse :: fonc (lexèmes: [..]$T) -> Parseuse(T)
{
    résultat: Parseuse(T)
    résultat.lexèmes = lexèmes
    retourne résultat
}

lexème_courant :: fonc (parseuse: &Parseuse($T)) -> T
{
    si parseuse.fini() {
        retourne Lexème(GenreLexème.EOF)
    }

    retourne parseuse.lexèmes[parseuse.curseur]
}

lexème_suivant :: fonc (parseuse: &Parseuse($T)) -> T
{
    retourne parseuse.lexèmes[parseuse.curseur + 1]
}

consomme_le_lexème_en_entrée_suivant :: fonc (parseuse: &Parseuse($T)) -> T
{
    résultat := parseuse.lexème_courant()
    parseuse.curseur += 1
    retourne résultat
}

reconsomme_le_lexème_courant :: fonc (parseuse: &Parseuse($T))
{
    parseuse.curseur -= 1
}

avance :: fonc (parseuse: &Parseuse($T))
{
    parseuse.curseur += 1
}

sauvegarde_position :: fonc (parseuse: &Parseuse($T))
{
    parseuse.curseur_sauvegardé = parseuse.curseur
}

restaure_position :: fonc (parseuse: &Parseuse($T))
{
    parseuse.curseur = parseuse.curseur_sauvegardé
}

consomme_espaces_blanches :: fonc (parseuse: &Parseuse($T))
{
    tantque !fini(parseuse) {
        si parseuse.lexème_courant().est_lexème_de_genre(GenreLexème.Whitespace) {
            parseuse.avance()
            continue
        }

        arrête
    }
}

apparie_lexème_ident :: fonc (parseuse: &Parseuse($T)) -> bool #enligne
{
    retourne parseuse.lexème_courant().est_lexème_de_genre(GenreLexème.Ident)
}

fini :: fonc (parseuse: &Parseuse($T)) -> bool
{
    retourne parseuse.curseur >= parseuse.lexèmes.taille
}

rapporte_erreur :: fonc (parseuse: &Parseuse($T) @inutilisée, message: chaine)
{
    imprime("%\n", message)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Parser Entry Points.
 * \{ */

/* 5.3.1 Parse something according to a CSS grammar */

/* 5.3.2 Parse A Comma-Separated List According To A CSS Grammar */

/* 5.3.3 Parse a stylesheet */
parse_a_stylesheet :: fonc (input: [..]Lexème) -> ParsedStyleSheet
{
    // 1. If input is a byte stream for stylesheet, decode bytes from input, and set input to the result.
    // 2. Normalize input, and set input to the result.

    // 3. Create a new stylesheet, with its location set to location (or null, if location was not passed).
    résultat: ParsedStyleSheet

    // 4. Consume a list of rules from input, with the top-level flag set, and set the stylesheet’s value to the result.
    parseuse := initialise_une_parseuse(input)
    résultat.value = consomme_une_liste_de_règles(parseuse, vrai)

    // 5. Return the stylesheet.
    retourne résultat
}

/* 5.3.4 Parse a list of rules */

/* 5.3.5 Parse a rule */

/* 5.3.6 Parse a declaration */

/* 5.3.7 Parse a style block’s contents */
StyleBlockContent :: struct {
    decls: [..]ParsedDeclaration
    rules: [..]*ParsedRule
}

détruit_content :: fonc (content: &StyleBlockContent)
{
    pour content.decls {
        déloge(it.value)
    }

    déloge(content.rules)
    déloge(content.decls)
}

parse_a_style_block_s_contents :: fonc (input: [..]ComponentValue) -> StyleBlockContent
{
    // 1. Normalize input, and set input to the result.
    // 2. Consume a style block’s contents from input, and return the result.
    parseuse := initialise_une_parseuse(input)
    retourne consomme_le_contenu_d_un_bloc_de_style(parseuse)
}

/* 5.3.8 Parse a list of declarations */
parse_a_list_of_declarations :: fonc (input: [..]Lexème) -> StyleBlockContent
{
    // 1. Normalize input, and set input to the result.
    // 2. Consume a list of declarations from input, and return the result.
    parseuse := initialise_une_parseuse(input)
    retourne consomme_une_liste_de_déclarations(parseuse)
}

parse_attribut_style :: fonc (valeur: ChaineUTF16) -> *CSSStyleDeclaration
{
    contenu := converti_vers_chaine(valeur)
    diffère déloge(contenu)

    lexèmes := lèxe_style(contenu)
    diffère détruit_lexèmes(*lexèmes)

    style_content := parse_a_list_of_declarations(lexèmes)
    diffère détruit_content(style_content)

    ctx: ContexteParsageFeuilleDeStyle
    diffère détruit_données_contexte(*ctx)

    résultat := parse_css_style_declaration(*ctx, style_content.decls)

    rapporte_propriétés_non_supportées(*ctx, #nom_de_cette_fonction)

    retourne résultat
}

/* 5.3.9 Parse a component value */

/* 5.3.10 Parse a list of component values */

/* 5.3.11 Parse a comma-separated list of component values */

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 5.4 Parser Algorithms.
 * https://www.w3.org/TR/css-syntax-3/#parser-algorithms
 * \{ */

/* 5.4.1 Consume a list of rules */
consomme_une_liste_de_règles :: fonc (parseuse: &Parseuse($T), top_level: bool) -> [..]*ParsedRule
{
    résultat: [..]*ParsedRule

    tantque !fini(parseuse) {
        lexème := parseuse.consomme_le_lexème_en_entrée_suivant()

        si lexème.est_lexème_de_genre(GenreLexème.Whitespace) {
            continue
        }

        si lexème.est_lexème_de_genre(GenreLexème.EOF) {
            retourne résultat
        }

        si lexème.est_lexème_de_genre(GenreLexème.CDO) || lexème.est_lexème_de_genre(GenreLexème.CDC) {
            si top_level {
                continue
            }

            parseuse.reconsomme_le_lexème_courant()

            règle := parseuse.consomme_une_règle_qualifiée()
            si règle {
                tableau_ajoute(*résultat, règle)
            }
            continue
        }

        si lexème.est_lexème_de_genre(GenreLexème.At_Keyword) {
            parseuse.reconsomme_le_lexème_courant()
            règle := parseuse.consomme_une_règle_arobase()
            tableau_ajoute(*résultat, règle)
            continue
        }

        parseuse.reconsomme_le_lexème_courant()

        règle := parseuse.consomme_une_règle_qualifiée()
        si règle {
            tableau_ajoute(*résultat, règle)
        }
    }

    retourne résultat
}

/* 5.4.2 Consume an at-rule */
consomme_une_règle_arobase :: fonc (parseuse: &Parseuse($T)) -> *ParsedAtRule
{
    _ := parseuse.consomme_le_lexème_en_entrée_suivant()

    résultat := loge(ParsedAtRule)
    résultat.name = parseuse.lexème_courant().donne_texte()
    résultat.name = résultat.name

    tantque !fini(parseuse) {
        lexème := parseuse.consomme_le_lexème_en_entrée_suivant()

        si lexème.est_lexème_de_genre(GenreLexème.Semicolon) {
            retourne résultat
        }

        si lexème.est_lexème_de_genre(GenreLexème.EOF) {
            parseuse.rapporte_erreur("fin de fichier dans une @-rule")
            retourne résultat
        }

        si lexème.est_lexème_de_genre(GenreLexème.Open_Bracket) {
            bloc := parseuse.consomme_un_bloc_simple(lexème)
            résultat.bloc = bloc
            retourne résultat
        }

        si lexème.est_simple_bloc_de_genre(GenreLexème.Open_Bracket) {
            résultat.bloc = lexème.donne_bloc_simple()
            retourne résultat
        }

        parseuse.reconsomme_le_lexème_courant()
        valeur := parseuse.consomme_une_valeur_composante()
        tableau_ajoute(*résultat.prelude, valeur)
    }

    retourne résultat
}

/* 5.4.3 Consume a qualified rule */
consomme_une_règle_qualifiée :: fonc (parseuse: &Parseuse($T)) -> *ParsedQualifiedRule
{
    résultat := loge(ParsedQualifiedRule)

    tantque !fini(parseuse) {
        lexème := parseuse.consomme_le_lexème_en_entrée_suivant()

        si lexème.est_lexème_de_genre(GenreLexème.EOF) {
            parseuse.rapporte_erreur("fin de fichier dans une qualified-rule")
            // À FAIRE détruit le résultat
            retourne nul
        }

        si lexème.est_lexème_de_genre(GenreLexème.Open_Bracket) {
            bloc := parseuse.consomme_un_bloc_simple(lexème)
            résultat.bloc = bloc
            retourne résultat
        }

        si lexème.est_simple_bloc_de_genre(GenreLexème.Open_Bracket) {
            résultat.bloc = lexème.donne_bloc_simple()
            retourne résultat
        }

        parseuse.reconsomme_le_lexème_courant()
        valeur := parseuse.consomme_une_valeur_composante()
        tableau_ajoute(*résultat.prelude, valeur)
    }

    retourne résultat
}

/* 5.4.4 Consume a style block’s contents */
consomme_le_contenu_d_un_bloc_de_style :: fonc (parseuse: &Parseuse($T)) -> StyleBlockContent
{
    decls: [..]ParsedDeclaration
    rules: [..]*ParsedRule

    tantque !fini(parseuse) {
        lexème := parseuse.consomme_le_lexème_en_entrée_suivant()

        si lexème.est_lexème_de_genre(GenreLexème.Whitespace) || lexème.est_lexème_de_genre(GenreLexème.Semicolon) {
            continue
        }

        si lexème.est_lexème_de_genre(GenreLexème.EOF) {
            // Extend decls with rules, then return decls.
            arrête
        }

        si lexème.est_lexème_de_genre(GenreLexème.At_Keyword) {
            parseuse.reconsomme_le_lexème_courant()
            rule := consomme_une_règle_arobase(parseuse)
            tableau_ajoute(*rules, rule)
            continue
        }

        si lexème.est_lexème_de_genre(GenreLexème.Ident) {
            // Initialize a temporary list initially filled with the current input token.
            temp: [..]T
            tableau_ajoute(*temp, lexème)

            // As long as the next input token is anything other than a <semicolon-token>
            // or <EOF-token>, consume a component value and append it to the temporary list.
            tantque !fini(parseuse) {
                lexème = parseuse.lexème_courant()

                si lexème.est_lexème_de_genre(GenreLexème.EOF) || lexème.est_lexème_de_genre(GenreLexème.Semicolon) {
                    arrête
                }

                tableau_ajoute(*temp, lexème)
                parseuse.avance()
            }

            // Consume a declaration from the temporary list.
            // If anything was returned, append it to decls.
            parseuse_decl := initialise_une_parseuse(temp)
            decl := consomme_une_déclaration(parseuse_decl)
            si decl.possède_valeur() {
                tableau_ajoute(*decls, decl.Quelque)
            }

            // @Performance
            déloge(temp)
            continue
        }

        si lexème.est_lexème_esperluette() {
            parseuse.reconsomme_le_lexème_courant()
            rule := consomme_une_règle_qualifiée(parseuse)
            si rule {
                tableau_ajoute(*rules, rule)
            }
            continue
        }

        /* Anything else.
         * This is a parse error. Reconsume the current input token.
         * As long as the next input token is anything other than a
         * <semicolon-token> or <EOF-token>, consume a component value
         * and throw away the returned value. */
        tantque !fini(parseuse) {
            lexème = parseuse.lexème_courant()
            si lexème.est_lexème_de_genre(GenreLexème.EOF) || lexème.est_lexème_de_genre(GenreLexème.Semicolon) {
                arrête
            }
            parseuse.avance()
        }
    }

    retourne StyleBlockContent(decls, rules)
}

/* 5.4.5 Consume a list of declarations */
consomme_une_liste_de_déclarations :: fonc (parseuse: &Parseuse($T)) -> StyleBlockContent
{
    // Create an initially empty list of declarations.
    decls: [..]ParsedDeclaration
    rules: [..]*ParsedRule

    tantque !fini(parseuse) {
        lexème := parseuse.consomme_le_lexème_en_entrée_suivant()

        si lexème.est_lexème_de_genre(GenreLexème.Whitespace) || lexème.est_lexème_de_genre(GenreLexème.Semicolon) {
            continue
        }

        si lexème.est_lexème_de_genre(GenreLexème.EOF) {
            arrête
        }

        si lexème.est_lexème_de_genre(GenreLexème.At_Keyword) {
            parseuse.reconsomme_le_lexème_courant()
            rule := parseuse.consomme_une_règle_arobase()
            si rule {
                tableau_ajoute(*rules, rule)
            }
            continue
        }

        si lexème.est_lexème_de_genre(GenreLexème.Ident) {
            // Initialize a temporary list initially filled with the current input token.
            temp: [..]T
            tableau_ajoute(*temp, lexème)

            // As long as the next input token is anything other than a <semicolon-token>
            // or <EOF-token>, consume a component value and append it to the temporary list.
            tantque !fini(parseuse) {
                lexème = parseuse.lexème_courant()

                si lexème.est_lexème_de_genre(GenreLexème.EOF) || lexème.est_lexème_de_genre(GenreLexème.Semicolon) {
                    arrête
                }

                tableau_ajoute(*temp, lexème)
                parseuse.avance()
            }

            // Consume a declaration from the temporary list.
            // If anything was returned, append it to the list of declarations.
            parseuse_decl := initialise_une_parseuse(temp)
            decl := consomme_une_déclaration(parseuse_decl)
            si decl.possède_valeur() {
                tableau_ajoute(*decls, decl.Quelque)
            }

            // @Performance
            déloge(temp)
            continue
        }

        // This is a parse error.
        // Reconsume the current input token.
        // As long as the next input token is anything other than a <semicolon-token> or <EOF-token>,
        // consume a component value and throw away the returned value.
        parseuse.reconsomme_le_lexème_courant()
        tantque !fini(parseuse) {
            lexème = parseuse.lexème_courant()
            si lexème.est_lexème_de_genre(GenreLexème.EOF) || lexème.est_lexème_de_genre(GenreLexème.Semicolon) {
                arrête
            }
            parseuse.avance()
        }
    }

    retourne StyleBlockContent(decls, rules)
}

/* 5.4.6 Consume a declaration */
consomme_une_déclaration :: fonc (parseuse: &Parseuse($T)) -> Optionnel(ParsedDeclaration)
{
    lexème := parseuse.consomme_le_lexème_en_entrée_suivant()

    résultat: ParsedDeclaration
    résultat.name = lexème.donne_texte()

    // 1. While the next input token is a <whitespace-token>, consume the next input token.
    consomme_espaces_blanches(parseuse)

    // 2. If the next input token is anything other than a <colon-token>, this is a parse error. Return nothing.
    //    Otherwise, consume the next input token.
    saufsi parseuse.lexème_courant().est_lexème_de_genre(GenreLexème.Colon) {
        retourne
    }
    parseuse.avance()

    // 3. While the next input token is a <whitespace-token>, consume the next input token.
    consomme_espaces_blanches(parseuse)

    // 4. As long as the next input token is anything other than an <EOF-token>, consume a component value and append it to the declaration’s value.
    value: [..]ComponentValue
    tantque !fini(parseuse) {
        lexème = parseuse.lexème_courant()
        si lexème.est_lexème_de_genre(GenreLexème.EOF) {
            arrête
        }

        tableau_ajoute(*value, lexème)
        parseuse.avance()
    }

    // 5. If the last two non-<whitespace-token>s in the declaration’s value are a <delim-token>
    // with the value "!" followed by an <ident-token> with a value that is an ASCII case-insensitive
    // match for "important", remove them from the declaration’s value and set the declaration’s
    // important flag to true.
    supprime_espaces_blanches_en_fin(*value)
    si value.taille > 2 {
        i0 := value.taille - 2
        i1 := value.taille - 1

        si value[i0].est_lexème_exclamation() && value[i1].est_lexème_de_genre(GenreLexème.Ident) && compare_ascii_insensible_à_la_casse(value[i1].lexème.valeur, "important") {
            value.taille -= 2
            résultat.important = vrai
        }
    }

    // 6. While the last token in the declaration’s value is a <whitespace-token>, remove that token.
    supprime_espaces_blanches_en_fin(*value)

    // 7. Return the declaration.
    résultat.value = value
    retourne résultat
}

supprime_espaces_blanches_en_fin :: fonc (value: *[..]ComponentValue)
{
    nombre_d_espaces_blanches := 0
    pour > mémoire(value) {
        saufsi it.est_lexème_de_genre(GenreLexème.Whitespace) {
            arrête
        }
        nombre_d_espaces_blanches += 1
    }

    value.taille -= nombre_d_espaces_blanches
    assert(value.taille >= 0)
}

/* 5.4.7 Consume a component value */
consomme_une_valeur_composante :: fonc (parseuse: &Parseuse($T)) -> ComponentValue
{
    lexème := parseuse.consomme_le_lexème_en_entrée_suivant()

    si lexème.est_lexème_de_genre(GenreLexème.Open_Bracket) || lexème.est_lexème_de_genre(GenreLexème.Open_Square_Bracket) || lexème.est_lexème_de_genre(GenreLexème.Open_Parenthesis) {
        retourne parseuse.consomme_un_bloc_simple(lexème)
    }

    si lexème.est_lexème_de_genre(GenreLexème.Function) {
        retourne parseuse.consomme_une_fonction(lexème)
    }

    // XXX - parseuse.lexème_courant() ?
    retourne lexème
}

donne_genre_lexème_mirroir :: fonc (lexème: Lexème) -> GenreLexème
{
    si lexème.est_lexème_de_genre(GenreLexème.Open_Bracket) {
        retourne GenreLexème.Close_Bracket
    }
    si lexème.est_lexème_de_genre(GenreLexème.Open_Square_Bracket) {
        retourne GenreLexème.Close_Square_Bracket
    }
    assert(lexème.est_lexème_de_genre(GenreLexème.Open_Parenthesis))
    retourne GenreLexème.Close_Parenthesis
}

/* 5.4.8 Consume a simple block */
consomme_un_bloc_simple :: fonc (parseuse: &Parseuse($T), lexème_associé: T) -> ParsedSimpleBlock
{
    genre_lexème_fin := donne_genre_lexème_mirroir(lexème_associé)

    résultat: ParsedSimpleBlock
    résultat.token = lexème_associé

    tantque !fini(parseuse) {
        lexème := parseuse.consomme_le_lexème_en_entrée_suivant()

        si lexème.est_lexème_de_genre(genre_lexème_fin) {
            retourne résultat
        }

        si lexème.est_lexème_de_genre(GenreLexème.EOF) {
            parseuse.rapporte_erreur("fin de fichier dans un bloc simple")
            retourne résultat
        }

        parseuse.reconsomme_le_lexème_courant()
        valeur := parseuse.consomme_une_valeur_composante()
        tableau_ajoute(*résultat.value, valeur)
    }

    retourne résultat
}

/* 5.4.9 Consume a function */
consomme_une_fonction :: fonc (parseuse: &Parseuse($T), lexème_function: T) -> ParsedFunction
{
    résultat: ParsedFunction
    résultat.name = lexème_function.donne_texte()
    résultat.name = résultat.name

    tantque !fini(parseuse) {
        lexème := parseuse.consomme_le_lexème_en_entrée_suivant()

        si lexème.est_lexème_de_genre(GenreLexème.Close_Parenthesis) {
            retourne résultat
        }

        si lexème.est_lexème_de_genre(GenreLexème.EOF) {
            parseuse.rapporte_erreur("fin de fichier dans une fonction")
            retourne résultat
        }

        parseuse.reconsomme_le_lexème_courant()
        valeur := parseuse.consomme_une_valeur_composante()
        tableau_ajoute(*résultat.value, valeur)
    }

    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Selectors.
 * https://www.w3.org/TR/selectors-4/#grammar
 * \{ */

ParseuseSelector :: Parseuse(ComponentValue)

/* <selector-list> = <complex-selector-list> */
parse_selector_list :: fonc (prelude: [..]ComponentValue) -> Optionnel(SelectorList)
{
    parseuse := initialise_une_parseuse(prelude)
    retourne parse_selector_list(parseuse)
}

parse_selector_list :: fonc (parseuse: &ParseuseSelector) -> Optionnel(SelectorList)
{
    // imprime("---------------------------\n[%]\n", #nom_de_cette_fonction)
    résultat: SelectorList
    parse_complex_selector_list(parseuse, *résultat)
    retourne résultat
}

/* <complex-selector-list> = <complex-selector># */
parse_complex_selector_list :: fonc (parseuse: &ParseuseSelector, list: *SelectorList)
{
    consomme_espaces_blanches(parseuse)

    // imprime("[%]\n", #nom_de_cette_fonction)
    tantque !fini(parseuse) {
        complex := parse_complex_selector(parseuse)
        saufsi complex.possède_valeur() {
            arrête
        }

        tableau_ajoute(*list.complex_selectors, complex.Quelque)

        saufsi parseuse.lexème_courant().est_lexème_de_genre(GenreLexème.Comma) {
            arrête
        }

        // imprime("-- virgule\n")
        _ := parseuse.consomme_le_lexème_en_entrée_suivant()
    }

    consomme_espaces_blanches(parseuse)
}

/* <complex-selector> = <compound-selector> [ <combinator>? <compound-selector> ]* */
parse_complex_selector :: fonc (parseuse: &ParseuseSelector) -> Optionnel(ComplexSelector)
{
    consomme_espaces_blanches(parseuse)

    résultat: ComplexSelector

    // imprime("[%]\n", #nom_de_cette_fonction)
    combinateur_courant: Optionnel(Combinator)

    tantque !fini(parseuse) {
        opt_compound := parse_compound_selector(parseuse)
        saufsi opt_compound.possède_valeur() {
            arrête
        }

        compound := opt_compound.Quelque

        si combinateur_courant.possède_valeur() {
            compound.combinateur = combinateur_courant.Quelque
        }

        tableau_ajoute(*résultat.compound_selectors, compound)

        combinateur_courant = parseuse.parse_combinateur()
        saufsi combinateur_courant.possède_valeur() {
            arrête
        }
    }

    consomme_espaces_blanches(parseuse)

    si résultat.compound_selectors.taille == 0 {
        retourne
    }

    retourne résultat
}

/* <compound-selector>  = [ <type-selector>? <subclass-selector>*
 *                        [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]! */
parse_compound_selector :: fonc (parseuse: &ParseuseSelector) -> Optionnel(CompoundSelector)
{
    // imprime("[%]\n", #nom_de_cette_fonction)

    résultat: CompoundSelector

    // imprime("-- position : %\n", parseuse.curseur)

    /* <type-selector>? */
    type_selector := parseuse.parse_type_selector()
    si type_selector.possède_valeur() {
        // imprime("-- %\n", type_selector.Quelque)
        tableau_ajoute(*résultat.simple_selectors, type_selector.Quelque)
    }

    /* <subclass-selector>* */
    tantque !fini(parseuse) {
        subclass_selector := parseuse.parse_subclass_selector()
        saufsi subclass_selector.possède_valeur() {
            arrête
        }

        // imprime("-- %\n", subclass_selector.Quelque)
        tableau_ajoute(*résultat.simple_selectors, subclass_selector.Quelque)
    }

    /* [ <pseudo-element-selector> <pseudo-class-selector>* ]* */
    tantque !fini(parseuse) {
        pseudo_element_selector := parseuse.parse_pseudo_element_selector()
        saufsi pseudo_element_selector.possède_valeur() {
            arrête
        }
        // imprime("-- %\n", pseudo_element_selector.Quelque)
        tableau_ajoute(*résultat.simple_selectors, pseudo_element_selector.Quelque)

        tantque !fini(parseuse) {
            subclass_selector := parseuse.parse_subclass_selector()
            saufsi subclass_selector.possède_valeur() {
                arrête
            }

            // imprime("-- %\n", subclass_selector.Quelque)
            tableau_ajoute(*résultat.simple_selectors, subclass_selector.Quelque)
        }
    }

    // imprime("-- position : %\n", parseuse.curseur)

    si résultat.simple_selectors.taille == 0 {
        retourne
    }

    retourne résultat
}

/* <type-selector> = <wq-name> | <ns-prefix>? '*' */
parse_type_selector :: fonc (parseuse: &ParseuseSelector) -> Optionnel(SimpleSelector)
{
    parseuse_locale : ParseuseSelector = parseuse

    opt_wq_name := parseuse_locale.parse_wq_name()
    si opt_wq_name.possède_valeur() {
        wq_name := opt_wq_name.Quelque

        espace_de_nom := crée_chaine_utf16_unique_vide()
        si wq_name.ns_prefix.possède_valeur() {
            espace_de_nom = wq_name.ns_prefix.Quelque.espace
        }

        parseuse.curseur = parseuse_locale.curseur
        retourne crée_type_selector(espace_de_nom, wq_name.ident)
    }

    parseuse_locale = parseuse

    ns_prefix := parseuse_locale.parse_ns_prefix()
    saufsi ns_prefix.possède_valeur() {
        parseuse_locale = parseuse
    }

    si parseuse_locale.lexème_courant().est_lexème_fois() {
        parseuse.curseur = parseuse_locale.curseur
        retourne crée_universal_selector(crée_chaine_utf16_unique_vide())
    }
}

/* <wq-name> = <ns-prefix>? <ident-token> */
WQName :: struct {
    ns_prefix: Optionnel(NSPrefix)
    ident := crée_chaine_utf16_unique_vide()
}

parse_wq_name :: fonc (parseuse: &ParseuseSelector) -> Optionnel(WQName)
{
    résultat: WQName
    
    parseuse_locale : ParseuseSelector = parseuse
    résultat.ns_prefix = parseuse_locale.parse_ns_prefix()

    saufsi résultat.ns_prefix.possède_valeur() {
        parseuse_locale = parseuse
    }

    si parseuse_locale.apparie_lexème_ident() {
        résultat.ident = parseuse_locale.lexème_courant().lexème.valeur
        parseuse_locale.avance()

        parseuse.curseur = parseuse_locale.curseur
        retourne résultat
    }
}

/* <ns-prefix> = [ <ident-token> | '*' ]? '|' */
NSPrefix :: struct {
    /* Un identifiant ou '*' */
    espace := crée_chaine_utf16_unique_vide()
}

parse_ns_prefix :: fonc (parseuse: &ParseuseSelector) -> Optionnel(NSPrefix)
{
    résultat: NSPrefix

    si parseuse.apparie_lexème_ident() {
        résultat.espace = parseuse.lexème_courant().lexème.valeur
        parseuse.avance()
    }
    sinon si parseuse.lexème_courant().est_lexème_fois() {
        résultat.espace = ChaineUTF16Unique('*' comme n32)
        parseuse.avance()
    }

    si parseuse.lexème_courant().est_lexème_pipe() {
        parseuse.avance()
        retourne résultat
    }
}

/* <subclass-selector> = <id-selector> | <class-selector> |
                      <attribute-selector> | <pseudo-class-selector> */
parse_subclass_selector :: fonc (parseuse: &ParseuseSelector) -> Optionnel(SimpleSelector)
{
    opt_id_selector := parseuse.parse_id_selector()
    si opt_id_selector.possède_valeur() {
        retourne opt_id_selector
    }

    opt_class_selector := parseuse.parse_class_selector()
    si opt_class_selector.possède_valeur() {
        retourne opt_class_selector
    }

    opt_attribute_selector := parseuse.parse_attribute_selector()
    si opt_attribute_selector.possède_valeur() {
        retourne opt_attribute_selector
    }

    opt_pseudo_class_selector := parseuse.parse_pseudo_class_selector(faux)
    si opt_pseudo_class_selector.possède_valeur() {
        retourne opt_pseudo_class_selector
    }
}

/* <id-selector> = <hash-token> */
parse_id_selector :: fonc (parseuse: &ParseuseSelector) -> Optionnel(SimpleSelector)
{
    lexème := parseuse.lexème_courant()
    saufsi lexème.est_lexème_de_genre(GenreLexème.Hash) {
        retourne
    }

    si lexème.lexème.valeur.donne_chaine_utf16().taille() == 0 {
        retourne
    }

    parseuse.avance()
    retourne crée_id_selector(lexème.lexème.valeur)
}

/* <class-selector> = '.' <ident-token> */
parse_class_selector :: fonc (parseuse: &ParseuseSelector) -> Optionnel(SimpleSelector)
{
    parseuse_locale : ParseuseSelector = parseuse

    lexème := parseuse_locale.lexème_courant()
    saufsi lexème.est_lexème_point() {
        retourne
    }
    parseuse_locale.avance()

    saufsi parseuse_locale.apparie_lexème_ident() {
        retourne
    }

    ident := parseuse_locale.lexème_courant().lexème.valeur
    parseuse_locale.avance()

    parseuse.curseur = parseuse_locale.curseur
    retourne crée_class_selector(ident)
}

/* <attribute-selector> = '[' <wq-name> ']' |
 *                        '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
 * <attr-modifier> = i | s */
parse_attribute_selector :: fonc (parseuse: &ParseuseSelector) -> Optionnel(SimpleSelector)
{
    saufsi parseuse.lexème_courant().est_simple_bloc_de_genre(GenreLexème.Open_Square_Bracket) {
        retourne
    }

    bloc := parseuse.lexème_courant().bloc

    parseuse_locale := initialise_une_parseuse(bloc.value)

    opt_wq_name := parseuse_locale.parse_wq_name()
    saufsi opt_wq_name.possède_valeur() {
        parseuse_locale.rapporte_erreur("wq_name invalide pour le selécteur d'attribut")
        retourne
    }
    wq_name := opt_wq_name.Quelque

    espace_de_nom := crée_chaine_utf16_unique_vide()
    si wq_name.ns_prefix.possède_valeur() {
        espace_de_nom = wq_name.ns_prefix.Quelque.espace
    }
    
    si parseuse_locale.fini() {
        parseuse.avance()
        retourne crée_attribute_selector(espace_de_nom, wq_name.ident)
    }

    matcher := parseuse_locale.parse_attribute_matcher()
    saufsi matcher.possède_valeur() {
        parseuse_locale.rapporte_erreur("matcher invalide")
        retourne
    }

    lexème_courant := parseuse_locale.lexème_courant()
    attribute_value: CSSOMString

    si lexème_courant.est_lexème_de_genre(GenreLexème.String) || lexème_courant.est_lexème_de_genre(GenreLexème.Ident) {
        attribute_value = lexème_courant.lexème.valeur
        parseuse_locale.avance()
    }
    sinon {
        parseuse_locale.rapporte_erreur("Attendu une chaine ou un identifiant pour la valeur de l'attribut")
        retourne
    }

    parseuse_locale.consomme_espaces_blanches()

    lexème_courant = parseuse_locale.lexème_courant()
    modifier: Optionnel(SimpleSelector.AttributeModifier)

    si lexème_courant.est_lexème_de_genre(GenreLexème.Ident) {
        valeur := lexème_courant.lexème.valeur

        si valeur.valeur == ('i' comme n32) || valeur.valeur == ('I' comme n32) {
            modifier = SimpleSelector.AttributeModifier.I
        }
        sinon si valeur.valeur == ('s' comme n32) || valeur.valeur == ('S' comme n32) {
            modifier = SimpleSelector.AttributeModifier.S
        }
        sinon {
            // erreur
            retourne
        }
    }
    sinon si !parseuse_locale.fini() {
        parseuse_locale.rapporte_erreur("Attendu un i ou s")
        retourne
    }

    parseuse.avance()
    retourne crée_attribute_selector(espace_de_nom, wq_name.ident, matcher.Quelque, attribute_value, modifier)
}

/* <attr-matcher> = [ '~' | '|' | '^' | '$' | '*' ]? '=' */
parse_attribute_matcher :: fonc (parseuse: &ParseuseSelector) -> Optionnel(SimpleSelector.AttributeMatcher)
{
    matcher: Optionnel(SimpleSelector.AttributeMatcher)

    lexème_courant := parseuse.lexème_courant()

    si lexème_courant.est_lexème_tilde() {
        matcher = SimpleSelector.AttributeMatcher.INCLUS
        parseuse.avance()
    }
    sinon si lexème_courant.est_lexème_pipe() {
        matcher = SimpleSelector.AttributeMatcher.DASHMATCH
        parseuse.avance()
    }
    sinon si lexème_courant.est_lexème_circonflèxe() {
        matcher = SimpleSelector.AttributeMatcher.PREFIXMATCH
        parseuse.avance()
    }
    sinon si lexème_courant.est_lexème_dollar() {
        matcher = SimpleSelector.AttributeMatcher.SUFFIXMATCH
        parseuse.avance()
    }
    sinon si lexème_courant.est_lexème_fois() {
        matcher = SimpleSelector.AttributeMatcher.SUBSTRINGMATCH
        parseuse.avance()
    }

    lexème_courant = parseuse.lexème_courant()

    saufsi lexème_courant.est_lexème_égal() {
        parseuse.rapporte_erreur("Attendu '=' pour le matcher")
        retourne
    }
    parseuse.avance()

    saufsi matcher.possède_valeur() {
        matcher = SimpleSelector.AttributeMatcher.EST_ÉGAL
    }

    retourne matcher
}

/* <pseudo-class-selector> = ':' <ident-token> |
                             ':' <function-token> <any-value> ')' */
parse_pseudo_class_selector :: fonc (parseuse: &ParseuseSelector, pour_pseudo_element: bool) -> Optionnel(SimpleSelector)
{
    parseuse_locale : ParseuseSelector = parseuse

    saufsi parseuse_locale.lexème_courant().est_lexème_de_genre(GenreLexème.Colon) {
        retourne
    }

    parseuse_locale.avance()
    si parseuse_locale.apparie_lexème_ident() {
        ident := parseuse_locale.lexème_courant().lexème.valeur
        parseuse_locale.avance()

        parseuse.curseur = parseuse_locale.curseur

        /* Pour ces pseudo-classes, nous changeons le type en pseudo-élément
         * directement au cas où nous ne serions pas appelés depuis
         * parse_pseudo_element car il est possible de n'avoir qu'un seul
         * double point pour ceux-ci pour des raisons historiques. */
        si pour_pseudo_element || ident == PROP_before || ident == PROP_after || ident == PROP_first_line || ident == PROP_first_letter {
            retourne crée_pseudo_element_selector(ident)
        }

        retourne crée_pseudo_class_selector(ident)
    }

    si parseuse_locale.lexème_courant().est_fonction() {
        fonction := parseuse_locale.lexème_courant().function
        nom_fonction := fonction.name

        /* https://www.w3.org/TR/selectors-4/#negation */
        si nom_fonction == PROP_not {
            parseuse_locale.avance()

            opt_selectors := parse_selector_list(fonction.value)
            si opt_selectors.possède_valeur() {
                parseuse.curseur = parseuse_locale.curseur
                retourne crée_function_selector(nom_fonction, opt_selectors.Quelque)
            }
        }
        /* https://www.w3.org/TR/selectors-4/#matches */
        sinon si nom_fonction == PROP_is {
            parseuse_locale.avance()

            /* À FAIRE : ceci doit être parse_forgiving_selector_list */
            opt_selectors := parse_selector_list(fonction.value)
            si opt_selectors.possède_valeur() {
                parseuse.curseur = parseuse_locale.curseur
                retourne crée_function_selector(nom_fonction, opt_selectors.Quelque)
            }
        }
        /* https://www.w3.org/TR/selectors-4/#zero-matches */
        sinon si nom_fonction == PROP_where {
            parseuse_locale.avance()

            /* À FAIRE : ceci doit être parse_forgiving_selector_list */
            opt_selectors := parse_selector_list(fonction.value)
            si opt_selectors.possède_valeur() {
                parseuse.curseur = parseuse_locale.curseur
                retourne crée_function_selector(nom_fonction, opt_selectors.Quelque)
            }
        }
        /* https://www.w3.org/TR/css-scoping-1/#selectordef-host0 */
        sinon si nom_fonction == PROP_host {
            parseuse_locale.avance()

            /* À FAIRE : ceci doit être parse_compound_selector */
            opt_selectors := parse_selector_list(fonction.value)
            si opt_selectors.possède_valeur() {
                parseuse.curseur = parseuse_locale.curseur
                retourne crée_function_selector(nom_fonction, opt_selectors.Quelque)
            }
        }
        /* https://www.w3.org/TR/selectors-4/#the-dir-pseudo */
        sinon si nom_fonction == PROP_dir {
            parseuse_locale.avance()

            si fonction.value.taille == 1 && fonction.value[0].est_lexème_de_genre(GenreLexème.Ident) {
                nom := fonction.value[0].lexème.valeur
                si nom == PROP_ltr || nom == PROP_rtl {
                    parseuse.curseur = parseuse_locale.curseur
                    retourne crée_function_selector(nom_fonction, nom)
                }
            }
        }
        sinon {
            imprime("fonction non supporté : %\n", nom_fonction)
        }

        retourne
    }
}

/* <pseudo-element-selector> = ':' <pseudo-class-selector> */
parse_pseudo_element_selector :: fonc (parseuse: &ParseuseSelector) -> Optionnel(SimpleSelector)
{
    parseuse_locale : ParseuseSelector = parseuse

    saufsi parseuse_locale.lexème_courant().est_lexème_de_genre(GenreLexème.Colon) {
        retourne
    }

    parseuse_locale.avance()

    pseudo_class := parseuse_locale.parse_pseudo_class_selector(vrai)
    si pseudo_class.possède_valeur() {
        parseuse.curseur = parseuse_locale.curseur
        retourne pseudo_class
    }
}

/* <combinator> = '>' | '+' | '~' | [ '|' '|' ] */
parse_combinateur :: fonc (parseuse: &ParseuseSelector) -> Optionnel(Combinator)
{
    // imprime("[%]\n", #nom_de_cette_fonction)

    résultat: Optionnel(Combinator)

    si parseuse.lexème_courant().est_lexème_de_genre(GenreLexème.Whitespace) {
        /* À FAIRE : nouvelle ligne ? */
        résultat = Combinator.DESCENDANT
    }

    consomme_espaces_blanches(parseuse)

    si parseuse.fini() {
        retourne
    }

    lexème := parseuse.lexème_courant()

    si lexème.est_lexème_greater() {
        parseuse.avance()
        résultat = Combinator.CHILD
    }
    sinon si lexème.est_lexème_plus() {
        parseuse.avance()
        résultat = Combinator.NEXT_SIBLING
    }
    sinon si lexème.est_lexème_tilde() {
        parseuse.avance()
        résultat = Combinator.SUBSEQUENT_SIBLING
    }
    sinon si lexème.est_lexème_pipe() {
        parseuse.avance()
        lexème = parseuse.lexème_courant()
        si lexème.est_lexème_pipe() {
            parseuse.avance()
            résultat = Combinator.COLUMN
        }
        sinon {
            // erreur de parsage
            retourne
        }
    }

    consomme_espaces_blanches(parseuse)
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Parsage de feuilles de style.
 * \{ */

ContexteParsageFeuilleDeStyle :: struct {
    propriétés_non_supportées: [..]CSSOMString
}

rapporte_propriétés_non_supportées :: fonc (ctx: *ContexteParsageFeuilleDeStyle, fonction: chaine)
{
    pour ctx.propriétés_non_supportées {
        imprime("[CSS][%] propriété non-supportée : %\n", fonction, it)
    }
}

détruit_données_contexte :: fonc (ctx: *ContexteParsageFeuilleDeStyle)
{
    déloge(ctx.propriétés_non_supportées)
}

donne_info_type_pour_nom :: fonc (ctx: *ContexteParsageFeuilleDeStyle, nom: CSSOMString) -> *InfoTypePropriété
{
    résultat := donne_info_type_pour_nom(nom)
    saufsi résultat {
        ensemble_ajoute(*ctx.propriétés_non_supportées, nom)
    }
    retourne résultat
}

/* https://www.w3.org/TR/css-syntax-3/#parse-a-css-stylesheet */
parse_a_css_style_sheet :: fonc (ctx: *ContexteParsageFeuilleDeStyle, contenu: chaine) -> *CSSStyleSheet
{
    résultat := loge(CSSStyleSheet)
    résultat.type = crée_chaine_utf16_unique("text/css")

    parse_style_rules(ctx, résultat, contenu)

    retourne résultat
}

parse_style_rules :: fonc (ctx: *ContexteParsageFeuilleDeStyle, css_stylesheet: *CSSStyleSheet, contenu: chaine)
{
    lexèmes := lèxe_style(contenu)
    diffère détruit_lexèmes(*lexèmes)

    stylesheet := parse_a_stylesheet(lexèmes)
    diffère détruit_données_stylesheet(*stylesheet)

    pour stylesheet.value {
        si it.type == ParsedQualifiedRule {
            parse_a_style_rule(ctx, css_stylesheet, it comme *ParsedQualifiedRule)
        }
    }
}

/* https://www.w3.org/TR/css-syntax-3/#style-rules */
parse_a_style_rule :: fonc (ctx: *ContexteParsageFeuilleDeStyle, parent_style_sheet: *CSSStyleSheet, parsed_rule: *ParsedQualifiedRule)
{
    selectors := parse_selector_list(parsed_rule.prelude)
    saufsi selectors.possède_valeur() {
        /* Si nous n'arrivons pas à parser les sélecteurs,
         * nous devons ignorer la règle. */
        retourne
    }

    résultat := loge(CSSStyleRule)
    résultat.parent_style_sheet = parent_style_sheet
    résultat.selector_list = selectors.Quelque

    content := parse_a_style_block_s_contents(parsed_rule.bloc.value)
    diffère détruit_content(content)

    /* Ne considère que les déclarations.
     * À FAIRE : @nest peut être préservé. */
    style := parse_css_style_declaration(ctx, content.decls)
    résultat.style = style
    style.parent_css_rule = résultat

    si style.déclarations.taille == 0 {
        détruit_style_rule(résultat)
        retourne
    }

    tableau_ajoute(*parent_style_sheet.rules, résultat)
}

parse_css_style_declaration :: fonc (ctx: *ContexteParsageFeuilleDeStyle, déclarations: []ParsedDeclaration) -> *CSSStyleDeclaration
{
    résultat := loge(CSSStyleDeclaration)

    pour déclarations {
        info_type_propriété := donne_info_type_pour_nom(ctx, it.name)
        saufsi info_type_propriété {
            continue
        }

        opt_valeur := info_type_propriété.fonction_de_parsage(it.value)
        saufsi opt_valeur.possède_valeur() {
            imprime("Impossible de parser '%'\n", it.name)
            continue
        }

        déclaration := loge(DéclarationPropriété)
        déclaration.info = info_type_propriété
        déclaration.property_name = it.name
        déclaration.value = opt_valeur.Quelque
        déclaration.important = it.important

        résultat.ajoute_déclaration(déclaration)
    }

    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom InfoTypePropriété
 * \{ */

#portée_module

PropriétéHéritable :: énum n8 {
    Oui
    Non
}

InfoTypePropriété :: struct {
    nom: CSSOMString
    fonction_de_parsage: fonc([..]ComponentValue)(Optionnel([..]ValeurDeStyle))
    héritable: PropriétéHéritable
}

infos_types_propriétés := [
    InfoTypePropriété(PROP_display, parse_propriété_display, PropriétéHéritable.Non),
    InfoTypePropriété(PROP_background, parse_propriété_color, PropriétéHéritable.Non),
    InfoTypePropriété(PROP_background_color, parse_propriété_color, PropriétéHéritable.Non),
    InfoTypePropriété(PROP_color, parse_propriété_color, PropriétéHéritable.Oui),
    InfoTypePropriété(PROP_text_decoration, parse_propriété_text_decoration, PropriétéHéritable.Non),
    InfoTypePropriété(PROP_cursor, parse_propriété_cursor, PropriétéHéritable.Oui),
    InfoTypePropriété(PROP_font_weight, parse_propriété_font_weight, PropriétéHéritable.Oui),
    InfoTypePropriété(PROP_font_size, parse_propriété_font_size, PropriétéHéritable.Oui),
    InfoTypePropriété(PROP_font_style, parse_propriété_font_style, PropriétéHéritable.Oui),
    InfoTypePropriété(PROP_border_color, parse_propriété_border_color, PropriétéHéritable.Non),
    InfoTypePropriété(PROP_border_top_color, parse_propriété_color, PropriétéHéritable.Non),
    InfoTypePropriété(PROP_border_left_color, parse_propriété_color, PropriétéHéritable.Non),
    InfoTypePropriété(PROP_border_bottom_color, parse_propriété_color, PropriétéHéritable.Non),
    InfoTypePropriété(PROP_border_right_color, parse_propriété_color, PropriétéHéritable.Non),
    InfoTypePropriété(PROP_border, parse_propriété_border, PropriétéHéritable.Non),
    InfoTypePropriété(PROP_border_top, parse_propriété_border, PropriétéHéritable.Non),
    InfoTypePropriété(PROP_border_left, parse_propriété_border, PropriétéHéritable.Non),
    InfoTypePropriété(PROP_border_bottom, parse_propriété_border, PropriétéHéritable.Non),
    InfoTypePropriété(PROP_border_right, parse_propriété_border, PropriétéHéritable.Non),
    InfoTypePropriété(PROP_border_style, parse_propriété_border_style, PropriétéHéritable.Non),
    InfoTypePropriété(PROP_border_top_style, parse_propriété_border_line_style, PropriétéHéritable.Non),
    InfoTypePropriété(PROP_border_bottom_style, parse_propriété_border_line_style, PropriétéHéritable.Non),
    InfoTypePropriété(PROP_border_right_style, parse_propriété_border_line_style, PropriétéHéritable.Non),
    InfoTypePropriété(PROP_border_left_style, parse_propriété_border_line_style, PropriétéHéritable.Non),
    InfoTypePropriété(PROP_border_width, parse_propriété_border_width, PropriétéHéritable.Non),
    InfoTypePropriété(PROP_border_top_width, parse_propriété_border_line_width, PropriétéHéritable.Non),
    InfoTypePropriété(PROP_border_bottom_width, parse_propriété_border_line_width, PropriétéHéritable.Non),
    InfoTypePropriété(PROP_border_left_width, parse_propriété_border_line_width, PropriétéHéritable.Non),
    InfoTypePropriété(PROP_border_right_width, parse_propriété_border_line_width, PropriétéHéritable.Non)
]

donne_info_type_pour_nom :: fonc (nom: CSSOMString) -> *InfoTypePropriété
{
    pour infos_types_propriétés {
        si it.nom == nom {
            retourne *infos_types_propriétés[index_it]
        }
    }
    retourne nul
}

#portée_export

/** } */

/* ------------------------------------------------------------------------- */
/** \nom Général
 * \{ */

/* https://www.w3.org/TR/css-cascade/#defaulting-keywords */
parse_css_wide_keyword :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(CSSOMString)
{
    mots_clés := [PROP_initial, PROP_inherit, PROP_unset, PROP_revert]
    lexème := parseuse.lexème_courant()

    pour mots_clés {
        si lexème.est_identifiant(it) {
            parseuse.avance()
            retourne lexème.donne_texte()
        }
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Display
 * \{ */

/* https://drafts.csswg.org/css-display/#the-display-properties */
parse_propriété_display :: fonc (value: [..]ComponentValue) -> Optionnel([..]ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)

    mot_clé := parseuse.parse_display_outside()
    si mot_clé.possède_valeur() {
        résultat: [..]ValeurDeStyle
        tableau_ajoute(*résultat, ValeurDeStyle(mot_clé.Quelque))
        retourne résultat
    }

    mot_clé = parseuse.parse_display_box()
    si mot_clé.possède_valeur() {
        résultat: [..]ValeurDeStyle
        tableau_ajoute(*résultat, ValeurDeStyle(mot_clé.Quelque))
        retourne résultat
    }

    lexème := parseuse.lexème_courant()
    si lexème.est_lexème_de_genre(GenreLexème.Ident) {
        si lexème.donne_texte() == PROP_list_item {
            résultat: [..]ValeurDeStyle
            tableau_ajoute(*résultat, ValeurDeStyle(PROP_list_item))
            retourne résultat
        }
    }
}

parse_display_outside :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(CSSOMString)
{
    opt_mot_clé := parse_css_wide_keyword(parseuse)
    si opt_mot_clé.possède_valeur() {
        retourne opt_mot_clé
    }

    /* block | inline | run-in */
    mots_clés := [PROP_block, PROP_inline, PROP_run_in]
    lexème := parseuse.lexème_courant()

    pour mots_clés {
        si lexème.est_identifiant(it) {
            parseuse.avance()
            retourne lexème.donne_texte()
        }
    }
}

parse_display_box :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(CSSOMString)
{
    opt_mot_clé := parse_css_wide_keyword(parseuse)
    si opt_mot_clé.possède_valeur() {
        retourne opt_mot_clé
    }

    /* contents | none */
    mots_clés := [PROP_contents, PROP_none]
    lexème := parseuse.lexème_courant()

    pour mots_clés {
        si lexème.est_identifiant(it) {
            parseuse.avance()
            retourne lexème.donne_texte()
        }
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Color
 * https://drafts.csswg.org/css-color/#the-color-property
 * \{ */

valeur_hex_depuis_unité :: fonc (unité: n16) -> n8
{
    si 'A' <= unité <= 'F' {
        retourne unité comme n8 - ('A' comme n8) + 10
    }

    si 'a' <= unité <= 'z' {
        retourne unité comme n8 - ('a' comme n8) + 10
    }

    retourne unité comme n8 - ('0' comme n8)
}

parse_propriété_color :: fonc (value: [..]ComponentValue) -> Optionnel([..]ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)

    résultat: [..]ValeurDeStyle

    tantque !fini(parseuse) {
        parseuse.consomme_espaces_blanches()

        valeur := parse_valeur_couleur(parseuse)
        si valeur.possède_valeur() {
            tableau_ajoute(*résultat, valeur.Quelque)
            retourne résultat
        }

        lexème := parseuse.lexème_courant()
        imprime("[%] lexème inconnu : %\n", #nom_de_cette_fonction, lexème)
        retourne
    }
}

parse_valeur_couleur :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(ValeurDeStyle)
{
    si parseuse.fini() {
        retourne
    }

    lexème := parseuse.lexème_courant()

    si lexème.est_lexème_de_genre(GenreLexème.Ident) {
        opt_couleur := trouve_couleur_pour_mot_clé(lexème.donne_texte())
        si opt_couleur.possède_valeur() {
            parseuse.avance()
            retourne ValeurDeStyle(couleur = opt_couleur.Quelque)
        }
    }

    /* https://www.w3.org/TR/css-color-4/#typedef-hex-color */
    si lexème.est_lexème_de_genre(GenreLexème.Hash) {
        valeur := lexème.donne_texte().donne_chaine_utf16()

        pour valeur.unités {
            saufsi est_chiffre_hex(it) {
                imprime("[%] couleur hexadécimal inconnu : %\n", #nom_de_cette_fonction, valeur)
                retourne
            }
        }

        couleur: CouleurRVBAN8
        si valeur.taille() == 3 {
            couleur.r = (valeur_hex_depuis_unité(valeur.unités[0]) comme r32 / 15.0 * 255.0) comme n8
            couleur.v = (valeur_hex_depuis_unité(valeur.unités[1]) comme r32 / 15.0 * 255.0) comme n8
            couleur.b = (valeur_hex_depuis_unité(valeur.unités[2]) comme r32 / 15.0 * 255.0) comme n8
            couleur.a = 255
        }
        sinon si valeur.taille() == 4 {
            couleur.r = (valeur_hex_depuis_unité(valeur.unités[0]) comme r32 / 15.0 * 255.0) comme n8
            couleur.v = (valeur_hex_depuis_unité(valeur.unités[1]) comme r32 / 15.0 * 255.0) comme n8
            couleur.b = (valeur_hex_depuis_unité(valeur.unités[2]) comme r32 / 15.0 * 255.0) comme n8
            couleur.a = (valeur_hex_depuis_unité(valeur.unités[3]) comme r32 / 15.0 * 255.0) comme n8
        }
        sinon si valeur.taille() == 6 {
            couleur.r = valeur_hex_depuis_unité(valeur.unités[0]) * 16 + valeur_hex_depuis_unité(valeur.unités[1])
            couleur.v = valeur_hex_depuis_unité(valeur.unités[2]) * 16 + valeur_hex_depuis_unité(valeur.unités[3])
            couleur.b = valeur_hex_depuis_unité(valeur.unités[4]) * 16 + valeur_hex_depuis_unité(valeur.unités[5])
            couleur.a = 255
        }
        sinon si valeur.taille() == 8 {
            couleur.r = valeur_hex_depuis_unité(valeur.unités[0]) * 16 + valeur_hex_depuis_unité(valeur.unités[1])
            couleur.v = valeur_hex_depuis_unité(valeur.unités[2]) * 16 + valeur_hex_depuis_unité(valeur.unités[3])
            couleur.b = valeur_hex_depuis_unité(valeur.unités[4]) * 16 + valeur_hex_depuis_unité(valeur.unités[5])
            couleur.a = valeur_hex_depuis_unité(valeur.unités[6]) * 16 + valeur_hex_depuis_unité(valeur.unités[7])
        }
        sinon {
            imprime("[%] couleur hexadécimal inconnu : %\n", #nom_de_cette_fonction, valeur)
            retourne
        }

        parseuse.avance()
        retourne ValeurDeStyle(couleur = couleur)
    }

    si lexème.est_fonction() {
        fonction := lexème.function

        si fonction.name == PROP_rgb || fonction.name == PROP_rgba {
            résultat := parse_couleur_rgb(fonction)
            si résultat.possède_valeur() {
                parseuse.avance()
            }
            retourne résultat
        }

        retourne
    }
}

parse_couleur_rgb :: fonc (function: &ParsedFunction) -> Optionnel(ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(function.value)

    si parseuse.fini() {
        retourne
    }

    /* Rouge */
    lexème := parseuse.lexème_courant()
    saufsi lexème.est_lexème_de_genre(GenreLexème.Number) {
        retourne
    }
    rouge := lexème.lexème.numeric_value
    parseuse.avance()

    lexème = parseuse.lexème_courant()
    saufsi lexème.est_lexème_de_genre(GenreLexème.Comma) {
        retourne
    }
    parseuse.avance()
    parseuse.consomme_espaces_blanches()

    /* Vert. */
    lexème = parseuse.lexème_courant()
    saufsi lexème.est_lexème_de_genre(GenreLexème.Number) {
        retourne
    }
    vert := lexème.lexème.numeric_value
    parseuse.avance()

    lexème = parseuse.lexème_courant()
    saufsi lexème.est_lexème_de_genre(GenreLexème.Comma) {
        retourne
    }
    parseuse.avance()
    parseuse.consomme_espaces_blanches()

    /* Bleu */
    lexème = parseuse.lexème_courant()
    saufsi lexème.est_lexème_de_genre(GenreLexème.Number) {
        retourne
    }
    bleu := lexème.lexème.numeric_value
    parseuse.avance()

    alpha : n8 = 255
    si function.name == PROP_rgba {
        /* Alpha */
        lexème = parseuse.lexème_courant()
        saufsi lexème.est_lexème_de_genre(GenreLexème.Comma) {
            retourne
        }
        parseuse.avance()
        parseuse.consomme_espaces_blanches()

        lexème = parseuse.lexème_courant()
        saufsi lexème.est_lexème_de_genre(GenreLexème.Number) {
            retourne
        }

        alpha = (lexème.lexème.numeric_value * 255.0) comme n8
        parseuse.avance()
    }

    couleur := CouleurRVBAN8(rouge comme n8, vert comme n8, bleu comme n8, alpha)
    retourne ValeurDeStyle(couleur = couleur)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Text decoration
 * https://drafts.csswg.org/css-text-decor/#text-decoration-property
 * \{ */

parse_propriété_text_decoration :: fonc (value: [..]ComponentValue) -> Optionnel([..]ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)

    résultat: [..]ValeurDeStyle

    // text-decoration-line
    // 	   none | [ underline || overline || line-through || blink ]
    // text-decoration-style
    // 	   solid | double | dotted | dashed | wavy
    // text-decoration-color
    //     <color>
    // text-decoration
    //     <'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'>

    eu_text_decoration_line := faux
    eu_text_decoration_style := faux

    tantque !fini(parseuse) {
        lexème := parseuse.lexème_courant()

        si lexème.est_lexème_de_genre(GenreLexème.Ident) {
            mot_clé := lexème.donne_texte()

            si mot_clé == PROP_none {
                saufsi eu_text_decoration_line {
                    tableau_ajoute(*résultat, ValeurDeStyle(mot_clé = mot_clé))
                }
                eu_text_decoration_line = vrai
            }
            sinon si mot_clé == PROP_underline || mot_clé == PROP_overline || mot_clé == PROP_line_through {
                tableau_ajoute(*résultat, ValeurDeStyle(mot_clé = mot_clé))
                eu_text_decoration_line = vrai
            }
            sinon si mot_clé == PROP_blink {
                imprime("[%] mot-clé non-supporté %\n", #nom_de_cette_fonction, mot_clé)
                déloge(résultat)
                retourne
            }
            sinon si mot_clé == PROP_solid {
                saufsi eu_text_decoration_style {
                    tableau_ajoute(*résultat, ValeurDeStyle(mot_clé = mot_clé))
                }
                eu_text_decoration_style = vrai
            }
            sinon si mot_clé == PROP_double || mot_clé == PROP_dotted || mot_clé == PROP_dashed || mot_clé == PROP_wavy {
                imprime("[%] mot-clé non-supporté %\n", #nom_de_cette_fonction, mot_clé)
                déloge(résultat)
                retourne
            }
            sinon {
                imprime("[%] mot-clé non-supporté %\n", #nom_de_cette_fonction, mot_clé)
                déloge(résultat)
                retourne
            }

            parseuse.avance()
        }
        sinon {
            imprime("[%] lexème non-supporté %\n", #nom_de_cette_fonction, lexème)
            déloge(résultat)
            retourne
        }

        parseuse.consomme_espaces_blanches()
    }

    si résultat.taille != 0 {
        retourne résultat
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Cursor
 * https://drafts.csswg.org/css-ui/#cursor
 * \{ */

CursorType :: énum {
    auto
    default
    none
    context_menu
    help
    pointer
    progress
    wait
    cell
    crosshair
    text
    vertical_text
    alias
    copy
    move
    no_drop
    not_allowed
    grab
    grabbing
    e_resize
    n_resize
    ne_resize
    nw_resize
    s_resize
    se_resize
    sw_resize
    w_resize
    ew_resize
    ns_resize
    nesw_resize
    nwse_resize
    col_resize
    row_resize
    all_scroll
    zoom_in
    zoom_out
}

donne_type_cursor :: fonc (chn: CSSOMString) -> CursorType
{
    si chn == PROP_auto {
        retourne CursorType.auto;
    }
    si chn == PROP_default {
        retourne CursorType.default;
    }
    si chn == PROP_none {
        retourne CursorType.none;
    }
    si chn == PROP_context_menu {
        retourne CursorType.context_menu;
    }
    si chn == PROP_help {
        retourne CursorType.help;
    }
    si chn == PROP_pointer {
        retourne CursorType.pointer;
    }
    si chn == PROP_progress {
        retourne CursorType.progress;
    }
    si chn == PROP_wait {
        retourne CursorType.wait;
    }
    si chn == PROP_cell {
        retourne CursorType.cell;
    }
    si chn == PROP_crosshair {
        retourne CursorType.crosshair;
    }
    si chn == PROP_text {
        retourne CursorType.text;
    }
    si chn == PROP_vertical_text {
        retourne CursorType.vertical_text;
    }
    si chn == PROP_alias {
        retourne CursorType.alias;
    }
    si chn == PROP_copy {
        retourne CursorType.copy;
    }
    si chn == PROP_move {
        retourne CursorType.move;
    }
    si chn == PROP_no_drop {
        retourne CursorType.no_drop;
    }
    si chn == PROP_not_allowed {
        retourne CursorType.not_allowed;
    }
    si chn == PROP_grab {
        retourne CursorType.grab;
    }
    si chn == PROP_grabbing {
        retourne CursorType.grabbing;
    }
    si chn == PROP_e_resize {
        retourne CursorType.e_resize;
    }
    si chn == PROP_n_resize {
        retourne CursorType.n_resize;
    }
    si chn == PROP_ne_resize {
        retourne CursorType.ne_resize;
    }
    si chn == PROP_nw_resize {
        retourne CursorType.nw_resize;
    }
    si chn == PROP_s_resize {
        retourne CursorType.s_resize;
    }
    si chn == PROP_se_resize {
        retourne CursorType.se_resize;
    }
    si chn == PROP_sw_resize {
        retourne CursorType.sw_resize;
    }
    si chn == PROP_w_resize {
        retourne CursorType.w_resize;
    }
    si chn == PROP_ew_resize {
        retourne CursorType.ew_resize;
    }
    si chn == PROP_ns_resize {
        retourne CursorType.ns_resize;
    }
    si chn == PROP_nesw_resize {
        retourne CursorType.nesw_resize;
    }
    si chn == PROP_nwse_resize {
        retourne CursorType.nwse_resize;
    }
    si chn == PROP_col_resize {
        retourne CursorType.col_resize;
    }
    si chn == PROP_row_resize {
        retourne CursorType.row_resize;
    }
    si chn == PROP_all_scroll {
        retourne CursorType.all_scroll;
    }
    si chn == PROP_zoom_in {
        retourne CursorType.zoom_in;
    }
    si chn == PROP_zoom_out {
        retourne CursorType.zoom_out;
    }
    panique("chn pour curseur invalide")
}

parse_propriété_cursor :: fonc (value: [..]ComponentValue) -> Optionnel([..]ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)

    résultat: [..]ValeurDeStyle

    mots_clés := [
        PROP_auto, PROP_default, PROP_none, PROP_context_menu, PROP_help, PROP_pointer, PROP_progress,
        PROP_wait, PROP_cell, PROP_crosshair, PROP_text, PROP_vertical_text, PROP_alias, PROP_copy,
        PROP_move, PROP_no_drop, PROP_not_allowed, PROP_grab, PROP_grabbing, PROP_e_resize,
        PROP_n_resize, PROP_ne_resize, PROP_nw_resize, PROP_s_resize, PROP_se_resize, PROP_sw_resize,
        PROP_w_resize, PROP_ew_resize, PROP_ns_resize, PROP_nesw_resize, PROP_nwse_resize,
        PROP_col_resize, PROP_row_resize, PROP_all_scroll, PROP_zoom_in, PROP_zoom_out
    ]

    tantque !fini(parseuse) {
        lexème := parseuse.lexème_courant()

        si lexème.est_lexème_de_genre(GenreLexème.Ident) {
            pour mots_clés {
                si lexème.est_identifiant(it) {
                    texte := lexème.donne_texte()
                    tableau_ajoute(*résultat, ValeurDeStyle(mot_clé = texte))
                    arrête
                }
            }
            sansarrêt {
                imprime("[%] lexème non-supporté %\n", #nom_de_cette_fonction, lexème)
                déloge(résultat)
                retourne
            }

            parseuse.avance()
        }
        sinon {
            imprime("[%] lexème non-supporté %\n", #nom_de_cette_fonction, lexème)
            déloge(résultat)
            retourne
        }

        parseuse.consomme_espaces_blanches()
    }

    si résultat.taille != 0 {
        retourne résultat
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Font Weight
 * https://drafts.csswg.org/css-fonts/#font-weight-prop
 * \{ */

parse_propriété_font_weight :: fonc (value: [..]ComponentValue) -> Optionnel([..]ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)

    résultat: [..]ValeurDeStyle

    mots_clés := [
        PROP_normal, PROP_bold
    ]

    tantque !fini(parseuse) {
        lexème := parseuse.lexème_courant()

        si lexème.est_lexème_de_genre(GenreLexème.Ident) {
            pour mots_clés {
                si lexème.est_identifiant(it) {
                    texte := lexème.donne_texte()
                    tableau_ajoute(*résultat, ValeurDeStyle(mot_clé = texte))
                    arrête
                }
            }
            sansarrêt {
                imprime("[%] lexème non-supporté %\n", #nom_de_cette_fonction, lexème)
                déloge(résultat)
                retourne
            }

            parseuse.avance()
        }
        sinon {
            imprime("[%] lexème non-supporté %\n", #nom_de_cette_fonction, lexème)
            déloge(résultat)
            retourne
        }

        parseuse.consomme_espaces_blanches()
    }

    si résultat.taille != 0 {
        retourne résultat
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Font Size
 * https://drafts.csswg.org/css-fonts/#font-size-prop
 * \{ */

parse_propriété_font_size :: fonc (value: [..]ComponentValue) -> Optionnel([..]ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)

    résultat: [..]ValeurDeStyle

    tantque !fini(parseuse) {
        lexème := parseuse.lexème_courant()

        si lexème.est_lexème_de_genre(GenreLexème.Dimension) {
            parseuse.avance()
            données_lexème := lexème.lexème

            si données_lexème.unité != PROP_em {
                imprime("[%] unité inconnue %\n", #nom_de_cette_fonction, lexème)
                déloge(résultat)
                retourne
            }

            longueur := Longueur(données_lexème.numeric_value, Longueur.Unité.Em)
            tableau_ajoute(*résultat, ValeurDeStyle(longueur = longueur))
        }
        sinon {
            imprime("[%] lexème non-supporté %\n", #nom_de_cette_fonction, lexème)
            déloge(résultat)
            retourne
        }

        parseuse.consomme_espaces_blanches()
    }

    si résultat.taille != 0 {
        retourne résultat
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Font Style
 * https://drafts.csswg.org/css-fonts/#font-style-prop
 * \{ */

parse_propriété_font_style :: fonc (value: [..]ComponentValue) -> Optionnel([..]ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)

    résultat: [..]ValeurDeStyle
    mots_clés := [
        PROP_normal, PROP_italic
    ]

    tantque !fini(parseuse) {
        lexème := parseuse.lexème_courant()

        si lexème.est_lexème_de_genre(GenreLexème.Ident) {
            pour mots_clés {
                si lexème.est_identifiant(it) {
                    texte := lexème.donne_texte()
                    tableau_ajoute(*résultat, ValeurDeStyle(mot_clé = texte))
                    arrête
                }
            }
            sansarrêt {
                imprime("[%] lexème non-supporté %\n", #nom_de_cette_fonction, lexème)
                déloge(résultat)
                retourne
            }

            parseuse.avance()
        }
        sinon {
            imprime("[%] lexème non-supporté %\n", #nom_de_cette_fonction, lexème)
            déloge(résultat)
            retourne
        }

        parseuse.consomme_espaces_blanches()
    }

    si résultat.taille != 0 {
        retourne résultat
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Borders
 * https://drafts.csswg.org/css-backgrounds-3/#border-shorthands
 * \{ */

parse_propriété_border :: fonc (value: [..]ComponentValue) -> Optionnel([..]ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)

    valeur_width: Optionnel(ValeurDeStyle)
    valeur_style: Optionnel(ValeurDeStyle)
    valeur_color: Optionnel(ValeurDeStyle)

    tantque !fini(parseuse) {
        parseuse.consomme_espaces_blanches()

        style := parse_valeur_line_style(parseuse)
        si style.possède_valeur() {
            valeur_style = style
            continue
        }

        width := parse_valeur_line_width(parseuse)
        si width.possède_valeur() {
            valeur_width = width
            continue
        }

        color := parse_valeur_couleur(parseuse)
        si color.possède_valeur() {
            valeur_color = color
            continue
        }

        parseuse.consomme_espaces_blanches()

        lexème := parseuse.lexème_courant()
        imprime("[%] lexème inconnu %\n", #nom_de_cette_fonction, lexème)
        retourne
    }

    résultat: [..]ValeurDeStyle
    tableau_réserve(*résultat, 3)

    si valeur_width.possède_valeur() {
        tableau_ajoute(*résultat, valeur_width.Quelque)
    }
    sinon {
        /* Valeur initiale */
        tableau_ajoute(*résultat, ValeurDeStyle(mot_clé = PROP_medium))
    }

    si valeur_style.possède_valeur() {
        tableau_ajoute(*résultat, valeur_style.Quelque)
    }
    sinon {
        /* Valeur initiale */
        tableau_ajoute(*résultat, ValeurDeStyle(mot_clé = PROP_none))
    }

    si valeur_color.possède_valeur() {
        tableau_ajoute(*résultat, valeur_color.Quelque)
    }
    sinon {
        /* Valeur initiale */
        tableau_ajoute(*résultat, ValeurDeStyle(mot_clé = PROP_currentColor))
    }

    retourne résultat
}

parse_propriété_border_color :: fonc (value: [..]ComponentValue) -> Optionnel([..]ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)

    résultat: [..]ValeurDeStyle
    tableau_réserve(*résultat, 4)

    tantque !fini(parseuse) {
        parseuse.consomme_espaces_blanches()

        color := parse_valeur_couleur(parseuse)
        si color.possède_valeur() {
            tableau_ajoute(*résultat, color.Quelque)
            continue
        }

        parseuse.consomme_espaces_blanches()

        lexème := parseuse.lexème_courant()
        imprime("[%] lexème inconnu %\n", #nom_de_cette_fonction, lexème)
        déloge(résultat)
        retourne
    }

    retourne résultat
}

parse_propriété_border_style :: fonc (value: [..]ComponentValue) -> Optionnel([..]ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)

    résultat: [..]ValeurDeStyle
    tableau_réserve(*résultat, 4)

    tantque !fini(parseuse) {
        parseuse.consomme_espaces_blanches()

        style := parse_valeur_line_style(parseuse)
        si style.possède_valeur() {
            tableau_ajoute(*résultat, style.Quelque)
            continue
        }

        parseuse.consomme_espaces_blanches()

        lexème := parseuse.lexème_courant()
        imprime("[%] lexème inconnu %\n", #nom_de_cette_fonction, lexème)
        déloge(résultat)
        retourne
    }

    retourne résultat
}

parse_propriété_border_width :: fonc (value: [..]ComponentValue) -> Optionnel([..]ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)

    résultat: [..]ValeurDeStyle
    tableau_réserve(*résultat, 4)

    tantque !fini(parseuse) {
        parseuse.consomme_espaces_blanches()

        width := parse_valeur_line_width(parseuse)
        si width.possède_valeur() {
            tableau_ajoute(*résultat, width.Quelque)
            continue
        }

        parseuse.consomme_espaces_blanches()

        lexème := parseuse.lexème_courant()
        imprime("[%] lexème inconnu %\n", #nom_de_cette_fonction, lexème)
        déloge(résultat)
        retourne
    }

    retourne résultat
}

parse_propriété_border_line_style :: fonc (value: [..]ComponentValue) -> Optionnel([..]ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)

    résultat: [..]ValeurDeStyle

    tantque !fini(parseuse) {
        parseuse.consomme_espaces_blanches()

        style := parse_valeur_line_style(parseuse)
        si style.possède_valeur() {
            tableau_ajoute(*résultat, style.Quelque)
            retourne résultat
        }

        parseuse.consomme_espaces_blanches()

        lexème := parseuse.lexème_courant()
        imprime("[%] lexème inconnu %\n", #nom_de_cette_fonction, lexème)
        déloge(résultat)
        retourne
    }
}

parse_propriété_border_line_width :: fonc (value: [..]ComponentValue) -> Optionnel([..]ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)

    résultat: [..]ValeurDeStyle

    tantque !fini(parseuse) {
        parseuse.consomme_espaces_blanches()

        width := parse_valeur_line_width(parseuse)
        si width.possède_valeur() {
            tableau_ajoute(*résultat, width.Quelque)
            retourne résultat
        }

        parseuse.consomme_espaces_blanches()

        lexème := parseuse.lexème_courant()
        imprime("[%] lexème inconnu %\n", #nom_de_cette_fonction, lexème)
        déloge(résultat)
        retourne
    }
}

/* <line-width> = <length [0,∞]> | thin | medium | thick */
parse_valeur_line_width :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(ValeurDeStyle)
{
    mots_clés := [PROP_thin, PROP_medium, PROP_thick]

    tantque !parseuse.fini() {
        parseuse.consomme_espaces_blanches()

        lexème := parseuse.lexème_courant()
        si lexème.est_lexème_de_genre(GenreLexème.Ident) {
            pour mots_clés {
                si lexème.est_identifiant(it) {
                    texte := lexème.donne_texte()
                    parseuse.avance()
                    retourne ValeurDeStyle(mot_clé = texte)
                }
            }

            retourne
        }

        si lexème.est_lexème_de_genre(GenreLexème.Dimension) {
            données_lexème := lexème.lexème

            si données_lexème.unité == PROP_em {
                parseuse.avance()
                longueur := Longueur(données_lexème.numeric_value, Longueur.Unité.Em)
                retourne ValeurDeStyle(longueur = longueur)
            }

            si données_lexème.unité == PROP_px {
                parseuse.avance()
                longueur := Longueur(données_lexème.numeric_value, Longueur.Unité.Px)
                retourne ValeurDeStyle(longueur = longueur)
            }

            retourne
        }

        si lexème.est_lexème_de_genre(GenreLexème.Number) {
            parseuse.avance()

            si lexème.lexème.drapeau_type_nombre == DrapeauxTypeNombre.Integer {
                retourne ValeurDeStyle(integer = lexème.lexème.numeric_value)
            }

            retourne ValeurDeStyle(number = lexème.lexème.numeric_value)
        }

        retourne
    }
}

/* <line-style> = none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset */
parse_valeur_line_style :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(ValeurDeStyle)
{
    mots_clés := [PROP_none, PROP_hidden, PROP_dotted, PROP_dashed, PROP_solid, PROP_double, PROP_groove, PROP_ridge, PROP_inset, PROP_outset]
    tantque !parseuse.fini() {
        parseuse.consomme_espaces_blanches()

        lexème := parseuse.lexème_courant()
        si lexème.est_lexème_de_genre(GenreLexème.Ident) {
            pour mots_clés {
                si lexème.est_identifiant(it) {
                    texte := lexème.donne_texte()
                    parseuse.avance()
                    retourne ValeurDeStyle(mot_clé = texte)
                }
            }
        }

        retourne
    }
}

/** \} */
