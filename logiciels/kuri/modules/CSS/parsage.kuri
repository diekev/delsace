importe Couleur

/* ------------------------------------------------------------------------- */
/** \nom 5. Parsing
 * https://www.w3.org/TR/css-syntax-3/#parsing
 * \{ */

ParsedStyleSheet :: struct {
    location: URI
    value: [..]*ParsedRule
}

détruit_données_stylesheet :: fonc (stylesheet: *ParsedStyleSheet)
{
    pour stylesheet.value {
        détruit_tableau_component_value(*it.prelude)
        détruit_données_bloc(*it.bloc)
        
        si it.type == ParsedQualifiedRule {
            qualified := it comme *ParsedQualifiedRule
            déloge(qualified)
        }
        sinon si it.type == ParsedAtRule {
            at := it comme *ParsedAtRule
            déloge(at)
        }
        sinon {
            déloge(it)
        }
    }

    déloge(stylesheet.value)
}

ParsedRule :: struct {
    type: type_de_données
    prelude: [..]ComponentValue
    bloc: ParsedSimpleBlock
}

ParsedAtRule :: struct {
    empl rule: ParsedRule
    type = #type_de_cette_structure
    name: CSSOMString
}

ParsedQualifiedRule :: struct {
    empl rule: ParsedRule
    type = #type_de_cette_structure
}

ParsedSimpleBlock :: struct {
    token: Lexème
    value: [..]ComponentValue
}

détruit_données_bloc :: fonc (bloc: *ParsedSimpleBlock)
{
    détruit_tableau_component_value(*bloc.value)
}

ParsedDeclaration :: struct {
    name: CSSOMString
    value: [..]ComponentValue
    important: bool
}

formatte_parsed_declaration :: fonc (enchaineuse: *Enchaineuse, déclaration: *ParsedDeclaration)
{
    saufsi déclaration {
        ajoute_au_tampon(enchaineuse, "déclaration nulle")
        retourne
    }

    ajoute_au_tampon(enchaineuse, déclaration.name, ": ")

    pour déclaration.value {
        ajoute_au_tampon(enchaineuse, it)
    }

    si déclaration.important {
        ajoute_au_tampon(enchaineuse, " !important")
    }
} @FormattageImpression

détruit_données_déclaration :: fonc (déclaration: *ParsedDeclaration)
{
    détruit_tableau_component_value(*déclaration.value)
}

ParsedFunction :: struct {
    name: CSSOMString
    value: [..]ComponentValue
}

détruit_données_function :: fonc (function: *ParsedFunction)
{
    détruit_tableau_component_value(*function.value)
}

ComponentValue :: union {
    lexème: Lexème
    function: ParsedFunction
    bloc: ParsedSimpleBlock
}

détruit_value :: fonc (value: ComponentValue)
{
    discr value {
        function(f) {
            détruit_données_function(*f)
        }
        bloc(b) {
            détruit_données_bloc(*b)
        }
        sinon {}
    }
}

copie_value :: fonc (value: ComponentValue) -> ComponentValue
{
    discr value {
        lexème {
            retourne value
        }
        function(f) {
            résultat: ParsedFunction
            résultat.name = f.name
            résultat.value = copie_tableau_component_value(f.value)
            retourne résultat
        }
        bloc(b) {
            résultat: ParsedSimpleBlock
            résultat.token = b.token
            résultat.value = copie_tableau_component_value(b.value)
            retourne résultat
        }
        sinon {}
    }

    retourne value
}

formatte_component_value :: fonc (enchaineuse: *Enchaineuse, value: *ComponentValue)
{
    saufsi value {
        ajoute_au_tampon(enchaineuse, "valeur nulle")
        retourne
    }

    discr mémoire(value) {
        lexème(l) {
            formatte_lexème(enchaineuse, *l)
            // À FAIRE collision de nom dans formattage ajoute_au_tampon(enchaineuse, l)
        }
        function(f) {
            ajoute_au_tampon(enchaineuse, f.name, "(")
            pour f.value {
                ajoute_au_tampon(enchaineuse, it)
            }
            ajoute_au_tampon(enchaineuse, ")")
        }
        bloc(b) {
            formatte_lexème(enchaineuse, *b.token)
            pour b.value {
                ajoute_au_tampon(enchaineuse, it)
            }
            lexème_mirroir := donne_genre_lexème_mirroir(b.token)
            token := b.token
            token.genre = lexème_mirroir
            formatte_lexème(enchaineuse, *token)
        }
        sinon {
            ajoute_au_tampon(enchaineuse, "IMPRESSION À FAIRE")
        }
    }
} @FormattageImpression

copie_tableau_component_value :: fonc (value: []ComponentValue) -> [..]ComponentValue
{
    résultat: [..]ComponentValue
    tableau_réserve(*résultat, value.taille)

    pour value {
        copie := copie_value(it)
        tableau_ajoute(*résultat, copie)
    }

    retourne résultat
}

détruit_tableau_component_value :: fonc (value: *[..]ComponentValue)
{
    tmp := mémoire(value)
    pour tmp {
        détruit_value(it)
    }

    déloge(tmp)
    mémoire(value) = tmp
}

donne_texte :: fonc (value: ComponentValue) -> CSSOMString #enligne
{
    retourne value.lexème.valeur
}

est_simple_bloc_de_genre :: fonc (value: ComponentValue, genre: GenreLexème) -> bool
{
    discr value {
        bloc(b) {
            retourne b.token.genre == genre
        }
        sinon {
            retourne faux
        }
    }
}

donne_bloc_simple :: fonc (value: ComponentValue) -> ParsedSimpleBlock
{
    retourne value.bloc
}

est_fonction :: fonc (value: ComponentValue) -> bool
{
    discr value {
        function {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_fonction :: fonc (value: ComponentValue, nom: CSSOMString) -> bool
{
    discr value {
        function(f) {
            retourne f.name == nom
        }
        sinon {
            retourne faux
        }
    }
}

est_lexème_de_genre :: fonc (value: ComponentValue, genre: GenreLexème) -> bool
{
    discr value {
        lexème(l) {
            retourne est_lexème_de_genre(l, genre)
        }
        sinon {
            retourne faux
        }
    }
}

est_lexème_delim :: fonc (value: ComponentValue, point_de_code: n32) -> bool
{
    discr value {
        lexème(l) {
            retourne est_lexème_delim(l, point_de_code)
        }
        sinon {
            retourne faux
        }
    }
}

est_mot_clé :: fonc (value: ComponentValue, mot_clé: CSSOMString) -> bool
{
    saufsi est_lexème_de_genre(value, GenreLexème.Ident) {
        retourne faux
    }
    retourne value.donne_texte() == mot_clé
}

ÉtatParsage :: énum {
    Ok
    EssaieEncore
    Erreur
}

Parseuse :: struct ($T: type_de_données) {
    lexèmes: []T
    curseur: z64
    possède_erreur: bool
}

initialise_une_parseuse :: fonc (lexèmes: []$T) -> Parseuse(T)
{
    résultat: Parseuse(T)
    résultat.lexèmes = lexèmes
    retourne résultat
}

lexème_courant :: fonc (parseuse: &Parseuse($T)) -> T
{
    si parseuse.fini() {
        retourne Lexème(GenreLexème.EOF)
    }

    retourne parseuse.lexèmes[parseuse.curseur]
}

consomme_le_lexème_en_entrée_suivant :: fonc (parseuse: &Parseuse($T)) -> T
{
    résultat := parseuse.lexème_courant()
    parseuse.curseur += 1
    retourne résultat
}

reconsomme_le_lexème_courant :: fonc (parseuse: &Parseuse($T))
{
    parseuse.curseur -= 1
}

avance :: fonc (parseuse: &Parseuse($T))
{
    parseuse.curseur += 1
}

consomme_espaces_blanches :: fonc (parseuse: &Parseuse($T))
{
    tantque !fini(parseuse) {
        si parseuse.lexème_courant().est_lexème_de_genre(GenreLexème.Whitespace) {
            parseuse.avance()
            continue
        }

        arrête
    }
}

apparie_lexème_ident :: fonc (parseuse: &Parseuse($T)) -> bool #enligne
{
    retourne parseuse.lexème_courant().est_lexème_de_genre(GenreLexème.Ident)
}

fini :: fonc (parseuse: &Parseuse($T)) -> bool
{
    retourne parseuse.curseur >= parseuse.lexèmes.taille || parseuse.possède_erreur
}

rapporte_erreur :: fonc (parseuse: &Parseuse($T) @inutilisée, message: chaine)
{
    imprime("%\n", message)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Parser Entry Points.
 * \{ */

/* 5.4.1 Parse something according to a CSS grammar */
parse_according_to_a_css_grammar :: fonc (input: CSSOMString, grammar: fonc([]ComponentValue)(Optionnel(*ValeurDeStyle))) -> Optionnel(*ValeurDeStyle)
{
    // 1. Normalize input, and set input to the result.
    chn_input := input.donne_chaine_utf16().converti_vers_chaine()
    diffère déloge(chn_input)

    retourne parse_according_to_a_css_grammar(chn_input, grammar)
}

parse_according_to_a_css_grammar :: fonc (input: chaine, grammar: fonc([]ComponentValue)($T)) -> T
{
    lexèmes := lèxe_style(input)
    diffère détruit_lexèmes(*lexèmes)

    // 2. Parse a list of component values from input, and let result be the return value.
    result := parse_a_list_of_component_values(lexèmes)
    diffère détruit_tableau_component_value(*result)

    // 3. Attempt to match result against grammar. If this is successful, return the matched result; otherwise, return failure.
    retourne grammar(result)
}

/* 5.4.2 Parse A Comma-Separated List According To A CSS Grammar */

/* 5.4.3 Parse a stylesheet */
parse_a_stylesheet :: fonc (input: [..]Lexème) -> ParsedStyleSheet
{
    // 1. If input is a byte stream for stylesheet, decode bytes from input, and set input to the result.
    // 2. Normalize input, and set input to the result.

    // 3. Create a new stylesheet, with its location set to location (or null, if location was not passed).
    résultat: ParsedStyleSheet

    // 4. Consume a list of rules from input, with the top-level flag set, and set the stylesheet’s value to the result.
    parseuse := initialise_une_parseuse(input)
    résultat.value = consomme_une_liste_de_règles(parseuse, vrai)

    // 5. Return the stylesheet.
    retourne résultat
}

/* 5.4.4 Parse a list of rules */

/* 5.4.5 Parse a rule */

/* 5.4.6 Parse a declaration */

/* 5.4.7 Parse a style block’s contents */
StyleBlockContent :: struct {
    decls: [..]ParsedDeclaration
    rules: [..]*ParsedRule
}

détruit_content :: fonc (content: &StyleBlockContent, détruit_valeurs: bool)
{
    pour content.decls {
        si détruit_valeurs {
            détruit_tableau_component_value(*it.value)
        }
        sinon {
            déloge(it.value)
        }
    }

    déloge(content.rules)
    déloge(content.decls)
}

parse_a_style_block_s_contents :: fonc (input: []ComponentValue) -> StyleBlockContent
{
    // 1. Normalize input, and set input to the result.
    // 2. Consume a style block’s contents from input, and return the result.
    parseuse := initialise_une_parseuse(input)
    retourne consomme_le_contenu_d_un_bloc_de_style(parseuse)
}

/* 5.4.8 Parse a list of declarations */
parse_a_list_of_declarations :: fonc (input: [..]Lexème) -> StyleBlockContent
{
    // 1. Normalize input, and set input to the result.
    // 2. Consume a list of declarations from input, and return the result.
    parseuse := initialise_une_parseuse(input)
    retourne consomme_une_liste_de_déclarations(parseuse)
}

parse_attribut_style :: fonc (valeur: ChaineUTF16) -> *CSSStyleDeclaration
{
    contenu := converti_vers_chaine(valeur)
    diffère déloge(contenu)

    lexèmes := lèxe_style(contenu)
    diffère détruit_lexèmes(*lexèmes)

    style_content := parse_a_list_of_declarations(lexèmes)
    diffère détruit_content(style_content, vrai)

    ctx: ContexteParsageFeuilleDeStyle
    diffère détruit_données_contexte(*ctx)

    résultat := parse_css_style_declaration(*ctx, style_content.decls)

    rapporte_propriétés_non_supportées(*ctx, #nom_de_cette_fonction)

    retourne résultat
}

/* 5.4.9 Parse a component value */

/* 5.4.10 Parse a list of component values */
parse_a_list_of_component_values :: fonc (input: []Lexème) -> [..]ComponentValue
{
    // 1. Normalize input, and set input to the result.
    parseuse := initialise_une_parseuse(input)

    // 2. Consume a list of component values from input, and return the result.
    retourne consomme_une_lise_de_valeur_composante(parseuse, GenreLexème.EOF)
}

/* 5.4.11 Parse a comma-separated list of component values */
parse_a_comma_separated_list_of_component_values :: fonc (input: []ComponentValue) -> [..][..]ComponentValue
{
    // 1. Let groups be an empty list.
    groups: [..][..]ComponentValue

    parseuse := initialise_une_parseuse(input)

    // 2. While input is not empty:
    tantque !parseuse.fini() {
        // 1. Consume a list of component values from input, with <comma-token> as the stop token, and append the result to groups.
        list := consomme_une_lise_de_valeur_composante(parseuse, GenreLexème.Comma)
        tableau_ajoute(*groups, list)

        // 2. Discard a token from input.
        saufsi parseuse.fini() {
            parseuse.avance()
        }
    }

    // 3. Return groups.
    retourne groups
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Color
 * \{ */

/* https://drafts.csswg.org/css-color/#parse-a-css-color-value */
parse_a_css_color :: fonc (input: CSSOMString, context: *HTML.Element @inutilisée) -> Optionnel(CouleurRVBAN8)
{
    // 1. Parse input as a <color>. If the result is failure, return failure; otherwise, let color be the result.
    opt_color := parse_according_to_a_css_grammar(input, parse_propriété_color)
    saufsi opt_color.possède_valeur() {
        retourne
    }

    color := opt_color.Quelque
    diffère détruit_valeur_de_style(color)

    saufsi color.est_couleur() {
        retourne
    }

    // À FAIRE : 2. Let used color be the result of resolving color to a used color. If the value of other properties on the element a <color> is on is required to do the resolution (such as resolving a currentcolor or system color), use element if it was passed, or the initial values of the properties if not.

    // 3. Return used color.
    retourne color.donne_couleur()
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 5.5 Parser Algorithms.
 * https://www.w3.org/TR/css-syntax-3/#parser-algorithms
 * \{ */

/* 5.5.1 Consume a list of rules */
consomme_une_liste_de_règles :: fonc (parseuse: &Parseuse($T), top_level: bool) -> [..]*ParsedRule
{
    résultat: [..]*ParsedRule

    tantque !fini(parseuse) {
        lexème := parseuse.consomme_le_lexème_en_entrée_suivant()

        si lexème.est_lexème_de_genre(GenreLexème.Whitespace) {
            continue
        }

        si lexème.est_lexème_de_genre(GenreLexème.EOF) {
            retourne résultat
        }

        si lexème.est_lexème_de_genre(GenreLexème.CDO) || lexème.est_lexème_de_genre(GenreLexème.CDC) {
            si top_level {
                continue
            }

            parseuse.reconsomme_le_lexème_courant()

            règle := parseuse.consomme_une_règle_qualifiée()
            si règle {
                tableau_ajoute(*résultat, règle)
            }
            continue
        }

        si lexème.est_lexème_de_genre(GenreLexème.At_Keyword) {
            parseuse.reconsomme_le_lexème_courant()
            règle := parseuse.consomme_une_règle_arobase()
            tableau_ajoute(*résultat, règle)
            continue
        }

        parseuse.reconsomme_le_lexème_courant()

        règle := parseuse.consomme_une_règle_qualifiée()
        si règle {
            tableau_ajoute(*résultat, règle)
        }
    }

    retourne résultat
}

/* 5.5.2 Consume an at-rule */
consomme_une_règle_arobase :: fonc (parseuse: &Parseuse($T)) -> *ParsedAtRule
{
    résultat := loge(ParsedAtRule)
    résultat.name = parseuse.lexème_courant().donne_texte()

    _ := parseuse.consomme_le_lexème_en_entrée_suivant()

    tantque !fini(parseuse) {
        lexème := parseuse.consomme_le_lexème_en_entrée_suivant()

        si lexème.est_lexème_de_genre(GenreLexème.Semicolon) {
            retourne résultat
        }

        si lexème.est_lexème_de_genre(GenreLexème.EOF) {
            parseuse.rapporte_erreur("fin de fichier dans une @-rule")
            retourne résultat
        }

        si lexème.est_lexème_de_genre(GenreLexème.Open_Bracket) {
            bloc := parseuse.consomme_un_bloc_simple(lexème)
            résultat.bloc = bloc
            retourne résultat
        }

        si lexème.est_simple_bloc_de_genre(GenreLexème.Open_Bracket) {
            résultat.bloc = lexème.donne_bloc_simple()
            retourne résultat
        }

        parseuse.reconsomme_le_lexème_courant()
        valeur := parseuse.consomme_une_valeur_composante()
        tableau_ajoute(*résultat.prelude, valeur)
    }

    retourne résultat
}

/* 5.5.3 Consume a qualified rule */
consomme_une_règle_qualifiée :: fonc (parseuse: &Parseuse($T)) -> *ParsedQualifiedRule
{
    résultat := loge(ParsedQualifiedRule)

    tantque !fini(parseuse) {
        lexème := parseuse.consomme_le_lexème_en_entrée_suivant()

        si lexème.est_lexème_de_genre(GenreLexème.EOF) {
            parseuse.rapporte_erreur("fin de fichier dans une qualified-rule")
            // À FAIRE détruit le résultat
            retourne nul
        }

        si lexème.est_lexème_de_genre(GenreLexème.Open_Bracket) {
            bloc := parseuse.consomme_un_bloc_simple(lexème)
            résultat.bloc = bloc
            retourne résultat
        }

        si lexème.est_simple_bloc_de_genre(GenreLexème.Open_Bracket) {
            résultat.bloc = lexème.donne_bloc_simple()
            retourne résultat
        }

        parseuse.reconsomme_le_lexème_courant()
        valeur := parseuse.consomme_une_valeur_composante()
        tableau_ajoute(*résultat.prelude, valeur)
    }

    retourne résultat
}

/* 5.5.4 Consume a style block’s contents */
consomme_le_contenu_d_un_bloc_de_style :: fonc (parseuse: &Parseuse($T)) -> StyleBlockContent
{
    decls: [..]ParsedDeclaration
    rules: [..]*ParsedRule

    tantque !fini(parseuse) {
        lexème := parseuse.consomme_le_lexème_en_entrée_suivant()

        si lexème.est_lexème_de_genre(GenreLexème.Whitespace) || lexème.est_lexème_de_genre(GenreLexème.Semicolon) {
            continue
        }

        si lexème.est_lexème_de_genre(GenreLexème.EOF) {
            // Extend decls with rules, then return decls.
            arrête
        }

        si lexème.est_lexème_de_genre(GenreLexème.At_Keyword) {
            parseuse.reconsomme_le_lexème_courant()
            rule := consomme_une_règle_arobase(parseuse)
            tableau_ajoute(*rules, rule)
            continue
        }

        si lexème.est_lexème_de_genre(GenreLexème.Ident) {
            // Initialize a temporary list initially filled with the current input token.
            temp: [..]ComponentValue
            tableau_ajoute(*temp, lexème)

            // As long as the next input token is anything other than a <semicolon-token>
            // or <EOF-token>, consume a component value and append it to the temporary list.
            tantque !fini(parseuse) {
                lexème = parseuse.lexème_courant()

                si lexème.est_lexème_de_genre(GenreLexème.EOF) || lexème.est_lexème_de_genre(GenreLexème.Semicolon) {
                    arrête
                }

                tableau_ajoute(*temp, lexème)
                parseuse.avance()
            }

            // Consume a declaration from the temporary list.
            // If anything was returned, append it to decls.
            parseuse_decl := initialise_une_parseuse(temp)
            decl := consomme_une_déclaration(parseuse_decl)
            si decl.possède_valeur() {
                tableau_ajoute(*decls, decl.Quelque)
            }

            // @Performance
            déloge(temp)
            continue
        }

        si lexème.est_lexème_esperluette() {
            parseuse.reconsomme_le_lexème_courant()
            rule := consomme_une_règle_qualifiée(parseuse)
            si rule {
                tableau_ajoute(*rules, rule)
            }
            continue
        }

        /* Anything else.
         * This is a parse error. Reconsume the current input token.
         * As long as the next input token is anything other than a
         * <semicolon-token> or <EOF-token>, consume a component value
         * and throw away the returned value. */
        tantque !fini(parseuse) {
            lexème = parseuse.lexème_courant()
            si lexème.est_lexème_de_genre(GenreLexème.EOF) || lexème.est_lexème_de_genre(GenreLexème.Semicolon) {
                arrête
            }
            component_value := consomme_une_valeur_composante(parseuse)
            détruit_value(component_value)
        }
    }

    retourne StyleBlockContent(decls, rules)
}

/* 5.5.5 Consume a list of declarations */
consomme_une_liste_de_déclarations :: fonc (parseuse: &Parseuse($T)) -> StyleBlockContent
{
    // Create an initially empty list of declarations.
    decls: [..]ParsedDeclaration
    rules: [..]*ParsedRule

    tantque !fini(parseuse) {
        lexème := parseuse.consomme_le_lexème_en_entrée_suivant()

        si lexème.est_lexème_de_genre(GenreLexème.Whitespace) || lexème.est_lexème_de_genre(GenreLexème.Semicolon) {
            continue
        }

        si lexème.est_lexème_de_genre(GenreLexème.EOF) {
            arrête
        }

        si lexème.est_lexème_de_genre(GenreLexème.At_Keyword) {
            parseuse.reconsomme_le_lexème_courant()
            rule := parseuse.consomme_une_règle_arobase()
            si rule {
                tableau_ajoute(*rules, rule)
            }
            continue
        }

        si lexème.est_lexème_de_genre(GenreLexème.Ident) {
            // Initialize a temporary list initially filled with the current input token.
            temp: [..]ComponentValue
            tableau_ajoute(*temp, lexème)

            // As long as the next input token is anything other than a <semicolon-token>
            // or <EOF-token>, consume a component value and append it to the temporary list.
            tantque !fini(parseuse) {
                lexème = parseuse.lexème_courant()

                si lexème.est_lexème_de_genre(GenreLexème.EOF) || lexème.est_lexème_de_genre(GenreLexème.Semicolon) {
                    arrête
                }

                component_value := consomme_une_valeur_composante(parseuse)
                tableau_ajoute(*temp, component_value)
            }

            // Consume a declaration from the temporary list.
            // If anything was returned, append it to the list of declarations.
            parseuse_decl := initialise_une_parseuse(temp)
            decl := consomme_une_déclaration(parseuse_decl)
            si decl.possède_valeur() {
                tableau_ajoute(*decls, decl.Quelque)
            }

            // @Performance
            déloge(temp)
            continue
        }

        // This is a parse error.
        // Reconsume the current input token.
        // As long as the next input token is anything other than a <semicolon-token> or <EOF-token>,
        // consume a component value and throw away the returned value.
        parseuse.reconsomme_le_lexème_courant()
        tantque !fini(parseuse) {
            lexème = parseuse.lexème_courant()
            si lexème.est_lexème_de_genre(GenreLexème.EOF) || lexème.est_lexème_de_genre(GenreLexème.Semicolon) {
                arrête
            }
            component_value := consomme_une_valeur_composante(parseuse)
            détruit_value(component_value)
        }
    }

    retourne StyleBlockContent(decls, rules)
}

/* 5.5.6 Consume a declaration */
consomme_une_déclaration :: fonc (parseuse: &Parseuse($T)) -> Optionnel(ParsedDeclaration)
{
    lexème := parseuse.consomme_le_lexème_en_entrée_suivant()

    résultat: ParsedDeclaration
    résultat.name = lexème.donne_texte()

    // 1. While the next input token is a <whitespace-token>, consume the next input token.
    consomme_espaces_blanches(parseuse)

    // 2. If the next input token is anything other than a <colon-token>, this is a parse error. Return nothing.
    //    Otherwise, consume the next input token.
    saufsi parseuse.lexème_courant().est_lexème_de_genre(GenreLexème.Colon) {
        retourne
    }
    parseuse.avance()

    // 3. While the next input token is a <whitespace-token>, consume the next input token.
    consomme_espaces_blanches(parseuse)

    // 4. As long as the next input token is anything other than an <EOF-token>, consume a component value and append it to the declaration’s value.
    value: [..]ComponentValue
    tantque !fini(parseuse) {
        lexème = parseuse.lexème_courant()
        si lexème.est_lexème_de_genre(GenreLexème.EOF) {
            arrête
        }

        component_value := consomme_une_valeur_composante(parseuse)
        tableau_ajoute(*value, component_value)
    }

    // 5. If the last two non-<whitespace-token>s in the declaration’s value are a <delim-token>
    // with the value "!" followed by an <ident-token> with a value that is an ASCII case-insensitive
    // match for "important", remove them from the declaration’s value and set the declaration’s
    // important flag to true.
    supprime_espaces_blanches_en_fin(*value)
    si value.taille > 2 {
        sauvegarde_taille := value.taille
        i0 := value.taille - 1

        si value[i0].est_lexème_de_genre(GenreLexème.Ident) && compare_ascii_insensible_à_la_casse(value[i0].lexème.valeur, "important") {
            value.taille -= 1
            supprime_espaces_blanches_en_fin(*value)

            si value.taille > 0 && value[value.taille - 1].est_lexème_exclamation() {
                value.taille -= 1
                résultat.important = vrai
            }
            sinon {
                value.taille = sauvegarde_taille
            }
        }
    }

    // 6. While the last token in the declaration’s value is a <whitespace-token>, remove that token.
    supprime_espaces_blanches_en_fin(*value)

    // 7. Return the declaration.
    résultat.value = value
    retourne résultat
}

supprime_espaces_blanches_en_fin :: fonc (value: *[..]ComponentValue)
{
    nombre_d_espaces_blanches := 0
    pour > mémoire(value) {
        saufsi it.est_lexème_de_genre(GenreLexème.Whitespace) {
            arrête
        }
        nombre_d_espaces_blanches += 1
    }

    value.taille -= nombre_d_espaces_blanches
    assert(value.taille >= 0)
}

/* 5.5.7. Consume a list of component values */
consomme_une_lise_de_valeur_composante :: fonc (parseuse: &Parseuse($T), stop_token: GenreLexème, nested := faux) -> [..]ComponentValue
{
    values: [..]ComponentValue

    tantque !fini(parseuse) {
        lexème := parseuse.lexème_courant()

        si lexème.est_lexème_de_genre(GenreLexème.EOF) || lexème.est_lexème_de_genre(stop_token) {
            arrête
        }

        si lexème.est_lexème_de_genre(GenreLexème.Close_Bracket) {
            si nested {
                arrête
            }

            /* parse-error */
            lexème = parseuse.consomme_le_lexème_en_entrée_suivant()
            tableau_ajoute(*values, lexème)
            continue
        }

        valeur := consomme_une_valeur_composante(parseuse)
        tableau_ajoute(*values, valeur)
    }

    retourne values
}

/* 5.5.8 Consume a component value */
consomme_une_valeur_composante :: fonc (parseuse: &Parseuse($T)) -> ComponentValue
{
    lexème := parseuse.consomme_le_lexème_en_entrée_suivant()

    si lexème.est_lexème_de_genre(GenreLexème.Open_Bracket) || lexème.est_lexème_de_genre(GenreLexème.Open_Square_Bracket) || lexème.est_lexème_de_genre(GenreLexème.Open_Parenthesis) {
        retourne parseuse.consomme_un_bloc_simple(lexème)
    }

    si lexème.est_lexème_de_genre(GenreLexème.Function) {
        retourne parseuse.consomme_une_fonction(lexème)
    }

    // XXX - parseuse.lexème_courant() ?
    retourne lexème
}

donne_genre_lexème_mirroir :: fonc (lexème: Lexème) -> GenreLexème
{
    si lexème.est_lexème_de_genre(GenreLexème.Open_Bracket) {
        retourne GenreLexème.Close_Bracket
    }
    si lexème.est_lexème_de_genre(GenreLexème.Open_Square_Bracket) {
        retourne GenreLexème.Close_Square_Bracket
    }
    assert(lexème.est_lexème_de_genre(GenreLexème.Open_Parenthesis))
    retourne GenreLexème.Close_Parenthesis
}

/* 5.5.9 Consume a simple block */
consomme_un_bloc_simple :: fonc (parseuse: &Parseuse($T), lexème_associé: T) -> ParsedSimpleBlock
{
    genre_lexème_fin := donne_genre_lexème_mirroir(lexème_associé)

    résultat: ParsedSimpleBlock
    résultat.token = lexème_associé

    tantque !fini(parseuse) {
        lexème := parseuse.consomme_le_lexème_en_entrée_suivant()

        si lexème.est_lexème_de_genre(genre_lexème_fin) {
            retourne résultat
        }

        si lexème.est_lexème_de_genre(GenreLexème.EOF) {
            parseuse.rapporte_erreur("fin de fichier dans un bloc simple")
            retourne résultat
        }

        parseuse.reconsomme_le_lexème_courant()
        valeur := parseuse.consomme_une_valeur_composante()
        tableau_ajoute(*résultat.value, valeur)
    }

    retourne résultat
}

/* 5.5.10 Consume a function */
consomme_une_fonction :: fonc (parseuse: &Parseuse($T), lexème_function: T) -> ParsedFunction
{
    résultat: ParsedFunction
    résultat.name = lexème_function.donne_texte()
    résultat.name = résultat.name

    tantque !fini(parseuse) {
        lexème := parseuse.consomme_le_lexème_en_entrée_suivant()

        si lexème.est_lexème_de_genre(GenreLexème.Close_Parenthesis) {
            retourne résultat
        }

        si lexème.est_lexème_de_genre(GenreLexème.EOF) {
            parseuse.rapporte_erreur("fin de fichier dans une fonction")
            retourne résultat
        }

        parseuse.reconsomme_le_lexème_courant()
        valeur := parseuse.consomme_une_valeur_composante()
        tableau_ajoute(*résultat.value, valeur)
    }

    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Selectors.
 * https://www.w3.org/TR/selectors-4/#grammar
 * \{ */

ParseuseSelector :: Parseuse(ComponentValue)

/* <selector-list> = <complex-selector-list> */
parse_selector_list :: fonc (prelude: []ComponentValue) -> Optionnel(SelectorList)
{
    parseuse := initialise_une_parseuse(prelude)
    résultat := parse_selector_list(parseuse)
    saufsi résultat.possède_valeur() {
        imprime("Impossible de parser : ")
        pour prelude {
            imprime("%", it)
        }
        imprime("\n")
    }
    retourne résultat
}

parse_selector_list :: fonc (parseuse: &ParseuseSelector) -> Optionnel(SelectorList)
{
    // imprime("---------------------------\n[%]\n", #nom_de_cette_fonction)
    résultat: SelectorList
    état := parse_complex_selector_list(parseuse, *résultat)
    saufsi état == ÉtatParsage.Ok {
        détruit_données_selector_list(*résultat)
        retourne
    }
    retourne résultat
}

/* https://drafts.csswg.org/selectors/#typedef-relative-selector-list
 * <relative-selector-list> = <relative-selector>#
 * <relative-selector> = <combinator>? <complex-selector> */
parse_relative_selector_list :: fonc (value: []ComponentValue) -> Optionnel(SelectorList)
{
    parseuse := initialise_une_parseuse(value)

    combinateur: Combinator
    état := parse_combinateur(parseuse, *combinateur)
    si état == ÉtatParsage.Erreur {
        retourne
    }
    si état == ÉtatParsage.EssaieEncore {
        combinateur = Combinator.DESCENDANT
    }

    résultat: SelectorList
    résultat.combinateur = combinateur

    état = parse_complex_selector_list(parseuse, *résultat)
    si état == ÉtatParsage.Erreur {
        détruit_données_selector_list(*résultat)
        retourne
    }

    assert(état != ÉtatParsage.EssaieEncore)
    retourne résultat
}

/* <complex-selector-list> = <complex-selector># */
parse_complex_selector_list :: fonc (parseuse: &ParseuseSelector, list: *SelectorList) -> ÉtatParsage
{
    consomme_espaces_blanches(parseuse)

    // imprime("[%]\n", #nom_de_cette_fonction)
    tantque !fini(parseuse) {
        complex: ComplexSelector
        état := parse_complex_selector(parseuse, *complex)
        si état != ÉtatParsage.Ok {
            détruit_données_complex_selector(*complex)
            retourne ÉtatParsage.Erreur
        }

        tableau_ajoute(*list.complex_selectors, complex)

        saufsi parseuse.lexème_courant().est_lexème_de_genre(GenreLexème.Comma) {
            arrête
        }

        // imprime("-- virgule\n")
        _ := parseuse.consomme_le_lexème_en_entrée_suivant()
    }

    consomme_espaces_blanches(parseuse)
    saufsi parseuse.fini() {
        détruit_données_selector_list(list)
        retourne ÉtatParsage.Erreur
    }
    retourne ÉtatParsage.Ok
}

/* <complex-selector> = <compound-selector> [ <combinator>? <compound-selector> ]* */
parse_complex_selector :: fonc (parseuse: &ParseuseSelector, résultat: *ComplexSelector) -> ÉtatParsage
{
    consomme_espaces_blanches(parseuse)

    // imprime("[%]\n", #nom_de_cette_fonction)
    combinateur_courant: Optionnel(Combinator)

    tantque !fini(parseuse) {
        compound: CompoundSelector
        état := parse_compound_selector(parseuse, *compound)
        si état == ÉtatParsage.Erreur {
            détruit_données_compound_selector(*compound)
            retourne état
        }
        saufsi état == ÉtatParsage.Ok {
            arrête
        }

        si combinateur_courant.possède_valeur() {
            compound.combinateur = combinateur_courant.Quelque
        }

        tableau_ajoute(*résultat.compound_selectors, compound)

        combinateur: Combinator
        état = parseuse.parse_combinateur(*combinateur)
        si état == ÉtatParsage.Erreur {
            détruit_données_compound_selector(*compound)
            retourne état
        }
        saufsi état == ÉtatParsage.Ok {
            arrête
        }

        combinateur_courant = combinateur
    }

    consomme_espaces_blanches(parseuse)

    si résultat.compound_selectors.taille == 0 {
        retourne ÉtatParsage.Erreur
    }

    retourne ÉtatParsage.Ok
}

/* <compound-selector>  = [ <type-selector>? <subclass-selector>*
 *                        [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]! */
parse_compound_selector :: fonc (parseuse: &ParseuseSelector, résultat: *CompoundSelector) -> ÉtatParsage
{
    // imprime("[%]\n", #nom_de_cette_fonction)

    // imprime("-- position : %\n", parseuse.curseur)

    /* <type-selector>? */
    type_selector := parseuse.parse_type_selector()
    si type_selector.possède_valeur() {
        // imprime("-- %\n", type_selector.Quelque)
        tableau_ajoute(*résultat.simple_selectors, type_selector.Quelque)
    }

    /* <subclass-selector>* */
    tantque !fini(parseuse) {
        subclass_selector : SimpleSelector = ---
        état := parseuse.parse_subclass_selector(*subclass_selector)
        si état == ÉtatParsage.Erreur {
            retourne état
        }
        saufsi état == ÉtatParsage.Ok {
            arrête
        }

        // imprime("-- %\n", subclass_selector.Quelque)
        tableau_ajoute(*résultat.simple_selectors, subclass_selector)
    }

    /* [ <pseudo-element-selector> <pseudo-class-selector>* ]* */
    tantque !fini(parseuse) {
        pseudo_element_selector: SimpleSelector
        état := parseuse.parse_pseudo_element_selector(*pseudo_element_selector)
        si état == ÉtatParsage.Erreur {
            retourne état
        }
        saufsi état == ÉtatParsage.Ok {
            // À FAIRE(erreur)
            arrête
        }
        // imprime("-- %\n", pseudo_element_selector.Quelque)
        tableau_ajoute(*résultat.simple_selectors, pseudo_element_selector)

        tantque !fini(parseuse) {
            subclass_selector : SimpleSelector = ---
            état = parseuse.parse_subclass_selector(*subclass_selector)
            si état == ÉtatParsage.Erreur {
                retourne état
            }
            saufsi état == ÉtatParsage.Ok {
                // À FAIRE(erreur)
                arrête
            }

            // imprime("-- %\n", subclass_selector.Quelque)
            tableau_ajoute(*résultat.simple_selectors, subclass_selector)
        }
    }

    // imprime("-- position : %\n", parseuse.curseur)

    si résultat.simple_selectors.taille == 0 {
        retourne ÉtatParsage.EssaieEncore
    }

    retourne ÉtatParsage.Ok
}

/* <type-selector> = <wq-name> | <ns-prefix>? '*' */
parse_type_selector :: fonc (parseuse: &ParseuseSelector) -> Optionnel(SimpleSelector)
{
    parseuse_locale : ParseuseSelector = parseuse

    opt_wq_name := parseuse_locale.parse_wq_name()
    si opt_wq_name.possède_valeur() {
        wq_name := opt_wq_name.Quelque

        espace_de_nom := crée_chaine_utf16_unique_vide()
        si wq_name.ns_prefix.possède_valeur() {
            espace_de_nom = wq_name.ns_prefix.Quelque.espace
        }

        parseuse.curseur = parseuse_locale.curseur
        retourne crée_type_selector(espace_de_nom, wq_name.ident)
    }

    parseuse_locale = parseuse

    ns_prefix := parseuse_locale.parse_ns_prefix()
    saufsi ns_prefix.possède_valeur() {
        parseuse_locale = parseuse
    }

    si parseuse_locale.lexème_courant().est_lexème_fois() {
        parseuse_locale.avance()
        parseuse.curseur = parseuse_locale.curseur
        retourne crée_universal_selector(crée_chaine_utf16_unique_vide())
    }
}

/* <wq-name> = <ns-prefix>? <ident-token> */
WQName :: struct {
    ns_prefix: Optionnel(NSPrefix)
    ident := crée_chaine_utf16_unique_vide()
}

parse_wq_name :: fonc (parseuse: &ParseuseSelector) -> Optionnel(WQName)
{
    résultat: WQName
    
    parseuse_locale : ParseuseSelector = parseuse
    résultat.ns_prefix = parseuse_locale.parse_ns_prefix()

    saufsi résultat.ns_prefix.possède_valeur() {
        parseuse_locale = parseuse
    }

    si parseuse_locale.apparie_lexème_ident() {
        résultat.ident = parseuse_locale.lexème_courant().lexème.valeur
        parseuse_locale.avance()

        parseuse.curseur = parseuse_locale.curseur
        retourne résultat
    }
}

/* <ns-prefix> = [ <ident-token> | '*' ]? '|' */
NSPrefix :: struct {
    /* Un identifiant ou '*' */
    espace := crée_chaine_utf16_unique_vide()
}

parse_ns_prefix :: fonc (parseuse: &ParseuseSelector) -> Optionnel(NSPrefix)
{
    résultat: NSPrefix

    si parseuse.apparie_lexème_ident() {
        résultat.espace = parseuse.lexème_courant().lexème.valeur
        parseuse.avance()
    }
    sinon si parseuse.lexème_courant().est_lexème_fois() {
        résultat.espace = ChaineUTF16Unique('*' comme n32)
        parseuse.avance()
    }

    si parseuse.lexème_courant().est_lexème_pipe() {
        parseuse.avance()

        /* Ignorons les appariements d'attibuts avec |=. */
        si parseuse.lexème_courant().est_lexème_égal() {
            retourne
        }

        retourne résultat
    }
}

/* <subclass-selector> = <id-selector> | <class-selector> |
                      <attribute-selector> | <pseudo-class-selector> */
parse_subclass_selector :: fonc (parseuse: &ParseuseSelector, résultat: *SimpleSelector) -> ÉtatParsage
{
    état := parseuse.parse_id_selector(résultat)
    si état != ÉtatParsage.EssaieEncore {
        retourne état
    }

    état = parseuse.parse_class_selector(résultat)
    si état != ÉtatParsage.EssaieEncore {
        retourne état
    }

    état = parseuse.parse_attribute_selector(résultat)
    si état != ÉtatParsage.EssaieEncore {
        retourne état
    }

    état = parseuse.parse_pseudo_class_selector(faux, résultat)
    si état != ÉtatParsage.EssaieEncore {
        retourne état
    }

    retourne ÉtatParsage.EssaieEncore
}

/* <id-selector> = <hash-token> */
parse_id_selector :: fonc (parseuse: &ParseuseSelector, résultat: *SimpleSelector) -> ÉtatParsage
{
    lexème := parseuse.lexème_courant()
    saufsi lexème.est_lexème_de_genre(GenreLexème.Hash) {
        retourne ÉtatParsage.EssaieEncore
    }

    si lexème.lexème.valeur.donne_chaine_utf16().taille() == 0 {
        retourne ÉtatParsage.Erreur
    }

    parseuse.avance()
    mémoire(résultat) = crée_id_selector(lexème.lexème.valeur)
    retourne ÉtatParsage.Ok
}

/* <class-selector> = '.' <ident-token> */
parse_class_selector :: fonc (parseuse: &ParseuseSelector, résultat: *SimpleSelector) -> ÉtatParsage
{
    parseuse_locale : ParseuseSelector = parseuse

    lexème := parseuse_locale.lexème_courant()
    saufsi lexème.est_lexème_point() {
        retourne ÉtatParsage.EssaieEncore
    }
    parseuse_locale.avance()

    saufsi parseuse_locale.apparie_lexème_ident() {
        retourne ÉtatParsage.Erreur
    }

    ident := parseuse_locale.lexème_courant().lexème.valeur
    parseuse_locale.avance()

    parseuse.curseur = parseuse_locale.curseur
    mémoire(résultat) = crée_class_selector(ident)
    retourne ÉtatParsage.Ok
}

/* <attribute-selector> = '[' <wq-name> ']' |
 *                        '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
 * <attr-modifier> = i | s */
parse_attribute_selector :: fonc (parseuse: &ParseuseSelector, résultat: *SimpleSelector) -> ÉtatParsage
{
    saufsi parseuse.lexème_courant().est_simple_bloc_de_genre(GenreLexème.Open_Square_Bracket) {
        retourne ÉtatParsage.EssaieEncore
    }

    bloc := parseuse.lexème_courant().bloc

    parseuse_locale := initialise_une_parseuse(bloc.value)

    opt_wq_name := parseuse_locale.parse_wq_name()
    saufsi opt_wq_name.possède_valeur() {
        parseuse_locale.rapporte_erreur("wq_name invalide pour le selécteur d'attribut")
        retourne ÉtatParsage.Erreur
    }
    wq_name := opt_wq_name.Quelque

    espace_de_nom := crée_chaine_utf16_unique_vide()
    si wq_name.ns_prefix.possède_valeur() {
        espace_de_nom = wq_name.ns_prefix.Quelque.espace
    }
    
    si parseuse_locale.fini() {
        parseuse.avance()
        mémoire(résultat) = crée_attribute_selector(espace_de_nom, wq_name.ident)
        retourne ÉtatParsage.Ok
    }

    matcher := parseuse_locale.parse_attribute_matcher()
    saufsi matcher.possède_valeur() {
        parseuse_locale.rapporte_erreur("matcher invalide")
        retourne ÉtatParsage.Erreur
    }

    lexème_courant := parseuse_locale.lexème_courant()
    attribute_value: CSSOMString

    si lexème_courant.est_lexème_de_genre(GenreLexème.String) || lexème_courant.est_lexème_de_genre(GenreLexème.Ident) {
        attribute_value = lexème_courant.lexème.valeur
        parseuse_locale.avance()
    }
    sinon {
        parseuse_locale.rapporte_erreur("Attendu une chaine ou un identifiant pour la valeur de l'attribut")
        retourne ÉtatParsage.Erreur
    }

    parseuse_locale.consomme_espaces_blanches()

    lexème_courant = parseuse_locale.lexème_courant()
    modifier: Optionnel(SimpleSelector.AttributeModifier)

    si lexème_courant.est_lexème_de_genre(GenreLexème.Ident) {
        valeur := lexème_courant.lexème.valeur

        si valeur.valeur == ('i' comme n32) || valeur.valeur == ('I' comme n32) {
            modifier = SimpleSelector.AttributeModifier.I
        }
        sinon si valeur.valeur == ('s' comme n32) || valeur.valeur == ('S' comme n32) {
            modifier = SimpleSelector.AttributeModifier.S
        }
        sinon {
            retourne ÉtatParsage.Erreur
        }
    }
    sinon si !parseuse_locale.fini() {
        parseuse_locale.rapporte_erreur("Attendu un i ou s")
        retourne ÉtatParsage.Erreur
    }

    parseuse.avance()
    mémoire(résultat) = crée_attribute_selector(espace_de_nom, wq_name.ident, matcher.Quelque, attribute_value, modifier)
    retourne ÉtatParsage.Ok
}

/* <attr-matcher> = [ '~' | '|' | '^' | '$' | '*' ]? '=' */
parse_attribute_matcher :: fonc (parseuse: &ParseuseSelector) -> Optionnel(SimpleSelector.AttributeMatcher)
{
    matcher: Optionnel(SimpleSelector.AttributeMatcher)

    lexème_courant := parseuse.lexème_courant()

    si lexème_courant.est_lexème_tilde() {
        matcher = SimpleSelector.AttributeMatcher.INCLUS
        parseuse.avance()
    }
    sinon si lexème_courant.est_lexème_pipe() {
        matcher = SimpleSelector.AttributeMatcher.DASHMATCH
        parseuse.avance()
    }
    sinon si lexème_courant.est_lexème_circonflèxe() {
        matcher = SimpleSelector.AttributeMatcher.PREFIXMATCH
        parseuse.avance()
    }
    sinon si lexème_courant.est_lexème_dollar() {
        matcher = SimpleSelector.AttributeMatcher.SUFFIXMATCH
        parseuse.avance()
    }
    sinon si lexème_courant.est_lexème_fois() {
        matcher = SimpleSelector.AttributeMatcher.SUBSTRINGMATCH
        parseuse.avance()
    }

    lexème_courant = parseuse.lexème_courant()

    saufsi lexème_courant.est_lexème_égal() {
        parseuse.rapporte_erreur("Attendu '=' pour le matcher")
        parseuse.possède_erreur = vrai
        retourne
    }
    parseuse.avance()

    saufsi matcher.possède_valeur() {
        matcher = SimpleSelector.AttributeMatcher.EST_ÉGAL
    }

    retourne matcher
}

/* <pseudo-class-selector> = ':' <ident-token> |
                             ':' <function-token> <any-value> ')' */
parse_pseudo_class_selector :: fonc (parseuse: &ParseuseSelector, pour_pseudo_element: bool, résultat: *SimpleSelector) -> ÉtatParsage
{
    parseuse_locale : ParseuseSelector = parseuse

    saufsi parseuse_locale.lexème_courant().est_lexème_de_genre(GenreLexème.Colon) {
        retourne ÉtatParsage.EssaieEncore
    }

    parseuse_locale.avance()
    si parseuse_locale.apparie_lexème_ident() {
        ident := parseuse_locale.lexème_courant().lexème.valeur
        parseuse_locale.avance()

        parseuse.curseur = parseuse_locale.curseur

        /* Pour ces pseudo-classes, nous changeons le type en pseudo-élément
         * directement au cas où nous ne serions pas appelés depuis
         * parse_pseudo_element car il est possible de n'avoir qu'un seul
         * double point pour ceux-ci pour des raisons historiques. */
        si pour_pseudo_element || ident == PROP_before || ident == PROP_after || ident == PROP_first_line || ident == PROP_first_letter {
            mémoire(résultat) = crée_pseudo_element_selector(ident)
            retourne ÉtatParsage.Ok
        }

        pseudo_classe := donne_pseudo_classe_pour_nom(ident)
        saufsi pseudo_classe.possède_valeur() {
            retourne ÉtatParsage.Erreur
        }

        mémoire(résultat) = crée_pseudo_class_selector(pseudo_classe.Quelque)
        retourne ÉtatParsage.Ok
    }

    si parseuse_locale.lexème_courant().est_fonction() {
        fonction := parseuse_locale.lexème_courant().function
        nom_fonction := fonction.name

        /* https://www.w3.org/TR/selectors-4/#negation */
        si nom_fonction == PROP_not {
            parseuse_locale.avance()

            opt_selectors := parse_selector_list(fonction.value)
            si opt_selectors.possède_valeur() {
                parseuse.curseur = parseuse_locale.curseur
                mémoire(résultat) = crée_function_selector(nom_fonction, opt_selectors.Quelque)
                retourne ÉtatParsage.Ok
            }
        }
        /* https://www.w3.org/TR/selectors-4/#matches */
        sinon si nom_fonction == PROP_is {
            parseuse_locale.avance()

            /* À FAIRE : ceci doit être parse_forgiving_selector_list */
            opt_selectors := parse_selector_list(fonction.value)
            si opt_selectors.possède_valeur() {
                parseuse.curseur = parseuse_locale.curseur
                mémoire(résultat) = crée_function_selector(nom_fonction, opt_selectors.Quelque)
                retourne ÉtatParsage.Ok
            }
        }
        /* https://www.w3.org/TR/selectors-4/#zero-matches */
        sinon si nom_fonction == PROP_where {
            parseuse_locale.avance()

            /* À FAIRE : ceci doit être parse_forgiving_selector_list */
            opt_selectors := parse_selector_list(fonction.value)
            si opt_selectors.possède_valeur() {
                parseuse.curseur = parseuse_locale.curseur
                mémoire(résultat) = crée_function_selector(nom_fonction, opt_selectors.Quelque)
                retourne ÉtatParsage.Ok
            }
        }
        /* https://www.w3.org/TR/css-scoping-1/#selectordef-host0 */
        sinon si nom_fonction == PROP_host {
            parseuse_locale.avance()

            /* À FAIRE : ceci doit être parse_compound_selector */
            opt_selectors := parse_selector_list(fonction.value)
            si opt_selectors.possède_valeur() {
                parseuse.curseur = parseuse_locale.curseur
                mémoire(résultat) = crée_function_selector(nom_fonction, opt_selectors.Quelque)
                retourne ÉtatParsage.Ok
            }
        }
        /* https://www.w3.org/TR/selectors-4/#the-dir-pseudo */
        sinon si nom_fonction == PROP_dir {
            parseuse_locale.avance()

            si fonction.value.taille == 1 && fonction.value[0].est_lexème_de_genre(GenreLexème.Ident) {
                nom := fonction.value[0].lexème.valeur
                si nom == PROP_ltr || nom == PROP_rtl {
                    parseuse.curseur = parseuse_locale.curseur
                    mémoire(résultat) = crée_function_selector(nom_fonction, nom)
                    retourne ÉtatParsage.Ok
                }
            }
        }
        sinon si nom_fonction == PROP_nth_child || nom_fonction == PROP_nth_of_type || nom_fonction == PROP_nth_last_child || nom_fonction == PROP_nth_last_of_type {
            parseuse_locale.avance()

            opt_nth_child := parse_nth_child(fonction.value)
            saufsi opt_nth_child.possède_valeur() {
                retourne ÉtatParsage.Erreur
            }
            
            parseuse.curseur = parseuse_locale.curseur
            mémoire(résultat) = crée_nth_child_selector(nom_fonction, opt_nth_child.Quelque)
            retourne ÉtatParsage.Ok
        }
        sinon si nom_fonction == PROP_has {
            // À FAIRE : exclus :has() -> erreur
            // À FAIRE : exclus les pseudos éléments -> erreur
            parseuse_locale.avance()

            relative_selectors := parse_relative_selector_list(fonction.value)
            saufsi relative_selectors.possède_valeur() {
                retourne ÉtatParsage.Erreur
            }
            
            parseuse.curseur = parseuse_locale.curseur
            mémoire(résultat) = crée_function_selector(nom_fonction, relative_selectors.Quelque)
            retourne ÉtatParsage.Ok
        }
        sinon {
            imprime("fonction non supporté : %, lexème : %\n", nom_fonction, parseuse_locale.lexème_courant())
        }
        retourne ÉtatParsage.Erreur
    }

    saufsi pour_pseudo_element {
        retourne ÉtatParsage.EssaieEncore
    }

    retourne ÉtatParsage.Erreur
}

parse_nth_child :: fonc (value: []ComponentValue) -> Optionnel(SimpleSelector.NthChild)
{
    parseuse := initialise_une_parseuse(value)
    parseuse.consomme_espaces_blanches()

    lexème := parseuse.lexème_courant()

    si lexème.est_mot_clé(PROP_odd) {
        retourne SimpleSelector.NthChild(2, 1)
    }

    si lexème.est_mot_clé(PROP_even) {
        retourne SimpleSelector.NthChild(2)
    }

    chn_moins_n := crée_chaine_utf16_unique("-n")
    chn_n := crée_chaine_utf16_unique("n")

    A_est_négatif := faux
    A: z32
    si lexème.est_lexème_moins() {
        /* -n */
        parseuse.avance()
        A_est_négatif = vrai

        parseuse.consomme_espaces_blanches()
        lexème = parseuse.lexème_courant()
        saufsi lexème.est_lexème_de_genre(GenreLexème.Ident) {
            retourne
        }
        parseuse.avance()

        si lexème.lexème.valeur != chn_n {
            retourne
        }

        A = -1
    }
    sinon si lexème.est_mot_clé(chn_moins_n) {
        parseuse.avance()
        A = -1
    }
    sinon si lexème.est_mot_clé(chn_n) {
        parseuse.avance()
        A = 1
    }
    sinon {
        si lexème.est_lexème_de_genre(GenreLexème.Number) {
            B := lexème.lexème.numeric_value comme z32
            retourne SimpleSelector.NthChild(0, B)
        }

        saufsi lexème.est_lexème_de_genre(GenreLexème.Dimension) {
            retourne
        }
        parseuse.avance()
        si lexème.lexème.unité != chn_n {
            retourne
        }
        A = lexème.lexème.numeric_value comme z32
    }

    parseuse.consomme_espaces_blanches()
    lexème = parseuse.lexème_courant()

    est_négatif := faux

    si lexème.est_lexème_plus() {
        parseuse.avance()
    }
    sinon si lexème.est_lexème_moins() {
        parseuse.avance()
        est_négatif = vrai
    }
    sinon si parseuse.fini() {
        retourne SimpleSelector.NthChild(A)
    }

    // Dans le cas de "2n+1" (sans espaces) il semblerait que le lexage fusionne "+1" en un simple "1".
    // Donc nous ne n'avortons pas s'il n'y a pas de signe.

    parseuse.consomme_espaces_blanches()
    lexème = parseuse.lexème_courant()
    saufsi lexème.est_lexème_de_genre(GenreLexème.Number) {
        retourne
    }

    B := lexème.lexème.numeric_value comme z32
    si est_négatif {
        B = -B
    }
    parseuse.avance()

    retourne SimpleSelector.NthChild(A, B)
}

/* <pseudo-element-selector> = ':' <pseudo-class-selector> */
parse_pseudo_element_selector :: fonc (parseuse: &ParseuseSelector, résultat: *SimpleSelector) -> ÉtatParsage
{
    parseuse_locale : ParseuseSelector = parseuse

    saufsi parseuse_locale.lexème_courant().est_lexème_de_genre(GenreLexème.Colon) {
        retourne ÉtatParsage.EssaieEncore
    }

    parseuse_locale.avance()

    état := parseuse_locale.parse_pseudo_class_selector(vrai, résultat)
    si état == ÉtatParsage.Ok {
        parseuse.curseur = parseuse_locale.curseur
    }

    retourne état
}

/* <combinator> = '>' | '+' | '~' | [ '|' '|' ] */
parse_combinateur :: fonc (parseuse: &ParseuseSelector, résultat: *Combinator) -> ÉtatParsage
{
    // imprime("[%]\n", #nom_de_cette_fonction)

    combinateur: Optionnel(Combinator)

    si parseuse.lexème_courant().est_lexème_de_genre(GenreLexème.Whitespace) {
        /* À FAIRE : nouvelle ligne ? */
        combinateur = Combinator.DESCENDANT
    }

    consomme_espaces_blanches(parseuse)

    saufsi parseuse.fini() {
        lexème := parseuse.lexème_courant()

        si lexème.est_lexème_greater() {
            parseuse.avance()
            combinateur = Combinator.CHILD
        }
        sinon si lexème.est_lexème_plus() {
            parseuse.avance()
            combinateur = Combinator.NEXT_SIBLING
        }
        sinon si lexème.est_lexème_tilde() {
            parseuse.avance()
            combinateur = Combinator.SUBSEQUENT_SIBLING
        }
        sinon si lexème.est_lexème_pipe() {
            parseuse.avance()
            lexème = parseuse.lexème_courant()
            si lexème.est_lexème_pipe() {
                parseuse.avance()
                combinateur = Combinator.COLUMN
            }
            sinon {
                retourne ÉtatParsage.Erreur
            }
        }

        consomme_espaces_blanches(parseuse)
    }

    si combinateur.possède_valeur() {
        mémoire(résultat) = combinateur.Quelque
        retourne ÉtatParsage.Ok
    }

    retourne ÉtatParsage.EssaieEncore
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Parsage de "media queries".
 * https://drafts.csswg.org/mediaqueries/#mq-syntax
 * \{ */

/* https://drafts.csswg.org/mediaqueries/#typedef-media-query-list */
parse_a_media_query_list :: fonc (values: []ComponentValue) -> *MediaList
{
    groups := parse_a_comma_separated_list_of_component_values(values)
    diffère {
        pour groups {
            déloge(it)
        }
        déloge(groups)
    }

    si groups.taille == 0 {
        retourne nul
    }

    résultat := loge(MediaList)

    pour groups {
        parseuse := initialise_une_parseuse(it)
        media_query := parse_a_media_query(parseuse)
        si media_query == nul || parseuse.possède_erreur {
            /* Si nous ne pouvons pas parser la liste, nous abandonnons, et la règle sera ignoré. */
            détruit_media_list(résultat)
            retourne nul
        }

        tableau_ajoute(*résultat.media_queries, media_query)
    }

    retourne résultat
}

// <media-query> = <media-condition>
//              | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?
parse_a_media_query :: fonc (parseuse: &Parseuse(ComponentValue)) -> *MediaQuery
{
    condition := parse_a_media_condition(parseuse)
    si condition {
        retourne condition
    }

    not_rencontré := faux

    parseuse.consomme_espaces_blanches()
    lexème := parseuse.lexème_courant()
    si lexème.est_mot_clé(PROP_only) {
        parseuse.avance()
        /* Rien à faire, 'only' est uniquement utilisé pour désactiver la
         * requête sur les agents ne supportant pas la nouvelle syntaxe post-HTML4. */
    }
    sinon si lexème.est_mot_clé(PROP_not) {
        parseuse.avance()
        not_rencontré = vrai
    }

    media_type := parse_a_media_type(parseuse)
    saufsi media_type {
        retourne nul
    }

    parseuse.consomme_espaces_blanches()
    lexème = parseuse.lexème_courant()
    si lexème.est_mot_clé(PROP_and) {
        parseuse.avance()

        droite := parse_a_media_condition_without_or(parseuse)
        saufsi droite {
            retourne nul
        }

        retourne crée_media_query_and(media_type, droite)
    }

    si not_rencontré {
        retourne crée_media_query_not(media_type)
    }

    retourne media_type
}

// <media-type> = <ident>
parse_a_media_type :: fonc (parseuse: &Parseuse(ComponentValue)) -> *MediaQuery
{
    parseuse.consomme_espaces_blanches()
    lexème := parseuse.lexème_courant()

    si lexème.est_lexème_de_genre(GenreLexème.Ident) {
        parseuse.avance()
        ident := lexème.donne_texte()
        retourne crée_media_query_type(ident)
    }

    retourne nul
}

// <media-condition> = <media-not> | <media-in-parens> [ <media-and>* | <media-or>* ]
parse_a_media_condition :: fonc (parseuse: &Parseuse(ComponentValue)) -> *MediaQuery
{
    media_not := parse_a_media_not(parseuse)
    si media_not {
        retourne media_not
    }

    media_in_parens := parse_a_media_in_parens(parseuse)
    saufsi media_in_parens {
        retourne nul
    }

    gauche := media_in_parens

    tantque !parseuse.fini() {
        parseuse.consomme_espaces_blanches()
        lexème := parseuse.lexème_courant()

        si lexème.est_mot_clé(PROP_and) {
            parseuse.avance()

            media_and := parse_a_media_and(parseuse, gauche)
            saufsi media_and {
                retourne nul
            }

            gauche = media_and
            continue
        }

        si lexème.est_mot_clé(PROP_or) {
            parseuse.avance()

            media_or := parse_a_media_or(parseuse, gauche)
            saufsi media_or {
                retourne nul
            }

            gauche = media_or
            continue
        }

        si lexème.est_lexème_de_genre(GenreLexème.EOF) {
            parseuse.avance()
            arrête
        }

        parseuse.consomme_espaces_blanches()
    }

    retourne gauche
}

// <media-condition-without-or> = <media-not> | <media-in-parens> <media-and>*
parse_a_media_condition_without_or :: fonc (parseuse: &Parseuse(ComponentValue)) -> *MediaQuery
{
    media_not := parse_a_media_not(parseuse)
    si media_not {
        retourne media_not
    }

    media_in_parens := parse_a_media_in_parens(parseuse)
    saufsi media_in_parens {
        retourne nul
    }

    gauche := media_in_parens

    tantque !parseuse.fini() {
        parseuse.consomme_espaces_blanches()
        lexème := parseuse.lexème_courant()

        si lexème.est_mot_clé(PROP_and) {
            parseuse.avance()

            media_and := parse_a_media_and(parseuse, gauche)
            saufsi media_and {
                retourne nul
            }

            gauche = media_and
            continue
        }

        si lexème.est_lexème_de_genre(GenreLexème.EOF) {
            parseuse.avance()
            arrête
        }

        parseuse.consomme_espaces_blanches()
    }

    retourne gauche
}

// <media-not> = not <media-in-parens>
parse_a_media_not :: fonc (parseuse: &Parseuse(ComponentValue)) -> *MediaQuery
{
    parseuse.consomme_espaces_blanches()
    lexème := parseuse.lexème_courant()
    
    saufsi lexème.est_mot_clé(PROP_not) {
        retourne nul
    }

    parseuse.avance()

    opérande := parse_a_media_in_parens(parseuse)
    saufsi opérande {
        parseuse.possède_erreur = vrai
        retourne nul
    }

    retourne crée_media_query_not(opérande)
}

// <media-and> = and <media-in-parens>
parse_a_media_and :: fonc (parseuse: &Parseuse(ComponentValue), gauche: *MediaQuery) -> *MediaQuery
{
    parseuse.consomme_espaces_blanches()
    lexème := parseuse.lexème_courant()
    
    saufsi lexème.est_mot_clé(PROP_and) {
        retourne nul
    }

    parseuse.avance()

    droite := parse_a_media_in_parens(parseuse)
    saufsi droite {
        retourne nul
    }

    retourne crée_media_query_and(gauche, droite)
}

// <media-or> = or <media-in-parens>
parse_a_media_or :: fonc (parseuse: &Parseuse(ComponentValue), gauche: *MediaQuery) -> *MediaQuery
{
    parseuse.consomme_espaces_blanches()
    lexème := parseuse.lexème_courant()
    
    saufsi lexème.est_mot_clé(PROP_or) {
        retourne nul
    }

    parseuse.avance()

    droite := parse_a_media_in_parens(parseuse)
    saufsi droite {
        retourne nul
    }

    retourne crée_media_query_or(gauche, droite)
}

// <media-in-parens> = ( <media-condition> ) | ( <media-feature> ) | <general-enclosed>
parse_a_media_in_parens :: fonc (parseuse: &Parseuse(ComponentValue)) -> *MediaQuery
{
    parseuse.consomme_espaces_blanches()
    lexème := parseuse.lexème_courant()

    saufsi lexème.est_simple_bloc_de_genre(GenreLexème.Open_Parenthesis) {
        retourne nul
    }

    parseuse.avance()

    bloc := lexème.bloc

    parseuse_locale := initialise_une_parseuse(bloc.value)
    media_condition := parse_a_media_condition(parseuse_locale)
    parseuse.possède_erreur = parseuse_locale.possède_erreur
    si media_condition {
        retourne crée_media_query_in_parens(media_condition)
    }

    parseuse_locale = initialise_une_parseuse(bloc.value)
    media_feature := parse_a_media_feature(parseuse_locale)
    parseuse.possède_erreur = parseuse_locale.possède_erreur
    si media_feature {
        retourne crée_media_query_in_parens(media_feature)
    }

    // À FAIRE : <general-enclosed>

    retourne nul
}

// <media-feature> = [ <mf-plain> | <mf-boolean> | <mf-range> ]
parse_a_media_feature :: fonc (parseuse: &Parseuse(ComponentValue)) -> *MediaQuery
{
    parseuse_locale : Parseuse(ComponentValue) = parseuse
    opt_mf_plain := parse_mf_plain(parseuse_locale)
    parseuse.possède_erreur = parseuse_locale.possède_erreur
    si opt_mf_plain.possède_valeur() {
        parseuse.curseur = parseuse_locale.curseur
        retourne crée_media_query_feature(opt_mf_plain.Quelque)
    }

    parseuse_locale = parseuse
    opt_mf_boolean := parse_mf_boolean(parseuse_locale)
    parseuse.possède_erreur = parseuse_locale.possède_erreur
    si opt_mf_boolean.possède_valeur() {
        parseuse.curseur = parseuse_locale.curseur
        retourne crée_media_query_feature(opt_mf_boolean.Quelque)
    }

    // À FAIRE
    // parseuse_locale = parseuse
    // opt_mf_range := parse_mf_range(parseuse_locale)
    // si opt_mf_range.possède_valeur() {
    //     retourne crée_media_query_feature(opt_mf_range.Quelque)
    // }
    
    retourne nul
}

// <mf-plain> = <mf-name> : <mf-value>
parse_mf_plain :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(MediaFeaturePlain)
{
    opt_mf_name := parse_mf_name(parseuse)
    saufsi opt_mf_name.possède_valeur() {
        retourne
    }

    parseuse.consomme_espaces_blanches()
    lexème := parseuse.lexème_courant()
    saufsi lexème.est_lexème_de_genre(GenreLexème.Colon) {
        retourne
    }
    parseuse.avance()

    opt_value := parseuse.parse_mf_value()
    saufsi opt_value.possède_valeur() {
        parseuse.possède_erreur = vrai
        retourne
    }

    résultat: MediaFeaturePlain
    résultat.name = opt_mf_name.Quelque
    résultat.value = opt_value.Quelque
    retourne résultat
}

// <mf-boolean> = <mf-name>
parse_mf_boolean :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(MediaFeatureBoolean)
{
    opt_mf_name := parse_mf_name(parseuse)
    saufsi opt_mf_name.possède_valeur() {
        retourne
    }

    résultat: MediaFeatureBoolean
    résultat.name = opt_mf_name.Quelque
    retourne résultat
}

// <mf-range> = <mf-name> <mf-comparison> <mf-value>
//            | <mf-value> <mf-comparison> <mf-name>
//            | <mf-value> <mf-lt> <mf-name> <mf-lt> <mf-value>
//            | <mf-value> <mf-gt> <mf-name> <mf-gt> <mf-value>

// <mf-name> = <ident>
parse_mf_name :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(CSSOMString)
{
    parseuse.consomme_espaces_blanches()
    lexème := parseuse.lexème_courant()

    saufsi lexème.est_lexème_de_genre(GenreLexème.Ident) {
        retourne
    }

    parseuse.avance()
    retourne lexème.donne_texte()
}

// <mf-value> = <number> | <dimension> | <ident> | <ratio>
parse_mf_value :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(MediaFeatureValue)
{
    parseuse.consomme_espaces_blanches()
    lexème := parseuse.lexème_courant()

    si lexème.est_lexème_de_genre(GenreLexème.Number) {
        parseuse.avance()
        retourne MediaFeatureValue(number = lexème.lexème.numeric_value)
    }

    si lexème.est_lexème_de_genre(GenreLexème.Dimension) {
        données_lexème := lexème.lexème

        unité := donne_unité_pour_nom(données_lexème.unité)
        si unité.possède_valeur() {
            parseuse.avance()
            longueur := Longueur(données_lexème.numeric_value, unité.Quelque)
            retourne MediaFeatureValue(dimension = longueur)
        }

        retourne
    }

    si lexème.est_lexème_de_genre(GenreLexème.Ident) {
        parseuse.avance()
        retourne MediaFeatureValue(ident = lexème.donne_texte())
    }

    // À FAIRE : calc
    // À FAIRE : ratio
}

// <mf-lt> = '<' '='?
// <mf-gt> = '>' '='?
// <mf-eq> = '='
// <mf-comparison> = <mf-lt> | <mf-gt> | <mf-eq>

// <general-enclosed> = [ <function-token> <any-value>? ) ] | [ ( <any-value>? ) ]

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Parsage de feuilles de style.
 * \{ */

ContexteParsageFeuilleDeStyle :: struct {
    propriétés_non_supportées: [..]CSSOMString
}

rapporte_propriétés_non_supportées :: fonc (ctx: *ContexteParsageFeuilleDeStyle, fonction: chaine)
{
    pour ctx.propriétés_non_supportées {
        imprime("[CSS][%] propriété non-supportée : %\n", fonction, it)
    }
}

détruit_données_contexte :: fonc (ctx: *ContexteParsageFeuilleDeStyle)
{
    déloge(ctx.propriétés_non_supportées)
}

donne_info_type_pour_nom :: fonc (ctx: *ContexteParsageFeuilleDeStyle, nom: CSSOMString) -> *InfoTypePropriété
{
    résultat := donne_info_type_pour_nom(nom)
    si résultat == nul && logue_propriétés_non_supportées {
        saufsi commence_par_préfixe_vendeur(nom) {
            ensemble_ajoute(*ctx.propriétés_non_supportées, nom)
        }
    }
    retourne résultat
}

commence_par_préfixe_vendeur :: fonc (nom: CSSOMString) -> bool
{
    préfixes_vendeurs := [PRV_khtml, PRV_moz, PRV_ms, PRV_o, PRV_webkit]

    pour préfixes_vendeurs {
        préfixe := it.donne_chaine_utf16()
        si est_préfixe_de(préfixe, nom.donne_chaine_utf16()) {
            retourne vrai
        }
    }

    retourne faux
}

/* https://www.w3.org/TR/css-syntax-3/#parse-a-css-stylesheet */
parse_a_css_style_sheet :: fonc (ctx: *ContexteParsageFeuilleDeStyle, contenu: chaine) -> *CSSStyleSheet
{
    résultat := loge(CSSStyleSheet)
    résultat.type = crée_chaine_utf16_unique("text/css")

    parse_style_rules(ctx, résultat, contenu)

    retourne résultat
}

parse_style_rules :: fonc (ctx: *ContexteParsageFeuilleDeStyle, css_stylesheet: *CSSStyleSheet, contenu: chaine)
{
    lexèmes := lèxe_style(contenu)
    diffère détruit_lexèmes(*lexèmes)

    stylesheet := parse_a_stylesheet(lexèmes)
    diffère détruit_données_stylesheet(*stylesheet)

    pour stylesheet.value {
        rule := parse_a_rule_generic(ctx, css_stylesheet, it)
        si rule {
            tableau_ajoute(*css_stylesheet.rules, rule)
        }
    }
}

parse_a_rule_generic :: fonc (ctx: *ContexteParsageFeuilleDeStyle, parent_style_sheet: *CSSStyleSheet, parsed_rule: *ParsedRule) -> *CSSRule
{
    si parsed_rule.type == ParsedQualifiedRule {
        retourne parse_a_style_rule(ctx, parent_style_sheet, parsed_rule comme *ParsedQualifiedRule)
    }

    si parsed_rule.type == ParsedAtRule {
        at_rule := parsed_rule comme *ParsedAtRule

        si at_rule.name == PROP_media {
            retourne parse_a_media_rule(ctx, parent_style_sheet, at_rule)
        }
    }

    retourne nul
}

/* https://www.w3.org/TR/css-syntax-3/#style-rules */
parse_a_style_rule :: fonc (ctx: *ContexteParsageFeuilleDeStyle, parent_style_sheet: *CSSStyleSheet, parsed_rule: *ParsedQualifiedRule) -> *CSSStyleRule
{
    selectors := parse_selector_list(parsed_rule.prelude)
    saufsi selectors.possède_valeur() {
        /* Si nous n'arrivons pas à parser les sélecteurs,
         * nous devons ignorer la règle. */
        retourne nul
    }

    résultat := loge(CSSStyleRule)
    résultat.parent_style_sheet = parent_style_sheet
    résultat.selector_list = selectors.Quelque

    content := parse_a_style_block_s_contents(parsed_rule.bloc.value)
    diffère détruit_content(content, faux)

    /* Ne considère que les déclarations.
     * À FAIRE : @nest peut être préservé. */
    style := parse_css_style_declaration(ctx, content.decls)
    résultat.style = style
    style.parent_css_rule = résultat

    si style.déclarations.taille == 0 {
        détruit_style_rule(résultat)
        retourne nul
    }

    retourne résultat
}

/* https://drafts.csswg.org/css-conditional-3/#at-media */
parse_a_media_rule :: fonc (ctx: *ContexteParsageFeuilleDeStyle, parent_style_sheet: *CSSStyleSheet, parsed_rule: *ParsedAtRule) -> *CSSMediaRule
{
    media_list := parse_a_media_query_list(parsed_rule.prelude)
    saufsi media_list {
        retourne nul
    }

    parseuse := initialise_une_parseuse(parsed_rule.bloc.value)
    règles := consomme_une_liste_de_règles(parseuse, vrai)
    diffère déloge(règles)

    résultat := loge(CSSMediaRule)
    résultat.parent_style_sheet = parent_style_sheet
    résultat.media_list = media_list

    pour règles {
        rule := parse_a_rule_generic(ctx, parent_style_sheet, it)
        si rule {
            tableau_ajoute(*résultat.css_rules, rule)
        }
    }

    retourne résultat
}

ContexteParsageShorthand :: struct {
    déclaration: *CSSStyleDeclaration
    
    déclaration_parsée: *ParsedDeclaration

    sur_ajoute_propriété := contexte_parsage_shorthand_ajoute_propriété
}

ajoute_propriété :: fonc (ctx: *ContexteParsageShorthand, nom: CSSOMString, valeur: *ValeurDeStyle)
{
    ctx.sur_ajoute_propriété(ctx, nom, valeur)
}

contexte_parsage_shorthand_ajoute_propriété :: fonc (ctx: *ContexteParsageShorthand, nom: CSSOMString, valeur: *ValeurDeStyle)
{
    info_type_propriété := donne_info_type_pour_nom(nom)
    saufsi info_type_propriété {
        retourne
    }

    déclaration := loge(DéclarationPropriété)
    déclaration.info = info_type_propriété
    déclaration.property_name = nom
    /// XXX - fuite de mémoire sur copie_valeur()
    tableau_ajoute(*déclaration.value, copie_valeur(valeur))
    déclaration.important = ctx.déclaration_parsée.important

    ctx.déclaration.ajoute_déclaration(déclaration)
}

/* Les valeurs et noms doivent être données dans l'ordre : top, right, bottom, left. Voir #BorderEdge. */
ajoute_propriétés_boite :: fonc (ctx: *ContexteParsageShorthand, nombre_valeurs: z64, valeurs: [4]*ValeurDeStyle, noms: [4]CSSOMString)
{
    si nombre_valeurs == 1 {
        pour 4 {
            ajoute_propriété(ctx, noms[it], valeurs[0])
        }
    }
    sinon si nombre_valeurs == 2 {
        ajoute_propriété(ctx, noms[BorderEdge.Top], valeurs[0])
        ajoute_propriété(ctx, noms[BorderEdge.Bottom], valeurs[0])
        ajoute_propriété(ctx, noms[BorderEdge.Right], valeurs[1])
        ajoute_propriété(ctx, noms[BorderEdge.Left], valeurs[1])
    }
    sinon si nombre_valeurs == 3 {
        ajoute_propriété(ctx, noms[BorderEdge.Top], valeurs[0])
        ajoute_propriété(ctx, noms[BorderEdge.Right], valeurs[1])
        ajoute_propriété(ctx, noms[BorderEdge.Left], valeurs[1])
        ajoute_propriété(ctx, noms[BorderEdge.Bottom], valeurs[2])
    }
    sinon {
        assert(nombre_valeurs == 4)
        ajoute_propriété(ctx, noms[BorderEdge.Top], valeurs[0])
        ajoute_propriété(ctx, noms[BorderEdge.Right], valeurs[1])
        ajoute_propriété(ctx, noms[BorderEdge.Bottom], valeurs[2])
        ajoute_propriété(ctx, noms[BorderEdge.Left], valeurs[3])
    }
}

/* Les valeurs et noms doivent être données dans l'ordre : start, end. */
ajoute_propriétés_logique :: fonc (ctx: *ContexteParsageShorthand, nombre_valeurs: z64, valeurs: [2]*ValeurDeStyle, noms: [2]CSSOMString)
{
    si nombre_valeurs == 1 {
        ajoute_propriété(ctx, noms[0], valeurs[0])
        ajoute_propriété(ctx, noms[1], valeurs[0])
    }
    sinon {
        assert(nombre_valeurs == 2)
        ajoute_propriété(ctx, noms[0], valeurs[0])
        ajoute_propriété(ctx, noms[1], valeurs[1])
    }
}

parse_mot_clé_global :: fonc (ctx: *ContexteParsageShorthand, noms_propriétés: []CSSOMString, value: []ComponentValue) -> bool
{
    parseuse := initialise_une_parseuse(value)
    valeur := parse_css_wide_keyword(parseuse)
    saufsi valeur.possède_valeur() {
        retourne faux
    }

    pour noms_propriétés {
        ctx.ajoute_propriété(it, valeur.Quelque)
    }

    retourne vrai
}

parse_shorthand_avec_variable :: fonc (ctx: *ContexteParsageShorthand, info_type_propriété: *InfoTypePropriété, value: []ComponentValue) -> bool
{
    pour value {
        si it.est_fonction(PROP_var) {
            arrête
        }
    }
    sansarrêt {
        retourne faux
    }

    déclaration := loge(DéclarationPropriété)
    déclaration.info = info_type_propriété
    déclaration.property_name = info_type_propriété.nom
    déclaration.important = ctx.déclaration_parsée.important
    déclaration.est_shorthand_avec_variable = vrai
    déclaration.valeur_personnalisée = copie_tableau_component_value(value)

    ctx.déclaration.ajoute_déclaration(déclaration)

    retourne vrai
}

parse_css_style_declaration :: fonc (ctx: *ContexteParsageFeuilleDeStyle, déclarations: []ParsedDeclaration) -> *CSSStyleDeclaration
{
    résultat := loge(CSSStyleDeclaration)

    pour déclarations {
        si est_propriété_personnalisée(it.name) {
            déclaration := loge(DéclarationPropriété)
            déclaration.property_name = it.name
            déclaration.case_sensitive = vrai
            déclaration.est_personnalisée = vrai
            déclaration.valeur_personnalisée = copie_tableau_component_value(it.value)
            résultat.ajoute_déclaration(déclaration)
            continue
        }

        info_type_propriété := donne_info_type_pour_nom(ctx, it.name)
        saufsi info_type_propriété {
            continue
        }

        si info_type_propriété.sur_parsage_shorthand {
            ctx_parsage_shorthand: ContexteParsageShorthand
            ctx_parsage_shorthand.déclaration_parsée = *it
            ctx_parsage_shorthand.déclaration = résultat

            si parse_shorthand_avec_variable(*ctx_parsage_shorthand, info_type_propriété, it.value) {
                continue
            }

            saufsi info_type_propriété.sur_parsage_shorthand(*ctx_parsage_shorthand, it.value) {
                rapporte_erreur_de_parsage(it)
            }

            continue
        }

        opt_valeur := parse_valeur_propriété(info_type_propriété, it.value)
        saufsi opt_valeur.possède_valeur() {
            rapporte_erreur_de_parsage(it)
            continue
        }

        déclaration := loge(DéclarationPropriété)
        déclaration.info = info_type_propriété
        déclaration.property_name = it.name
        tableau_ajoute(*déclaration.value, opt_valeur.Quelque)
        déclaration.important = it.important

        résultat.ajoute_déclaration(déclaration)
    }

    retourne résultat
}

rapporte_erreur_de_parsage :: fonc (déclaration: ParsedDeclaration)
{
    saufsi logue_erreurs_de_parsage {
        retourne
    }

    pour déclaration.value {
        si it.est_lexème_de_genre(GenreLexème.Ident) {
            si commence_par_préfixe_vendeur(it.lexème.valeur) {
                retourne
            }
        }
        sinon si it.est_fonction() {
            fonction := it.function
            si commence_par_préfixe_vendeur(fonction.name) {
                retourne
            }
        }
    }

    imprime("Impossible de parser : %\n", déclaration)
}

parse_valeur_propriété :: fonc (info_type_propriété: *InfoTypePropriété, value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    opt_valeur := info_type_propriété.fonction_de_parsage(value)
    si opt_valeur.possède_valeur() {
        retourne opt_valeur
    }

    parseuse := initialise_une_parseuse(value)
    opt_valeur = parse_mot_clé_global_ou_var(parseuse)
    si opt_valeur.possède_valeur() {
        retourne opt_valeur
    }
}

est_propriété_personnalisée :: fonc (nom: CSSOMString) -> bool
{
    chn := nom.donne_chaine_utf16()
    si chn.taille() < 2 {
        retourne faux
    }

    HYPHEN := '-' comme n32

    retourne chn.unités[0] == HYPHEN && chn.unités[1] == HYPHEN
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom InfoTypePropriété
 * \{ */

#portée_module

DrapeauxPropriété :: énum_drapeau {
    /* La propriété est léguée aux descendants. */
    Héritée
    /* Un changement de valeur requiers une redisposition. */
    AffecteDisposition
    /* Un changement de valeur requiers une reconstruction de l'arbre. */
    AffecteConstructionArbre
    /* Un changement de valeur requiers la reconstruction des stacking contexts. */
    AffecteStackingContext
    /* Une valeur négative nous fait ignorer la propriété lors du calcul du style. */
    ValeurNégativeIllégale
}

InfoTypePropriété :: struct {
    nom: CSSOMString
    drapeaux: DrapeauxPropriété
    genre_valeur_calculée: GenreValeurCalculée
    id: IDPropriété
    fonction_de_parsage: fonc([]ComponentValue)(Optionnel(*ValeurDeStyle))
    sur_parsage_shorthand: fonc(*ContexteParsageShorthand, []ComponentValue)(bool)
    sur_calcul_style: fonc(*DéclarationPropriété, *Style, *ContexteCalculStyle)(rien)
}

NOMBRE_PROPRIÉTÉS_SHORTHAND :: 26
NOMBRE_PROPRIÉTÉS :: 108

infos_types_propriétés_shorthand : [NOMBRE_PROPRIÉTÉS_SHORTHAND]InfoTypePropriété = ---
infos_types_propriétés : [NOMBRE_PROPRIÉTÉS]InfoTypePropriété = ---
infos_types_propriétés_pour_id : [IDPropriété.nombre_éléments]*InfoTypePropriété = ---

donne_info_type_pour_nom :: fonc (nom: CSSOMString) -> *InfoTypePropriété
{
    initialise_tables_infos_propriétés()

    pour infos_types_propriétés_shorthand {
        si it.nom == nom {
            retourne *infos_types_propriétés_shorthand[indice_it]
        }
    }
    pour infos_types_propriétés {
        si it.nom == nom {
            retourne *infos_types_propriétés[indice_it]
        }
    }
    retourne nul
}

#portée_fichier

__infos_propriétés_initialisées := faux

initialise_tables_infos_propriétés :: fonc ()
{
    si __infos_propriétés_initialisées {
        retourne
    }

    __infos_propriétés_initialisées = vrai

    infos_types_propriétés_shorthand = [
        InfoTypePropriété(PROP_background, sur_parsage_shorthand = parse_propriété_background),
        InfoTypePropriété(PROP_border, sur_parsage_shorthand = parse_propriété_border, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_border_color, sur_parsage_shorthand = parse_propriété_border_color),
        InfoTypePropriété(PROP_border_style, sur_parsage_shorthand = parse_propriété_border_style),
        InfoTypePropriété(PROP_border_width, sur_parsage_shorthand = parse_propriété_border_width, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_border_top, sur_parsage_shorthand = parse_propriété_border_edge, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_border_left, sur_parsage_shorthand = parse_propriété_border_edge, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_border_bottom, sur_parsage_shorthand = parse_propriété_border_edge, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_border_right, sur_parsage_shorthand = parse_propriété_border_edge, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_margin, sur_parsage_shorthand = parse_propriété_margin, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_margin_block, sur_parsage_shorthand = parse_propriété_margin_logique, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_margin_inline, sur_parsage_shorthand = parse_propriété_margin_logique, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_text_decoration, sur_parsage_shorthand = parse_propriété_text_decoration),
        InfoTypePropriété(PROP_padding, sur_parsage_shorthand = parse_propriété_padding, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_padding_block, sur_parsage_shorthand = parse_propriété_padding_logique, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_padding_inline, sur_parsage_shorthand = parse_propriété_padding_logique, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_inset, sur_parsage_shorthand = parse_propriété_inset_shorthand, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_inset_block, sur_parsage_shorthand = parse_propriété_inset_logique, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_inset_inline, sur_parsage_shorthand = parse_propriété_inset_logique, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_text_align, sur_parsage_shorthand = parse_propriété_text_align, drapeaux = DrapeauxPropriété.Héritée, genre_valeur_calculée = GenreValeurCalculée.Spécifié),
        InfoTypePropriété(PROP_font, sur_parsage_shorthand = parse_propriété_font, drapeaux = DrapeauxPropriété.AffecteDisposition /* | DrapeauxPropriété.Héritée */),
        InfoTypePropriété(PROP_all, sur_parsage_shorthand = parse_propriété_all, drapeaux = DrapeauxPropriété.AffecteConstructionArbre),
        InfoTypePropriété(PROP_border_radius, sur_parsage_shorthand = parse_propriété_border_radius_shorthand),
        InfoTypePropriété(PROP_overflow, sur_parsage_shorthand = parse_shorthand_overflow),
        InfoTypePropriété(PROP_flex, sur_parsage_shorthand = parse_shorthand_flex),
        InfoTypePropriété(PROP_flex_flow, sur_parsage_shorthand = parse_shorthand_flex_flow)
    ]

    infos_types_propriétés = [
        InfoTypePropriété(PROP_display, id = IDPropriété.Display, fonction_de_parsage = parse_propriété_display, genre_valeur_calculée = GenreValeurCalculée.Display, drapeaux = DrapeauxPropriété.AffecteConstructionArbre),
        InfoTypePropriété(PROP_background_color, id = IDPropriété.BackgroundColor, fonction_de_parsage = parse_propriété_color, genre_valeur_calculée = GenreValeurCalculée.Couleur),
        InfoTypePropriété(PROP_background_image, id = IDPropriété.BackgroundImage, fonction_de_parsage = parse_propriété_background_image, genre_valeur_calculée = GenreValeurCalculée.BackgroundImage),
        InfoTypePropriété(PROP_background_repeat, id = IDPropriété.BackgroundRepeat, fonction_de_parsage = parse_propriété_background_repeat, genre_valeur_calculée = GenreValeurCalculée.BackgroundRepeat),
        InfoTypePropriété(PROP_background_attachment, id = IDPropriété.BackgroundAttachment, fonction_de_parsage = parse_propriété_background_attachment, genre_valeur_calculée = GenreValeurCalculée.Spécifié | GenreValeurCalculée.BackgroundPosition),
        InfoTypePropriété(PROP_background_position, id = IDPropriété.BackgroundPosition, fonction_de_parsage = parse_propriété_background_position, genre_valeur_calculée = GenreValeurCalculée.Spécifié),
        InfoTypePropriété(PROP_background_clip, id = IDPropriété.BackgroundClip, fonction_de_parsage = parse_propriété_valeur_visual_box, genre_valeur_calculée = GenreValeurCalculée.Spécifié),
        InfoTypePropriété(PROP_background_origin, id = IDPropriété.BackgroundOrigin, fonction_de_parsage = parse_propriété_valeur_visual_box, genre_valeur_calculée = GenreValeurCalculée.Spécifié),
        InfoTypePropriété(PROP_background_size, id = IDPropriété.BackgroundSize, fonction_de_parsage = parse_propriété_background_size, genre_valeur_calculée = GenreValeurCalculée.Spécifié | GenreValeurCalculée.BackgroundSize),
        InfoTypePropriété(PROP_color, id = IDPropriété.Color, fonction_de_parsage = parse_propriété_color, drapeaux = DrapeauxPropriété.Héritée, genre_valeur_calculée = GenreValeurCalculée.Couleur),
        InfoTypePropriété(PROP_text_decoration_line, id = IDPropriété.TextDecorationLine, fonction_de_parsage = parse_propriété_text_decoration_line, genre_valeur_calculée = GenreValeurCalculée.TextDecorationLine),
        InfoTypePropriété(PROP_text_decoration_style, id = IDPropriété.TextDecorationStyle, fonction_de_parsage = parse_propriété_text_decoration_style, genre_valeur_calculée = GenreValeurCalculée.TextDecorationStyle),
        InfoTypePropriété(PROP_text_decoration_color, id = IDPropriété.TextDecorationColor, fonction_de_parsage = parse_propriété_color, genre_valeur_calculée = GenreValeurCalculée.Couleur),
        InfoTypePropriété(PROP_text_transform, id = IDPropriété.TextTransform, fonction_de_parsage = parse_propriété_text_transform, drapeaux = DrapeauxPropriété.Héritée, genre_valeur_calculée = GenreValeurCalculée.Spécifié),
        InfoTypePropriété(PROP_cursor, id = IDPropriété.Cursor, fonction_de_parsage = parse_propriété_cursor, drapeaux = DrapeauxPropriété.Héritée, genre_valeur_calculée = GenreValeurCalculée.Cursor),
        InfoTypePropriété(PROP_font_family, id = IDPropriété.FontFamily, fonction_de_parsage = parse_propriété_font_family, drapeaux = DrapeauxPropriété.Héritée | DrapeauxPropriété.AffecteDisposition, genre_valeur_calculée = GenreValeurCalculée.Spécifié),
        InfoTypePropriété(PROP_font_weight, id = IDPropriété.FontWeight, fonction_de_parsage = parse_propriété_font_weight, drapeaux = DrapeauxPropriété.Héritée | DrapeauxPropriété.AffecteDisposition, genre_valeur_calculée = GenreValeurCalculée.Nombre | GenreValeurCalculée.FontWeight),
        InfoTypePropriété(PROP_font_size, id = IDPropriété.FontSize, fonction_de_parsage = parse_propriété_font_size, drapeaux = DrapeauxPropriété.Héritée | DrapeauxPropriété.AffecteDisposition, genre_valeur_calculée = GenreValeurCalculée.LongueurAbsolue | GenreValeurCalculée.FontSize),
        InfoTypePropriété(PROP_font_style, id = IDPropriété.FontStyle, fonction_de_parsage = parse_propriété_font_style, drapeaux = DrapeauxPropriété.Héritée | DrapeauxPropriété.AffecteDisposition, genre_valeur_calculée = GenreValeurCalculée.Spécifié),
        InfoTypePropriété(PROP_border_top_color, id = IDPropriété.BorderColorTop, fonction_de_parsage = parse_propriété_color, genre_valeur_calculée = GenreValeurCalculée.Couleur),
        InfoTypePropriété(PROP_border_left_color, id = IDPropriété.BorderColorLeft, fonction_de_parsage = parse_propriété_color, genre_valeur_calculée = GenreValeurCalculée.Couleur),
        InfoTypePropriété(PROP_border_bottom_color, id = IDPropriété.BorderColorBottom, fonction_de_parsage = parse_propriété_color, genre_valeur_calculée = GenreValeurCalculée.Couleur),
        InfoTypePropriété(PROP_border_right_color, id = IDPropriété.BorderColorRight, fonction_de_parsage = parse_propriété_color, genre_valeur_calculée = GenreValeurCalculée.Couleur),
        InfoTypePropriété(PROP_border_block_end_color, fonction_de_parsage = parse_propriété_color, sur_calcul_style = prop_border_block_end_color_sur_calcul_style, genre_valeur_calculée = GenreValeurCalculée.Couleur),
        InfoTypePropriété(PROP_border_block_start_color, fonction_de_parsage = parse_propriété_color, sur_calcul_style = prop_border_block_start_color_sur_calcul_style, genre_valeur_calculée = GenreValeurCalculée.Couleur),
        InfoTypePropriété(PROP_border_inline_end_color, fonction_de_parsage = parse_propriété_color, sur_calcul_style = prop_border_inline_end_color_sur_calcul_style, genre_valeur_calculée = GenreValeurCalculée.Couleur),
        InfoTypePropriété(PROP_border_inline_start_color, fonction_de_parsage = parse_propriété_color, sur_calcul_style = prop_border_inline_start_color_sur_calcul_style, genre_valeur_calculée = GenreValeurCalculée.Couleur),
        InfoTypePropriété(PROP_border_top_style, id = IDPropriété.BorderStyleTop, fonction_de_parsage = parse_propriété_border_line_style, genre_valeur_calculée = GenreValeurCalculée.LineStyle),
        InfoTypePropriété(PROP_border_bottom_style, id = IDPropriété.BorderStyleBottom, fonction_de_parsage = parse_propriété_border_line_style, genre_valeur_calculée = GenreValeurCalculée.LineStyle),
        InfoTypePropriété(PROP_border_right_style, id = IDPropriété.BorderStyleRight, fonction_de_parsage = parse_propriété_border_line_style, genre_valeur_calculée = GenreValeurCalculée.LineStyle),
        InfoTypePropriété(PROP_border_left_style, id = IDPropriété.BorderStyleLeft, fonction_de_parsage = parse_propriété_border_line_style, genre_valeur_calculée = GenreValeurCalculée.LineStyle),
        InfoTypePropriété(PROP_border_block_end_style, fonction_de_parsage = parse_propriété_border_line_style, sur_calcul_style = prop_border_block_end_style_sur_calcul_style, genre_valeur_calculée = GenreValeurCalculée.LineStyle),
        InfoTypePropriété(PROP_border_block_start_style, fonction_de_parsage = parse_propriété_border_line_style, sur_calcul_style = prop_border_block_start_style_sur_calcul_style, genre_valeur_calculée = GenreValeurCalculée.LineStyle),
        InfoTypePropriété(PROP_border_inline_end_style, fonction_de_parsage = parse_propriété_border_line_style, sur_calcul_style = prop_border_inline_end_style_sur_calcul_style, genre_valeur_calculée = GenreValeurCalculée.LineStyle),
        InfoTypePropriété(PROP_border_inline_start_style, fonction_de_parsage = parse_propriété_border_line_style, sur_calcul_style = prop_border_inline_start_style_sur_calcul_style, genre_valeur_calculée = GenreValeurCalculée.LineStyle),
        InfoTypePropriété(PROP_border_top_width, id = IDPropriété.BorderWidthTop, fonction_de_parsage = parse_propriété_border_line_width, genre_valeur_calculée = GenreValeurCalculée.BorderWidth, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_border_bottom_width, id = IDPropriété.BorderWidthBottom, fonction_de_parsage = parse_propriété_border_line_width, genre_valeur_calculée = GenreValeurCalculée.BorderWidth, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_border_left_width, id = IDPropriété.BorderWidthLeft, fonction_de_parsage = parse_propriété_border_line_width, genre_valeur_calculée = GenreValeurCalculée.BorderWidth, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_border_right_width, id = IDPropriété.BorderWidthRight, fonction_de_parsage = parse_propriété_border_line_width, genre_valeur_calculée = GenreValeurCalculée.BorderWidth, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_border_block_end_width, fonction_de_parsage = parse_propriété_border_line_width, sur_calcul_style = prop_border_block_end_width_sur_calcul_style, genre_valeur_calculée = GenreValeurCalculée.BorderWidth, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_border_block_start_width, fonction_de_parsage = parse_propriété_border_line_width, sur_calcul_style = prop_border_block_start_width_sur_calcul_style, genre_valeur_calculée = GenreValeurCalculée.BorderWidth, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_border_inline_end_width, fonction_de_parsage = parse_propriété_border_line_width, sur_calcul_style = prop_border_inline_end_width_sur_calcul_style, genre_valeur_calculée = GenreValeurCalculée.BorderWidth, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_border_inline_start_width, fonction_de_parsage = parse_propriété_border_line_width, sur_calcul_style = prop_border_inline_start_width_sur_calcul_style, genre_valeur_calculée = GenreValeurCalculée.BorderWidth, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_margin_block_end, fonction_de_parsage = parse_propriété_margin_top, sur_calcul_style = prop_margin_block_end_sur_calcul_style, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage | GenreValeurCalculée.Auto, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_margin_block_start, fonction_de_parsage = parse_propriété_margin_top, sur_calcul_style = prop_margin_block_start_sur_calcul_style, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage | GenreValeurCalculée.Auto, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_margin_bottom, id = IDPropriété.MarginBottom, fonction_de_parsage = parse_propriété_margin_top, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage | GenreValeurCalculée.Auto, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_margin_inline_end, fonction_de_parsage = parse_propriété_margin_top, sur_calcul_style = prop_margin_inline_end_sur_calcul_style, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage | GenreValeurCalculée.Auto, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_margin_inline_start, fonction_de_parsage = parse_propriété_margin_top, sur_calcul_style = prop_margin_inline_start_sur_calcul_style, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage | GenreValeurCalculée.Auto, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_margin_left, id = IDPropriété.MarginLeft, fonction_de_parsage = parse_propriété_margin_top, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage | GenreValeurCalculée.Auto, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_margin_right, id = IDPropriété.MarginRight, fonction_de_parsage = parse_propriété_margin_top, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage | GenreValeurCalculée.Auto, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_margin_top, id = IDPropriété.MarginTop, fonction_de_parsage = parse_propriété_margin_top, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage | GenreValeurCalculée.Auto, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_padding_block_end, fonction_de_parsage = parse_propriété_padding_top, sur_calcul_style = prop_padding_block_end_sur_calcul_style, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_padding_block_start, fonction_de_parsage = parse_propriété_padding_top, sur_calcul_style = prop_padding_block_start_sur_calcul_style, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_padding_bottom, id = IDPropriété.PaddingBottom, fonction_de_parsage = parse_propriété_padding_top, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_padding_inline_end, fonction_de_parsage = parse_propriété_padding_top, sur_calcul_style = prop_padding_inline_end_sur_calcul_style, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_padding_inline_start, fonction_de_parsage = parse_propriété_padding_top, sur_calcul_style = prop_padding_inline_start_sur_calcul_style, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_padding_left, id = IDPropriété.PaddingLeft, fonction_de_parsage = parse_propriété_padding_top, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_padding_right, id = IDPropriété.PaddingRight, fonction_de_parsage = parse_propriété_padding_top, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_padding_top, id = IDPropriété.PaddingTop, fonction_de_parsage = parse_propriété_padding_top, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_height, id = IDPropriété.Height, fonction_de_parsage = parse_propriété_height_width, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage | GenreValeurCalculée.Spécifié, drapeaux = DrapeauxPropriété.AffecteDisposition | DrapeauxPropriété.ValeurNégativeIllégale),
        InfoTypePropriété(PROP_min_height, id = IDPropriété.MinHeight, fonction_de_parsage = parse_propriété_min_height_width, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage | GenreValeurCalculée.Spécifié, drapeaux = DrapeauxPropriété.AffecteDisposition | DrapeauxPropriété.ValeurNégativeIllégale),
        InfoTypePropriété(PROP_max_height, id = IDPropriété.MaxHeight, fonction_de_parsage = parse_propriété_max_height_width, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage | GenreValeurCalculée.Spécifié, drapeaux = DrapeauxPropriété.AffecteDisposition | DrapeauxPropriété.ValeurNégativeIllégale),
        InfoTypePropriété(PROP_width, id = IDPropriété.Width, fonction_de_parsage = parse_propriété_height_width, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage | GenreValeurCalculée.Spécifié, drapeaux = DrapeauxPropriété.AffecteDisposition | DrapeauxPropriété.ValeurNégativeIllégale),
        InfoTypePropriété(PROP_min_width, id = IDPropriété.MinWidth, fonction_de_parsage = parse_propriété_min_height_width, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage | GenreValeurCalculée.Spécifié, drapeaux = DrapeauxPropriété.AffecteDisposition | DrapeauxPropriété.ValeurNégativeIllégale),
        InfoTypePropriété(PROP_max_width, id = IDPropriété.MaxWidth, fonction_de_parsage = parse_propriété_max_height_width, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage | GenreValeurCalculée.Spécifié, drapeaux = DrapeauxPropriété.AffecteDisposition | DrapeauxPropriété.ValeurNégativeIllégale),
        InfoTypePropriété(PROP_inline_size, fonction_de_parsage = parse_propriété_height_width, sur_calcul_style = prop_inline_size_sur_calcul_style, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage | GenreValeurCalculée.Spécifié, drapeaux = DrapeauxPropriété.AffecteDisposition | DrapeauxPropriété.ValeurNégativeIllégale),
        InfoTypePropriété(PROP_block_size, fonction_de_parsage = parse_propriété_height_width, sur_calcul_style = prop_block_size_sur_calcul_style, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage | GenreValeurCalculée.Spécifié, drapeaux = DrapeauxPropriété.AffecteDisposition | DrapeauxPropriété.ValeurNégativeIllégale),
        InfoTypePropriété(PROP_max_inline_size, fonction_de_parsage = parse_propriété_min_height_width, sur_calcul_style = prop_max_inline_size_sur_calcul_style, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage | GenreValeurCalculée.Spécifié, drapeaux = DrapeauxPropriété.AffecteDisposition | DrapeauxPropriété.ValeurNégativeIllégale),
        InfoTypePropriété(PROP_max_block_size, fonction_de_parsage = parse_propriété_max_height_width, sur_calcul_style = prop_max_block_size_sur_calcul_style, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage | GenreValeurCalculée.Spécifié, drapeaux = DrapeauxPropriété.AffecteDisposition | DrapeauxPropriété.ValeurNégativeIllégale),
        InfoTypePropriété(PROP_min_inline_size, fonction_de_parsage = parse_propriété_min_height_width, sur_calcul_style = prop_min_inline_size_sur_calcul_style, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage | GenreValeurCalculée.Spécifié, drapeaux = DrapeauxPropriété.AffecteDisposition | DrapeauxPropriété.ValeurNégativeIllégale),
        InfoTypePropriété(PROP_min_block_size, fonction_de_parsage = parse_propriété_max_height_width, sur_calcul_style = prop_min_block_size_sur_calcul_style, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage | GenreValeurCalculée.Spécifié, drapeaux = DrapeauxPropriété.AffecteDisposition | DrapeauxPropriété.ValeurNégativeIllégale),
        InfoTypePropriété(PROP_line_height, id = IDPropriété.LineHeight, fonction_de_parsage = parse_propriété_line_height, drapeaux = DrapeauxPropriété.Héritée | DrapeauxPropriété.AffecteDisposition, genre_valeur_calculée = GenreValeurCalculée.Nombre | GenreValeurCalculée.Spécifié | GenreValeurCalculée.LineHeight),
        InfoTypePropriété(PROP_bottom, id = IDPropriété.Bottom, fonction_de_parsage = parse_propriété_inset, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage | GenreValeurCalculée.Auto, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_left, id = IDPropriété.Left, fonction_de_parsage = parse_propriété_inset, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage | GenreValeurCalculée.Auto, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_right, id = IDPropriété.Right, fonction_de_parsage = parse_propriété_inset, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage | GenreValeurCalculée.Auto, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_top, id = IDPropriété.Top, fonction_de_parsage = parse_propriété_inset, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage | GenreValeurCalculée.Auto, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_inset_block_end, fonction_de_parsage = parse_propriété_inset, sur_calcul_style = prop_inset_block_end_sur_calcul_style, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage | GenreValeurCalculée.Auto, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_inset_block_start, fonction_de_parsage = parse_propriété_inset, sur_calcul_style = prop_inset_block_start_sur_calcul_style, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage | GenreValeurCalculée.Auto, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_inset_inline_end, fonction_de_parsage = parse_propriété_inset, sur_calcul_style = prop_inset_inline_end_sur_calcul_style, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage | GenreValeurCalculée.Auto, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_inset_inline_start, fonction_de_parsage = parse_propriété_inset, sur_calcul_style = prop_inset_inline_start_sur_calcul_style, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage | GenreValeurCalculée.Auto, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_position, id = IDPropriété.Position, fonction_de_parsage = parse_propriété_position, genre_valeur_calculée = GenreValeurCalculée.Spécifié, drapeaux = DrapeauxPropriété.AffecteConstructionArbre),
        InfoTypePropriété(PROP_float, id = IDPropriété.Float, fonction_de_parsage = parse_propriété_float, genre_valeur_calculée = GenreValeurCalculée.Spécifié, drapeaux = DrapeauxPropriété.AffecteConstructionArbre),
        InfoTypePropriété(PROP_vertical_align, id = IDPropriété.VerticalAlign, fonction_de_parsage = parse_propriété_vertical_align, genre_valeur_calculée = GenreValeurCalculée.Spécifié, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_border_bottom_left_radius, id = IDPropriété.BorderBottomLeftRadius, fonction_de_parsage = parse_propriété_border_radius, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage),
        InfoTypePropriété(PROP_border_bottom_right_radius, id = IDPropriété.BorderBottomRightRadius, fonction_de_parsage = parse_propriété_border_radius, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage),
        InfoTypePropriété(PROP_border_top_left_radius, id = IDPropriété.BorderTopLeftRadius, fonction_de_parsage = parse_propriété_border_radius, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage),
        InfoTypePropriété(PROP_border_top_right_radius, id = IDPropriété.BorderTopRightRadius, fonction_de_parsage = parse_propriété_border_radius, genre_valeur_calculée = GenreValeurCalculée.LongueurPourcentage),
        InfoTypePropriété(PROP_clear, id = IDPropriété.Clear, fonction_de_parsage = parse_propriété_clear, genre_valeur_calculée = GenreValeurCalculée.Spécifié),
        InfoTypePropriété(PROP_overflow_x, id = IDPropriété.OverflowX, fonction_de_parsage = parse_propriété_overflow, genre_valeur_calculée = GenreValeurCalculée.Spécifié),
        InfoTypePropriété(PROP_overflow_y, id = IDPropriété.OverflowY, fonction_de_parsage = parse_propriété_overflow, genre_valeur_calculée = GenreValeurCalculée.Spécifié),
        InfoTypePropriété(PROP_justify_content, id = IDPropriété.JustifyContent, fonction_de_parsage = parse_propriété_justify_content, genre_valeur_calculée = GenreValeurCalculée.Spécifié),
        InfoTypePropriété(PROP_flex_basis, id = IDPropriété.FlexBasis, fonction_de_parsage = parse_propriété_flex_basis, genre_valeur_calculée = GenreValeurCalculée.Spécifié | GenreValeurCalculée.LongueurPourcentage),
        InfoTypePropriété(PROP_flex_direction, id = IDPropriété.FlexDirection, fonction_de_parsage = parse_propriété_flex_direction, genre_valeur_calculée = GenreValeurCalculée.Spécifié),
        InfoTypePropriété(PROP_flex_wrap, id = IDPropriété.FlexWrap, fonction_de_parsage = parse_propriété_flex_wrap, genre_valeur_calculée = GenreValeurCalculée.Spécifié),
        InfoTypePropriété(PROP_flex_grow, id = IDPropriété.FlexGrow, fonction_de_parsage = parse_propriété_number, genre_valeur_calculée = GenreValeurCalculée.Spécifié),
        InfoTypePropriété(PROP_flex_shrink, id = IDPropriété.FlexShrink, fonction_de_parsage = parse_propriété_number, genre_valeur_calculée = GenreValeurCalculée.Spécifié),
        InfoTypePropriété(PROP_box_sizing, id = IDPropriété.BoxSizing, fonction_de_parsage = parse_propriété_box_sizing, genre_valeur_calculée = GenreValeurCalculée.Spécifié),
        InfoTypePropriété(PROP_white_space, id = IDPropriété.WhiteSpace, fonction_de_parsage = parse_propriétés_white_space, genre_valeur_calculée = GenreValeurCalculée.Spécifié, drapeaux = DrapeauxPropriété.Héritée),
        InfoTypePropriété(PROP_opacity, id = IDPropriété.Opacity, fonction_de_parsage = parse_propriété_number_ou_pourcentage, genre_valeur_calculée = GenreValeurCalculée.Spécifié, drapeaux = DrapeauxPropriété.AffecteStackingContext),
        InfoTypePropriété(PROP_z_index, id = IDPropriété.ZIndex, fonction_de_parsage = parse_propriété_number_ou_auto, genre_valeur_calculée = GenreValeurCalculée.Spécifié, drapeaux = DrapeauxPropriété.AffecteStackingContext),
        InfoTypePropriété(PROP_border_spacing, id = IDPropriété.BorderSpacing, fonction_de_parsage = parse_propriété_border_spacing, genre_valeur_calculée = GenreValeurCalculée.LongueurAbsolue, drapeaux = DrapeauxPropriété.AffecteDisposition | DrapeauxPropriété.Héritée),
        InfoTypePropriété(PROP_border_collapse, id = IDPropriété.BorderCollapse, fonction_de_parsage = parse_propriété_border_collapse, genre_valeur_calculée = GenreValeurCalculée.Spécifié, drapeaux = DrapeauxPropriété.AffecteDisposition | DrapeauxPropriété.Héritée),
        InfoTypePropriété(PROP_align_content, id = IDPropriété.AlignContent, fonction_de_parsage = parse_propriété_align_content, genre_valeur_calculée = GenreValeurCalculée.Spécifié, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_align_items, id = IDPropriété.AlignItems, fonction_de_parsage = parse_propriété_align_items, genre_valeur_calculée = GenreValeurCalculée.Spécifié, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_align_self, id = IDPropriété.AlignSelf, fonction_de_parsage = parse_propriété_align_self, genre_valeur_calculée = GenreValeurCalculée.Spécifié, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_content, id = IDPropriété.Content, fonction_de_parsage = parse_propriété_content, genre_valeur_calculée = GenreValeurCalculée.Spécifié, drapeaux = DrapeauxPropriété.AffecteDisposition),
        InfoTypePropriété(PROP_text_align_all, id = IDPropriété.TextAlignAll, fonction_de_parsage = parse_propriété_text_align_all, drapeaux = DrapeauxPropriété.Héritée, genre_valeur_calculée = GenreValeurCalculée.Spécifié),
        InfoTypePropriété(PROP_text_align_last, id = IDPropriété.TextAlignLast, fonction_de_parsage = parse_propriété_text_align_last, drapeaux = DrapeauxPropriété.Héritée, genre_valeur_calculée = GenreValeurCalculée.Spécifié)
    ]

    /* NOTE : par défaut les infos n'ayant pas d'id prennent la valeur défaut de "Display".
     * nous devons donc vérfier si la valeur "Display" est pour la propriété "display". */
    assert(IDPropriété.Display comme n16 == 0)
    pour infos_types_propriétés {
        si it.id == IDPropriété.Display && it.nom != PROP_display {
            continue
        }

        infos_types_propriétés_pour_id[it.id] = *infos_types_propriétés[indice_it]
    }
}

/** } */

/* ------------------------------------------------------------------------- */
/** \nom Général
 * \{ */

#portée_module

/* https://www.w3.org/TR/css-cascade/#defaulting-keywords */
parse_css_wide_keyword :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    mots_clés := [PROP_initial, PROP_inherit, PROP_unset, PROP_revert]
    retourne parse_mot_clé(parseuse, mots_clés)
}

parse_mot_clé_global_ou_var :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    opt_valeur := parse_css_wide_keyword(parseuse)
    si opt_valeur.possède_valeur() {
        retourne opt_valeur
    }

    opt_variable := parse_variable(parseuse)
    si opt_variable.possède_valeur() {
        retourne opt_variable.Quelque
    }
}

parse_mot_clé :: fonc (parseuse: &Parseuse(ComponentValue), mots_clés: []CSSOMString) -> Optionnel(*ValeurDeStyle)
{
    lexème := parseuse.lexème_courant()

    pour mots_clés {
        si lexème.est_identifiant(it) {
            parseuse.avance()
            retourne crée_valeur_mot_clé(lexème.donne_texte())
        }
    }
}

/* https://drafts.csswg.org/css-values-4/#lengths */
parse_valeur_length :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    si parseuse.fini() {
        retourne
    }

    lexème := parseuse.lexème_courant()

    si lexème.est_lexème_de_genre(GenreLexème.Dimension) {
        données_lexème := lexème.lexème

        unité := donne_unité_pour_nom(données_lexème.unité)
        si unité.possède_valeur() {
            parseuse.avance()
            longueur := Longueur(données_lexème.numeric_value, unité.Quelque)
            retourne crée_valeur_longueur(longueur)
        }

        retourne
    }

    si lexème.est_lexème_de_genre(GenreLexème.Number) {
        /* Pour <length>, si l'unité est manquante, seul 0 est valide. */
        valeur := lexème.lexème.numeric_value
        si valeur != 0.0 {
            retourne
        }

        parseuse.avance()

        si lexème.lexème.drapeau_type_nombre == DrapeauxTypeNombre.Integer {
            retourne crée_valeur_integer(valeur)
        }

        retourne crée_valeur_number(valeur)
    }

    retourne parse_calc_function(parseuse)
}

parse_valeur_length_positive :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    valeur := parse_valeur_length(parseuse)
    si valeur.possède_valeur() {
        si valeur.Quelque.est_négative() {
            retourne
        }
        retourne valeur
    }
}

parse_valeur_percentage :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    si parseuse.fini() {
        retourne
    }

    lexème := parseuse.lexème_courant()

    si lexème.est_lexème_de_genre(GenreLexème.Percentage) {
        parseuse.avance()
        retourne crée_valeur_percentage(lexème.lexème.numeric_value)
    }
}

parse_valeur_number :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    si parseuse.fini() {
        retourne
    }

    lexème := parseuse.lexème_courant()

    si lexème.est_lexème_de_genre(GenreLexème.Number) {
        parseuse.avance()

        si lexème.lexème.drapeau_type_nombre == DrapeauxTypeNombre.Integer {
            retourne crée_valeur_integer(lexème.lexème.numeric_value)
        }

        retourne crée_valeur_number(lexème.lexème.numeric_value)
    }
}

parse_valeur_number_positive :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    valeur := parse_valeur_number(parseuse)
    si valeur.possède_valeur() {
        si valeur.Quelque.est_négative() {
            retourne
        }
        retourne valeur
    }
}

parse_valeur_length_percentage :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    length := parse_valeur_length(parseuse)
    si length.possède_valeur() {
        retourne length
    }
    retourne parse_valeur_percentage(parseuse)
}

parse_valeur_length_percentage_positive :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    valeur := parse_valeur_length_percentage(parseuse)
    si valeur.possède_valeur() {
        si valeur.Quelque.est_négative() {
            retourne
        }
        retourne valeur
    }
}

parse_valeur_length_percentage_ou_auto :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    lexème := parseuse.lexème_courant()
    si lexème.est_mot_clé(PROP_auto) {
        parseuse.avance()
        retourne donne_valeur_auto()
    }
    retourne parse_valeur_length_percentage(parseuse)
}

parse_valeur_length_percentage_positive_ou_auto :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    valeur := parse_valeur_length_percentage_ou_auto(parseuse)
    si valeur.possède_valeur() {
        si valeur.Quelque.est_négative() {
            retourne
        }
        retourne valeur
    }
}

/* https://drafts.csswg.org/css-values/#calc-syntax
 * <calc()>  = calc( <calc-sum> ) */
parse_calc_function :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    si parseuse.fini() {
        retourne
    }

    lexème := parseuse.lexème_courant()
    saufsi lexème.est_fonction(PROP_calc) {
        retourne
    }

    valeurs: [..]NoeudDeCalcul

    parseuse_arguments := initialise_une_parseuse(lexème.function.value)
    
    saufsi parseuse_arguments.parse_calc_sum(*valeurs) {
        déloge(valeurs)
        retourne
    }

    parseuse.avance()

    résultat := crée_valeur_calc(CalcFunction(valeurs))
    retourne résultat
}

/* <calc-sum> = <calc-product> [ [ '+' | '-' ] <calc-product> ]* */
parse_calc_sum :: fonc (parseuse: &Parseuse(ComponentValue), résultat: *[..]NoeudDeCalcul) -> bool
{
    saufsi parseuse.parse_calc_product(résultat) {
        retourne faux
    }

    tantque !parseuse.fini() {
        parseuse.consomme_espaces_blanches()
        lexème := parseuse.lexème_courant()
        opérateur_calc: OpérateurCalc
        si lexème.est_lexème_plus() {
            parseuse.avance()
            opérateur_calc = OpérateurCalc.Plus
        }
        sinon si lexème.est_lexème_moins() {
            parseuse.avance()
            opérateur_calc = OpérateurCalc.Moins
        }
        sinon {
            arrête
        }
        parseuse.consomme_espaces_blanches()

        saufsi parseuse.parse_calc_product(résultat) {
            retourne faux
        }

        tableau_ajoute(résultat, NoeudDeCalcul(est_opérateur = vrai, opérateur_calc = opérateur_calc))
    }

    retourne vrai
}

/* <calc-product> = <calc-value> [ [ '*' | '/' ] <calc-value> ]* */
parse_calc_product :: fonc (parseuse: &Parseuse(ComponentValue), résultat: *[..]NoeudDeCalcul) -> bool
{
    saufsi parseuse.parse_calc_value(résultat) {
        retourne faux
    }

    tantque !parseuse.fini() {
        parseuse.consomme_espaces_blanches()
        lexème := parseuse.lexème_courant()
        opérateur_calc: OpérateurCalc
        si lexème.est_lexème_fois() {
            parseuse.avance()
            opérateur_calc = OpérateurCalc.Fois
        }
        sinon si lexème.est_lexème_slash() {
            parseuse.avance()
            opérateur_calc = OpérateurCalc.Divise
        }
        sinon {
            arrête
        }

        parseuse.consomme_espaces_blanches()

        saufsi parseuse.parse_calc_value(résultat) {
            retourne faux
        }

        tableau_ajoute(résultat, NoeudDeCalcul(est_opérateur = vrai, opérateur_calc = opérateur_calc))
    }

    retourne vrai
}

/* <calc-value> = <number> | <dimension> | <percentage> | <calc-keyword> | ( <calc-sum> ) */
parse_calc_value :: fonc (parseuse: &Parseuse(ComponentValue), résultat: *[..]NoeudDeCalcul) -> bool
{
    parseuse.consomme_espaces_blanches()

    si parseuse.fini() {
        retourne faux
    }

    lexème := parseuse.lexème_courant()
    si lexème.est_lexème_de_genre(GenreLexème.Number) {
        parseuse.avance()

        si lexème.lexème.drapeau_type_nombre == DrapeauxTypeNombre.Integer {
            tableau_ajoute(résultat, NoeudDeCalcul(valeur = crée_valeur_integer(lexème.lexème.numeric_value)))
        }
        sinon {
            tableau_ajoute(résultat, NoeudDeCalcul(valeur = crée_valeur_number(lexème.lexème.numeric_value)))
        }

        retourne vrai
    }

    si lexème.est_lexème_de_genre(GenreLexème.Dimension) {
        données_lexème := lexème.lexème

        unité := donne_unité_pour_nom(données_lexème.unité)
        si unité.possède_valeur() {
            parseuse.avance()
            longueur := Longueur(données_lexème.numeric_value, unité.Quelque)
            tableau_ajoute(résultat, NoeudDeCalcul(valeur = crée_valeur_longueur(longueur)))
            retourne vrai
        }

        retourne faux
    }

    si lexème.est_lexème_de_genre(GenreLexème.Percentage) {
        parseuse.avance()
        tableau_ajoute(résultat, NoeudDeCalcul(valeur = crée_valeur_percentage(lexème.lexème.numeric_value)))
        retourne vrai
    }

    // À FAIRE : <calc-keyword>, var()

    si lexème.est_lexème_de_genre(GenreLexème.Open_Parenthesis) {
        parseuse.avance()
        saufsi parseuse.parse_calc_sum(résultat) {
            retourne faux
        }

        si parseuse.fini() {
            retourne faux
        }

        lexème = parseuse.lexème_courant()
        saufsi lexème.est_lexème_de_genre(GenreLexème.Close_Parenthesis) {
            retourne faux
        }

        parseuse.avance()
        retourne vrai
    }

    si lexème.est_simple_bloc_de_genre(GenreLexème.Open_Parenthesis) {
        bloc := lexème.bloc
        parseuse_bloc := initialise_une_parseuse(bloc.value)

        saufsi parseuse_bloc.parse_calc_sum(résultat) {
            retourne faux
        }

        parseuse.avance()
        retourne vrai
    }

    retourne faux
}

parse_variable :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    parseuse.consomme_espaces_blanches()
    si parseuse.fini() {
        retourne
    }

    lexème := parseuse.lexème_courant()
    saufsi lexème.est_fonction(PROP_var) {
        retourne
    }

    parseuse_arguments := initialise_une_parseuse(lexème.function.value)
    retourne parseuse_arguments.parse_variables_depuis_arguments()
}

parse_variables_depuis_arguments :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    parseuse.consomme_espaces_blanches()

    lexème := parseuse.lexème_courant()
    saufsi lexème.est_lexème_de_genre(GenreLexème.Ident) {
        retourne
    }

    nom := lexème.donne_texte()
    saufsi nom.est_propriété_personnalisée() {
        retourne
    }

    parseuse.avance()
    parseuse.consomme_espaces_blanches()

    // À FAIRE : fallback

    résultat: Variable
    résultat.nom = nom

    retourne crée_valeur_variable(résultat)
}

parse_propriété_number :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)
    lexème := parseuse.lexème_courant()
    si lexème.est_lexème_de_genre(GenreLexème.Number) {
        retourne crée_valeur_number(lexème.lexème.numeric_value)
    }
}

parse_propriété_number_ou_pourcentage :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)
    lexème := parseuse.lexème_courant()
    si lexème.est_lexème_de_genre(GenreLexème.Number) {
        retourne crée_valeur_number(lexème.lexème.numeric_value)
    }
    si lexème.est_lexème_de_genre(GenreLexème.Percentage) {
        retourne crée_valeur_percentage(lexème.lexème.numeric_value / 100.0)
    }
}

parse_propriété_number_ou_auto :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)
    lexème := parseuse.lexème_courant()
    si lexème.est_lexème_de_genre(GenreLexème.Number) {
        retourne crée_valeur_number(lexème.lexème.numeric_value)
    }
    si lexème.est_mot_clé(PROP_auto) {
        retourne donne_valeur_auto()
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom All
 * https://drafts.csswg.org/css-cascade/#all-shorthand
 * \{ */

parse_propriété_all :: fonc (ctx: *ContexteParsageShorthand, value: []ComponentValue) -> bool
{
    parseuse := initialise_une_parseuse(value)
    opt_valeur := parse_css_wide_keyword(parseuse)
    si opt_valeur.possède_valeur() {
        valeur := opt_valeur.Quelque
        pour * infos_types_propriétés {
            ctx.ajoute_propriété(it.nom, valeur)
        }
        retourne vrai
    }
    retourne faux
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Display
 * \{ */

/* https://drafts.csswg.org/css-display/#the-display-properties */
parse_propriété_display :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)

    mot_clé := parseuse.parse_display_legacy()
    si mot_clé.possède_valeur() {
        retourne mot_clé
    }

    mot_clé = parseuse.parse_display_outside()
    si mot_clé.possède_valeur() {
        retourne mot_clé
    }

    mot_clé = parseuse.parse_display_inside()
    si mot_clé.possède_valeur() {
        retourne mot_clé
    }

    mot_clé = parseuse.parse_display_box()
    si mot_clé.possède_valeur() {
        retourne mot_clé
    }

    mot_clé = parseuse.parse_display_internal()
    si mot_clé.possède_valeur() {
        retourne mot_clé
    }

    lexème := parseuse.lexème_courant()
    si lexème.est_lexème_de_genre(GenreLexème.Ident) {
        si lexème.donne_texte() == PROP_list_item {
            retourne crée_valeur_mot_clé(PROP_list_item)
        }
    }
}

parse_display_inside :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    /* <display-inside>   = flow | flow-root | table | flex | grid | ruby */
    mots_clés := [PROP_flow, PROP_flow_root, PROP_flex, PROP_table]
    retourne parse_mot_clé(parseuse, mots_clés)
}

parse_display_outside :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    opt_mot_clé := parse_css_wide_keyword(parseuse)
    si opt_mot_clé.possède_valeur() {
        retourne opt_mot_clé
    }

    /* block | inline | run-in */
    mots_clés := [PROP_block, PROP_inline, PROP_run_in]
    retourne parse_mot_clé(parseuse, mots_clés)
}

parse_display_box :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    opt_mot_clé := parse_css_wide_keyword(parseuse)
    si opt_mot_clé.possède_valeur() {
        retourne opt_mot_clé
    }

    /* contents | none */
    mots_clés := [PROP_contents, PROP_none]
    retourne parse_mot_clé(parseuse, mots_clés)
}

parse_display_legacy :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    /* <display-legacy>   = inline-block | inline-table | inline-flex | inline-grid */
    mots_clés := [PROP_inline_block, PROP_inline_flex, PROP_inline_table]
    retourne parse_mot_clé(parseuse, mots_clés)
}

parse_display_internal :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    /* <display-internal> = table-row-group | table-header-group |
                     table-footer-group | table-row | table-cell |
                     table-column-group | table-column | table-caption |
                     ruby-base | ruby-text | ruby-base-container |
                     ruby-text-container */
    mots_clés := [PROP_table_row_group, PROP_table_header_group, PROP_table_footer_group, PROP_table_row, PROP_table_cell, PROP_table_column_group, PROP_table_column, PROP_table_caption]
    retourne parse_mot_clé(parseuse, mots_clés)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Color
 * https://drafts.csswg.org/css-color/#the-color-property
 * \{ */

#portée_export

valeur_hex_depuis_unité :: fonc (unité: n16) -> n8
{
    si 'A' <= unité <= 'F' {
        retourne unité comme n8 - ('A' comme n8) + 10
    }

    si 'a' <= unité <= 'f' {
        retourne unité comme n8 - ('a' comme n8) + 10
    }

    retourne unité comme n8 - ('0' comme n8)
}

#portée_module

parse_propriété_color :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)

    tantque !fini(parseuse) {
        parseuse.consomme_espaces_blanches()

        valeur := parse_valeur_couleur(parseuse)
        si valeur.possède_valeur() {
            retourne valeur
        }

        retourne
    }
}

parse_valeur_couleur :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    si parseuse.fini() {
        retourne
    }

    lexème := parseuse.lexème_courant()

    si lexème.est_lexème_de_genre(GenreLexème.Ident) {
        opt_couleur := trouve_couleur_pour_mot_clé(lexème.donne_texte())
        si opt_couleur.possède_valeur() {
            parseuse.avance()
            retourne crée_valeur_couleur(opt_couleur.Quelque)
        }

        si compare_ascii_insensible_à_la_casse(lexème.donne_texte(), PROP_currentColor) {
            parseuse.avance()
            retourne donne_valeur_currentColor()
        }

        retourne
    }

    /* https://www.w3.org/TR/css-color-4/#typedef-hex-color */
    si lexème.est_lexème_de_genre(GenreLexème.Hash) {
        valeur := lexème.donne_texte().donne_chaine_utf16()

        pour valeur.unités {
            saufsi est_chiffre_hexadecimal_ascii(it) {
                retourne
            }
        }

        couleur: CouleurRVBAN8
        si valeur.taille() == 3 {
            couleur.r = (valeur_hex_depuis_unité(valeur.unités[0]) comme r32 / 15.0 * 255.0) comme n8
            couleur.v = (valeur_hex_depuis_unité(valeur.unités[1]) comme r32 / 15.0 * 255.0) comme n8
            couleur.b = (valeur_hex_depuis_unité(valeur.unités[2]) comme r32 / 15.0 * 255.0) comme n8
            couleur.a = 255
        }
        sinon si valeur.taille() == 4 {
            couleur.r = (valeur_hex_depuis_unité(valeur.unités[0]) comme r32 / 15.0 * 255.0) comme n8
            couleur.v = (valeur_hex_depuis_unité(valeur.unités[1]) comme r32 / 15.0 * 255.0) comme n8
            couleur.b = (valeur_hex_depuis_unité(valeur.unités[2]) comme r32 / 15.0 * 255.0) comme n8
            couleur.a = (valeur_hex_depuis_unité(valeur.unités[3]) comme r32 / 15.0 * 255.0) comme n8
        }
        sinon si valeur.taille() == 6 {
            couleur.r = valeur_hex_depuis_unité(valeur.unités[0]) * 16 + valeur_hex_depuis_unité(valeur.unités[1])
            couleur.v = valeur_hex_depuis_unité(valeur.unités[2]) * 16 + valeur_hex_depuis_unité(valeur.unités[3])
            couleur.b = valeur_hex_depuis_unité(valeur.unités[4]) * 16 + valeur_hex_depuis_unité(valeur.unités[5])
            couleur.a = 255
        }
        sinon si valeur.taille() == 8 {
            couleur.r = valeur_hex_depuis_unité(valeur.unités[0]) * 16 + valeur_hex_depuis_unité(valeur.unités[1])
            couleur.v = valeur_hex_depuis_unité(valeur.unités[2]) * 16 + valeur_hex_depuis_unité(valeur.unités[3])
            couleur.b = valeur_hex_depuis_unité(valeur.unités[4]) * 16 + valeur_hex_depuis_unité(valeur.unités[5])
            couleur.a = valeur_hex_depuis_unité(valeur.unités[6]) * 16 + valeur_hex_depuis_unité(valeur.unités[7])
        }
        sinon {
            retourne
        }

        parseuse.avance()
        retourne crée_valeur_couleur(couleur)
    }

    si lexème.est_fonction() {
        fonction := lexème.function

        si compare_ascii_insensible_à_la_casse(fonction.name, PROP_rgb, PROP_rgba) {
            résultat := parse_couleur_rgb(fonction)
            si résultat.possède_valeur() {
                parseuse.avance()
            }
            retourne résultat
        }

        si compare_ascii_insensible_à_la_casse(fonction.name, PROP_hsl, PROP_hsla) {
            résultat := parse_couleur_hsl(fonction)
            si résultat.possède_valeur() {
                parseuse.avance()
            }
            retourne résultat
        }

        retourne
    }
}

/* https://www.w3.org/TR/css-color-4/#rgb-functions */
parse_couleur_rgb :: fonc (function: &ParsedFunction) -> Optionnel(*ValeurDeStyle)
{
    résultat := parse_couleur_syntaxe_legacy(function.value)
    si résultat.possède_valeur() {
        retourne résultat
    }

    résultat = parse_couleur_rgb_legacy(function.value)
    si résultat.possède_valeur() {
        retourne résultat
    }

    résultat = parse_couleur_rgb_modern(function.value)
    si résultat.possède_valeur() {
        retourne résultat
    }
}

parse_couleur_rgb_modern :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)

    valeurs := r64.[0.0, 0.0, 0.0, 255.0]
    nombre_de_valeurs := 0

    eu_nombre := faux
    eu_pourcentage := faux

    tantque !parseuse.fini() && nombre_de_valeurs < 3 {
        lexème := parseuse.lexème_courant()
        si lexème.est_lexème_de_genre(GenreLexème.Number) {
            si eu_pourcentage {
                /* pas de mélange entre nombre et pourcentage pour les couleurs hors alpha */
                retourne
            }

            eu_nombre = vrai

            valeurs[nombre_de_valeurs] = lexème.lexème.numeric_value
            nombre_de_valeurs += 1
        }
        sinon si lexème.est_lexème_de_genre(GenreLexème.Percentage) {
            si eu_nombre {
                /* pas de mélange entre nombre et pourcentage pour les couleurs hors alpha */
                retourne
            }

            eu_pourcentage = vrai
            valeur := lexème.lexème.numeric_value * 255.0 / 100.0
            valeurs[nombre_de_valeurs] = valeur
            nombre_de_valeurs += 1
        }
        sinon si lexème.est_mot_clé(PROP_none) {
            valeurs[nombre_de_valeurs] = 0.0
            nombre_de_valeurs += 1
        }
        sinon {
            retourne
        }

        parseuse.avance()

        si consomme_slash_et_espaces_blanches(parseuse) {
            arrête
        }
    }

    parseuse.consomme_espaces_blanches()
    saufsi parseuse.fini() {
        lexème := parseuse.lexème_courant()
        si lexème.est_lexème_de_genre(GenreLexème.Number) {
            valeurs[3] = lexème.lexème.numeric_value * 255.0
        }
        sinon si lexème.est_lexème_de_genre(GenreLexème.Percentage) {
            eu_pourcentage = vrai
            valeur := lexème.lexème.numeric_value * 255.0 / 100.0
            valeurs[3] = valeur
        }
        sinon si lexème.est_mot_clé(PROP_none) {
            valeurs[3] = 0.0
        }
    }

    couleur := CouleurRVBAN8(valeurs[0] comme n8, valeurs[1] comme n8, valeurs[2] comme n8, valeurs[3] comme n8)
    retourne crée_valeur_couleur(couleur)
}

parse_couleur_rgb_legacy :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)

    valeurs := r64.[0.0, 0.0, 0.0, 255.0]
    nombre_de_valeurs := 0

    eu_nombre := faux
    eu_pourcentage := faux

    tantque !parseuse.fini() && nombre_de_valeurs < 3 {
        lexème := parseuse.lexème_courant()
        si lexème.est_lexème_de_genre(GenreLexème.Number) {
            si eu_pourcentage {
                /* pas de mélange entre nombre et pourcentage pour les couleurs hors alpha */
                retourne
            }

            eu_nombre = vrai

            valeurs[nombre_de_valeurs] = lexème.lexème.numeric_value
            nombre_de_valeurs += 1
        }
        sinon si lexème.est_lexème_de_genre(GenreLexème.Percentage) {
            si eu_nombre {
                /* pas de mélange entre nombre et pourcentage pour les couleurs hors alpha */
                retourne
            }

            eu_pourcentage = vrai
            valeur := lexème.lexème.numeric_value * 255.0 / 100.0
            valeurs[nombre_de_valeurs] = valeur
            nombre_de_valeurs += 1
        }
        sinon {
            retourne
        }

        parseuse.avance()

        si consomme_virgule_et_espaces_blanches(parseuse) {
            arrête
        }
    }

    parseuse.consomme_espaces_blanches()
    saufsi parseuse.fini() {
        lexème := parseuse.lexème_courant()
        si lexème.est_lexème_de_genre(GenreLexème.Number) {
            valeurs[3] = lexème.lexème.numeric_value * 255.0
        }
        sinon si lexème.est_lexème_de_genre(GenreLexème.Percentage) {
            eu_pourcentage = vrai
            valeur := lexème.lexème.numeric_value * 255.0 / 100.0
            valeurs[3] = valeur
        }
    }

    couleur := CouleurRVBAN8(valeurs[0] comme n8, valeurs[1] comme n8, valeurs[2] comme n8, valeurs[3] comme n8)
    retourne crée_valeur_couleur(couleur)
}

/* https://www.w3.org/TR/css-color-4/#legacy-color-syntax */
parse_couleur_syntaxe_legacy :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)

    valeurs := r64.[0.0, 0.0, 0.0, 255.0]
    nombre_de_valeurs := 0

    eu_nombre := faux
    eu_pourcentage := faux

    tantque !parseuse.fini() && nombre_de_valeurs < 4 {
        lexème := parseuse.lexème_courant()
        si lexème.est_lexème_de_genre(GenreLexème.Number) {
            si eu_pourcentage && nombre_de_valeurs < 4 {
                /* pas de mélange entre nombre et pourcentage pour les couleurs hors alpha */
                retourne
            }

            eu_nombre = vrai

            valeur := lexème.lexème.numeric_value
            si nombre_de_valeurs == 3 {
                valeur *= 255.0
            }

            valeurs[nombre_de_valeurs] = valeur
            nombre_de_valeurs += 1
        }
        sinon si lexème.est_lexème_de_genre(GenreLexème.Percentage) {
            si eu_nombre && nombre_de_valeurs < 4 {
                /* pas de mélange entre nombre et pourcentage pour les couleurs hors alpha */
                retourne
            }

            eu_pourcentage = vrai
            valeurs[nombre_de_valeurs] = lexème.lexème.numeric_value * 255.0 / 100.0
            nombre_de_valeurs += 1
        }
        sinon {
            retourne
        }

        parseuse.avance()

        saufsi consomme_virgule_et_espaces_blanches(parseuse) {
            arrête
        }
    }

    parseuse.consomme_espaces_blanches()
    saufsi parseuse.fini() {
        /* Erreur de parsage ou de syntaxe. */
        retourne
    }

    /* L'alpha est implicite. */
    si nombre_de_valeurs < 3 {
        retourne
    }

    couleur := CouleurRVBAN8(valeurs[0] comme n8, valeurs[1] comme n8, valeurs[2] comme n8, valeurs[3] comme n8)
    retourne crée_valeur_couleur(couleur)
}

/* https://drafts.csswg.org/css-color-4/#funcdef-hsl */
parse_couleur_hsl :: fonc (function: &ParsedFunction) -> Optionnel(*ValeurDeStyle)
{
    résultat := parse_couleur_hsl_legacy(function.value)
    si résultat.possède_valeur() {
        retourne résultat
    }

    résultat = parse_couleur_hsl_modern(function.value)
    si résultat.possède_valeur() {
        retourne résultat
    }
}

parse_couleur_hsl_modern :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)

    /* Teinte */
    hue : r64 = 0
    opt_hue := parseuse.parse_hue()
    si opt_hue.possède_valeur() {
        hue = opt_hue.Quelque
    }
    sinon {
        lexème := parseuse.lexème_courant()
        saufsi lexème.est_mot_clé(PROP_none) {
            retourne
        }
        parseuse.avance()
    }

    parseuse.consomme_espaces_blanches()

    /* Saturation. */
    lexème := parseuse.lexème_courant()
    sat : r64 = 0
    si lexème.est_lexème_de_genre(GenreLexème.Percentage) {
        sat = lexème.lexème.numeric_value
    }
    sinon saufsi lexème.est_mot_clé(PROP_none) {
        retourne
    }
    parseuse.avance()

    parseuse.consomme_espaces_blanches()

    /* Luminance */
    lexème = parseuse.lexème_courant()
    lum : r64 = 0
    si lexème.est_lexème_de_genre(GenreLexème.Percentage) {
        lum = lexème.lexème.numeric_value
    }
    sinon saufsi lexème.est_mot_clé(PROP_none) {
        retourne
    }
    parseuse.avance()

    parseuse.consomme_espaces_blanches()

    /* Alpha */
    alpha : r64 = 0.0
    saufsi parseuse.fini() {
        lexème = parseuse.lexème_courant()
        si lexème.est_lexème_de_genre(GenreLexème.Percentage) {
            alpha = lexème.lexème.numeric_value / 100.0
        }
        sinon si lexème.est_lexème_de_genre(GenreLexème.Number) {
            alpha = lexème.lexème.numeric_value
        }
        sinon {
            retourne
        }

        parseuse.avance()
        parseuse.consomme_espaces_blanches()
    }

    saufsi parseuse.fini() {
        retourne
    }

    tsl: CouleurTSL
    tsl.t = (hue / 360.0) comme r32
    tsl.s = (sat / 100.0) comme r32
    tsl.l = (lum / 100.0) comme r32

    rvb := tsl_vers_rvb(tsl)

    couleur := CouleurRVBAN8((rvb.r * 255.0) comme n8, (rvb.v * 255.0)  comme n8, (rvb.b * 255.0)  comme n8, (alpha * 255.0)  comme n8)
    retourne crée_valeur_couleur(couleur)
}

parse_couleur_hsl_legacy :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)

    /* Teinte */
    opt_hue := parseuse.parse_hue()
    saufsi opt_hue.possède_valeur() {
        retourne
    }
    hue := opt_hue.Quelque

    saufsi parseuse.consomme_virgule_et_espaces_blanches() {
        retourne
    }

    /* Saturation. */
    lexème := parseuse.lexème_courant()
    saufsi lexème.est_lexème_de_genre(GenreLexème.Percentage) {
        retourne
    }
    sat := lexème.lexème.numeric_value
    parseuse.avance()

    saufsi parseuse.consomme_virgule_et_espaces_blanches() {
        retourne
    }

    /* Luminance */
    lexème = parseuse.lexème_courant()
    saufsi lexème.est_lexème_de_genre(GenreLexème.Percentage) {
        retourne
    }
    lum := lexème.lexème.numeric_value
    parseuse.avance()

    /* Alpha */
    alpha : r64 = 0.0
    si parseuse.consomme_virgule_et_espaces_blanches() {
        lexème = parseuse.lexème_courant()
        si lexème.est_lexème_de_genre(GenreLexème.Percentage) {
            alpha = lexème.lexème.numeric_value / 100.0
        }
        sinon si lexème.est_lexème_de_genre(GenreLexème.Number) {
            alpha = lexème.lexème.numeric_value
        }
        sinon {
            retourne
        }

        parseuse.avance()
        parseuse.consomme_espaces_blanches()
    }

    saufsi parseuse.fini() {
        retourne
    }

    tsl: CouleurTSL
    tsl.t = (hue / 360.0) comme r32
    tsl.s = (sat / 100.0) comme r32
    tsl.l = (lum / 100.0) comme r32

    rvb := tsl_vers_rvb(tsl)

    couleur := CouleurRVBAN8((rvb.r * 255.0) comme n8, (rvb.v * 255.0)  comme n8, (rvb.b * 255.0)  comme n8, (alpha * 255.0)  comme n8)
    retourne crée_valeur_couleur(couleur)
}

parse_hue :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(r64)
{
    lexème := parseuse.lexème_courant()

    si lexème.est_lexème_de_genre(GenreLexème.Number) {
        parseuse.avance()
        retourne lexème.lexème.numeric_value
    }

    si lexème.est_lexème_de_genre(GenreLexème.Dimension) {
        données_lexème := lexème.lexème
        
        si données_lexème.unité == PROP_deg {
            parseuse.avance()
            retourne lexème.lexème.numeric_value
        }

        si données_lexème.unité == PROP_grad {
            parseuse.avance()
            retourne lexème.lexème.numeric_value / 400.0 * 360.0
        }

        si données_lexème.unité == PROP_rad {
            parseuse.avance()
            retourne lexème.lexème.numeric_value / Constantes(r64).PI * 180.0
        }

        si données_lexème.unité == PROP_turn {
            parseuse.avance()
            retourne lexème.lexème.numeric_value * 360.0
        }

        retourne
    }
}

consomme_virgule_et_espaces_blanches :: fonc (parseuse: &Parseuse(ComponentValue)) -> bool
{
    parseuse.consomme_espaces_blanches()
    lexème := parseuse.lexème_courant()
    saufsi lexème.est_lexème_de_genre(GenreLexème.Comma) {
        retourne faux
    }
    parseuse.avance()
    parseuse.consomme_espaces_blanches()
    retourne vrai
}

consomme_slash_et_espaces_blanches :: fonc (parseuse: &Parseuse(ComponentValue)) -> bool
{
    parseuse.consomme_espaces_blanches()
    lexème := parseuse.lexème_courant()
    saufsi lexème.est_lexème_slash() {
        retourne faux
    }
    parseuse.avance()
    parseuse.consomme_espaces_blanches()
    retourne vrai
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Text decoration
 * https://drafts.csswg.org/css-text-decor/#text-decoration-property
 * \{ */

parse_propriété_text_decoration :: fonc (ctx: *ContexteParsageShorthand, value: []ComponentValue) -> bool
{
    noms_propriétés := [PROP_text_decoration_line, PROP_text_decoration_style, PROP_text_decoration_color]
    si parse_mot_clé_global(ctx, noms_propriétés, value) {
        retourne vrai
    }

    parseuse := initialise_une_parseuse(value)

    // text-decoration-line
    // 	   none | [ underline || overline || line-through || blink ]
    // text-decoration-style
    // 	   solid | double | dotted | dashed | wavy
    // text-decoration-color
    //     <color>
    // text-decoration
    //     <'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'>

    line := donne_valeur_none()
    style := donne_valeur_solid()
    color := donne_valeur_currentColor()

    tantque !fini(parseuse) {
        parseuse.consomme_espaces_blanches()

        valeur_line := parse_valeur_text_decoration_line(parseuse)
        si valeur_line.possède_valeur() {
            line = valeur_line.Quelque
            continue
        }

        valeur_style := parse_valeur_text_decoration_style(parseuse)
        si valeur_style.possède_valeur() {
            style = valeur_style.Quelque
            continue
        }

        valeur_color := parse_valeur_couleur(parseuse)
        si valeur_color.possède_valeur() {
            color = valeur_color.Quelque
            continue
        }

        retourne faux
    }

    ajoute_propriété(ctx, PROP_text_decoration_line, line)
    ajoute_propriété(ctx, PROP_text_decoration_style, style)
    ajoute_propriété(ctx, PROP_text_decoration_color, color)
    retourne vrai
}

parse_propriété_text_decoration_line :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)
    retourne parse_valeur_text_decoration_line(parseuse)
}

parse_propriété_text_decoration_style :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)
    retourne parse_valeur_text_decoration_style(parseuse)
}

parse_valeur_text_decoration_line :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    si parseuse.fini() {
        retourne
    }

    mots_clés: [..]CSSOMString
    diffère déloge(mots_clés)

    tantque !fini(parseuse) {
        lexème := parseuse.lexème_courant()

        saufsi lexème.est_lexème_de_genre(GenreLexème.Ident) {
            retourne
        }

        mot_clé := lexème.donne_texte()

        si mot_clé == PROP_none {
            parseuse.avance()
            retourne donne_valeur_none()
        }

        si mot_clé == PROP_underline {
            tableau_ajoute(*mots_clés, mot_clé)
        }
        sinon si mot_clé == PROP_overline {
            tableau_ajoute(*mots_clés, mot_clé)
        }
        sinon si mot_clé == PROP_line_through {
            tableau_ajoute(*mots_clés, mot_clé)
        }
        sinon {
            retourne
        }

        parseuse.avance()
        parseuse.consomme_espaces_blanches()
    }

    si mots_clés.taille == 1 {
        retourne crée_valeur_mot_clé(mots_clés[0])
    }

    résultat := crée_valeur_liste()
    pour mots_clés {
        tableau_ajoute(*résultat.valeur, crée_valeur_mot_clé(it))
    }
    retourne résultat
}

parse_valeur_text_decoration_style :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    si parseuse.fini() {
        retourne
    }

    lexème := parseuse.lexème_courant()

    saufsi lexème.est_lexème_de_genre(GenreLexème.Ident) {
        retourne
    }

    mot_clé := lexème.donne_texte()

    si mot_clé == PROP_solid {
        parseuse.avance()
        retourne donne_valeur_solid()
    }

    si mot_clé == PROP_double || mot_clé == PROP_dotted || mot_clé == PROP_dashed || mot_clé == PROP_wavy {
        retourne
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Text Transform
 * https://drafts.csswg.org/css-text-4/#text-transform
 * \{ */

/* none | [capitalize | uppercase | lowercase ] || full-width || full-size-kana | math-auto  */
parse_propriété_text_transform :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    mots_clés := [ PROP_none, PROP_capitalize, PROP_uppercase, PROP_lowercase ]
    parseuse := initialise_une_parseuse(value)
    retourne parse_mot_clé(parseuse, mots_clés)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Cursor
 * https://drafts.csswg.org/css-ui/#cursor
 * \{ */

#portée_export

CursorType :: énum {
    auto
    default
    none
    context_menu
    help
    pointer
    progress
    wait
    cell
    crosshair
    text
    vertical_text
    alias
    copy
    move
    no_drop
    not_allowed
    grab
    grabbing
    e_resize
    n_resize
    ne_resize
    nw_resize
    s_resize
    se_resize
    sw_resize
    w_resize
    ew_resize
    ns_resize
    nesw_resize
    nwse_resize
    col_resize
    row_resize
    all_scroll
    zoom_in
    zoom_out
}

#portée_module

donne_type_cursor :: fonc (chn: CSSOMString) -> CursorType
#corps_texte {
    enchaineuse: Enchaineuse
    initialise_enchaineuse(*enchaineuse)

    infos := info_de(CursorType)
    pour infos.noms {
        ajoute_au_tampon(*enchaineuse, "    si chn == PROP_", it, " {\n")
        ajoute_au_tampon(*enchaineuse, "        retourne CursorType.", it, "\n")
        ajoute_au_tampon(*enchaineuse, "    }\n")
    }

    ajoute_au_tampon(*enchaineuse, «panique("chn pour curseur invalide")\n»)
    retourne chaine_depuis_enchaineuse(*enchaineuse)
}

parse_propriété_cursor :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    mots_clés := [
        PROP_auto, PROP_default, PROP_none, PROP_context_menu, PROP_help, PROP_pointer, PROP_progress,
        PROP_wait, PROP_cell, PROP_crosshair, PROP_text, PROP_vertical_text, PROP_alias, PROP_copy,
        PROP_move, PROP_no_drop, PROP_not_allowed, PROP_grab, PROP_grabbing, PROP_e_resize,
        PROP_n_resize, PROP_ne_resize, PROP_nw_resize, PROP_s_resize, PROP_se_resize, PROP_sw_resize,
        PROP_w_resize, PROP_ew_resize, PROP_ns_resize, PROP_nesw_resize, PROP_nwse_resize,
        PROP_col_resize, PROP_row_resize, PROP_all_scroll, PROP_zoom_in, PROP_zoom_out
    ]

    parseuse := initialise_une_parseuse(value)
    valeur := parse_mot_clé(parseuse, mots_clés)
    saufsi valeur.possède_valeur() {
        retourne
    }

    retourne valeur
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Font
 * https://drafts.csswg.org/css-fonts/#font-prop
 * \{ */

parse_propriété_font :: fonc (ctx: *ContexteParsageShorthand, value: []ComponentValue) -> bool
{
    noms_propriétés := [PROP_font_weight, PROP_line_height, PROP_font_family, PROP_font_size]
    si parse_mot_clé_global(ctx, noms_propriétés, value) {
        retourne vrai
    }

    font_weight := donne_valeur_normal()
    line_height := donne_valeur_normal()
    font_family := donne_valeur_serif()
    font_size := donne_valeur_medium()

    parseuse := initialise_une_parseuse(value)

    tantque !fini(parseuse) {
        parseuse.consomme_espaces_blanches()

        valeur := parse_valeur_font_weight(parseuse)
        si valeur.possède_valeur() {
            /* font-weight et font-size peuvent n'être qu'un nombre, si nous avons un slash,
             * c'est une font-size, sinon font-weight. */
            si parseuse.consomme_slash_et_espaces_blanches() {
                font_size = valeur.Quelque

                valeur = parse_valeur_line_height(parseuse)
                si valeur.possède_valeur() {
                    line_height = valeur.Quelque
                    continue
                }
                retourne faux
            }

            font_weight = valeur.Quelque
            continue
        }

        valeur = parse_valeur_font_size(parseuse)
        si valeur.possède_valeur() {
            font_size = valeur.Quelque

            saufsi parseuse.consomme_slash_et_espaces_blanches() { 
                continue
            }

            valeur = parse_valeur_line_height(parseuse)
            si valeur.possède_valeur() {
                line_height = valeur.Quelque
                continue
            }

            retourne faux
        }

        valeur = parse_valeur_font_family(parseuse, vrai)
        si valeur.possède_valeur() {
            font_family = valeur.Quelque
            continue
        }

        retourne faux
    }

    ctx.ajoute_propriété(PROP_font_weight, font_weight)
    ctx.ajoute_propriété(PROP_line_height, line_height)
    ctx.ajoute_propriété(PROP_font_family, font_family)
    ctx.ajoute_propriété(PROP_font_size, font_size)
    retourne vrai
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Font family
 * https://drafts.csswg.org/css-fonts/#font-family-prop
 * \{ */

parse_propriété_font_family :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)
    retourne parse_valeur_font_family(parseuse, faux)
}

parse_valeur_font_family :: fonc (parseuse: &Parseuse(ComponentValue), pour_shorthand: bool) -> Optionnel(*ValeurDeStyle)
{

    // [ <family-name> | <generic-family> ]#
    // <generic-family> = <generic-script-specific>| <generic-complete> | <generic-incomplete>
    // <generic-script-specific> = generic(kai) | generic(fangsong) | generic(nastaliq)
    // <generic-complete> = serif | sans-serif | system-ui | cursive | fantasy | math | monospace
    // <generic-incomplete> = ui-serif | ui-sans-serif | ui-monospace | ui-rounded

    generic_complete := [
        PROP_serif, PROP_sans_serif, PROP_monospace
    ]

    valeurs: [..]CSSOMString
    diffère déloge(valeurs)

    /* Pour les familles composées sans guillemets */
    morceaux: [..]CSSOMString
    diffère déloge(morceaux)

    tantque !fini(parseuse) {
        lexème := parseuse.lexème_courant()

        si lexème.est_lexème_de_genre(GenreLexème.Ident) {
            si fait_partie_de(lexème.lexème.valeur, ...generic_complete) {
                tableau_ajoute(*valeurs, lexème.lexème.valeur)
                parseuse.avance()
                continue
            }

            /* Essaie de parser une suite d'identifiants pouvant correspondre à une famille composée sans guillemets. */
            morceaux.taille = 0
            tableau_ajoute(*morceaux, lexème.lexème.valeur)
            parseuse.avance()

            chn_espace := crée_chaine_utf16_unique(" ")

            tantque !fini(parseuse) {
                parseuse.consomme_espaces_blanches()
                lexème = parseuse.lexème_courant()

                saufsi lexème.est_lexème_de_genre(GenreLexème.Ident) {
                    arrête
                }

                tableau_ajoute(*morceaux, chn_espace)
                tableau_ajoute(*morceaux, lexème.lexème.valeur)
                parseuse.avance()
            }

            /* Nous ne pouvons savoir si les guillemets sont manquants où s'il y des mots-clés en plus. */
            si morceaux.taille != 1 && pour_shorthand {
                retourne
            }

            famille := enchaine(...morceaux)
            tableau_ajoute(*valeurs, crée_chaine_utf16_unique(famille))
            continue
        }

        si lexème.est_lexème_de_genre(GenreLexème.String) {
            tableau_ajoute(*valeurs, lexème.lexème.valeur)
            parseuse.avance()
            continue
        }

        si parseuse.consomme_virgule_et_espaces_blanches() {
            continue
        }

        si pour_shorthand {
            arrête
        }

        retourne
    }

    si valeurs.taille == 0 {
        retourne
    }

    si valeurs.taille == 1 {
        retourne crée_valeur_string(valeurs[0])
    }

    résultat := crée_valeur_liste()
    pour valeurs {
        tableau_ajoute(*résultat.valeur, crée_valeur_string(it))
    }
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Font Weight
 * https://drafts.csswg.org/css-fonts/#font-weight-prop
 * \{ */

parse_propriété_font_weight :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)
    retourne parse_valeur_font_weight(parseuse)
}

parse_valeur_font_weight :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    mots_clés := [
        PROP_normal, PROP_bold, PROP_lighter, PROP_bolder
    ]

    valeur := parse_mot_clé(parseuse, mots_clés)
    si valeur.possède_valeur() {
        retourne valeur
    }

    lexème := parseuse.lexème_courant()
    si lexème.est_lexème_de_genre(GenreLexème.Number) {
        parseuse.avance()
        retourne crée_valeur_number(lexème.lexème.numeric_value)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Font Size
 * https://drafts.csswg.org/css-fonts/#font-size-prop
 * \{ */

parse_propriété_font_size :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)
    retourne parse_valeur_font_size(parseuse)
}

parse_valeur_font_size :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    mots_clés := [PROP_larger, PROP_smaller, PROP_xx_small, PROP_x_small, PROP_small, PROP_medium, PROP_large, PROP_x_large, PROP_xx_large, PROP_xxx_large]

    valeur := parse_valeur_length_percentage_positive(parseuse)
    si valeur.possède_valeur() {
        retourne valeur
    }

    valeur = parse_mot_clé(parseuse, mots_clés)
    si valeur.possède_valeur() {
        retourne valeur
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Font Style
 * https://drafts.csswg.org/css-fonts/#font-style-prop
 * \{ */

parse_propriété_font_style :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    /* normal | italic | oblique <angle [-90deg,90deg]>? */
    mots_clés := [
        PROP_normal, PROP_italic
    ]

    parseuse := initialise_une_parseuse(value)
    retourne parse_mot_clé(parseuse, mots_clés)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Background
 * https://drafts.csswg.org/css-backgrounds-3/#background
 * \{ */

parse_propriété_background :: fonc (ctx: *ContexteParsageShorthand, value: []ComponentValue) -> bool
{
    noms_propriétés := [PROP_background_color, PROP_background_image, PROP_background_repeat, PROP_background_attachment]
    si parse_mot_clé_global(ctx, noms_propriétés, value) {
        retourne vrai
    }

    couleur := donne_valeur_transparent()
    eu_couleur := faux
    image := donne_valeur_none()
    background_repeat := donne_valeur_background_repeat_défaut()
    background_attachment := donne_valeur_scroll()
    background_position := donne_valeur_background_position_défaut()
    background_size := donne_valeur_auto()
    background_origin := donne_valeur_border_box()
    background_clip := donne_valeur_border_box()

    nombre_visual_box_spécifiés := 0

    parseuse := initialise_une_parseuse(value)

    tantque !parseuse.fini() {
        parseuse.consomme_espaces_blanches()

        valeur_couleur := parse_valeur_couleur(parseuse)
        si valeur_couleur.possède_valeur() {
            si eu_couleur {
                /* Seule une couleur est autorisée. */
                retourne faux
            }
            couleur = valeur_couleur
            eu_couleur = vrai
            continue
        }

        valeur_image := parse_valeur_background_image(parseuse)
        si valeur_image.possède_valeur() {
            image = valeur_image
            continue
        }

        valeur_attachment := parse_valeur_background_attachment(parseuse)
        si valeur_attachment.possède_valeur() {
            background_attachment = valeur_attachment
            continue
        }

        valeur_repeat := parse_valeur_background_repeat(parseuse)
        si valeur_repeat.possède_valeur() {
            background_repeat = valeur_repeat
            continue
        }

        valeur_position := parse_valeur_background_position(parseuse)
        si valeur_position.possède_valeur() {
            background_position = valeur_position.Quelque

            lexème := parseuse.lexème_courant()
            si lexème.est_lexème_slash() {
                parseuse.avance()
                parseuse.consomme_espaces_blanches()

                size := parse_valeur_background_size(parseuse)
                saufsi size.possède_valeur() {
                    retourne faux
                }

                background_size = size.Quelque
            }

            continue
        }

        valeur_visual_box := parse_valeur_visual_box(parseuse)
        si valeur_visual_box.possède_valeur() {
            /* If one <visual-box> value is present then it sets both background-origin and background-clip
             * to that value. If two values are present, then the first sets background-origin and the second
             * background-clip. */
            si nombre_visual_box_spécifiés == 0 {
                background_clip = valeur_visual_box.Quelque
                background_origin = copie_valeur(background_clip)
                nombre_visual_box_spécifiés = 1
            }
            sinon si nombre_visual_box_spécifiés == 1 {
                background_clip = valeur_visual_box.Quelque
            }
            sinon {
                /* Ignore ou erreur de parsage ? */
            }

            continue
        }

        retourne faux
    }

    ajoute_propriété(ctx, PROP_background_color, couleur)
    ajoute_propriété(ctx, PROP_background_image, image)
    ajoute_propriété(ctx, PROP_background_attachment, background_attachment)
    ajoute_propriété(ctx, PROP_background_repeat, background_repeat)
    ajoute_propriété(ctx, PROP_background_position, background_position)
    ajoute_propriété(ctx, PROP_background_size, background_size)
    ajoute_propriété(ctx, PROP_background_origin, background_origin)
    ajoute_propriété(ctx, PROP_background_clip, background_clip)

    retourne vrai
}

/* https://drafts.csswg.org/css-backgrounds-3/#background-image */
parse_propriété_background_image :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)

    tantque !fini(parseuse) {
        image := parse_valeur_background_image(parseuse)
        si image.possède_valeur() {
            retourne image
        }

        retourne
    }
}

/* <image> | none
 * <image> = <url> | <gradient> */
parse_valeur_background_image :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    lexème := parseuse.lexème_courant()
    si lexème.est_mot_clé(PROP_none) {
        parseuse.avance()
        retourne donne_valeur_none()
    }

    si lexème.est_lexème_de_genre(GenreLexème.Url) {
        url := lexème.lexème.valeur
        parseuse.avance()
        retourne crée_valeur_url(url)
    }

    si lexème.est_fonction() {
        fonction := lexème.function

        si fonction.name == PROP_url {
            parseuse.avance()
            /* À FAIRE : parse proprement un identifiant ou une chaine. */
            retourne crée_valeur_url(fonction.value[0].lexème.valeur)
        }
        retourne
    }
}

/* https://drafts.csswg.org/css-backgrounds-3/#background-repeat */
parse_propriété_background_repeat :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)
    retourne parse_valeur_background_repeat(parseuse)
}

/* <repeat-style> = repeat-x | repeat-y | [repeat | space | round | no-repeat]{1,2} */
parse_valeur_background_repeat :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    si parseuse.fini() {
        retourne
    }

    résultat: BackgroundRepeat

    lexème := parseuse.lexème_courant()
    si lexème.est_mot_clé(PROP_repeat_x) {
        parseuse.avance()
        résultat.horizontal = PROP_repeat_x
        retourne crée_valeur_background_repeat(résultat)
    }

    si lexème.est_mot_clé(PROP_repeat_y) {
        parseuse.avance()
        résultat.horizontal = PROP_repeat_y
        retourne crée_valeur_background_repeat(résultat)
    }

    mots_clés := [PROP_repeat, PROP_space, PROP_round, PROP_no_repeat]

    valeur := parse_mot_clé(parseuse, mots_clés)
    saufsi valeur.possède_valeur() {
        retourne
    }
    
    résultat.horizontal = valeur.Quelque.donne_mot_clé()
    détruit_valeur_de_style(valeur.Quelque)

    parseuse.consomme_espaces_blanches()

    valeur = parse_mot_clé(parseuse, mots_clés)
    si valeur.possède_valeur() {
        résultat.vertical = valeur.Quelque.donne_mot_clé()
        détruit_valeur_de_style(valeur.Quelque)
    }

    retourne crée_valeur_background_repeat(résultat)
}

/* https://drafts.csswg.org/css-backgrounds-3/#background-attachment */
parse_propriété_background_attachment :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)
    retourne parse_valeur_background_attachment(parseuse)
}

/* <attachment> = scroll | fixed | local */
parse_valeur_background_attachment :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    mots_clés := [PROP_scroll, PROP_fixed, PROP_local]
    retourne parse_mot_clé(parseuse, mots_clés)
}

/* https://drafts.csswg.org/css-backgrounds/#background-position */
parse_propriété_background_position :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)
    retourne parse_valeur_background_position(parseuse)
}

parse_valeur_background_position :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    mots_clés := [PROP_left, PROP_center, PROP_right, PROP_top, PROP_bottom]

    valeurs: [4]*ValeurDeStyle
    nombre_de_valeurs: z32
    diffère {
        pour nombre_de_valeurs {
            détruit_valeur_de_style(valeurs[it])
        }
    }

    tantque !parseuse.fini() && nombre_de_valeurs != 4 {
        parseuse.consomme_espaces_blanches()

        opt_mot_clé := parse_mot_clé(parseuse, mots_clés)
        si opt_mot_clé.possède_valeur() {
            valeurs[nombre_de_valeurs] = opt_mot_clé.Quelque
            nombre_de_valeurs += 1
            continue
        }

        opt_length := parse_valeur_length_percentage(parseuse)
        si opt_length.possède_valeur() {
            valeurs[nombre_de_valeurs] = opt_length.Quelque
            nombre_de_valeurs += 1
            continue
        }

        arrête
    }

    si nombre_de_valeurs == 0 {
        retourne
    }

    résultat: BackgroundPosition = ---

    si nombre_de_valeurs == 1 {
        si valeurs[0].est_mot_clé() {
            résultat.horizontal = valeurs[0].donne_mot_clé()
            résultat.décalage_horizontal = donne_valeur_percentage_zéro()
        }
        sinon {
            résultat.horizontal = PROP_left
            résultat.décalage_horizontal = copie_valeur(valeurs[0])
        }
        /* If only one value is specified, the second value is assumed to be center. */
        résultat.vertical = PROP_top
        résultat.décalage_vertical = crée_valeur_percentage(50.0)
    }
    sinon si nombre_de_valeurs == 2 {
        si valeurs[0].est_mot_clé() {
            résultat.horizontal = valeurs[0].donne_mot_clé()
            résultat.décalage_horizontal = donne_valeur_percentage_zéro()
        }
        sinon {
            résultat.horizontal = PROP_left
            résultat.décalage_horizontal = copie_valeur(valeurs[0])
        }
        si valeurs[1].est_mot_clé() {
            résultat.vertical = valeurs[1].donne_mot_clé()
            résultat.décalage_vertical = donne_valeur_percentage_zéro()
        }
        sinon {
            résultat.vertical = PROP_top
            résultat.décalage_vertical = copie_valeur(valeurs[1])
        }
    }
    sinon si nombre_de_valeurs == 3 {
        si valeurs[0].est_mot_clé() && valeurs[1].est_mot_clé() && !valeurs[2].est_mot_clé() {
            valeurs[3] = valeurs[2]
            valeurs[2] = valeurs[1]
            valeurs[1] = donne_valeur_percentage_zéro()
        }
        sinon si valeurs[0].est_mot_clé() && !valeurs[1].est_mot_clé() && valeurs[2].est_mot_clé() {
            valeurs[3] = donne_valeur_percentage_zéro()
        }
        sinon {
            // invalide
            retourne
        }

        résultat.horizontal = valeurs[0].donne_mot_clé()
        résultat.décalage_horizontal = copie_valeur(valeurs[1])
        résultat.vertical = valeurs[2].donne_mot_clé()
        résultat.décalage_vertical = copie_valeur(valeurs[3])
    }
    sinon {
        assert(nombre_de_valeurs == 4)
        saufsi valeurs[0].est_mot_clé() && !valeurs[1].est_mot_clé() && valeurs[2].est_mot_clé() && !valeurs[3].est_mot_clé() {
            // invalide
            retourne
        }

        résultat.horizontal = valeurs[0].donne_mot_clé()
        résultat.décalage_horizontal = copie_valeur(valeurs[1])
        résultat.vertical = valeurs[2].donne_mot_clé()
        résultat.décalage_vertical = copie_valeur(valeurs[3])
    }

    retourne crée_valeur_background_position(résultat)
}

/* Pour background-clip et background-origin
 * https://drafts.csswg.org/css-backgrounds-3/#background-clip
 * https://drafts.csswg.org/css-backgrounds-3/#background-origin
 */
parse_propriété_valeur_visual_box :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)
    retourne parse_valeur_visual_box(parseuse)
}

/* https://drafts.csswg.org/css-box-4/#typedef-visual-box
 * <visual-box> = content-box | padding-box | border-box */
parse_valeur_visual_box :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    mots_clés := [PROP_content_box, PROP_padding_box, PROP_border_box]
    retourne parse_mot_clé(parseuse, mots_clés)
}

/* https://drafts.csswg.org/css-backgrounds-3/#background-size */
parse_propriété_background_size :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)
    retourne parse_valeur_background_size(parseuse)
}

parse_valeur_background_size :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    mots_clés := [PROP_contain, PROP_cover]
    valeur := parse_mot_clé(parseuse, mots_clés)
    si valeur.possède_valeur() {
        retourne valeur
    }

    horizontal := parse_valeur_length_percentage_positive_ou_auto(parseuse)
    saufsi horizontal.possède_valeur() {
        retourne
    }

    vertical := parse_valeur_length_percentage_positive_ou_auto(parseuse)
    saufsi vertical.possède_valeur() {
        vertical = donne_valeur_auto()
    }

    résultat : BackgroundSize = ---
    résultat.horizontal = horizontal
    résultat.vertical = vertical
    retourne crée_valeur_background_size(résultat)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Borders
 * https://drafts.csswg.org/css-backgrounds-3/#border-shorthands
 * \{ */

ValeursBorder :: struct {
    width: *ValeurDeStyle
    style: *ValeurDeStyle
    color: *ValeurDeStyle
}

parse_propriété_border_impl :: fonc (value: []ComponentValue) -> Optionnel(ValeursBorder)
{
    parseuse := initialise_une_parseuse(value)

    valeur_width: Optionnel(*ValeurDeStyle)
    valeur_style: Optionnel(*ValeurDeStyle)
    valeur_color: Optionnel(*ValeurDeStyle)

    tantque !fini(parseuse) {
        parseuse.consomme_espaces_blanches()

        style := parse_valeur_line_style(parseuse)
        si style.possède_valeur() {
            valeur_style = style
            continue
        }

        width := parse_valeur_line_width(parseuse)
        si width.possède_valeur() {
            valeur_width = width
            continue
        }

        color := parse_valeur_couleur(parseuse)
        si color.possède_valeur() {
            valeur_color = color
            continue
        }

        retourne
    }

    résultat: ValeursBorder

    si valeur_width.possède_valeur() {
        résultat.width = valeur_width.Quelque
    }
    sinon {
        /* Valeur initiale */
        résultat.width = donne_valeur_medium()
    }

    si valeur_style.possède_valeur() {
        résultat.style = valeur_style.Quelque
    }
    sinon {
        /* Valeur initiale */
        résultat.style = donne_valeur_none()
    }

    si valeur_color.possède_valeur() {
        résultat.color = valeur_color.Quelque
    }
    sinon {
        /* Valeur initiale */
        résultat.color = donne_valeur_currentColor()
    }

    retourne résultat
}

parse_propriété_border :: fonc (ctx: *ContexteParsageShorthand, value: []ComponentValue) -> bool
{
    noms_propriétés := [
        PROP_border_top_width, PROP_border_bottom_width, PROP_border_right_width, PROP_border_left_width,
        PROP_border_top_style, PROP_border_bottom_style, PROP_border_right_style, PROP_border_left_style,
        PROP_border_top_color, PROP_border_bottom_color, PROP_border_right_color, PROP_border_left_color
    ]
    si parse_mot_clé_global(ctx, noms_propriétés, value) {
        retourne vrai
    }

    opt_valeurs := parse_propriété_border_impl(value)
    saufsi opt_valeurs.possède_valeur() {
        retourne faux
    }

    valeurs := opt_valeurs.Quelque

    ajoute_propriété(ctx, PROP_border_top_width, valeurs.width)
    ajoute_propriété(ctx, PROP_border_bottom_width, valeurs.width)
    ajoute_propriété(ctx, PROP_border_right_width, valeurs.width)
    ajoute_propriété(ctx, PROP_border_left_width, valeurs.width)

    ajoute_propriété(ctx, PROP_border_top_style, valeurs.style)
    ajoute_propriété(ctx, PROP_border_bottom_style, valeurs.style)
    ajoute_propriété(ctx, PROP_border_right_style, valeurs.style)
    ajoute_propriété(ctx, PROP_border_left_style, valeurs.style)

    ajoute_propriété(ctx, PROP_border_top_color, valeurs.color)
    ajoute_propriété(ctx, PROP_border_bottom_color, valeurs.color)
    ajoute_propriété(ctx, PROP_border_right_color, valeurs.color)
    ajoute_propriété(ctx, PROP_border_left_color, valeurs.color)

    retourne vrai
}

parse_propriété_border_edge :: fonc (ctx: *ContexteParsageShorthand, value: []ComponentValue) -> bool
{
    noms_propriétés: [3]CSSOMString
    si ctx.déclaration_parsée.name == PROP_border_top {
        noms_propriétés = [PROP_border_top_width, PROP_border_top_style, PROP_border_top_color]
    }
    sinon si ctx.déclaration_parsée.name == PROP_border_bottom {
        noms_propriétés = [PROP_border_bottom_width, PROP_border_bottom_style, PROP_border_bottom_color]
    }
    sinon si ctx.déclaration_parsée.name == PROP_border_right {
        noms_propriétés = [PROP_border_right_width, PROP_border_right_style, PROP_border_right_color]
    }
    sinon {
        assert(ctx.déclaration_parsée.name == PROP_border_left)
        noms_propriétés = [PROP_border_left_width, PROP_border_left_style, PROP_border_left_color]
    }
    si parse_mot_clé_global(ctx, noms_propriétés, value) {
        retourne vrai
    }

    opt_valeurs := parse_propriété_border_impl(value)
    saufsi opt_valeurs.possède_valeur() {
        retourne faux
    }

    valeurs := opt_valeurs.Quelque

    si ctx.déclaration_parsée.name == PROP_border_top {
        ajoute_propriété(ctx, PROP_border_top_width, valeurs.width)
        ajoute_propriété(ctx, PROP_border_top_style, valeurs.style)
        ajoute_propriété(ctx, PROP_border_top_color, valeurs.color)
    }
    sinon si ctx.déclaration_parsée.name == PROP_border_bottom {
        ajoute_propriété(ctx, PROP_border_bottom_width, valeurs.width)
        ajoute_propriété(ctx, PROP_border_bottom_style, valeurs.style)
        ajoute_propriété(ctx, PROP_border_bottom_color, valeurs.color)
    }
    sinon si ctx.déclaration_parsée.name == PROP_border_right {
        ajoute_propriété(ctx, PROP_border_right_width, valeurs.width)
        ajoute_propriété(ctx, PROP_border_right_style, valeurs.style)
        ajoute_propriété(ctx, PROP_border_right_color, valeurs.color)
    }
    sinon {
        assert(ctx.déclaration_parsée.name == PROP_border_left)
        ajoute_propriété(ctx, PROP_border_left_width, valeurs.width)
        ajoute_propriété(ctx, PROP_border_left_style, valeurs.style)
        ajoute_propriété(ctx, PROP_border_left_color, valeurs.color)
    }

    retourne vrai
}

parse_propriété_border_color :: fonc (ctx: *ContexteParsageShorthand, value: []ComponentValue) -> bool
{
    noms_propriétés := [PROP_border_top_color, PROP_border_right_color, PROP_border_bottom_color, PROP_border_left_color]
    si parse_mot_clé_global(ctx, noms_propriétés, value) {
        retourne vrai
    }

    parseuse := initialise_une_parseuse(value)

    résultat: [4]*ValeurDeStyle
    nombre_valeurs: z64

    tantque !fini(parseuse) && nombre_valeurs != 4 {
        parseuse.consomme_espaces_blanches()

        color := parse_valeur_couleur(parseuse)
        si color.possède_valeur() {
            résultat[nombre_valeurs] = color.Quelque
            nombre_valeurs += 1
            continue
        }

        opt_valeur := parse_mot_clé_global_ou_var(parseuse)
        si opt_valeur.possède_valeur() {
            résultat[nombre_valeurs] = opt_valeur.Quelque
            nombre_valeurs += 1
            continue
        }

        retourne faux
    }

    si nombre_valeurs == 0 {
        retourne faux
    }

    ctx.ajoute_propriétés_boite(nombre_valeurs, résultat, noms_propriétés)
    retourne vrai
}

parse_propriété_border_style :: fonc (ctx: *ContexteParsageShorthand, value: []ComponentValue) -> bool
{
    noms_propriétés := [PROP_border_top_style, PROP_border_right_style, PROP_border_bottom_style, PROP_border_left_style]
    si parse_mot_clé_global(ctx, noms_propriétés, value) {
        retourne vrai
    }

    parseuse := initialise_une_parseuse(value)

    résultat: [4]*ValeurDeStyle
    nombre_valeurs: z64

    tantque !fini(parseuse) && nombre_valeurs != 4 {
        parseuse.consomme_espaces_blanches()

        style := parse_valeur_line_style(parseuse)
        si style.possède_valeur() {
            résultat[nombre_valeurs] = style.Quelque
            nombre_valeurs += 1
            continue
        }

        opt_valeur := parse_mot_clé_global_ou_var(parseuse)
        si opt_valeur.possède_valeur() {
            résultat[nombre_valeurs] = opt_valeur.Quelque
            nombre_valeurs += 1
            continue
        }

        retourne faux
    }

    si nombre_valeurs == 0 {
        retourne faux
    }

    ctx.ajoute_propriétés_boite(nombre_valeurs, résultat, noms_propriétés)
    retourne vrai
}

parse_propriété_border_width :: fonc (ctx: *ContexteParsageShorthand, value: []ComponentValue) -> bool
{
    noms_propriétés := [PROP_border_top_width, PROP_border_right_width, PROP_border_bottom_width, PROP_border_left_width]
    si parse_mot_clé_global(ctx, noms_propriétés, value) {
        retourne vrai
    }

    parseuse := initialise_une_parseuse(value)

    résultat: [4]*ValeurDeStyle
    nombre_valeurs: z64

    tantque !fini(parseuse) && nombre_valeurs != 4 {
        parseuse.consomme_espaces_blanches()

        width := parse_valeur_line_width(parseuse)
        si width.possède_valeur() {
            résultat[nombre_valeurs] = width.Quelque
            nombre_valeurs += 1
            continue
        }

        opt_valeur := parse_mot_clé_global_ou_var(parseuse)
        si opt_valeur.possède_valeur() {
            résultat[nombre_valeurs] = opt_valeur.Quelque
            nombre_valeurs += 1
            continue
        }

        retourne faux
    }

    si nombre_valeurs == 0 {
        retourne faux
    }

    ctx.ajoute_propriétés_boite(nombre_valeurs, résultat, noms_propriétés)
    retourne vrai
}

parse_propriété_border_line_style :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)

    tantque !fini(parseuse) {
        parseuse.consomme_espaces_blanches()

        style := parse_valeur_line_style(parseuse)
        si style.possède_valeur() {
            retourne style
        }

        retourne
    }
}

parse_propriété_border_line_width :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)

    tantque !fini(parseuse) {
        parseuse.consomme_espaces_blanches()

        width := parse_valeur_line_width(parseuse)
        si width.possède_valeur() {
            retourne width
        }

        retourne
    }
}

/* <line-width> = <length [0,∞]> | thin | medium | thick */
parse_valeur_line_width :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    mots_clés := [PROP_thin, PROP_medium, PROP_thick]

    tantque !parseuse.fini() {
        parseuse.consomme_espaces_blanches()

        lexème := parseuse.lexème_courant()
        si lexème.est_lexème_de_genre(GenreLexème.Ident) {
            valeur := parse_mot_clé(parseuse, mots_clés)
            si valeur.possède_valeur() {
                retourne valeur
            }

            retourne
        }

        valeur := parse_valeur_length_positive(parseuse)
        si valeur.possède_valeur() {
            retourne valeur
        }

        retourne
    }
}

/* <line-style> = none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset */
parse_valeur_line_style :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    mots_clés := [PROP_none, PROP_hidden, PROP_dotted, PROP_dashed, PROP_solid, PROP_double, PROP_groove, PROP_ridge, PROP_inset, PROP_outset]
    tantque !parseuse.fini() {
        parseuse.consomme_espaces_blanches()

        lexème := parseuse.lexème_courant()
        si lexème.est_lexème_de_genre(GenreLexème.Ident) {
            valeur := parse_mot_clé(parseuse, mots_clés)
            si valeur.possède_valeur() {
                retourne valeur
            }
        }

        retourne
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Border radius
 * https://drafts.csswg.org/css-backgrounds-3/#border-radius
 * \{ */

parse_propriété_border_radius_shorthand :: fonc (ctx: *ContexteParsageShorthand, value: []ComponentValue) -> bool
{
    noms_propriétés := [PROP_border_top_left_radius, PROP_border_top_right_radius, PROP_border_bottom_right_radius, PROP_border_bottom_left_radius]
    si parse_mot_clé_global(ctx, noms_propriétés, value) {
        retourne vrai
    }

    parseuse := initialise_une_parseuse(value)

    résultat: [4]*ValeurDeStyle
    nombre_de_valeurs: z64

    tantque !fini(parseuse) && nombre_de_valeurs != 4 {
        parseuse.consomme_espaces_blanches()

        /* <length-percentage> */
        valeur := parse_valeur_length_percentage_positive(parseuse)
        si valeur.possède_valeur() {
            résultat[nombre_de_valeurs] = valeur.Quelque
            nombre_de_valeurs += 1
            continue
        }

        opt_variable := parse_variable(parseuse)
        si opt_variable.possède_valeur() {
            résultat[nombre_de_valeurs] = opt_variable.Quelque
            nombre_de_valeurs += 1
            continue
        }

        retourne faux
    }

    si nombre_de_valeurs == 1 {
        résultat[1] = résultat[0]
        résultat[2] = résultat[0]
        résultat[3] = résultat[0]
    }
    sinon si nombre_de_valeurs == 2 {
        résultat[2] = résultat[0]
        résultat[3] = résultat[1]
    }
    sinon si nombre_de_valeurs == 3 {
        résultat[3] = résultat[0]
    }

    pour 4 {
        ctx.ajoute_propriété(noms_propriétés[it], résultat[it])
    }

    retourne vrai
}

parse_propriété_border_radius :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)
    retourne parse_valeur_length_percentage_positive(parseuse)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Margin
 * https://drafts.csswg.org/css-box/#margin-physical
 * https://drafts.csswg.org/css-logical/#margin-properties
 * \{ */

parse_propriété_margin :: fonc (ctx: *ContexteParsageShorthand, value: []ComponentValue) -> bool
{
    noms_propriétés := [PROP_margin_top, PROP_margin_right, PROP_margin_bottom, PROP_margin_left]
    si parse_mot_clé_global(ctx, noms_propriétés, value) {
        retourne vrai
    }

    parseuse := initialise_une_parseuse(value)

    résultat: [4]*ValeurDeStyle
    nombre_valeurs: z64

    tantque !fini(parseuse) && nombre_valeurs != 4 {
        parseuse.consomme_espaces_blanches()

        /* <length-percentage> | auto */
        valeur := parse_valeur_length_percentage_ou_auto(parseuse)
        si valeur.possède_valeur() {
            résultat[nombre_valeurs] = valeur.Quelque
            nombre_valeurs += 1
            continue
        }

        valeur = parse_mot_clé_global_ou_var(parseuse)
        si valeur.possède_valeur() {
            résultat[nombre_valeurs] = valeur.Quelque
            nombre_valeurs += 1
            continue
        }

        retourne faux
    }

    si nombre_valeurs == 0 {
        retourne faux
    }

    ctx.ajoute_propriétés_boite(nombre_valeurs, résultat, noms_propriétés)
    retourne vrai
}

parse_propriété_margin_logique :: fonc (ctx: *ContexteParsageShorthand, value: []ComponentValue) -> bool
{
    noms_propriétés: [2]CSSOMString
    si ctx.déclaration_parsée.name == PROP_margin_block {
        noms_propriétés[0] = PROP_margin_block_start
        noms_propriétés[1] = PROP_margin_block_end
    }
    sinon {
        assert(ctx.déclaration_parsée.name == PROP_margin_inline)
        noms_propriétés[0] = PROP_margin_inline_start
        noms_propriétés[1] = PROP_margin_inline_end
    }
    si parse_mot_clé_global(ctx, noms_propriétés, value) {
        retourne vrai
    }

    parseuse := initialise_une_parseuse(value)

    résultat: [2]*ValeurDeStyle
    nombre_valeurs: z64

    tantque !fini(parseuse) && nombre_valeurs != 2 {
        parseuse.consomme_espaces_blanches()

        /* <length-percentage> | auto */
        valeur := parse_valeur_length_percentage_ou_auto(parseuse)
        si valeur.possède_valeur() {
            résultat[nombre_valeurs] = valeur.Quelque
            nombre_valeurs += 1
            continue
        }

        valeur = parse_mot_clé_global_ou_var(parseuse)
        si valeur.possède_valeur() {
            résultat[nombre_valeurs] = valeur.Quelque
            nombre_valeurs += 1
            continue
        }

        retourne faux
    }

    si nombre_valeurs == 0 {
        retourne faux
    }

    ctx.ajoute_propriétés_logique(nombre_valeurs, résultat, noms_propriétés)
    retourne vrai
}

parse_propriété_margin_top :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)
    parseuse.consomme_espaces_blanches()
    /* <length-percentage> | auto */
    retourne parse_valeur_length_percentage_ou_auto(parseuse)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Padding
 * https://drafts.csswg.org/css-box/#padding-physical
 * https://drafts.csswg.org/css-logical/#padding-properties
 * \{ */

/* <length-percentage [0,∞]> */
parse_propriété_padding :: fonc (ctx: *ContexteParsageShorthand, value: []ComponentValue) -> bool
{
    noms_propriétés := [PROP_padding_top, PROP_padding_right, PROP_padding_bottom, PROP_padding_left]
    si parse_mot_clé_global(ctx, noms_propriétés, value) {
        retourne vrai
    }

    parseuse := initialise_une_parseuse(value)

    résultat: [4]*ValeurDeStyle
    nombre_valeurs: z64

    tantque !fini(parseuse) && nombre_valeurs != 4 {
        parseuse.consomme_espaces_blanches()

        valeur := parse_valeur_length_percentage_positive(parseuse)
        si valeur.possède_valeur() {
            résultat[nombre_valeurs] = valeur.Quelque
            nombre_valeurs += 1
            continue
        }

        opt_valeur := parse_mot_clé_global_ou_var(parseuse)
        si opt_valeur.possède_valeur() {
            résultat[nombre_valeurs] = opt_valeur.Quelque
            nombre_valeurs += 1
            continue
        }

        retourne faux
    }

    si nombre_valeurs == 0 {
        retourne faux
    }

    ctx.ajoute_propriétés_boite(nombre_valeurs, résultat, noms_propriétés)
    retourne vrai
}

parse_propriété_padding_logique :: fonc (ctx: *ContexteParsageShorthand, value: []ComponentValue) -> bool
{
    noms_propriétés: [2]CSSOMString
    si ctx.déclaration_parsée.name == PROP_padding_block {
        noms_propriétés[0] = PROP_padding_block_start
        noms_propriétés[1] = PROP_padding_block_end
    }
    sinon {
        assert(ctx.déclaration_parsée.name == PROP_padding_inline)
        noms_propriétés[0] = PROP_padding_inline_start
        noms_propriétés[1] = PROP_padding_inline_end
    }
    si parse_mot_clé_global(ctx, noms_propriétés, value) {
        retourne vrai
    }

    parseuse := initialise_une_parseuse(value)

    résultat: [2]*ValeurDeStyle
    nombre_valeurs: z64

    tantque !fini(parseuse) && nombre_valeurs != 2 {
        parseuse.consomme_espaces_blanches()

        /* 	<length-percentage [0,∞]> */
        valeur := parse_valeur_length_percentage_positive(parseuse)
        si valeur.possède_valeur() {
            résultat[nombre_valeurs] = valeur.Quelque
            nombre_valeurs += 1
            continue
        }

        valeur = parse_mot_clé_global_ou_var(parseuse)
        si valeur.possède_valeur() {
            résultat[nombre_valeurs] = valeur.Quelque
            nombre_valeurs += 1
            continue
        }

        retourne faux
    }

    si nombre_valeurs == 0 {
        retourne faux
    }

    ctx.ajoute_propriétés_logique(nombre_valeurs, résultat, noms_propriétés)
    retourne vrai
}

parse_propriété_padding_top :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)
    parseuse.consomme_espaces_blanches()
    /* 	<length-percentage [0,∞]> */
    retourne parse_valeur_length_percentage_positive(parseuse)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Height & Width
 * https://www.w3.org/TR/2011/REC-CSS2-20110607/visudet.html#propdef-height
 * https://drafts.csswg.org/css-sizing-3/#preferred-size-properties
 * \{ */

parse_propriété_height_width :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)

    /* auto | <length-percentage [0,∞]> | min-content | max-content | fit-content(<length-percentage [0,∞]>) | <calc-size()> */

    tantque !fini(parseuse) {
        parseuse.consomme_espaces_blanches()

        valeur := parse_valeur_length_percentage_positive_ou_auto(parseuse)
        si valeur.possède_valeur() {
            retourne valeur
        }

        retourne
    }
}

parse_propriété_min_height_width :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)
    parseuse.consomme_espaces_blanches()
    /* auto | <length-percentage [0,∞]> | min-content | max-content | fit-content(<length-percentage [0,∞]>) | <calc-size()> */
    retourne parse_valeur_length_percentage_positive_ou_auto(parseuse)
}

parse_propriété_max_height_width :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)
    parseuse.consomme_espaces_blanches()

    /* none | <length-percentage [0,∞]> | min-content | max-content | fit-content(<length-percentage [0,∞]>) | <calc-size()> */
    lexème := parseuse.lexème_courant()
    si lexème.est_mot_clé(PROP_none) {
        retourne donne_valeur_none()
    }

    retourne parse_valeur_length_percentage_positive(parseuse)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Line Height
 * https://drafts.csswg.org/css2/#propdef-line-height
 * \{ */

/* normal | <number> | <length> | <percentage> | inherit */
parse_propriété_line_height :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)
    retourne parse_valeur_line_height(parseuse)
}

parse_valeur_line_height :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    valeur := parse_valeur_length_positive(parseuse)
    si valeur.possède_valeur() {
        retourne valeur
    }

    valeur = parse_valeur_number_positive(parseuse)
    si valeur.possède_valeur() {
        retourne valeur
    }

    valeur = parse_valeur_percentage(parseuse)
    si valeur.possède_valeur() {
        retourne valeur
    }

    lexème := parseuse.lexème_courant()

    si lexème.est_mot_clé(PROP_normal) {
        parseuse.avance()
        retourne donne_valeur_normal()
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Line Height
 * https://drafts.csswg.org/css-position/#insets
 * \{ */

parse_propriété_inset :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)
    /* auto | <length-percentage> */
    retourne parse_valeur_length_percentage_ou_auto(parseuse)
}

parse_propriété_inset_logique :: fonc (ctx: *ContexteParsageShorthand, value: []ComponentValue) -> bool
{
    noms_propriétés: [2]CSSOMString
    si ctx.déclaration_parsée.name == PROP_inset_block {
        noms_propriétés[0] = PROP_inset_block_start
        noms_propriétés[1] = PROP_inset_block_end
    }
    sinon {
        assert(ctx.déclaration_parsée.name == PROP_inset_inline)
        noms_propriétés[0] = PROP_inset_inline_start
        noms_propriétés[1] = PROP_inset_inline_end
    }
    si parse_mot_clé_global(ctx, noms_propriétés, value) {
        retourne vrai
    }

    parseuse := initialise_une_parseuse(value)

    résultat: [2]*ValeurDeStyle
    nombre_valeurs: z64

    tantque !fini(parseuse) && nombre_valeurs != 2 {
        parseuse.consomme_espaces_blanches()

        /* auto | <length-percentage> */
        valeur := parse_valeur_length_percentage_ou_auto(parseuse)
        si valeur.possède_valeur() {
            résultat[nombre_valeurs] = valeur.Quelque
            nombre_valeurs += 1
            continue
        }

        opt_valeur := parse_mot_clé_global_ou_var(parseuse)
        si opt_valeur.possède_valeur() {
            résultat[nombre_valeurs] = opt_valeur.Quelque
            nombre_valeurs += 1
            continue
        }

        retourne faux
    }


    ctx.ajoute_propriétés_logique(nombre_valeurs, résultat, noms_propriétés)
    retourne vrai
}

parse_propriété_inset_shorthand :: fonc (ctx: *ContexteParsageShorthand, value: []ComponentValue) -> bool
{
    noms_propriétés := [PROP_top, PROP_right, PROP_bottom, PROP_left]
    si parse_mot_clé_global(ctx, noms_propriétés, value) {
        retourne vrai
    }

    parseuse := initialise_une_parseuse(value)

    résultat: [4]*ValeurDeStyle
    nombre_valeurs: z64

    tantque !fini(parseuse) && nombre_valeurs != 4 {
        parseuse.consomme_espaces_blanches()

        /* auto | <length-percentage> */
        valeur := parse_valeur_length_percentage_ou_auto(parseuse)
        si valeur.possède_valeur() {
            résultat[nombre_valeurs] = valeur.Quelque
            nombre_valeurs += 1
            continue
        }

        opt_valeur := parse_mot_clé_global_ou_var(parseuse)
        si opt_valeur.possède_valeur() {
            résultat[nombre_valeurs] = opt_valeur.Quelque
            nombre_valeurs += 1
            continue
        }

        retourne faux
    }

    si nombre_valeurs == 0 {
        retourne faux
    }

    ctx.ajoute_propriétés_boite(nombre_valeurs, résultat, noms_propriétés)
    retourne vrai
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Text Align
 * https://drafts.csswg.org/css-text/#text-align-property
 * \{ */

parse_propriété_text_align :: fonc (ctx: *ContexteParsageShorthand, value: []ComponentValue) -> bool
{
    noms_propriétés := [PROP_text_align_all, PROP_text_align_last]
    si parse_mot_clé_global(ctx, noms_propriétés, value) {
        retourne vrai
    }

    parseuse := initialise_une_parseuse(value)
    mots_clés := [PROP_start, PROP_end, PROP_left, PROP_right, PROP_center, PROP_justify, PROP_match_parent, PROP_justify_all]
    valeur := parse_mot_clé(parseuse, mots_clés)
    saufsi valeur.possède_valeur() {
        retourne faux
    }

    pour noms_propriétés {
        ctx.ajoute_propriété(it, valeur.Quelque)
    }

    retourne vrai
}

/* https://drafts.csswg.org/css-text/#propdef-text-align-all */
parse_propriété_text_align_all :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)
    mots_clés := [PROP_start, PROP_end, PROP_left, PROP_right, PROP_center, PROP_justify, PROP_match_parent, PROP_justify_all]
    retourne parse_mot_clé(parseuse, mots_clés)
}

/* https://drafts.csswg.org/css-text/#propdef-text-align-last */
parse_propriété_text_align_last :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)
    mots_clés := [PROP_auto, PROP_start, PROP_end, PROP_left, PROP_right, PROP_center, PROP_justify, PROP_match_parent, PROP_justify_all]
    retourne parse_mot_clé(parseuse, mots_clés)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Position
 * https://drafts.csswg.org/css-position/#position-property
 * \{ */

parse_propriété_position :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)
    mots_clés := [PROP_static, PROP_relative, PROP_absolute, PROP_sticky, PROP_fixed]
    retourne parse_mot_clé(parseuse, mots_clés)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Float
 * https://drafts.csswg.org/css2/#propdef-float
 * \{ */

parse_propriété_float :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)
    mots_clés := [PROP_left, PROP_right, PROP_none]
    retourne parse_mot_clé(parseuse, mots_clés)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Vertical Align
 * https://drafts.csswg.org/css2/#propdef-vertical-align
 * https://www.w3.org/TR/css-inline-3/#transverse-alignment
 * \{ */

/* baseline | sub | super | top | text-top | middle | bottom | text-bottom | <percentage> | <length> */
parse_propriété_vertical_align :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)
    mots_clés := [PROP_baseline, PROP_top, PROP_middle, PROP_bottom]
    retourne parse_mot_clé(parseuse, mots_clés)
}

/** } */

/* ------------------------------------------------------------------------- */
/** \nom Clear
 * https://www.w3.org/TR/CSS2/visuren.html#propdef-clear
 * \{ */

parse_propriété_clear :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)
    mots_clés := [PROP_none, PROP_left, PROP_both, PROP_right]
    retourne parse_mot_clé(parseuse, mots_clés)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Overflow
 * https://drafts.csswg.org/css-overflow/#propdef-overflow
 * \{ */

parse_shorthand_overflow :: fonc (ctx: *ContexteParsageShorthand, value: []ComponentValue) -> bool
{
    noms_propriétés := [PROP_overflow_x, PROP_overflow_y]
    si parse_mot_clé_global(ctx, noms_propriétés, value) {
        retourne vrai
    }

    parseuse := initialise_une_parseuse(value)

    résultat: [2]*ValeurDeStyle
    nombre_valeurs: z64

    tantque !fini(parseuse) && nombre_valeurs != 2 {
        parseuse.consomme_espaces_blanches()

        valeur := parse_valeur_overflow(parseuse)
        si valeur.possède_valeur() {
            résultat[nombre_valeurs] = valeur.Quelque
            nombre_valeurs += 1
            continue
        }

        opt_valeur := parse_mot_clé_global_ou_var(parseuse)
        si opt_valeur.possède_valeur() {
            résultat[nombre_valeurs] = opt_valeur.Quelque
            nombre_valeurs += 1
            continue
        }

        retourne faux
    }

    ctx.ajoute_propriétés_logique(nombre_valeurs, résultat, noms_propriétés)
    retourne vrai
}

parse_propriété_overflow :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)
    retourne parse_valeur_overflow(parseuse)
}

parse_valeur_overflow :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    mots_clés := [PROP_visible, PROP_hidden, PROP_clip, PROP_scroll, PROP_auto]
    retourne parse_mot_clé(parseuse, mots_clés)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Justify Content
 * https://drafts.csswg.org/css-flexbox/#justify-content-property
 * https://www.w3.org/TR/css-align/#align-justify-content
 * \{ */

parse_propriété_justify_content :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    /* normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ] */
    parseuse := initialise_une_parseuse(value)

    valeur_normal := parse_mot_clé(parseuse, [PROP_normal])
    si valeur_normal.possède_valeur() {
        retourne valeur_normal.Quelque
    }

    content_distribution := parse_valeur_type_content_distribution(parseuse)
    si content_distribution.possède_valeur() {
        retourne content_distribution.Quelque
    }

    retourne parse_valeur_type_content_position(parseuse)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Flex Basis
 * https://drafts.csswg.org/css-flexbox/#flex-basis-property
 * \{ */

parse_propriété_flex_basis :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)

    lexème := parseuse.lexème_courant()

    si lexème.est_mot_clé(PROP_content) {
        retourne donne_valeur_content()
    }

    retourne parse_propriété_height_width(value)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Flex Direction
 * https://drafts.csswg.org/css-flexbox/#flex-direction-property
 * \{ */

parse_propriété_flex_direction :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)
    retourne parse_valeur_flex_direction(parseuse)
}

parse_valeur_flex_direction :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    mots_clés := [PROP_row, PROP_row_reverse, PROP_column, PROP_column_reverse]
    retourne parse_mot_clé(parseuse, mots_clés)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Flex Wrap
 * https://drafts.csswg.org/css-flexbox/#flex-wrap-property
 * \{ */

parse_propriété_flex_wrap :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)
    retourne parse_valeur_flex_wrap(parseuse)
}

parse_valeur_flex_wrap :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    mots_clés := [PROP_nowrap, PROP_wrap, PROP_wrap_reverse]
    retourne parse_mot_clé(parseuse, mots_clés)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Flex
 * https://drafts.csswg.org/css-flexbox/#flex-property
 * \{ */

parse_shorthand_flex :: fonc (ctx: *ContexteParsageShorthand, value: []ComponentValue) -> bool
{
    noms_propriétés := [PROP_flex_grow, PROP_flex_shrink, PROP_flex_basis]
    si parse_mot_clé_global(ctx, noms_propriétés, value) {
        retourne vrai
    }

    parseuse := initialise_une_parseuse(value)

    lexème := parseuse.lexème_courant()

    flex_grow := donne_valeur_number_zéro()
    flex_shrink := donne_valeur_number_un()
    flex_basis := donne_valeur_auto()

    eu_flex_grow := faux
    eu_flex_shrink := faux
    eu_flex_basis := faux

    si lexème.est_mot_clé(PROP_none) {
        // flex: 0 0 auto
        flex_shrink = donne_valeur_number_zéro()
    }
    sinon {
        tantque !fini(parseuse) {
            parseuse.consomme_espaces_blanches()
            lexème = parseuse.lexème_courant()

            si lexème.est_lexème_de_genre(GenreLexème.Number) {
                /* flex-grow */
                parseuse.avance()

                si eu_flex_grow == faux {
                    flex_grow = crée_valeur_number(lexème.lexème.numeric_value)
                    eu_flex_grow = vrai
                }
                sinon si eu_flex_shrink == faux {
                    flex_shrink = crée_valeur_number(lexème.lexème.numeric_value)
                    eu_flex_shrink = vrai
                }
                sinon si eu_flex_basis == faux {
                    flex_basis = crée_valeur_number(lexème.lexème.numeric_value)
                    eu_flex_basis = vrai
                }
                sinon {
                    arrête
                }

                continue
            }

            valeur := parse_valeur_length_percentage_ou_auto(parseuse)
            saufsi valeur.possède_valeur() {
                retourne faux
            }

            si eu_flex_basis {
                retourne faux
            }

            flex_basis = valeur
            eu_flex_basis = vrai
        }
    }

    /* https://drafts.csswg.org/css-flexbox/#flex-common */
    si eu_flex_grow && !eu_flex_shrink && !eu_flex_basis {
        // flex: <number> -> number 1 0%;
        flex_shrink = donne_valeur_number_un()
        flex_basis = donne_valeur_percentage_zéro()
    }
    sinon si eu_flex_basis && !eu_flex_shrink && !eu_flex_grow {
        si flex_basis.est_auto() {
            // flex: auto -> 1 1 auto;
            flex_grow = donne_valeur_number_un()
            flex_shrink = donne_valeur_number_un()
        }
    }

    ctx.ajoute_propriété(PROP_flex_grow, flex_grow)
    ctx.ajoute_propriété(PROP_flex_shrink, flex_shrink)
    ctx.ajoute_propriété(PROP_flex_basis, flex_basis)
    retourne vrai
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Flex Flow
 * https://drafts.csswg.org/css-flexbox/#flex-flow-property
 * \{ */

parse_shorthand_flex_flow :: fonc (ctx: *ContexteParsageShorthand, value: []ComponentValue) -> bool
{
    noms_propriétés := [PROP_flex_direction, PROP_flex_wrap]
    si parse_mot_clé_global(ctx, noms_propriétés, value) {
        retourne vrai
    }

    parseuse := initialise_une_parseuse(value)

    flex_direction := donne_valeur_row()
    flex_wrap := donne_valeur_nowrap()

    tantque !fini(parseuse) {
        parseuse.consomme_espaces_blanches()

        valeur_flex_direction := parse_valeur_flex_direction(parseuse)
        si valeur_flex_direction.possède_valeur() {
            flex_direction = valeur_flex_direction.Quelque
            continue
        }

        valeur_flex_wrap := parse_valeur_flex_wrap(parseuse)
        si valeur_flex_wrap.possède_valeur() {
            flex_wrap = valeur_flex_wrap.Quelque
            continue
        }
    }

    ctx.ajoute_propriété(PROP_flex_direction, flex_direction)
    ctx.ajoute_propriété(PROP_flex_wrap, flex_wrap)
    retourne vrai
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Box Sizing
 * https://drafts.csswg.org/css-sizing/#box-sizing
 * \{ */

parse_propriété_box_sizing :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    mots_clés := [PROP_border_box, PROP_content_box]
    parseuse := initialise_une_parseuse(value)
    retourne parse_mot_clé(parseuse, mots_clés)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom White Space
 * https://drafts.csswg.org/css-text/#propdef-white-space
 * \{ */

parse_propriétés_white_space :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    mots_clés := [PROP_normal, PROP_pre, PROP_nowrap, PROP_pre_wrap, PROP_break_spaces, PROP_pre_line]
    parseuse := initialise_une_parseuse(value)
    retourne parse_mot_clé(parseuse, mots_clés)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Border spacing
 * https://drafts.csswg.org/css2/#propdef-border-spacing
 * \{ */

parse_propriété_border_spacing :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    parseuse := initialise_une_parseuse(value)
    /* À FAIRE : 2 valeurs possibles. */
    retourne parse_valeur_length(parseuse)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Border collapse
 * https://drafts.csswg.org/css2/#propdef-border-collapse
 * \{ */

parse_propriété_border_collapse :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    mots_clés := [PROP_collapse, PROP_separate]
    parseuse := initialise_une_parseuse(value)
    retourne parse_mot_clé(parseuse, mots_clés)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Align Content
 * https://www.w3.org/TR/css-flexbox-1/#propdef-align-content
 * https://www.w3.org/TR/css-align/#align-justify-content
 * \{ */

parse_propriété_align_content :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    /* normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position> */
    parseuse := initialise_une_parseuse(value)
    valeur_normal := parse_mot_clé(parseuse, [PROP_normal])
    si valeur_normal.possède_valeur() {
        retourne valeur_normal.Quelque
    }

    content_distribution := parse_valeur_type_content_distribution(parseuse)
    si content_distribution.possède_valeur() {
        retourne content_distribution.Quelque
    }

    retourne parse_valeur_type_content_position(parseuse)
}

/* https://www.w3.org/TR/css-align/#typedef-content-distribution */
parse_valeur_type_content_distribution :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    /* space-between | space-around | space-evenly | stretch */
    mots_clés := [PROP_space_between, PROP_space_around, PROP_space_evenly, PROP_stretch]
    retourne parse_mot_clé(parseuse, mots_clés)
}

/* https://www.w3.org/TR/css-align/#typedef-content-position */
parse_valeur_type_content_position :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    /* center | start | end | flex-start | flex-end */
    mots_clés := [PROP_center, PROP_start, PROP_end, PROP_flex_start, PROP_flex_end]
    retourne parse_mot_clé(parseuse, mots_clés)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Align Items
 * https://www.w3.org/TR/css-flexbox-1/#align-items-property
 * \{ */

parse_propriété_align_items :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    /* normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ] */
    parseuse := initialise_une_parseuse(value)

    mots_clés := [PROP_normal, PROP_stretch]
    valeur := parse_mot_clé(parseuse, mots_clés)
    si valeur.possède_valeur() {
        retourne valeur.Quelque
    }

    retourne parse_valeur_type_self_position(parseuse)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Align Self
 * https://www.w3.org/TR/css-flexbox-1/#propdef-align-self
 * https://www.w3.org/TR/css-align/#align-self-property
 * \{ */

parse_propriété_align_self :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    /* auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position> */
    parseuse := initialise_une_parseuse(value)

    mots_clés := [PROP_auto, PROP_normal, PROP_stretch]
    valeur := parse_mot_clé(parseuse, mots_clés)
    si valeur.possède_valeur() {
        retourne valeur.Quelque
    }

    retourne parse_valeur_type_self_position(parseuse)
}

/* https://www.w3.org/TR/css-align/#typedef-self-position */
parse_valeur_type_self_position :: fonc (parseuse: &Parseuse(ComponentValue)) -> Optionnel(*ValeurDeStyle)
{
    /* center | start | end | self-start | self-end | flex-start | flex-end */
    mots_clés := [PROP_center, PROP_start, PROP_end, PROP_self_start, PROP_self_end, PROP_flex_start, PROP_flex_end]
    retourne parse_mot_clé(parseuse, mots_clés)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Content
 * https://drafts.csswg.org/css-content-3/#propdef-content
 * \{ */

parse_propriété_content :: fonc (value: []ComponentValue) -> Optionnel(*ValeurDeStyle)
{
    /* normal | none | [ <content-replacement> | <content-list> ] [/ [ <string> | <counter> | <attr()> ]+ ]? */
    parseuse := initialise_une_parseuse(value)

    lexème := parseuse.lexème_courant()
    si lexème.est_mot_clé(PROP_none) {
        retourne donne_valeur_none()
    }

    si lexème.est_mot_clé(PROP_normal) {
        retourne donne_valeur_normal()
    }

    si lexème.est_lexème_de_genre(GenreLexème.String) {
        retourne crée_valeur_string(lexème.lexème.valeur)
    }
}

/** \} */
