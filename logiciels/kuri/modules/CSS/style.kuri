importe Chaine
importe Couleur
importe Fondation

TextDecorationLine :: énum_drapeau n8 {
    UNDERLINE
    LINE_THROUGH
    OVERLINE
    BLINK
}

/* https://www.w3.org/TR/css-values/#value-defs */
ValeurDeStyle :: union {
    mot_clé: CSSOMString
    couleur: CouleurRVBAN8
    longueur: Longueur
    integer: r64
    number: r64
    text_decoration_line: TextDecorationLine
}

détruit_valeur_de_style :: fonc (value: *ValeurDeStyle @inutilisée)
{
}

est_mot_clé :: fonc (valeur: ValeurDeStyle, mot_clé: CSSOMString) -> bool
{
    discr valeur {
        mot_clé(m) {
            retourne m == mot_clé
        }
        sinon {
            retourne faux
        }
    }
}

est_auto :: fonc (valeur: ValeurDeStyle) -> bool
{
    retourne est_mot_clé(valeur, PROP_auto)
}

est_nombre :: fonc (valeur: ValeurDeStyle) -> bool
{
    discr valeur {
        number {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

imprime_valeur_de_style :: fonc (enchaineuse: *Enchaineuse, valeur: *ValeurDeStyle)
{
    saufsi valeur {
        retourne
    }

    discr mémoire(valeur) {
        mot_clé(m) {
            ajoute_au_tampon(enchaineuse, m)
        }
        couleur(c) {
            ajoute_au_tampon(enchaineuse, "rgb(", c.r, " ", c.v, " ", c.b, ")")
        }
        longueur(l) {
            ajoute_au_tampon(enchaineuse, l.valeur, " ", l.unité)
        }
        integer(i) {
            ajoute_au_tampon(enchaineuse, i)
        }
        number(n) {
            ajoute_au_tampon(enchaineuse, n)
        }
        text_decoration_line(t) {
            ajoute_au_tampon(enchaineuse, t)
        }
        sinon {
            ajoute_au_tampon(enchaineuse, "VALEUR INVALIDE OU À IMPRIMER")
        }
    }
} @FormattageImpression

/* ------------------------------------------------------------------------- */
/** \nom PropriétésDeStyle
 * Cette structure représente les propriétés finales d'un élément après la
 * cascade.
 * \{ */

PropriétésDeStyle :: struct {
    déclarations: [..]*DéclarationPropriété
    style: Style
}

crée_propriétés_de_style :: fonc () -> *PropriétésDeStyle
{
    résultat := loge(PropriétésDeStyle)
    initialise_style(*résultat.style)
    retourne résultat
}

copie_propriétés :: fonc (source: *PropriétésDeStyle) -> *PropriétésDeStyle
{
    résultat := crée_propriétés_de_style()

    pour source.déclarations {
        ajoute_déclaration(résultat, it)
    }

    retourne résultat
}

détruit_données_propriétés :: fonc (propriétés: *PropriétésDeStyle)
{
    déloge(propriétés.déclarations)
}

détruit_propriétés :: fonc (propriétés: *PropriétésDeStyle)
{
    détruit_données_propriétés(propriétés)
    déloge(propriétés)
}

ajoute_déclaration :: fonc (propriétés: *PropriétésDeStyle, déclaration: *DéclarationPropriété)
{
    pour propriétés.déclarations {
        si it.property_name == déclaration.property_name {
            propriétés.déclarations[index_it] = déclaration
            retourne
        }
    }
    tableau_ajoute(*propriétés.déclarations, déclaration)
}

donne_déclaration :: fonc (propriétés: *PropriétésDeStyle, nom: CSSOMString) -> *DéclarationPropriété
{
    pour propriétés.déclarations {
        si it.property_name == nom {
            retourne it
        }
    }
    retourne nul
}

/** \} */

Marges :: struct {
    valeur: [4]ValeurDeStyle
}

Padding :: struct {
    valeur: [4]ValeurDeStyle
}

Longueur :: struct {
    Unité :: énum {
        Em
        /* https://drafts.csswg.org/css-values-4/#absolute-lengths */
        Cm
        Mm
        Q
        In
        Pc
        Pt
        Px
    }

    valeur: r64
    unité: Unité
}

calcule_longueur :: fonc (l: Longueur, ctx: *ContexteCalculStyle) -> r64
{
    discr l.unité {
        Px {
            retourne l.valeur
        }
        Em {
            retourne l.valeur * ctx.taille_fonte
        }
        In {
            /* 1in = 96 px */
            retourne l.valeur * 96.0
        }
        Cm {
            /* 1cm = 1 / 2.54 in */
            retourne l.valeur * 96.0 / 2.54
        }
        Mm {
            /* 1mm = 1 / 10 cm */
            retourne l.valeur * 9.6 / 2.54
        }
        Q {
            /* 1Q = 1 / 40 cm (2.4 = 96 / 40) */
            retourne l.valeur * 2.4 / 2.54
        }
        Pc {
            /* 1pc = 1 / 6 in (16 = 96 / 6) */
            retourne l.valeur * 16
        }
        Pt {
            /* 1pt = 1/72 in */
            retourne l.valeur * 96.0 / 72.0
        }
    }

    retourne l.valeur
}

/* https://drafts.csswg.org/css-backgrounds/ */
Background :: struct {
    color: CouleurRVBAN8
}

LineStyle :: énum {
    None
    Hidden
    Dotted
    Dashed
    Solid
    Double
    Groove
    Ridge
    Inset
    Outset
}

BorderEdge :: énum {
    Top
    Bottom
    Left
    Right
}

Border :: struct {
    width: [4]ValeurDeStyle
    style: [4]LineStyle
    color: [4]ValeurDeStyle
}

donne_line_style :: fonc (value: ValeurDeStyle) -> LineStyle
{
    si value.est_mot_clé(PROP_none) {
        retourne LineStyle.None
    }
    si value.est_mot_clé(PROP_hidden) {
        retourne LineStyle.Hidden
    }
    si value.est_mot_clé(PROP_dotted) {
        retourne LineStyle.Dotted
    }
    si value.est_mot_clé(PROP_dashed) {
        retourne LineStyle.Dashed
    }
    si value.est_mot_clé(PROP_solid) {
        retourne LineStyle.Solid
    }
    si value.est_mot_clé(PROP_double) {
        retourne LineStyle.Double
    }
    si value.est_mot_clé(PROP_groove) {
        retourne LineStyle.Groove
    }
    si value.est_mot_clé(PROP_ridge) {
        retourne LineStyle.Ridge
    }
    si value.est_mot_clé(PROP_inset) {
        retourne LineStyle.Inset
    }
    si value.est_mot_clé(PROP_outset) {
        retourne LineStyle.Outset
    }

    imprime("[%] %\n", #nom_de_cette_fonction, value)
    panique("LineStyle inconnu")
}

ContexteCalculStyle :: struct {
    taille_fonte: r64
}

Style :: struct {
    display: Display
    color: CouleurRVBAN8
    // opacity: Opacity
    background: Background
    marges: Marges
    bordure: Border
    padding: Padding
    cursor: CursorType

    font_family: ValeurDeStyle
    taille_fonte: ValeurDeStyle
    font_weight: ValeurDeStyle
    font_style: ValeurDeStyle

    width: ValeurDeStyle
    min_width: ValeurDeStyle
    max_width: ValeurDeStyle

    height: ValeurDeStyle
    min_height: ValeurDeStyle
    max_height: ValeurDeStyle

    text_decoration_style: ValeurDeStyle
    text_decoration_line: ValeurDeStyle
    text_decoration_color: ValeurDeStyle

    line_height: ValeurDeStyle
}

initialise_style :: fonc (style: *Style)
{
    /* Marges */
    pour 4 {
        style.marges.valeur[it] = ValeurDeStyle(number = 0.0)
    }
    /* Padding */
    pour 4 {
        style.padding.valeur[it] = ValeurDeStyle(number = 0.0)
    }

    style.color = CouleurRVBAN8(0, 0, 0, 255)
    style.background.color = CouleurRVBAN8(0, 0, 0, 0)

    /* Bordure */
    pour i dans 4 {
        style.bordure.width[i] = ValeurDeStyle(mot_clé = PROP_medium)
    }
    pour i dans 4 {
        style.bordure.style[i] = LineStyle.None
    }
    pour i dans 4 {
        style.bordure.color[i] = ValeurDeStyle(mot_clé = PROP_currentColor)
    }

    /* Font */
    style.font_family = ValeurDeStyle(mot_clé = PROP_serif)
    style.font_weight = ValeurDeStyle(mot_clé = PROP_normal)
    style.font_style = ValeurDeStyle(mot_clé = PROP_normal)

    /* Text Decoration */
    style.text_decoration_line = ValeurDeStyle(mot_clé = PROP_none)
    style.text_decoration_style = ValeurDeStyle(mot_clé = PROP_solid)
    style.text_decoration_color = ValeurDeStyle(mot_clé = PROP_currentColor)

    /* Tailles */
    style.width = ValeurDeStyle(mot_clé = PROP_auto)
    style.min_width = ValeurDeStyle(number = 0.0)
    style.max_width = ValeurDeStyle(mot_clé = PROP_none)
    style.height = ValeurDeStyle(mot_clé = PROP_auto)
    style.min_height = ValeurDeStyle(number = 0.0)
    style.max_height = ValeurDeStyle(mot_clé = PROP_none)

    style.line_height = ValeurDeStyle(mot_clé = PROP_normal)
}

/* https://www.w3.org/TR/css-color-4/ */
// Color :: struct {
// }

/* https://www.w3.org/TR/css-color-4/#named-colors */

#portée_module

NamedColor :: struct {
    nom: CSSOMString
    valeur: CouleurRVBAN8
}

named_colors := [
    NamedColor(COL_aliceblue, CouleurRVBAN8(240, 248, 255, 255)),
    NamedColor(COL_antiquewhite, CouleurRVBAN8(250, 235, 215, 255)),
    NamedColor(COL_aqua, CouleurRVBAN8(0, 255, 255, 255)),
    NamedColor(COL_aquamarine, CouleurRVBAN8(127, 255, 212, 255)),
    NamedColor(COL_azure, CouleurRVBAN8(240, 255, 255, 255)),
    NamedColor(COL_beige, CouleurRVBAN8(245, 245, 220, 255)),
    NamedColor(COL_bisque, CouleurRVBAN8(255, 228, 196, 255)),
    NamedColor(COL_black, CouleurRVBAN8(0, 0, 0, 255)),
    NamedColor(COL_blanchedalmond, CouleurRVBAN8(255, 235, 205, 255)),
    NamedColor(COL_blue, CouleurRVBAN8(0, 0, 255, 255)),
    NamedColor(COL_blueviolet, CouleurRVBAN8(138, 43, 226, 255)),
    NamedColor(COL_brown, CouleurRVBAN8(165, 42, 42, 255)),
    NamedColor(COL_burlywood, CouleurRVBAN8(222, 184, 135, 255)),
    NamedColor(COL_cadetblue, CouleurRVBAN8(95, 158, 160, 255)),
    NamedColor(COL_chartreuse, CouleurRVBAN8(127, 255, 0, 255)),
    NamedColor(COL_chocolate, CouleurRVBAN8(210, 105, 30, 255)),
    NamedColor(COL_coral, CouleurRVBAN8(255, 127, 80, 255)),
    NamedColor(COL_cornflowerblue, CouleurRVBAN8(100, 149, 237, 255)),
    NamedColor(COL_cornsilk, CouleurRVBAN8(255, 248, 220, 255)),
    NamedColor(COL_crimson, CouleurRVBAN8(220, 20, 60, 255)),
    NamedColor(COL_cyan, CouleurRVBAN8(0, 255, 255, 255)),
    NamedColor(COL_darkblue, CouleurRVBAN8(0, 0, 139, 255)),
    NamedColor(COL_darkcyan, CouleurRVBAN8(0, 139, 139, 255)),
    NamedColor(COL_darkgoldenrod, CouleurRVBAN8(184, 134, 11, 255)),
    NamedColor(COL_darkgray, CouleurRVBAN8(169, 169, 169, 255)),
    NamedColor(COL_darkgreen, CouleurRVBAN8(0, 100, 0, 255)),
    NamedColor(COL_darkgrey, CouleurRVBAN8(169, 169, 169, 255)),
    NamedColor(COL_darkkhaki, CouleurRVBAN8(189, 183, 107, 255)),
    NamedColor(COL_darkmagenta, CouleurRVBAN8(139, 0, 139, 255)),
    NamedColor(COL_darkolivegreen, CouleurRVBAN8(85, 107, 47, 255)),
    NamedColor(COL_darkorange, CouleurRVBAN8(255, 140, 0, 255)),
    NamedColor(COL_darkorchid, CouleurRVBAN8(153, 50, 204, 255)),
    NamedColor(COL_darkred, CouleurRVBAN8(139, 0, 0, 255)),
    NamedColor(COL_darksalmon, CouleurRVBAN8(233, 150, 122, 255)),
    NamedColor(COL_darkseagreen, CouleurRVBAN8(143, 188, 143, 255)),
    NamedColor(COL_darkslateblue, CouleurRVBAN8(72, 61, 139, 255)),
    NamedColor(COL_darkslategray, CouleurRVBAN8(47, 79, 79, 255)),
    NamedColor(COL_darkslategrey, CouleurRVBAN8(47, 79, 79, 255)),
    NamedColor(COL_darkturquoise, CouleurRVBAN8(0, 206, 209, 255)),
    NamedColor(COL_darkviolet, CouleurRVBAN8(148, 0, 211, 255)),
    NamedColor(COL_deeppink, CouleurRVBAN8(255, 20, 147, 255)),
    NamedColor(COL_deepskyblue, CouleurRVBAN8(0, 191, 255, 255)),
    NamedColor(COL_dimgray, CouleurRVBAN8(105, 105, 105, 255)),
    NamedColor(COL_dimgrey, CouleurRVBAN8(105, 105, 105, 255)),
    NamedColor(COL_dodgerblue, CouleurRVBAN8(30, 144, 255, 255)),
    NamedColor(COL_firebrick, CouleurRVBAN8(178, 34, 34, 255)),
    NamedColor(COL_floralwhite, CouleurRVBAN8(255, 250, 240, 255)),
    NamedColor(COL_forestgreen, CouleurRVBAN8(34, 139, 34, 255)),
    NamedColor(COL_fuchsia, CouleurRVBAN8(255, 0, 255, 255)),
    NamedColor(COL_gainsboro, CouleurRVBAN8(220, 220, 220, 255)),
    NamedColor(COL_ghostwhite, CouleurRVBAN8(248, 248, 255, 255)),
    NamedColor(COL_gold, CouleurRVBAN8(255, 215, 0, 255)),
    NamedColor(COL_goldenrod, CouleurRVBAN8(218, 165, 32, 255)),
    NamedColor(COL_gray, CouleurRVBAN8(128, 128, 128, 255)),
    NamedColor(COL_green, CouleurRVBAN8(0, 128, 0, 255)),
    NamedColor(COL_greenyellow, CouleurRVBAN8(173, 255, 47, 255)),
    NamedColor(COL_grey, CouleurRVBAN8(128, 128, 128, 255)),
    NamedColor(COL_honeydew, CouleurRVBAN8(240, 255, 240, 255)),
    NamedColor(COL_hotpink, CouleurRVBAN8(255, 105, 180, 255)),
    NamedColor(COL_indianred, CouleurRVBAN8(205, 92, 92, 255)),
    NamedColor(COL_indigo, CouleurRVBAN8(75, 0, 130, 255)),
    NamedColor(COL_ivory, CouleurRVBAN8(255, 255, 240, 255)),
    NamedColor(COL_khaki, CouleurRVBAN8(240, 230, 140, 255)),
    NamedColor(COL_lavender, CouleurRVBAN8(230, 230, 250, 255)),
    NamedColor(COL_lavenderblush, CouleurRVBAN8(255, 240, 245, 255)),
    NamedColor(COL_lawngreen, CouleurRVBAN8(124, 252, 0, 255)),
    NamedColor(COL_lemonchiffon, CouleurRVBAN8(255, 250, 205, 255)),
    NamedColor(COL_lightblue, CouleurRVBAN8(173, 216, 230, 255)),
    NamedColor(COL_lightcoral, CouleurRVBAN8(240, 128, 128, 255)),
    NamedColor(COL_lightcyan, CouleurRVBAN8(224, 255, 255, 255)),
    NamedColor(COL_lightgoldenrodyellow, CouleurRVBAN8(250, 250, 210, 255)),
    NamedColor(COL_lightgray, CouleurRVBAN8(211, 211, 211, 255)),
    NamedColor(COL_lightgreen, CouleurRVBAN8(144, 238, 144, 255)),
    NamedColor(COL_lightgrey, CouleurRVBAN8(211, 211, 211, 255)),
    NamedColor(COL_lightpink, CouleurRVBAN8(255, 182, 193, 255)),
    NamedColor(COL_lightsalmon, CouleurRVBAN8(255, 160, 122, 255)),
    NamedColor(COL_lightseagreen, CouleurRVBAN8(32, 178, 170, 255)),
    NamedColor(COL_lightskyblue, CouleurRVBAN8(135, 206, 250, 255)),
    NamedColor(COL_lightslategray, CouleurRVBAN8(119, 136, 153, 255)),
    NamedColor(COL_lightslategrey, CouleurRVBAN8(119, 136, 153, 255)),
    NamedColor(COL_lightsteelblue, CouleurRVBAN8(176, 196, 222, 255)),
    NamedColor(COL_lightyellow, CouleurRVBAN8(255, 255, 224, 255)),
    NamedColor(COL_lime, CouleurRVBAN8(0, 255, 0, 255)),
    NamedColor(COL_limegreen, CouleurRVBAN8(50, 205, 50, 255)),
    NamedColor(COL_linen, CouleurRVBAN8(250, 240, 230, 255)),
    NamedColor(COL_magenta, CouleurRVBAN8(255, 0, 255, 255)),
    NamedColor(COL_maroon, CouleurRVBAN8(128, 0, 0, 255)),
    NamedColor(COL_mediumaquamarine, CouleurRVBAN8(102, 205, 170, 255)),
    NamedColor(COL_mediumblue, CouleurRVBAN8(0, 0, 205, 255)),
    NamedColor(COL_mediumorchid, CouleurRVBAN8(186, 85, 211, 255)),
    NamedColor(COL_mediumpurple, CouleurRVBAN8(147, 112, 219, 255)),
    NamedColor(COL_mediumseagreen, CouleurRVBAN8(60, 179, 113, 255)),
    NamedColor(COL_mediumslateblue, CouleurRVBAN8(123, 104, 238, 255)),
    NamedColor(COL_mediumspringgreen, CouleurRVBAN8(0, 250, 154, 255)),
    NamedColor(COL_mediumturquoise, CouleurRVBAN8(72, 209, 204, 255)),
    NamedColor(COL_mediumvioletred, CouleurRVBAN8(199, 21, 133, 255)),
    NamedColor(COL_midnightblue, CouleurRVBAN8(25, 25, 112, 255)),
    NamedColor(COL_mintcream, CouleurRVBAN8(245, 255, 250, 255)),
    NamedColor(COL_mistyrose, CouleurRVBAN8(255, 228, 225, 255)),
    NamedColor(COL_moccasin, CouleurRVBAN8(255, 228, 181, 255)),
    NamedColor(COL_navajowhite, CouleurRVBAN8(255, 222, 173, 255)),
    NamedColor(COL_navy, CouleurRVBAN8(0, 0, 128, 255)),
    NamedColor(COL_oldlace, CouleurRVBAN8(253, 245, 230, 255)),
    NamedColor(COL_olive, CouleurRVBAN8(128, 128, 0, 255)),
    NamedColor(COL_olivedrab, CouleurRVBAN8(107, 142, 35, 255)),
    NamedColor(COL_orange, CouleurRVBAN8(255, 165, 0, 255)),
    NamedColor(COL_orangered, CouleurRVBAN8(255, 69, 0, 255)),
    NamedColor(COL_orchid, CouleurRVBAN8(218, 112, 214, 255)),
    NamedColor(COL_palegoldenrod, CouleurRVBAN8(238, 232, 170, 255)),
    NamedColor(COL_palegreen, CouleurRVBAN8(152, 251, 152, 255)),
    NamedColor(COL_paleturquoise, CouleurRVBAN8(175, 238, 238, 255)),
    NamedColor(COL_palevioletred, CouleurRVBAN8(219, 112, 147, 255)),
    NamedColor(COL_papayawhip, CouleurRVBAN8(255, 239, 213, 255)),
    NamedColor(COL_peachpuff, CouleurRVBAN8(255, 218, 185, 255)),
    NamedColor(COL_peru, CouleurRVBAN8(205, 133, 63, 255)),
    NamedColor(COL_pink, CouleurRVBAN8(255, 192, 203, 255)),
    NamedColor(COL_plum, CouleurRVBAN8(221, 160, 221, 255)),
    NamedColor(COL_powderblue, CouleurRVBAN8(176, 224, 230, 255)),
    NamedColor(COL_purple, CouleurRVBAN8(128, 0, 128, 255)),
    NamedColor(COL_rebeccapurple, CouleurRVBAN8(102, 51, 153, 255)),
    NamedColor(COL_red, CouleurRVBAN8(255, 0, 0, 255)),
    NamedColor(COL_rosybrown, CouleurRVBAN8(188, 143, 143, 255)),
    NamedColor(COL_royalblue, CouleurRVBAN8(65, 105, 225, 255)),
    NamedColor(COL_saddlebrown, CouleurRVBAN8(139, 69, 19, 255)),
    NamedColor(COL_salmon, CouleurRVBAN8(250, 128, 114, 255)),
    NamedColor(COL_sandybrown, CouleurRVBAN8(244, 164, 96, 255)),
    NamedColor(COL_seagreen, CouleurRVBAN8(46, 139, 87, 255)),
    NamedColor(COL_seashell, CouleurRVBAN8(255, 245, 238, 255)),
    NamedColor(COL_sienna, CouleurRVBAN8(160, 82, 45, 255)),
    NamedColor(COL_silver, CouleurRVBAN8(192, 192, 192, 255)),
    NamedColor(COL_skyblue, CouleurRVBAN8(135, 206, 235, 255)),
    NamedColor(COL_slateblue, CouleurRVBAN8(106, 90, 205, 255)),
    NamedColor(COL_slategray, CouleurRVBAN8(112, 128, 144, 255)),
    NamedColor(COL_slategrey, CouleurRVBAN8(112, 128, 144, 255)),
    NamedColor(COL_snow, CouleurRVBAN8(255, 250, 250, 255)),
    NamedColor(COL_springgreen, CouleurRVBAN8(0, 255, 127, 255)),
    NamedColor(COL_steelblue, CouleurRVBAN8(70, 130, 180, 255)),
    NamedColor(COL_tan, CouleurRVBAN8(210, 180, 140, 255)),
    NamedColor(COL_teal, CouleurRVBAN8(0, 128, 128, 255)),
    NamedColor(COL_thistle, CouleurRVBAN8(216, 191, 216, 255)),
    NamedColor(COL_tomato, CouleurRVBAN8(255, 99, 71, 255)),
    NamedColor(COL_turquoise, CouleurRVBAN8(64, 224, 208, 255)),
    NamedColor(COL_violet, CouleurRVBAN8(238, 130, 238, 255)),
    NamedColor(COL_wheat, CouleurRVBAN8(245, 222, 179, 255)),
    NamedColor(COL_white, CouleurRVBAN8(255, 255, 255, 255)),
    NamedColor(COL_whitesmoke, CouleurRVBAN8(245, 245, 245, 255)),
    NamedColor(COL_yellow, CouleurRVBAN8(255, 255, 0, 255)),
    NamedColor(COL_yellowgreen, CouleurRVBAN8(154, 205, 50, 255))
]

/* https://www.w3.org/TR/css-color-4/#css-system-colors */
system_colors := [
    NamedColor(COL_AccentColor, CouleurRVBAN8(0, 0, 0, 255)),
    NamedColor(COL_AccentColorText, CouleurRVBAN8(0, 0, 0, 255)),
    NamedColor(COL_ActiveText, CouleurRVBAN8(0, 0, 255, 255)),
    NamedColor(COL_ButtonBorder, CouleurRVBAN8(0, 0, 0, 255)),
    NamedColor(COL_ButtonFace, CouleurRVBAN8(200, 200, 200, 255)),
    NamedColor(COL_ButtonText, CouleurRVBAN8(0, 0, 0, 255)),
    NamedColor(COL_Canvas, CouleurRVBAN8(255, 255, 255, 255)),
    NamedColor(COL_CanvasText, CouleurRVBAN8(0, 0, 0, 255)),
    NamedColor(COL_Field, CouleurRVBAN8(255, 255, 255, 255)),
    NamedColor(COL_FieldText, CouleurRVBAN8(0, 0, 0, 255)),
    NamedColor(COL_GrayText, CouleurRVBAN8(128, 128, 128, 255)),
    NamedColor(COL_Highlight, CouleurRVBAN8(0, 0, 255, 255)),
    NamedColor(COL_HighlightText, CouleurRVBAN8(0, 0, 0, 255)),
    NamedColor(COL_LinkText, CouleurRVBAN8(0, 0, 255, 255)),
    NamedColor(COL_Mark, CouleurRVBAN8(0, 255, 255, 255)),
    NamedColor(COL_MarkText, CouleurRVBAN8(0, 0, 0, 255)),
    NamedColor(COL_SelectedItem, CouleurRVBAN8(25, 103, 210, 255)),
    NamedColor(COL_SelectedItemText, CouleurRVBAN8(0, 0, 0, 255)),
    NamedColor(COL_VisitedText, CouleurRVBAN8(0, 0, 255, 255))
]

trouve_couleur_pour_mot_clé :: fonc (mot_clé: CSSOMString) -> Optionnel(CouleurRVBAN8)
{
    si mot_clé == PROP_transparent {
        retourne CouleurRVBAN8(0, 0, 0, 0)
    }

    pour named_colors {
        si compare_ascii_insensible_à_la_casse(mot_clé, it.nom) {
            retourne it.valeur
        }
    }

    pour system_colors {
        si compare_ascii_insensible_à_la_casse(mot_clé, it.nom) {
            retourne it.valeur
        }
    }
}

#portée_export

// Opacity :: struct {
// }

TypePropriété :: énum {
    Display
}

/* https://drafts.csswg.org/css-display/#the-display-properties */
Display :: struct {
    Type :: énum n8 {
        Block
        Inline
        RunIn
        Flow
        FlowRoot
        Table
        Flex
        Grid
        Ruby
        ListItem
        TableRowGroup
        TableHeaderGroup
        TableFooterGroup
        TableRow
        TableCell
        TableColumnGroup
        TableColumn
        TableCaption
        RubyBase
        RubyText
        RubyBaseContainer
        RubyTextContainer
        Contents
        None
        InlineBlock
        InlineTable
        InlineFlex
        InlineGrid
    }

    /* Valeurs initiales. */
    outer_type := Type.Inline
    inner_type := Type.Flow
    est_list_item := faux
}

/* ------------------------------------------------------------------------- */
/** \nom Fonctions auxillaires pour le calcul des valeurs de style.
 * \{ */

calcule_valeur_marge :: fonc (valeur: ValeurDeStyle, style: *Style @inutilisée, ctx: *ContexteCalculStyle) -> ValeurDeStyle
{
    discr valeur {
        longueur(l) {
            retourne ValeurDeStyle(number = calcule_longueur(l, ctx))
        }
        integer(i) {
            retourne ValeurDeStyle(number = i)
        }
        sinon {}
    }

    retourne valeur
}

calcule_valeur_padding :: fonc (valeur: ValeurDeStyle, style: *Style @inutilisée, ctx: *ContexteCalculStyle) -> ValeurDeStyle
{
    discr valeur {
        longueur(l) {
            retourne ValeurDeStyle(number = calcule_longueur(l, ctx))
        }
        integer(i) {
            retourne ValeurDeStyle(number = i)
        }
        sinon {}
    }

    retourne valeur
}

calcule_valeur_border_width :: fonc (valeur: ValeurDeStyle, style: *Style @inutilisée, ctx: *ContexteCalculStyle) -> ValeurDeStyle
{
    discr valeur {
        integer(i) {
            retourne ValeurDeStyle(number = i)
        }
        number {
            retourne valeur
        }
        longueur(l) {
            retourne ValeurDeStyle(number = calcule_longueur(l, ctx))
        }
        mot_clé(m) {
            si m == PROP_thin {
                retourne ValeurDeStyle(number = 1.0)
            }
            si m == PROP_medium {
                retourne ValeurDeStyle(number = 3.0)
            }
            si m == PROP_thick {
                retourne ValeurDeStyle(number = 5.0)
            }
            panique("calcule_valeur_border_width : mot-clé inconnu")
        }
        sinon {
            panique("calcule_valeur_border_width non-implémenté")
        }
    }
    retourne valeur
}

calcule_valeur_line_style :: fonc (valeur: ValeurDeStyle, style: *Style @inutilisée, ctx: *ContexteCalculStyle @inutilisée) -> LineStyle
{
    retourne donne_line_style(valeur)
}

calcule_valeur_color :: fonc (valeur: ValeurDeStyle, style: *Style, ctx: *ContexteCalculStyle @inutilisée) -> ValeurDeStyle
{
    discr valeur {
        couleur {
            retourne valeur
        }
        mot_clé(m) {
            si m == PROP_currentColor {
                retourne style.color
            }
            panique("donne_couleur : mot-clé inconnu")
        }
        sinon {
            panique("donne_couleur non-implémenté")
        }
    }
    retourne valeur
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Fonctions de rappels pour le calcul des valeurs de style.
 * Ces fonctions génèrent les "computed values".
 * \{ */

prop_display_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle @inutilisée)
{
    mot_clé := déclaration.value[0].mot_clé

    si mot_clé == PROP_none {
        style.display.outer_type = Display.Type.None
    }
    sinon si mot_clé == PROP_block {
        style.display.outer_type = Display.Type.Block
    }
    sinon si mot_clé == PROP_list_item {
        style.display.outer_type = Display.Type.Block
        style.display.inner_type = Display.Type.Flow
        style.display.est_list_item = vrai
    }
    sinon {
        assert(mot_clé == PROP_inline)
    }
}

prop_color_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    assert(déclaration.value.taille == 1)
    style.color = calcule_valeur_color(déclaration.value[0], style, ctx)
}

prop_background_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    assert(déclaration.value.taille == 1)
    style.background.color = calcule_valeur_color(déclaration.value[0], style, ctx)
}

prop_background_color_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    assert(déclaration.value.taille == 1)
    style.background.color = calcule_valeur_color(déclaration.value[0], style, ctx)
}

prop_text_decoration_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    assert(déclaration.value.taille == 3)
    style.text_decoration_line = déclaration.value[0]
    style.text_decoration_style = déclaration.value[1]
    style.text_decoration_color = calcule_valeur_color(déclaration.value[2], style, ctx)
}

prop_text_decoration_line_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle @inutilisée)
{
    style.text_decoration_line = déclaration.value[0]
}

prop_text_decoration_style_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle @inutilisée)
{
    style.text_decoration_style = déclaration.value[0]
}

prop_text_decoration_color_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    style.text_decoration_color = calcule_valeur_color(déclaration.value[0], style, ctx)
}

prop_cursor_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle @inutilisée)
{
    assert(déclaration.value.taille == 1)
    style.cursor = donne_type_cursor(déclaration.value[0].mot_clé)
}

prop_font_weight_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle @inutilisée)
{
    assert(déclaration.value.taille == 1)
    style.font_weight = déclaration.value[0]
}

prop_font_family_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle @inutilisée)
{
    assert(déclaration.value.taille == 1)
    style.font_family = déclaration.value[0]
}

prop_font_style_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle @inutilisée)
{
    assert(déclaration.value.taille == 1)
    style.font_style = déclaration.value[0]
}

prop_font_size_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    valeur := déclaration.value[0]

    discr valeur {
        mot_clé(m) {
            taille_fonte_référence := ctx.taille_fonte

            taille_fonte := taille_fonte_référence

            /* Utilise 1.2 pour l'échelle. La spécification propose une valeur entre 1.2 et 1.5. */
            si m == PROP_smaller {
                taille_fonte /= 1.2
            }
            sinon si m == PROP_larger {
                taille_fonte *= 1.2
            }
            /* https://drafts.csswg.org/css-fonts/#absolute-size-mapping */
            sinon si m == PROP_xx_small {
                taille_fonte *= 3.0 / 5.0
            }
            sinon si m == PROP_x_small {
                taille_fonte *= 3.0 / 4.0
            }
            sinon si m == PROP_small {
                taille_fonte *= 8.0 / 9.0
            }
            sinon si m == PROP_medium {
                /* Valeur de base, fateur de 1.0 */
            }
            sinon si m == PROP_large {
                taille_fonte *= 6.0 / 5.0
            }
            sinon si m == PROP_x_large {
                taille_fonte *= 3.0 / 2.0
            }
            sinon si m == PROP_xx_large {
                taille_fonte *= 2.0
            }
            sinon si m == PROP_xxx_large {
                taille_fonte *= 3.0
            }
            sinon {
                message := imprime_chaine("[%] mot_clé '%' non pris en charge", #nom_de_cette_fonction, m)
                panique(message)
            }

            ctx.taille_fonte = taille_fonte
            style.taille_fonte = ValeurDeStyle(number = taille_fonte)
        }
        longueur(l) {
            taille_fonte := calcule_longueur(l, ctx)
            ctx.taille_fonte = taille_fonte
            style.taille_fonte = ValeurDeStyle(number = taille_fonte)
        }
        sinon {
            retourne
        }
    }
}

prop_margin_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    si déclaration.value.taille == 1 {
        pour i dans 4 {
            style.marges.valeur[i] = calcule_valeur_marge(déclaration.value[0], style, ctx)
        }
    }
    sinon si déclaration.value.taille == 2 {
        style.marges.valeur[BorderEdge.Top] = calcule_valeur_marge(déclaration.value[0], style, ctx)
        style.marges.valeur[BorderEdge.Bottom] = calcule_valeur_marge(déclaration.value[0], style, ctx)
        style.marges.valeur[BorderEdge.Right] = calcule_valeur_marge(déclaration.value[1], style, ctx)
        style.marges.valeur[BorderEdge.Left] = calcule_valeur_marge(déclaration.value[1], style, ctx)
    }
    sinon si déclaration.value.taille == 3 {
        style.marges.valeur[BorderEdge.Top] = calcule_valeur_marge(déclaration.value[0], style, ctx)
        style.marges.valeur[BorderEdge.Right] = calcule_valeur_marge(déclaration.value[1], style, ctx)
        style.marges.valeur[BorderEdge.Left] = calcule_valeur_marge(déclaration.value[1], style, ctx)
        style.marges.valeur[BorderEdge.Bottom] = calcule_valeur_marge(déclaration.value[2], style, ctx)
    }
    sinon {
        assert(déclaration.value.taille == 4)
        style.marges.valeur[BorderEdge.Top] = calcule_valeur_marge(déclaration.value[0], style, ctx)
        style.marges.valeur[BorderEdge.Right] = calcule_valeur_marge(déclaration.value[1], style, ctx)
        style.marges.valeur[BorderEdge.Bottom] = calcule_valeur_marge(déclaration.value[2], style, ctx)
        style.marges.valeur[BorderEdge.Left] = calcule_valeur_marge(déclaration.value[3], style, ctx)
    }
}

prop_margin_left_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    style.marges.valeur[BorderEdge.Left] = calcule_valeur_marge(déclaration.value[0], style, ctx)
}

prop_margin_right_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    style.marges.valeur[BorderEdge.Right] = calcule_valeur_marge(déclaration.value[0], style, ctx)
}

prop_margin_top_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    style.marges.valeur[BorderEdge.Top] = calcule_valeur_marge(déclaration.value[0], style, ctx)
}

prop_margin_bottom_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    style.marges.valeur[BorderEdge.Bottom] = calcule_valeur_marge(déclaration.value[0], style, ctx)
}

/* À FAIRE : direction du flux */
prop_margin_block_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    si déclaration.value.taille == 1 {
        style.marges.valeur[BorderEdge.Top] = calcule_valeur_marge(déclaration.value[0], style, ctx)
        style.marges.valeur[BorderEdge.Bottom] = calcule_valeur_marge(déclaration.value[0], style, ctx)
    }
    sinon {
        assert(déclaration.value.taille >= 2)
        style.marges.valeur[BorderEdge.Top] = calcule_valeur_marge(déclaration.value[0], style, ctx)
        style.marges.valeur[BorderEdge.Bottom] = calcule_valeur_marge(déclaration.value[1], style, ctx)
    }
}

prop_margin_block_end_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    style.marges.valeur[BorderEdge.Bottom] = calcule_valeur_marge(déclaration.value[0], style, ctx)
}

prop_margin_block_start_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    style.marges.valeur[BorderEdge.Top] = calcule_valeur_marge(déclaration.value[0], style, ctx)
}

prop_margin_inline_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    si déclaration.value.taille == 1 {
        style.marges.valeur[BorderEdge.Left] = calcule_valeur_marge(déclaration.value[0], style, ctx)
        style.marges.valeur[BorderEdge.Right] = calcule_valeur_marge(déclaration.value[0], style, ctx)
    }
    sinon {
        assert(déclaration.value.taille >= 2)
        style.marges.valeur[BorderEdge.Left] = calcule_valeur_marge(déclaration.value[0], style, ctx)
        style.marges.valeur[BorderEdge.Right] = calcule_valeur_marge(déclaration.value[1], style, ctx)
    }
}

prop_margin_inline_end_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    style.marges.valeur[BorderEdge.Right] = calcule_valeur_marge(déclaration.value[0], style, ctx)
}

prop_margin_inline_start_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    style.marges.valeur[BorderEdge.Left] = calcule_valeur_marge(déclaration.value[0], style, ctx)
}

prop_padding_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    si déclaration.value.taille == 1 {
        pour i dans 4 {
            style.padding.valeur[i] = calcule_valeur_padding(déclaration.value[0], style, ctx)
        }
    }
    sinon si déclaration.value.taille == 2 {
        style.padding.valeur[BorderEdge.Top] = calcule_valeur_padding(déclaration.value[0], style, ctx)
        style.padding.valeur[BorderEdge.Bottom] = calcule_valeur_padding(déclaration.value[0], style, ctx)
        style.padding.valeur[BorderEdge.Right] = calcule_valeur_padding(déclaration.value[1], style, ctx)
        style.padding.valeur[BorderEdge.Left] = calcule_valeur_padding(déclaration.value[1], style, ctx)
    }
    sinon si déclaration.value.taille == 3 {
        style.padding.valeur[BorderEdge.Top] = calcule_valeur_padding(déclaration.value[0], style, ctx)
        style.padding.valeur[BorderEdge.Right] = calcule_valeur_padding(déclaration.value[1], style, ctx)
        style.padding.valeur[BorderEdge.Left] = calcule_valeur_padding(déclaration.value[1], style, ctx)
        style.padding.valeur[BorderEdge.Bottom] = calcule_valeur_padding(déclaration.value[2], style, ctx)
    }
    sinon {
        assert(déclaration.value.taille == 4)
        style.padding.valeur[BorderEdge.Top] = calcule_valeur_padding(déclaration.value[0], style, ctx)
        style.padding.valeur[BorderEdge.Right] = calcule_valeur_padding(déclaration.value[1], style, ctx)
        style.padding.valeur[BorderEdge.Bottom] = calcule_valeur_padding(déclaration.value[2], style, ctx)
        style.padding.valeur[BorderEdge.Left] = calcule_valeur_padding(déclaration.value[3], style, ctx)
    }
}

prop_padding_left_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    style.padding.valeur[BorderEdge.Left] = calcule_valeur_padding(déclaration.value[0], style, ctx)
}

prop_padding_right_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    style.padding.valeur[BorderEdge.Right] = calcule_valeur_padding(déclaration.value[0], style, ctx)
}

prop_padding_top_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    style.padding.valeur[BorderEdge.Top] = calcule_valeur_padding(déclaration.value[0], style, ctx)
}

prop_padding_bottom_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    style.padding.valeur[BorderEdge.Bottom] = calcule_valeur_padding(déclaration.value[0], style, ctx)
}

/* À FAIRE : direction du flux */
prop_padding_block_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    si déclaration.value.taille == 1 {
        style.padding.valeur[BorderEdge.Top] = calcule_valeur_padding(déclaration.value[0], style, ctx)
        style.padding.valeur[BorderEdge.Bottom] = calcule_valeur_padding(déclaration.value[0], style, ctx)
    }
    sinon {
        assert(déclaration.value.taille >= 2)
        style.padding.valeur[BorderEdge.Top] = calcule_valeur_padding(déclaration.value[0], style, ctx)
        style.padding.valeur[BorderEdge.Bottom] = calcule_valeur_padding(déclaration.value[1], style, ctx)
    }
}

prop_padding_block_end_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    style.padding.valeur[BorderEdge.Bottom] = calcule_valeur_padding(déclaration.value[0], style, ctx)
}

prop_padding_block_start_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    style.padding.valeur[BorderEdge.Top] = calcule_valeur_padding(déclaration.value[0], style, ctx)
}

prop_padding_inline_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    si déclaration.value.taille == 1 {
        style.padding.valeur[BorderEdge.Left] = calcule_valeur_padding(déclaration.value[0], style, ctx)
        style.padding.valeur[BorderEdge.Right] = calcule_valeur_padding(déclaration.value[0], style, ctx)
    }
    sinon {
        assert(déclaration.value.taille >= 2)
        style.padding.valeur[BorderEdge.Left] = calcule_valeur_padding(déclaration.value[0], style, ctx)
        style.padding.valeur[BorderEdge.Right] = calcule_valeur_padding(déclaration.value[1], style, ctx)
    }
}

prop_padding_inline_end_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    style.padding.valeur[BorderEdge.Right] = calcule_valeur_padding(déclaration.value[0], style, ctx)
}

prop_padding_inline_start_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    style.padding.valeur[BorderEdge.Left] = calcule_valeur_padding(déclaration.value[0], style, ctx)
}

prop_border_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    assert(déclaration.value.taille == 3)

    width := calcule_valeur_border_width(déclaration.value[0], style, ctx)
    border_style := calcule_valeur_line_style(déclaration.value[1], style, ctx)
    color := calcule_valeur_color(déclaration.value[2], style, ctx)

    pour i dans 4 {
        style.bordure.width[i] = width
    }
    pour i dans 4 {
        style.bordure.style[i] = border_style
    }
    pour i dans 4 {
        style.bordure.color[i] = color
    }
}

prop_border_style_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    si déclaration.value.taille == 1 {
        pour i dans 4 {
            style.bordure.style[i] = calcule_valeur_line_style(déclaration.value[0], style, ctx)
        }
    }
    sinon si déclaration.value.taille == 2 {
        style.bordure.style[BorderEdge.Top] = calcule_valeur_line_style(déclaration.value[0], style, ctx)
        style.bordure.style[BorderEdge.Bottom] = calcule_valeur_line_style(déclaration.value[0], style, ctx)
        style.bordure.style[BorderEdge.Right] = calcule_valeur_line_style(déclaration.value[1], style, ctx)
        style.bordure.style[BorderEdge.Left] = calcule_valeur_line_style(déclaration.value[1], style, ctx)
    }
    sinon si déclaration.value.taille == 3 {
        style.bordure.style[BorderEdge.Top] = calcule_valeur_line_style(déclaration.value[0], style, ctx)
        style.bordure.style[BorderEdge.Right] = calcule_valeur_line_style(déclaration.value[1], style, ctx)
        style.bordure.style[BorderEdge.Left] = calcule_valeur_line_style(déclaration.value[1], style, ctx)
        style.bordure.style[BorderEdge.Bottom] = calcule_valeur_line_style(déclaration.value[2], style, ctx)
    }
    sinon {
        assert(déclaration.value.taille == 4)
        style.bordure.style[BorderEdge.Top] = calcule_valeur_line_style(déclaration.value[0], style, ctx)
        style.bordure.style[BorderEdge.Right] = calcule_valeur_line_style(déclaration.value[1], style, ctx)
        style.bordure.style[BorderEdge.Bottom] = calcule_valeur_line_style(déclaration.value[2], style, ctx)
        style.bordure.style[BorderEdge.Left] = calcule_valeur_line_style(déclaration.value[3], style, ctx)
    }
}

prop_border_width_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    si déclaration.value.taille == 1 {
        pour i dans 4 {
            style.bordure.width[i] = calcule_valeur_border_width(déclaration.value[0], style, ctx)
        }
    }
    sinon si déclaration.value.taille == 2 {
        style.bordure.width[BorderEdge.Top] = calcule_valeur_border_width(déclaration.value[0], style, ctx)
        style.bordure.width[BorderEdge.Bottom] = calcule_valeur_border_width(déclaration.value[0], style, ctx)
        style.bordure.width[BorderEdge.Right] = calcule_valeur_border_width(déclaration.value[1], style, ctx)
        style.bordure.width[BorderEdge.Left] = calcule_valeur_border_width(déclaration.value[1], style, ctx)
    }
    sinon si déclaration.value.taille == 3 {
        style.bordure.width[BorderEdge.Top] = calcule_valeur_border_width(déclaration.value[0], style, ctx)
        style.bordure.width[BorderEdge.Right] = calcule_valeur_border_width(déclaration.value[1], style, ctx)
        style.bordure.width[BorderEdge.Left] = calcule_valeur_border_width(déclaration.value[1], style, ctx)
        style.bordure.width[BorderEdge.Bottom] = calcule_valeur_border_width(déclaration.value[2], style, ctx)
    }
    sinon {
        assert(déclaration.value.taille == 4)
        style.bordure.width[BorderEdge.Top] = calcule_valeur_border_width(déclaration.value[0], style, ctx)
        style.bordure.width[BorderEdge.Right] = calcule_valeur_border_width(déclaration.value[1], style, ctx)
        style.bordure.width[BorderEdge.Bottom] = calcule_valeur_border_width(déclaration.value[2], style, ctx)
        style.bordure.width[BorderEdge.Left] = calcule_valeur_border_width(déclaration.value[3], style, ctx)
    }
}

prop_border_color_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    si déclaration.value.taille == 1 {
        pour i dans 4 {
            style.bordure.color[i] = calcule_valeur_color(déclaration.value[0], style, ctx)
        }
    }
    sinon si déclaration.value.taille == 2 {
        style.bordure.color[BorderEdge.Top] = calcule_valeur_color(déclaration.value[0], style, ctx)
        style.bordure.color[BorderEdge.Bottom] = calcule_valeur_color(déclaration.value[0], style, ctx)
        style.bordure.color[BorderEdge.Right] = calcule_valeur_color(déclaration.value[1], style, ctx)
        style.bordure.color[BorderEdge.Left] = calcule_valeur_color(déclaration.value[1], style, ctx)
    }
    sinon si déclaration.value.taille == 3 {
        style.bordure.color[BorderEdge.Top] = calcule_valeur_color(déclaration.value[0], style, ctx)
        style.bordure.color[BorderEdge.Right] = calcule_valeur_color(déclaration.value[1], style, ctx)
        style.bordure.color[BorderEdge.Left] = calcule_valeur_color(déclaration.value[1], style, ctx)
        style.bordure.color[BorderEdge.Bottom] = calcule_valeur_color(déclaration.value[2], style, ctx)
    }
    sinon {
        assert(déclaration.value.taille == 4)
        style.bordure.color[BorderEdge.Top] = calcule_valeur_color(déclaration.value[0], style, ctx)
        style.bordure.color[BorderEdge.Right] = calcule_valeur_color(déclaration.value[1], style, ctx)
        style.bordure.color[BorderEdge.Bottom] = calcule_valeur_color(déclaration.value[2], style, ctx)
        style.bordure.color[BorderEdge.Left] = calcule_valeur_color(déclaration.value[3], style, ctx)
    }
}

prop_border_top_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    assert(déclaration.value.taille == 3)
    style.bordure.width[BorderEdge.Top] = calcule_valeur_border_width(déclaration.value[0], style, ctx)
    style.bordure.style[BorderEdge.Top] = calcule_valeur_line_style(déclaration.value[1], style, ctx)
    style.bordure.color[BorderEdge.Top] = calcule_valeur_color(déclaration.value[2], style, ctx)
}

prop_border_bottom_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    assert(déclaration.value.taille == 3)
    style.bordure.width[BorderEdge.Bottom] = calcule_valeur_border_width(déclaration.value[0], style, ctx)
    style.bordure.style[BorderEdge.Bottom] = calcule_valeur_line_style(déclaration.value[1], style, ctx)
    style.bordure.color[BorderEdge.Bottom] = calcule_valeur_color(déclaration.value[2], style, ctx)
}

prop_border_left_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    assert(déclaration.value.taille == 3)
    style.bordure.width[BorderEdge.Left] = calcule_valeur_border_width(déclaration.value[0], style, ctx)
    style.bordure.style[BorderEdge.Left] = calcule_valeur_line_style(déclaration.value[1], style, ctx)
    style.bordure.color[BorderEdge.Left] = calcule_valeur_color(déclaration.value[2], style, ctx)
}

prop_border_right_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    assert(déclaration.value.taille == 3)
    style.bordure.width[BorderEdge.Right] = calcule_valeur_border_width(déclaration.value[0], style, ctx)
    style.bordure.style[BorderEdge.Right] = calcule_valeur_line_style(déclaration.value[1], style, ctx)
    style.bordure.color[BorderEdge.Right] = calcule_valeur_color(déclaration.value[2], style, ctx)
}

prop_border_top_color_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    assert(déclaration.value.taille == 1)
    style.bordure.color[BorderEdge.Top] = calcule_valeur_color(déclaration.value[0], style, ctx)
}

prop_border_bottom_color_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    assert(déclaration.value.taille == 1)
    style.bordure.color[BorderEdge.Bottom] = calcule_valeur_color(déclaration.value[0], style, ctx)
}

prop_border_left_color_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    assert(déclaration.value.taille == 1)
    style.bordure.color[BorderEdge.Left] = calcule_valeur_color(déclaration.value[0], style, ctx)
}

prop_border_right_color_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    assert(déclaration.value.taille == 1)
    style.bordure.color[BorderEdge.Right] = calcule_valeur_color(déclaration.value[0], style, ctx)
}

prop_border_top_width_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    assert(déclaration.value.taille == 1)
    style.bordure.width[BorderEdge.Top] = calcule_valeur_border_width(déclaration.value[0], style, ctx)
}

prop_border_bottom_width_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    assert(déclaration.value.taille == 1)
    style.bordure.width[BorderEdge.Bottom] = calcule_valeur_border_width(déclaration.value[0], style, ctx)
}

prop_border_left_width_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    assert(déclaration.value.taille == 1)
    style.bordure.width[BorderEdge.Left] = calcule_valeur_border_width(déclaration.value[0], style, ctx)
}

prop_border_right_width_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    assert(déclaration.value.taille == 1)
    style.bordure.width[BorderEdge.Right] = calcule_valeur_border_width(déclaration.value[0], style, ctx)
}

prop_border_top_style_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    assert(déclaration.value.taille == 1)
    style.bordure.style[BorderEdge.Top] = calcule_valeur_line_style(déclaration.value[0], style, ctx)
}

prop_border_bottom_style_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    assert(déclaration.value.taille == 1)
    style.bordure.style[BorderEdge.Bottom] = calcule_valeur_line_style(déclaration.value[0], style, ctx)
}

prop_border_left_style_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    assert(déclaration.value.taille == 1)
    style.bordure.style[BorderEdge.Left] = calcule_valeur_line_style(déclaration.value[0], style, ctx)
}

prop_border_right_style_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    assert(déclaration.value.taille == 1)
    style.bordure.style[BorderEdge.Right] = calcule_valeur_line_style(déclaration.value[0], style, ctx)
}

prop_height_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    valeur := déclaration.value[0]

    discr valeur {
        integer(i) {
            style.height = ValeurDeStyle(number = i)
        }
        longueur(l) {
            style.height = ValeurDeStyle(number = calcule_longueur(l, ctx))
        }
        sinon {
            style.height = valeur
        }
    }
}

prop_min_height_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété @inutilisée, style: *Style @inutilisée, ctx: *ContexteCalculStyle @inutilisée)
{
}

prop_max_height_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété @inutilisée, style: *Style @inutilisée, ctx: *ContexteCalculStyle @inutilisée)
{
}

prop_width_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    valeur := déclaration.value[0]

    discr valeur {
        integer(i) {
            style.width = ValeurDeStyle(number = i)
        }
        longueur(l) {
            style.width = ValeurDeStyle(number = calcule_longueur(l, ctx))
        }
        sinon {
            style.width = valeur
        }
    }
}

prop_min_width_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété @inutilisée, style: *Style @inutilisée, ctx: *ContexteCalculStyle @inutilisée)
{
}

prop_max_width_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    discr déclaration.value[0] {
        integer(i) {
            style.max_width = ValeurDeStyle(number = i)
        }
        number {
            style.max_width = déclaration.value[0]
        }
        longueur(l) {
            style.max_width = ValeurDeStyle(number = calcule_longueur(l, ctx))
        }
        sinon {
            style.max_width = déclaration.value[0]
        }
    }
}

prop_line_height_sur_calcul_style :: fonc (déclaration: *DéclarationPropriété, style: *Style, ctx: *ContexteCalculStyle)
{
    valeur := déclaration.value[0]

    discr valeur {
        integer(i) {
            style.line_height = ValeurDeStyle(number = i)
        }
        longueur(l) {
            style.line_height = ValeurDeStyle(number = calcule_longueur(l, ctx))
        }
        sinon {
            style.line_height = valeur
        }
    }
}

/** \} */
