importe Chaine
importe Fondation
importe Géométrie
importe Math

/* ------------------------------------------------------------------------- */
/** \nom ContexteDeFormattage
 * \{ */

ModeDeFormattage :: énum {
    Normal
    /* Pour le calcul de la largeur « préférée ». */
    BrisureDeLigneExplicite
    /* Pour le calcul de la largeur « minimale préférée ». */
    ToutesLesBrisuresDeLigne
}

BoiteAbsolue :: struct {
    noeud: *NoeudDeDispositionBloc
    containing_block: *NoeudDeDisposition
    pos_x_statique: r64
    pos_y_statique: r64
    fut_disposée: bool
}

GardeBoitesAbsolues :: struct {
    boites: [..]BoiteAbsolue
}

ContexteDeFormattage :: struct {
    type: type_de_données
    parent: *ContexteDeFormattage

    sur_formatte: fonc(*ContexteDeFormattage, *NoeudDeDispositionBloc, ModeDeFormattage)(rien)

    globales: *GlobalesDessin
    arbre: *ArbreDeDisposition
    initial_containing_block: *ContainingBlock

    /* Pour la résolution des pourcentages. */
    ctx_calcul_style: *ContexteCalculStyle

    /* Pour la disposition des boites absolues. */
    boites_absolues: *GardeBoitesAbsolues

    /* https://html.spec.whatwg.org/multipage/rendering.html#align-descendants */
    doit_aligner_les_descendants: Optionnel(AlignementTexte)
}

initialise_depuis_parent :: fonc (ctx: *ContexteDeFormattage, parent: *ContexteDeFormattage)
{
    ctx.parent = parent
    ctx.arbre = parent.arbre
    ctx.globales = parent.globales
    ctx.initial_containing_block = parent.initial_containing_block
    ctx.boites_absolues = parent.boites_absolues
    ctx.ctx_calcul_style = parent.ctx_calcul_style
}

donne_initial_containing_block :: fonc (ctx: *ContexteDeFormattage) -> ContainingBlock
{
    retourne mémoire(ctx.initial_containing_block)
}

formatte :: fonc (contexte: *ContexteDeFormattage, noeud: *NoeudDeDispositionBloc, mode: ModeDeFormattage)
{
    contexte.sur_formatte(contexte, noeud, mode)
}

/* https://drafts.csswg.org/css-display-4/#establish-an-independent-formatting-context
 * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_flow_layout/Introduction_to_formatting_contexts#creating_a_new_block_formatting_context */
requiers_contexte_de_formattage_indépendant :: fonc (noeud: *NoeudDeDisposition) -> bool
{
    si noeud.parent == nul {
        retourne vrai
    }

    // elements made to float using float
    float := noeud.propriétés.donne_valeur_calculée(IDPropriété.Float)
    saufsi float.est_none() {
        retourne vrai
    }

    // absolutely positioned elements
    position := noeud.propriétés.donne_valeur_calculée(IDPropriété.Position)
    si position.est_mot_clé(PROP_absolute) {
        retourne vrai
    }

    // table cells or elements with display: table-cell, including anonymous table cells created when using the display: table-* properties
    si noeud.table_virtuelle.type == TableCellBox {
        retourne vrai
    }

    // table captions or elements with display: table-caption
    si noeud.table_virtuelle.type == CaptionBox {
        retourne vrai
    }

    // block elements where overflow has a value other than visible
    overflow_x := noeud.propriétés.donne_valeur_calculée(IDPropriété.OverflowX)
    overflow_y := noeud.propriétés.donne_valeur_calculée(IDPropriété.OverflowY)
    si !overflow_x.est_mot_clé(PROP_visible) || !overflow_y.est_mot_clé(PROP_visible) {
        retourne vrai
    }

    // elements with display: inline-block
    // elements with display: flow-root or display: flow-root list-item
    display := noeud.propriétés.donne_valeur_calculée(IDPropriété.Display).display
    si display.inner_type == Display.Type.FlowRoot {
        retourne vrai
    }

    // À FAIRE : elements with contain: layout, content, or strict

    // flex items
    si noeud.parent.donne_display().inner_type == Display.Type.Flex {
        // À FAIRE : autres cas
        si noeud.donne_display().inner_type != Display.Type.Flex {
            retourne vrai
        }
    }

    // À FAIRE : grid items
    // À FAIRE : multicol containers
    // À FAIRE : elements with column-span set to all

    retourne faux
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ContexteDeFormattage
 * \{ */

BoiteFlottante :: struct {
    noeud: *NoeudDeDisposition
    position_x: r32
    position_y: r32
    hauteur: r32
    largeur: r32
}

crée_boite_flottante :: fonc (noeud: *NoeudDeDisposition) -> BoiteFlottante
{
    résultat: BoiteFlottante
    résultat.noeud = noeud
    résultat.position_x = noeud.modèle_de_boite.marge.x
    résultat.position_y = noeud.modèle_de_boite.marge.y
    résultat.hauteur = noeud.modèle_de_boite.marge.hauteur
    résultat.largeur = noeud.modèle_de_boite.marge.largeur
    retourne résultat
}

donne_rectangle :: fonc (boite: BoiteFlottante) -> RectanglePosDim(r64)
{
    résultat: RectanglePosDim(r64)
    résultat.x = boite.position_x
    résultat.y = boite.position_y
    résultat.hauteur = boite.hauteur
    résultat.largeur = boite.largeur
    retourne résultat
}

LigneDeFlottants :: struct {
    boites: [..]BoiteFlottante
    rect: RectanglePosDim(r64)
}

détruit_donnée_ligne :: fonc (ligne: *LigneDeFlottants)
{
    déloge(ligne.boites)
}

ajoute_boite :: fonc (ligne: *LigneDeFlottants, boite: BoiteFlottante)
{
    tableau_ajoute(*ligne.boites, boite)
    si ligne.boites.taille == 1 {
        ligne.rect = boite.donne_rectangle()
    }
    sinon {
        ligne.rect = donne_union(ligne.rect, boite.donne_rectangle())
    }
}

donne_position_la_plus_à_gauche :: fonc (ligne: *LigneDeFlottants) -> r64
{
    résultat := ligne.rect.x

    pour > ligne.boites {
        si it.hauteur == 0.0 {
            continue
        }

        résultat = it.position_x + it.largeur
        arrête
    }

    retourne résultat
}

donne_position_la_plus_à_droite :: fonc (ligne: *LigneDeFlottants) -> r64
{
    résultat := ligne.rect.x

    pour > ligne.boites {
        si it.hauteur == 0.0 {
            continue
        }

        résultat = it.position_x
        arrête
    }

    retourne résultat
}

ContenantLignesDeFlottants :: struct {
    lignes: [..]LigneDeFlottants
    réinitialise_pour_clear: bool
}

détruit_données_lignes :: fonc (contenant: *ContenantLignesDeFlottants)
{
    pour * contenant.lignes {
        détruit_donnée_ligne(it)
    }
    déloge(contenant.lignes)
}

donne_dernière_ligne :: fonc (contenant: *ContenantLignesDeFlottants, containing_block: &ContainingBlock, gauche: bool) -> *LigneDeFlottants
{
    si contenant.lignes.taille == 0 || contenant.réinitialise_pour_clear {
        contenant.réinitialise_pour_clear = faux
        retourne ajoute_une_ligne(contenant, containing_block, gauche)
    }

    résultat := *contenant.lignes[contenant.lignes.taille - 1]

    /* Ajoute une nouvelle ligne s'il n'y a pas d'intersection possible avec la dernière ligne. */
    si résultat.boites.taille != 0 && (résultat.rect.y + résultat.rect.hauteur <= containing_block.rect.y) {
        résultat = ajoute_une_ligne(contenant, containing_block, gauche)
    }

    retourne résultat
}

ajoute_une_ligne :: fonc (contenant: *ContenantLignesDeFlottants, containing_block: &ContainingBlock, gauche: bool) -> *LigneDeFlottants
{
    résultat := tableau_ajoute_élément(*contenant.lignes)
    résultat.rect.x = containing_block.rect.x
    saufsi gauche {
        résultat.rect.x += containing_block.rect.largeur
    }

    si contenant.lignes.taille > 1 {
        dernière_ligne := contenant.lignes[contenant.lignes.taille - 2]
        résultat.rect.y = dernière_ligne.rect.y + dernière_ligne.rect.hauteur
    }
    sinon {
        résultat.rect.y = containing_block.rect.y
    }

    retourne résultat
}

DonnéesMarge :: struct {
    noeud: *NoeudDeDisposition
    /* Pour différencier entre margin-top et margin-bottom */
    id_propriété: IDPropriété
    taille: r32
    y_min: r32
    y_max: r32
}

marges_sont_adjointes :: fonc (a: *DonnéesMarge, b: *DonnéesMarge) -> bool
{
    /* Puisque nous modifions directement la position des noeuds, le test sur
     * l'adjonction ne peut se faire via p.e. a.y_max == b.y_min. En effet,
     * suite au déplacement, les marges peuvent se superposer. */
    saufsi a.y_min <= b.y_min <= a.y_max || a.y_min <= b.y_max <= a.y_max {
        retourne faux
    }

    /* Par contre, puisqu'il y a une superposition, nous devons tester que les
     * sources des marges peuvent avoir une adjonction.
     * https://www.w3.org/TR/2011/REC-CSS2-20110607/box.html#collapsing-margins
     */

    si a.noeud == b.noeud {
        /* Nous devons être vide. */
        retourne a.noeud.modèle_de_boite.contenu.hauteur == 0.0
    }

    /* Nous sommes adèlphes. */
    si a.noeud.parent == b.noeud.parent {
        si a.id_propriété == IDPropriété.MarginBottom {
            /* Soit nous fusionnons avec la marge haute, ou s'il n'y a pas de marge haute, le contenu du noeud doit être vide. */
            retourne b.id_propriété == IDPropriété.MarginTop || b.noeud.modèle_de_boite.contenu.hauteur == 0.0
        }

        /* Nous devons être vide. */
        retourne a.noeud.modèle_de_boite.contenu.hauteur == 0.0
    }

    retourne vrai
}

ContexteDeFormattageBloc :: struct {
    empl base: ContexteDeFormattage
    type = #type_de_cette_structure
    sur_formatte = contexte_formattage_bloc_sur_formatte

    racine: *NoeudDeDispositionBloc

    /* Pour la disposition des floats. */
    lignes_boites_flottantes_gauche: ContenantLignesDeFlottants
    lignes_boites_flottantes_droite: ContenantLignesDeFlottants
    rect_boites_flottantes_gauches: RectanglePosDim(r64)
    rect_boites_flottantes_droites: RectanglePosDim(r64)

    /* Pour le collapsage des marges. */
    marges: [..]DonnéesMarge
}

détruit_données_contexte :: fonc (ctx: *ContexteDeFormattageBloc)
{
    déloge(ctx.marges)
    détruit_données_lignes(*ctx.lignes_boites_flottantes_gauche)
    détruit_données_lignes(*ctx.lignes_boites_flottantes_droite)
}

ParamètresPositionnementBoite :: struct {
    décalage_hors_float := 0.0
    décalage_pour_floats_gauche := 0.0
    décalage_pour_floats_droite := 0.0
}

contexte_formattage_bloc_sur_formatte :: fonc (base: *ContexteDeFormattage, noeud: *NoeudDeDispositionBloc, mode: ModeDeFormattage)
{
    ctx := base comme *ContexteDeFormattageBloc

    ajoute_marge(ctx, noeud, IDPropriété.MarginTop)

    /* Pour le collapsage des marges :
     * https://www.w3.org/TR/CSS2/box.html#collapsing-margins */
    dernier_enfant_in_flow: *NoeudDeDisposition = nul

    décalage_x := noeud.modèle_de_boite.contenu.x
    décalage_y := noeud.modèle_de_boite.contenu.y

    params_position: ParamètresPositionnementBoite

    pour noeud.enfants {
        position := it.propriétés.donne_valeur_utilisée(IDPropriété.Position)
        si position.est_mot_clé(PROP_absolute) {
            ctx.dispose_boite_absolute(it comme *NoeudDeDispositionBloc, décalage_x, décalage_y + params_position.décalage_hors_float, mode)
            continue
        }

        si position.est_mot_clé(PROP_fixed) {
            ctx.dispose_boite_fixed(it comme *NoeudDeDispositionBloc, décalage_x, décalage_y + params_position.décalage_hors_float)
            continue
        }

        clear := it.propriétés.donne_valeur_utilisée(IDPropriété.Clear)
        applique_clearance(ctx, *params_position, clear, décalage_y)

        float := it.propriétés.donne_valeur_utilisée(IDPropriété.Float)
        si float.est_mot_clé(PROP_left) {
            it.définis_position(décalage_x, décalage_y + params_position.décalage_pour_floats_gauche)
            it.mesure(ctx, mode, nul)
            ctx.ajoute_boite_flottante_gauche(it, mode)
            continue
        }
        si float.est_mot_clé(PROP_right) {
            it.définis_position(décalage_x, décalage_y + params_position.décalage_pour_floats_droite)
            it.mesure(ctx, mode, nul)
            ctx.ajoute_boite_flottante_droite(it, mode)
            continue
        }

        /* Sauvegarde la position des floats pour le collapsage des marges.
         * Si la propriété clear du noeud nous force à le décaler sous les floats,
         * nous ne voulons pas qu'il soit décalé sous ses descendants. */
        position_basse_floats_gauches := ctx.donne_décalage_floats_gauche()
        position_basse_floats_droites := ctx.donne_décalage_floats_droite()

        it.définis_position(décalage_x, décalage_y + params_position.décalage_hors_float)
        it.mesure(ctx, mode, nul)
        ajoute_marge(ctx, it, IDPropriété.MarginBottom)

        hauteur_enfant := it.modèle_de_boite.marge.hauteur

        marge_collapsée_opt := donne_marge_collapsée(ctx, it, dernier_enfant_in_flow)
        si marge_collapsée_opt.possède_valeur() {
            marge_collapsée := marge_collapsée_opt.Quelque

            nouvelle_position_bordure := marge_collapsée.bord_référence + marge_collapsée.taille

            si clear.est_mot_clé(PROP_left) {
                nouvelle_position_bordure = max(nouvelle_position_bordure, position_basse_floats_gauches)
            }
            sinon si clear.est_mot_clé(PROP_right) {
                nouvelle_position_bordure = max(nouvelle_position_bordure, position_basse_floats_droites)
            }
            sinon si clear.est_mot_clé(PROP_both) {
                décalage := max(position_basse_floats_gauches, position_basse_floats_droites)
                nouvelle_position_bordure = max(nouvelle_position_bordure, décalage)
            }

            décalage := nouvelle_position_bordure - it.modèle_de_boite.bordure.y

            si décalage != 0.0 {
                it.décale(0.0, décalage)

                /* À FAIRE : généralise. */
                pour * boite dans ctx.boites_absolues.boites {
                    si boite.noeud.parent == it {
                        boite.pos_y_statique += décalage
                    }
                }

                hauteur_enfant += décalage
            }
        }

        /* Les noeuds anonymes pour les espaces blanches entre éléments interfèrent avec le collapsage des marges. */
        saufsi it.est_espace_blanche_document() {
            dernier_enfant_in_flow = it
        }

        params_position.décalage_hors_float += hauteur_enfant

        /* Les blocs dont le formatte interne est inline ne doivent pas déplacer les floats. */
        méthode_de_formattage := donne_méthode_de_formattage_intérieur(it)
        si méthode_de_formattage != MéthodeDeFormattage.Inline {
            params_position.décalage_pour_floats_gauche = params_position.décalage_hors_float
            params_position.décalage_pour_floats_droite = params_position.décalage_hors_float
        }
    }

    pour noeud.enfants {
        position := it.propriétés.donne_valeur_utilisée(IDPropriété.Position)
        /* À FAIRE : https://drafts.csswg.org/css-position/#relpos-insets */
        si position.est_mot_clé(PROP_relative) {
            résoud_pourcentage_insets(it, ctx)
            top := it.donne_décalage_top_pour_relative()
            left := it.donne_décalage_left_pour_relative()
            it.décale(left, top)
        }
    }

    discr mode {
        BrisureDeLigneExplicite,
        ToutesLesBrisuresDeLigne {
            largeur_max_enfant : r64 = 0.0
            pour noeud.enfants {
                position := it.propriétés.donne_valeur_utilisée(IDPropriété.Position)
                si position.est_mot_clé(PROP_absolute) || position.est_mot_clé(PROP_fixed) {
                    continue
                }

                largeur_enfant := it.modèle_de_boite.marge.largeur
                largeur_max_enfant = max(largeur_max_enfant, largeur_enfant)
            }

            largeur_max_enfant = max(largeur_max_enfant, ctx.rect_boites_flottantes_gauches.largeur)
            largeur_max_enfant = max(largeur_max_enfant, ctx.rect_boites_flottantes_droites.largeur)

            prop_largeur := noeud.propriétés.donne_valeur_calculée(IDPropriété.Width)
            si prop_largeur.est_auto() {
                noeud.propriétés.définis_valeur_utilisée(IDPropriété.Width, ValeurDeStyle(pixels = largeur_max_enfant))
                ajourne_boite_pour_calcul_largeur(noeud)
            }
        }
        sinon {}
    }
}

marges_sont_adjointes :: fonc (noeud: *NoeudDeDisposition) -> bool
{
    retourne noeud.modèle_de_boite.bordure.y == noeud.modèle_de_boite.bordure.y + noeud.modèle_de_boite.bordure.hauteur
}

ajoute_marge :: fonc (ctx: *ContexteDeFormattageBloc, noeud: *NoeudDeDisposition, id: IDPropriété)
{
    assert(id == IDPropriété.MarginTop || id == IDPropriété.MarginBottom)

    taille := noeud.propriétés.donne_valeur_utilisée(id).pixels comme r32
    si taille == 0.0 && est_espace_blanche_document(noeud) {
        retourne
    }

    marge := tableau_ajoute_élément(*ctx.marges)
    marge.noeud = noeud
    marge.id_propriété = id
    marge.taille = taille
    ajourne_min_max(marge)
}

ajourne_min_max :: fonc (marge: *DonnéesMarge)
{
    noeud := marge.noeud

    si marge.id_propriété == IDPropriété.MarginTop {
        marge.y_min = noeud.modèle_de_boite.marge.y
        marge.y_max = noeud.modèle_de_boite.bordure.y
    }
    sinon {
        marge.y_min = noeud.modèle_de_boite.bordure.y + noeud.modèle_de_boite.bordure.hauteur
        marge.y_max = noeud.modèle_de_boite.marge.y + noeud.modèle_de_boite.marge.hauteur
    }

    /* Pour les marges négatives. */
    si marge.y_max < marge.y_min {
        tmp := marge.y_min
        marge.y_min = marge.y_max
        marge.y_max = tmp
    }
}

MargeCollapsée :: struct {
    /* Soit le bord haut de la marge haute du noeud parent (pour le premier enfant),
     * ou le bord bas du contenu d'un ainé. L'ainé en question n'est pas forcément
     * l'élément précédent puisque celui peut être vide et nous pourrions collapser
     * à travers lui. */
    bord_référence: r32

    /* La taille de la marge. */
    taille: r32
}

donne_marge_collapsée :: fonc (ctx: *ContexteDeFormattageBloc, noeud: *NoeudDeDisposition, dernier_enfant_in_flow: *NoeudDeDisposition) -> Optionnel(MargeCollapsée)
{
    si dernier_enfant_in_flow == nul {
        /* Nous collapsons avec la marge du parent, sauf s'il est la racine du contexte (les floats,
         * le noeud racine, etc., ne collapsent pas leurs marges avec leurs enfants). */
        si noeud.parent == ctx.racine {
            retourne
        }

        index_marge_parent := donne_index_marge(ctx, noeud.parent, IDPropriété.MarginTop)
        index_marge := donne_index_marge(ctx, noeud, IDPropriété.MarginTop)

        si index_marge_parent == -1 || index_marge == -1 {
            /* Nous ne pouvons collapser avec le parent, la position est inchangée. */
            retourne
        }

        /* Si le parent possède une bordure, on ne peut pas collapser. */
        si noeud.parent.modèle_de_boite.bordure.hauteur != noeud.parent.modèle_de_boite.contenu.hauteur {
            retourne
        }

        marge_parent := ctx.marges[index_marge_parent]
        marge := ctx.marges[index_marge]

        taille := si marge_parent.taille < 0.0 && marge.taille < 0.0 {
            0.0 - max(abs(marge.taille), abs(marge_parent.taille))
        }
        sinon si marge_parent.taille < 0.0 {
            (marge.taille - abs(marge_parent.taille))
        }
        sinon si marge.taille < 0.0 {
            (marge_parent.taille - abs(marge.taille))
        }
        sinon {
            max(marge_parent.taille, marge.taille)
        }

        résultat: MargeCollapsée
        résultat.taille = taille
        résultat.bord_référence = noeud.parent.modèle_de_boite.marge.y
        retourne résultat
    }

    si marges_sont_adjointes(noeud) {
        retourne donne_marge_collapsée_depuis(ctx, noeud, IDPropriété.MarginBottom)
    }
    retourne donne_marge_collapsée_depuis(ctx, noeud, IDPropriété.MarginTop)
}

donne_index_marge :: fonc (ctx: *ContexteDeFormattageBloc, noeud: *NoeudDeDisposition, id: IDPropriété) -> z64
{
    pour ctx.marges {
        si it.noeud == noeud && it.id_propriété == id {
            retourne index_it
        }
    }

    retourne -1
}

donne_marge_collapsée_depuis :: fonc (ctx: *ContexteDeFormattageBloc, noeud: *NoeudDeDisposition, id: IDPropriété) -> Optionnel(MargeCollapsée)
{
    index := donne_index_marge(ctx, noeud, id)
    si index == -1 {
        retourne
    }

    dernier := *ctx.marges[index]
    premier := dernier
    début := *ctx.marges[0]

    tantque premier >= début {
        ajourne_min_max(premier)

        si premier < dernier {
            saufsi marges_sont_adjointes(premier, premier + 1) {
                premier += 1
                arrête
            }
        }

        premier -= 1
    }

    si premier < début {
        premier = début
    }

    si premier == dernier {
        /* La seule marge existante est la nôtre : nous ne la collapsons pas. */
        assert(premier.noeud == noeud)
        retourne
    }

    résultat: MargeCollapsée
    si premier.id_propriété == IDPropriété.MarginTop {
        résultat.bord_référence = premier.y_min
    }
    sinon {
        résultat.bord_référence = premier.noeud.modèle_de_boite.bordure.y + premier.noeud.modèle_de_boite.bordure.hauteur
    }

    nombre_positives := 0
    nombre_négatives := 0

    max_positives := 0.0
    max_négatives := 0.0

    tantque premier <= dernier {
        taille := premier.taille

        si taille < 0.0 {
            nombre_négatives += 1
            max_négatives = max(max_négatives, abs(taille))
        }
        sinon {
            nombre_positives += 1
            max_positives = max(max_positives, taille)
        }

        premier += 1
    }

    résultat.taille = si nombre_positives == 0 {
        0.0 - max_négatives
    }
    sinon si nombre_négatives == 0 {
        max_positives
    }
    sinon {
        max_positives - max_négatives
    }

    retourne résultat
}

applique_clearance :: fonc (ctx: *ContexteDeFormattageBloc, empl params: *ParamètresPositionnementBoite, clear: ValeurDeStyle, décalage_y: r32)
{
    si clear.est_mot_clé(PROP_left) {
        hauteur_float_left := ctx.donne_décalage_floats_gauche() - décalage_y

        si décalage_hors_float < hauteur_float_left {
            décalage_hors_float = hauteur_float_left
        }

        si décalage_pour_floats_gauche < hauteur_float_left {
            décalage_pour_floats_gauche = hauteur_float_left
        }

        ctx.lignes_boites_flottantes_gauche.réinitialise_pour_clear = vrai
    }
    sinon si clear.est_mot_clé(PROP_right) {
        hauteur_float_right := ctx.donne_décalage_floats_droite() - décalage_y

        si décalage_hors_float < hauteur_float_right {
            décalage_hors_float = hauteur_float_right
        }

        si décalage_pour_floats_droite < hauteur_float_right {
            décalage_pour_floats_droite = hauteur_float_right
        }

        ctx.lignes_boites_flottantes_droite.réinitialise_pour_clear = vrai
    }
    sinon si clear.est_mot_clé(PROP_both) {
        hauteur_float_right := ctx.donne_décalage_floats_droite() - décalage_y
        hauteur_float_left := ctx.donne_décalage_floats_gauche() - décalage_y
        hauteur_float_both := max(hauteur_float_left, hauteur_float_right)

        si décalage_hors_float < hauteur_float_both {
            décalage_hors_float = hauteur_float_both
        }

        si décalage_pour_floats_gauche < hauteur_float_both {
            décalage_pour_floats_gauche = hauteur_float_both
        }

        si décalage_pour_floats_droite < hauteur_float_both {
            décalage_pour_floats_droite = hauteur_float_both
        }

        ctx.lignes_boites_flottantes_gauche.réinitialise_pour_clear = vrai
        ctx.lignes_boites_flottantes_droite.réinitialise_pour_clear = vrai
    }
}

dispose_boite_fixed :: fonc (empl ctx: *ContexteDeFormattageBloc, noeud: *NoeudDeDispositionBloc, pos_x_statique: r64, pos_y_statique: r64)
{
    boite_absolue: BoiteAbsolue
    boite_absolue.containing_block = ctx.donne_initial_containing_block().noeud
    boite_absolue.noeud = noeud
    boite_absolue.pos_x_statique = pos_x_statique
    boite_absolue.pos_y_statique = pos_y_statique

    dispose_boite_absolute(ctx, *boite_absolue)
}

dispose_boite_absolute :: fonc (empl ctx: *ContexteDeFormattage, noeud: *NoeudDeDispositionBloc, pos_x_statique: r64, pos_y_statique: r64, mode: ModeDeFormattage)
{
    si mode != ModeDeFormattage.Normal {
        retourne
    }

    containing_block := donne_containing_block(noeud, ctx)

    boite_absolue := tableau_ajoute_élément(*ctx.boites_absolues.boites)
    boite_absolue.noeud = noeud
    boite_absolue.containing_block = containing_block.noeud
    boite_absolue.pos_x_statique = pos_x_statique
    boite_absolue.pos_y_statique = pos_y_statique
}

dispose_les_boites_absolues :: fonc (ctx: *ContexteDeFormattage, containing_block: *NoeudDeDisposition)
{
    boites_à_disposer: [..]BoiteAbsolue
    diffère déloge(boites_à_disposer)

    pour ctx.boites_absolues.boites {
        si it.containing_block != containing_block {
            continue
        }

        tableau_ajoute(*boites_à_disposer, it)

        si index_it < ctx.boites_absolues.boites.taille - 1 {
            ctx.boites_absolues.boites[index_it] = ctx.boites_absolues.boites[ctx.boites_absolues.boites.taille - 1]
            ctx.boites_absolues.boites.taille -= 1
            reprends it
        }
    }

    pour * boites_à_disposer {
        dispose_boite_absolute(ctx, it)
    }
}

/* À FAIRE : https://drafts.csswg.org/css-position/#abspos-layout */
dispose_boite_absolute :: fonc (empl ctx: *ContexteDeFormattage, boite: *BoiteAbsolue)
{
    noeud := boite.noeud

    containing_block := donne_containing_block(noeud, ctx)
    assert(containing_block.noeud == boite.containing_block)

    args := crée_arguments_dimensionnement_largeur(ctx, noeud, containing_block, nul, ModeDeFormattage.Normal)
    args.pos_x_statique = boite.pos_x_statique
    args.pos_y_statique = boite.pos_y_statique
    calcule_largeur_et_marges(*args)
    état_calcul_hauteur := calcule_hauteur_et_marges(*args)

    si état_calcul_hauteur != ÉtatCalculHauteur.HauteurDépendSurContenu {
        position_boite_absolue(noeud, containing_block, faux)
    }

    formatte_intérieur(noeud, ctx, ModeDeFormattage.Normal)

    si état_calcul_hauteur == ÉtatCalculHauteur.HauteurDépendSurContenu {
        args.calcul_hauteur_après_contenu = vrai
        _ := calcule_hauteur_et_marges(*args)

        position_boite_absolue(noeud, containing_block, vrai)
    }

    ctx.dispose_les_boites_absolues(noeud)
}

position_boite_absolue :: fonc (noeud: *NoeudDeDisposition, containing_block: &ContainingBlock, décale: bool)
{
    bord_gauche := containing_block.rect.x
    bord_haut := containing_block.rect.y

    top := noeud.propriétés.donne_valeur_utilisée(IDPropriété.Top)
    left := noeud.propriétés.donne_valeur_utilisée(IDPropriété.Left)

    x := bord_gauche + left.pixels comme r32
    y := bord_haut + top.pixels comme r32

    si décale {
        noeud.décale_vers_position(x, y)
    }
    sinon {
        noeud.définis_position(x, y)
    }
}

ajoute_boite_flottante_gauche :: fonc (empl ctx: *ContexteDeFormattageBloc, noeud: *NoeudDeDisposition, mode: ModeDeFormattage)
{
    containing_block := donne_containing_block(noeud, ctx)
    largeur_disponible := containing_block.donne_largeur()

    bord_gauche := containing_block.rect.x
    bord_droit := bord_gauche + largeur_disponible

    boite := crée_boite_flottante(noeud)

    ligne := donne_dernière_ligne(*ctx.lignes_boites_flottantes_gauche, containing_block, vrai)

    boucle {
        boite.position_x = ligne.donne_position_la_plus_à_gauche() comme r32
        boite.position_y = max(ligne.rect.y comme r32, boite.position_y)

        si mode == ModeDeFormattage.BrisureDeLigneExplicite || (boite.position_x + boite.largeur <= bord_droit || boite.position_x <= bord_gauche) {
            arrête
        }

        ligne = ajoute_une_ligne(*ctx.lignes_boites_flottantes_gauche, containing_block, vrai)
    }

    si mode != ModeDeFormattage.BrisureDeLigneExplicite && instersecte_hors_touche(boite.donne_rectangle(), ctx.rect_boites_flottantes_droites) {
        pour ligne_droite dans ctx.lignes_boites_flottantes_droite.lignes {
            saufsi instersecte_hors_touche(boite.donne_rectangle(), ligne_droite.rect) {
                continue
            }

            pour boite_droite dans ligne_droite.boites {
                saufsi instersecte_hors_touche(boite.donne_rectangle(), boite_droite.donne_rectangle()) {
                    continue
                }

                si ligne.boites.taille != 0 {
                    ligne = ajoute_une_ligne(*ctx.lignes_boites_flottantes_gauche, containing_block, vrai)
                }

                boite.position_y = max(boite_droite.position_y + boite_droite.hauteur, ligne.rect.y comme r32)
                boite.position_x = ligne.donne_position_la_plus_à_gauche() comme r32
            }
        }
    }

    ligne.ajoute_boite(boite)

    si ctx.lignes_boites_flottantes_gauche.lignes.taille == 1 && ligne.boites.taille == 1 {
        ctx.rect_boites_flottantes_gauches = boite.donne_rectangle()
    }
    sinon {
        ctx.rect_boites_flottantes_gauches = donne_union(ctx.rect_boites_flottantes_gauches, boite.donne_rectangle())
    }

    noeud.décale_vers_position(boite.position_x, boite.position_y)
}

ajoute_boite_flottante_droite :: fonc (empl ctx: *ContexteDeFormattageBloc, noeud: *NoeudDeDisposition, mode: ModeDeFormattage)
{
    containing_block := donne_containing_block(noeud, ctx)
    largeur_disponible := containing_block.donne_largeur()

    bord_gauche := containing_block.rect.x
    bord_droit := bord_gauche + largeur_disponible

    boite := crée_boite_flottante(noeud)

    ligne := donne_dernière_ligne(*ctx.lignes_boites_flottantes_droite, containing_block, faux)

    boucle {
        boite.position_x = ligne.donne_position_la_plus_à_droite() comme r32 - boite.largeur
        boite.position_y = max(ligne.rect.y comme r32, boite.position_y)

        si mode == ModeDeFormattage.BrisureDeLigneExplicite || boite.position_x >= bord_gauche || boite.position_x + boite.largeur >= bord_droit {
            arrête
        }

        ligne = ajoute_une_ligne(*ctx.lignes_boites_flottantes_droite, containing_block, faux)
    }

    si mode != ModeDeFormattage.BrisureDeLigneExplicite && instersecte_hors_touche(boite.donne_rectangle(), ctx.rect_boites_flottantes_gauches) {
        pour ligne_gauche dans ctx.lignes_boites_flottantes_gauche.lignes {
            saufsi instersecte_hors_touche(boite.donne_rectangle(), ligne_gauche.rect) {
                continue
            }

            pour boite_gauche dans ligne_gauche.boites {
                saufsi instersecte_hors_touche(boite.donne_rectangle(), boite_gauche.donne_rectangle()) {
                    continue
                }

                si ligne.boites.taille != 0 {
                    ligne = ajoute_une_ligne(*ctx.lignes_boites_flottantes_droite, containing_block, faux)
                }

                boite.position_y = max(boite_gauche.position_y + boite_gauche.hauteur, ligne.rect.y comme r32)
                boite.position_x = ligne.donne_position_la_plus_à_droite() comme r32 - boite.largeur
            }
        }
    }

    ligne.ajoute_boite(boite)

    si ctx.lignes_boites_flottantes_droite.lignes.taille == 1 && ligne.boites.taille == 1 {
        ctx.rect_boites_flottantes_droites = boite.donne_rectangle()
    }
    sinon {
        ctx.rect_boites_flottantes_droites = donne_union(ctx.rect_boites_flottantes_droites, boite.donne_rectangle())
    }

    noeud.décale_vers_position(boite.position_x, boite.position_y)
}

/* Retourne faux si les rectangles ne font que se toucher. */
instersecte_hors_touche :: fonc (rect1: RectanglePosDim(r64), rect2: RectanglePosDim(r64)) -> bool
{
    saufsi intersecte(rect1, rect2) {
        retourne faux
    }

    si abs(rect1.y + rect1.hauteur - rect2.y) <= 0.00001 {
        retourne faux
    }

    si abs(rect2.y + rect2.hauteur - rect1.y) <= 0.00001 {
        retourne faux
    }

    si abs(rect1.x + rect1.largeur - rect2.x) <= 0.00001 {
        retourne faux
    }

    si abs(rect2.x + rect2.largeur - rect1.x) <= 0.00001 {
        retourne faux
    }

    retourne vrai
}

donne_décalage_floats_gauche :: fonc (empl ctx: *ContexteDeFormattageBloc) -> r32
{
    retourne (ctx.rect_boites_flottantes_gauches.y + ctx.rect_boites_flottantes_gauches.hauteur) comme r32
}

donne_décalage_floats_droite :: fonc (empl ctx: *ContexteDeFormattageBloc) -> r32
{
    retourne (ctx.rect_boites_flottantes_droites.y + ctx.rect_boites_flottantes_droites.hauteur) comme r32
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ContexteDeFormattage
 * \{ */

ContexteDeFormattageInline :: struct {
    empl base: ContexteDeFormattage
    type = #type_de_cette_structure
    sur_formatte = contexte_formattage_inline_sur_formatte

    racine: *NoeudDeDispositionBloc
}

donne_position_et_largeur_ligne :: fonc (ctx: *ContexteDeFormattageInline, x_min: r32, x_max: r32, position_y: r32) -> (position: r32, largeur: r32)
{
    si ctx.parent && ctx.parent.type == ContexteDeFormattageBloc {
        ctx_bloc := ctx.parent comme *ContexteDeFormattageBloc

        pour ligne dans ctx_bloc.lignes_boites_flottantes_gauche.lignes {
            pour ligne.boites {
                si contient(it.donne_rectangle(), x_min, position_y) {
                    x_min += it.largeur
                }
            }
        }

        pour ligne dans ctx_bloc.lignes_boites_flottantes_droite.lignes {
            pour ligne.boites {
                si contient(it.donne_rectangle(), x_max, position_y) {
                    x_max -= it.largeur
                }
            }
        }
    }

    position = x_min
    largeur = x_max - x_min

    si largeur < 0.0 {
        largeur = 0.0
    }

    retourne position, largeur
}

AlignementTexte :: énum {
    Gauche
    Droite
    Centre
    Justifié
}

donne_alignement_texte :: fonc (noeud: *NoeudDeDispositionBloc) -> AlignementTexte
{
    text_align := noeud.propriétés.donne_valeur_utilisée(IDPropriété.TextAlign)

    si text_align.est_mot_clé(PROP_start) {
        retourne AlignementTexte.Gauche
    }

    si text_align.est_mot_clé(PROP_end) {
        retourne AlignementTexte.Droite
    }

    si text_align.est_mot_clé(PROP_left) {
        retourne AlignementTexte.Gauche
    }

    si text_align.est_mot_clé(PROP_right) {
        retourne AlignementTexte.Droite
    }

    si text_align.est_mot_clé(PROP_center) {
        retourne AlignementTexte.Centre
    }

    si text_align.est_mot_clé(PROP_justify) {
        retourne AlignementTexte.Justifié
    }

    retourne AlignementTexte.Gauche
}

contexte_formattage_inline_sur_formatte :: fonc (base: *ContexteDeFormattage, noeud: *NoeudDeDispositionBloc, mode: ModeDeFormattage)
{
    ctx := base comme *ContexteDeFormattageInline

    si ctx.parent && ctx.parent.type == ContexteDeFormattageBloc {
        ctx_bloc := ctx.parent comme *ContexteDeFormattageBloc
        ctx_bloc.ajoute_marge(noeud, IDPropriété.MarginTop)
    }

    line_height := donne_line_height(noeud, ctx)

    enligneuse: Enligneuse
    enligneuse.ctx = ctx
    divise_en_lignes(*enligneuse, noeud, mode)

    alignement := donne_alignement_texte(noeud)
    si ctx.doit_aligner_les_descendants.possède_valeur() {
        alignement = ctx.doit_aligner_les_descendants.Quelque
    }

    lignes_tenante := noeud.lignes_tenante

    pour * lignes_tenante.lignes {
        fragments := donne_fragments_ligne(lignes_tenante, it)

        si fragments.taille == 0 {
            continue
        }

        si it.hauteur_contenu != 0.0 && it.hauteur_contenu < line_height {
            it.hauteur_contenu = line_height
        }

        largeur_disponible := it.largeur_max

        décalage_pour_alignement := 0.0
        si alignement == AlignementTexte.Droite {
            décalage_pour_alignement = largeur_disponible - it.largeur_courante
        }
        sinon si alignement == AlignementTexte.Centre {
            décalage_pour_alignement = (largeur_disponible - it.largeur_courante) / 2.0
        }
        sinon si alignement == AlignementTexte.Justifié {
            /* À FAIRE : ignore l'espace finale. */
            décalage_pour_alignement = (largeur_disponible - it.largeur_courante) / ((fragments.taille - 1) comme r32)
        }

        pour * fragment, index_fragment dans fragments {
            décalage_fragment_x := 0.0
            si alignement == AlignementTexte.Justifié {
                si index_fragment != 0 && index_it != (lignes_tenante.lignes.taille - 1) {
                    décalage_fragment_x += décalage_pour_alignement * (index_fragment comme r32)
                }
            }
            sinon {
                décalage_fragment_x += décalage_pour_alignement
            }

            fragment.x += décalage_fragment_x

            si fragment.type == Fragment.Type.InlineBlock || fragment.type == Fragment.Type.NouvelleLigne || fragment.type == Fragment.Type.MargeDébut {
                fragment.noeud.décale_vers_position(fragment.x, fragment.y)
            }
        }
    }

    discr mode {
        BrisureDeLigneExplicite,
        ToutesLesBrisuresDeLigne {
            largeur_max_enfant : r64 = 0.0
            pour lignes_tenante.lignes {
                largeur_max_enfant = max(largeur_max_enfant, it.largeur_courante comme r64)
            }

            largeur := noeud.propriétés.donne_valeur_calculée(IDPropriété.Width)
            si largeur.est_auto() {
                valeur_largeur_enfant := crée_outrepas_pour_coter_contenu(largeur_max_enfant)
                /* Utilise cette fontcion pour résoudre les valeurs 'auto' pour les autres propriétés. */
                args := ArgumentsDimensionnement(ctx, noeud, width_of_containing_block = 0.0, outrepas_largeur = valeur_largeur_enfant)
                calcule_largeur_et_marges(*args, calcule_largeur_et_marges_inline_non_replaced_element)
            }
        }
        sinon {}
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Flexbox
 * https://www.w3.org/TR/css-flexbox-1/
 * \{ */

est_espace_blanche_document :: fonc (base: *NoeudDeDisposition) -> bool
{
    si base.table_virtuelle.type == NoeudDeDispositionTexte {
        noeud := base comme *NoeudDeDispositionTexte
        retourne est_vide_ou_uniquement_espaces_blanches(noeud.noeud_texte.données)
    }

    si base.table_virtuelle.type == NoeudDeDispositionBloc || base.table_virtuelle.type == NoeudDeDispositionInline {
        noeud := base comme *NoeudDeDispositionBloc

        si noeud.élément != nul {
            /* Nous voulons un noeud anonyme. */
            retourne faux
        }

        /* Généralement, nous n'avons qu'un seul enfant. Mais s'il y a des commentaires, nous aurons plusieurs enfants.
         * Ainsi, nous devons vérifier tous les enfants. */
        pour noeud.enfants {
            saufsi est_espace_blanche_document(noeud.enfants[0]) {
                retourne faux
            }
        }

        retourne vrai
    }

    retourne faux
}

ItemFlex :: struct {
    noeud: *NoeudDeDisposition

    frozen: bool
    flex_base_size: r32
    hypothetical_main_size: r32
    used_main_size: r32
    target_main_size: r32
    scaled_flex_shrink_factor: r32
    violation: r32
}

donne_inner_flex_base_size :: fonc (item: *ItemFlex) -> r32
{
    // À FAIRE : inner_flex_base_size
    retourne item.flex_base_size
}

LigneFlex :: struct {
    items: []ItemFlex
    largeur: r32
}

toutes_les_items_sont_gelés :: fonc (ligne: *LigneFlex) -> bool
{
    pour ligne.items {
        saufsi it.frozen {
            retourne faux
        }
    }
    retourne vrai
}

ContexteDeFormattageFlex :: struct {
    empl base: ContexteDeFormattage
    type = #type_de_cette_structure
    sur_formatte = contexte_formattage_flex_sur_formatte

    contenant: *NoeudDeDisposition

    items: [..]ItemFlex
    lignes: [..]LigneFlex
}

donne_outer_main_size :: fonc (ctx: *ContexteDeFormattageFlex) -> r32
{
    retourne ctx.contenant.modèle_de_boite.marge.largeur
}

donne_inner_main_size :: fonc (ctx: *ContexteDeFormattageFlex) -> r32
{
    retourne ctx.contenant.modèle_de_boite.contenu.largeur
}

contexte_formattage_flex_sur_formatte :: fonc (base: *ContexteDeFormattage, noeud: *NoeudDeDispositionBloc, mode: ModeDeFormattage)
{
    ctx := base comme *ContexteDeFormattageFlex
    ctx.contenant = noeud

    diffère {
        déloge(ctx.items)
        déloge(ctx.lignes)
    }

    construit_liste_items(ctx, noeud, mode)
    calcule_taille_items(ctx, noeud, mode)
    // determine_the_flex_base_size_and_hypothetical_main_size_of_each_item(ctx, mode)

    direction := noeud.propriétés.donne_valeur_calculée(IDPropriété.FlexDirection).mot_clé

    si direction == PROP_row || direction == PROP_row_reverse {
        formatte_flex_row(ctx, noeud, mode, direction == PROP_row_reverse)
    }
    sinon {
        assert(direction == PROP_column || direction == PROP_column_reverse)
        formatte_flex_column(ctx, noeud, mode, direction == PROP_column_reverse)
    }
}

construit_liste_items :: fonc (ctx: *ContexteDeFormattageFlex, noeud: *NoeudDeDispositionBloc, mode: ModeDeFormattage)
{
    pour noeud.enfants {
        si est_espace_blanche_document(it) {
            it.traite_comme_display_none = vrai
            continue
        }

        /* À FAIRE : les boites fixed doivent être disposé autrement. */
        position := it.propriétés.donne_valeur_utilisée(IDPropriété.Position)
        si position.est_mot_clé(PROP_absolute) || position.est_mot_clé(PROP_fixed) {
            ctx.dispose_boite_absolute(it comme *NoeudDeDispositionBloc, noeud.modèle_de_boite.contenu.x, noeud.modèle_de_boite.contenu.y, mode)
            continue
        }

        tableau_ajoute(*ctx.items, ItemFlex(it))
    }
}

calcule_taille_items :: fonc (ctx: *ContexteDeFormattageFlex, noeud: *NoeudDeDispositionBloc, mode: ModeDeFormattage)
{
    largeur_disponible := noeud.modèle_de_boite.contenu.largeur

    pour * item dans ctx.items {
        it := item.noeud
        flex_basis := résoud_flex_basis(it)

        largeur_désirée: OutrepasCotation
        si flex_basis.est_mot_clé(PROP_content) {
            /* calcule_shrink_to_fit_width ne résoud pas les pourcentages... */
            it.mesure(ctx, mode, nul)
            largeur := calcule_shrink_to_fit_width(ctx, it, largeur_disponible)
            largeur_désirée = crée_outrepas_pour_coter_contenu(largeur)
        }
        sinon si flex_basis.est_percentage() || flex_basis.est_calc() {
            définis_propriétés(ctx.ctx_calcul_style, noeud.propriétés)
            largeur := calcule_pourcentage(ctx.ctx_calcul_style, flex_basis, largeur_disponible).pixels
            largeur_désirée = crée_outrepas_pour_coter_boite(largeur)
        }
        sinon {
            largeur_désirée = crée_outrepas_pour_coter_boite(flex_basis.pixels)
        }

        it.mesure(ctx, mode, *largeur_désirée)
        item.hypothetical_main_size = it.modèle_de_boite.marge.largeur
    }
}

/* https://www.w3.org/TR/css-flexbox-1/#algo-main-item */
determine_the_flex_base_size_and_hypothetical_main_size_of_each_item :: fonc (ctx: *ContexteDeFormattageFlex, mode: ModeDeFormattage)
{
    largeur_disponible := ctx.donne_inner_main_size()

    pour * ctx.items {
        flex_basis := résoud_flex_basis(it.noeud)
        imprime("item[%].flex_basis : %\n", index_it, flex_basis)

        // A. If the item has a definite used flex basis, that’s the flex base size. 
        si flex_basis.est_percentage() || flex_basis.est_calc() {
            définis_propriétés(ctx.ctx_calcul_style, it.noeud.propriétés)
            largeur := calcule_pourcentage(ctx.ctx_calcul_style, flex_basis, largeur_disponible).pixels
            it.flex_base_size = largeur comme r32
            continue
        }

        si flex_basis.est_pixels() {
            it.flex_base_size = flex_basis.pixels comme r32
            continue
        }

        assert(flex_basis.est_mot_clé(PROP_content))

        // À FAIRE : B. If the flex item has ...
        //     an intrinsic aspect ratio,
        //     a used flex basis of content, and
        //     a definite cross size, 
        // then the flex base size is calculated from its inner cross size and the flex item’s intrinsic aspect ratio.

        // C. If the used flex basis is content or depends on its available space, and the flex container is being
        //    sized under a min-content or max-content constraint (e.g. when performing automatic table layout [CSS21]),
        //    size the item under that constraint. The flex base size is the item’s resulting main size.
        si mode != ModeDeFormattage.Normal {
            it.noeud.mesure(ctx, mode, nul)
            it.flex_base_size = it.noeud.modèle_de_boite.marge.largeur
            continue
        }

        // À FAIRE : D. Otherwise, if the used flex basis is content or depends on its available space, the available main size
        //    is infinite, and the flex item’s inline axis is parallel to the main axis, lay the item out using the
        //    rules for a box in an orthogonal flow [CSS3-WRITING-MODES].
        //    The flex base size is the item’s max-content main size.

        // E. Otherwise, size the item into the available space using its used flex basis in place of its main size,
        //    treating a value of content as max-content. If a cross size is needed to determine the main size (e.g.
        //    when the flex item’s main size is in its block axis) and the flex item’s cross size is auto and not
        //    definite, in this calculation use fit-content as the flex item’s cross size. The flex base size is the
        //    item’s resulting main size.
        it.noeud.mesure(ctx, ModeDeFormattage.BrisureDeLigneExplicite, nul)
        it.flex_base_size = it.noeud.modèle_de_boite.marge.largeur
    }

    // À FAIRE : When determining the flex base size, the item’s min and max main sizes are ignored (no clamping occurs).
    // Furthermore, the sizing calculations that floor the content box size at zero when applying box-sizing are
    // also ignored. (For example, an item with a specified size of zero, positive padding, and box-sizing:
    // border-box will have an outer flex base size of zero—and hence a negative inner flex base size.)

    // À FAIRE : The hypothetical main size is the item’s flex base size clamped according to its used min and max main
    // sizes (and flooring the content box size at zero).
    pour * ctx.items {
        it.hypothetical_main_size = it.flex_base_size
        min_width := it.noeud.propriétés.donne_valeur_utilisée(IDPropriété.MinWidth)
        si min_width.est_pixels() && it.hypothetical_main_size < min_width.pixels {
            it.hypothetical_main_size = min_width.pixels comme r32
        }

        max_width := it.noeud.propriétés.donne_valeur_utilisée(IDPropriété.MaxWidth)
        si max_width.est_pixels() && it.hypothetical_main_size > max_width.pixels {
            it.hypothetical_main_size = max_width.pixels comme r32
        }
        imprime("item[%].flex_base_size : %, .hypothetical_main_size : %\n", index_it, it.flex_base_size, it.hypothetical_main_size)
    }
}

/* https://www.w3.org/TR/css-flexbox-1/#valdef-flex-flex-basis */
résoud_flex_basis :: fonc (noeud: *NoeudDeDisposition) -> ValeurDeStyle
{
    flex_basis := noeud.propriétés.donne_valeur_utilisée(IDPropriété.FlexBasis)

    si flex_basis.est_mot_clé(PROP_auto) {
        width := noeud.propriétés.donne_valeur_calculée(IDPropriété.Width)

        si width.est_auto() {
            retourne ValeurDeStyle(mot_clé = PROP_content)
        }

        retourne width
    }

    retourne flex_basis
}

/* https://www.w3.org/TR/css-flexbox-1/#algo-line-break */
collect_flex_items_into_flex_lines :: fonc (ctx: *ContexteDeFormattageFlex)
{
    largeur_disponible := ctx.donne_inner_main_size()

    ligne_courante := tableau_ajoute_élément(*ctx.lignes)
    ligne_courante.items.pointeur = ctx.items.pointeur

    flex_wrap := ctx.contenant.propriétés.donne_valeur_utilisée(IDPropriété.FlexWrap).mot_clé

    pour * ctx.items {
        largeur := it.hypothetical_main_size

        si flex_wrap == PROP_wrap && (ligne_courante.largeur + largeur) > largeur_disponible {
            ligne_courante = tableau_ajoute_élément(*ctx.lignes)
            ligne_courante.items.pointeur = ctx.items.pointeur + index_it
        }

        ligne_courante.largeur += largeur
        ligne_courante.items.taille += 1
    }
}

/* https://www.w3.org/TR/css-flexbox-1/#resolve-flexible-lengths */
resolve_flexible_lengths :: fonc (ctx: *ContexteDeFormattageFlex)
{
    pour * ctx.lignes {
        resolve_flexible_lengths(ctx, it)
    }
}

resolve_flexible_lengths :: fonc (ctx: *ContexteDeFormattageFlex, ligne: *LigneFlex)
{
    // 1. Determine the used flex factor. Sum the outer hypothetical main sizes of all
    //    items on the line. If the sum is less than the flex container’s inner main size,
    //    use the flex grow factor for the rest of this algorithm; otherwise, use the
    //    flex shrink factor.
    somme_items_sizes := 0.0
    pour ligne.items {
        somme_items_sizes += it.hypothetical_main_size
    }

    used_flex_factor := si somme_items_sizes < ctx.donne_inner_main_size() {
        IDPropriété.FlexGrow
    }
    sinon {
        IDPropriété.FlexShrink
    }

    // 2. Size inflexible items. Freeze, setting its target main size to its hypothetical main size…
    pour * ligne.items {
        doit_geler := faux

        // any item that has a flex factor of zero
        flex_factor := it.noeud.propriétés.donne_valeur_utilisée(used_flex_factor)
        si flex_factor.number == 0.0 {
            doit_geler = vrai
        }
        // if using the flex grow factor: any item that has a flex base size greater than its hypothetical main size
        sinon si used_flex_factor == IDPropriété.FlexGrow {
            doit_geler = it.flex_base_size > it.hypothetical_main_size
        }
        // if using the flex shrink factor: any item that has a flex base size smaller than its hypothetical main size
        sinon {
            doit_geler = it.flex_base_size < it.hypothetical_main_size
        }

        si doit_geler {
            it.frozen = vrai
            it.target_main_size = it.hypothetical_main_size
        }
    }

    // 3. Calculate initial free space. Sum the outer sizes of all items on the line, and subtract this
    //    from the flex container’s inner main size. For frozen items, use their outer target main size;
    //    for other items, use their outer flex base size.
    initial_free_space := calcule_espace_libre_items_gelés(ctx, ligne)
    imprime("initial free space : %\n", initial_free_space)

    // 4. Loop:
    boucle {
        // a. Check for flexible items. If all the flex items on the line are frozen, free space has been
        //    distributed; exit this loop. 
        si ligne.toutes_les_items_sont_gelés() {
            arrête
        }

        // b. Calculate the remaining free space as for initial free space, above.
        //    If the sum of the unfrozen flex items’ flex factors is less than one, multiply the initial
        //    free space by this sum. If the magnitude of this value is less than the magnitude of the
        //    remaining free space, use this as the remaining free space.
        remaining_free_space := calcule_espace_libre_items_gelés(ctx, ligne)
        somme_flex_factors := 0.0
        pour * ligne.items {
            si it.frozen {
                continue
            }
            somme_flex_factors += it.noeud.propriétés.donne_valeur_utilisée(used_flex_factor).number comme r32
        }

        si somme_flex_factors < 1.0 {
            initial_free_space_pondéré := initial_free_space * somme_flex_factors
            si initial_free_space_pondéré < remaining_free_space {
                remaining_free_space = initial_free_space_pondéré
            }
        }

        imprime("somme_flex_factors : %, remaining_free_space : %\n", somme_flex_factors, remaining_free_space)

        // c: Distribute free space proportional to the flex factors.
        // If the remaining free space is zero
        si remaining_free_space == 0.0 {
            // Do nothing. 
        }
        // If using the flex grow factor
        sinon si used_flex_factor == IDPropriété.FlexGrow {
            // Find the ratio of the item’s flex grow factor to the sum of the flex grow factors of all unfrozen
            // items on the line. Set the item’s target main size to its flex base size plus a fraction of the
            // remaining free space proportional to the ratio.
            pour * ligne.items {
                flex_factor := it.noeud.propriétés.donne_valeur_utilisée(used_flex_factor).number comme r32
                ratio := flex_factor / somme_flex_factors
                it.target_main_size = it.flex_base_size + remaining_free_space * ratio
            }
        }
        // If using the flex shrink factor
        sinon si used_flex_factor == IDPropriété.FlexShrink {
            // For every unfrozen item on the line, multiply its flex shrink factor by its inner flex base size,
            // and note this as its scaled flex shrink factor. Find the ratio of the item’s scaled flex shrink
            // factor to the sum of the scaled flex shrink factors of all unfrozen items on the line.
            // Set the item’s target main size to its flex base size minus a fraction of the absolute value of
            // the remaining free space proportional to the ratio. Note this may result in a negative inner main
            // size; it will be corrected in the next step.
            somme_scaled_flex_shrink_factors := 0.0
            pour * ligne.items {
                si it.frozen {
                    continue
                }

                flex_factor := it.noeud.propriétés.donne_valeur_utilisée(used_flex_factor).number comme r32
                it.scaled_flex_shrink_factor = it.donne_inner_flex_base_size() * flex_factor
                somme_scaled_flex_shrink_factors += it.scaled_flex_shrink_factor
            }

            pour * ligne.items {
                si it.frozen {
                    continue
                }

                ratio := it.scaled_flex_shrink_factor / somme_scaled_flex_shrink_factors
                it.target_main_size = it.flex_base_size - abs(remaining_free_space * ratio)
            }
        }
        // Otherwise
        sinon {
            // Do nothing.
        }

        // d. Fix min/max violations. Clamp each non-frozen item’s target main size by its used min and max main
        //    sizes and floor its content-box size at zero. If the item’s target main size was made smaller by this,
        //    it’s a max violation. If the item’s target main size was made larger by this, it’s a min violation.
        violations := 0.0
        pour * ligne.items {
            si it.frozen {
                continue
            }

            target_main_size := it.target_main_size

            min_width := it.noeud.propriétés.donne_valeur_utilisée(IDPropriété.MinWidth)
            si min_width.est_pixels() && target_main_size < min_width.pixels {
                target_main_size = min_width.pixels comme r32
            }

            max_width := it.noeud.propriétés.donne_valeur_utilisée(IDPropriété.MaxWidth)
            si max_width.est_pixels() && target_main_size > max_width.pixels {
                target_main_size = max_width.pixels comme r32
            }

            it.violation = target_main_size - it.target_main_size
            it.target_main_size = target_main_size
            imprime("violation : %\n", it.violation)
        }

        // e.  Freeze over-flexed items. The total violation is the sum of the adjustments from the previous step
        //     ∑(clamped size - unclamped size). If the total violation is:
        si violations == 0.0 {
            // Freeze all items.
            pour * ligne.items {
                it.frozen = vrai
            }
        }
        sinon si violations > 0.0 {
            // Freeze all the items with min violations. 
            pour * ligne.items {
                si it.violation > 0.0 {
                    it.frozen = vrai
                }
            }
        }
        sinon {
            // Freeze all the items with max violations.
            pour * ligne.items {
                si it.violation < 0.0 {
                    it.frozen = vrai
                }
            }
        }

        // f. Return to the start of this loop. 
    }

    pour * ligne.items {
        it.used_main_size = it.target_main_size
        imprime("item[%].used_main_size = %\n", index_it, it.used_main_size)
    }
}

calcule_espace_libre_items_gelés :: fonc (ctx: *ContexteDeFormattageFlex, ligne: *LigneFlex) -> r32
{
    outer_sizes := 0.0
    pour * ligne.items {
        si it.frozen {
            outer_sizes += it.target_main_size
        }
        sinon {
            outer_sizes += it.flex_base_size
        }
    }

    retourne ctx.donne_inner_main_size() - outer_sizes
}

formatte_flex_row :: fonc (ctx: *ContexteDeFormattageFlex, noeud: *NoeudDeDispositionBloc, mode: ModeDeFormattage, reverse: bool)
{
    largeur_disponible := noeud.modèle_de_boite.contenu.largeur

    /* Crée des lignes. */
    collect_flex_items_into_flex_lines(ctx)
    // resolve_flexible_lengths(ctx)

    /* Dispose les noeuds. */
    décalage_x := noeud.modèle_de_boite.contenu.x
    décalage_y := noeud.modèle_de_boite.contenu.y

    si reverse {
        décalage_x += noeud.modèle_de_boite.contenu.largeur
    }

    décalage_x_original := décalage_x

    hauteur_contenu := 0.0

    pour * ligne dans ctx.lignes {
        justify_content := noeud.propriétés.donne_valeur_utilisée(IDPropriété.JustifyContent).mot_clé
        espace_disponible := largeur_disponible - ligne.largeur

        distribue_espace_disponible(ctx, ligne, espace_disponible, mode)

        espace_disponible = largeur_disponible - ligne.largeur

        décalage_pre := 0.0
        décalage_post := 0.0

        si justify_content == PROP_center {
            décalage_x += espace_disponible * 0.5
        }
        sinon si justify_content == PROP_flex_end {
            décalage_x += espace_disponible
        }
        sinon si justify_content == PROP_space_between {
            décalage_post = espace_disponible / (ligne.items.taille - 1) comme r32
        }
        sinon si justify_content == PROP_space_around {
            espace_par_bloc := espace_disponible / (ligne.items.taille) comme r32
            décalage_pre = espace_par_bloc * 0.5
            décalage_post = décalage_pre
        }

        hauteur_ligne := 0.0
        pour item dans ligne.items {
            it := item.noeud
            si reverse {
                décalage_x -= décalage_pre + it.modèle_de_boite.marge.largeur
            }
            sinon {
                décalage_x += décalage_pre
            }

            it.décale_vers_position(décalage_x, décalage_y)

            si reverse {
                décalage_x -= décalage_post
            }
            sinon {
                décalage_x += it.modèle_de_boite.marge.largeur + décalage_post
            }
            hauteur_ligne = max(hauteur_ligne, it.modèle_de_boite.marge.hauteur)
        }

        décalage_y += hauteur_ligne
        hauteur_contenu += hauteur_ligne
        décalage_x = décalage_x_original
    }

    /* Ajourne les propriétés du noeud. */
    prop_largeur := noeud.propriétés.donne_valeur_calculée(IDPropriété.Width)
    si prop_largeur.est_auto() {
        largeur_des_enfants := 0.0
        pour item dans ctx.items {
            largeur_des_enfants += item.noeud.modèle_de_boite.marge.largeur
        }
        noeud.propriétés.définis_valeur_utilisée(IDPropriété.Width, ValeurDeStyle(pixels = largeur_des_enfants))
    }

    hauteur_finale := crée_outrepas_pour_coter_contenu(hauteur_contenu)
    containing_block := donne_containing_block(noeud, ctx)
    args := crée_arguments_dimensionnement_hauteur(ctx, noeud, containing_block, *hauteur_finale)
    _ := calcule_hauteur_et_marges(*args)

    discr mode {
        BrisureDeLigneExplicite,
        ToutesLesBrisuresDeLigne {
            noeud.ajourne_boite_pour_calcul_largeur()
        }
        sinon {}
    }
}

formatte_flex_column :: fonc (ctx: *ContexteDeFormattageFlex, noeud: *NoeudDeDispositionBloc, mode: ModeDeFormattage, reverse: bool)
{
    largeur_des_enfants := 0.0
    hauteur_des_enfants := 0.0

    /* Calcule la taille des noeuds. */
    pour item dans ctx.items {
        it := item.noeud
        largeur_des_enfants += it.modèle_de_boite.marge.largeur
        hauteur_des_enfants += it.modèle_de_boite.marge.hauteur
    }

    /* Dispose les noeuds. */
    décalage_x := noeud.modèle_de_boite.contenu.x
    décalage_y := noeud.modèle_de_boite.contenu.y

    si reverse {
        décalage_y += noeud.modèle_de_boite.contenu.hauteur
    }

    pour item dans ctx.items {
        it := item.noeud
        si reverse {
            décalage_y -= it.modèle_de_boite.marge.hauteur
        }

        it.décale_vers_position(décalage_x, décalage_y)

        largeur_des_enfants += it.modèle_de_boite.marge.largeur

        saufsi reverse {
            décalage_y += it.modèle_de_boite.marge.hauteur
        }
    }

    /* Ajourne les propriétés du noeud. */
    prop_largeur := noeud.propriétés.donne_valeur_calculée(IDPropriété.Width)
    si prop_largeur.est_auto() {
        noeud.propriétés.définis_valeur_utilisée(IDPropriété.Width, ValeurDeStyle(pixels = largeur_des_enfants))
    }

    hauteur_finale := crée_outrepas_pour_coter_contenu(hauteur_des_enfants)
    containing_block := donne_containing_block(noeud, ctx)
    args := crée_arguments_dimensionnement_hauteur(ctx, noeud, containing_block, *hauteur_finale)
    _ := calcule_hauteur_et_marges(*args)

    discr mode {
        BrisureDeLigneExplicite,
        ToutesLesBrisuresDeLigne {
            noeud.ajourne_boite_pour_calcul_largeur()
        }
        sinon {}
    }
}

/* Modifie la taille des items selon leurs facteurs de croissance. */
distribue_espace_disponible :: fonc (ctx: *ContexteDeFormattageFlex, ligne: *LigneFlex, espace_disponible: r64, mode: ModeDeFormattage)
{
    si espace_disponible == 0.0 {
        retourne
    }

    utilise_flex_shrink := espace_disponible < 0.0

    somme_flex_grow: r64
    somme_flex_shrink: r64
    pour item dans ligne.items {
        it := item.noeud
        flex_grow := it.propriétés.donne_valeur_utilisée(IDPropriété.FlexGrow)
        flex_shrink := it.propriétés.donne_valeur_utilisée(IDPropriété.FlexShrink)
        somme_flex_grow += flex_grow.number
        somme_flex_shrink += flex_shrink.number
    }

    si utilise_flex_shrink && somme_flex_shrink == 0.0 {
        retourne
    }

    si !utilise_flex_shrink && somme_flex_grow == 0.0 {
        retourne
    }

    pour item dans ligne.items {
        it := item.noeud
        flex_grow := it.propriétés.donne_valeur_utilisée(IDPropriété.FlexGrow)
        flex_shrink := it.propriétés.donne_valeur_utilisée(IDPropriété.FlexShrink)

        si utilise_flex_shrink && flex_shrink.number == 0.0 {
            continue
        }

        si !utilise_flex_shrink && flex_grow.number == 0.0 {
            continue
        }

        /* Nous utilisons la largeur du contenu ici car c'est le contenu qui doit
         * changer sa taille. */
        ancienne_largeur := it.modèle_de_boite.contenu.largeur
        delta := si utilise_flex_shrink {
            espace_disponible * flex_shrink.number / somme_flex_shrink
        }
        sinon {
            espace_disponible * flex_grow.number / somme_flex_grow
        }

        nouvelle_largeur := ancienne_largeur + delta

        largeur_désirée := crée_outrepas_pour_coter_contenu(nouvelle_largeur)
        it.mesure(ctx, mode, *largeur_désirée)
    }

    ligne.largeur = 0.0
    pour item dans ligne.items {
        it := item.noeud
        ligne.largeur += it.modèle_de_boite.marge.largeur
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ContexteDeFormattageTable
 * \{ */

AlignementCellule :: énum {
    BaseLine
    Top
    Bottom
    Middle
}

DonnéesCellule :: struct {
    box: *TableCellBox
    colonne: z64
    ligne: z64
    colspan: n32

    minimum_content_width: r64
    maximum_content_width: r64

    largeur_est_en_pourcentage: bool
    pourcentage: r64

    position_x_finale: r32
    largeur_finale: r32

    baseline: r32
}

donne_alignement_vertical :: fonc (cellule: *DonnéesCellule) -> AlignementCellule
{
    vertical_align := cellule.box.propriétés.donne_valeur_utilisée(IDPropriété.VerticalAlign)
    si vertical_align.est_mot_clé(PROP_top) {
        retourne AlignementCellule.Top
    }
    si vertical_align.est_mot_clé(PROP_middle) {
        retourne AlignementCellule.Middle
    }
    si vertical_align.est_mot_clé(PROP_bottom) {
        retourne AlignementCellule.Bottom
    }
    retourne AlignementCellule.BaseLine
}

donne_bottom :: fonc (cellule: *DonnéesCellule) -> r32 #enligne
{
    retourne cellule.box.modèle_de_boite.marge.y + cellule.box.modèle_de_boite.marge.hauteur
}

donne_middle :: fonc (cellule: *DonnéesCellule) -> r32
{
    box := cellule.box

    si box.lignes_tenante {
        y_min := R64_INFINITÉ
        y_max := R64_INFINITÉ_NÉGATIVE

        pour box.lignes_tenante.lignes {
            y_min_enfant := it.position_y
            y_max_enfant := it.position_y + it.hauteur_contenu

            y_min = min(y_min, y_min_enfant comme r64)
            y_max = max(y_max, y_max_enfant comme r64)
        }

        retourne (y_min + (y_max - y_min) * 0.5) comme r32
    }

    si box.enfants {
        y_min := R64_INFINITÉ
        y_max := R64_INFINITÉ_NÉGATIVE

        pour box.enfants {
            y_min_enfant := it.modèle_de_boite.marge.y
            y_max_enfant := it.modèle_de_boite.marge.y + it.modèle_de_boite.marge.hauteur

            y_min = min(y_min, y_min_enfant comme r64)
            y_max = max(y_max, y_max_enfant comme r64)
        }

        retourne (y_min + (y_max - y_min) * 0.5) comme r32
    }

    retourne box.modèle_de_boite.contenu.y + box.modèle_de_boite.contenu.hauteur * 0.5
}

donne_hauteur :: fonc (cellule: *DonnéesCellule) -> r32 #enligne
{
    retourne cellule.box.modèle_de_boite.marge.hauteur
}

R64_INFINITÉ : r64 : 0r7ff0000000000000
R64_INFINITÉ_NÉGATIVE : r64 : 0rfff0000000000000

DonnéesColonne :: struct {
    minimum_width := R64_INFINITÉ_NÉGATIVE
    maximum_width := R64_INFINITÉ_NÉGATIVE
    final_width: r64
}

LigneDeCellules :: struct {
    row: *TableRowBox
    index_première_cellule: z32
    nombre_de_cellules: z32
    hauteur_finale: r32

    hauteur: r32
    top: r32
    bottom: r32
    baseline: r32
}

donne_cellules :: fonc (ligne: *LigneDeCellules, ctx: *ContexteDeFormattageTable) -> []DonnéesCellule
{
    résultat: []DonnéesCellule
    résultat.pointeur = ctx.cellules.pointeur + ligne.index_première_cellule
    résultat.taille = ligne.nombre_de_cellules
    retourne résultat
}

GroupeDeLignes :: struct {
    group_box: *TableRowGroupBox
    index_première_ligne: z32
    nombre_de_lignes: z32
}

donne_lignes :: fonc (groupe: *GroupeDeLignes, ctx: *ContexteDeFormattageTable) -> []LigneDeCellules
{
    résultat: []LigneDeCellules
    résultat.pointeur = ctx.lignes.pointeur + groupe.index_première_ligne
    résultat.taille = groupe.nombre_de_lignes
    retourne résultat
}

ContexteDeFormattageTable :: struct {
    empl base: ContexteDeFormattage
    type = #type_de_cette_structure

    cellules: [..]DonnéesCellule
    lignes: [..]LigneDeCellules
    groupes_de_lignes: [..]GroupeDeLignes
    colonnes_cellules: [..]z64

    données_colonnes: [..]DonnéesColonne

    nombre_de_lignes: z64
    nombre_de_colonnes: z64
}

formatte_table :: fonc (ctx: *ContexteDeFormattageTable, table: *TableBox)
{
    initialise_données_cellules(ctx, table)

    possède_cellule_avec_largeur_en_pourcentage := faux

    pour * ctx.cellules {
        width := it.box.propriétés.donne_valeur_calculée(IDPropriété.Width)
        si width.est_percentage() {
            possède_cellule_avec_largeur_en_pourcentage = vrai
            it.largeur_est_en_pourcentage = vrai
            it.pourcentage = width.percentage / 100.0
            continue
        }

        mesure(it.box, ctx, ModeDeFormattage.ToutesLesBrisuresDeLigne, nul)
        it.minimum_content_width = it.box.modèle_de_boite.bordure.largeur

        mesure(it.box, ctx, ModeDeFormattage.BrisureDeLigneExplicite, nul)
        it.maximum_content_width = it.box.modèle_de_boite.bordure.largeur

        containing_block := donne_containing_block(it.box, ctx)
        résoud_pourcentage_largeurs(ctx, it.box, containing_block)

        width = it.box.propriétés.donne_valeur_calculée(IDPropriété.Width)
        si width.est_pixels() {
            si width.pixels > it.minimum_content_width {
                it.minimum_content_width = width.pixels
            }

            si width.pixels > it.maximum_content_width {
                it.maximum_content_width = width.pixels
            }
        }

        min_width := it.box.propriétés.donne_valeur_calculée(IDPropriété.MinWidth)
        si min_width.est_pixels() {
            si min_width.pixels > it.minimum_content_width {
                it.minimum_content_width = min_width.pixels
            }

            si min_width.pixels > it.maximum_content_width {
                it.maximum_content_width = min_width.pixels
            }
        }

        // imprime("cellule min %, max %\n", it.minimum_content_width, it.maximum_content_width)
    }

    si possède_cellule_avec_largeur_en_pourcentage {
        pourcentage_à_allouer : r64 = 0.0
        minimum_content_width_hors_pourcentage : r64 = 0
        maximum_content_width_hors_pourcentage : r64 = 0

        pour * ctx.cellules {
            si it.largeur_est_en_pourcentage {
                pourcentage_à_allouer += it.pourcentage
                continue
            }

            minimum_content_width_hors_pourcentage += it.minimum_content_width
            maximum_content_width_hors_pourcentage += it.maximum_content_width
        }

        pourcentage_occupé := 1.0 - pourcentage_à_allouer

        minimum_content_width := minimum_content_width_hors_pourcentage / pourcentage_occupé
        maximum_content_width := maximum_content_width_hors_pourcentage / pourcentage_occupé

        pour * ctx.cellules {
            saufsi it.largeur_est_en_pourcentage {
                continue
            }

            it.minimum_content_width = minimum_content_width * it.pourcentage
            it.maximum_content_width = maximum_content_width * it.pourcentage
        }
    }

    pour ctx.colonnes_cellules.taille / 2 {
        index_colonne := ctx.colonnes_cellules[it * 2]
        index_cellule := ctx.colonnes_cellules[it * 2 + 1]

        cellule := ctx.cellules[index_cellule]

        si cellule.colspan == 1 {
            données_colonnes := *ctx.données_colonnes[index_colonne]

            si données_colonnes.minimum_width < cellule.minimum_content_width {
                données_colonnes.minimum_width = cellule.minimum_content_width
            }

            si données_colonnes.maximum_width < cellule.maximum_content_width {
                données_colonnes.maximum_width = cellule.maximum_content_width
            }
        }
        sinon {
            largeur_min_colonnes : r64 = 0.0
            largeur_max_colonnes : r64 = 0.0

            pour idx dans index_colonne ... index_colonne + (cellule.colspan comme z32) - 1 {
                assert(idx < ctx.données_colonnes.taille)
                données_colonnes := *ctx.données_colonnes[idx]

                largeur_min_colonnes += données_colonnes.minimum_width
                largeur_max_colonnes += données_colonnes.maximum_width
            }

            si largeur_min_colonnes < cellule.minimum_content_width {
                delta := (cellule.minimum_content_width - largeur_min_colonnes) / cellule.colspan comme r64

                pour idx dans index_colonne ... index_colonne + (cellule.colspan comme z32) - 1 {
                    données_colonnes := *ctx.données_colonnes[idx]
                    données_colonnes.minimum_width += delta
                }
            }

            si largeur_max_colonnes < cellule.maximum_content_width {
                delta := (cellule.maximum_content_width - largeur_max_colonnes) / cellule.colspan comme r64

                pour idx dans index_colonne ... index_colonne + (cellule.colspan comme z32) - 1 {
                    données_colonnes := *ctx.données_colonnes[idx]
                    données_colonnes.maximum_width += delta
                }
            }
        }
    }

    largeur := calcule_largeur_table(ctx, table)
    largeur_du_contenu := largeur

    border_spacing := table.propriétés.donne_valeur_calculée(IDPropriété.BorderSpacing).pixels
    border_collapse := table.propriétés.donne_valeur_calculée(IDPropriété.BorderCollapse)

    utilise_border_spacing := border_collapse.est_mot_clé(PROP_separate)
    si utilise_border_spacing {
        largeur += border_spacing * (2.0 + ctx.données_colonnes.taille comme r32)
        largeur_du_contenu += border_spacing * (ctx.données_colonnes.taille comme r32)
    }

    outrepas_largeur := crée_outrepas_pour_coter_contenu(largeur)
    containing_block := donne_containing_block(table, ctx)
    args := crée_arguments_dimensionnement_largeur(ctx, table, containing_block, *outrepas_largeur, ModeDeFormattage.Normal)
    calcule_largeur_et_marges(*args)
    _ := calcule_hauteur_et_marges(*args)

    /* Nous utilisons la bordure et non le contenu car la bordure et le rembourrage
     * sont géré par le TableWrapperBox parent : nous risquerions de décaler inutilement le contenu. */
    décalage_x := table.modèle_de_boite.bordure.x
    décalage_y := table.modèle_de_boite.bordure.y

    si utilise_border_spacing {
        décalage_x += border_spacing comme r32
        décalage_y += border_spacing comme r32
    }

    params: ParamsDispositionCellules
    params.utilise_border_spacing = utilise_border_spacing
    params.border_spacing = border_spacing
    params.décalage_x = décalage_x
    params.décalage_y_ligne = décalage_y
    params.largeur_du_contenu = largeur_du_contenu

    pour * ctx.lignes {
        _ := dispose_cellules_ligne(ctx, it, *params)
    }

    pour * ctx.groupes_de_lignes {
        lignes := it.donne_lignes(ctx)

        x_min := R64_INFINITÉ
        x_max := R64_INFINITÉ_NÉGATIVE
        y_min := R64_INFINITÉ
        y_max := R64_INFINITÉ_NÉGATIVE

        pour * ligne dans lignes {
            cellules := ligne.donne_cellules(ctx)

            pour * cellule dans cellules {
                box := cellule.box

                x_min_cellule := box.modèle_de_boite.marge.x
                x_max_cellule := box.modèle_de_boite.marge.x + box.modèle_de_boite.marge.largeur
                y_min_cellule := box.modèle_de_boite.marge.y
                y_max_cellule := box.modèle_de_boite.marge.y + box.modèle_de_boite.marge.hauteur

                x_min = min(x_min, x_min_cellule comme r64)
                x_max = max(x_max, x_max_cellule comme r64)
                y_min = min(y_min, y_min_cellule comme r64)
                y_max = max(y_max, y_max_cellule comme r64)
            }
        }

        group_box := it.group_box
        définis_position(group_box, x_min comme r32, y_min comme r32)
        définis_largeur_contenu(group_box.modèle_de_boite, (x_max - x_min) comme r32)
        définis_hauteur_contenu(group_box.modèle_de_boite, (y_max - y_min) comme r32)
    }

    hauteur_du_contenu := params.décalage_y_ligne - décalage_y
    si utilise_border_spacing {
        hauteur_du_contenu += border_spacing comme r32
    }

    outrepas_hauteur := crée_outrepas_pour_coter_contenu(hauteur_du_contenu)
    args = crée_arguments_dimensionnement_hauteur(ctx, table, containing_block, *outrepas_hauteur)
    _ := calcule_hauteur_et_marges(*args)
}

initialise_données_cellules :: fonc (ctx: *ContexteDeFormattageTable, table: *TableBox)
{
    index_ligne: z64

    pour table.enfants {
        si it.table_virtuelle.type == TableRowBox {
            récolte_cellules_sur_table_row(ctx, it comme *TableRowBox, index_ligne)
            index_ligne += 1
            continue
        }

        saufsi est_row_group_box(it) {
            continue
        }

        groupe := tableau_ajoute_élément(*ctx.groupes_de_lignes)
        groupe.group_box = it comme *TableRowGroupBox
        groupe.index_première_ligne = ctx.lignes.taille comme z32

        pour enfant_row_group dans it.enfants {
            saufsi enfant_row_group.table_virtuelle.type == TableRowBox {
                continue
            }

            récolte_cellules_sur_table_row(ctx, enfant_row_group comme *TableRowBox, index_ligne)
            index_ligne += 1

            groupe.nombre_de_lignes += 1
        }
    }

    ctx.nombre_de_lignes = index_ligne

    tableau_redimensionne(ctx.données_colonnes, ctx.nombre_de_colonnes)

    // imprime("lignes : %, colones : %\n", index_ligne, ctx.nombre_de_colonnes)
}

récolte_cellules_sur_table_row :: fonc (ctx: *ContexteDeFormattageTable, row: *TableRowBox, index_ligne: z64)
{
    index_colonne: z64
    cellules_sur_ligne: z32

    ligne := tableau_ajoute_élément(*ctx.lignes)
    ligne.row = row
    ligne.index_première_cellule = ctx.cellules.taille comme z32

    pour enfant_row dans row.enfants {
        saufsi enfant_row.table_virtuelle.type == TableCellBox {
            continue
        }

        cell := enfant_row comme *TableCellBox

        index_cellule := ctx.cellules.taille

        cellule := tableau_ajoute_élément(*ctx.cellules)
        cellule.box = cell
        cellule.colonne = index_colonne
        cellule.ligne = index_ligne

        si cell.élément {
            cellule.colspan = HTML.donne_colspan(cell.élément)
        }
        sinon {
            cellule.colspan = 1
        }

        ligne.nombre_de_cellules += 1

        tableau_ajoute(*ctx.colonnes_cellules, index_colonne)
        tableau_ajoute(*ctx.colonnes_cellules, index_cellule)

        index_colonne += cellule.colspan comme z64
        cellules_sur_ligne += 1

        si ctx.nombre_de_colonnes < index_colonne {
            ctx.nombre_de_colonnes = index_colonne
        }
    }
}

/* https://www.w3.org/TR/2011/REC-CSS2-20110607/tables.html#auto-table-layout */
calcule_largeur_table :: fonc (ctx: *ContexteDeFormattageTable, table: *TableBox) -> r64
{
    containing_block := donne_containing_block(table, ctx)
    résoud_pourcentage_largeurs(ctx, table, containing_block)
    width := table.propriétés.donne_valeur_calculée(IDPropriété.Width)

    // À FAIRE : CAPMIN
    CAPMIN : r64 = 0.0
    // À FAIRE : cell spacing and borders

    MIN: r64
    pour ctx.données_colonnes {
        MIN += it.minimum_width
    }

    saufsi width.est_auto() {
        W := width.pixels
        used_width := max(W, CAPMIN, MIN)

        si used_width > MIN {
            delta := (used_width - MIN) / ctx.données_colonnes.taille comme r64

            pour * ctx.données_colonnes {
                it.final_width = it.minimum_width + delta
            }
        }
        sinon {
            pour * ctx.données_colonnes {
                it.final_width = it.minimum_width
            }
        }

        retourne used_width
    }

    largeur_containing_block := containing_block.donne_largeur()

    MAX: r64
    pour ctx.données_colonnes {
        MAX += it.maximum_width
    }

    pour * ctx.données_colonnes {
        it.final_width = it.maximum_width
    }

    si CAPMIN < largeur_containing_block || MAX < largeur_containing_block {
        retourne max(MAX, CAPMIN)
    }

    retourne max(largeur_containing_block comme r64, CAPMIN, MIN)
}

ParamsDispositionCellules :: struct {
    utilise_border_spacing: bool
    décalage_x: r32
    border_spacing: r64
    décalage_y_ligne: r32
    largeur_du_contenu: r64
}

dispose_cellules_ligne :: fonc (ctx: *ContexteDeFormattageTable, ligne: *LigneDeCellules, empl params: *ParamsDispositionCellules) -> r64
{
    // imprime("[%]\n", #nom_de_cette_fonction)
    calcule_largeurs_cellules(ctx, ligne, params)

    ligne.top = décalage_y_ligne
    dispose_cellules_ligne(ctx, ligne)

    aligne_cellules_verticalement(ctx, ligne, AlignementCellule.BaseLine)
    aligne_cellules_verticalement(ctx, ligne, AlignementCellule.Top)

    cellules := ligne.donne_cellules(ctx)

    pour * cellules {
        alignement := it.donne_alignement_vertical()
        // imprime("-- %\n", alignement)
        si alignement != AlignementCellule.Middle && alignement != AlignementCellule.Bottom {
            continue
        }

        ligne.hauteur = max(ligne.hauteur, it.donne_hauteur())
    }

    row := ligne.row

    // À FAIRE : résoud ceci proprement
    prop_height := row.propriétés.donne_valeur_calculée(IDPropriété.Height)
    si prop_height.est_pixels() && ligne.hauteur < prop_height.pixels {
        ligne.hauteur = prop_height.pixels comme r32
    }

    aligne_cellules_verticalement(ctx, ligne, AlignementCellule.Bottom)
    aligne_cellules_verticalement(ctx, ligne, AlignementCellule.Middle)

    hauteur_ligne := ligne.hauteur

    /* "Cell boxes that are smaller than the height of the row receive extra top or bottom padding."
     * https://www.w3.org/TR/2011/REC-CSS2-20110607/tables.html#height-layout */
    pour row.enfants {
        saufsi it.table_virtuelle.type == TableCellBox {
            continue
        }

        saufsi it.modèle_de_boite.marge.hauteur < hauteur_ligne {
            continue
        }

        // À FAIRE : il faudrait plustôt ajuster la hauteur puis déplacer les enfants selon l'alignement de la cellule.
        it.modèle_de_boite.définis_hauteur_contenu(hauteur_ligne)
    }

    définis_position(row, décalage_x, décalage_y_ligne)
    définis_largeur_contenu(row.modèle_de_boite, largeur_du_contenu comme r32)
    définis_hauteur_contenu(row.modèle_de_boite, hauteur_ligne)

    décalage_y_ligne += hauteur_ligne

    si utilise_border_spacing {
        décalage_y_ligne += border_spacing comme r32
    }

    ligne.hauteur_finale = hauteur_ligne

    retourne hauteur_ligne
}

dispose_cellules_ligne :: fonc (ctx: *ContexteDeFormattageTable, ligne: *LigneDeCellules)
{
    cellules := ligne.donne_cellules(ctx)
    pour * cellule dans cellules {
        définis_position(cellule.box, cellule.position_x_finale, ligne.top)
        outrepas_largeur := crée_outrepas_pour_coter_contenu(donne_largeur_contenu(cellule.box, cellule.largeur_finale))
        mesure(cellule.box, ctx, ModeDeFormattage.Normal, *outrepas_largeur)
    }
}

aligne_cellules_verticalement :: fonc (ctx: *ContexteDeFormattageTable, ligne: *LigneDeCellules, alignement: AlignementCellule)
{
    cellules := ligne.donne_cellules(ctx)
    si alignement == AlignementCellule.BaseLine {
        pour * cellules {
            si it.donne_alignement_vertical() != alignement {
                continue
            }
            it.baseline = donne_baseline(it.box).Quelque
            ligne.baseline = max(ligne.baseline, it.baseline)
        }
    
        pour * cellules {
            si it.donne_alignement_vertical() != alignement {
                continue
            }

            // imprime("baseline ligne % cellule %\n", ligne.baseline, it.baseline)

            si it.baseline != ligne.baseline {
                delta := ligne.baseline - it.baseline
                it.box.décale_contenu(0.0, delta)
            }

            ligne.hauteur = max(ligne.hauteur, it.donne_bottom() - ligne.top)
        }

        retourne
    }

    si alignement == AlignementCellule.Top {
        pour * cellules {
            si it.donne_alignement_vertical() != alignement {
                continue
            }

            ligne.hauteur = max(ligne.hauteur, it.donne_bottom() - ligne.top)
        }

        retourne
    }

    si alignement == AlignementCellule.Bottom {
        pour * cellules {
            si it.donne_alignement_vertical() != alignement {
                continue
            }

            si it.donne_bottom() != ligne.bottom {
                delta := it.donne_bottom() - ligne.bottom
                it.box.décale_contenu(0.0, delta)
            }
        }

        retourne
    }

    assert(alignement == AlignementCellule.Middle)
    middle := ligne.top + ligne.hauteur * 0.5

    pour * cellules {
        si it.donne_alignement_vertical() != alignement {
            continue
        }

        middle_cellule := it.donne_middle()

        // imprime("middle ligne % cellule %\n", middle, middle_cellule)

        si middle_cellule != middle {
            delta := middle - middle_cellule
            it.box.décale_contenu(0.0, delta)
        }
    }
}

calcule_largeurs_cellules :: fonc (ctx: *ContexteDeFormattageTable, ligne: *LigneDeCellules, empl params: *ParamsDispositionCellules)
{
    décalage_x_colonne := décalage_x

    cellules := ligne.donne_cellules(ctx)

    pour * cellule dans cellules {
        données_colonnes := *ctx.données_colonnes[cellule.colonne]

        largeur_cellule := données_colonnes.final_width
        si cellule.colspan > 1 {
            pour idx dans cellule.colonne + 1 ... cellule.colonne + (cellule.colspan comme z32) - 1 {
                données_colonnes = *ctx.données_colonnes[idx]
                largeur_cellule += données_colonnes.final_width
            }
        }

        cellule.position_x_finale = décalage_x_colonne
        cellule.largeur_finale = largeur_cellule comme r32

        décalage_x_colonne += largeur_cellule comme r32
        si utilise_border_spacing {
            décalage_x_colonne += border_spacing comme r32
        }
    }
}

/** \} */
