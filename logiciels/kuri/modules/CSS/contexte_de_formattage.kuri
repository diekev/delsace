importe Chaine
importe Fondation
importe Géométrie
importe Math

/* ------------------------------------------------------------------------- */
/** \nom ContexteDeFormattage
 * \{ */

ModeDeFormattage :: énum {
    Normal
    /* Pour le calcul de la largeur « préférée ». */
    BrisureDeLigneExplicite
    /* Pour le calcul de la largeur « minimale préférée ». */
    ToutesLesBrisuresDeLigne
}

BoiteAbsolue :: struct {
    noeud: *NoeudDeDispositionBloc
    containing_block: *NoeudDeDisposition
    pos_x_statique: r64
    pos_y_statique: r64
    fut_disposée: bool
}

GardeBoitesAbsolues :: struct {
    boites: [..]BoiteAbsolue
}

ContexteDeFormattage :: struct {
    type: type_de_données
    parent: *ContexteDeFormattage

    sur_formatte: fonc(*ContexteDeFormattage, *NoeudDeDispositionBloc, ModeDeFormattage)(rien)

    globales: *GlobalesDessin
    initial_containing_block: *ContainingBlock

    /* Pour la résolution des pourcentages. */
    ctx_calcul_style: *ContexteCalculStyle

    /* Pour la disposition des boites absolues. */
    boites_absolues: *GardeBoitesAbsolues

    /* https://html.spec.whatwg.org/multipage/rendering.html#align-descendants */
    doit_aligner_les_descendants: Optionnel(AlignementTexte)
}

initialise_depuis_parent :: fonc (ctx: *ContexteDeFormattage, parent: *ContexteDeFormattage)
{
    ctx.parent = parent
    ctx.globales = parent.globales
    ctx.initial_containing_block = parent.initial_containing_block
    ctx.boites_absolues = parent.boites_absolues
    ctx.ctx_calcul_style = parent.ctx_calcul_style
}

donne_initial_containing_block :: fonc (ctx: *ContexteDeFormattage) -> ContainingBlock
{
    retourne mémoire(ctx.initial_containing_block)
}

formatte :: fonc (contexte: *ContexteDeFormattage, noeud: *NoeudDeDispositionBloc, mode: ModeDeFormattage)
{
    contexte.sur_formatte(contexte, noeud, mode)
}

/* https://drafts.csswg.org/css-display-4/#establish-an-independent-formatting-context
 * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_flow_layout/Introduction_to_formatting_contexts#creating_a_new_block_formatting_context */
requiers_contexte_de_formattage_indépendant :: fonc (noeud: *NoeudDeDisposition) -> bool
{
    si noeud.parent == nul {
        retourne vrai
    }

    // elements made to float using float
    float := noeud.propriétés.donne_valeur_calculée(IDPropriété.Float)
    saufsi float.est_none() {
        retourne vrai
    }

    // absolutely positioned elements
    position := noeud.propriétés.donne_valeur_calculée(IDPropriété.Position)
    si position.est_mot_clé(PROP_absolute) {
        retourne vrai
    }

    // table cells or elements with display: table-cell, including anonymous table cells created when using the display: table-* properties
    si noeud.type == TableCellBox {
        retourne vrai
    }

    // table captions or elements with display: table-caption
    si noeud.type == CaptionBox {
        retourne vrai
    }

    // block elements where overflow has a value other than visible
    overflow_x := noeud.propriétés.donne_valeur_calculée(IDPropriété.OverflowX)
    overflow_y := noeud.propriétés.donne_valeur_calculée(IDPropriété.OverflowY)
    si !overflow_x.est_mot_clé(PROP_visible) || !overflow_y.est_mot_clé(PROP_visible) {
        retourne vrai
    }

    // elements with display: inline-block
    // elements with display: flow-root or display: flow-root list-item
    display := noeud.propriétés.donne_valeur_calculée(IDPropriété.Display).display
    si display.inner_type == Display.Type.FlowRoot {
        retourne vrai
    }

    // À FAIRE : elements with contain: layout, content, or strict

    // flex items
    si noeud.parent.donne_display().inner_type == Display.Type.Flex {
        // À FAIRE : autres cas
        si noeud.donne_display().inner_type != Display.Type.Flex {
            retourne vrai
        }
    }

    // À FAIRE : grid items
    // À FAIRE : multicol containers
    // À FAIRE : elements with column-span set to all

    retourne faux
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ContexteDeFormattage
 * \{ */

BoiteFlottante :: struct {
    noeud: *NoeudDeDisposition
    position_x: r32
    position_y: r32
    hauteur: r32
    largeur: r32
}

crée_boite_flottante :: fonc (noeud: *NoeudDeDisposition) -> BoiteFlottante
{
    résultat: BoiteFlottante
    résultat.noeud = noeud
    résultat.position_x = noeud.modèle_de_boite.marge.x
    résultat.position_y = noeud.modèle_de_boite.marge.y
    résultat.hauteur = noeud.modèle_de_boite.marge.hauteur
    résultat.largeur = noeud.modèle_de_boite.marge.largeur
    retourne résultat
}

donne_rectangle :: fonc (boite: BoiteFlottante) -> RectanglePosDim(r64)
{
    résultat: RectanglePosDim(r64)
    résultat.x = boite.position_x
    résultat.y = boite.position_y
    résultat.hauteur = boite.hauteur
    résultat.largeur = boite.largeur
    retourne résultat
}

LigneDeFlottants :: struct {
    boites: [..]BoiteFlottante
    rect: RectanglePosDim(r64)
}

détruit_donnée_ligne :: fonc (ligne: *LigneDeFlottants)
{
    déloge(ligne.boites)
}

ajoute_boite :: fonc (ligne: *LigneDeFlottants, boite: BoiteFlottante)
{
    tableau_ajoute(*ligne.boites, boite)
    si ligne.boites.taille == 1 {
        ligne.rect = boite.donne_rectangle()
    }
    sinon {
        ligne.rect = donne_union(ligne.rect, boite.donne_rectangle())
    }
}

donne_position_la_plus_à_gauche :: fonc (ligne: *LigneDeFlottants) -> r64
{
    résultat := ligne.rect.x

    pour > ligne.boites {
        si it.hauteur == 0.0 {
            continue
        }

        résultat = it.position_x + it.largeur
        arrête
    }

    retourne résultat
}

donne_position_la_plus_à_droite :: fonc (ligne: *LigneDeFlottants) -> r64
{
    résultat := ligne.rect.x

    pour > ligne.boites {
        si it.hauteur == 0.0 {
            continue
        }

        résultat = it.position_x
        arrête
    }

    retourne résultat
}

ContenantLignesDeFlottants :: struct {
    lignes: [..]LigneDeFlottants
    réinitialise_pour_clear: bool
}

détruit_données_lignes :: fonc (contenant: *ContenantLignesDeFlottants)
{
    pour * contenant.lignes {
        détruit_donnée_ligne(it)
    }
    déloge(contenant.lignes)
}

donne_dernière_ligne :: fonc (contenant: *ContenantLignesDeFlottants, containing_block: &ContainingBlock, gauche: bool) -> *LigneDeFlottants
{
    si contenant.lignes.taille == 0 || contenant.réinitialise_pour_clear {
        contenant.réinitialise_pour_clear = faux
        retourne ajoute_une_ligne(contenant, containing_block, gauche)
    }

    résultat := *contenant.lignes[contenant.lignes.taille - 1]

    /* Ajoute une nouvelle ligne s'il n'y a pas d'intersection possible avec la dernière ligne. */
    si résultat.boites.taille != 0 && (résultat.rect.y + résultat.rect.hauteur <= containing_block.rect.y) {
        résultat = ajoute_une_ligne(contenant, containing_block, gauche)
    }

    retourne résultat
}

ajoute_une_ligne :: fonc (contenant: *ContenantLignesDeFlottants, containing_block: &ContainingBlock, gauche: bool) -> *LigneDeFlottants
{
    résultat := tableau_ajoute_élément(*contenant.lignes)
    résultat.rect.x = containing_block.rect.x
    saufsi gauche {
        résultat.rect.x += containing_block.rect.largeur
    }

    si contenant.lignes.taille > 1 {
        dernière_ligne := contenant.lignes[contenant.lignes.taille - 2]
        résultat.rect.y = dernière_ligne.rect.y + dernière_ligne.rect.hauteur
    }
    sinon {
        résultat.rect.y = containing_block.rect.y
    }

    retourne résultat
}

ContexteDeFormattageBloc :: struct {
    empl base: ContexteDeFormattage
    type = #type_de_cette_structure
    sur_formatte = contexte_formattage_bloc_sur_formatte

    racine: *NoeudDeDispositionBloc

    /* Pour la disposition des floats. */
    décalage_x: r32
    décalage_float_left_x: r32
    décalage_float_left_y: r32
    décalage_float_right_x: r32
    décalage_float_right_y: r32

    lignes_boites_flottantes_gauche: ContenantLignesDeFlottants
    lignes_boites_flottantes_droite: ContenantLignesDeFlottants
    rect_boites_flottantes_gauches: RectanglePosDim(r64)
    rect_boites_flottantes_droites: RectanglePosDim(r64)
}

détruit_données_contexte :: fonc (ctx: *ContexteDeFormattageBloc)
{
    détruit_données_lignes(*ctx.lignes_boites_flottantes_gauche)
    détruit_données_lignes(*ctx.lignes_boites_flottantes_droite)
}

contexte_formattage_bloc_sur_formatte :: fonc (base: *ContexteDeFormattage, noeud: *NoeudDeDispositionBloc, mode: ModeDeFormattage)
{
    ctx := base comme *ContexteDeFormattageBloc

    /* https://www.w3.org/TR/CSS2/box.html#collapsing-margins */
    décalage_x := noeud.modèle_de_boite.contenu.x
    décalage_y := noeud.modèle_de_boite.contenu.y

    // dernière_marge := marges[BorderEdge.Top]

    hauteur_contenu := 0.0
    décalage_hors_float := 0.0
    décalage_pour_floats_gauche := 0.0
    décalage_pour_floats_droite := 0.0

    si noeud == ctx.racine {
        ctx.décalage_x = décalage_x
        ctx.décalage_float_left_x = décalage_x
        ctx.décalage_float_left_y = décalage_y
        ctx.décalage_float_right_x = décalage_x + noeud.modèle_de_boite.contenu.largeur
        ctx.décalage_float_right_y = décalage_y
    }

    pour noeud.enfants {
        position := it.propriétés.donne_valeur_utilisée(IDPropriété.Position)
        si position.est_mot_clé(PROP_absolute) {
            ctx.dispose_boite_absolute(it comme *NoeudDeDispositionBloc, décalage_x, décalage_y + décalage_hors_float, mode)
            continue
        }

        si position.est_mot_clé(PROP_fixed) {
            ctx.dispose_boite_fixed(it comme *NoeudDeDispositionBloc)
            continue
        }

        clear := it.propriétés.donne_valeur_utilisée(IDPropriété.Clear)
        si clear.est_mot_clé(PROP_left) {
            hauteur_float_left := ctx.donne_décalage_floats_gauche() - décalage_y

            si hauteur_contenu < hauteur_float_left {
                hauteur_contenu = hauteur_float_left
            }

            si décalage_hors_float < hauteur_float_left {
                décalage_hors_float = hauteur_float_left
            }

            si décalage_pour_floats_gauche < hauteur_float_left {
                décalage_pour_floats_gauche = hauteur_float_left
            }

            ctx.décalage_float_left_y = hauteur_contenu
            ctx.lignes_boites_flottantes_gauche.réinitialise_pour_clear = vrai
        }
        sinon si clear.est_mot_clé(PROP_right) {
            hauteur_float_right := ctx.donne_décalage_floats_droite() - décalage_y

            si hauteur_contenu < hauteur_float_right {
                hauteur_contenu = hauteur_float_right
            }

            si décalage_hors_float < hauteur_float_right {
                décalage_hors_float = hauteur_float_right
            }

            si décalage_pour_floats_droite < hauteur_float_right {
                décalage_pour_floats_droite = hauteur_float_right
            }

            ctx.décalage_float_right_y = hauteur_contenu
            ctx.lignes_boites_flottantes_droite.réinitialise_pour_clear = vrai
        }
        sinon si clear.est_mot_clé(PROP_both) {
            hauteur_float_right := ctx.donne_décalage_floats_droite() - décalage_y
            hauteur_float_left := ctx.donne_décalage_floats_gauche() - décalage_y
            hauteur_float_both := max(hauteur_float_left, hauteur_float_right)

            si hauteur_contenu < hauteur_float_both {
                hauteur_contenu = hauteur_float_both
            }

            si décalage_hors_float < hauteur_float_both {
                décalage_hors_float = hauteur_float_both
            }

            si décalage_pour_floats_gauche < hauteur_float_both {
                décalage_pour_floats_gauche = hauteur_float_both
            }

            si décalage_pour_floats_droite < hauteur_float_both {
                décalage_pour_floats_droite = hauteur_float_both
            }

            ctx.décalage_float_left_y = hauteur_contenu
            ctx.décalage_float_right_y = hauteur_contenu
            ctx.lignes_boites_flottantes_gauche.réinitialise_pour_clear = vrai
            ctx.lignes_boites_flottantes_droite.réinitialise_pour_clear = vrai
        }

        float := it.propriétés.donne_valeur_utilisée(IDPropriété.Float)
        si float.est_mot_clé(PROP_left) {
            it.définis_position(décalage_x, décalage_y + décalage_pour_floats_gauche)
            it.mesure(ctx, mode, nul)
            ctx.ajoute_boite_flottante_gauche(it)
            continue
        }
        si float.est_mot_clé(PROP_right) {
            it.définis_position(décalage_x, décalage_y + décalage_pour_floats_droite)
            it.mesure(ctx, mode, nul)
            ctx.ajoute_boite_flottante_droite(it)
            continue
        }

        it.définis_position(décalage_x, décalage_y + décalage_hors_float)
        it.mesure(ctx, mode, nul)

        hauteur_enfant := it.modèle_de_boite.marge.hauteur

        hauteur_contenu += hauteur_enfant
        décalage_hors_float += hauteur_enfant

        /* Les blocs dont le formatte interne est inline ne doivent pas déplacer les floats. */
        méthode_de_formattage := donne_méthode_de_formattage_intérieur(it)
        si méthode_de_formattage != MéthodeDeFormattage.Inline {
            décalage_pour_floats_gauche = décalage_hors_float
            décalage_pour_floats_droite = décalage_hors_float
        }
    }

    pour noeud.enfants {
        position := it.propriétés.donne_valeur_utilisée(IDPropriété.Position)
        /* À FAIRE : https://drafts.csswg.org/css-position/#relpos-insets */
        si position.est_mot_clé(PROP_relative) {
            résoud_pourcentage_insets(it, ctx)

            top := it.propriétés.donne_valeur_utilisée(IDPropriété.Top)
            bottom := it.propriétés.donne_valeur_utilisée(IDPropriété.Bottom)
            left := it.propriétés.donne_valeur_utilisée(IDPropriété.Left)
            right := it.propriétés.donne_valeur_utilisée(IDPropriété.Right)

            si left.est_auto() && right.est_auto() {
                left = ValeurDeStyle(pixels = 0.0)
                right = ValeurDeStyle(pixels = 0.0)
            }
            sinon si left.est_auto() {
                left = ValeurDeStyle(pixels = -right.pixels)
            }
            sinon si right.est_auto() {
                right.pixels = -left.pixels
            }
            sinon {
                right.pixels = 0.0
            }

            si top.est_auto() && bottom.est_auto() {
                top = ValeurDeStyle(pixels = 0.0)
                bottom.pixels = 0.0
            }
            sinon si top.est_auto() {
                top = ValeurDeStyle(pixels = -bottom.pixels)
            }
            sinon si bottom.est_auto() {
                bottom.pixels = -top.pixels
            }
            sinon {
                bottom.pixels = 0.0
            }

            it.décale(left.pixels comme r32, top.pixels comme r32)
        }
    }

    si noeud == ctx.racine {
        /* https://www.w3.org/TR/2011/REC-CSS2-20110607/visudet.html#root-height */
        pour noeud.enfants {
            float := it.propriétés.donne_valeur_utilisée(IDPropriété.Float)
            si float.est_mot_clé(PROP_none) {
                continue
            }

            si hauteur_contenu < it.modèle_de_boite.marge.hauteur {
                hauteur_contenu = it.modèle_de_boite.marge.hauteur
            }
        }
    }

    height := noeud.propriétés.donne_valeur_calculée(IDPropriété.Height)
    si height.est_auto() {
        hauteur_finale := crée_outrepas_pour_coter_contenu(hauteur_contenu)
        containing_block := donne_containing_block(noeud, ctx)
        args := crée_arguments_dimensionnement_hauteur(ctx, noeud, containing_block, *hauteur_finale)
        _ := calcule_hauteur_et_marges(*args)
    }

    discr mode {
        BrisureDeLigneExplicite,
        ToutesLesBrisuresDeLigne {
            largeur_max_enfant : r64 = 0.0
            pour noeud.enfants {
                position := it.propriétés.donne_valeur_utilisée(IDPropriété.Position)
                si position.est_mot_clé(PROP_absolute) || position.est_mot_clé(PROP_fixed) {
                    continue
                }

                largeur_enfant := it.modèle_de_boite.marge.largeur
                largeur_max_enfant = max(largeur_max_enfant, largeur_enfant)
            }

            prop_largeur := noeud.propriétés.donne_valeur_calculée(IDPropriété.Width)
            si prop_largeur.est_auto() {
                noeud.propriétés.définis_valeur_utilisée(IDPropriété.Width, ValeurDeStyle(pixels = largeur_max_enfant))
                ajourne_boite_pour_calcul_largeur(noeud)
            }
        }
        sinon {}
    }
}

dispose_boite_fixed :: fonc (empl ctx: *ContexteDeFormattageBloc, noeud: *NoeudDeDispositionBloc)
{
    containing_block := donne_containing_block(noeud, ctx)
    args := crée_arguments_dimensionnement_largeur(ctx, noeud, containing_block, nul, ModeDeFormattage.Normal)
    calcule_largeur_et_marges(*args)
    _ := calcule_hauteur_et_marges(*args)

    bord_gauche := containing_block.rect.x
    bord_haut := containing_block.rect.y

    top := noeud.propriétés.donne_valeur_utilisée(IDPropriété.Top)
    bottom := noeud.propriétés.donne_valeur_utilisée(IDPropriété.Bottom)
    left := noeud.propriétés.donne_valeur_utilisée(IDPropriété.Left)

    si top.est_auto() && bottom.est_auto() {
        top = ValeurDeStyle(pixels = 0.0)
    }
    sinon si top.est_auto() {
        top = ValeurDeStyle(pixels = -bottom.pixels)
    }
    sinon saufsi top.est_pixels() {
        top = ValeurDeStyle(pixels = 0.0)
    }

    noeud.définis_position(bord_gauche + left.pixels comme r32, bord_haut + top.pixels comme r32)
    formatte_intérieur(noeud, ctx, ModeDeFormattage.Normal)
}

dispose_boite_absolute :: fonc (empl ctx: *ContexteDeFormattage, noeud: *NoeudDeDispositionBloc, pos_x_statique: r64, pos_y_statique: r64, mode: ModeDeFormattage)
{
    si mode != ModeDeFormattage.Normal {
        retourne
    }

    containing_block := donne_containing_block(noeud, ctx)

    boite_absolue := tableau_ajoute_élément(*ctx.boites_absolues.boites)
    boite_absolue.noeud = noeud
    boite_absolue.containing_block = containing_block.noeud
    boite_absolue.pos_x_statique = pos_x_statique
    boite_absolue.pos_y_statique = pos_y_statique
}

dispose_les_boites_absolues :: fonc (ctx: *ContexteDeFormattage, containing_block: *NoeudDeDisposition)
{
    boites_à_disposer: [..]BoiteAbsolue
    diffère déloge(boites_à_disposer)

    pour ctx.boites_absolues.boites {
        si it.containing_block != containing_block {
            continue
        }

        tableau_ajoute(*boites_à_disposer, it)

        si index_it < ctx.boites_absolues.boites.taille - 1 {
            ctx.boites_absolues.boites[index_it] = ctx.boites_absolues.boites[ctx.boites_absolues.boites.taille - 1]
            ctx.boites_absolues.boites.taille -= 1
            reprends it
        }
    }

    pour * boites_à_disposer {
        dispose_boite_absolute(ctx, it)
    }
}

/* À FAIRE : https://drafts.csswg.org/css-position/#abspos-layout */
dispose_boite_absolute :: fonc (empl ctx: *ContexteDeFormattage, boite: *BoiteAbsolue)
{
    noeud := boite.noeud

    containing_block := donne_containing_block(noeud, ctx)
    assert(containing_block.noeud == boite.containing_block)

    args := crée_arguments_dimensionnement_largeur(ctx, noeud, containing_block, nul, ModeDeFormattage.Normal)
    args.pos_x_statique = boite.pos_x_statique
    args.pos_y_statique = boite.pos_y_statique
    calcule_largeur_et_marges(*args)
    état_calcul_hauteur := calcule_hauteur_et_marges(*args)

    si état_calcul_hauteur != ÉtatCalculHauteur.HauteurDépendSurContenu {
        position_boite_absolue(noeud, containing_block, faux)
    }

    formatte_intérieur(noeud, ctx, ModeDeFormattage.Normal)

    si état_calcul_hauteur == ÉtatCalculHauteur.HauteurDépendSurContenu {
        args.calcul_hauteur_après_contenu = vrai
        _ := calcule_hauteur_et_marges(*args)

        position_boite_absolue(noeud, containing_block, vrai)
    }

    ctx.dispose_les_boites_absolues(noeud)
}

position_boite_absolue :: fonc (noeud: *NoeudDeDisposition, containing_block: &ContainingBlock, décale: bool)
{
    bord_gauche := containing_block.rect.x
    bord_haut := containing_block.rect.y

    top := noeud.propriétés.donne_valeur_utilisée(IDPropriété.Top)
    left := noeud.propriétés.donne_valeur_utilisée(IDPropriété.Left)

    x := bord_gauche + left.pixels comme r32
    y := bord_haut + top.pixels comme r32

    si décale {
        noeud.décale_vers_position(x, y)
    }
    sinon {
        noeud.définis_position(x, y)
    }
}

ajoute_boite_flottante_gauche :: fonc (empl ctx: *ContexteDeFormattageBloc, noeud: *NoeudDeDisposition)
{
    containing_block := donne_containing_block(noeud, ctx)
    largeur_disponible := containing_block.donne_largeur()

    bord_gauche := containing_block.rect.x
    bord_droit := bord_gauche + largeur_disponible

    boite := crée_boite_flottante(noeud)

    ligne := donne_dernière_ligne(*ctx.lignes_boites_flottantes_gauche, containing_block, vrai)

    boucle {
        boite.position_x = ligne.donne_position_la_plus_à_gauche() comme r32
        boite.position_y = max(ligne.rect.y comme r32, boite.position_y)

        si boite.position_x + boite.largeur <= bord_droit || boite.position_x <= bord_gauche {
            arrête
        }

        ligne = ajoute_une_ligne(*ctx.lignes_boites_flottantes_gauche, containing_block, vrai)
    }

    si instersecte_hors_touche(boite.donne_rectangle(), ctx.rect_boites_flottantes_droites) {
        pour ligne_droite dans ctx.lignes_boites_flottantes_droite.lignes {
            saufsi instersecte_hors_touche(boite.donne_rectangle(), ligne_droite.rect) {
                continue
            }

            pour boite_droite dans ligne_droite.boites {
                saufsi instersecte_hors_touche(boite.donne_rectangle(), boite_droite.donne_rectangle()) {
                    continue
                }

                si ligne.boites.taille != 0 {
                    ligne = ajoute_une_ligne(*ctx.lignes_boites_flottantes_gauche, containing_block, vrai)
                }

                boite.position_y = max(boite_droite.position_y + boite_droite.hauteur, ligne.rect.y comme r32)
                boite.position_x = ligne.donne_position_la_plus_à_gauche() comme r32
            }
        }
    }

    décalage_float_left_y = boite.position_y
    ligne.ajoute_boite(boite)

    si ctx.lignes_boites_flottantes_gauche.lignes.taille == 1 && ligne.boites.taille == 1 {
        ctx.rect_boites_flottantes_gauches = boite.donne_rectangle()
    }
    sinon {
        ctx.rect_boites_flottantes_gauches = donne_union(ctx.rect_boites_flottantes_gauches, boite.donne_rectangle())
    }

    noeud.décale_vers_position(boite.position_x, boite.position_y)
}

ajoute_boite_flottante_droite :: fonc (empl ctx: *ContexteDeFormattageBloc, noeud: *NoeudDeDisposition)
{
    containing_block := donne_containing_block(noeud, ctx)
    largeur_disponible := containing_block.donne_largeur()

    bord_gauche := containing_block.rect.x
    bord_droit := bord_gauche + largeur_disponible

    boite := crée_boite_flottante(noeud)

    ligne := donne_dernière_ligne(*ctx.lignes_boites_flottantes_droite, containing_block, faux)

    boucle {
        boite.position_x = ligne.donne_position_la_plus_à_droite() comme r32 - boite.largeur
        boite.position_y = max(ligne.rect.y comme r32, boite.position_y)

        si boite.position_x >= bord_gauche || boite.position_x + boite.largeur >= bord_droit {
            arrête
        }

        ligne = ajoute_une_ligne(*ctx.lignes_boites_flottantes_droite, containing_block, faux)
    }

    si instersecte_hors_touche(boite.donne_rectangle(), ctx.rect_boites_flottantes_gauches) {
        pour ligne_gauche dans ctx.lignes_boites_flottantes_gauche.lignes {
            saufsi instersecte_hors_touche(boite.donne_rectangle(), ligne_gauche.rect) {
                continue
            }

            pour boite_gauche dans ligne_gauche.boites {
                saufsi instersecte_hors_touche(boite.donne_rectangle(), boite_gauche.donne_rectangle()) {
                    continue
                }

                si ligne.boites.taille != 0 {
                    ligne = ajoute_une_ligne(*ctx.lignes_boites_flottantes_droite, containing_block, faux)
                }

                boite.position_y = max(boite_gauche.position_y + boite_gauche.hauteur, ligne.rect.y comme r32)
                boite.position_x = ligne.donne_position_la_plus_à_droite() comme r32 - boite.largeur
            }
        }
    }

    décalage_float_right_y = boite.position_y
    ligne.ajoute_boite(boite)

    si ctx.lignes_boites_flottantes_droite.lignes.taille == 1 && ligne.boites.taille == 1 {
        ctx.rect_boites_flottantes_droites = boite.donne_rectangle()
    }
    sinon {
        ctx.rect_boites_flottantes_droites = donne_union(ctx.rect_boites_flottantes_droites, boite.donne_rectangle())
    }

    noeud.décale_vers_position(boite.position_x, boite.position_y)
}

/* Retourne faux si les rectangles ne font que se toucher. */
instersecte_hors_touche :: fonc (rect1: RectanglePosDim(r64), rect2: RectanglePosDim(r64)) -> bool
{
    saufsi intersecte(rect1, rect2) {
        retourne faux
    }

    si abs(rect1.y + rect1.hauteur - rect2.y) <= 0.00001 {
        retourne faux
    }

    si abs(rect2.y + rect2.hauteur - rect1.y) <= 0.00001 {
        retourne faux
    }

    si abs(rect1.x + rect1.largeur - rect2.x) <= 0.00001 {
        retourne faux
    }

    si abs(rect2.x + rect2.largeur - rect1.x) <= 0.00001 {
        retourne faux
    }

    retourne vrai
}

donne_décalage_floats_gauche :: fonc (empl ctx: *ContexteDeFormattageBloc) -> r32
{
    retourne (ctx.rect_boites_flottantes_gauches.y + ctx.rect_boites_flottantes_gauches.hauteur) comme r32
}

donne_décalage_floats_droite :: fonc (empl ctx: *ContexteDeFormattageBloc) -> r32
{
    retourne (ctx.rect_boites_flottantes_droites.y + ctx.rect_boites_flottantes_droites.hauteur) comme r32
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ContexteDeFormattage
 * \{ */

ContexteDeFormattageInline :: struct {
    empl base: ContexteDeFormattage
    type = #type_de_cette_structure
    sur_formatte = contexte_formattage_inline_sur_formatte

    racine: *NoeudDeDispositionBloc
}

donne_position_et_largeur_ligne :: fonc (ctx: *ContexteDeFormattageInline, x_min: r32, x_max: r32, position_y: r32) -> (position: r32, largeur: r32)
{
    si ctx.parent && ctx.parent.type == ContexteDeFormattageBloc {
        ctx_bloc := ctx.parent comme *ContexteDeFormattageBloc

        pour ligne dans ctx_bloc.lignes_boites_flottantes_gauche.lignes {
            pour ligne.boites {
                si contient(it.donne_rectangle(), x_min, position_y) {
                    x_min += it.largeur
                }
            }
        }

        pour ligne dans ctx_bloc.lignes_boites_flottantes_droite.lignes {
            pour ligne.boites {
                si contient(it.donne_rectangle(), x_max, position_y) {
                    x_max -= it.largeur
                }
            }
        }
    }

    position = x_min
    largeur = x_max - x_min

    si largeur < 0.0 {
        largeur = 0.0
    }

    retourne position, largeur
}

AlignementTexte :: énum {
    Gauche
    Droite
    Centre
    Justifié
}

donne_alignement_texte :: fonc (noeud: *NoeudDeDispositionBloc) -> AlignementTexte
{
    text_align := noeud.propriétés.donne_valeur_utilisée(IDPropriété.TextAlign)

    si text_align.est_mot_clé(PROP_start) {
        retourne AlignementTexte.Gauche
    }

    si text_align.est_mot_clé(PROP_end) {
        retourne AlignementTexte.Droite
    }

    si text_align.est_mot_clé(PROP_left) {
        retourne AlignementTexte.Gauche
    }

    si text_align.est_mot_clé(PROP_right) {
        retourne AlignementTexte.Droite
    }

    si text_align.est_mot_clé(PROP_center) {
        retourne AlignementTexte.Centre
    }

    si text_align.est_mot_clé(PROP_justify) {
        retourne AlignementTexte.Justifié
    }

    retourne AlignementTexte.Gauche
}

contexte_formattage_inline_sur_formatte :: fonc (base: *ContexteDeFormattage, noeud: *NoeudDeDispositionBloc, mode: ModeDeFormattage)
{
    ctx := base comme *ContexteDeFormattageInline

    containing_block := donne_containing_block(noeud, ctx)

    enligneuse: Enligneuse
    divise_en_lignes(*enligneuse, noeud, ctx, mode)

    hauteur_contenu := 0.0

    alignement := donne_alignement_texte(noeud)
    si ctx.doit_aligner_les_descendants.possède_valeur() {
        alignement = ctx.doit_aligner_les_descendants.Quelque
    }

    lignes_tenante := *noeud.lignes_tenante

    pour lignes_tenante.lignes {
        hauteur := it.hauteur_contenu
        décalage_pour_alignement := 0.0

        fragments := donne_fragments_ligne(lignes_tenante, *it)

        si fragments.taille == 0 {
            hauteur_contenu += hauteur
            continue
        }

        largeur_disponible := it.largeur_max

        si alignement == AlignementTexte.Droite {
            décalage_pour_alignement = largeur_disponible - it.largeur_courante
        }
        sinon si alignement == AlignementTexte.Centre {
            décalage_pour_alignement = (largeur_disponible - it.largeur_courante) / 2.0
        }
        sinon si alignement == AlignementTexte.Justifié {
            /* À FAIRE : ignore l'espace finale. */
            décalage_pour_alignement = (largeur_disponible - it.largeur_courante) / ((fragments.taille - 1) comme r32)
        }

        pour * fragment, index_fragment dans fragments {
            décalage_fragment_x := 0.0
            si alignement == AlignementTexte.Justifié {
                si index_fragment != 0 && index_it != (lignes_tenante.lignes.taille - 1) {
                    décalage_fragment_x += décalage_pour_alignement * (index_fragment comme r32)
                }
            }
            sinon {
                décalage_fragment_x += décalage_pour_alignement
            }

            // imprime("décalage fragment : % %\n", décalage_fragment_x, décalage_y)
            fragment.x += décalage_fragment_x

            si fragment.type == Fragment.Type.InlineBlock {
                fragment.noeud.décale_vers_position(fragment.x, fragment.y)
            }
        }

        // pour * fragment dans it.fragments {
        //     noeud_fragment := fragment.noeud
        //     propriétés_noeud_fragment := donne_propriétés(noeud_fragment)
        //     vertical_align := propriétés_noeud_fragment.donne_valeur_utilisée(IDPropriété.VerticalAlign)
        //     imprime("vertical-align: % (% | %)\n", vertical_align, fragment.hauteur, hauteur)

        //     si vertical_align.est_mot_clé(PROP_bottom) || vertical_align.est_mot_clé(PROP_baseline) {
        //         si fragment.hauteur < hauteur {
        //             fragment.y += (hauteur - fragment.hauteur)
        //         }
        //     }
        //     sinon si vertical_align.est_mot_clé(PROP_top) {
        //         si fragment.hauteur < hauteur {
        //             fragment.y = (hauteur - fragment.hauteur)
        //         }
        //     }
        // }

        hauteur_contenu += hauteur
    }

    hauteur_finale := crée_outrepas_pour_coter_contenu(hauteur_contenu)
    args := crée_arguments_dimensionnement_hauteur(ctx, noeud, containing_block, *hauteur_finale)
    _ := calcule_hauteur_et_marges(*args)

    discr mode {
        BrisureDeLigneExplicite,
        ToutesLesBrisuresDeLigne {
            largeur_max_enfant : r64 = 0.0
            pour lignes_tenante.lignes {
                largeur_max_enfant = max(largeur_max_enfant, it.largeur_courante comme r64)
            }

            largeur := noeud.propriétés.donne_valeur_calculée(IDPropriété.Width)
            si largeur.est_auto() {
                valeur_largeur_enfant := crée_outrepas_pour_coter_contenu(largeur_max_enfant)
                /* Utilise cette fontcion pour résoudre les valeurs 'auto' pour les autres propriétés. */
                args = ArgumentsDimensionnement(ctx, noeud, width_of_containing_block = 0.0, outrepas_largeur = valeur_largeur_enfant)
                calcule_largeur_et_marges(*args, calcule_largeur_et_marges_inline_non_replaced_element)
            }
        }
        sinon {}
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Flexbox
 * https://www.w3.org/TR/css-flexbox-1/
 * \{ */

est_espace_blanche_document :: fonc (base: *NoeudDeDisposition) -> bool
{
    si base.type == NoeudDeDispositionTexte {
        noeud := base comme *NoeudDeDispositionTexte
        retourne est_vide_ou_uniquement_espaces_blanches(noeud.noeud_texte.données)
    }

    si base.type == NoeudDeDispositionBloc || base.type == NoeudDeDispositionInline {
        noeud := base comme *NoeudDeDispositionBloc

        si noeud.élément != nul {
            /* Nous voulons un noeud anonyme. */
            retourne faux
        }

        si noeud.enfants.taille != 1 {
            /* Il ne doit y avoir qu'un seul enfant : le noeud inline anonyme ou le noeud texte. */
            retourne faux
        }

        retourne est_espace_blanche_document(noeud.enfants[0])
    }

    retourne faux
}

ItemFlex :: struct {
    noeud: *NoeudDeDisposition
}

LigneFlex :: struct {
    items: []ItemFlex
    largeur: r32
}

ContexteDeFormattageFlex :: struct {
    empl base: ContexteDeFormattage
    type = #type_de_cette_structure
    sur_formatte = contexte_formattage_flex_sur_formatte

    items: [..]ItemFlex
    lignes: [..]LigneFlex
}

contexte_formattage_flex_sur_formatte :: fonc (base: *ContexteDeFormattage, noeud: *NoeudDeDispositionBloc, mode: ModeDeFormattage)
{
    ctx := base comme *ContexteDeFormattageFlex
    diffère {
        déloge(ctx.items)
        déloge(ctx.lignes)
    }

    construit_liste_items(ctx, noeud, mode)
    calcule_taille_items(ctx, noeud, mode)

    direction := noeud.propriétés.donne_valeur_calculée(IDPropriété.FlexDirection).mot_clé

    si direction == PROP_row || direction == PROP_row_reverse {
        formatte_flex_row(ctx, noeud, mode, direction == PROP_row_reverse)
    }
    sinon {
        assert(direction == PROP_column || direction == PROP_column_reverse)
        formatte_flex_column(ctx, noeud, mode, direction == PROP_column_reverse)
    }
}

construit_liste_items :: fonc (ctx: *ContexteDeFormattageFlex, noeud: *NoeudDeDispositionBloc, mode: ModeDeFormattage)
{
    pour noeud.enfants {
        si est_espace_blanche_document(it) {
            it.traite_comme_display_none = vrai
            continue
        }

        /* À FAIRE : les boites fixed doivent être disposé autrement. */
        position := it.propriétés.donne_valeur_utilisée(IDPropriété.Position)
        si position.est_mot_clé(PROP_absolute) || position.est_mot_clé(PROP_fixed) {
            ctx.dispose_boite_absolute(it comme *NoeudDeDispositionBloc, noeud.modèle_de_boite.contenu.x, noeud.modèle_de_boite.contenu.y, mode)
            continue
        }

        tableau_ajoute(*ctx.items, ItemFlex(it))
    }
}

calcule_taille_items :: fonc (ctx: *ContexteDeFormattageFlex, noeud: *NoeudDeDispositionBloc, mode: ModeDeFormattage)
{
    largeur_disponible := noeud.modèle_de_boite.contenu.largeur

    pour item dans ctx.items {
        it := item.noeud
        flex_basis := résoud_flex_basis(it)

        largeur_désirée: OutrepasCotation
        si flex_basis.est_mot_clé(PROP_content) {
            /* calcule_shrink_to_fit_width ne résoud pas les pourcentages... */
            it.mesure(ctx, mode, nul)
            largeur := calcule_shrink_to_fit_width(ctx, it, largeur_disponible)
            largeur_désirée = crée_outrepas_pour_coter_contenu(largeur)
        }
        sinon si flex_basis.est_percentage() || flex_basis.est_calc() {
            définis_propriétés(ctx.ctx_calcul_style, noeud.propriétés)
            largeur := calcule_pourcentage(ctx.ctx_calcul_style, flex_basis, largeur_disponible).pixels
            largeur_désirée = crée_outrepas_pour_coter_boite(largeur)
        }
        sinon {
            largeur_désirée = crée_outrepas_pour_coter_boite(flex_basis.pixels)
        }

        it.mesure(ctx, mode, *largeur_désirée)
    }
}

/* https://www.w3.org/TR/css-flexbox-1/#valdef-flex-flex-basis */
résoud_flex_basis :: fonc (noeud: *NoeudDeDisposition) -> ValeurDeStyle
{
    flex_basis := noeud.propriétés.donne_valeur_utilisée(IDPropriété.FlexBasis)

    si flex_basis.est_mot_clé(PROP_auto) {
        width := noeud.propriétés.donne_valeur_calculée(IDPropriété.Width)

        si width.est_auto() {
            retourne ValeurDeStyle(mot_clé = PROP_content)
        }

        retourne width
    }

    retourne flex_basis
}

formatte_flex_row :: fonc (ctx: *ContexteDeFormattageFlex, noeud: *NoeudDeDispositionBloc, mode: ModeDeFormattage, reverse: bool)
{
    largeur_disponible := noeud.modèle_de_boite.contenu.largeur

    /* Crée des lignes. */
    ligne_courante := tableau_ajoute_élément(*ctx.lignes)
    ligne_courante.items.pointeur = ctx.items.pointeur

    flex_wrap := noeud.propriétés.donne_valeur_utilisée(IDPropriété.FlexWrap).mot_clé

    pour item, index_item dans ctx.items {
        it := item.noeud
        largeur := it.modèle_de_boite.marge.largeur

        si flex_wrap == PROP_wrap && (ligne_courante.largeur + largeur) > largeur_disponible {
            ligne_courante = tableau_ajoute_élément(*ctx.lignes)
            ligne_courante.items.pointeur = ctx.items.pointeur + index_item
        }

        ligne_courante.largeur += largeur
        ligne_courante.items.taille += 1
    }

    /* Dispose les noeuds. */
    décalage_x := noeud.modèle_de_boite.contenu.x
    décalage_y := noeud.modèle_de_boite.contenu.y

    si reverse {
        décalage_x += noeud.modèle_de_boite.contenu.largeur
    }

    décalage_x_original := décalage_x

    hauteur_contenu := 0.0

    pour * ligne dans ctx.lignes {
        justify_content := noeud.propriétés.donne_valeur_utilisée(IDPropriété.JustifyContent).mot_clé
        espace_disponible := largeur_disponible - ligne.largeur

        distribue_espace_disponible(ctx, ligne, espace_disponible, mode)

        espace_disponible = largeur_disponible - ligne.largeur

        décalage_pre := 0.0
        décalage_post := 0.0

        si justify_content == PROP_center {
            décalage_x += espace_disponible * 0.5
        }
        sinon si justify_content == PROP_flex_end {
            décalage_x += espace_disponible
        }
        sinon si justify_content == PROP_space_between {
            décalage_post = espace_disponible / (ligne.items.taille - 1) comme r32
        }
        sinon si justify_content == PROP_space_around {
            espace_par_bloc := espace_disponible / (ligne.items.taille) comme r32
            décalage_pre = espace_par_bloc * 0.5
            décalage_post = décalage_pre
        }

        hauteur_ligne := 0.0
        pour item dans ligne.items {
            it := item.noeud
            si reverse {
                décalage_x -= décalage_pre + it.modèle_de_boite.marge.largeur
            }
            sinon {
                décalage_x += décalage_pre
            }

            it.décale_vers_position(décalage_x, décalage_y)

            si reverse {
                décalage_x -= décalage_post
            }
            sinon {
                décalage_x += it.modèle_de_boite.marge.largeur + décalage_post
            }
            hauteur_ligne = max(hauteur_ligne, it.modèle_de_boite.marge.hauteur)
        }

        décalage_y += hauteur_ligne
        hauteur_contenu += hauteur_ligne
        décalage_x = décalage_x_original
    }

    /* Ajourne les propriétés du noeud. */
    prop_largeur := noeud.propriétés.donne_valeur_calculée(IDPropriété.Width)
    si prop_largeur.est_auto() {
        largeur_des_enfants := 0.0
        pour item dans ctx.items {
            largeur_des_enfants += item.noeud.modèle_de_boite.marge.largeur
        }
        noeud.propriétés.définis_valeur_utilisée(IDPropriété.Width, ValeurDeStyle(pixels = largeur_des_enfants))
    }

    hauteur_finale := crée_outrepas_pour_coter_contenu(hauteur_contenu)
    containing_block := donne_containing_block(noeud, ctx)
    args := crée_arguments_dimensionnement_hauteur(ctx, noeud, containing_block, *hauteur_finale)
    _ := calcule_hauteur_et_marges(*args)

    discr mode {
        BrisureDeLigneExplicite,
        ToutesLesBrisuresDeLigne {
            noeud.ajourne_boite_pour_calcul_largeur()
        }
        sinon {}
    }
}

formatte_flex_column :: fonc (ctx: *ContexteDeFormattageFlex, noeud: *NoeudDeDispositionBloc, mode: ModeDeFormattage, reverse: bool)
{
    largeur_des_enfants := 0.0
    hauteur_des_enfants := 0.0

    /* Calcule la taille des noeuds. */
    pour item dans ctx.items {
        it := item.noeud
        largeur_des_enfants += it.modèle_de_boite.marge.largeur
        hauteur_des_enfants += it.modèle_de_boite.marge.hauteur
    }

    /* Dispose les noeuds. */
    décalage_x := noeud.modèle_de_boite.contenu.x
    décalage_y := noeud.modèle_de_boite.contenu.y

    si reverse {
        décalage_y += noeud.modèle_de_boite.contenu.hauteur
    }

    pour item dans ctx.items {
        it := item.noeud
        si reverse {
            décalage_y -= it.modèle_de_boite.marge.hauteur
        }

        it.décale_vers_position(décalage_x, décalage_y)

        largeur_des_enfants += it.modèle_de_boite.marge.largeur

        saufsi reverse {
            décalage_y += it.modèle_de_boite.marge.hauteur
        }
    }

    /* Ajourne les propriétés du noeud. */
    prop_largeur := noeud.propriétés.donne_valeur_calculée(IDPropriété.Width)
    si prop_largeur.est_auto() {
        noeud.propriétés.définis_valeur_utilisée(IDPropriété.Width, ValeurDeStyle(pixels = largeur_des_enfants))
    }

    hauteur_finale := crée_outrepas_pour_coter_contenu(hauteur_des_enfants)
    containing_block := donne_containing_block(noeud, ctx)
    args := crée_arguments_dimensionnement_hauteur(ctx, noeud, containing_block, *hauteur_finale)
    _ := calcule_hauteur_et_marges(*args)

    discr mode {
        BrisureDeLigneExplicite,
        ToutesLesBrisuresDeLigne {
            noeud.ajourne_boite_pour_calcul_largeur()
        }
        sinon {}
    }
}

/* Modifie la taille des items selon leurs facteurs de croissance. */
distribue_espace_disponible :: fonc (ctx: *ContexteDeFormattageFlex, ligne: *LigneFlex, espace_disponible: r64, mode: ModeDeFormattage)
{
    si espace_disponible == 0.0 {
        retourne
    }

    utilise_flex_shrink := espace_disponible < 0.0

    somme_flex_grow: r64
    somme_flex_shrink: r64
    pour item dans ligne.items {
        it := item.noeud
        flex_grow := it.propriétés.donne_valeur_utilisée(IDPropriété.FlexGrow)
        flex_shrink := it.propriétés.donne_valeur_utilisée(IDPropriété.FlexShrink)
        somme_flex_grow += flex_grow.number
        somme_flex_shrink += flex_shrink.number
    }

    si utilise_flex_shrink && somme_flex_shrink == 0.0 {
        retourne
    }

    si !utilise_flex_shrink && somme_flex_grow == 0.0 {
        retourne
    }

    pour item dans ligne.items {
        it := item.noeud
        flex_grow := it.propriétés.donne_valeur_utilisée(IDPropriété.FlexGrow)
        flex_shrink := it.propriétés.donne_valeur_utilisée(IDPropriété.FlexShrink)

        si utilise_flex_shrink && flex_shrink.number == 0.0 {
            continue
        }

        si !utilise_flex_shrink && flex_grow.number == 0.0 {
            continue
        }

        /* Nous utilisons la largeur du contenu ici car c'est le contenu qui doit
         * changer sa taille. */
        ancienne_largeur := it.modèle_de_boite.contenu.largeur
        delta := si utilise_flex_shrink {
            espace_disponible * flex_shrink.number / somme_flex_shrink
        }
        sinon {
            espace_disponible * flex_grow.number / somme_flex_grow
        }

        nouvelle_largeur := ancienne_largeur + delta

        largeur_désirée := crée_outrepas_pour_coter_contenu(nouvelle_largeur)
        it.mesure(ctx, mode, *largeur_désirée)
    }

    ligne.largeur = 0.0
    pour item dans ligne.items {
        it := item.noeud
        ligne.largeur += it.modèle_de_boite.marge.largeur
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ContexteDeFormattageTable
 * \{ */

DonnéesCellule :: struct {
    box: *TableCellBox
    colonne: z64
    ligne: z64
    colspan: n32

    minimum_content_width: r64
    maximum_content_width: r64
}

R64_INFINITÉ : r64 : 0r7ff0000000000000
R64_INFINITÉ_NÉGATIVE : r64 : 0rfff0000000000000

DonnéesColonne :: struct {
    minimum_width := R64_INFINITÉ_NÉGATIVE
    maximum_width := R64_INFINITÉ_NÉGATIVE
    final_width: r64
}

ContexteDeFormattageTable :: struct {
    empl base: ContexteDeFormattage
    type = #type_de_cette_structure

    cellules: [..]DonnéesCellule
    lignes_cellules: [..]z64
    colonnes_cellules: [..]z64
    cellules_par_ligne: [..]z32

    données_colonnes: [..]DonnéesColonne

    nombre_de_lignes: z64
    nombre_de_colonnes: z64
}

formatte_table :: fonc (ctx: *ContexteDeFormattageTable, table: *TableBox)
{
    initialise_données_cellules(ctx, table)

    pour * ctx.cellules {
        mesure(it.box, ctx, ModeDeFormattage.ToutesLesBrisuresDeLigne, nul)
        it.minimum_content_width = it.box.modèle_de_boite.bordure.largeur

        mesure(it.box, ctx, ModeDeFormattage.BrisureDeLigneExplicite, nul)
        it.maximum_content_width = it.box.modèle_de_boite.bordure.largeur

        containing_block := donne_containing_block(it.box, ctx)
        résoud_pourcentage_largeurs(ctx, it.box, containing_block)

        width := it.box.propriétés.donne_valeur_calculée(IDPropriété.Width)
        si width.est_pixels() {
            si width.pixels > it.minimum_content_width {
                it.minimum_content_width = width.pixels
            }

            si width.pixels > it.maximum_content_width {
                it.maximum_content_width = width.pixels
            }
        }

        min_width := it.box.propriétés.donne_valeur_calculée(IDPropriété.MinWidth)
        si min_width.est_pixels() {
            si min_width.pixels > it.minimum_content_width {
                it.minimum_content_width = min_width.pixels
            }

            si min_width.pixels > it.maximum_content_width {
                it.maximum_content_width = min_width.pixels
            }
        }

        // imprime("cellule min %, max %\n", it.minimum_content_width, it.maximum_content_width)
    }

    pour ctx.colonnes_cellules.taille / 2 {
        index_colonne := ctx.colonnes_cellules[it * 2]
        index_cellule := ctx.colonnes_cellules[it * 2 + 1]

        cellule := ctx.cellules[index_cellule]

        si cellule.colspan == 1 {
            données_colonnes := *ctx.données_colonnes[index_colonne]

            si données_colonnes.minimum_width < cellule.minimum_content_width {
                données_colonnes.minimum_width = cellule.minimum_content_width
            }

            si données_colonnes.maximum_width < cellule.maximum_content_width {
                données_colonnes.maximum_width = cellule.maximum_content_width
            }
        }
        sinon {
            largeur_min_colonnes : r64 = 0.0
            largeur_max_colonnes : r64 = 0.0

            pour idx dans index_colonne ... index_colonne + (cellule.colspan comme z32) - 1 {
                assert(idx < ctx.données_colonnes.taille)
                données_colonnes := *ctx.données_colonnes[idx]

                largeur_min_colonnes += données_colonnes.minimum_width
                largeur_max_colonnes += données_colonnes.maximum_width
            }

            si largeur_min_colonnes < cellule.minimum_content_width {
                delta := (cellule.minimum_content_width - largeur_min_colonnes) / cellule.colspan comme r64

                pour idx dans index_colonne ... index_colonne + (cellule.colspan comme z32) - 1 {
                    données_colonnes := *ctx.données_colonnes[idx]
                    données_colonnes.minimum_width += delta
                }
            }

            si largeur_max_colonnes < cellule.maximum_content_width {
                delta := (cellule.maximum_content_width - largeur_max_colonnes) / cellule.colspan comme r64

                pour idx dans index_colonne ... index_colonne + (cellule.colspan comme z32) - 1 {
                    données_colonnes := *ctx.données_colonnes[idx]
                    données_colonnes.maximum_width += delta
                }
            }
        }
    }

    largeur := calcule_largeur_table(ctx, table)

    outrepas_largeur := crée_outrepas_pour_coter_contenu(largeur)
    containing_block := donne_containing_block(table, ctx)
    args := crée_arguments_dimensionnement_largeur(ctx, table, containing_block, *outrepas_largeur, ModeDeFormattage.Normal)
    calcule_largeur_et_marges(*args)
    _ := calcule_hauteur_et_marges(*args)

    /* Nous utilisons la bordure et non le contenu car la bordure et le rembourrage
     * sont géré par le TableWrapperBox parent : nous risquerions de décaler inutilement le contenu. */
    décalage_x := table.modèle_de_boite.bordure.x
    décalage_y := table.modèle_de_boite.bordure.y

    décalage_y_ligne := décalage_y

    index_cellule: z64

    pour table.enfants {
        saufsi est_row_group_box(it) {
            continue
        }

        hauteur_row_group: r64
        décalage_y_row_group := décalage_y_ligne

        pour enfant_row_group dans it.enfants {
            saufsi enfant_row_group.type == TableRowBox {
                continue
            }

            décalage_x_colonne := décalage_x
            hauteur_ligne: r64

            pour enfant_row dans enfant_row_group.enfants {
                saufsi enfant_row.type == TableCellBox {
                    continue
                }

                cellule := *ctx.cellules[index_cellule]
                index_cellule += 1

                données_colonnes := *ctx.données_colonnes[cellule.colonne]

                largeur_cellule := données_colonnes.final_width
                si cellule.colspan > 1 {
                    pour idx dans cellule.colonne + 1 ... cellule.colonne + (cellule.colspan comme z32) - 1 {
                        données_colonnes = *ctx.données_colonnes[idx]
                        largeur_cellule += données_colonnes.final_width
                    }
                }

                définis_position(cellule.box, décalage_x_colonne, décalage_y_ligne)
                outrepas_largeur = crée_outrepas_pour_coter_contenu(donne_largeur_contenu(cellule.box, largeur_cellule))
                mesure(cellule.box, ctx, ModeDeFormattage.Normal, *outrepas_largeur)

                hauteur_ligne = max(hauteur_ligne, cellule.box.modèle_de_boite.marge.hauteur)
                décalage_x_colonne += largeur_cellule comme r32
            }

            définis_position(enfant_row_group, décalage_x, décalage_y_ligne)
            définis_largeur_contenu(enfant_row_group.modèle_de_boite, largeur comme r32)
            définis_hauteur_contenu(enfant_row_group.modèle_de_boite, hauteur_ligne comme r32)

            décalage_y_ligne += hauteur_ligne comme r32
            hauteur_row_group += hauteur_ligne
        }

        définis_position(it, décalage_x, décalage_y_row_group)
        définis_largeur_contenu(it.modèle_de_boite, largeur comme r32)
        définis_hauteur_contenu(it.modèle_de_boite, hauteur_row_group comme r32)
    }

    outrepas_hauteur := crée_outrepas_pour_coter_contenu(décalage_y_ligne - décalage_y)
    args = crée_arguments_dimensionnement_hauteur(ctx, table, containing_block, *outrepas_hauteur)
    _ := calcule_hauteur_et_marges(*args)
}

initialise_données_cellules :: fonc (ctx: *ContexteDeFormattageTable, table: *TableBox)
{
    index_ligne: z64

    pour table.enfants {
        saufsi est_row_group_box(it) {
            continue
        }

        pour enfant_row_group dans it.enfants {
            saufsi enfant_row_group.type == TableRowBox {
                continue
            }

            row := enfant_row_group comme *TableRowBox

            index_colonne: z64
            cellules_sur_ligne: z32

            pour enfant_row dans row.enfants {
                saufsi enfant_row.type == TableCellBox {
                    continue
                }

                cell := enfant_row comme *TableCellBox

                index_cellule := ctx.cellules.taille

                cellule := tableau_ajoute_élément(*ctx.cellules)
                cellule.box = cell
                cellule.colonne = index_colonne
                cellule.ligne = index_ligne

                si cell.élément {
                    cellule.colspan = HTML.donne_colspan(cell.élément)
                }
                sinon {
                    cellule.colspan = 1
                }

                tableau_ajoute(*ctx.lignes_cellules, index_ligne)
                tableau_ajoute(*ctx.lignes_cellules, index_cellule)

                tableau_ajoute(*ctx.colonnes_cellules, index_colonne)
                tableau_ajoute(*ctx.colonnes_cellules, index_cellule)

                index_colonne += cellule.colspan comme z64
                cellules_sur_ligne += 1

                si ctx.nombre_de_colonnes < index_colonne {
                    ctx.nombre_de_colonnes = index_colonne
                }
            }

            tableau_ajoute(*ctx.cellules_par_ligne, cellules_sur_ligne)
            index_ligne += 1
        }
    }

    ctx.nombre_de_lignes = index_ligne

    tableau_redimensionne(ctx.données_colonnes, ctx.nombre_de_colonnes)

    // imprime("lignes : %, colones : %\n", index_ligne, ctx.nombre_de_colonnes)
}

/* https://www.w3.org/TR/2011/REC-CSS2-20110607/tables.html#auto-table-layout */
calcule_largeur_table :: fonc (ctx: *ContexteDeFormattageTable, table: *TableBox) -> r64
{
    containing_block := donne_containing_block(table, ctx)
    résoud_pourcentage_largeurs(ctx, table, containing_block)
    width := table.propriétés.donne_valeur_calculée(IDPropriété.Width)

    // À FAIRE : CAPMIN
    CAPMIN : r64 = 0.0
    // À FAIRE : cell spacing and borders

    MIN: r64
    pour ctx.données_colonnes {
        MIN += it.minimum_width
    }

    saufsi width.est_auto() {
        W := width.pixels
        used_width := max(W, CAPMIN, MIN)

        si used_width > MIN {
            delta := (used_width - MIN) / ctx.données_colonnes.taille comme r64

            pour * ctx.données_colonnes {
                it.final_width = it.minimum_width + delta
            }
        }
        sinon {
            pour * ctx.données_colonnes {
                it.final_width = it.minimum_width
            }
        }

        retourne used_width
    }

    largeur_containing_block := containing_block.donne_largeur()

    MAX: r64
    pour ctx.données_colonnes {
        MAX += it.maximum_width
    }

    pour * ctx.données_colonnes {
        it.final_width = it.maximum_width
    }

    si CAPMIN < largeur_containing_block || MAX < largeur_containing_block {
        retourne max(MAX, CAPMIN)
    }

    retourne max(largeur_containing_block comme r64, CAPMIN, MIN)
}

/** \} */
