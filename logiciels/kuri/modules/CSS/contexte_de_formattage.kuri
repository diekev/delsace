importe Fondation
importe Math

/* ------------------------------------------------------------------------- */
/** \nom ContexteDeFormattage
 * \{ */

ModeDeFormattage :: énum {
    Normal
    /* Pour le calcul de la largeur « préférée ». */
    BrisureDeLigneExplicite
    /* Pour le calcul de la largeur « minimale préférée ». */
    ToutesLesBrisuresDeLigne
}

ContexteDeFormattage :: struct {
    sur_formatte: fonc(*ContexteDeFormattage, *NoeudDeDispositionBloc, ModeDeFormattage)(rien)

    globales: *GlobalesDessin
    initial_containing_block: *ContainingBlock

    /* https://html.spec.whatwg.org/multipage/rendering.html#align-descendants */
    doit_aligner_les_descendants: Optionnel(AlignementTexte)
}

donne_initial_containing_block :: fonc (ctx: *ContexteDeFormattage) -> ContainingBlock
{
    retourne mémoire(ctx.initial_containing_block)
}

formatte :: fonc (contexte: *ContexteDeFormattage, noeud: *NoeudDeDispositionBloc, mode: ModeDeFormattage)
{
    // ancien_noeud := contexte.noeud_contextuel
    // diffère contexte.définis_noeud_contextuel(ancien_noeud)
    // contexte.définis_noeud_contextuel(noeud)

    contexte.sur_formatte(contexte, noeud, mode)
}

modifie_marges_pour_alignement_forcé :: fonc (ctx: *ContexteDeFormattage, noeud: *NoeudDeDisposition)
{
    saufsi ctx.doit_aligner_les_descendants.possède_valeur() {
        retourne
    }

    propriétés := noeud.propriétés
    margin_left := propriétés.donne_valeur_calculée(IDPropriété.MarginLeft)
    margin_right := propriétés.donne_valeur_calculée(IDPropriété.MarginRight)

    si !margin_left.est_auto() && !margin_right.est_auto() {
        propriétés.définis_valeur_utilisée(IDPropriété.MarginLeft, ValeurDeStyle(mot_clé = PROP_auto))
        propriétés.définis_valeur_utilisée(IDPropriété.MarginRight, ValeurDeStyle(mot_clé = PROP_auto))
    }
}

/* https://drafts.csswg.org/css-display-4/#establish-an-independent-formatting-context
 * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_flow_layout/Introduction_to_formatting_contexts#creating_a_new_block_formatting_context */
requiers_contexte_de_formattage_indépendant :: fonc (noeud: *NoeudDeDisposition) -> bool
{
    si noeud.parent == nul {
        retourne vrai
    }

    // elements made to float using float
    float := noeud.propriétés.donne_valeur_calculée(IDPropriété.Float)
    saufsi float.est_none() {
        retourne vrai
    }

    // absolutely positioned elements
    position := noeud.propriétés.donne_valeur_calculée(IDPropriété.Position)
    si position.est_mot_clé(PROP_absolute) {
        retourne vrai
    }

    // À FAIRE : table cells or elements with display: table-cell, including anonymous table cells created when using the display: table-* properties
    // À FAIRE : table captions or elements with display: table-caption
    // À FAIRE : block elements where overflow has a value other than visible

    // elements with display: inline-block
    // elements with display: flow-root or display: flow-root list-item
    display := noeud.propriétés.donne_valeur_calculée(IDPropriété.Display).display
    si display.inner_type == Display.Type.FlowRoot {
        retourne vrai
    }

    // À FAIRE : elements with contain: layout, content, or strict
    // À FAIRE : flex items
    // À FAIRE : grid items
    // À FAIRE : multicol containers
    // À FAIRE : elements with column-span set to all

    retourne faux
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ContexteDeFormattage
 * \{ */

ContexteDeFormattageBloc :: struct {
    empl base: ContexteDeFormattage
    sur_formatte = contexte_formattage_bloc_sur_formatte

    racine: *NoeudDeDispositionBloc
}

résoud_pourcentage_insets :: fonc (noeud: *NoeudDeDisposition, ctx: *ContexteDeFormattage)
{
    containing_block := donne_containing_block(noeud, ctx)

    noeud.propriétés.résoud_pourcentage(IDPropriété.Top, containing_block.donne_hauteur())
    noeud.propriétés.résoud_pourcentage(IDPropriété.Bottom, containing_block.donne_hauteur())

    noeud.propriétés.résoud_pourcentage(IDPropriété.Left, containing_block.donne_largeur())
    noeud.propriétés.résoud_pourcentage(IDPropriété.Right, containing_block.donne_largeur())

    pour [IDPropriété.Top, IDPropriété.Bottom, IDPropriété.Left, IDPropriété.Right] {
        noeud.propriétés.définis_valeur_utilisée(it, noeud.propriétés.donne_valeur_calculée(it))
    }
}

contexte_formattage_bloc_sur_formatte :: fonc (base: *ContexteDeFormattage, noeud: *NoeudDeDispositionBloc, mode: ModeDeFormattage)
{
    ctx := base comme *ContexteDeFormattageBloc

    /* https://www.w3.org/TR/CSS2/box.html#collapsing-margins */
    décalage_x := noeud.modèle_de_boite.contenu.x
    décalage_y := noeud.modèle_de_boite.contenu.y

    // dernière_marge := marges[BorderEdge.Top]

    hauteur_contenu := 0.0
    décalage_hors_float := 0.0

    // décalage_float_right := décalage_x + noeud.modèle_de_boite.contenu.largeur

    // pour noeud.enfants {
    //     float := it.propriétés.donne_valeur_utilisée(IDPropriété.Float)
    //     si float.est_mot_clé(PROP_left) {
    //         it.mesure(ctx)
    //         it.décale(décalage_x, décalage_y)
    //         décalage_x += it.modèle_de_boite.marge.largeur
    //         hauteur_contenu = max(it.modèle_de_boite.marge.hauteur, hauteur_contenu)
    //     }
    //     sinon si float.est_mot_clé(PROP_right) {
    //         it.mesure(ctx)
    //         it.décale(décalage_float_right - it.modèle_de_boite.marge.largeur, décalage_y)
    //         décalage_float_right -= it.modèle_de_boite.marge.largeur
    //         hauteur_contenu = max(it.modèle_de_boite.marge.hauteur, hauteur_contenu)
    //     }
    // }

    pour noeud.enfants {
        // float := it.propriétés.donne_valeur_utilisée(IDPropriété.Float)
        // si float.est_mot_clé(PROP_left) {
        //     continue
        // }
        // si float.est_mot_clé(PROP_right) {
        //     continue
        // }

        it.mesure(ctx, mode)

        position := it.propriétés.donne_valeur_utilisée(IDPropriété.Position)
        /* À FAIRE : https://drafts.csswg.org/css-position/#abspos-layout */
        si position.est_mot_clé(PROP_absolute) {
            résoud_pourcentage_insets(it, ctx)

            top := it.propriétés.donne_valeur_utilisée(IDPropriété.Top)
            bottom := it.propriétés.donne_valeur_utilisée(IDPropriété.Bottom)
            left := it.propriétés.donne_valeur_utilisée(IDPropriété.Left)
            right := it.propriétés.donne_valeur_utilisée(IDPropriété.Right)

            si left.est_auto() && right.est_auto() {
                left = ValeurDeStyle(pixels = 0.0)
            }
            sinon si left.est_auto() {
                left = ValeurDeStyle(pixels = -right.pixels)
            }
            sinon saufsi left.est_pixels() {
                left = ValeurDeStyle(pixels = 0.0)
            }

            si top.est_auto() && bottom.est_auto() {
                top = ValeurDeStyle(pixels = 0.0)
            }
            sinon si top.est_auto() {
                top = ValeurDeStyle(pixels = -bottom.pixels)
            }
            sinon saufsi top.est_pixels() {
                top = ValeurDeStyle(pixels = 0.0)
            }

            it.décale(décalage_x + left.pixels comme r32, décalage_y + décalage_hors_float + top.pixels comme r32)
            continue
        }

        hauteur_enfant := it.modèle_de_boite.marge.hauteur

        // marges_enfant := it.marges
        // marge_inter_enfant := max(marges_enfant[BorderEdge.Bottom], dernière_marge)
        // décalage_y := marge_inter_enfant comme r32

        it.décale(décalage_x, décalage_y + décalage_hors_float)

        // dernière_marge = marges_enfant[BorderEdge.Bottom]

        si index_it == 0 {
            hauteur_contenu += hauteur_enfant // + marges[BorderEdge.Top] comme r32
            décalage_hors_float += hauteur_enfant
        }
        sinon si index_it == noeud.enfants.taille - 1 {
            hauteur_contenu += hauteur_enfant // + marges[BorderEdge.Bottom] comme r32
            décalage_hors_float += hauteur_enfant
        }
        sinon {
            hauteur_contenu += hauteur_enfant // + dernière_marge comme r32
            décalage_hors_float += hauteur_enfant
        }
    }

    pour noeud.enfants {
        position := it.propriétés.donne_valeur_utilisée(IDPropriété.Position)
        /* À FAIRE : https://drafts.csswg.org/css-position/#relpos-insets */
        si position.est_mot_clé(PROP_relative) {
            résoud_pourcentage_insets(it, ctx)

            top := it.propriétés.donne_valeur_utilisée(IDPropriété.Top)
            bottom := it.propriétés.donne_valeur_utilisée(IDPropriété.Bottom)
            left := it.propriétés.donne_valeur_utilisée(IDPropriété.Left)
            right := it.propriétés.donne_valeur_utilisée(IDPropriété.Right)

            si left.est_auto() && right.est_auto() {
                left = ValeurDeStyle(pixels = 0.0)
            }
            sinon si left.est_auto() {
                left = ValeurDeStyle(pixels = -right.pixels)
            }

            si top.est_auto() && bottom.est_auto() {
                top = ValeurDeStyle(pixels = 0.0)
            }
            sinon si top.est_auto() {
                top = ValeurDeStyle(pixels = -bottom.pixels)
            }

            it.décale(left.pixels comme r32, top.pixels comme r32)
        }
    }

    noeud.propriétés.définis_valeur_calculée(IDPropriété.Height, ValeurDeStyle(pixels = hauteur_contenu))
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ContexteDeFormattage
 * \{ */

ContexteDeFormattageInline :: struct {
    empl base: ContexteDeFormattage
    sur_formatte = contexte_formattage_inline_sur_formatte

    racine: *NoeudDeDispositionBloc
}

AlignementTexte :: énum {
    Gauche
    Droite
    Centre
    Justifié
}

donne_alignement_texte :: fonc (noeud: *NoeudDeDispositionBloc) -> AlignementTexte
{
    text_align := noeud.propriétés.donne_valeur_utilisée(IDPropriété.TextAlign)

    si text_align.est_mot_clé(PROP_start) {
        retourne AlignementTexte.Gauche
    }

    si text_align.est_mot_clé(PROP_end) {
        retourne AlignementTexte.Droite
    }

    si text_align.est_mot_clé(PROP_left) {
        retourne AlignementTexte.Gauche
    }

    si text_align.est_mot_clé(PROP_right) {
        retourne AlignementTexte.Droite
    }

    si text_align.est_mot_clé(PROP_center) {
        retourne AlignementTexte.Centre
    }

    si text_align.est_mot_clé(PROP_justify) {
        retourne AlignementTexte.Justifié
    }

    retourne AlignementTexte.Gauche
}

contexte_formattage_inline_sur_formatte :: fonc (base: *ContexteDeFormattage, noeud: *NoeudDeDispositionBloc, mode: ModeDeFormattage)
{
    ctx := base comme *ContexteDeFormattageInline

    containing_block := donne_containing_block(noeud, ctx)
    largeur_disponible := containing_block.donne_largeur()

    décalage_x := noeud.modèle_de_boite.contenu.x
    décalage_y := noeud.modèle_de_boite.contenu.y

    enligneuse: Enligneuse
    divise_en_lignes(*enligneuse, noeud, ctx, mode)

    hauteur_contenu := 0.0

    alignement := donne_alignement_texte(noeud)
    si ctx.doit_aligner_les_descendants.possède_valeur() {
        alignement = ctx.doit_aligner_les_descendants.Quelque
    }

    lignes_tenante := *noeud.lignes_tenante

    pour lignes_tenante.lignes {
        hauteur := it.hauteur_contenu
        décalage_pour_alignement := 0.0

        fragments := donne_fragments_ligne(lignes_tenante, *it)

        si fragments.taille == 0 {
            hauteur_contenu += hauteur
            décalage_y += hauteur
            continue
        }

        si alignement == AlignementTexte.Droite {
            décalage_pour_alignement = largeur_disponible - it.largeur_courante
        }
        sinon si alignement == AlignementTexte.Centre {
            décalage_pour_alignement = (largeur_disponible - it.largeur_courante) / 2.0
        }
        sinon si alignement == AlignementTexte.Justifié {
            /* À FAIRE : ignore l'espace finale. */
            décalage_pour_alignement = (largeur_disponible - it.largeur_courante) / ((fragments.taille - 1) comme r32)
        }

        pour * fragment, index_fragment dans fragments {
            si alignement == AlignementTexte.Justifié {
                si index_fragment != 0 && index_it != (lignes_tenante.lignes.taille - 1) {
                    fragment.x += décalage_pour_alignement * (index_fragment comme r32)
                }
            }
            sinon {
                fragment.x += décalage_pour_alignement
            }

            fragment.y = décalage_y
        }

        // pour * fragment dans it.fragments {
        //     noeud_fragment := fragment.noeud
        //     propriétés_noeud_fragment := donne_propriétés(noeud_fragment)
        //     vertical_align := propriétés_noeud_fragment.donne_valeur_utilisée(IDPropriété.VerticalAlign)
        //     imprime("vertical-align: % (% | %)\n", vertical_align, fragment.hauteur, hauteur)

        //     si vertical_align.est_mot_clé(PROP_bottom) || vertical_align.est_mot_clé(PROP_baseline) {
        //         si fragment.hauteur < hauteur {
        //             fragment.y += (hauteur - fragment.hauteur)
        //         }
        //     }
        //     sinon si vertical_align.est_mot_clé(PROP_top) {
        //         si fragment.hauteur < hauteur {
        //             fragment.y = (hauteur - fragment.hauteur)
        //         }
        //     }
        // }

        hauteur_contenu += hauteur
        décalage_y += hauteur
    }

    incrémente_hauteur_contenu(noeud.modèle_de_boite, hauteur_contenu)

    si décalage_x != 0.0 || décalage_y != 0.0 {
        pour * noeud.lignes_tenante.fragments {
            it.x += décalage_x
        }
    }
}

/** \} */
