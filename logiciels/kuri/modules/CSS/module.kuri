importe Chaine
importe Internet

charge "lexage"
charge "parsage"

lèxe_style :: fonc (contenu: chaine) -> [..]Lexème
{
    chn := crée_chaine_utf32(contenu)
    diffère détruit_chaine(chn)

    prétraite(chn)

    lexeuse: Lexeuse
    lexeuse.contenu = chn

    lexèmes: [..]Lexème

    tantque !fini(lexeuse) {
        lexème := consomme_un_lexème(lexeuse)
        tableau_ajoute(*lexèmes, lexème)
    }

    retourne lexèmes
}

/* 3.3. Preprocessing the input stream
 * https://www.w3.org/TR/css-syntax-3/#input-preprocessing */
prétraite :: fonc (chn: &ChaineUTF32)
{
    CARRIAGE_RETURN : n32 : 0x0D
    FORM_FEED : n32 : 0x0C
    LINE_FEED : n32 : 0x0A
    
    pour & chn.points_de_code {
        /* À FAIRE : \r\n => \n */
        si it == CARRIAGE_RETURN || it == FORM_FEED {
            it = LINE_FEED
        }
    }
}

/* ------------------------------------------------------------------------- */
/** \nom StyleSheet
 * https://www.w3.org/TR/cssom-1/#css-style-sheets
 * \{ */

StyleSheet :: struct {
    type := "text/css"
    location: URI
    rules: [..]*Rule
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Rule
 * https://www.w3.org/TR/cssom-1/#css-rules
 * \{ */

Rule :: struct {

}

/** \} */


/*
SelectorsGroup :: struct {
    selectors: [..]Selector
}

Combinator :: énum {
    ESPACE  // " "
    PLUS    // "+"
    PLUS_GRAND // ">"
    TILDE // "~"
}

Selector :: struct {
    simple_selector_sequence: [..]SimpleSelector
    combinators: [..]Combinator
}


SimpleSelector :: struct {
    Type :: énum {
        Type
        Universal
        ID
        Class
        Attrib
        PseudoElement
        PseudoClass
        Negation
    }

    namespace_prefix: chaine
    ident: chaine
}

ParseuseSelector :: struct {

}

parse_selectors_group :: fonc (parseuse: *ParseuseSelector) -> Optionnel(SelectorsGroup)
{
    selector := parse_selector(parseuse)


}

parse_selector :: fonc (parseuse: *ParseuseSelector) -> Optionnel(Selector)
{
    sequence := parse_simple_selector_sequence(parseuse)
}

parse_simple_selector_sequence :: fonc (parseuse: *ParseuseSelector) -> Optionnel([..]SimpleSelector)
{

}


selectors_group
  : selector [ COMMA S* selector ]*
  ;

selector
  : simple_selector_sequence [ combinator simple_selector_sequence ]*
  ;

combinator
  /* combinators can be surrounded by whitespace */
  : PLUS S* | GREATER S* | TILDE S* | S+
  ;

simple_selector_sequence
  : [ type_selector | universal ]
    [ HASH | class | attrib | pseudo | negation ]*
  | [ HASH | class | attrib | pseudo | negation ]+
  ;

type_selector
  : [ namespace_prefix ]? element_name
  ;

namespace_prefix
  : [ IDENT | '*' ]? '|'
  ;

element_name
  : IDENT
  ;

universal
  : [ namespace_prefix ]? '*'
  ;

class
  : '.' IDENT
  ;

attrib
  : '[' S* [ namespace_prefix ]? IDENT S*
        [ [ PREFIXMATCH |
            SUFFIXMATCH |
            SUBSTRINGMATCH |
            '=' |
            INCLUDES |
            DASHMATCH ] S* [ IDENT | STRING ] S*
        ]? ']'
  ;

pseudo
  /* '::' starts a pseudo-element, ':' a pseudo-class */
  /* Exceptions: :first-line, :first-letter, :before and :after. */
  /* Note that pseudo-elements are restricted to one per selector and */
  /* occur only in the last simple_selector_sequence. */
  : ':' ':'? [ IDENT | functional_pseudo ]
  ;

functional_pseudo
  : FUNCTION S* expression ')'
  ;

expression
  /* In CSS3, the expressions are identifiers, strings, */
  /* or of the form "an+b" */
  : [ [ PLUS | '-' | DIMENSION | NUMBER | STRING | IDENT ] S* ]+
  ;

negation
  : NOT S* negation_arg S* ')'
  ;

negation_arg
  : type_selector | universal | HASH | class | attrib | pseudo
  ;



*/