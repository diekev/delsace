charge "lexage"

importe Fondation

TypeNoeud :: énum z32 {
	CHAINE_CARACTÈRE
	VARIABLE
	BLOC
	POUR
	SI
}

NoeudSyntaxique :: struct {
    type : TypeNoeud
    données : DonnéesLexème
    enfants : []*NoeudSyntaxique
}

détruit_noeud :: fonc(noeud : *NoeudSyntaxique) -> rien
{
    déloge noeud.enfants
    déloge noeud
}

ajoute_noeud :: fonc(noeud : *NoeudSyntaxique, enfant : *NoeudSyntaxique) -> rien
{
    tableau_ajoute(@noeud.enfants, enfant)
}

lexème :: fonc(noeud : *NoeudSyntaxique) -> TypeLexème
{
    retourne noeud.données.type_lexème
}

//##############################################################################

PileNoeud :: struct {
    données : []*NoeudSyntaxique
    curseur := 0
}

détruit :: fonc(pile : &PileNoeud) -> rien
{
    déloge pile.données
}

empile :: fonc(pile : &PileNoeud, noeud : *NoeudSyntaxique) -> rien
{
    si pile.curseur == pile.données.taille {
        taille := pile.données.taille
        reloge pile.données : [taille + 1]*NoeudSyntaxique
    }

    pile.données[pile.curseur] = noeud
    pile.curseur += 1
}

dépile :: fonc(pile : &PileNoeud) -> *NoeudSyntaxique
{
    ret := pile.haut()
    pile.curseur -= 1
    retourne ret
}

haut :: fonc(pile : &PileNoeud) -> *NoeudSyntaxique
{
    retourne pile.données[pile.curseur - 1]
}

taille :: fonc(pile : &PileNoeud) -> z32
{
    retourne pile.curseur
}

est_vide :: fonc(pile : &PileNoeud) -> bool
{
    retourne pile.curseur == 0
}

//##############################################################################

AssembleuseArbre :: struct {
    noeuds : []*NoeudSyntaxique
    pile : PileNoeud
}

construit_assembleuse :: fonc() -> AssembleuseArbre
{
	assembleuse : AssembleuseArbre
    retourne assembleuse
}

détruit_assembleuse :: fonc(assembleuse : &AssembleuseArbre) -> rien
{
    pour noeud dans assembleuse.noeuds {
        détruit_noeud(noeud)
    }

    déloge assembleuse.noeuds

    détruit(assembleuse.pile)
}

empile_noeud :: fonc(
    assembleuse : &AssembleuseArbre,
    type_noeud : TypeNoeud,
    données : &DonnéesLexème) -> *NoeudSyntaxique
{
	noeud := assembleuse.crée_noeud(type_noeud, données)

	si (!assembleuse.pile.est_vide()) {
		assembleuse.pile.haut().ajoute_noeud(noeud)
	}

	assembleuse.pile.empile(noeud)

	retourne noeud
}

ajoute_noeud :: fonc(
    assembleuse : &AssembleuseArbre,
    type_noeud : TypeNoeud,
    données : &DonnéesLexème) -> rien
{
	noeud := assembleuse.crée_noeud(type_noeud, données)
	assembleuse.pile.haut().ajoute_noeud(noeud)
}

crée_noeud :: fonc(
    assembleuse : &AssembleuseArbre,
    type_noeud : TypeNoeud,
    données : &DonnéesLexème) -> *NoeudSyntaxique
{
	noeud := loge NoeudSyntaxique
    noeud.type = type_noeud
    noeud.données = données
    noeud.enfants.taille = 0
    noeud.enfants.pointeur = nul

    tableau_ajoute(@assembleuse.noeuds, noeud)

	retourne noeud
}

dépile_noeud :: fonc(assembleuse : &AssembleuseArbre, type_noeud : TypeNoeud) -> rien
{
	assembleuse.attend_type(type_noeud)
	assembleuse.pile.dépile()
}

attend_type :: fonc(assembleuse : &AssembleuseArbre, type_noeud : TypeNoeud) -> rien
{
	assert(assembleuse.pile.haut().type == type_noeud)
}
