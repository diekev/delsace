importe Fondation // pour imprime_valeur
importe Tori

// À FAIRE: ajout d'un message aux erreurs
ErreurGénérationPage :: énum z32 {
    AUCUNE
    OBJET_NON_ITÉRABLE
    OBJET_NON_TROUVÉ
}

génère_page :: fonc(
    noeud: *NoeudSyntaxique,
    gestionnaire: *GestionnaireObjet,
    dico: *ObjetDictionnaire,
    enchaineuse: *Enchaineuse) -> ErreurGénérationPage
{
    discr noeud.type {
        BLOC {
            pour enfant dans noeud.enfants {
                erreur_ := génère_page(enfant, gestionnaire, dico, enchaineuse)

                si erreur_ != ErreurGénérationPage.AUCUNE {
                    retourne erreur_
                }
            }
        }
        CHAINE_CARACTÈRE {
            ajoute_au_tampon(enchaineuse, noeud.données.chn)
        }
        VARIABLE {
            variable := noeud.données.chn
            objet_variable := dico.trouve_objet(variable)

            si objet_variable == nul {
                retourne ErreurGénérationPage.OBJET_NON_TROUVÉ
            }

            discr objet_variable.id {
                NUL {
                    ajoute_au_tampon(enchaineuse, "nul")
                }
                CHAINE {
                    objet_chaine := objet_variable comme *ObjetChaine
                    ajoute_au_tampon(enchaineuse, objet_chaine.valeur)
                }
                ENTIER {
                    objet_nombre := objet_variable comme *ObjetEntier
                    ajoute_au_tampon(enchaineuse, objet_nombre.valeur)
                }
                RÉEL {
                    objet_nombre := objet_variable comme *ObjetRéel
                    ajoute_au_tampon(enchaineuse, objet_nombre.valeur)
                }
                LISTE,
                DICTIONNAIRE {
                    ajoute_au_tampon(enchaineuse, "objet à ")
                    ajoute_au_tampon(enchaineuse, objet_variable)
                }
            }
        }
        POUR {
            propriete := noeud.enfants[1].données.chn
            objet_iter := dico.trouve_objet(propriete)

            si objet_iter == nul {
                retourne ErreurGénérationPage.OBJET_NON_TROUVÉ
            }

            variable := noeud.enfants[0].données.chn

            discr objet_iter.id {
                NUL {
                    ajoute_au_tampon(enchaineuse, "Objet nul n'est pas itérable !")
                    retourne ErreurGénérationPage.OBJET_NON_ITÉRABLE
                }
                CHAINE {
                    ajoute_au_tampon(enchaineuse, "Objet chaine n'est pas itérable !")
                    retourne ErreurGénérationPage.OBJET_NON_ITÉRABLE
                }
                ENTIER {
                    ajoute_au_tampon(enchaineuse, "Objet nombre entier n'est pas itérable !")
                    retourne ErreurGénérationPage.OBJET_NON_ITÉRABLE
                }
                RÉEL {
                    ajoute_au_tampon(enchaineuse, "Objet nombre réel n'est pas itérable !")
                    retourne ErreurGénérationPage.OBJET_NON_ITÉRABLE
                }
                LISTE {
                    liste := objet_iter comme *ObjetListe

                    pour objet dans liste.valeur {
                        dico.insère(variable, objet)
                        erreur_ := génère_page(noeud.enfants[2], gestionnaire, dico, enchaineuse)

                        si erreur_ != ErreurGénérationPage.AUCUNE {
                            retourne erreur_
                        }
                    }
                }
                DICTIONNAIRE {
                    dictionnaire := objet_iter comme *ObjetDictionnaire

                    pour nom, idx dans dictionnaire.noms {
                        objet_nom := gestionnaire.crée_chaine()
                        objet_nom.valeur = nom

                        dico.insère(variable, objet_nom)
                        erreur_ := génère_page(noeud.enfants[2], gestionnaire, dico, enchaineuse)

                        si erreur_ != ErreurGénérationPage.AUCUNE {
                            retourne erreur_
                        }
                    }
                }
            }
        }
        SI {
            variable := noeud.enfants[0].données.chn
            objet_valeur := dico.trouve_objet(variable)

            si objet_valeur != nul {
                erreur_ := génère_page(noeud.enfants[1], gestionnaire, dico, enchaineuse)

                si erreur_ != ErreurGénérationPage.AUCUNE {
                    retourne erreur_
                }
            }
            sinon si noeud.enfants.taille > 2 {
                erreur_ := génère_page(noeud.enfants[2], gestionnaire, dico, enchaineuse)

                si erreur_ != ErreurGénérationPage.AUCUNE {
                    retourne erreur_
                }
            }
        }
        ACCÈS_MEMBRE {
            // non-implémenté
        }
    }

    retourne ErreurGénérationPage.AUCUNE
}

trouve_membre :: fonc (valeur: eini, nom_membre: chaine) -> *InfoTypeMembreStructure
{
    saufsi valeur.est_structure() {
        retourne nul
    }

    info := valeur.info comme *InfoTypeStructure

    pour info.membres {
        si it.nom == nom_membre {
            retourne membre
        }
    }

    retourne nul
}

valeur_membre :: fonc (valeur: eini, nom_membre: chaine) -> eini
{
    résultat : eini

    si valeur.est_chaine() {
        si nom_membre == "taille" {
            résultat.pointeur = valeur.pointeur + 8
            résultat.info = info_de(z64)
            retourne résultat
        }
    }

    saufsi valeur.est_structure() {
        retourne résultat
    }

    info := valeur.info comme *InfoTypeStructure

    pour info.membres {
        si it.nom == nom_membre {
            résultat.pointeur = valeur.pointeur + it.décalage
            résultat.info = it.id
            retourne résultat
        }
    }

    retourne résultat
}

DonnéesGénération :: struct {
    valeur : eini
    nom_variable_boucle : chaine
    données_variable_boucle : eini
}

trouve_variable :: fonc (données: *DonnéesGénération, nom: chaine) -> eini
{
    valeur := valeur_membre(données.valeur, nom)

    si valeur.est_valide() {
        retourne valeur
    }

    si nom == données.nom_variable_boucle {
        retourne données.données_variable_boucle
    }

    /* la valeur est invalide, donc nous pouvons sûrement la retourner */
    retourne valeur
}

génère_page :: fonc(
    données: *DonnéesGénération,
    noeud: *NoeudSyntaxique,
    enchaineuse: *Enchaineuse) -> ErreurGénérationPage
{
    discr noeud.type {
        BLOC {
            pour enfant dans noeud.enfants {
                erreur_ := génère_page(données, enfant, enchaineuse)

                si erreur_ != ErreurGénérationPage.AUCUNE {
                    retourne erreur_
                }
            }
        }
        CHAINE_CARACTÈRE {
            ajoute_au_tampon(enchaineuse, noeud.données.chn)
        }
        VARIABLE {
            variable := noeud.données.chn
            valeur := trouve_variable(données, variable)

            saufsi valeur.est_valide() {
                retourne ErreurGénérationPage.OBJET_NON_TROUVÉ
            }

            imprime_valeur(enchaineuse, valeur.pointeur, valeur.info, faux)
        }
        POUR {
            propriété := noeud.enfants[1].données.chn
            valeur := trouve_variable(données, propriété)

            saufsi valeur.est_valide() {
                retourne ErreurGénérationPage.OBJET_NON_TROUVÉ
            }

            variable := noeud.enfants[0].données.chn

            si valeur.est_tableau() {
                itératrice := crée_itératrice_tableau(valeur)

                boucle {
                    valeur_ := itératrice.valeur_suivante()

                    saufsi valeur_.est_valide() {
                        arrête
                    }

                    données.nom_variable_boucle = variable
                    données.données_variable_boucle = valeur_

                    erreur_ := génère_page(données, noeud.enfants[2], enchaineuse)

                    si erreur_ != ErreurGénérationPage.AUCUNE {
                        retourne erreur_
                    }
                }
            }
            sinon {
                ajoute_au_tampon(enchaineuse, "Objet nul n'est pas itérable !")
                retourne ErreurGénérationPage.OBJET_NON_ITÉRABLE
            }
        }
        SI {
            variable := noeud.enfants[0].données.chn
            valeur := trouve_variable(données, variable)

            idx_enfant := 0

            si évalue_condition(valeur) {
                idx_enfant = 1
            }
            sinon si noeud.enfants.taille > 2 {
                idx_enfant = 2
            }

            erreur_ := génère_page(données, noeud.enfants[idx_enfant], enchaineuse)

            si erreur_ != ErreurGénérationPage.AUCUNE {
                retourne erreur_
            }
        }
        ACCÈS_MEMBRE {
            valeur := trouve_valeur_pour_expression(données, noeud)

            saufsi valeur.est_valide() {
                retourne ErreurGénérationPage.OBJET_NON_TROUVÉ
            }

            imprime_valeur(enchaineuse, valeur.pointeur, valeur.info, faux)
        }
    }

    retourne ErreurGénérationPage.AUCUNE
}

évalue_condition :: fonc (valeur: eini) -> bool
{
    saufsi valeur.est_valide() {
        retourne faux
    }

    si valeur.est_bool() {
        retourne valeur.comme_bool()
    }

    si valeur.est_chaine() {
        retourne valeur.comme_chaine() != ""
    }

    retourne faux
}

trouve_valeur_pour_expression :: fonc (données: *DonnéesGénération, noeud: *NoeudSyntaxique) -> eini
{
    résultat : eini

    discr noeud.type {
        VARIABLE {
            variable := noeud.données.chn
            résultat = trouve_variable(données, variable)
        }
        ACCÈS_MEMBRE {
            accédé := noeud.enfants[0]
            membre := noeud.enfants[1].données.chn

            valeur_accédée := trouve_valeur_pour_expression(données, accédé)

            saufsi valeur_accédée.est_valide() {
                retourne résultat
            }

            résultat = valeur_membre(valeur_accédée, membre)
        }
        sinon {
            // mauvais type de neoud
        }
    }

    retourne résultat
}

// À FAIRE(langage) : surcharge opérateur ! pour eini
est_valide :: fonc (valeur: eini) -> bool
{
    retourne valeur.pointeur != nul
}

est_bool :: fonc (valeur: eini) -> bool
{
    retourne valeur.info.id == id_info.BOOLÉEN
}

est_chaine :: fonc (valeur: eini) -> bool
{
    retourne valeur.info.id == id_info.CHAINE
}

est_structure :: fonc (valeur: eini) -> bool
{
    retourne valeur.info.id == id_info.STRUCTURE
}

est_tableau :: fonc (valeur: eini) -> bool
{
    retourne valeur.info.id == id_info.TABLEAU
}

comme_bool :: fonc (valeur: eini) -> bool
{
    retourne mémoire(valeur.pointeur comme *bool)
}

comme_chaine :: fonc (valeur: eini) -> chaine
{
    retourne mémoire(valeur.pointeur comme *chaine)
}

ItératriceTableau :: struct {
    valeur: eini

    pointeur: *z8
    taille: z64

    position: z64

    type_pointé : *InfoType

    décalage : z32
}

crée_itératrice_tableau :: fonc (valeur: eini) -> ItératriceTableau
{
    itératrice : ItératriceTableau

    saufsi valeur.est_valide() {
        retourne itératrice
    }

    saufsi valeur.est_tableau() {
        retourne itératrice
    }

    info_tableau := valeur.info comme *InfoTypeTableau
    type_pointé := info_tableau.type_pointé
    décalage := type_pointé.taille_en_octet comme z32

    si info_tableau.est_tableau_fixe {
        itératrice.pointeur = valeur.pointeur
        itératrice.taille = info_tableau.taille_fixe
    }
    sinon {
        x := mémoire(valeur.pointeur comme *[]z8)

        itératrice.pointeur = x.pointeur
        itératrice.taille = x.taille
    }

    itératrice.valeur = valeur
    itératrice.type_pointé = type_pointé
    itératrice.décalage = décalage

    retourne itératrice
}

valeur_suivante :: fonc (itératrice: &ItératriceTableau) -> eini
{
    résultat : eini

    si itératrice.position >= itératrice.taille {
        retourne résultat
    }

    résultat.pointeur = itératrice.pointeur + itératrice.décalage * itératrice.position
    résultat.info = itératrice.type_pointé

    itératrice.position += 1

    retourne résultat
}
