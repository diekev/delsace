importe Fondation // pour imprime_valeur
importe Tori

charge "assemblage_arbre"
charge "lexage"
charge "syntaxage"

// À FAIRE: ajout d'un message aux erreurs
ErreurGénérationPage :: énum z32 {
    AUCUNE
    OBJET_NON_ITÉRABLE
    OBJET_NON_TROUVÉ
}

génère_page :: fonc(
    noeud: *NoeudSyntaxique,
    dyn gestionnaire: *GestionnaireObjet,
    dyn dico: *ObjetDictionnaire,
    enchaineuse: *Enchaineuse) -> ErreurGénérationPage
{
    discr noeud.type {
        BLOC {
            pour enfant dans noeud.enfants {
                erreur := génère_page(enfant, gestionnaire, dico, enchaineuse)

                si erreur != ErreurGénérationPage.AUCUNE {
                    retourne erreur
                }
            }
        }
        CHAINE_CARACTÈRE {
            ajoute_au_tampon(enchaineuse, noeud.données.chn)
        }
        VARIABLE {
            variable := noeud.données.chn
            objet_variable := dico.trouve_objet(variable)

            si objet_variable == nul {
                retourne ErreurGénérationPage.OBJET_NON_TROUVÉ
            }

            discr objet_variable.id {
                NUL {
                    ajoute_au_tampon(enchaineuse, "nul")
                }
                CHAINE {
                    objet_chaine := transtype(objet_variable : *ObjetChaine)
                    ajoute_au_tampon(enchaineuse, objet_chaine.valeur)
                }
                ENTIER {
                    objet_nombre := transtype(objet_variable : *ObjetEntier)
                    ajoute_au_tampon(enchaineuse, objet_nombre.valeur)
                }
                RÉEL {
                    objet_nombre := transtype(objet_variable : *ObjetRéel)
                    ajoute_au_tampon(enchaineuse, objet_nombre.valeur)
                }
                LISTE,
                DICTIONNAIRE {
                    ajoute_au_tampon(enchaineuse, "objet à ")
                    ajoute_au_tampon(enchaineuse, objet_variable)
                }
            }
        }
        POUR {
            propriete := noeud.enfants[1].données.chn
            objet_iter := dico.trouve_objet(propriete)

            si objet_iter == nul {
                retourne ErreurGénérationPage.OBJET_NON_TROUVÉ
            }

            variable := noeud.enfants[0].données.chn

            discr objet_iter.id {
                NUL {
                    ajoute_au_tampon(enchaineuse, "Objet nul n'est pas itérable !")
                    retourne ErreurGénérationPage.OBJET_NON_ITÉRABLE
                }
                CHAINE {
                    ajoute_au_tampon(enchaineuse, "Objet chaine n'est pas itérable !")
                    retourne ErreurGénérationPage.OBJET_NON_ITÉRABLE
                }
                ENTIER {
                    ajoute_au_tampon(enchaineuse, "Objet nombre entier n'est pas itérable !")
                    retourne ErreurGénérationPage.OBJET_NON_ITÉRABLE
                }
                RÉEL {
                    ajoute_au_tampon(enchaineuse, "Objet nombre réel n'est pas itérable !")
                    retourne ErreurGénérationPage.OBJET_NON_ITÉRABLE
                }
                LISTE {
                    liste := transtype(objet_iter : *ObjetListe)

                    pour objet dans liste.valeur {
                        dico.insère(variable, objet)
                        erreur := génère_page(noeud.enfants[2], gestionnaire, dico, enchaineuse)

                        si erreur != ErreurGénérationPage.AUCUNE {
                            retourne erreur
                        }
                    }
                }
                DICTIONNAIRE {
                    dictionnaire := transtype(objet_iter : *ObjetDictionnaire)

                    pour nom, idx dans dictionnaire.noms {
                        dyn objet_nom := gestionnaire.crée_chaine()
                        objet_nom.valeur = nom

                        dico.insère(variable, transtype(objet_nom : *Objet))
                        erreur := génère_page(noeud.enfants[2], gestionnaire, dico, enchaineuse)

                        si erreur != ErreurGénérationPage.AUCUNE {
                            retourne erreur
                        }
                    }
                }
            }
        }
        SI {
            variable := noeud.enfants[0].données.chn
            objet_valeur := dico.trouve_objet(variable)

            si objet_valeur != nul {
                erreur := génère_page(noeud.enfants[1], gestionnaire, dico, enchaineuse)

                si erreur != ErreurGénérationPage.AUCUNE {
                    retourne erreur
                }
            }
            sinon si noeud.enfants.taille > 2 {
                erreur := génère_page(noeud.enfants[2], gestionnaire, dico, enchaineuse)

                si erreur != ErreurGénérationPage.AUCUNE {
                    retourne erreur
                }
            }
        }
    }

    retourne ErreurGénérationPage.AUCUNE
}

trouve_membre :: fonc (valeur: eini, nom_membre: chaine) -> *InfoTypeMembreStructure
{
    info := valeur.info

    si info.id != id_info.STRUCTURE {
        retourne nul
    }

    info_struct := transtype(info: *InfoTypeStructure)

    pour membre dans info_struct.membres {
        si membre.nom == nom_membre {
            retourne membre
        }
    }

    retourne nul
}

DonnéesGénération :: struct {
    valeur : eini
    nom_variable_boucle : chaine
    données_variable_boucle : eini
}

trouve_variable :: fonc (données: *DonnéesGénération, nom: chaine) -> eini
{
    info_membre := trouve_membre(données.valeur, nom)

    si info_membre != nul {
        dyn e: eini
        e.pointeur = données.valeur.pointeur + info_membre.décalage
        e.info = info_membre.id
        retourne e
    }

    si nom == données.nom_variable_boucle {
        retourne données.données_variable_boucle
    }

    dyn e: eini
    retourne e
}

génère_page :: fonc(
    dyn données: *DonnéesGénération,
    noeud: *NoeudSyntaxique,
    enchaineuse: *Enchaineuse) -> ErreurGénérationPage
{
    discr noeud.type {
        BLOC {
            pour enfant dans noeud.enfants {
                erreur := génère_page(données, enfant, enchaineuse)

                si erreur != ErreurGénérationPage.AUCUNE {
                    retourne erreur
                }
            }
        }
        CHAINE_CARACTÈRE {
            ajoute_au_tampon(enchaineuse, noeud.données.chn)
        }
        VARIABLE {
            variable := noeud.données.chn
            valeur := trouve_variable(données, variable)

            si valeur.pointeur == nul {
                retourne ErreurGénérationPage.OBJET_NON_TROUVÉ
            }

            imprime_valeur(enchaineuse, valeur.pointeur, valeur.info, faux)
        }
        POUR {
            propriété := noeud.enfants[1].données.chn
            valeur := trouve_variable(données, propriété)

            si valeur.pointeur == nul {
                retourne ErreurGénérationPage.OBJET_NON_TROUVÉ
            }

            variable := noeud.enfants[0].données.chn

            discr valeur.info.id  {
                TABLEAU {
                    pointeur := valeur.pointeur

                    info_arg := transtype(valeur.info : *InfoTypeTableau)
                    décalage := transtype(info_arg.type_pointé.taille_en_octet: z32)

                    si info_arg.est_tableau_fixe {
                        pour i dans 0 ... info_arg.taille_fixe - 1 {
                            données.nom_variable_boucle = variable

                            dyn e : eini
                            e.pointeur = pointeur + décalage * i
                            e.info = info_arg.type_pointé

                            données.données_variable_boucle = e

                            erreur := génère_page(données, noeud.enfants[2], enchaineuse)

                            si erreur != ErreurGénérationPage.AUCUNE {
                                retourne erreur
                            }
                        }
                    }
                    sinon {
                        x := mémoire(transtype(pointeur: *[]z8))

                        pour i dans 0 ... x.taille - 1 {
                            données.nom_variable_boucle = variable

                            dyn e : eini
                            e.pointeur = pointeur + décalage * i
                            e.info = info_arg.type_pointé

                            données.données_variable_boucle = e

                            erreur := génère_page(données, noeud.enfants[2], enchaineuse)

                            si erreur != ErreurGénérationPage.AUCUNE {
                                retourne erreur
                            }
                        }
                    }
                }
                STRUCTURE {
                    // itération sur les membres
                }
                sinon {
                    ajoute_au_tampon(enchaineuse, "Objet nul n'est pas itérable !")
                    retourne ErreurGénérationPage.OBJET_NON_ITÉRABLE
                }
            }
        }
        SI {
            variable := noeud.enfants[0].données.chn
            valeur := trouve_variable(données, variable)

            dyn idx_enfant := 0

            si valeur.pointeur != nul {
                idx_enfant = 1
            }
            sinon si noeud.enfants.taille > 2 {
                idx_enfant = 2
            }

            erreur := génère_page(données, noeud.enfants[idx_enfant], enchaineuse)

            si erreur != ErreurGénérationPage.AUCUNE {
                retourne erreur
            }
        }
    }

    retourne ErreurGénérationPage.AUCUNE
}
