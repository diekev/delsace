importe Fondation

charge "catalogue_fichier"

RendeusePage :: struct {
    catalogue : CatalogueFichier
    cache_page : []PageGabarit
}

détruit_rendeuse :: fonc (rendeuse_gabarit: *RendeusePage) -> rien
{
    pour page dans rendeuse_gabarit.cache_page {
        détruit_page_gabarit(*page)
    }

    détruit_catalogue(*rendeuse_gabarit.catalogue)

    déloge rendeuse_gabarit.cache_page
}

PageGabarit :: struct {
    fichier : *FichierTexte
    lexeuse : Lexeuse
    syntaxeuse : Syntaxeuse
    racine : *NoeudSyntaxique
}

détruit_page_gabarit :: fonc (page : *PageGabarit) -> rien
{
    détruit_lexeuse(page.lexeuse)
    détruit_assembleuse(page.syntaxeuse.assembleuse)
}

trouve_dans_cache :: fonc (rendeuse_gabarit: *RendeusePage, nom_court: chaine) -> *PageGabarit
{
    pour page dans rendeuse_gabarit.cache_page {
        si page.fichier.nom_court == nom_court {
            retourne *page
        }
    }

    fichier := trouve_fichier(*rendeuse_gabarit.catalogue, nom_court)

    si fichier == nul {
        retourne nul
    }

    si fichier.données.taille == 0 {
        commence_fichier(fichier)
    }

    si fichier.succès == faux {
        retourne nul
    }

    lexeuse := construit_lexeuse(fichier.données)
    lexeuse.performe_lexage()

    syntaxeuse := construit_syntaxeuse(lexeuse.lexèmes)
    syntaxeuse.performe_syntaxage()

    si syntaxeuse.erreurs {
        retourne nul
    }

    racine := syntaxeuse.assembleuse.pile.haut()

    si syntaxeuse.est_extension {
        page_étendue := trouve_dans_cache(rendeuse_gabarit, syntaxeuse.fichier_étendu)

        // À FAIRE : indique que la base parente est manquante
        si page_étendue == nul {
            retourne nul
        }

        nouvelle_racine := copie_noeud(syntaxeuse.assembleuse, page_étendue.racine)

        blocs : []*NoeudSyntaxique
        rassemble_blocs(racine, *blocs)
        remplace_blocs(nouvelle_racine, blocs)
        déloge blocs

        racine = nouvelle_racine
    }

    page : PageGabarit
    page.fichier = fichier
    page.lexeuse = lexeuse
    page.syntaxeuse = syntaxeuse
    page.racine = racine

    tableau_ajoute(*rendeuse_gabarit.cache_page, page)

    retourne *rendeuse_gabarit.cache_page[rendeuse_gabarit.cache_page.taille - 1]
}

rassemble_blocs :: fonc (racine: *NoeudSyntaxique, blocs: *[]*NoeudSyntaxique)
{
    si racine.type == TypeNoeud.BLOC && racine.nom != "" {
        tableau_ajoute(blocs, racine)
    }

    pour racine.enfants {
        rassemble_blocs(it, blocs)
    }
}

/* Travarse l'arbre de la nouvelle_racine et remplace les blocs ayant les mêmes noms que ceux données par ces derniers.
 * Si plusieurs blocs du noeud racine ont le même nom, il seront remplacés par le même bloc d'origine.
 * À FAIRE : vérifie que tous les blocs ont été assignés ?
 */
remplace_blocs :: fonc (nouvelle_racine: *NoeudSyntaxique, blocs: []*NoeudSyntaxique)
{
    saufsi blocs {
        retourne
    }

    pour nouvelle_racine.enfants {
        si it.type == TypeNoeud.BLOC && it.nom != "" {
            pour bloc dans blocs {
                si it.nom == bloc.nom {
                    it = bloc
                    arrête
                }
            }

            continue
        }

        remplace_blocs(it, blocs)
    }
}

ErreurRenduPage :: erreur {
    PageManquante
    RenduImpossible
}

ChaineOuErreur :: union {
    c: chaine
    e: ErreurRenduPage
}

rends_page :: fonc (rendeuse_gabarit: *RendeusePage, nom_court: chaine, données: eini) -> ChaineOuErreur
{
    //temps_présent := compte_ticks_microsecondes()
    //diffère { imprime_log("", "Durée rendu gabarit : %µs", compte_ticks_microsecondes() - temps_présent) }


    page := trouve_dans_cache(rendeuse_gabarit, nom_court)

    si page == nul {
        retourne ErreurRenduPage.PageManquante
    }

    données_génération : DonnéesGénération
    données_génération.valeur = données

    enchaineuse : Enchaineuse
	initialise_enchaineuse(*enchaineuse)
    diffère { détruit_tampons(*enchaineuse) }

    erreur_ := génère_page(*données_génération, page.racine, *enchaineuse)

    si erreur_ != ErreurGénérationPage.AUCUNE {
        retourne ErreurRenduPage.RenduImpossible
    }

    retourne chaine_depuis_enchaineuse(*enchaineuse)
}
