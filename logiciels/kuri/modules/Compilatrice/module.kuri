// Bibliothèque pour faire le pont entre le Compilateur et le programme compilé

// ----------------------------------------------------------------------------

// Ces structures doivent être tenues synchronisées avec celles dans options.hh
TypeCoulisse :: énum z32 {
    C
    LLVM
}

ArchitectureCible :: énum z32 {
    X64
    X86
}

NiveauOptimisation :: énum z32 {
    AUCUN
	O0
	O1
	O2
	Os
	Oz
	O3
}

OptionsLangage :: énum_drapeau z32 {
    ACTIVE_INTROSPECTION
    ACTIVE_COROUTINE

	//TOUT :: (ACTIVE_COROUTINE | ACTIVE_INTROSPECTION)
}

OptionsCompilation :: struct {
    nom_sortie := "a.out"
    type_coulisse := TypeCoulisse.C
    niveau_optimisation := NiveauOptimisation.AUCUN
    architecture_cible := ArchitectureCible.X64
    options_langage : OptionsLangage

    crée_exécutable := vrai
    émets_métriques := vrai
}

// ----------------------------------------------------------------------------
// structures pour l'arbre syntaxique des programmes, à tenir synchronisé avec noeud_code.hh
// GenreNoeudCode est une copie carbone de l'énumération de arbre_syntaxique.hh

GenreNoeudCode :: énum z32 {
    DECLARATION_COROUTINE
	DECLARATION_ENUM
	DECLARATION_FONCTION
	DECLARATION_OPERATEUR
	DECLARATION_STRUCTURE
	DECLARATION_VARIABLE
	DIRECTIVE_EXECUTION
	EXPRESSION_APPEL_FONCTION
	EXPRESSION_ASSIGNATION_VARIABLE
	EXPRESSION_CONSTRUCTION_STRUCTURE
	EXPRESSION_CONSTRUCTION_TABLEAU
	EXPRESSION_DELOGE
	EXPRESSION_INDEXAGE
	EXPRESSION_INFO_DE
	EXPRESSION_INIT_DE
	EXPRESSION_LITTERALE_BOOLEEN
	EXPRESSION_LITTERALE_CARACTERE
	EXPRESSION_LITTERALE_CHAINE
	EXPRESSION_LITTERALE_NOMBRE_REEL
	EXPRESSION_LITTERALE_NOMBRE_ENTIER
	EXPRESSION_LITTERALE_NUL
	EXPRESSION_LOGE
	EXPRESSION_MEMOIRE
	EXPRESSION_PARENTHESE
	EXPRESSION_PLAGE
	EXPRESSION_REFERENCE_DECLARATION
	EXPRESSION_REFERENCE_MEMBRE
	EXPRESSION_REFERENCE_MEMBRE_UNION
	EXPRESSION_REFERENCE_TYPE
	EXPRESSION_RELOGE
	EXPRESSION_TABLEAU_ARGS_VARIADIQUES
	EXPRESSION_TAILLE_DE
	EXPRESSION_TYPE_DE
	EXPRESSION_COMME
	INSTRUCTION_BOUCLE
	INSTRUCTION_COMPOSEE
	INSTRUCTION_CONTINUE_ARRETE
	INSTRUCTION_DISCR
	INSTRUCTION_DISCR_ENUM
	INSTRUCTION_DISCR_UNION
	INSTRUCTION_NON_INITIALISATION
	INSTRUCTION_POUR
	INSTRUCTION_POUSSE_CONTEXTE
	INSTRUCTION_REPETE
	INSTRUCTION_RETIENS
	INSTRUCTION_RETOUR
	INSTRUCTION_RETOUR_MULTIPLE
	INSTRUCTION_RETOUR_SIMPLE
	INSTRUCTION_SAUFSI
	INSTRUCTION_SI
	INSTRUCTION_SINON
	INSTRUCTION_TANTQUE
	INSTRUCTION_TENTE
	OPERATEUR_BINAIRE
	OPERATEUR_COMPARAISON_CHAINEE
	OPERATEUR_UNAIRE
	EXPANSION_VARIADIQUE
}

NoeudCode :: struct {
    genre : GenreNoeudCode
    type : *InfoType
}

NoeudCodeFonction :: struct {
    empl base : NoeudCode

    nom: chaine
    bloc : *NoeudCodeBloc

    params_entrée : []*NoeudCodeDéclaration
    params_sortie : []*NoeudCodeDéclaration
}

NoeudCodeAssignation :: struct {
    empl base : NoeudCode

    assigné : *NoeudCodeDéclaration
    expression : *NoeudCode
}

NoeudCodeDéclaration :: struct {
    empl base : NoeudCode

    nom: chaine
}

NoeudCodeOpérationUnaire :: struct {
    empl base : NoeudCode

    opérande : *NoeudCode
}

NoeudCodeOpérationBinaire :: struct {
    empl base : NoeudCode

    opérande_gauche : *NoeudCode
    opérande_droite : *NoeudCode
}

NoeudCodeBloc :: struct {
    empl base : NoeudCode

    expressions : []*NoeudCode
    membres : []*NoeudCodeDéclaration
}

NoeudCodeSi :: struct {
    empl base : NoeudCode

    condition : *NoeudCode
    bloc_si_vrai : *NoeudCodeBloc
    bloc_si_faux : *NoeudCodeBloc
}

NoeudCodeBoucle :: struct {
    empl base : NoeudCode

    condition : *NoeudCode
    bloc : *NoeudCodeBloc
}

// ----------------------------------------------------------------------------

EspaceDeTravail :: struct externe;

// ----------------------------------------------------------------------------
// structures des Messages, celles-ci doivent être tenues synchronisées avec celles de message.hh

GenreMessage :: énum z32 {
    INVALIDE

    FICHIER_OUVERT
    FICHIER_FERMÉ
    MODULE_OUVERT
    MODULE_FERMÉ
    TYPAGE_CODE_TERMINÉ

    // ce type de message n'a pas l'air évident à géré, la compilation ne peut être marqué comme terminée tant que le métaprogramme est en cours d'exécution
    COMPILATION_TERMINÉE
}

Message :: struct {
    genre : GenreMessage
	espace : *EspaceDeTravail
}

MessageFichier :: struct {
    empl base : Message

    chemin: chaine
}

MessageTypageCodeTerminé :: struct {
    empl base : Message

    code : *NoeudCode
}

// ----------------------------------------------------------------------------

ajoute_chaine_à_la_compilation :: fonc(espace: *EspaceDeTravail, c: chaine) -> rien #compilatrice

ajoute_fichier_à_la_compilation :: fonc(espace: *EspaceDeTravail, c: chaine) -> rien #compilatrice

compilatrice_obtiens_options :: fonc () -> *OptionsCompilation #compilatrice

compilatrice_ajourne_options :: fonc (options: *OptionsCompilation) -> rien #compilatrice

compilatrice_attend_message :: fonc () -> *Message #compilatrice

compilatrice_commence_interception :: fonc (espace: *EspaceDeTravail) #compilatrice

compilatrice_termine_interception :: fonc (espace: *EspaceDeTravail) #compilatrice

démarre_un_espace_de_travail :: fonc (nom: chaine, options: *OptionsCompilation) -> *EspaceDeTravail #compilatrice
