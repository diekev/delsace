/* Module de création d'application avec fenêtres utilisant SDL2 ou GLFW. */

/*

Le système donne des rappels au programme :
    rappel pour créer une fenêtre
    rappel pour fermer une fenêtre
    rappel pour créer un chronomètre
    rappel pour ajouter un évènement dans la boucle d'évènement
    rappel pour crée un contexte OpenGL

 */

importe Compilatrice
importe Dessin
importe Fondation
importe Géométrie
importe OpenGL

/* ------------------------------------------------------------------------- */
/** \nom Fenêtre
 * \{ */

Fenêtre :: struct {
    hauteur : z32
    largeur : z32

    /* Rappels pour les coulisses. */
    sur_destruction: fonc(*Fenêtre)(rien)
}

ArgumentsCréationFenêtre :: struct {
    titre: chaine
    rect: RectanglePosDim(z32)
    plein_écran: bool
}

détruit_fenêtre :: fonc (fenêtre: *Fenêtre)
{
    si fenêtre.sur_destruction {
        fenêtre.sur_destruction(fenêtre)
    }
}

redimensionne_fenêtre :: fonc (fenêtre: *Fenêtre, largeur: z32, hauteur: z32)
{
    fenêtre.hauteur = hauteur
    fenêtre.largeur = largeur
}

/** } */

/* ------------------------------------------------------------------------- */
/** \nom Application
 * \{ */

Application :: struct {
    fenêtre: *Fenêtre
}

application_globale : *Application

donne_application :: fonc () -> *Application
{
    retourne application_globale
}

redimensionne_app :: fonc (app: *Application, largeur: z32, hauteur: z32)
{
    redimensionne_fenêtre(app.fenêtre, largeur, hauteur)
}

/** } */

/* ------------------------------------------------------------------------- */
/** \nom Dessin de fenêtre.
 * \{ */

ModeDessinFenêtre :: énum {
    /* L'application cliente a un rappel de la forme fonc (*TypeCliente)(rien). */
    PERSONNALISÉ
    /* L'application cliente a un rappel de la forme fonc (*TypeCliente, *Fenêtre)(rien). */
    FENÊTRE
    /* L'application cliente n'a pas de rappel. */
    AUCUN
}

détermine_mode_dessin_fenêtre :: fonc (info_cliente: *InfoTypeStructure, info_pointeur_cliente: *InfoTypePointeur) -> ModeDessinFenêtre
{
    /* À FAIRE(langage) : typage des tableaux fixes selon le dénominateur commun. */
    types_entrée_mode_perso := [info_pointeur_cliente comme *InfoType]
    types_entrée_mode_fenêtre := [info_pointeur_cliente comme *InfoType, info_de(*Fenêtre) comme *InfoType]
    types_sortie := [info_de(rien)]

    pour info_cliente.membres {
        saufsi it.nom == "sur_rendu_fenêtre" {
            continue
        }

        type_membre := it.id

        si type_membre.id != id_info.FONCTION {
            retourne ModeDessinFenêtre.AUCUN
        }

        type_fonction := type_membre comme *InfoTypeFonction

        si apparie_type_fonction(type_fonction, types_entrée_mode_perso, types_sortie) {
            retourne ModeDessinFenêtre.PERSONNALISÉ
        }

        si apparie_type_fonction(type_fonction, types_entrée_mode_fenêtre, types_sortie) {
            retourne ModeDessinFenêtre.FENÊTRE
        }

        rapporte_erreur_membre_sur_dessin(info_cliente, it)
        retourne ModeDessinFenêtre.AUCUN
    }

    retourne ModeDessinFenêtre.AUCUN
}

rapporte_erreur_membre_sur_dessin :: fonc (info_cliente: *InfoTypeStructure, membre: *InfoTypeMembreStructure)
{
    enchaineuse: Enchaineuse
    initialise_enchaineuse(*enchaineuse)

    imprime_dans_enchaineuse(*enchaineuse, "Le membre '%.%' ne possède pas un type de fonction compatible pour sur_dessin_fenêtre.\n\n", info_cliente.nom, membre.nom)

    ajoute_au_tampon(*enchaineuse, "Les types possibles sont :\n")
    imprime_dans_enchaineuse(*enchaineuse, "\tfonc (*%)(rien), pour un dessin de fenêtre personnalisé,\n", info_cliente.nom)
    imprime_dans_enchaineuse(*enchaineuse, "\tfonc (*%, *Fenêtre)(rien), pour un dessiner la fenêtre donnée.\n", info_cliente.nom)

    ajoute_au_tampon(*enchaineuse, "\nNote : le type du membre est '")
    imprime_type(*enchaineuse, membre.id)
    ajoute_au_tampon(*enchaineuse, "'\n")

    message_erreur := chaine_depuis_enchaineuse(*enchaineuse)
    diffère déloge(message_erreur)

    compilatrice_rapporte_erreur(message_erreur)
}

/** } */

/* ------------------------------------------------------------------------- */
/** \nom Évènements
 * \{ */

ÉvènementRequis :: énum_drapeau {
    CLIQUE_SOURIS
    DOUBLE_CLIQUE
    MOUVEMENT_SOURIS
    TOUCHE_CLAVIER
    FIN_APPLICATION
    REDIMENSION_FENÊTRE
}

détermine_évènements_requis :: fonc (info_cliente: *InfoTypeStructure) -> ÉvènementRequis
{
    résultat : ÉvènementRequis

    pour info_cliente.membres {
        // À FAIRE : valide les types
        si it.nom == "sur_clique_souris" {
            résultat.CLIQUE_SOURIS = vrai
            continue
        }

        si it.nom == "sur_mouvement_souris" {
            résultat.MOUVEMENT_SOURIS = vrai
            continue
        }

        si it.nom == "sur_double_clique_souris" {
            résultat.DOUBLE_CLIQUE = vrai
            continue
        }

        si it.nom == "sur_fin_application" {
            résultat.FIN_APPLICATION = vrai
            continue
        }

        si it.nom == "sur_touche_clavier" {
            résultat.TOUCHE_CLAVIER = vrai
            continue
        }

        si it.nom == "sur_redimension_fenêtre" {
            résultat.REDIMENSION_FENÊTRE = vrai
            continue
        }
    }

    retourne résultat
}

/** } */
