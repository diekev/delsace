charge "interne"

/* ------------------------------------------------------------------------- */
/** \nom Emboiteuse
 * \{ */

ÉditriceTextePourId :: struct {
    id: n64
    éditrice_texte: *ÉditriceTexte
}

Emboiteuse :: struct {
    racine: *BoiteFlexible

    toutes_les_boites: [..]*BoiteFlexible
    boites_libres: [..]*BoiteFlexible

    traversée_boites: [..]*BoiteFlexible
    boites_à_visiter: [..]z64

    fragments: [..]FragmentTexte

    boites_disposées: [..]BoiteDisposée
    boites_disposées_flottantes: [..]z32

    barres_de_défilement: [..]BarreDeDéfilement
    éditrices_textes: [..]ÉditriceTextePourId

    bordures: [..]ConfigurationBordure
    flottances: [..]Flottance

    /* Hors des bordures pour éviter les problèmes lors du démarrage des applications
     * (p.e. un élément est détecté comme survolé alors que la souris est ailleurs). */
    souris_x : r32 = -1.0
    souris_y : r32 = -1.0

    hauteur_racine: r32

    commandes: CommandesDeRendu

    id_pressé: n64

    /* Mémoire vive. */
    croissables: [..]*BoiteFlexible
    décroissables: [..]*BoiteFlexible

    guetteuse_courante: *Guetteuse
    guetteuse_barre: GuetteuseBarreDéfilage

    rappels: [..]RappelUtilisateur
    boite_interagit: [TypeRappelUtilisateur.nombre_éléments]n64
}

détruit_données :: fonc (emboiteuse: *Emboiteuse)
{
    pour emboiteuse.toutes_les_boites {
        déloge(it)
    }
    déloge(emboiteuse.toutes_les_boites)
    déloge(emboiteuse.boites_libres)
    déloge(emboiteuse.fragments)
    déloge(emboiteuse.boites_disposées)
    déloge(emboiteuse.boites_disposées_flottantes)
    déloge(emboiteuse.barres_de_défilement)
    déloge(emboiteuse.éditrices_textes)
    déloge(emboiteuse.bordures)
    déloge(emboiteuse.croissables)
    déloge(emboiteuse.décroissables)
    déloge(emboiteuse.traversée_boites)
    déloge(emboiteuse.boites_à_visiter)
    déloge(emboiteuse.rappels)
}

commence_disposition :: fonc (emboiteuse: *Emboiteuse, largeur: z32, hauteur: z32)
{
    réinitialise(emboiteuse)

    emboiteuse.hauteur_racine = hauteur comme r32

    racine := emboiteuse.crée_boite()
    racine.disposition.cotation.largeur = FIXE(largeur)
    racine.disposition.cotation.hauteur = FIXE(hauteur)

    emboiteuse.racine = racine

    __boite_courante = emboiteuse.racine
}

termine_disposition :: fonc (emboiteuse: *Emboiteuse) -> CommandesDeRendu
{
    assert(__boite_courante == emboiteuse.racine)
    __boite_courante = nul

    emboiteuse.commandes.commandes.taille = 0

    si emboiteuse.racine {
        calcule_cotation_sur_direction(emboiteuse.racine, Direction.Horizontale)
        résoud_cotation_croissante_sur_direction(emboiteuse.racine, Direction.Horizontale)
        fragmente_texte(emboiteuse.racine)
        calcule_cotation_sur_direction(emboiteuse.racine, Direction.Verticale)
        résoud_cotation_croissante_sur_direction(emboiteuse.racine, Direction.Verticale)
        calcule_positions(emboiteuse.racine)
        génère_commandes(emboiteuse)

        enregistre_disposition(emboiteuse)
    }

    retourne emboiteuse.commandes
}

donne_position_souris :: fonc (emboiteuse: *Emboiteuse, origine_en_bas: bool) -> Point2D(r32)
{
    résultat : Point2D(r32) = ---
    résultat.x = emboiteuse.souris_x
    résultat.y = emboiteuse.souris_y
    si origine_en_bas {
        résultat.y = emboiteuse.hauteur_racine - résultat.y
    }
    retourne résultat
}

gère_évènement :: fonc (emboiteuse: *Emboiteuse, évènement: &Évènement)
{
    si emboiteuse.guetteuse_courante && gère_évènement(emboiteuse.guetteuse_courante, évènement) == ÉtatÉvènement.CONSOMMÉ {
        retourne
    }

    si évènement.type == TypeÉvènement.Souris {
        empl TypeRappelUtilisateur
        
        position := évènement.état_souris.où

        si évènement.action_souris == ActionSouris.DÉPLACÉE {
            définis_position_souris(emboiteuse, position.x comme r32, position.y comme r32)

            pour * emboiteuse.barres_de_défilement {
                it.est_survolée = contient(it.rect, position.x comme r32, position.y comme r32)
            }

            retourne
        }

        si évènement.action_souris == ActionSouris.ROULEMENT {
            sur_évènement_souris(emboiteuse, SurMoletteSouris, évènement.donne_clic_souris())
            retourne
        }

        si évènement.action_souris == ActionSouris.PRESSÉE {
            sur_évènement_souris(emboiteuse, SurPressionSouris, évènement.donne_clic_souris())
            retourne
        }

        si évènement.action_souris == ActionSouris.RELACHÉE {
            sur_évènement_souris(emboiteuse, SurRelâchementSouris, évènement.donne_clic_souris())

            si emboiteuse.boite_interagit[SurPressionSouris] == emboiteuse.boite_interagit[SurRelâchementSouris] {
                boite := donne_boite_disposée_pour_id(emboiteuse, emboiteuse.boite_interagit[SurRelâchementSouris])
                _ := appel_rappel(emboiteuse, boite, SurClicSouris, évènement.donne_clic_souris())
            }

            retourne
        }
    }
}

définis_position_souris :: fonc (emboiteuse: *Emboiteuse, x: r32, y: r32)
{
    emboiteuse.souris_x = x
    emboiteuse.souris_y = y
}

définis_position_souris :: fonc (emboiteuse: *Emboiteuse, souris: ClicSouris)
{
    emboiteuse.souris_x = souris.état.où.x comme r32
    emboiteuse.souris_y = souris.état.où.y comme r32
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Disposition
 * \{ */

AlignementEnfant :: énum n8 {
    Début
    Milieu
    Fin
}

Direction :: énum n8 {
    Horizontale
    Verticale
}

Cotation :: struct {
    largeur: z32
    hauteur: z32

    largeur_min: n32
    hauteur_min: n32
    largeur_max: n32 = 0xffffffff
    hauteur_max: n32 = 0xffffffff
}

FIXE :: fonc (v: z32) -> z32
{
    retourne v | BIT_COTATION_FIXE
}

CROISSANTE :: fonc () -> z32
{
    retourne BIT_COTATION_CROISSANTE
}

crée_cotation_image :: fonc (image: NouvelleImage) -> Cotation
{
    retourne Cotation(FIXE(image.desc.largeur comme z32), FIXE(image.desc.hauteur comme z32))
}

IndiceRectangle :: énum {
    GAUCHE :: 0
    HAUT :: 1
    DROITE :: 2
    BAS :: 3
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Création Boite
 * \{ */

ConfigurationDisposition :: struct {
    cotation: Cotation
    rembourrage: Rembourrage
    séparation_enfant: r32
    alignement_horizontal: AlignementEnfant
    alignement_vertical: AlignementEnfant
    direction: Direction
}

ConfigurationRectangle :: struct {
    rayon_coin: r32
}

ConfigurationBordure :: struct {
    largeur: [4]r32
    couleur: [4]CouleurRVBA
}

Rembourrage :: struct {
    v: [4]r32
}

RembourrageUniforme :: fonc (v: r32) -> Rembourrage
{
    retourne Rembourrage([v, v, v, v])
}

RembourrageDifforme :: fonc (horizontal: r32, vertical: r32) -> Rembourrage
{
    retourne Rembourrage([horizontal, vertical, horizontal, vertical])
}

RembourrageHoriz :: fonc (valeur: r32) -> Rembourrage
{
    retourne RembourrageDifforme(valeur, 0.0)
}

RembourrageVert :: fonc (valeur: r32) -> Rembourrage
{
    retourne RembourrageDifforme(0.0, valeur)
}

dispose_rectangle :: fonc (id := "", défilage := ConfigurationDéfilage(), config := ConfigurationRectangle(), pos := #position_code_source)
{
    assert(__boite_courante != nul)

    boite := __boite_courante.ajoute_enfant()

    si id {
        boite.id = calcule_empreinte_djb2(id)
    }
    sinon {
        boite.id = donne_empreinte(pos, combine_empreintes(__boite_courante.id, __boite_courante.enfants.taille comme n64))
    }

    boite.défilage = défilage
    boite.rectangle = config

    __boite_courante = boite
}

termine_rectangle :: fonc ()
{
    assert(__boite_courante != nul)
    __boite_courante = __boite_courante.parent
}

ConfigurationTexte :: struct {
    fonte: *Fonte
    couleur: CouleurRVBA
}

dispose_texte :: fonc (texte: chaine, config := ConfigurationTexte())
{
    assert(__boite_courante != nul)

    boite := __boite_courante.ajoute_texte(nul, texte)
    boite.config_texte = config
}

dispose_texte :: fonc (texte: ChaineUTF32, config := ConfigurationTexte())
{
    assert(__boite_courante != nul)

    boite := __boite_courante.ajoute_texte(nul, texte)
    boite.config_texte = config
}

dispose_image :: fonc (image: NouvelleImage, cotation: Cotation, teinte := CouleurRVBA(1.0, 1.0, 1.0, 1.0))
{
    assert(__boite_courante != nul)
    boite := __boite_courante.ajoute_image(image)
    boite.disposition.cotation = cotation
    boite.teinte = teinte
}

dispose_procédure :: fonc (procédure: fonc(*rien, RectanglePosDim(r32))(rien), données_procédure: *rien, id := "", cotation := Cotation())
{
    assert(__boite_courante != nul)
    boite := __boite_courante.ajoute_procédure(procédure, données_procédure)
    boite.disposition.cotation = cotation
    boite.id = calcule_empreinte_djb2(id)
    __boite_courante = boite
}

termine_procédure :: fonc ()
{
    termine_rectangle()
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Évènements
 * \{ */

TypeRappelSouris :: fonc(*rien, ClicSouris, n64, z32)(ÉtatÉvènement)

sur_pression_souris :: fonc (rappel: TypeRappelSouris, données: *rien, indice: z32)
{
    assert(__boite_courante != nul)
    définis_rappel(__boite_courante, TypeRappelUtilisateur.SurPressionSouris, rappel, données, indice, faux)
}

sur_relâchement_souris :: fonc (rappel: TypeRappelSouris, données: *rien, indice: z32)
{
    assert(__boite_courante != nul)
    définis_rappel(__boite_courante, TypeRappelUtilisateur.SurRelâchementSouris, rappel, données, indice, faux)
}

sur_clic_souris :: fonc (rappel: TypeRappelSouris, données: *rien, indice: z32)
{
    assert(__boite_courante != nul)
    définis_rappel(__boite_courante, TypeRappelUtilisateur.SurClicSouris, rappel, données, indice, faux)
}

sur_molette_souris :: fonc (rappel: TypeRappelSouris, données: *rien, indice: z32)
{
    assert(__boite_courante != nul)
    définis_rappel(__boite_courante, TypeRappelUtilisateur.SurMoletteSouris, rappel, données, indice, faux)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Propriétés Boite
 * \{ */

tag_boite :: fonc ()
{
    assert(__boite_courante != nul)
    __boite_courante.est_taggée = vrai
}

définis_id_débogage :: fonc (id: chaine)
{
    assert(__boite_courante != nul)
    __boite_courante.id_débogage = id
}

définis_disposition :: fonc (cotation := Cotation(), rembourrage := Rembourrage(), séparation_enfant := 0.0, alignement_horizontal := AlignementEnfant.Début, alignement_vertical := AlignementEnfant.Début, direction := Direction.Horizontale)
{
    assert(__boite_courante != nul)
    __boite_courante.disposition = ConfigurationDisposition(cotation, rembourrage, séparation_enfant, alignement_horizontal, alignement_vertical, direction)
}

définis_cotation :: fonc (cotation: Cotation)
{
     assert(__boite_courante != nul)
    __boite_courante.disposition.cotation = cotation
}

définis_rembourrage :: fonc (rembourrage: Rembourrage)
{
     assert(__boite_courante != nul)
    __boite_courante.disposition.rembourrage = rembourrage
}

définis_séparation_enfant :: fonc (séparation_enfant: r32)
{
     assert(__boite_courante != nul)
    __boite_courante.disposition.séparation_enfant = séparation_enfant
}

définis_alignement :: fonc (alignement: AlignementEnfant)
{
     assert(__boite_courante != nul)
    __boite_courante.disposition.alignement_horizontal = alignement
    __boite_courante.disposition.alignement_vertical = alignement
}

définis_alignement :: fonc (alignement_horizontal: AlignementEnfant, alignement_vertical: AlignementEnfant)
{
     assert(__boite_courante != nul)
    __boite_courante.disposition.alignement_horizontal = alignement_horizontal
    __boite_courante.disposition.alignement_vertical = alignement_vertical
}

définis_alignement_horizontal :: fonc (alignement_horizontal: AlignementEnfant)
{
     assert(__boite_courante != nul)
    __boite_courante.disposition.alignement_horizontal = alignement_horizontal
}

définis_alignement_vertical :: fonc (alignement_vertical: AlignementEnfant)
{
     assert(__boite_courante != nul)
    __boite_courante.disposition.alignement_vertical = alignement_vertical
}

définis_direction :: fonc (direction: Direction)
{
     assert(__boite_courante != nul)
    __boite_courante.disposition.direction = direction
}

ajoute_bordure_uniforme :: fonc (largeur: r32, couleur: CouleurRVBA)
{
    config := donne_configuration_bordure_courante()
    si config {
        pour 4 {
            config.largeur[it] = largeur
            config.couleur[it] = couleur
        }
    }
}

ajoute_bordure_haut :: fonc (largeur: r32, couleur: CouleurRVBA)
{
    définis_bordure_courante(largeur, couleur, IndiceRectangle.HAUT)
}

ajoute_bordure_bas :: fonc (largeur: r32, couleur: CouleurRVBA)
{
    définis_bordure_courante(largeur, couleur, IndiceRectangle.BAS)
}

ajoute_bordure_gauche :: fonc (largeur: r32, couleur: CouleurRVBA)
{
    définis_bordure_courante(largeur, couleur, IndiceRectangle.GAUCHE)
}

ajoute_bordure_droite :: fonc (largeur: r32, couleur: CouleurRVBA)
{
    définis_bordure_courante(largeur, couleur, IndiceRectangle.DROITE)
}

ConfigurationDéfilage :: struct {
    vertical: bool
    horizontal: bool

    largeur_verticale := 16.0
    couleur_verticale := CouleurRVBA(0.0, 0.0, 0.0, 0.7)
    couleur_verticale_survolage := CouleurRVBA(0.5, 0.5, 0.5, 0.7)
}

ajoute_défilage :: fonc (config: ConfigurationDéfilage)
{
    assert(__boite_courante != nul)
    __boite_courante.défilage = config
}

ajoute_défilage_vertical :: fonc (largeur := 16.0, couleur := CouleurRVBA(0.0, 0.0, 0.0, 0.7), couleur_survolage_survolage := CouleurRVBA(0.5, 0.5, 0.5, 0.7))
{
    assert(__boite_courante != nul)
    __boite_courante.défilage.vertical = vrai
    __boite_courante.défilage.largeur_verticale = largeur
    __boite_courante.défilage.couleur_verticale = couleur
    __boite_courante.défilage.couleur_verticale_survolage = couleur_survolage_survolage
}

BarreDeDéfilement :: struct {
    défilage: r32
    défilage_max: r32
    /* hauteur disponible / hauteur contenu */
    ratio: r32

    direction: Direction
    est_survolée: bool
    rect: RectanglePosDim(r32)
}

donne_barre_défilage_verticale :: fonc () -> *BarreDeDéfilement
{
    assert(__boite_courante != nul)

    boite := donne_boite_disposée_pour_id(__boite_courante.emboiteuse, __boite_courante.id)
    si boite && boite.barre_de_défilement_verticale != INDEX_BARRE_DÉFILEMENT_INVALIDE {
        retourne *__boite_courante.emboiteuse.barres_de_défilement[boite.barre_de_défilement_verticale]
    }

    barre, _ := donne_barre_de_défilement(__boite_courante, Direction.Verticale)
    retourne barre
}

définis_défilage :: fonc (barre: *BarreDeDéfilement, défilage: r32)
{
    barre.défilage = défilage
    si barre.ratio != 0.0 {
        si barre.défilage < 0.0 {
            barre.défilage = 0.0
        }
        si barre.défilage > barre.défilage_max {
            barre.défilage = barre.défilage_max
        }
    }
}

définis_arrière_plan :: fonc (r: r32, v: r32, b: r32, a: r32)
{
    définis_arrière_plan(CouleurRVBA(r, v, b, a))
}

définis_arrière_plan :: fonc (couleur := CouleurRVBA())
{
    assert(__boite_courante != nul)
    __boite_courante.arrière_plan = couleur
}

AncrageFlottante :: énum {
    HAUT_GAUCHE
    HAUT_CENTRE
    HAUT_DROIT
    CENTRE_GAUCHE
    CENTRE
    CENTRE_DROIT
    BAS_GAUCHE
    BAS_CENTRE
    BAS_DROIT
}

Flottance :: struct {
    /* Ancrage par rapport au parent. */
    ancrage: AncrageFlottante
    /* Décalages par rapport à l'ancrage. */
    décalage_x := 0.0
    décalage_y := 0.0
}

définis_flottance :: fonc (décalage_x := 0.0, décalage_y := 0.0, ancrage := AncrageFlottante.HAUT_GAUCHE)
{
    assert(__boite_courante != nul)
    emboiteuse := __boite_courante.emboiteuse

    si __boite_courante.flottance.est_valide() {
        config := *emboiteuse.flottances[__boite_courante.flottance]
        config.ancrage = ancrage
        config.décalage_x = décalage_x
        config.décalage_y = décalage_y
    }
    sinon {
        __boite_courante.flottance = emboiteuse.ajoute_flottance(Flottance(ancrage, décalage_x, décalage_y))
    }
}

donne_rect :: fonc () -> RectanglePosDim(r32)
{
    assert(__boite_courante != nul)
    résultat := donne_rect(__boite_courante.emboiteuse, __boite_courante.id)
    retourne résultat
}

est_survolée :: fonc () -> bool
{
    assert(__boite_courante != nul)
    boite_disposée := donne_boite_sous_souris(__boite_courante.emboiteuse)
    boite_courante := boite_disposée

    tantque boite_courante != nul {
        si boite_courante.id == __boite_courante.id {
            retourne vrai
        }

        si boite_courante.parent == -1 {
            arrête
        }

        boite_courante = *__boite_courante.emboiteuse.boites_disposées[boite_courante.parent]
    }

    retourne faux
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Édition Texte
 * \{ */

définis_éditrice_texte :: fonc (éditrice_texte: *ÉditriceTexte)
{
    assert(__boite_courante != nul)
    emboiteuse := __boite_courante.emboiteuse

    pour * emboiteuse.éditrices_textes {
        si it.id == __boite_courante.id {
            it.éditrice_texte = éditrice_texte
            arrête
        }
    }
    sansarrêt {
        tableau_ajoute(*emboiteuse.éditrices_textes, ÉditriceTextePourId(__boite_courante.id, éditrice_texte))
    }
}

définis_éditrice_texte :: fonc (emboiteuse: *Emboiteuse, id: n64, éditrice_texte: *ÉditriceTexte)
{
    pour * emboiteuse.éditrices_textes {
        si it.id != id {
            continue
        }

        si éditrice_texte == nul {
            tableau_supprime_indice(*emboiteuse.éditrices_textes, indice_it)
            retourne
        }

        it.éditrice_texte = éditrice_texte
        retourne
    }

    assert(éditrice_texte != nul)
    tableau_ajoute(*emboiteuse.éditrices_textes, ÉditriceTextePourId(id, éditrice_texte))
}

donne_éditrice_texte :: fonc (emboiteuse: *Emboiteuse, id: n64) -> *ÉditriceTexte
{
    pour * emboiteuse.éditrices_textes {
        si it.id == id {
            retourne it.éditrice_texte
        }
    }

    retourne nul
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Utilitaires
 * \{ */

dispose_séparateur_horizontal :: fonc (hauteur := 0)
{
    assert(__boite_courante != nul)
    séparateur := __boite_courante.ajoute_enfant()
    séparateur.disposition.cotation.largeur = CROISSANTE()

    si hauteur != 0 {
        séparateur.disposition.cotation.hauteur = FIXE(hauteur)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom CommandesDeRendu
 * \{ */

TypeCommandeDeRendu :: énum {
    REMPLIS_RECTANGLE
    REMPLIS_RECTANGLE_ARRONDI
    DESSINE_BORDURE
    DESSINE_TEXTE
    DESSINE_TEXTE_UTF32
    DESSINE_IMAGE
    DÉBUTE_CISELAGE
    TERMINE_CISELAGE
    DESSINE_PROCÉDURAL
}

CommandesDeRendu :: struct {
    commandes: [..]octet
}

détruit_commandes :: fonc (commandes: *CommandesDeRendu)
{
    saufsi commandes {
        retourne
    }

    déloge(commandes.commandes)
    déloge(commandes)
}

réinitialise :: fonc (commandes: *CommandesDeRendu)
{
    commandes.commandes.taille = 0
}

crée_commande :: fonc (commandes: *CommandesDeRendu, $T: type_de_données) -> *T
{
    décalage := commandes.commandes.taille
    tableau_redimensionne(commandes.commandes, décalage + (taille_de(T) comme z64))

    résultat := *commandes.commandes[décalage] comme *T
    init_de(T)(résultat)
    résultat.taille_type = taille_de(T)
    retourne résultat
}

BaseCommande :: struct {
    type: TypeCommandeDeRendu
    taille_type: n32
    rect: RectanglePosDim(r32)
}

CommandeRemplisRectangle :: struct {
    empl base: BaseCommande
    type = TypeCommandeDeRendu.REMPLIS_RECTANGLE

    couleur: CouleurRVBAN8
}

remplis_rectangle :: fonc (commandes: *CommandesDeRendu, rect: RectanglePosDim(r32), couleur: CouleurRVBAN8)
{
    résultat := crée_commande(commandes, CommandeRemplisRectangle)
    résultat.rect = rect
    résultat.couleur = couleur
}

remplis_rectangle :: fonc (commandes: *CommandesDeRendu, rect: RectanglePosDim(r32), couleur: CouleurRVBA)
{
    résultat := crée_commande(commandes, CommandeRemplisRectangle)
    résultat.rect = rect
    résultat.couleur = depuis_couleur_rvba(couleur)
}

CommandeRemplisRectangleArrondi :: struct {
    empl base: BaseCommande
    type = TypeCommandeDeRendu.REMPLIS_RECTANGLE_ARRONDI

    couleur: CouleurRVBAN8
    rayon: r32
}

remplis_rectangle_arrondi :: fonc (commandes: *CommandesDeRendu, rect: RectanglePosDim(r32), couleur: CouleurRVBA, rayon: r32)
{
    résultat := crée_commande(commandes, CommandeRemplisRectangleArrondi)
    résultat.rect = rect
    résultat.couleur = depuis_couleur_rvba(couleur)
    résultat.rayon = rayon
}

CommandeDessineBordure :: struct {
    empl base: BaseCommande
    type = TypeCommandeDeRendu.DESSINE_BORDURE

    couleur: [4]CouleurRVBAN8
    largeur: [4]r32
    rayon: r32
}

dessine_bordure :: fonc (commandes: *CommandesDeRendu, rect: RectanglePosDim(r32), couleur: [4]CouleurRVBA, largeur: [4]r32, rayon: r32)
{
    résultat := crée_commande(commandes, CommandeDessineBordure)
    résultat.rect = rect
    pour couleur {
        résultat.couleur[indice_it] = depuis_couleur_rvba(it)
    }
    résultat.largeur = largeur
    résultat.rayon = rayon
}

CommandeDessineTexte :: struct {
    empl base: BaseCommande
    type = TypeCommandeDeRendu.DESSINE_TEXTE

    fonte: *Fonte
    texte: chaine
    couleur: CouleurRVBA
    effets: EffetsTexte
}

dessine_texte :: fonc (commandes: *CommandesDeRendu, rect: RectanglePosDim(r32), fonte: *Fonte, texte: chaine, couleur: CouleurRVBA, effets: *EffetsTexte = nul)
{
    résultat := crée_commande(commandes, CommandeDessineTexte)
    résultat.fonte = fonte
    résultat.texte = texte
    résultat.rect = rect
    résultat.couleur = couleur
    si effets {
        résultat.effets = mémoire(effets)
    }
}

CommandeDessineTexteUTF32 :: struct {
    empl base: BaseCommande
    type = TypeCommandeDeRendu.DESSINE_TEXTE_UTF32

    fonte: *Fonte
    texte: ChaineUTF32
    couleur: CouleurRVBA
    effets: EffetsTexte
}

dessine_texte :: fonc (commandes: *CommandesDeRendu, rect: RectanglePosDim(r32), fonte: *Fonte, texte: ChaineUTF32, couleur: CouleurRVBA, effets: *EffetsTexte = nul)
{
    résultat := crée_commande(commandes, CommandeDessineTexteUTF32)
    résultat.fonte = fonte
    résultat.texte = texte
    résultat.rect = rect
    résultat.couleur = couleur
    si effets {
        résultat.effets = mémoire(effets)
    }
}

CommandeDessineImage :: struct {
    empl base: BaseCommande
    type = TypeCommandeDeRendu.DESSINE_IMAGE

    image: NouvelleImage
    teinte: CouleurRVBA
}

dessine_image :: fonc (commandes: *CommandesDeRendu, rect: RectanglePosDim(r32), image: NouvelleImage, teinte: CouleurRVBA)
{
    résultat := crée_commande(commandes, CommandeDessineImage)
    résultat.rect = rect
    résultat.image = image
    résultat.teinte = teinte
}

CommandeDébuteCiselage :: struct {
    empl base: BaseCommande
    type = TypeCommandeDeRendu.DÉBUTE_CISELAGE
}

débute_ciselage :: fonc (commandes: *CommandesDeRendu, rect: RectanglePosDim(r32))
{
    résultat := crée_commande(commandes, CommandeDébuteCiselage)
    résultat.rect = rect
}

CommandeTermineCiselage :: struct {
    empl base: BaseCommande
    type = TypeCommandeDeRendu.TERMINE_CISELAGE
}

termine_ciselage :: fonc (commandes: *CommandesDeRendu)
{
    _ := crée_commande(commandes, CommandeTermineCiselage)
}

CommandeDessineProcédural :: struct {
    empl base: BaseCommande
    type = TypeCommandeDeRendu.DESSINE_PROCÉDURAL

    procédure: fonc(*rien, RectanglePosDim(r32))(rien)
    données_procédure: *rien
}

dessine_procédural :: fonc (commandes: *CommandesDeRendu, rect: RectanglePosDim(r32), procédure: fonc(*rien, RectanglePosDim(r32))(rien), données_procédure: *rien)
{
    résultat := crée_commande(commandes, CommandeDessineProcédural)
    résultat.rect = rect
    résultat.procédure = procédure
    résultat.données_procédure = données_procédure
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Rendu avec PeintureInterface
 * \{ */

importe PeintureInterface

dessine_commandes :: fonc (peintre: *Peintre, commandes: *CommandesDeRendu)
{
    peintre.commence_dessin()

    début := commandes.commandes.pointeur
    fin := début + commandes.commandes.taille

    hauteur_vue := peintre.donne_taille_canevas().hauteur comme z32 comme r32

    tantque début < fin {
        base := début comme *BaseCommande
        discr base.type {
            REMPLIS_RECTANGLE {
                commande := base comme *CommandeRemplisRectangle
                rect := commande.rect
                rect.y = hauteur_vue - rect.y - rect.hauteur
                peintre.remplis_rectangle(rect, commande.couleur)
            }
            REMPLIS_RECTANGLE_ARRONDI {
                commande := base comme *CommandeRemplisRectangleArrondi
                rect := commande.rect
                rect.y = hauteur_vue - rect.y - rect.hauteur
                peintre.remplis_rectangle_arrondi(rect, [commande.rayon, commande.rayon, commande.rayon, commande.rayon], commande.couleur)
            }
            DESSINE_BORDURE {
                commande := base comme *CommandeDessineBordure
                rect := commande.rect
                rect.y = hauteur_vue - rect.y - rect.hauteur
                // À FAIRE : rayon

                largeurs := [commande.largeur[1], commande.largeur[2], commande.largeur[3], commande.largeur[0]]
                couleurs := CouleurPeintre.[commande.couleur[1], commande.couleur[2], commande.couleur[3], commande.couleur[0]]

                peintre.dessine_bordure(rect, largeurs, couleurs)
            }
            DESSINE_TEXTE {
                commande := base comme *CommandeDessineTexte
                rect := commande.rect
                rect.y = hauteur_vue - rect.y - rect.hauteur
                peintre.dessine_texte(commande.fonte, commande.texte, rect, commande.couleur)
            }
            DESSINE_TEXTE_UTF32 {
                commande := base comme *CommandeDessineTexteUTF32
                rect := commande.rect
                rect.y = hauteur_vue - rect.y - rect.hauteur
                peintre.dessine_texte(commande.fonte, commande.texte, rect, commande.couleur)
            }
            DESSINE_IMAGE {
                commande := base comme *CommandeDessineImage
                rect := commande.rect
                rect.y = hauteur_vue - rect.y - rect.hauteur
                peintre.dessine_image(*commande.image, rect, commande.teinte)
            }
            DESSINE_PROCÉDURAL {
                commande := base comme *CommandeDessineProcédural
                rect := commande.rect
                rect.y = hauteur_vue - rect.y - rect.hauteur
                commande.procédure(commande.données_procédure, rect)
            }
            DÉBUTE_CISELAGE {
                rect := base.rect
                rect.y = hauteur_vue - rect.y - rect.hauteur
                peintre.définis_ciseau(rect)
            }
            TERMINE_CISELAGE {
                peintre.restaure_ciseau()
            }
        }

        début += base.taille_type
    }

    peintre.termine_dessin()
}

/** \} */
