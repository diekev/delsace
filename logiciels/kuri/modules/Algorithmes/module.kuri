importe Fondation
importe Math

charge "tableaux"

/* ------------------------------------------------------------------------- */
/** \nom Recherche binaire
 * Différents algorithmes de recherche binaire. Ces algorithmes nous évitent de faire trop
 * de comparaisons, et sont résistant aux dépassement de bornes.
 * \{ */

// Trouve une valeur entre deux pointeurs. Retourne le premier pointeur dont la valeur pointée
// ést plus petite que la valeur recherchée. Sinon retourne le pointeur de fin.
// Ceci est utile pour stocker dans l'ordre croissant des données.
limite_basse :: fonc (f: *$T, l: *T, v: T) -> *T
{
    fl := f
    ll := l

    boucle {
        si fl == ll {
            arrête
        }

        m := suivant(fl, distance(fl, ll) / 2)

        si m[0] < v {
            fl = suivant(m, 1)
        }
        sinon {
            ll = m
        }
    }

    retourne fl
}

// Trouve une valeur entre deux pointeurs. Retourne le premier pointeur dont la valeur pointée
// ést plus petite que la valeur recherchée. Sinon retourne le pointeur de fin.
// Ceci est utile pour stocker dans l'ordre croissant des données.
limite_basse :: fonc (f: *$T, l: *T, v: T, rappel_comp: fonc (a: *T, b: *T) -> bool) -> *T
{
    fl := f
    ll := l

    boucle {
        si fl == ll {
            arrête
        }

        m := suivant(fl, distance(fl, ll) / 2)

        si rappel_comp(m, *v) {
            fl = suivant(m, 1)
        }
        sinon {
            ll = m
        }
    }

    retourne fl
}

// Trouve une valeur entre deux pointeurs. Retourne le premier pointeur dont la valeur pointée
// ést plus grande que la valeur recherchée. Sinon retourne le pointeur de fin.
// Ceci est utile pour stocker dans l'ordre décroissant des données.
limite_haute :: fonc (f: *$T, l: *T, v: T) -> *T
{
    fl := f
    ll := l

    boucle {
        si fl == ll {
            arrête
        }

        m := suivant(fl, distance(fl, ll) / 2)

        si m[0] > v {
            fl = suivant(m, 1)
        }
        sinon {
            ll = m
        }
    }

    retourne fl
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Arithmétique de pointeurs
 * \{ */

// Retourne le nombre d'éléments se situant entre deux pointeurs.
distance :: fonc (ptr1: *$T, ptr2: *T) -> z64 #enligne
{
    retourne ptr2 - ptr1
}

// Retourne le pointeur se situant à n éléments après celui donné.
suivant :: fonc (ptr: *$T, n: z64) -> *T #enligne
{
    retourne ptr + n
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Test de valeurs
 * \{ */

tous_de :: fonc (tableau: []$T, prédicat: fonc (t: T) -> bool) -> bool
{
    pour tableau {
        saufsi prédicat(it) {
            retourne faux
        }
    }

    retourne vrai
}

aucun_de :: fonc (tableau: []$T, prédicat: fonc (t: T) -> bool) -> bool
{
    pour tableau {
        si prédicat(it) {
            retourne faux
        }
    }

    retourne vrai
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Accumulation
 * \{ */

accumule :: fonc (tableau: []$T, valeur_initiale: $V, rappel: fonc (t: T) -> V) -> V
{
    résultat := valeur_initiale

    pour tableau {
        résultat += rappel(it)
    }

    retourne résultat
}

accumule :: fonc (tableau: []$T, valeur_initiale: T) -> T
{
    retourne accumule(tableau.pointeur, tableau.pointeur + tableau.taille, valeur_initiale)
}

accumule :: fonc (premier: *$T, dernier: *T) -> T
{
    valeur_initiale: T
    retourne accumule(premier, dernier, valeur_initiale)
}

accumule :: fonc (premier: *$T, dernier: *T, valeur_initiale: T) -> T
{
    résultat := valeur_initiale
    tantque premier < dernier {
        résultat += mémoire(premier)
        premier += 1
    }
    retourne résultat
}

/* Sommation de nombres réels par Kahan et Babuska, variante de Neumaier.
 * Ceci accumule moins d'erreur en point flottant.
 * https://en.wikipedia.org/wiki/Kahan_summation_algorithm
 */
accumule_selon_kahan_babuska_version_neumaier :: fonc (tableau: []r32) -> r32
{
    saufsi tableau {
        retourne 0.0
    }

    résultat := tableau[0]
    err := 0.0

    pour 1 ... tableau.taille - 1 {
        k := tableau[it]
        m := résultat + k

        err += si abs(résultat) >= abs(k) {
            résultat - m + k
        }
        sinon {
            k - m + résultat
        }

        résultat = m
    }

    retourne résultat + err
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Permutation de valeur.
 * \{ */

permute :: fonc (a: *$T, b: *T) #enligne
{
    tmp := mémoire(a)
    mémoire(a) = mémoire(b)
    mémoire(b) = tmp
}

permute :: fonc (a: &$T, b: &T) #enligne
{
    tmp : T = a
    a = b
    b = tmp
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Inversion d'une séquence.
 * \{ */

inverse :: fonc (premier: *$T, dernier: *T)
{
    tantque premier < dernier {
        dernier -= 1
        permute(premier, dernier)
        premier += 1
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Pivote
*
 * Déplace les éléments entre `premier` et `milieu` afin qu'ils se trouvent
 * après `dernier`.
 * Retourne la nouvelle position de `premier`.
 * \{ */

pivote :: fonc (premier: *$T, milieu: *T, dernier: *T) -> *T
{
    taille_début := distance(premier, milieu)
    taille_fin := distance(milieu, dernier)

    /* À FAIRE : évite d'allouer de la mémoire */
    tampon: [..]T
    diffère déloge(tampon)
    tableau_redimensionne(tampon, taille_début)

    copie_mem_nonsur(src = premier, dst = tampon.pointeur, taille = taille_début * taille_de(T) comme z64)
    déplace_mémoire_nonsur(src = milieu, dst = premier, taille = taille_fin * taille_de(T) comme z64)
    copie_mem_nonsur(src = tampon.pointeur, dst = dernier - taille_début, taille = taille_début * taille_de(T) comme z64)

    retourne suivant(premier, taille_fin)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Partition.
 *
 * Tri les éléments entre `premier` et `dernier` tel quel les éléments qui
 * satisfont le `prédicat` se retrouvent avant les autres.
 * Retourne le premier élément satisfaisant le `prédicat`.
 * \{ */

partitionne :: fonc (premier: *$T, dernier: *T, prédicat: fonc (t: T) -> bool) -> *T
{
    boucle {
        tantque (premier != dernier) && prédicat(mémoire(premier)) {
            premier = suivant(premier, 1)
        }

        si premier == dernier {
            arrête
        }

        dernier = suivant(dernier, -1)

        tantque (premier != dernier) && !prédicat(mémoire(dernier)) {
            dernier = suivant(dernier, -1)
        }

        si premier == dernier {
            arrête
        }

        permute(premier, dernier)
        premier = suivant(premier, 1)
    }

    retourne premier
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Partition stable.
 *
 * Tri les éléments entre `premier` et `dernier` tel quel les éléments qui
 * satisfont le `prédicat` se retrouvent avant les autres en préservant leur
 * ordre relatif.
 * Retourne le premier élément satisfaisant le `prédicat`.
 * \{ */

partition_stable :: fonc (premier: *$T, dernier: *T, p: fonc (t: T) -> bool) -> *T
{
    taille := distance(premier, dernier)
    saufsi taille {
        retourne premier
    }

    si taille == 1 {
        retourne suivant(premier, p(mémoire(premier)) comme z32)
    }

    milieu := suivant(premier, taille / 2)

    retourne pivote(partition_stable(premier, milieu, p),
                    milieu,
                    partition_stable(milieu, dernier, p))
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Copie
 * \{ */

/* Copie les éléments entre [début_src, fin_scr) dans la zone commençant à
 * début_dst selon le prédicat p. Seuls les éléments satisfaisant le prédicat
 * seront copiés.
 * Retourne l'adresse suivant le dernier élément dans début_dst (le nombre
 * d'éléments copiés sera (résultat - début_dst). */
copie_si :: fonc (début_src: *$T, fin_src: *T, début_dst: *T, p: fonc (t: T) -> bool) -> *T
{
    tantque début != fin_src {
        valeur := mémoire(début_src)
        début_src += 1

        saufsi p(valeur) {
            continue
        }

        mémoire(début_dst) = valeur
        début_dst += 1
    }

    retourne début_dst
}

copie_si :: fonc (tableau: []$T, prédicat: fonc (t: T) -> bool) -> [..]T
{
    résultat: [..]T
    tableau_réserve(*résultat, tableau.taille)

    pour tableau {
        si prédicat(it) {
            tableau_ajoute(*résultat, copie(it))
        }
    }

    retourne résultat
}

copie :: fonc (tableau: []$T) -> [..]T
{
    résultat: [..]T
    tableau_réserve(*résultat, tableau.taille)

    pour tableau {
        tableau_ajoute(*résultat, copie(it))
    }

    retourne résultat
}

copie_depuis_la_fin :: fonc (premier: *$T, dernier: *T, résultat: *T)
{
    tantque premier != dernier {
        dernier -= 1
        résultat -= 1
        mémoire(résultat) = mémoire(dernier)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Énième élément.
 *
 * Performe un tri partiel des données de sort que l'énième élément se retrouve
 * à la position où il aurait été si le tri fut complet. Tous les éléments
 * précédents l'éniènme seront plus petit, les suivants plus grands, mais désordonnées.
 * \{ */

énième_élément :: fonc (tableau: []$T, indice: z64) -> T
{
    retourne énième_élément(tableau, indice, opérateur<(T, T))
}

énième_élément :: fonc (tableau: []$T, indice: z64, comp: fonc (a: T, b: T) -> bool) -> T
{
    début := tableau.pointeur
    élément := début + indice
    fin := début + tableau.taille

    énième_élément(début, élément, fin, comp)

    retourne mémoire(élément)
}

énième_élément :: fonc (premier: *$T, énième: *T, dernier: *T)
{
    énième_élément(premier, énième, dernier, opérateur<(T, T))
}

énième_élément :: fonc (premier: *$T, énième: *T, dernier: *T, comp: fonc (a: T, b: T) -> bool)
{
    assert(premier <= énième <= dernier)

    si premier == dernier || énième == dernier {
        retourne
    }

    sélection_introspective(premier, énième, dernier, log_base_2(dernier - premier) * 2, comp)
}

log_base_2 :: fonc (n: z64) -> z64
{
    BIS_PAR_OCTET :: 8
    retourne (taille_de(z64) comme z32) * BIS_PAR_OCTET - 1 - intrinsèque_compte_zéros_en_tête(n comme n64)
}

#test {
    v := [5, 10, 6, 4, 3, 2, 6, 7, 9, 3]
    imprime_tableau(v)
 
    m := *v[0] + v.taille / 2

    début := *v[0]
    énième_élément(début, m, début + v.taille)

    assert(v[v.taille / 2] == 6)
    imprimeln("La médiane est %", v[v.taille / 2])

    // Conséquence de l'inégalité des éléments avant/après l'énième :
    assert(accumule(début, m) < accumule(m, début + v.taille))
    assert(tableaux_sont_égaux(v, [3, 2, 3, 4, 5, 6, 10, 7, 9, 6]))
    imprime_tableau(v);
 
    // Note: changement de la fonction de comparaison
    est_plus_grand :: fonc (a: z32, b: z32) -> bool
    {
        retourne a > b
    }
    énième_élément(début, début + 1, début + v.taille, est_plus_grand)

    imprimeln("Le deuxième grandissime élément est %", v[1])
    assert(v[1] == 9)
    imprimeln("Le grandissime élément est %", v[0])
    assert(v[0] == 10)

    assert(tableaux_sont_égaux(v, [10, 9, 6, 7, 6, 3, 5, 4, 3, 2]))
    imprime_tableau(v)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Sélection introspective.
 *
 * https://en.wikipedia.org/wiki/Introselect
 * \{ */

sélection_introspective :: fonc (premier: *$T, énième: *T, dernier: *T, limite_profondeur: z64, comp: fonc (a: T, b: T) -> bool)
{
    tantque (dernier - premier) > 3 {
        si limite_profondeur == 0 {
            sélectionne_tas(premier, énième + 1, dernier, comp);
            // Positionne le énième grandissime élément à sa place finale.
            permute(premier, énième);
            retourne
        }

        limite_profondeur -= 1
        coupe := partition_sans_garde_pivot(premier, dernier, comp)

        si coupe <= énième {
            premier = coupe
        }
        sinon {
            dernier = coupe
        }
    }

    tri_par_insertion(premier, dernier, comp);
}

partition_sans_garde_pivot :: fonc (premier: *$T, dernier: *T, comp: fonc (a: T, b: T) -> bool) -> *T
{
    milieu := premier + (dernier - premier) / 2
    déplace_médiane_au_début(premier, premier + 1, milieu, dernier - 1, comp)
    retourne partition_sans_garde(premier + 1, dernier, premier, comp)
}

partition_sans_garde :: fonc (premier: *$T, dernier: *T, pivot: *T, comp: fonc (a: T, b: T) -> bool) -> *T
{
    boucle {
        tantque comp(mémoire(premier), mémoire(pivot)) {
            premier += 1
        }

        dernier -= 1
    
        tantque comp(mémoire(pivot), mémoire(dernier)) {
            dernier -= 1
        }

        saufsi (premier < dernier) {
            retourne premier
        }

        permute(premier, dernier);
        premier += 1
    }

    retourne nul
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Tas.
 * https://fr.wikipedia.org/wiki/Tas_(informatique)
 * \{ */

sélectionne_tas :: fonc (premier: *$T, milieu: *T, dernier: *T, comp: fonc (a: T, b: T) -> bool)
{
    cére_tas(premier, milieu, comp)

    it := milieu
    // pour milieu ... dernier - 1 {
    tantque it < dernier {
        si comp(mémoire(it), mémoire(premier)) {
            défile_tas(premier, milieu, it, comp)
        }
        it += 1
    }
}

cére_tas :: fonc (premier: *$T, dernier: *T, comp: fonc (a: T, b: T) -> bool)
{
    si (dernier - premier) < 2 {
        retourne
    }

    TypeDistance :: z64

    longueur := (dernier - premier) comme TypeDistance
    parent := (longueur - 2) / 2

    boucle {
        value := mémoire(premier + parent)
        ajuste_tas(premier, parent, longueur, value, comp);
        saufsi parent {
            retourne
        }
        parent -= 1
    }
}

ajuste_tas :: fonc (premier: *$T, indice_trou: z64, longueur: z64, value: T, comp: fonc (a: T, b: T) -> bool)
{
    indice_tête := indice_trou
    deuxième_enfant := indice_trou

    tantque (deuxième_enfant < (longueur - 1) / 2) {
        deuxième_enfant = 2 * (deuxième_enfant + 1)

        si comp(mémoire(premier + deuxième_enfant), mémoire(premier + (deuxième_enfant - 1))) {
            deuxième_enfant -= 1
        }

        mémoire(premier + indice_trou) = mémoire(premier + deuxième_enfant)
        indice_trou = deuxième_enfant
    }

    si ((longueur & 1) == 0 && deuxième_enfant == (longueur - 2) / 2) {
        deuxième_enfant = 2 * (deuxième_enfant + 1)
        mémoire(premier + indice_trou) = mémoire(premier + (deuxième_enfant - 1))
        indice_trou = deuxième_enfant - 1;
    }

    enfile_tas(premier, indice_trou, indice_tête, value, comp);
}

enfile_tas :: fonc (premier: *$T, indice_trou: z64, indice_tête: z64, value: T, comp: fonc (a: T, b: T) -> bool)
{
    parent := (indice_trou - 1) / 2;
    tantque (indice_trou > indice_tête && comp(mémoire(premier + parent), value)) {
        mémoire(premier + indice_trou) = mémoire(premier + parent)
        indice_trou = parent;
        parent = (indice_trou - 1) / 2
    }
    mémoire(premier + indice_trou) = value
}

défile_tas :: fonc (premier: *$T, dernier: *T, résultat: *T, comp: fonc (a: T, b: T) -> bool)
{
    value := mémoire(résultat)
    mémoire(résultat) = mémoire(premier)
    ajuste_tas(premier, 0, (dernier - premier) comme z64, value, comp);
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Fonctions auxilliaires
 * \{ */

déplace_médiane_au_début :: fonc (résultat: *$T, a: *T, b: *T, c: *T, comp: fonc (a: T, b: T) -> bool)
{
    si comp(mémoire(a), mémoire(b)) {
        si (comp(mémoire(b), mémoire(c))) {
            permute(résultat, b)
        }
        sinon si comp(mémoire(a), mémoire(c)) {
            permute(résultat, c)
        }
        sinon {
            permute(résultat, a)
        }
    }
    sinon si comp(mémoire(a), mémoire(c)) {
        permute(résultat, a)
    }
    sinon si comp(mémoire(b), mémoire(c)) {
        permute(résultat, c)
    }
    sinon {
        permute(résultat, b)
    }
}

tri_par_insertion :: fonc (premier: *$T, dernier: *T, comp: fonc (a: T, b: T) -> bool)
{
    si premier == dernier {
      retourne
    }

    it := premier + 1
    // pour premier + 1 ... dernier - 1
    tantque it != dernier {
        si comp(mémoire(it), mémoire(premier)) {
            valeur := mémoire(it)
            copie_depuis_la_fin(premier, it, it + 1);
            mémoire(premier) = valeur
        }
        sinon {
            insertion_linéaire_sans_garde(it, comp);
        }

        it += 1
    }
}

insertion_linéaire_sans_garde :: fonc (dernier: *$T, comp: fonc (a: T, b: T) -> bool)
{
    valeur := mémoire(dernier)
    suivant := dernier;
    suivant -= 1

    tantque comp(valeur, mémoire(suivant)) {
        mémoire(dernier) = mémoire(suivant)
        dernier = suivant
        suivant -= 1
    }

    mémoire(dernier) = valeur
}

/** \} */
