/*

    Module de service HTTP.

    Définie une serveuse pouvant recevoir des requête HTTP.
    La serveuse dérive de ServeuseTCP.
    Si vous voulez utiliser un service se basant sur Apache, utilisez plutôt ServeuseCGI.

    Pour répondre à des requêtes, la serveuse doit connaître les routes possibles, et pour ce faire utilise une Routeuse.

 */

/*

    À FAIRE :
    - paramétrise les logs
    - gestion des fichiers statiques

 */
importe ConnexionTCP
importe ServeuseTCP
importe Fondation
importe Internet
importe Réseau
importe SysFichier
importe Temps

/*
    Pour mapper plusieurs port localhost via un proxy
    https://stackoverflow.com/questions/10729034/can-i-map-a-hostname-and-a-port-with-etc-hosts
    https://github.com/cristianoliveira/ergo
    https://askubuntu.com/questions/935859/hosts-file-with-port
*/

TypeRappelRoute :: fonc(*Prise, &MessageClienteHTTP)(MessageServeuseHTTP)

apparie_uri :: fonc (chemin_base: chaine, chemin_donnée: chaine) -> bool
{
    retourne chemin_base == chemin_donnée
}

Route :: struct {
    chemin: chaine
    rappel: TypeRappelRoute
}

NouvelleRouteuse :: struct {
    routes_get: []Route
    routes_post: []Route
}

apparie_route :: fonc (routeuse: &NouvelleRouteuse, chemin: chaine, méthode: chaine) -> TypeRappelRoute
{
    si méthode == "GET" {
        pour routeuse.routes_get {
            si apparie_uri(it.chemin, chemin) {
                retourne it.rappel
            }
        }

        retourne nul
    }

    si méthode == "POST" {
        pour routeuse.routes_post {
            si apparie_uri(it.chemin, chemin) {
                retourne it.rappel
            }
        }

        retourne nul
    }

    retourne nul
}

ServeuseHTTP :: struct {
    empl base: ServeuseTCP.ServeuseTCP

    nom: chaine = "test"
    routeuse: NouvelleRouteuse
}

crée_serveuse_http :: fonc (adresse_ip: AdresseIPv4, port: n16, connexions_max: z32, $T: type_de_données, $TypeDonnéesPrise: type_de_données) -> *ServeuseHTTP
{
    // À FAIRE: déduplique avec ServeuseTCP, requiers d'avoir une manière de déterminer le bon type (ServeuseTCP vs. ServeuseHTTP)
    serveuse := loge(ServeuseHTTP)

    boucle_évènements := crée_boucle()
    ctx := crée_contexte_vide(boucle_évènements, T)

    ctx.mute_serveuse(serveuse)

    prise := crée_prise_pour_écoute(ctx, adresse_ip, port, connexions_max, TypeDonnéesPrise)

    // À FAIRE erreur
    si !prise {
        détruit_serveuse(serveuse)
        retourne nul
    }

    serveuse.boucle_évènements = boucle_évènements
    serveuse.ctx = ctx
    serveuse.adresse_ip = adresse_ip
    serveuse.port = port

    serveuse.rappel_quand_ouverture(quand_ouverture)
    serveuse.rappel_quand_lecture(quand_lecture)

    retourne serveuse
}

lance :: fonc (serveuse: *ServeuseHTTP)
{
    serveuse.boucle_évènements.lance()
}

détruit_serveuse :: fonc (serveuse: *ServeuseHTTP)
{
    détruit_boucle(serveuse.boucle_évènements)
    détruit_contexte(serveuse.ctx)
    déloge(serveuse)
}

ajoute_route_get :: fonc (serveuse: *ServeuseHTTP, chemin: chaine, rappel: TypeRappelRoute)
{
    route: Route = ---
    route.chemin = chemin
    route.rappel = rappel

    tableau_ajoute(*serveuse.routeuse.routes_get, route)
}

ajoute_route_post :: fonc (serveuse: *ServeuseHTTP, chemin: chaine, rappel: TypeRappelRoute)
{
    route: Route = ---
    route.chemin = chemin
    route.rappel = rappel

    tableau_ajoute(*serveuse.routeuse.routes_post, route)
}

quand_ouverture :: fonc (prise: *Prise)
{
    quand_lecture(prise)
}

quand_lecture :: fonc (prise: *Prise)
{
    contenu := tente lis_tout(*prise.fichier) piège err {
        retourne
    }

    si !contenu {
        retourne
    }

    imprime("reçu :\n%\n", contenu)

    serveuse := prise.contexte_.accède_serveuse(ServeuseHTTP)

    message := parse_message_cliente(contenu)

    rappel_route := apparie_route(serveuse.routeuse, message.requête, message.méthode)

    saufsi rappel_route {
        _ := écris(*prise.fichier, "HTTP/1.1 404 NOT FOUND\r\n")
        _ = écris(*prise.fichier, "Server: test\r\n")
        _ = écris(*prise.fichier, "Connection: close\r\n")
        _ = écris(*prise.fichier, "\r\n")
        prise.ferme()
        retourne
    }

    // si serveuse.intergiciel {
    //     serveuse.intergiciel(prise, message)
    //     // ...
    // }

    réponse := rappel_route(prise, message)

    écris_réponse(prise, réponse)
}

// Entête: Cache-Control
// pour supprimer un cache, ajouter max-age=0
// https://developer.mozilla.org/fr/docs/Web/HTTP/Headers/Cache-Control
PolitiqueDeCache :: énum {
    Revalide // no-cache
    ClientsSeulement // private
    NeJamaisCacher // no-store
}

écris_réponse :: fonc (prise: *Prise, message: &MessageServeuseHTTP)
{
    enchaineuse : Enchaineuse
    initialise_enchaineuse(*enchaineuse)
    diffère détruit_tampons(*enchaineuse)

    serveuse := prise.contexte_.accède_serveuse(ServeuseHTTP)

    ajoute_au_tampon(*enchaineuse, message.version, " ", chaine_code_état_http(message.code_état), "\r\n")
    ajoute_au_tampon(*enchaineuse, "Server: ", serveuse.nom, "\r\n")

    date := hui_système()
    date_http := date_http_depuis_date(date)

    ajoute_au_tampon(*enchaineuse, "Date: ")
    imprime_date_http(*enchaineuse, date_http)
    ajoute_au_tampon(*enchaineuse, "\r\n")

    pour message.entêtes {
        ajoute_au_tampon(*enchaineuse, it.nom, ": ", it.valeur, "\r\n")
    }

    // Évite le traçage FLoC de Google
    si !possède_entête(message, "Permissions-Policy") {
        ajoute_au_tampon(*enchaineuse, "Permissions-Policy: interest-cohort=()\r\n")
    }

    // Évite le clickjacking
    // À FAIRE: https://developer.mozilla.org/fr/docs/Web/HTTP/Headers/Content-Security-Policy
    // https://www.netsparker.com/blog/web-security/clickjacking-attack-on-facebook-how-tiny-attribute-save-corporation/
    si !possède_entête(message, "X-Frame-Options") {
        ajoute_au_tampon(*enchaineuse, "X-Frame-Options: deny\r\n")
    }

    si message.contenu {
        ajoute_au_tampon(*enchaineuse, "Content-Length: ", message.contenu.taille, "\r\n")
    }

    ajoute_au_tampon(*enchaineuse, "\r\n")

    si message.contenu {
        ajoute_au_tampon(*enchaineuse, message.contenu)
    }

    _ := copie_enchaineuse_fichier(*enchaineuse, *prise.fichier)
}

chaine_pour_aujourdhui :: fonc (enchaineuse : *Enchaineuse) -> rien
{
    date := hui_système()

    ajoute_au_tampon(enchaineuse, chaine_jour_pour_tm(date.jour_semaine), ", ")

    si date.jour < 10 {
        ajoute_au_tampon(enchaineuse, '0')
    }

    ajoute_au_tampon(enchaineuse, date.jour, " ", chaine_mois_pour_tm(date.mois), " ", date.année)

    ajoute_au_tampon(enchaineuse, " ")

    heure := date.heure

    si heure < 10 {
        ajoute_au_tampon(enchaineuse, '0')
    }

    ajoute_au_tampon(enchaineuse, heure, ":")

    si date.minute < 10 {
        ajoute_au_tampon(enchaineuse, '0')
    }

    ajoute_au_tampon(enchaineuse, date.minute, ":")

    si date.seconde < 10 {
        ajoute_au_tampon(enchaineuse, '0')
    }

    ajoute_au_tampon(enchaineuse, date.seconde)

    ajoute_au_tampon(enchaineuse, " GMT")
}
