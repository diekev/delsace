/*

    Module de service HTTP.

    Définie une serveuse pouvant recevoir des requête HTTP.
    La serveuse dérive de ServeuseTCP.
    Si vous voulez utiliser un service se basant sur Apache, utilisez plutôt ServeuseCGI.

    Pour répondre à des requêtes, la serveuse doit connaître les routes possibles, et pour ce faire utilise une Routeuse.

 */

/*

    À FAIRE :
    - paramétrise les logs
    - gestion des fichiers statiques

 */

importe Fondation
importe Réseau
importe Routage
importe SysFichier
importe Temps
importe ServeuseTCP

charge "entete_http"

/*
    serveuse: ServeuseHTTP(Site)
    serveuse.écoute_sur("localhost", 5000)

    serveuse.intergiciel = intergiciel;

    /* initialise les routes */
    serveuse.ajoute_route(....)

    serveuse.lance()
 */

ServeuseHTTP :: struct ($T: type_de_données) {
    empl base: ServeuseTCP(T)

    routeuse: Routeuse(T)

    quand_connexion = #cuisine quand_connexion_http(T = T)

    intergiciel : fonc(*Requête, *T)(RésultatRequête)
}

ajoute_route :: fonc (serveuse: &ServeuseHTTP($T), chemin: chaine, méthode_get: fonc(*Requête, *T)(RésultatRequête), méthode_post: fonc(*Requête, *T)(RésultatRequête))
{
    ajoute_route(*serveuse.routeuse, chemin, méthode_get, méthode_post)
}

écoute_sur :: fonc (serveuse: &ServeuseHTTP($T), adresse: AdresseTCP) -> chaine
{
    // À FAIRE(langage) : ceci devrait être géré d'une manière ou d'une autre par la monomorphisation
    retourne écoute_sur(serveuse comme &ServeuseTCP(T), adresse)
}

lance :: fonc (serveuse: &ServeuseHTTP($T))
{
    lance(serveuse comme &ServeuseTCP(T))
}

quand_connexion_http :: fonc (serveuse_tcp: &ServeuseTCP($T), cliente: ClienteTCP)
{
    serveuse := serveuse_tcp comme &ServeuseHTTP(T)

    // À FAIRE : défini si l'on doit fermer la connexion
    diffère { _ := ferme(*cliente.fichier) }

    // lis le tampon
    données_requête := tente lis_tout(*cliente.fichier) piège err {
        retourne
    }

    // parse la requête HTTP
    analyseuse : AnalyseuseRequête
    analyseuse.requête = données_requête

    ligne_requête := analyse_ligne_requête(*analyseuse)

    entêtes := analyse_entêtes(*analyseuse)
    diffère { détruit_entêtes(*entêtes); }

    contenu_requête := analyse_contenu(*analyseuse)

    uri := tente parse_uri_depuis_chemin_requête(ligne_requête.chemin) piège err {
        // @erreur
        retourne
    }

    requête : Requête
    requête.uri = uri
    // À FAIRE : parse cookies
    // requête.cookies = cookies
    requête.méthode = ligne_requête.méthode
    requête.adresse_ip = cliente.adresse

    si serveuse.intergiciel {
        résultat := serveuse.intergiciel(*requête, serveuse.routeuse.données_serveuse)

        si résultat.status != CodeÉtatHTTP.OK {
            crée_réponse(résultat, cliente)
            retourne
        }

        // À FAIRE : ceci est pour détecter les cas où nous avons un fichier, ou une icone
        si résultat.type_contenu {
            crée_réponse(résultat, cliente)
            retourne
        }
    }

    // résoud la requête
    // À FAIRE: trouve une meilleure manière de passer cette information
    serveuse.routeuse.données_serveuse = *serveuse.données
    résultat := apparie_route(*serveuse.routeuse, *requête)

    // envoie la réponse au client
    crée_réponse(résultat, cliente)
}

crée_réponse :: fonc (résultat: &RésultatRequête, cliente: &ClienteTCP)
{
    enchaineuse : Enchaineuse
    initialise_enchaineuse(*enchaineuse)
    diffère { détruit_tampons(*enchaineuse) }

    contenu := résultat.contenu

    ajoute_au_tampon(*enchaineuse, "HTTP/1.1 ", chaine_code_état_http(résultat.status), "\r\n")
    // À FAIRE : paramétrise le nom du serveur
    ajoute_au_tampon(*enchaineuse, "Server: delsace\r\n")
    ajoute_au_tampon(*enchaineuse, "Content-Length: ", contenu.taille, "\r\n")

    si résultat.type_contenu {
        imprime_dans_enchaineuse(*enchaineuse, "Content-Type: %\r\n", résultat.type_contenu)
    }

    pour résultat.entêtes {
        imprime_dans_enchaineuse(*enchaineuse, "%: %\r\n", it.nom, it.valeur)
    }

    pour résultat.cookies {
        chn_cookie := chaine_cookie_pour_entête_http(it)
        imprime_dans_enchaineuse(*enchaineuse, "Set-Cookie: %\r\n", chn_cookie)
        déloge(chn_cookie)
    }

/*
    discr réponse.type_contenu {
        TEXT_HTML {
            ajoute_au_tampon(*enchaineuse, "Content-Type: text/html; charset=utf-8\r\n")
        }
        APPLICATION_JAVASCRIPT {
            ajoute_au_tampon(*enchaineuse, "Content-Type: application/javascript\r\n")
            ajoute_au_tampon(*enchaineuse, "Content-Disposition: attachment; filename='test.js'\r\n")
            ajoute_au_tampon(*enchaineuse, "Cache-Control: public, max-age=31556952, immutable\r\n")
        }
        APPLICATION_JSON {
            ajoute_au_tampon(*enchaineuse, "Content-Type: application/json; charset=utf-8\r\n")
        }
        sinon {
            // RÀF
        }
    }
*/

    ajoute_au_tampon(*enchaineuse, "Date: ")
    chaine_pour_aujourdhui(*enchaineuse)
    ajoute_au_tampon(*enchaineuse, "\r\n")

    // À FAIRE: Content-Encoding, voir Accept-Encoding de la requête

    ajoute_au_tampon(*enchaineuse, "Set-Cookie: test=abcdefg; Domain=localhost; Max-Age=60; Path=/; HttpOnly\r\n")

    ajoute_au_tampon(*enchaineuse, "\r\n")
    ajoute_au_tampon(*enchaineuse, contenu)

    chaine_reponse := chaine_depuis_enchaineuse(*enchaineuse)
    diffère { déloge(chaine_reponse); }

    tente écris(*cliente.fichier, chaine_reponse) piège err {
        retourne
    }
}

chaine_pour_aujourdhui :: fonc (enchaineuse : *Enchaineuse) -> rien
{
    date := hui_système()

    ajoute_au_tampon(enchaineuse, chaine_jour_pour_tm(date.jour_semaine), ", ")

    si date.jour < 10 {
        ajoute_au_tampon(enchaineuse, '0')
    }

    ajoute_au_tampon(enchaineuse, date.jour, " ", chaine_mois_pour_tm(date.mois), " ", date.année)

    ajoute_au_tampon(enchaineuse, " ")

    heure := date.heure

    si heure < 10 {
        ajoute_au_tampon(enchaineuse, '0')
    }

    ajoute_au_tampon(enchaineuse, heure, ":")

    si date.minute < 10 {
        ajoute_au_tampon(enchaineuse, '0')
    }

    ajoute_au_tampon(enchaineuse, date.minute, ":")

    si date.seconde < 10 {
        ajoute_au_tampon(enchaineuse, '0')
    }

    ajoute_au_tampon(enchaineuse, date.seconde)

    ajoute_au_tampon(enchaineuse, " GMT")
}
