importe Fondation
importe Numérique
importe Réseau

// ----------------------------------------------------

entier_vers_chaine :: fonc (entier: z64) -> chaine
{
    enchaineuse : Enchaineuse
    initialise_enchaineuse(*enchaineuse)

    ajoute_au_tampon(*enchaineuse, entier)

    retourne chaine_depuis_enchaineuse(*enchaineuse)
}

// ----------------------------------------------------

PositionChaine :: struct {
    début: z32
    fin: z32
}

taille_position :: fonc (position: PositionChaine) -> z32
{
    retourne position.fin - position.début
}

sous_chaine :: fonc (chn: chaine, position: PositionChaine) -> chaine
{
    résultat : chaine = ---
    résultat.pointeur = chn.pointeur + position.début
    résultat.taille = position.fin - position.début
    retourne résultat
}

// ----------------------------------------------------

DonnéesEntête :: struct {
    position_nom: PositionChaine
    position_valeur: PositionChaine
}

// À FAIRE : enregistre proprement les positions, nous ne pouvons utiliser des sous chaines quand une requête n'est pas encore terminée !
DonnéesMessage :: struct {
    position_méthode: PositionChaine
    position_requête: PositionChaine
    position_version: PositionChaine

    positions_entêtes: []DonnéesEntête

    // si taille fixe
    position_contenu: PositionChaine

    // si chunked
    contenu : chaine
}

ajoute_entête :: fonc (données_message: &DonnéesMessage, nom: PositionChaine, valeur: PositionChaine)
{
    tableau_ajoute(*données_message.positions_entêtes, DonnéesEntête(nom, valeur))
}

// ----------------------------------------------------

ÉtatParsage :: énum {
    NON_COMMENCÉ
    MÉTHODE_OBTENUE
    REQUÊTE_OBTENUE
    VERSION_OBTENUE
    ENTÊTE_EN_COURS
    MESSAGE_TERMINÉ
    CORPS_EN_COURS // voir si content-length, ou chunked
    PARSAGE_TERMINÉ
    ERREUR
}

// ----------------------------------------------------

/* Parseuse pour des requêtes HTTP, cette parseuse est désignée pour pouvoir accumuler les données
 * afin de prendre en compte les requêtes arrivant partiellement, soit par le type de contenu est
 * « chunked », ou encore parce que nous sommes appelés illégitimement par OpenSSL ou un thread qui
 * se réveille, ou encore car nous subissons une attaque « SlowLoris ».
 */
ParseuseHTTP :: struct {
    message_en_cours: MessageClienteHTTP
    données_message: DonnéesMessage

    données: chaine

    état_parsage: ÉtatParsage

    parseuse_chaine: ParseuseChaine

    // pour le parsage du contenu
    taille_contenu : z32

    contenu_chunked : bool
    contenu_fixe : bool

    pour_sous_message := faux
}

ajourne_données :: fonc (parseuse: *ParseuseHTTP, données: chaine)
{
    saufsi données {
        retourne
    }

    chaine_ajoute(*parseuse.données, données)

    parseuse.parseuse_chaine.chn = parseuse.données

    parse_données(parseuse)
}

parse_données :: fonc (parseuse: *ParseuseHTTP)
{
    si parseuse.état_parsage == ÉtatParsage.NON_COMMENCÉ {
        début := parseuse.parseuse_chaine.curseur

        // taille max d'une commande HTTP + 1
        si parseuse.données.taille < 8 {
            retourne
        }

        méthodes : []chaine = ["GET", "POST", "PUT", "DELETE", "HEAD", "CONNECT", "OPTIONS", "TRACE", "PATCH"]

        index := apparie_un_de(*parseuse.parseuse_chaine, ...méthodes)

        si index == -1 {
            parseuse.état_parsage = ÉtatParsage.ERREUR
            retourne
        }

        méthode := méthodes[index]

        positionne(*parseuse.parseuse_chaine, méthode.taille)

        parseuse.état_parsage = ÉtatParsage.MÉTHODE_OBTENUE
        parseuse.données_message.position_méthode = PositionChaine(début, début + méthode.taille comme z32)
    }

    si parseuse.état_parsage == ÉtatParsage.MÉTHODE_OBTENUE {
        si !consomme(*parseuse.parseuse_chaine, ' ') {
            parseuse.état_parsage = ÉtatParsage.ERREUR
            retourne
        }

        début := parseuse.parseuse_chaine.curseur

        pos_prochain_espace := trouve_prochain(*parseuse.parseuse_chaine, ' ')

        si pos_prochain_espace <= 0 {
            // recule pour revenir sur l'espace avant le chemin
            parseuse.parseuse_chaine.curseur -= 1
            retourne
        }

        requête := sous_chaine_jusque_index(*parseuse.parseuse_chaine, pos_prochain_espace)
        positionne(*parseuse.parseuse_chaine, pos_prochain_espace + 1)

        parseuse.état_parsage = ÉtatParsage.REQUÊTE_OBTENUE
        parseuse.données_message.position_requête = PositionChaine(début, début + requête.taille comme z32)
    }

    si parseuse.état_parsage == ÉtatParsage.REQUÊTE_OBTENUE {
        début := parseuse.parseuse_chaine.curseur
        pos_nouvelle_ligne := trouve_prochain(*parseuse.parseuse_chaine, "\r\n")

        si pos_nouvelle_ligne <= 0 {
            retourne
        }

        version := sous_chaine_jusque_index(*parseuse.parseuse_chaine, pos_nouvelle_ligne)
        positionne(*parseuse.parseuse_chaine, pos_nouvelle_ligne + 2)

        parseuse.état_parsage = ÉtatParsage.VERSION_OBTENUE
        parseuse.données_message.position_version = PositionChaine(début, début + version.taille comme z32)
    }

    si parseuse.état_parsage == ÉtatParsage.VERSION_OBTENUE {
        parseuse.état_parsage = ÉtatParsage.ENTÊTE_EN_COURS
    }

    si parseuse.état_parsage == ÉtatParsage.ENTÊTE_EN_COURS {
        tantque !fini(*parseuse.parseuse_chaine) && parseuse.état_parsage != ÉtatParsage.MESSAGE_TERMINÉ {
            // parse une entête
            pos_courante := parseuse.parseuse_chaine.curseur
            pos_nouvelle_ligne := trouve_prochain(*parseuse.parseuse_chaine, "\r\n")

            // une ligne vide indique la fin des entêtes
            si pos_nouvelle_ligne == parseuse.parseuse_chaine.curseur {
                avance(*parseuse.parseuse_chaine, 2)
                parseuse.état_parsage = ÉtatParsage.MESSAGE_TERMINÉ
            }
            sinon {
                pos_double_points := trouve_prochain(*parseuse.parseuse_chaine, ':')

                si pos_double_points <= 0 {
                    positionne(*parseuse.parseuse_chaine, pos_courante)
                    retourne
                }

                nom := sous_chaine_jusque_index(*parseuse.parseuse_chaine, pos_double_points)

                positionne(*parseuse.parseuse_chaine, pos_double_points + 1)

                saute_espace_blanc(*parseuse.parseuse_chaine)

                début_valeur := parseuse.parseuse_chaine.curseur

                // valeur
                si pos_nouvelle_ligne <= 0 {
                    positionne(*parseuse.parseuse_chaine, pos_courante)
                    retourne
                }

                valeur := sous_chaine_jusque_index(*parseuse.parseuse_chaine, pos_nouvelle_ligne)

                positionne(*parseuse.parseuse_chaine, pos_nouvelle_ligne + 2)

                position_nom := PositionChaine(pos_courante, pos_courante + nom.taille comme z32)
                position_valeur := PositionChaine(début_valeur, début_valeur + valeur.taille comme z32)

                parseuse.données_message.ajoute_entête(position_nom, position_valeur)
            }
        }
    }

    si parseuse.état_parsage == ÉtatParsage.MESSAGE_TERMINÉ {
        message := parseuse.prépare_message_pour_parsage_contenu()

        si possède_entête(message, "Transfer-Encoding") {
            chn_transfer_encoding := entête(message, "Transfer-Encoding").valeur

            // À FAIRE : il existe des options
            si chn_transfer_encoding != "chunked" {
                parseuse.état_parsage = ÉtatParsage.ERREUR
                retourne
            }

            parseuse.état_parsage = ÉtatParsage.CORPS_EN_COURS
            parseuse.contenu_chunked = vrai
        }
        sinon si possède_entête(message, "Content-Length") {
            chn_taille_contenu := entête(message, "Content-Length").valeur

            taille_contenu := tente extrait_z32(chn_taille_contenu) piège err {
                parseuse.état_parsage = ÉtatParsage.ERREUR
                retourne
            }

            parseuse.contenu_fixe = vrai
            parseuse.taille_contenu = taille_contenu
            parseuse.état_parsage = ÉtatParsage.CORPS_EN_COURS
            parseuse.données_message.position_contenu.début = parseuse.parseuse_chaine.curseur
            parseuse.données_message.position_contenu.fin = parseuse.parseuse_chaine.curseur
        }
        sinon si parseuse.pour_sous_message {
            parseuse.contenu_fixe = vrai
            parseuse.taille_contenu = (parseuse.parseuse_chaine.chn.taille - parseuse.parseuse_chaine.curseur) comme z32
            parseuse.état_parsage = ÉtatParsage.CORPS_EN_COURS
            parseuse.données_message.position_contenu.début = parseuse.parseuse_chaine.curseur
            parseuse.données_message.position_contenu.fin = parseuse.parseuse_chaine.curseur
        }
        sinon {
            parseuse.état_parsage = ÉtatParsage.PARSAGE_TERMINÉ
        }
    }

    si parseuse.état_parsage == ÉtatParsage.CORPS_EN_COURS {
        si parseuse.contenu_fixe {
            parseuse.données_message.position_contenu.fin = parseuse.parseuse_chaine.chn.taille comme z32

            si taille_position(parseuse.données_message.position_contenu) >= parseuse.taille_contenu {
                // tronque le contenu
                // À FAIRE : erreur ?
                parseuse.données_message.position_contenu.fin = parseuse.données_message.position_contenu.début + parseuse.taille_contenu
                parseuse.état_parsage = ÉtatParsage.PARSAGE_TERMINÉ
            }
        }
        sinon si parseuse.contenu_chunked {
            taille := 0

            boucle {
                pos_courante := parseuse.parseuse_chaine.curseur

                /* ** read chunk-size, chunk-extension (if any) and CRLF ** */

                // À FAIRE: chunk-extension

                // parse la taille du chunk
                pos_nouvelle_ligne := trouve_prochain(*parseuse.parseuse_chaine, "\r\n")

                si pos_nouvelle_ligne <= 0 {
                    retourne
                }

                valeur := sous_chaine_jusque_index(*parseuse.parseuse_chaine, pos_nouvelle_ligne)

                taille_chunk := tente parse_hexadécimal_z32(valeur) piège err {
                    parseuse.état_parsage = ÉtatParsage.ERREUR
                    retourne
                }

                si taille_chunk == 0 {
                    arrête
                }

                positionne(*parseuse.parseuse_chaine, pos_nouvelle_ligne + 2)

                index_fin_chunk := parseuse.parseuse_chaine.curseur + taille_chunk

                si index_fin_chunk >= parseuse.parseuse_chaine.chn.taille {
                    positionne(*parseuse.parseuse_chaine, pos_courante)
                    retourne
                }

                /* ** append chunk-data to entity-body ** */
                données := sous_chaine_jusque_index(*parseuse.parseuse_chaine, index_fin_chunk)

                positionne(*parseuse.parseuse_chaine, index_fin_chunk)

                si !consomme(*parseuse.parseuse_chaine, "\r\n") {
                    positionne(*parseuse.parseuse_chaine, pos_courante)
                    retourne
                }

                taille += données.taille comme z32
                chaine_ajoute(*parseuse.données_message.contenu, données)
            }

            parseuse.état_parsage = ÉtatParsage.PARSAGE_TERMINÉ

            // À FAIRE : entêtes "trailing"

            /*

            length := 0
            read chunk-size, chunk-extension (if any) and CRLF
            while (chunk-size > 0) {
                read chunk-data and CRLF
                append chunk-data to entity-body
                length := length + chunk-size
                read chunk-size and CRLF
            }
            read entity-header
            while (entity-header not empty) {
                append entity-header to existing header fields
                read entity-header
            }
            Content-Length := length
            Remove "chunked" from Transfer-Encoding

            */
        }
    }
}

message_est_erroné :: fonc (parseuse: *ParseuseHTTP) -> bool
{
    retourne parseuse.état_parsage == ÉtatParsage.ERREUR
}

message_prêt_pour_finalisation :: fonc (parseuse: *ParseuseHTTP) -> bool
{
    retourne parseuse.état_parsage == ÉtatParsage.PARSAGE_TERMINÉ
}

prépare_message_pour_parsage_contenu :: fonc (parseuse: *ParseuseHTTP) -> MessageClienteHTTP
{
    parseuse.message_en_cours.méthode = sous_chaine(parseuse.données, parseuse.données_message.position_méthode)
    parseuse.message_en_cours.requête = sous_chaine(parseuse.données, parseuse.données_message.position_requête)
    parseuse.message_en_cours.version = sous_chaine(parseuse.données, parseuse.données_message.position_version)

    pour parseuse.données_message.positions_entêtes {
        nom := sous_chaine(parseuse.données, it.position_nom)
        valeur := sous_chaine(parseuse.données, it.position_valeur)

        ajoute_entête(*parseuse.message_en_cours, nom, valeur)
    }

    retourne parseuse.message_en_cours
}

finalise_message :: fonc (parseuse: *ParseuseHTTP) -> MessageClienteHTTP
{
    détruit_message(*parseuse.message_en_cours)

    // reprépare le message car nous avons potentiellement ajouter des choses
    // au tampon du message invalidant alors les pointeurs
    message := parseuse.prépare_message_pour_parsage_contenu()

    pour message.entêtes {
        si it.nom == "Cookie" {
            message.cookies = parse_cookie_client(it.valeur)
        }
    }

    résoud_échappement_url_localement(message.requête)

    message.uri = tente parse_uri_depuis_chemin_requête(message.requête) piège err {
        parseuse.état_parsage = ÉtatParsage.ERREUR
        retourne message
    }

    parseuse.message_en_cours = message

    si parseuse.données_message.contenu {
        parseuse.message_en_cours.contenu = parseuse.données_message.contenu
        chn_taille_contenu := entier_vers_chaine(parseuse.message_en_cours.contenu.taille)
        fusionne_entête(*parseuse.message_en_cours, "Content-Length", chn_taille_contenu)
    }
    sinon {
        parseuse.message_en_cours.contenu = sous_chaine(parseuse.données, parseuse.données_message.position_contenu)
    }

    retourne parseuse.message_en_cours
}

réinitialise :: fonc (parseuse: *ParseuseHTTP)
{
    détruit_message(*parseuse.message_en_cours)
    déloge(parseuse.données)
    déloge(parseuse.données_message.positions_entêtes)
    init_de(ParseuseHTTP)(parseuse)
}
