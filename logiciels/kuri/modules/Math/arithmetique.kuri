// À FAIRE : implémente les fonctions suivantes avec notre langage

#bibliothèque_dynamique "m"

sqrt :: fonc externe (v: r64) -> r64
cos :: fonc externe (a : r64) -> r64
sin :: fonc externe (a : r64) -> r64
tan :: fonc externe (a : r64) -> r64
acos :: fonc externe (a : r64) -> r64
asin :: fonc externe (a : r64) -> r64
atan :: fonc externe (a : r64) -> r64
atan2 :: fonc externe (a : r64, b: r64) -> r64
pow :: fonc externe (a: r64, b: r64) -> r64
ceil :: fonc externe (a: r64) -> r64
floor :: fonc externe (a: r64) -> r64
copysign :: fonc externe (a: r64, b: r64) -> r64

sol :: fonc (a: r32) -> r32
{
    retourne floor(a) comme r32
}

sol :: fonc (a: r64) -> r64
{
    retourne floor(a)
}

plafond :: fonc (a: r32) -> r32
{
    retourne ceil(a) comme r32
}

plafond :: fonc (a: r64) -> r64
{
    retourne ceil(a)
}

cosinus :: fonc (a: r32) -> r32
{
    retourne cos(a) comme r32
}

cosinus :: fonc (a: r64) -> r64
{
    retourne cos(a)
}

sinus :: fonc (a: r32) -> r32
{
    retourne sin(a) comme r32
}

sinus :: fonc (a: r64) -> r64
{
    retourne sin(a)
}

puissance :: fonc (v: r32, exp: r32) -> r32
{
    retourne pow(v, exp) comme r32
}

puissance :: fonc (v: r64, exp: r64) -> r64
{
    retourne pow(v, exp)
}

copie_signe :: fonc (a: r32, b: r32) -> r32
{
    retourne copysign(a, b) comme r32
}

copie_signe :: fonc (a: r64, b: r64) -> r64
{
    retourne copysign(a, b)
}

// calcul d'une racine carré d'un nombre réel selon la méthode approximative de Newton
racine_carrée :: fonc (n: r64) -> r64
{
    si n == 0.0 {
        retourne 0.0
    }

    si n == 1.0 {
        retourne 1.0
    }

    si n < 0.0 {
        // À FAIRE: retourne NaN
        retourne 0.0
    }

    PRÉCISION := 0.0001
    limite_basse : r64
    limite_haute : r64

    si n < 1.0 {
        limite_basse = n
        limite_haute = 1.0
    }
    sinon {
        limite_basse = 1.0
        limite_haute = n
    }

    tantque (limite_haute - limite_basse) > PRÉCISION {
        prédiction := (limite_basse + limite_haute) * 0.5

        si (prédiction * prédiction) > n {
            limite_haute = prédiction
        }
        sinon {
            limite_basse = prédiction
        }
    }

    retourne (limite_basse + limite_haute) * 0.5
}

racine_cubique :: fonc (n: r64) -> r64
{
    si n == 0.0 {
        retourne 0.0
    }

    si n == 1.0 {
        retourne 1.0
    }

    PRÉCISION := 0.00001
    limite_basse : r64
    limite_haute : r64

    si n < 1.0 {
        limite_basse = n
        limite_haute = 1.0
    }
    sinon {
        limite_basse = 1.0
        limite_haute = n
    }

    tantque (limite_haute - limite_basse) > PRÉCISION {
        prédiction := (limite_basse + limite_haute) * 0.5

        si (prédiction * prédiction * prédiction) > n {
            limite_haute = prédiction
        }
        sinon {
            limite_basse = prédiction
        }
    }

    retourne (limite_basse + limite_haute) * 0.5
}

// À FAIRE : certaines fonctions ne de sens que pour les nombres relatifs ou réels

abs :: fonc(a : $T) -> $T #enligne
{
    si a < 0 comme $T { retourne -a } sinon { retourne a; }
	//retourne si a < 0 { -a } sinon { a }
}

min :: fonc(a : $T, b : $T) -> $T #enligne
{
    si a < b { retourne a; } sinon { retourne b; }
	//retourne si a < b { a } sinon { b }
}

/*
min :: fonc(args : ...$T) -> $T
{
	vmin := args[0]

	pour v, index dans 1 ... args.taille - 1 {
		vmin = min(vmin, v)
	}

	retourne vmin
}
*/

max :: fonc(a : $T, b : $T) -> $T #enligne
{
    si a > b { retourne a; } sinon { retourne b; }
	//retourne si a > b { a } sinon { b }
}

/*
max :: fonc(args : ...$T) -> $T
{
	vmax := args[0]

	pour v, index dans 1 ... args.taille - 1 {
		vmax = max(vmin, v)
	}

	retourne vmax
}
*/

restreint :: fonc(x : *$T, min : $T, max : $T) -> rien #enligne
{
    si mémoire(x) <= min {
        mémoire(x) = min;
    }
    si mémoire(x) >= max {
        mémoire(x) = max;
    }
}

// Trouve le plus grand commun diviseur selon l'algorithme d'Euclide
pgcd :: fonc(a : z32, b : z32) -> z32
{
	x := a
	y := b

	tantque y > 1 {
		x = y
		y = x % y
	}

	retourne x
}

// Trouve le plus petit commun multiple
ppmc :: fonc(a : z32, b : z32) -> z32
{
	si a == 0 || b == 0 {
		retourne 0
	}

	retourne abs(a * b) / pgcd(a, b)
}
