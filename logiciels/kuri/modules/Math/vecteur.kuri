importe Compilatrice

// ------------------------------------
// vecteurs de nombres réels

/* ------------------------------------------------------------------------- */
/* Vecteur 2D
 * \{ */

Vec2 :: struct {
    x := 0.0 @mutable
    y := 0.0 @mutable
}

new_Vec2_pour_python :: fonc (vec: *Vec2, x: r32, y: r32) -> bool
{
    vec.x = x
    vec.y = y
    retourne vrai
} @Python "new"

str_Vec2_pour_python :: fonc (v: *Vec2) -> chaine
{
    retourne imprime_chaine("Vec2(%, %)", v.x, v.y)
} @Python "str"

produit_scalaire :: fonc (u: Vec2, v: Vec2) -> r32
{
    retourne u.x * v.x + u.y * v.y
}

produit_vectoriel :: fonc (u: Vec2, v: Vec2) -> r32
{
    retourne u.x * v.y - u.y * v.x
}

longueur :: fonc (u: Vec2, v: Vec2) -> r32
{
    retourne longueur(u - v)
}

longueur :: fonc (u: Vec2) -> r32
{
    retourne racine_carrée(produit_scalaire(u, u))
}

longueur_carrée :: fonc (u: Vec2, v: Vec2) -> r32
{
    w := v - u
    retourne produit_scalaire(w, w)
}

// projection vectorielle de a sur b
projette :: fonc (a: Vec2, b: Vec2) -> Vec2
{
    retourne produit_scalaire(a, b) / produit_scalaire(b, b) * b
}

// rejection vectorielle, a1 doit être une projection
rejette :: fonc (a1: Vec2, a: Vec2) -> Vec2
{
    retourne a - a1
}

angle_entre :: fonc (a: Vec2, b: Vec2) -> r32
{
    a = normalise(a)
    b = normalise(b)

    /* Plus précis que arccosinus(produit_scalaire(a, b)). */
    si produit_scalaire(a, b) >= 0.0 {
        retourne 2.0 * arc_sinus_borné(longueur(a, b) * 0.5)
    }

    b2 := -b
    retourne Constantes(r32).PI - 2.0 * arc_sinus_borné(longueur(a, b2) * 0.5)
}

normalise :: fonc (v: Vec2) -> Vec2
{
    l := longueur(v)
    retourne v / l
}

/* \} */

/* ------------------------------------------------------------------------- */
/* Vecteur 3D
 * \{ */

// À considérer: opérateurs de bases si la structure ne contient que des scalaires
Vec3 :: struct {
    x: r32 @mutable
    y: r32 @mutable
    z: r32 @mutable
}

Point3 :: #opaque Vec3
Norm3 :: #opaque Vec3

new_Vec3_pour_python :: fonc (vec: *Vec3) -> bool
{
    init_de(Vec3)(vec)
    retourne vrai
} @Python "new"

produit_scalaire :: fonc (u: Vec3, v: Vec3) -> r32 #enligne
{
    retourne u.x * v.x + u.y * v.y + u.z * v.z
}

longueur :: fonc (u: Vec3) -> r32 #enligne
{
    retourne racine_carrée(u.x * u.x + u.y * u.y + u.z * u.z)
}

longueur_carrée :: fonc (u: Vec3) -> r32 #enligne
{
    retourne produit_scalaire(u, u)
}

produit_vectoriel :: fonc (u: Vec3, v: Vec3) -> Vec3 #enligne
{
    résultat : Vec3 = ---
    résultat.x = u.y * v.z - u.z * v.y
    résultat.y = u.z * v.x - u.x * v.z
    résultat.z = u.x * v.y - u.y * v.x
    retourne résultat
}

produit_en_croix :: fonc (u: Vec3, v: Vec3) -> Vec3 #enligne
{
    retourne produit_vectoriel(u, v)
}

calcul_normal :: fonc (a: Vec3, b: Vec3) -> Norm3 #enligne
{
    résultat := produit_en_croix(a, b)
    retourne Norm3(résultat)
}

calcul_normal_normalisé :: fonc (a: Vec3, b: Vec3) -> Norm3 #enligne
{
    nor := calcul_normal(a, b)
    l := longueur(nor comme Vec3)
    si l != 0.0 {
        nor.x /= l
        nor.y /= l
        nor.z /= l
    }
    retourne nor
}

normalise :: fonc (v: Vec3) -> Vec3 #enligne
{
    l := longueur(v)
    retourne v / l
}

normalise_retourne_longueur :: fonc (v: Vec3) -> Vec3, r32 #enligne
{
    l := longueur(v)
    retourne v / l, l
}

// Calcul des coordonnées UV depuis une vecteur de direction (I) et d'un
// vecteur normal (N) pour échantillonner une capmat.
calcul_uv_capmat :: fonc (I: Vec3, N: Vec3, inversé: bool) -> Vec2
{
    // Création rapide d'une base orthonormale
    a := 1.0 / (1.0 + I.z)
    b := -I.x * I.y * a
    b1 := Vec3(1.0 - I.x * I.x * a, b, -I.x)
    b2 := Vec3(b, 1.0 - I.y * I.y * a, -I.y)

    uv_capmat := Vec2(x = produit_scalaire(b1, N), y = produit_scalaire(b2, N))

    si inversé {
        uv_capmat.x = -uv_capmat.x
    }

    uv_capmat.x *= 0.496
    uv_capmat.y *= 0.496

    uv_capmat.x += 0.5
    uv_capmat.y += 0.5

    retourne uv_capmat
}

// -------------------------------------------------------------------------

interp_linéaire :: fonc (v0: Vec3, t: r32, v1: Vec3) -> Vec3
{
    retourne (1.0 - t) * v0 + t * v1
}

/* Calcule la déclinaison du vecteur en degrés. */
déclinaison :: fonc (v: Vec3) -> Degrés(r32)
{
    retourne vers_degrés(Radians(arc_tangeante2(racine_carrée(v.x * v.x + v.y * v.y), v.z)))
}

/* \} */

/* ------------------------------------------------------------------------- */
/* Vecteur 4D
 * \{ */

Vec4 :: struct {
    x := 0.0 @mutable
    y := 0.0 @mutable
    z := 0.0 @mutable
    w := 0.0 @mutable
}

/* \} */

// ------------------------------------
// vecteurs de nombres entiers relatifs

Vec2z :: struct {
    x := 0
    y := 0
}

Vec3z :: struct {
    x := 0
    y := 0
    z := 0
}

Vec4z :: struct {
    x := 0
    y := 0
    z := 0
    w := 0
}

/* ------------------------------------------------------------------------- */
/** \nom Fonctions auxilliaires.
 * \{ */

/* Retourne la position sur une sphère de rayon `r` des coordonnées <u, v>
 * données. `u` doit être entre [-PI, PI], et `v` [-PI/2, PI/2].
 * La sphère est défini pour un système de coordonnées où Y est vertical. */
position_sphérique :: fonc (u: r32, v: r32, r := 1.0) -> Vec3 #enligne
{
    retourne Vec3(cosinus(u) * sinus(v) * r, cosinus(v) * r, sinus(u) * sinus(v) * r)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Génération de code.
 * \{ */

#portée_fichier

génère_opérateurs_vecteurs :: fonc ()
{
    opérateurs_arithmétiques := ["+", "-", "*", "/"]
    opérateurs_logiques := ["==", "!=", "<", "<=", ">", ">="]

    dimensions := [2, 3, 4]

    ajoute_appel_opérateur :: fonc (enchaineuse: *Enchaineuse, op: chaine, rubrique: chaine, est_scalaire: bool)
    {
        si op == "/" {
            si est_scalaire {
                ajoute_au_tampon(enchaineuse, "    si s != 0 {\n    ")
            }
            sinon {
                ajoute_au_tampon(enchaineuse, "    si v.", rubrique , " != 0 {\n    ")
            }
        }

        si est_scalaire {
            ajoute_au_tampon(enchaineuse, "    résultat.", rubrique ," = u.", rubrique ," ", op, " s\n")
        }
        sinon {
            ajoute_au_tampon(enchaineuse, "    résultat.", rubrique ," = u.", rubrique ," ", op, " v.", rubrique ,"\n")
        }

        si op == "/" {
            ajoute_au_tampon(enchaineuse, "    }\n")
        }
    }

    enchaineuse: Enchaineuse
    initialise_enchaineuse(*enchaineuse)

    pour dimension dans dimensions {
        /* négation */
        imprime_dans_enchaineuse(*enchaineuse, "opérateur - :: (u: Vec%) -> Vec%\n", dimension, dimension)
        ajoute_au_tampon(*enchaineuse, "{\n")
        imprime_dans_enchaineuse(*enchaineuse, "    résultat: Vec% = ---\n", dimension)
        ajoute_au_tampon(*enchaineuse, "    résultat.x = -u.x\n")
        ajoute_au_tampon(*enchaineuse, "    résultat.y = -u.y\n")
        si dimension >= 3 {
            ajoute_au_tampon(*enchaineuse, "    résultat.z = -u.z\n")
        }
        si dimension >= 4 {
            ajoute_au_tampon(*enchaineuse, "    résultat.w = -u.w\n")
        }
        ajoute_au_tampon(*enchaineuse, "    retourne résultat\n")
        ajoute_au_tampon(*enchaineuse, "}\n")

        pour op dans opérateurs_arithmétiques {
            /* vecteur - vecteur */
            imprime_dans_enchaineuse(*enchaineuse, "opérateur % :: (u: Vec%, v: Vec%) -> Vec%\n", op, dimension, dimension, dimension)
            ajoute_au_tampon(*enchaineuse, "{\n")

            init := si op == "/" { "" } sinon { " = ---" }

            imprime_dans_enchaineuse(*enchaineuse, "    résultat: Vec%%\n", dimension, init)
            ajoute_appel_opérateur(*enchaineuse, op, "x", faux)
            ajoute_appel_opérateur(*enchaineuse, op, "y", faux)
            si dimension >= 3 {
                ajoute_appel_opérateur(*enchaineuse, op, "z", faux)
            }
            si dimension >= 4 {
                ajoute_appel_opérateur(*enchaineuse, op, "w", faux)
            }
            ajoute_au_tampon(*enchaineuse, "    retourne résultat\n")
            ajoute_au_tampon(*enchaineuse, "}\n")

            /* vecteur - scalaire */
            imprime_dans_enchaineuse(*enchaineuse, "opérateur % :: (u: Vec%, s: r32) -> Vec%\n", op, dimension, dimension)
            ajoute_au_tampon(*enchaineuse, "{\n")

            imprime_dans_enchaineuse(*enchaineuse, "    résultat: Vec%%\n", dimension, init)
            ajoute_appel_opérateur(*enchaineuse, op, "x", vrai)
            ajoute_appel_opérateur(*enchaineuse, op, "y", vrai)
            si dimension >= 3 {
                ajoute_appel_opérateur(*enchaineuse, op, "z", vrai)
            }
            si dimension >= 4 {
                ajoute_appel_opérateur(*enchaineuse, op, "w", vrai)
            }
            ajoute_au_tampon(*enchaineuse, "    retourne résultat\n")
            ajoute_au_tampon(*enchaineuse, "}\n")

            si op == "/" {
                /* réciproque */
                imprime_dans_enchaineuse(*enchaineuse, "opérateur % :: (s: r32, v: Vec%) -> Vec%\n", op, dimension, dimension)
                ajoute_au_tampon(*enchaineuse, "{\n")

                imprime_dans_enchaineuse(*enchaineuse, "    résultat: Vec%%\n", dimension, init)
                ajoute_au_tampon(*enchaineuse, "    si v.x != 0 { résultat.x = s / v.x }\n")
                ajoute_au_tampon(*enchaineuse, "    si v.y != 0 { résultat.y = s / v.y }\n")
                si dimension >= 3 {
                    ajoute_au_tampon(*enchaineuse, "    si v.z != 0 { résultat.z = s / v.z }\n")
                }
                si dimension >= 4 {
                    ajoute_au_tampon(*enchaineuse, "    si v.w != 0 { résultat.w = s / v.w }\n")
                }
                ajoute_au_tampon(*enchaineuse, "    retourne résultat\n")
                ajoute_au_tampon(*enchaineuse, "}\n")
            }
        }

        pour op dans opérateurs_logiques {
            /* vecteur - vecteur */
            imprime_dans_enchaineuse(*enchaineuse, "opérateur % :: (u: Vec%, v: Vec%) -> bool\n", op, dimension, dimension, dimension)
            ajoute_au_tampon(*enchaineuse, "{\n")
            ajoute_au_tampon(*enchaineuse, "    résultat: bool = u.x ", op, " v.x")
            ajoute_au_tampon(*enchaineuse, " && u.y ", op, " v.y")
            si dimension >= 3 {
                ajoute_au_tampon(*enchaineuse, " && u.z ", op, " v.z")
            }
            si dimension >= 4 {
                ajoute_au_tampon(*enchaineuse, " && u.w ", op, " v.w")
            }
            ajoute_au_tampon(*enchaineuse, "\n    retourne résultat\n")
            ajoute_au_tampon(*enchaineuse, "}\n")

            /* vecteur - scalaire */
            imprime_dans_enchaineuse(*enchaineuse, "opérateur % :: (u: Vec%, s: r32) -> bool\n", op, dimension, dimension)
            ajoute_au_tampon(*enchaineuse, "{\n")
            ajoute_au_tampon(*enchaineuse, "    résultat: bool = u.x ", op, " s")
            ajoute_au_tampon(*enchaineuse, " && u.y ", op, " s")
            si dimension >= 3 {
                ajoute_au_tampon(*enchaineuse, " && u.z ", op, " s")
            }
            si dimension >= 4 {
                ajoute_au_tampon(*enchaineuse, " && u.w ", op, " s")
            }
            ajoute_au_tampon(*enchaineuse, "\n    retourne résultat\n")
            ajoute_au_tampon(*enchaineuse, "}\n")
        }

        imprime_dans_enchaineuse(*enchaineuse, "opérateur [] :: (u: Vec%, index: z64) -> r32\n", dimension)
        ajoute_au_tampon(*enchaineuse, "{\n")
        imprime_dans_enchaineuse(*enchaineuse, "    assert(index >= 0 && index < %)\n", dimension)
        ajoute_au_tampon(*enchaineuse, "    résultat := (*u.x)[index]\n")
        ajoute_au_tampon(*enchaineuse, "    retourne résultat\n")
        ajoute_au_tampon(*enchaineuse, "}\n")
    }

    résultat := chaine_depuis_enchaineuse(*enchaineuse)
    diffère déloge(résultat)

    ajoute_chaine_au_module(compilatrice_espace_courant(), compilatrice_module_courant(), résultat)
}

#exécute génère_opérateurs_vecteurs()

/** \} */
