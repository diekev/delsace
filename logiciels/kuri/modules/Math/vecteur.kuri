// ------------------------------------
// vecteurs de nombres réels

Vec2r :: struct {
    x := 0.0
    y := 0.0
}

Vec3r :: struct {
    x := 0.0
    y := 0.0
    z := 0.0
}

crée_vec3r :: fonc (x := 0.0, y := 0.0, z := 0.0) -> Vec3r
{
    retourne Vec3r( x = x, y = y, z = z )
}

Vec4r :: struct {
    x := 0.0
    y := 0.0
    z := 0.0
    w := 0.0
}

produit_scalaire :: fonc (u: Vec3r, v: Vec3r) -> r32
{
    retourne u.x * v.x + u.y * v.y + u.z * v.z
}

produit_vectoriel :: fonc (u: *Vec3r, v: *Vec3r) -> Vec3r
{
    résultat : Vec3r

    résultat.x = u.y * v.z - u.z * v.y
    résultat.y = u.z * v.x - u.x * v.z
    résultat.z = u.x * v.y - u.y * v.x

    retourne résultat
}

longueur :: fonc (u: Vec3r) -> r32
{
    retourne u.x * u.x + u.y * u.y + u.z * u.z
    //retourne sqrt(u.x * u.x + u.y * u.y + u.z * u.z)
}

longueur_carrée :: fonc (u: Vec3r) -> r32
{
    retourne u.x * u.x + u.y * u.y + u.z * u.z
}

échange :: fonc (tri1 : *Vec3r, tri2 : *Vec3r) -> rien
{
    tmp := mémoire(tri2)
    mémoire(tri2) = mémoire(tri1)
    mémoire(tri1) = tmp
}

ajoute :: fonc (v1: Vec3r, v2: Vec3r) -> Vec3r
{
    résultat : Vec3r
    résultat.x = v1.x + v2.x
    résultat.y = v1.y + v2.y
    résultat.z = v1.z + v2.z

    retourne résultat
}

soustrait :: fonc (a: Vec3r, b: Vec3r) -> Vec3r
{
    rés : Vec3r

    rés.x = a.x - b.x
    rés.y = a.y - b.y
    rés.z = a.z - b.z

    retourne rés
}

multiplie :: fonc (v1: Vec3r, v: r32) -> Vec3r
{
    résultat : Vec3r

    si v != 0.0 {
        résultat.x = v1.x * v
        résultat.y = v1.y * v
        résultat.z = v1.z * v
    }

    retourne résultat
}

multiplie :: fonc (a: Vec3r, b: Vec3r) -> Vec3r
{
    rés : Vec3r

    rés.x = a.x * b.x
    rés.y = a.y * b.y
    rés.z = a.z * b.z

    retourne rés
}

divise :: fonc (v1: Vec3r, v: r32) -> Vec3r
{
    résultat : Vec3r

    si v != 0.0 {
        résultat.x = v1.x / v
        résultat.y = v1.y / v
        résultat.z = v1.z / v
    }

    retourne résultat
}

est_inférieur :: fonc (v1: Vec3r, v2: Vec3r) -> bool
{
    retourne v1.x < v2.x || v1.y < v2.y || v1.z < v2.z
}

est_inférieur_ou_égal :: fonc (v1: Vec3r, v2: Vec3r) -> bool
{
    retourne v1.x <= v2.x && v1.y <= v2.y && v1.z <= v2.z
}

est_supérieur :: fonc (v1: Vec3r, v2: Vec3r) -> bool
{
    retourne v1.x > v2.x || v1.y > v2.y || v1.z > v2.z
}

est_supérieur_ou_égal :: fonc (v1: Vec3r, v2: Vec3r) -> bool
{
    retourne v1.x >= v2.x && v1.y >= v2.y && v1.z >= v2.z
}

crée_vec4r :: fonc (x := 0.0, y := 0.0, z := 0.0, w := 0.0) -> Vec4r
{
    retourne Vec4r( x = x, y = y, z = z, w = w )
}

multiplie :: fonc (v1: Vec4r, v: r32) -> Vec4r
{
    résultat : Vec4r

    si v != 0.0 {
        résultat.x = v1.x * v
        résultat.y = v1.y * v
        résultat.z = v1.z * v
        résultat.z = v1.w * v
    }

    retourne résultat
}

soustrait :: fonc (v1: Vec4r, v: r32) -> Vec4r
{
    résultat : Vec4r

    résultat.x = v1.x - v
    résultat.y = v1.y - v
    résultat.z = v1.z - v
    résultat.z = v1.w - v

    retourne résultat
}

Nor3r :: struct {
    x := 0.0
    y := 0.0
    z := 0.0
}

calcul_normal :: fonc (a: Vec3r, b: Vec3r) -> Nor3r
{
    nor : Nor3r

    nor.x = a.y * b.z - a.z * b.y
    nor.y = a.z * b.x - a.x * b.z
    nor.z = a.x * b.y - a.y * b.x

    retourne nor
}

calcul_normal_normalisé :: fonc (a: Vec3r, b: Vec3r) -> Nor3r
{
    nor : Nor3r

    nor.x = a.y * b.z - a.z * b.y
    nor.y = a.z * b.x - a.x * b.z
    nor.z = a.x * b.y - a.y * b.x

    l := sqrt(nor.x * nor.x + nor.y * nor.y + nor.z * nor.z)
    nor.x /= l comme r32
    nor.y /= l comme r32
    nor.z /= l comme r32

    retourne nor
}

normalise :: fonc (v: *Vec3r) -> Vec3r
{
    résultat := mémoire(v)
    l := longueur(résultat)
    retourne divise(résultat, l)
}

vec_depuis_nor :: fonc (n: Nor3r) -> Vec3r
{
    retourne mémoire(*n comme *Vec3r)
}

// Calcul des coordonnées UV depuis une vecteur de direction (I) et d'un
// vecteur normal (N) pour échantillonner une capmat.
calcul_uv_capmat :: fonc (I: *Vec3r, N: *Vec3r, inversé: bool) -> Vec2r
{
    // Création rapide d'une base orthonormale
    a := 1.0 / (1.0 + I.z);
    b := -I.x * I.y * a;
    b1 := crée_vec3r(1.0 - I.x * I.x * a, b, -I.x);
    b2 := crée_vec3r(b, 1.0 - I.y * I.y * a, -I.y);

    uv_capmat := Vec2r( x = produit_scalaire(b1, mémoire(N)), y = produit_scalaire(b2, mémoire(N)) )

    si inversé {
        uv_capmat.x = -uv_capmat.x;
    }

    uv_capmat.x *= 0.496
    uv_capmat.y *= 0.496

    uv_capmat.x += 0.5
    uv_capmat.y += 0.5

    retourne uv_capmat
}

// ------------------------------------
// vecteurs de nombres entiers relatifs

Vec2z :: struct {
    x := 0
    y := 0
}

Vec3z :: struct {
    x := 0
    y := 0
    z := 0
}

Vec4z :: struct {
    x := 0
    y := 0
    z := 0
    w := 0
}
