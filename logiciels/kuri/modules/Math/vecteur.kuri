// ------------------------------------
// vecteurs de nombres réels

Vec2 :: struct {
    x := 0.0  @mutable
    y := 0.0  @mutable
}

opérateur == :: fonc (u: Vec2, v: Vec2) -> bool
{
    retourne u.x == v.x && u.y == v.y
}

opérateur != :: fonc (u: Vec2, v: Vec2) -> bool
{
    retourne !(u == v)
}

opérateur + :: fonc (u: Vec2, v: Vec2) -> Vec2
{
    retourne Vec2(u.x + v.x, u.y + v.y)
}

opérateur - :: fonc (u: Vec2, v: Vec2) -> Vec2
{
    retourne Vec2(u.x - v.x, u.y - v.y)
}

opérateur - :: fonc (u: Vec2) -> Vec2
{
    retourne Vec2(-u.x, -u.y)
}

opérateur * :: fonc (u: Vec2, v: Vec2) -> Vec2
{
    retourne Vec2(u.x * v.x, u.y * v.y)
}

opérateur * :: fonc (u: Vec2, v: r32) -> Vec2
{
    retourne Vec2(u.x * v, u.y * v)
}

opérateur / :: fonc (u: Vec2, v: Vec2) -> Vec2
{
    retourne Vec2(u.x / v.x, u.y / v.y)
}

opérateur / :: fonc (u: Vec2, v: r32) -> Vec2
{
    retourne Vec2(u.x / v, u.y / v)
}

produit_scalaire :: fonc (u: Vec2, v: Vec2) -> r32
{
    retourne u.x * v.x + u.y * v.y
}

produit_vectoriel :: fonc (u: Vec2, v: Vec2) -> r32
{
    retourne u.x * v.y - u.y * v.x
}

longueur :: fonc (u: Vec2, v: Vec2) -> r32
{
    retourne longueur(u - v)
}

longueur :: fonc (u: Vec2) -> r32
{
    retourne racine_carrée(produit_scalaire(u, u))
}

longueur_carrée :: fonc (u: Vec2, v: Vec2) -> r32
{
    w := v - u
    retourne produit_scalaire(w, w)
}

// projection vectorielle
projette :: fonc (a: Vec2, b: Vec2) -> Vec2
{
    retourne produit_scalaire(a, b) / produit_scalaire(b, b) * b
}

// rejection vectorielle, a1 doit être une projection
rejette :: fonc (a1: Vec2, a: Vec2) -> Vec2
{
    retourne a - a1
}

angle_entre :: fonc (a: Vec2, b: Vec2) -> r32 #enligne
{
    a = normalise(a)
    b = normalise(b)

    /* Plus précis que acos(produit_scalaire(a, b)). */
    si produit_scalaire(a, b) >= 0.0 {
        retourne 2.0 * arcsinus_borné(longueur(a, b) * 0.5)
    }

    b2 := -b
    retourne Constantes(r32).PI - 2.0 * arcsinus_borné(longueur(a, b2) * 0.5)
}

normalise :: fonc (v: Vec2) -> Vec2 #enligne
{
    l := longueur(v)
    retourne v / l
}

// À considérer: opérateurs de bases si la structure ne contient que des scalaires
Vec3 :: struct {
    x: r32  @mutable
    y: r32  @mutable
    z: r32  @mutable
}

Point3 :: #opaque Vec3
Norm3 :: #opaque Vec3

crée_vec3r :: fonc (x := 0.0, y := 0.0, z := 0.0) -> Vec3
{
    retourne Vec3( x = x, y = y, z = z )
}

new_Vec3_pour_python :: fonc (vec: *Vec3) -> bool
{
    init_de(Vec3)(vec)
    retourne vrai
} @Python "new"

Vec4 :: struct {
    x := 0.0  @mutable
    y := 0.0  @mutable
    z := 0.0  @mutable
    w := 0.0  @mutable
}

produit_scalaire :: fonc (u: Vec3, v: Vec3) -> r32
{
    retourne u.x * v.x + u.y * v.y + u.z * v.z
}

produit_vectoriel :: fonc (u: *Vec3, v: *Vec3) -> Vec3
{
    résultat : Vec3

    résultat.x = u.y * v.z - u.z * v.y
    résultat.y = u.z * v.x - u.x * v.z
    résultat.z = u.x * v.y - u.y * v.x

    retourne résultat
}

produit_en_croix :: fonc (u: Vec3, v: Vec3) -> Vec3
{
    résultat : Vec3 = ---
    résultat.x = u.y * v.z - u.z * v.y
    résultat.y = u.z * v.x - u.x * v.z
    résultat.z = u.x * v.y - u.y * v.x
    retourne résultat
}

longueur :: fonc (u: Vec3) -> r32
{
    retourne racine_carrée(u.x * u.x + u.y * u.y + u.z * u.z)
}

longueur_carrée :: fonc (u: Vec3) -> r32
{
    retourne u.x * u.x + u.y * u.y + u.z * u.z
}

opérateur [] :: fonc (v: Vec3, index: z64) -> r32
{
	retourne (*v.x)[index]
}

opérateur - :: fonc (v: Vec3) -> Vec3
{
    retourne Vec3(x = -v.x, y = -v.y, z = -v.z)
}

opérateur + :: fonc (v1: Vec3, v2: Vec3) -> Vec3
{
    retourne Vec3(x = v1.x + v2.x, y = v1.y + v2.y, z = v1.z + v2.z)
}

opérateur + :: fonc (u: Vec3, s: r32) -> Vec3
{
    r : Vec3 = ---
    r.x = u.x + s
    r.y = u.y + s
    r.z = u.z + s
    retourne r
}

opérateur - :: fonc (u: Vec3, s: r32) -> Vec3
{
    r : Vec3 = ---
    r.x = u.x - s
    r.y = u.y - s
    r.z = u.z - s
    retourne r
}

opérateur - :: fonc (v1: Vec3, v2: Vec3) -> Vec3
{
    retourne Vec3(x = v1.x - v2.x, y = v1.y - v2.y, z = v1.z - v2.z)
}

opérateur * :: fonc (u: Vec3, s: r32) -> Vec3
{
    r : Vec3

    si s != 0.0 {
        r.x = u.x * s
        r.y = u.y * s
        r.z = u.z * s
    }

    retourne r
}

opérateur / :: fonc (u: Vec3, v: Vec3) -> Vec3
{
    r : Vec3
    r.x = u.x / v.x
    r.y = u.y / v.y
    r.z = u.z / v.z
    retourne r
}

opérateur / :: fonc (u: Vec3, s: r32) -> Vec3
{
    r : Vec3

    si s != 0.0 {
        r.x = u.x / s
        r.y = u.y / s
        r.z = u.z / s
    }

    retourne r
}

// opérateur pour calculer des réciproques
opérateur / :: fonc (s: r32, u: Vec3) -> Vec3
{
    r : Vec3

    si s != 0.0 {
        r.x = s / u.x
        r.y = s / u.y
        r.z = s / u.z
    }

    retourne r
}

opérateur == :: fonc (u: Vec3, v: Vec3) -> bool
{
    retourne u.x == v.x && u.y == v.y && u.z == v.z
}

opérateur == :: fonc (u: Vec3, s: r32) -> bool
{
    retourne u.x == s && u.y == s && u.z == s
}

opérateur != :: fonc (v0: Vec3, v1: Vec3) -> bool
{
	retourne !(v0 == v1)
}

opérateur < :: fonc (u: Vec3, s: r32) -> bool
{
    retourne u.x < s && u.y < s && u.z < s
}

opérateur > :: fonc (u: Vec3, s: r32) -> bool
{
    retourne u.x > s && u.y > s && u.z > s
}

opérateur < :: fonc (v1: Vec3, v2: Vec3) -> bool
{
    retourne v1.x < v2.x && v1.y < v2.y && v1.z < v2.z
}

opérateur <= :: fonc (v1: Vec3, v2: Vec3) -> bool
{
    retourne v1.x <= v2.x && v1.y <= v2.y && v1.z <= v2.z
}

opérateur > :: fonc (v1: Vec3, v2: Vec3) -> bool
{
    retourne v1.x > v2.x && v1.y > v2.y && v1.z > v2.z
}

opérateur >= :: fonc (v1: Vec3, v2: Vec3) -> bool
{
    retourne v1.x >= v2.x && v1.y >= v2.y && v1.z >= v2.z
}

crée_vec4r :: fonc (x := 0.0, y := 0.0, z := 0.0, w := 0.0) -> Vec4
{
    retourne Vec4( x = x, y = y, z = z, w = w )
}

multiplie :: fonc (v1: Vec4, v: r32) -> Vec4
{
    résultat : Vec4

    si v != 0.0 {
        résultat.x = v1.x * v
        résultat.y = v1.y * v
        résultat.z = v1.z * v
        résultat.z = v1.w * v
    }

    retourne résultat
}

soustrait :: fonc (v1: Vec4, v: r32) -> Vec4
{
    résultat : Vec4

    résultat.x = v1.x - v
    résultat.y = v1.y - v
    résultat.z = v1.z - v
    résultat.z = v1.w - v

    retourne résultat
}

calcul_normal :: fonc (a: Vec3, b: Vec3) -> Norm3
{
    nor : Norm3

    nor.x = a.y * b.z - a.z * b.y
    nor.y = a.z * b.x - a.x * b.z
    nor.z = a.x * b.y - a.y * b.x

    retourne nor
}

calcul_normal_normalisé :: fonc (a: Vec3, b: Vec3) -> Norm3
{
    nor : Norm3

    nor.x = a.y * b.z - a.z * b.y
    nor.y = a.z * b.x - a.x * b.z
    nor.z = a.x * b.y - a.y * b.x

    l := sqrt(nor.x * nor.x + nor.y * nor.y + nor.z * nor.z)
    nor.x /= l comme r32
    nor.y /= l comme r32
    nor.z /= l comme r32

    retourne nor
}

normalise :: fonc (v: *Vec3) -> Vec3
{
    résultat := mémoire(v)
    l := longueur(résultat)
    retourne résultat / l
}

normalise :: fonc (v: Vec3) -> Vec3
{
    l := longueur(v)
    retourne v / l
}

normalise_retourne_longueur :: fonc (v: Vec3) -> Vec3, r32
{
    l := longueur(v)
    retourne v / l, l
}

vec_depuis_nor :: fonc (n: Norm3) -> Vec3
{
    retourne mémoire(*n comme *Vec3)
}

// Calcul des coordonnées UV depuis une vecteur de direction (I) et d'un
// vecteur normal (N) pour échantillonner une capmat.
calcul_uv_capmat :: fonc (I: *Vec3, N: *Vec3, inversé: bool) -> Vec2
{
    // Création rapide d'une base orthonormale
    a := 1.0 / (1.0 + I.z);
    b := -I.x * I.y * a;
    b1 := crée_vec3r(1.0 - I.x * I.x * a, b, -I.x);
    b2 := crée_vec3r(b, 1.0 - I.y * I.y * a, -I.y);

    uv_capmat := Vec2( x = produit_scalaire(b1, mémoire(N)), y = produit_scalaire(b2, mémoire(N)) )

    si inversé {
        uv_capmat.x = -uv_capmat.x;
    }

    uv_capmat.x *= 0.496
    uv_capmat.y *= 0.496

    uv_capmat.x += 0.5
    uv_capmat.y += 0.5

    retourne uv_capmat
}

// -------------------------------------------------------------------------

interp_linéaire :: fonc (v0: Vec3, t: r32, v1: Vec3) -> Vec3
{
    retourne (1.0 - t) * v0 + t * v1
}

// ------------------------------------
// vecteurs de nombres entiers relatifs

Vec2z :: struct {
    x := 0
    y := 0
}

Vec3z :: struct {
    x := 0
    y := 0
    z := 0
}

Vec4z :: struct {
    x := 0
    y := 0
    z := 0
    w := 0
}
