
// --------------------

Point :: struct {
    x: r32
    y: r32
}

opérateur + :: fonc (p0: Point, p1: Point) -> Point
{
    retourne Point(p0.x + p1.x, p0.y + p1.y)
}

opérateur + :: fonc (p0: Point, v: Vecteur) -> Point
{
    retourne Point(p0.x + v.x, p0.y + v.y)
}

opérateur - :: fonc (p0: Point, p1: Point) -> Vecteur
{
    retourne Vecteur(p0.x - p1.x, p0.y - p1.y)
}

opérateur * :: fonc (p0: Point, r: r32) -> Point
{
    retourne Point(p0.x * r, p0.y * r)
}

opérateur / :: fonc (p0: Point, r: r32) -> Point
{
    retourne Point(p0.x / r, p0.y / r)
}

/*

Segment :: struct {
    x: r32
    y: r32
}
*/

Vecteur :: struct {
    x: r32
    y: r32
}

opérateur - :: fonc (u: Vecteur, v: Vecteur) -> Vecteur
{
    retourne Vecteur(u.x - v.x, u.y - v.y)
}

opérateur * :: fonc (u: Vecteur, v: Vecteur) -> Vecteur
{
    retourne Vecteur(u.x * v.x, u.y * v.y)
}

opérateur * :: fonc (u: Vecteur, v: r32) -> Vecteur
{
    retourne Vecteur(u.x * v, u.y * v)
}

opérateur / :: fonc (u: Vecteur, v: Vecteur) -> Vecteur
{
    retourne Vecteur(u.x / v.x, u.y / v.y)
}

opérateur / :: fonc (u: Vecteur, v: r32) -> Vecteur
{
    retourne Vecteur(u.x / v, u.y / v)
}

produit_scalaire :: fonc (u: Vecteur, v: Vecteur) -> r32
{
    retourne u.x * v.x + u.y * v.y
}

produit_vectoriel :: fonc (u: Vecteur, v: Vecteur) -> r32
{
    retourne u.x * v.y - u.y * v.x
}

longueur :: fonc (u: Vecteur, v: Vecteur) -> r32
{
    retourne longueur(u - v)
}

longueur :: fonc (u: Vecteur) -> r32
{
    retourne racine_carrée(produit_scalaire(u, u))
}

// projection vectorielle
projette :: fonc (a: Vecteur, b: Vecteur) -> Vecteur
{
    retourne produit_scalaire(a, b) / produit_scalaire(b, b) * b
}

// rejection vectorielle, a1 doit être une projection
rejette :: fonc (a1: Vecteur, a: Vecteur) -> Vecteur
{
    retourne a - a1
}

// --------------------

Triangle :: struct {
    p0: Point
    p1: Point
    p2: Point
}

est_rectangle :: fonc (triangle: Triangle) -> bool
{

}

est_isocèle :: fonc (triangle: Triangle) -> bool
{
    l0 := longueur(triangle.p1 - triangle.p0)
    l1 := longueur(triangle.p2 - triangle.p1)

    si l0 == l1 {
        retourne vrai
    }

    l2 := longueur(triangle.p0 - triangle.p1)

    si l0 == l2 {
        retourne vrai
    }

    retourne l1 == l2
}

// retourne vrai si la longueur de tous les côtés sont égales
// Un triangle est équilatéral si :
// - les cotés du triangle ont tous la même longueur
// - les angles du triangle ont tous la même valeur
// - les droites remarquables (hauteurs, médianes, médiatrices, bissectrices) sont confondues
est_équilatéral :: fonc (triangle: Triangle) -> bool
{
    retourne longueur(triangle.p0 - triangle.p1) == longueur(triangle.p1 - triangle.p2) == longueur(triangle.p2 - triangle.p0)
}

aire :: fonc (triangle: Triangle) -> r32
{
    s0 := triangle.p1 - triangle.p0

    // aire = base * hauteur / 2
    base := longueur(s0)

    // Pour la hauteur, projette un des autres cotés sur la base
    s1 := triangle.p2 - triangle.p0

    projection_s1_sur_s0 := projette(s1, s0)

    hauteur := longueur(s1 - projection_s1_sur_s0)

    retourne base * hauteur / 2.0
}

// Retourne une ligne perpendiculaire à [p0, p1] passant par p2, en somme, c'est une hauteur d'un triangle
perpendiculaire_passant_par :: fonc (p0: Point, p1: Point, p2: Point) -> Ligne
{
    c0 := p1 - p0
    c1 := p2 - p0
    projection_c1_sur_c0 := projette(c1, c0)
    p := p0 + projection_c1_sur_c0
    retourne Ligne(p, p2)
}

// Le point d'intersection des perpendiculaires du triangles
orthocentre :: fonc (triangle: Triangle) -> Point
{
    l0 := perpendiculaire_passant_par(triangle.p0, triangle.p1, triangle.p2)
    l1 := perpendiculaire_passant_par(triangle.p1, triangle.p2, triangle.p0)

    intersecte, point := point_d_intersection(l0, l1)

    si !intersecte {
        // imprime("orthocentre: les perpendiculaires ne s'intersectent pas !\n")
    }

    retourne point
}

// le point d'intersection des médianes du triangle
médicentre :: fonc (triangle: Triangle) -> Point
{
    retourne (triangle.p0 + triangle.p1 + triangle.p2) / 3.0
}

Ligne :: struct {
    origine: Point
    point: Point
}

point_d_intersection :: fonc (l0: Ligne, l1: Ligne) -> bool, Point
{
    retourne point_d_intersection(l0.origine, l0.point, l1.origine, l1.point)
}

point_centrale :: fonc (p0: Point, p1: Point) -> Point
{
    retourne (p0 + p1) * 0.5
}

médiatrice :: fonc (p0: Point, p1: Point) -> Ligne
{
    centre := point_centrale(p0, p1)
    v := p0 - centre
    orthogonale := Point(v.y, -v.x) // sense horaire, antihoraire serait -y, x
    retourne Ligne(centre, centre + orthogonale)
}

// le point d'intersection de deux médiatrices du triangle
// Une médiatrice est une ligne perpendiculaire à un coté du triangle, passant par le centre du coté
// Le circoncentre définis le centre d'un cercle passant par tous les points du triangles.
circoncentre :: fonc (triangle: Triangle) -> Point
{
    b0 := médiatrice(triangle.p0, triangle.p1)
    b1 := médiatrice(triangle.p0, triangle.p2)

    intersecte, point := point_d_intersection(b0, b1)

    si !intersecte {
        // imprime("circoncentre : les médiatrices ne s'intersectent pas !\n")
    }

    retourne point
}

centroide :: fonc (triangle: Triangle) -> Point
{
    retourne médicentre(triangle)
}

centre_de_masse :: fonc (triangle: Triangle) -> Point
{
    retourne centroide(triangle)
}

// Le point d'intersection des bissectrices du triangle.
encentre :: fonc (triangle: Triangle) -> Point
{

}

// La ligne passant par l'orthocentre, le médicentre, et le circoncentre
ligne_de_euler :: fonc (triangle: Triangle) -> Ligne
{
    o := triangle.orthocentre()
    m := triangle.médicentre()
    // c := triangle.circoncentre()
    retourne Ligne(o, m)
}

Cercle :: struct {
    origine: Point
    rayon: r32
}

cercle_circonscrit :: fonc (triangle: Triangle) -> Cercle
{
    origine := triangle.circoncentre()
    rayon := longueur(origine - triangle.p0)
    retourne Cercle(origine, rayon)
}

// Inverse un point selon un cercle d'inversion.
// Pour un point, le point inverse Pi devra préserver la relation suivante :
// |OP| * |OPi| = r²
// où
// O est l'origine du cercle
// OP, le segment alant de l'origine au point
// OPi, le segment allant de l'origine au point inversé
// r, le rayon du cercle
inverse :: fonc (cercle_d_inversion: Cercle, point: Point) -> Point
{
    // Pi = O + OP / |OP| * distance
    // distance = r² / |OP|
    OP := point - cercle_d_inversion.origine
    l_OP := longueur(OP)

    si l_OP == 0.0 {
        retourne point
    }

    rr := cercle_d_inversion.rayon * cercle_d_inversion.rayon

    retourne cercle_d_inversion.origine + OP / l_OP * (rr / l_OP)
}

point_d_intersection :: fonc (o1: Point, p1: Point, o2: Point, p2: Point) -> bool, Point
{
    résultat : Point

    x := o2 - o1
    d1 := p1 - o1
    d2 := p2 - o2

    croix := produit_vectoriel(d1, d2)

    si abs(croix) < 0.00001 {
        retourne faux, résultat
    }

    t1 := produit_vectoriel(x, d2) / croix
    résultat = o1 + d1 * t1
    retourne vrai, résultat
}

/*

    triangle_depuis_angles_et_longueurs
    est_obtus
    est_aigus

    est_valide : somme des angles == 180°
 */
