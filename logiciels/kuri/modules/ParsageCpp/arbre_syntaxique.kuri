importe Introspection

/* ------------------------------------------------------------------------- */
/** \nom Noeud de base pour tous les noeuds syntaxique.
 * \{ */

ASTNode :: struct {
    genre := #type_de_cette_structure
}

/** \} */

VarDecl :: struct {
    empl node: ASTNode
    genre = #type_de_cette_structure

    nom: chaine
    type: *Type
}

FunctionDecl :: struct {
    empl node: ASTNode
    genre = #type_de_cette_structure

    nom: chaine
    type: *Type
    params: [..]*ParamDecl
}

FunctionDefinition :: struct {
    empl node: ASTNode
    genre = #type_de_cette_structure

    nom: chaine
    type: *Type
    params: [..]*ParamDecl
    statement: *CompoundStatement
}

TypeKind :: énum {
    CHAR
    UNSIGNED_CHAR
    SHORT
    UNSIGNED_SHORT
    INT
    UNSIGNED_INT
    LONG
    UNSIGNED_LONG
    LONG_LONG
    UNSIGNED_LONG_LONG
    FLOAT
    DOUBLE
    LONG_DOUBLE

    POINTER

    VOID

    RECORD
    REFERENCE // Pour TypeRef

    TYPEDEF

    FUNCTION
    CONSTANT_ARRAY

    ENUM
}

Type :: struct {
    empl node: ASTNode
    genre = #type_de_cette_structure

    kind: TypeKind
}

TypeRef :: struct {
    empl base_type: Type
    genre = #type_de_cette_structure
    kind = TypeKind.REFERENCE

    // À FAIRE : type référencé
    nom: chaine
}

PointerType :: struct {
    empl base_type: Type
    genre = #type_de_cette_structure
    kind = TypeKind.POINTER

    pointed_to: *Type
}

FunctionType :: struct {
    empl base_type: Type
    genre = #type_de_cette_structure
    kind = TypeKind.FUNCTION

    return_type: *Type
    parameters: [..]*ParamDecl
}

ParamDecl :: struct {
    empl base: ASTNode
    genre = #type_de_cette_structure

    name: chaine
    type: *Type
}

ConstantArray :: struct {
    empl base_type: Type
    genre = #type_de_cette_structure
    kind = TypeKind.CONSTANT_ARRAY

    size: n64
    element_type: *Type
}

TypedefDecl :: struct {
    empl base_type: Type
    genre = #type_de_cette_structure
    kind = TypeKind.TYPEDEF

    type: *Type
    underlying_type: *Type
}

StructDecl :: struct {
    empl base_type: Type
    genre = #type_de_cette_structure
    kind = TypeKind.RECORD

    name: chaine
    fields: [..]*FieldDecl
}

UnionDecl :: struct {
    empl base_type: Type
    genre = #type_de_cette_structure
    kind = TypeKind.RECORD

    name: chaine
    fields: [..]*FieldDecl
}

EnumDecl :: struct {
    empl base_type: Type
    genre = #type_de_cette_structure
    kind = TypeKind.ENUM

    name: chaine
    enumerators: [..]*EnumeratorDecl
}

EnumeratorDecl :: struct {
    empl base_type: Type
    genre = #type_de_cette_structure

    identifier: LexèmePréprocès
    expression: *Expression
}

FieldDecl :: struct {
    empl node: ASTNode
    genre = #type_de_cette_structure

    name: chaine
    type: *Type
}

Expression :: struct {
    empl node: ASTNode
    genre = #type_de_cette_structure
}

IntegerLiteralExpression :: struct {
    empl expr: Expression
    genre = #type_de_cette_structure

    lexème: LexèmePréprocès
}

BinaryExpression :: struct {
    empl expr: Expression
    genre = #type_de_cette_structure
    
    // À FAIRE : stocke les lexèmes
    op: chaine
    left: *Expression
    right: *Expression
}

UnaryExpression :: struct {
    empl expr: Expression
    genre = #type_de_cette_structure
    
    // À FAIRE : stocke les lexèmes
    op: chaine
    operand: *Expression
}

SizeOfExpression :: struct {
    empl expr: Expression
    genre = #type_de_cette_structure

    operand: *Expression
}

DeclarationReference :: struct {
    empl expr: Expression
    genre = #type_de_cette_structure

    lexème: LexèmePréprocès
}

CallExpression :: struct {
    empl expr: Expression
    genre = #type_de_cette_structure

    callee: *Expression
    arguments: [..]*Expression
}

StringLiteral :: struct {
    empl expr: Expression
    genre = #type_de_cette_structure

    lexème: LexèmePréprocès
}

// À FAIRE : déduplique avec TypeRef (ou supprime ce dernier)
// Expression se trouvant par exemple dans sizeof().
TypeNameExpression :: struct {
    empl expr: Expression
    genre = #type_de_cette_structure
}

CompoundStatement :: struct {
    empl node: ASTNode
    genre = #type_de_cette_structure

    items: [..]*ASTNode
}

NullStatement :: struct {
    empl node: ASTNode
    genre = #type_de_cette_structure
}

ExpressionStatement :: struct {
    empl node: ASTNode
    genre = #type_de_cette_structure

    expression: *Expression
}

ReturnStatement :: struct {
    empl node: ASTNode
    genre = #type_de_cette_structure

    expression: *Expression
}

/* ------------------------------------------------------------------------- */
/** \nom ClassDecl
 * \{ */

SpécificationBase :: struct {
    accès: SpécificationAccès
    est_virtuel: bool
    nom: chaine
}

// Utilisée par Cycles
ClassDecl :: struct {
    empl node: ASTNode
    genre = #type_de_cette_structure

    nom: chaine
    clé_classe: CléClasse
    bases: [..]SpécificationBase
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom DeclContext
 * Structure de base pour tous les noeuds représentant un contexte de déclaration.
 * \{ */

DeclContext :: struct {
    empl node: ASTNode
    genre = #type_de_cette_structure

    declarations: [..]*ASTNode
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NamespaceDecl
 * \{ */

NamespaceDecl :: struct {
    empl base: DeclContext
    genre = #type_de_cette_structure

    identifiant: chaine
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Créatrice de Noeuds
 * \{ */

CréatriceNoeuds :: struct {
    noeuds: [..]*ASTNode
}

crée_noeud :: fonc (créatrice: *CréatriceNoeuds, $T: type_de_données) -> *T
{
    résultat := loge(T)
    tableau_ajoute(*créatrice.noeuds, résultat)
    retourne résultat
}

crée_type :: fonc (créatrice: *CréatriceNoeuds, kind: TypeKind) -> *Type
{
    résultat := crée_noeud(créatrice, Type)
    résultat.kind = kind
    retourne résultat
}

crée_type_ref :: fonc (créatrice: *CréatriceNoeuds, nom: chaine) -> *TypeRef
{
    résultat := crée_noeud(créatrice, TypeRef)
    résultat.nom = nom
    retourne résultat
}

crée_pointer_type :: fonc (créatrice: *CréatriceNoeuds, pointed_to: *Type) -> *PointerType
{
    résultat := crée_noeud(créatrice, PointerType)
    résultat.pointed_to = pointed_to
    retourne résultat
}

crée_constant_array :: fonc (créatrice: *CréatriceNoeuds, element_type: *Type, size: n64) -> *ConstantArray
{
    résultat := crée_noeud(créatrice, ConstantArray)
    résultat.element_type = element_type
    résultat.size = size
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Utilitaires
 * \{ */

imprime_arbre :: fonc (node: *ASTNode)
{
    rappel_pour_noeud :: fonc (visiteuse: *VisiteuseArbre(ASTNode), noeud: *ASTNode, info: *InfoTypeStructure) -> VisiteEnfants
    {
        imprime_tabulation(visiteuse.profondeur)
        discr noeud.genre {
            FunctionDecl {
                function := noeud comme *FunctionDecl
                imprimeln("% : %", info.nom, function.nom)
            }
            FunctionDefinition {
                function := noeud comme *FunctionDefinition
                imprimeln("% : %", info.nom, function.nom)
            }
            VarDecl {
                var := noeud comme *VarDecl
                imprimeln("% : %", info.nom, var.nom)
            }
            sinon {
                imprimeln("%", info.nom)
            }
        }
        retourne VisiteEnfants.Oui
    }

    rappel_pour_tableau :: fonc (visiteuse: *VisiteuseArbre(ASTNode), tableau: [..]*ASTNode)
    {
        pour tableau {
            info := it.genre comme *InfoTypeStructure
            rappel_pour_noeud(visiteuse, it, info)
        }
    }

    visiteuse: VisiteuseArbre(ASTNode)
    visiteuse.rappel_pour_noeud = rappel_pour_noeud
    visite_noeud(*visiteuse, node)
}

/** \} */
