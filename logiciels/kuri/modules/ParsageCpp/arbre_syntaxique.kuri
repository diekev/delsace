importe Introspection;

/* ------------------------------------------------------------------------- */
/** \nom Noeud de base pour tous les noeuds syntaxique.
 * \{ */

État_Validation :: énum n8 {
    NON_VALIDÉ;
    EN_VALIDATION;
    VALIDÉ;
}

ASTNode :: struct {
    genre := #type_de_cette_structure;

    token: Token;
    type: *Type;
    état_validation: État_Validation;
}

/** \} */

Declaration :: struct {
    empl node: ASTNode;
    genre = #type_de_cette_structure;

    declarators: [..]*ASTNode;
}

StaticAssert :: struct {
    empl node: ASTNode;
    genre = #type_de_cette_structure;

    expression: *Expression;
    message: chaine;
}

Linkage :: énum n8 {
    NONE;
    EXTERNAL;
    INTERNAL;
}

/* 6.2.4 Storage durations of objects */
Storage_Duration :: énum n8 {
    AUTOMATIC;
    ALLOCATED;
    STATIC;
    THREAD;
}

VarDecl :: struct {
    empl node: ASTNode;
    genre = #type_de_cette_structure;

    nom: chaine;
    type_expression: *Expression;
    initializer: *Expression;

    storage_class_specifier: chaine;
    storage_duration: Storage_Duration;
    linkage: Linkage;
}

BuiltinFunctionType :: énum {
    NONE;

    BSWAP16;
    BSWAP32;
    BSWAP64;
}

FunctionDecl :: struct {
    empl node: ASTNode;
    genre = #type_de_cette_structure;

    builtin_function_type: BuiltinFunctionType;

    nom: chaine;
    type_expression: *FunctionTypeExpression;
    params: [..]*ParamDecl;
    storage_class_specifier: chaine;
    linkage: Linkage;
}

FunctionDefinition :: struct {
    empl node: ASTNode;
    genre = #type_de_cette_structure;

    nom: chaine;
    type_expression: *FunctionTypeExpression;
    params: [..]*ParamDecl;
    storage_class_specifier: chaine;
    linkage: Linkage;
    statement: *CompoundStatement;
}

donne_dernière_instruction :: fonc (statement: *CompoundStatement) -> *ASTNode
{
    boucle {
        si statement.items.taille == 0 {
            arrête;
        }

        test := statement.items[statement.items.taille - 1];
        si test.genre == CompoundStatement {
            statement = test comme *CompoundStatement;
            continue;
        }

        si test.genre == LabelStatement {
            label := test comme *LabelStatement;
            si label.statement.genre == CompoundStatement {
                statement = label.statement comme *CompoundStatement;
                continue;
            }
            retourne label.statement;
        }

        retourne test;
    }

    retourne nul;
}

TypeKind :: énum {
    BOOL;
    CHAR;
    SIGNED_CHAR;
    UNSIGNED_CHAR;
    SHORT;
    UNSIGNED_SHORT;
    INT;
    UNSIGNED_INT;
    LONG;
    UNSIGNED_LONG;
    LONG_LONG;
    UNSIGNED_LONG_LONG;
    FLOAT;
    DOUBLE;
    LONG_DOUBLE;

    FLOAT128; // extension de GCC

    POINTER;

    VOID;

    RECORD;

    TYPEDEF;

    FUNCTION;
    CONSTANT_ARRAY;
    INCOMPLETE_ARRAY;

    COMPLEX;
    COMPLEX_DOUBLE;
    COMPLEX_LONG_DOUBLE;

    ENUM;

    VARIADIC;
}

/* 6.2.5 Types. */
Drapeaux_Type :: énum_drapeau {
    COMPLET;

    STANDARD;

    CHARACTER;
    SIGNED_INTEGER;
    UNSIGNED_INTEGER;
    REAL_FLOATING;
    COMPLEX;
    ENUMERATED;
    VOID;
    POINTER;
    ARRAY;
    STRUCTURE;
    UNION;
    FUNCTION;

    FLOATING :: REAL_FLOATING | COMPLEX;
    BASIC :: CHARACTER | SIGNED_INTEGER | UNSIGNED_INTEGER | FLOATING;
    INTEGER :: CHARACTER | SIGNED_INTEGER | UNSIGNED_INTEGER | ENUMERATED;

    REAL :: INTEGER | REAL_FLOATING;

    // À FAIRE : type domain
    ARITHMETIC :: INTEGER | FLOATING;

    SCALAR :: ARITHMETIC | POINTER;

    AGGREGATE :: ARRAY | STRUCTURE;
}

Type :: struct {
    empl node: ASTNode;
    genre = #type_de_cette_structure;

    kind: TypeKind;
    drapeaux: Drapeaux_Type;

    taille_en_octet: n32;
    alignement: n32;
}

PointerType :: struct {
    empl base_type: Type;
    genre = #type_de_cette_structure;
    kind = TypeKind.POINTER;

    pointed_to: *Type;
}

PointerTypeExpression :: struct {
    empl expr: Expression;
    genre = #type_de_cette_structure;

    pointed_to: *Expression;
}

FunctionType :: struct {
    empl base_type: Type;
    genre = #type_de_cette_structure;
    kind = TypeKind.FUNCTION;

    return_type: *Type;
    parameters: [..]*Type;
}

FunctionTypeExpression :: struct {
    empl expr: Expression;
    genre = #type_de_cette_structure;

    return_type: *Expression;
    parameters: [..]*ParamDecl;
}

ParamDecl :: struct {
    empl base: ASTNode;
    genre = #type_de_cette_structure;

    name: chaine;
    type_expression: *Expression;
}

IncompleteArray :: struct {
    empl base_type: Type;
    genre = #type_de_cette_structure;
    kind = TypeKind.INCOMPLETE_ARRAY;

    element_type: *Type;
}

ConstantArray :: struct {
    empl base_type: Type;
    genre = #type_de_cette_structure;
    kind = TypeKind.CONSTANT_ARRAY;

    size: n64;
    element_type: *Type;
}

ConstantArrayExpression :: struct {
    empl expr: Expression;
    genre = #type_de_cette_structure;

    size_expression: *Expression;
    element_type: *Expression;
}

TypedefDecl :: struct {
    empl base_type: Type;
    genre = #type_de_cette_structure;
    kind = TypeKind.TYPEDEF;

    name: chaine;
    underlying_type: *Expression;
}

Field_Info :: struct {
    decl: *FieldDecl;
    nom: chaine;
    type: *Type;
    décalage: n32;
    est_rembourrage: bool;
}

StructDecl :: struct {
    empl base_type: Type;
    genre = #type_de_cette_structure;
    kind = TypeKind.RECORD;

    name: chaine;
    declarations: [..]*ASTNode;

    field_infos: [..]Field_Info;
}

UnionDecl :: struct {
    empl base_type: Type;
    genre = #type_de_cette_structure;
    kind = TypeKind.RECORD;

    name: chaine;
    declarations: [..]*ASTNode;

    field_infos: [..]Field_Info;
}

EnumDecl :: struct {
    empl base_type: Type;
    genre = #type_de_cette_structure;
    kind = TypeKind.ENUM;

    name: chaine;
    enumerators: [..]*EnumeratorDecl;
}

EnumeratorDecl :: struct {
    empl base_type: Type;
    genre = #type_de_cette_structure;

    identifier: Token;
    expression: *Expression;
}

FieldDecl :: struct {
    empl node: ASTNode;
    genre = #type_de_cette_structure;

    name: chaine;
    type_expression: *Expression;
    bitfield_expression: *Expression;
}

Drapeaux_Expression :: énum_drapeau {
    LVALUE;

    OPÉRANDE_SIZEOF;
    OPÉRANDE_ALIGNOF;
}

Expression :: struct {
    empl node: ASTNode;
    genre = #type_de_cette_structure;

    drapeaux: Drapeaux_Expression;
}

TypeRef :: struct {
    empl expr: Expression;
    genre = #type_de_cette_structure;

    reference_type: *Type;
}

CommaExpression :: struct {
    empl expr: Expression;
    genre = #type_de_cette_structure;

    expressions: [..]*Expression;
}

InitializerList :: struct {
    empl expr: Expression;
    genre = #type_de_cette_structure;

    initializers: [..]*Expression;
}

IdentifierDesignator :: struct {
    empl expr: Expression;
    genre = #type_de_cette_structure;

    identifier: chaine;
    initializer: *Expression;
}

IndexDesignator :: struct {
    empl expr: Expression;
    genre = #type_de_cette_structure;

    index: *Expression;
    initializer: *Expression;
}

CharacterConstant :: struct {
    empl expr: Expression;
    genre = #type_de_cette_structure;
}

IntegerConstant :: struct {
    empl expr: Expression;
    genre = #type_de_cette_structure;
}

FloatingConstant :: struct {
    empl expr: Expression;
    genre = #type_de_cette_structure;
}

GenericSelection :: struct {
    empl expr: Expression;
    genre = #type_de_cette_structure;

    expression: *Expression;
    generic_assoc_list: [..]*GenericAssociation;

    /* Mise en place après la validation sémantique. */
    selected_expression: *Expression;
}

GenericAssociation :: struct {
    empl expr: Expression;
    genre = #type_de_cette_structure;

    // Si nul, nous avons default:
    type_name: *Expression;
    expression: *Expression;
}

BinaryExpression :: struct {
    empl expr: Expression;
    genre = #type_de_cette_structure;
    
    // À FAIRE : stocke les lexèmes
    op: chaine;
    left: *Expression;
    right: *Expression;
}

MemberAccessExpression :: struct {
    empl expr: Expression;
    genre = #type_de_cette_structure;

    is_arrow: bool;
    left: *Expression;
    right: *Expression;
}

IndexExpression :: struct {
    empl expr: Expression;
    genre = #type_de_cette_structure;

    left: *Expression;
    right: *Expression;
}

AssignmentExpression :: struct {
    empl expr: Expression;
    genre = #type_de_cette_structure;

    left: *Expression;
    right: *Expression;
}

CompoundAssignmentExpression :: struct {
    empl binary_expr: BinaryExpression;
    genre = #type_de_cette_structure;
}

UnaryExpression :: struct {
    empl expr: Expression;
    genre = #type_de_cette_structure;
    
    // À FAIRE : stocke les lexèmes
    op: chaine;
    operand: *Expression;
}

AddressExpression :: struct {
    empl expr: Expression;
    genre = #type_de_cette_structure;
    
    operand: *Expression;
}

IndirectionExpression :: struct {
    empl expr: Expression;
    genre = #type_de_cette_structure;
    
    operand: *Expression;
}

SizeOfExpression :: struct {
    empl expr: Expression;
    genre = #type_de_cette_structure;

    operand: *Expression;
}

AlignOfExpression :: struct {
    empl expr: Expression;
    genre = #type_de_cette_structure;

    operand: *Expression;
}

DeclarationReference :: struct {
    empl expr: Expression;
    genre = #type_de_cette_structure;

    referred_declaration: *ASTNode;
}

CallExpression :: struct {
    empl expr: Expression;
    genre = #type_de_cette_structure;

    callee: *Expression;
    arguments: [..]*Expression;
}

StringLiteral :: struct {
    empl expr: Expression;
    genre = #type_de_cette_structure;
}

PrefixUpdateExpression :: struct {
    empl expr: Expression;
    genre = #type_de_cette_structure;

    op: chaine;
    operand: *Expression;
}

PostFixUpdateExpression :: struct {
    empl expr: Expression;
    genre = #type_de_cette_structure;

    op: chaine;
    operand: *Expression;
}

TernaryExpression :: struct {
    empl expr: Expression;
    genre = #type_de_cette_structure;

    test: *Expression;
    consequent: *Expression;
    alternate: *Expression;
}

// Expression se trouvant par exemple dans sizeof().
TypeNameExpression :: struct {
    empl expr: Expression;
    genre = #type_de_cette_structure;

    type_expression: *Expression;
}

CastExpression :: struct {
    empl expr: Expression;
    genre = #type_de_cette_structure;

    cast_type: *TypeNameExpression;
    expression: *Expression;
}

InlineAsmExpression :: struct {
    empl expr: Expression;
    genre = #type_de_cette_structure;
}

CompoundStatement :: struct {
    empl node: ASTNode;
    genre = #type_de_cette_structure;

    items: [..]*ASTNode;
}

NullStatement :: struct {
    empl node: ASTNode;
    genre = #type_de_cette_structure;
}

ExpressionStatement :: struct {
    empl node: ASTNode;
    genre = #type_de_cette_structure;

    expression: *Expression;
}

GotoStatement :: struct {
    empl node: ASTNode;
    genre = #type_de_cette_structure;

    identifier: chaine;
}

ContinueStatement :: struct {
    empl node: ASTNode;
    genre = #type_de_cette_structure;
}

BreakStatement :: struct {
    empl node: ASTNode;
    genre = #type_de_cette_structure;
}

ReturnStatement :: struct {
    empl node: ASTNode;
    genre = #type_de_cette_structure;

    expression: *Expression;
}

IfStatement :: struct {
    empl node: ASTNode;
    genre = #type_de_cette_structure;

    expression: *Expression;
    statement: *ASTNode;
    else_statement: *ASTNode;
}

SwitchStatement :: struct {
    empl node: ASTNode;
    genre = #type_de_cette_structure;

    expression: *Expression;
    statement: *ASTNode;

    labels: [..]*ASTNode;
    default_clause: *DefaultClause;
}

WhileStatement :: struct {
    empl node: ASTNode;
    genre = #type_de_cette_structure;

    expression: *Expression;
    statement: *ASTNode;
}

DoWhileStatement :: struct {
    empl node: ASTNode;
    genre = #type_de_cette_structure;

    statement: *ASTNode;
    expression: *Expression;
}

ForStatement :: struct {
    empl node: ASTNode;
    genre = #type_de_cette_structure;

    initializer: *ASTNode;
    test: *Expression;
    update: *Expression;

    statement: *ASTNode;
}

CaseClause :: struct {
    empl node: ASTNode;
    genre = #type_de_cette_structure;

    expression: *Expression;
    statement: *ASTNode;

    valeur: n64;
}

DefaultClause :: struct {
    empl node: ASTNode;
    genre = #type_de_cette_structure;

    statement: *ASTNode;
}

LabelStatement :: struct {
    empl node: ASTNode;
    genre = #type_de_cette_structure;

    identifier: chaine;
    statement: *ASTNode;
}

/* ------------------------------------------------------------------------- */
/** \nom ClassDecl
 * \{ */

SpécificationBase :: struct {
    accès: SpécificationAccès;
    est_virtuel: bool;
    nom: chaine;
}

// Utilisée par Cycles
ClassDecl :: struct {
    empl node: ASTNode;
    genre = #type_de_cette_structure;

    nom: chaine;
    clé_classe: CléClasse;
    bases: [..]SpécificationBase;
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom DeclContext
 * Structure de base pour tous les noeuds représentant un contexte de déclaration.
 * \{ */

DeclContext :: struct {
    empl node: ASTNode;
    genre = #type_de_cette_structure;

    declarations: [..]*ASTNode;
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NamespaceDecl
 * \{ */

NamespaceDecl :: struct {
    empl base: DeclContext;
    genre = #type_de_cette_structure;

    identifiant: chaine;
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Créatrice de Noeuds
 * \{ */

CréatriceNoeuds :: struct {
    noeuds: [..]*ASTNode;
}

crée_noeud :: fonc (créatrice: *CréatriceNoeuds, token: Token, $T: type_de_données) -> *T
{
    résultat := loge(T);
    tableau_ajoute(*créatrice.noeuds, résultat);
    résultat.token = token;
    retourne résultat;
}

crée_type :: fonc (créatrice: *CréatriceNoeuds, kind: TypeKind) -> *Type
{
    résultat := crée_noeud(créatrice, Token(), Type);
    résultat.kind = kind;
    retourne résultat;
}

crée_type_ref :: fonc (créatrice: *CréatriceNoeuds, token: Token, type: *Type) -> *TypeRef
{
    résultat := crée_noeud(créatrice, token, TypeRef);
    résultat.reference_type = type;
    retourne résultat;
}

crée_pointer_type :: fonc (créatrice: *CréatriceNoeuds, pointed_to: *Type) -> *PointerType
{
    résultat := crée_noeud(créatrice, Token(), PointerType);
    résultat.pointed_to = pointed_to;
    retourne résultat;
}

crée_pointer_type :: fonc (créatrice: *CréatriceNoeuds, token: Token, pointed_to: *Expression) -> *PointerTypeExpression
{
    résultat := crée_noeud(créatrice, token, PointerTypeExpression);
    résultat.pointed_to = pointed_to;
    retourne résultat;
}

crée_constant_array :: fonc (créatrice: *CréatriceNoeuds, token: Token, element_type: *Expression, size_expression: *Expression) -> *ConstantArrayExpression
{
    résultat := crée_noeud(créatrice, token, ConstantArrayExpression);
    résultat.element_type = element_type;
    résultat.size_expression = size_expression;
    retourne résultat;
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Utilitaires
 * \{ */

imprime_arbre :: fonc (node: *ASTNode)
{
    rappel_pour_noeud :: fonc (visiteuse: *VisiteuseArbre(ASTNode), noeud: *ASTNode, info: *InfoTypeStructure) -> VisiteEnfants;
    {
        imprime_tabulation(visiteuse.profondeur);
        discr noeud.genre {
            FunctionDecl {
                function := noeud comme *FunctionDecl;
                imprimeln("% : %", info.nom, function.nom);
            }
            FunctionDefinition {
                function := noeud comme *FunctionDefinition;
                imprimeln("% : %", info.nom, function.nom);
            }
            VarDecl {
                var := noeud comme *VarDecl;
                imprimeln("% : %", info.nom, var.nom);
            }
            ParamDecl {
                param := noeud comme *ParamDecl;
                imprimeln("% : %", info.nom, param.name);
            }
            TypedefDecl {
                typedef := noeud comme *TypedefDecl;
                imprimeln("% : %", info.nom, typedef.name);
            }
            StructDecl {
                struct_decl := noeud comme *StructDecl;
                imprimeln("% : %", info.nom, struct_decl.name);
            }
            UnionDecl {
                union_decl := noeud comme *UnionDecl;
                imprimeln("% : %", info.nom, union_decl.name);
            }
            EnumDecl {
                enum_decl := noeud comme *EnumDecl;
                imprimeln("% : %", info.nom, enum_decl.name);
            }
            FieldDecl {
                field_decl := noeud comme *FieldDecl;
                imprimeln("% : %", info.nom, field_decl.name);
            }
            Type {
                type := noeud comme *Type;
                imprimeln("% : %", info.nom, type.kind);
            }
            sinon {
                imprimeln("%", info.nom);
            }
        }
        retourne VisiteEnfants.Oui;
    }

    rappel_pour_tableau :: fonc (visiteuse: *VisiteuseArbre(ASTNode), tableau: [..]*ASTNode);
    {
        pour tableau {
            info := it.genre comme *InfoTypeStructure;
            rappel_pour_noeud(visiteuse, it, info);
        }
    }

    visiteuse: VisiteuseArbre(ASTNode);
    visiteuse.rappel_pour_noeud = rappel_pour_noeud;
    visite_noeud(*visiteuse, node);
}

/** \} */
