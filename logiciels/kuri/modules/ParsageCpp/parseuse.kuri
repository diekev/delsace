importe Fondation

/* ------------------------------------------------------------------------- */
/** \nom Parseuse
 * \{ */

Parseuse :: struct {
    fichier: *FichierSource
    lexèmes: []Lexème
    index_courant: z64

    créatrice_noeuds: CréatriceNoeuds

    possède_erreur: bool

    /* Rappels. */
    sur_prodéclaration_struct_ou_class : fonc(&Parseuse, *NoeudProdéclarationObjet)(rien)
    sur_définition_classe : fonc (&Parseuse, *NoeudDéfinitionClasse)(rien)
    sur_prodéclaration_énum : fonc(&Parseuse, *NoeudProdéclarationÉnum)(rien)
    sur_identifiant: fonc(&Parseuse, chaine)(rien)
    sur_inclusion: fonc(&Parseuse, chaine, bool)(rien)
}

initialise_parseuse :: fonc (parseuse: &Parseuse, fichier: *FichierSource)
{
    parseuse.fichier = fichier
    parseuse.lexèmes = fichier.lexèmes
}

rapporte_erreur :: fonc (parseuse: &Parseuse, message: chaine)
{
    si parseuse.possède_erreur {
        retourne
    }
    
    lexème := parseuse.lexème_courant()

    imprime("%:%:\n", parseuse.fichier.chemin, lexème.ligne)
    imprime("\tErreur : %\n", message)

    parseuse.possède_erreur = vrai
}

lexème_courant :: fonc (parseuse: &Parseuse) -> *Lexème
{
    retourne *parseuse.lexèmes[parseuse.index_courant]
}

avance :: fonc (parseuse: &Parseuse)
{
    parseuse.index_courant += 1
}

fini :: fonc (parseuse: &Parseuse) -> bool
{
    retourne parseuse.index_courant >= parseuse.lexèmes.taille
}

consomme :: fonc (parseuse: &Parseuse, genre_lexème: GenreLexème) -> bool
{
    lexème := parseuse.lexème_courant()
    saufsi lexème.genre == genre_lexème {
        retourne faux
    }

    parseuse.avance()
    retourne vrai
}

apparie :: fonc (parseuse: &Parseuse, genre_lexème: GenreLexème) -> bool
{
    lexème := parseuse.lexème_courant()
    retourne lexème.genre == genre_lexème
}

apparie :: fonc (parseuse: &Parseuse, caractère: z8) -> bool
{
    lexème := parseuse.lexème_courant()
    retourne lexème.genre == (caractère comme z32 comme GenreLexème)
}

apparie_mot_clé :: fonc (parseuse: &Parseuse, ident: chaine) -> bool
{
    lexème := parseuse.lexème_courant()
    retourne lexème.genre == GenreLexème.MOT_CLÉ && lexème.ident == ident
}

apparie_identifiant :: fonc (parseuse: &Parseuse, ident: chaine) -> bool
{
    lexème := parseuse.lexème_courant()
    retourne lexème.genre == GenreLexème.IDENTIFIANT && lexème.ident == ident
}

consomme_ident :: fonc (parseuse: &Parseuse) -> chaine
{
    ident := parseuse.lexème_courant().ident
    parseuse.avance()
    retourne ident
}

consomme_mot_clé :: fonc (parseuse: &Parseuse, ident: chaine) -> bool
{
    saufsi est_mot_clé(parseuse.lexème_courant(), ident) {
        retourne faux
    }

    parseuse.avance()
    retourne vrai
}

CléClasse :: énum {
    STRUCT
    CLASS
    UNION
}

parse :: fonc (parseuse: &Parseuse)
{
    tantque !fini(parseuse) {
        si apparie_mot_clé(parseuse, "struct") {
            parseuse.parse_classe(CléClasse.STRUCT)
            continue
        }

        si apparie_mot_clé(parseuse, "class") {
            parseuse.parse_classe(CléClasse.CLASS)
            continue
        }

        si apparie_mot_clé(parseuse, "enum") {
            parseuse.parse_enum()
            continue
        }

        si apparie(parseuse, GenreLexème.HASHTAG) {
            parseuse.parse_directive_préprocesseur()
            continue
        }

        lexème := parseuse.lexème_courant()
        si lexème.genre == GenreLexème.IDENTIFIANT {
            si parseuse.sur_identifiant {
                parseuse.sur_identifiant(parseuse, lexème.ident)
            }
        }

        parseuse.avance()
    }
}

/* ------------------------------------------------------------------------- */
/** \nom Parsage d'une classe.
 * https://en.cppreference.com/w/cpp/language/class
 * \{ */

parse_classe :: fonc (parseuse: &Parseuse, clé_classe: CléClasse)
{
    /* Nous sommes sur le mot-clé. */
    lexème := parseuse.lexème_courant()
    parseuse.avance()

    // À FAIRE : attributs (C++11)

    saufsi parseuse.apparie(GenreLexème.IDENTIFIANT) {
        si clé_classe == CléClasse.STRUCT {
            parseuse.rapporte_erreur("Attendu un identifiant après 'struct'\n")
        }
        sinon {
            parseuse.rapporte_erreur("Attendu un identifiant après 'class'\n")
        }

        retourne
    }

    nom_struct := parseuse.lexème_courant().ident
    parseuse.avance()

    si apparie(parseuse, ';') {
        parseuse.avance()

        noeud_prodéclaration := parseuse.créatrice_noeuds.crée_noeud(lexème, NoeudProdéclarationObjet)
        noeud_prodéclaration.est_struct = clé_classe == CléClasse.STRUCT
        noeud_prodéclaration.nom_objet = nom_struct

        si parseuse.sur_prodéclaration_struct_ou_class {
            parseuse.sur_prodéclaration_struct_ou_class(parseuse, noeud_prodéclaration)
        }

        retourne
    }

    est_finale := faux
    si apparie_mot_clé(parseuse, "final") {
        est_finale = vrai
        parseuse.avance()
    }

    bases: []SpécificationBase
    si apparie(parseuse, ':') {
        parseuse.avance()
        parseuse.parse_spécification_base(clé_classe, *bases)
    }

/*
    saufsi parseuse.apparie('{') {
        parseuse.rapporte_erreur("Attendu '{'")
        retourne
    }
    parseuse.avance()

    parseuse.parse_spécification_membre()

    saufsi parseuse.apparie('}') {
        parseuse.rapporte_erreur("Attendu '}'")
        retourne
    }
    parseuse.avance()

    saufsi parseuse.apparie(';') {
        parseuse.rapporte_erreur("Attendu ';'")
        retourne
    }
    parseuse.avance()
*/

    si parseuse.sur_définition_classe {
        noeud := parseuse.créatrice_noeuds.crée_noeud(lexème, NoeudDéfinitionClasse)
        noeud.nom = nom_struct
        noeud.clé_classe = clé_classe
        noeud.bases = bases

        parseuse.sur_définition_classe(parseuse, noeud)
    }
}

/** } */

// À FAIRE(langage) : n8
SpécificationAccès :: énum {
    PUBLIC
    PROTÉGÉ
    PRIVÉ
}

parse_spécification_accès :: fonc (parseuse: &Parseuse) -> Optionnel(SpécificationAccès)
{
    si parseuse.apparie_mot_clé("public") {
        parseuse.avance()
        retourne SpécificationAccès.PUBLIC
    }

    si parseuse.apparie_mot_clé("private") {
        parseuse.avance()
        retourne SpécificationAccès.PRIVÉ
    }

    si parseuse.apparie_mot_clé("protected") {
        parseuse.avance()
        retourne SpécificationAccès.PROTÉGÉ
    }
}

/* ------------------------------------------------------------------------- */
/** \nom Parsage spécification base.
 * https://en.cppreference.com/w/cpp/language/derived_class
 * \{ */

/* base-class */
parse_spécification_base :: fonc (parseuse: &Parseuse, clé_classe: CléClasse, bases: *[]SpécificationBase)
{
    accès_courant := si clé_classe == CléClasse.STRUCT {
        SpécificationAccès.PUBLIC
    }
    sinon {
        SpécificationAccès.PRIVÉ
    }

    tantque !parseuse.fini() {
        // À FAIRE : attributs (C++11)

        est_virtuel := faux
        eu_virtuel := faux

        si parseuse.apparie_mot_clé("virtual") {
            parseuse.avance()
            est_virtuel = vrai
            eu_virtuel = vrai
        }

        opt_accès := parseuse.parse_spécification_accès()
        si opt_accès.possède_valeur() {
            accès_courant = opt_accès.Quelque
        }

        /* « virtual » peut-être avant ou après la spécification d'accès. */
        si parseuse.apparie_mot_clé("virtual") {
            si eu_virtuel {
                parseuse.rapporte_erreur("« virtual » fut déjà spécifé")
            }
            parseuse.avance()
            est_virtuel = vrai
        }

        nom_parent := parseuse.parse_classe_ou_decltype()

        spécification_base : SpécificationBase = ---
        spécification_base.nom = nom_parent
        spécification_base.accès = accès_courant
        spécification_base.est_virtuel = est_virtuel

        tableau_ajoute(bases, spécification_base)
        // imprime("Classe parent : % (%, virtuel: %)\n", nom_parent, accès_courant, est_virtuel)

        saufsi parseuse.apparie(',') {
            arrête
        }

        parseuse.avance()
    }
}

/* class-or-decltype:
 * - nested-name-specifier(optional) type-name
 * - nested-name-specifier `template` simple-template-id
 * - decltype-specifier (C++11)
 */
parse_classe_ou_decltype :: fonc (parseuse: &Parseuse) -> chaine
{
    // À FAIRE : decltype
    // https://en.cppreference.com/w/cpp/language/decltype

    // À FAIRE : scope globale
    si parseuse.apparie(GenreLexème.OPÉRATEUR_RÉSOLUTION_SCOPE) {
        parseuse.avance()
    }

    nom_parent := ""

    tantque !parseuse.fini() {
        saufsi parseuse.apparie(GenreLexème.IDENTIFIANT) {
            parseuse.rapporte_erreur("Attendu un identifiant")
            retourne ""
        }

        nom_parent = parseuse.lexème_courant().ident
        parseuse.avance()

        si parseuse.apparie('<') {
            parseuse.avance()

            // À FAIRE : parse le contenu

            tantque !parseuse.fini() {
                si parseuse.apparie('>') {
                    arrête
                }

                parseuse.avance()
            }

            parseuse.avance()
        }

        // À FAIRE : si template, peut avoir ... après le type

        saufsi parseuse.apparie(GenreLexème.OPÉRATEUR_RÉSOLUTION_SCOPE) {
            arrête
        }

        parseuse.avance()
    }

    retourne nom_parent
}

/** } */

/* ------------------------------------------------------------------------- */
/** \nom Spécification des membres des classes.
 * \{ */

parse_spécification_membre :: fonc (parseuse: &Parseuse)
{
    // À FAIRE
}

/** } */

parse_enum :: fonc (parseuse: &Parseuse)
{
    /* Nous sommes sur le mot-clé. */
    lexème := parseuse.lexème_courant()
    parseuse.avance()

    est_énum_class := faux

    si apparie_mot_clé(parseuse, "class") {
        parseuse.avance()
        est_énum_class = vrai
    }

    nom_énum := parseuse.lexème_courant().ident
    parseuse.avance()

    si apparie(parseuse, ':') {
        parseuse.avance()
        parseuse.avance() // type À FAIRE
    }

    si apparie(parseuse, ';') {
        parseuse.avance()

        noeud_prodéclaration := parseuse.créatrice_noeuds.crée_noeud(lexème, NoeudProdéclarationÉnum)
        noeud_prodéclaration.nom_énum = nom_énum

        si parseuse.sur_prodéclaration_énum {
            parseuse.sur_prodéclaration_énum(parseuse, noeud_prodéclaration)
        }

        retourne
    }
}

parse_directive_préprocesseur :: fonc (parseuse: &Parseuse)
{
    /* Nous sommes sur le hashtag. */
    parseuse.avance()

    si apparie_identifiant(parseuse, "include") {
        parseuse.avance()

        lexème := parseuse.lexème_courant()
        si lexème.genre == GenreLexème.CHAINE_LITTÉRALE {
            parseuse.avance()

            si parseuse.sur_inclusion {
                parseuse.sur_inclusion(parseuse, lexème.ident, faux)
            }

            retourne
        }
    }
}

/** } */