/* ------------------------------------------------------------------------- */
/** \nom LexèmePréProcès
 * Lexèmes pour le préprocesseur.
 * \{ */

LexèmePréprocès :: struct {
    lexème: Lexème
    fichier: z64 = -1
}

est_symbole :: fonc (lexème: LexèmePréprocès) -> bool #enligne
{
    retourne lexème.lexème.type == TypeLexème.Symbole
}

est_chaine_littérale :: fonc (lexème: LexèmePréprocès) -> bool #enligne
{
    retourne lexème.lexème.type == TypeLexème.ChaineLittérale
}

est_fin_de_fichier :: fonc (lexème: LexèmePréprocès) -> bool #enligne
{
    retourne lexème.lexème.type == TypeLexème.FinDeFichier
}

est_lexème_nouvelle_ligne :: fonc (lexème: LexèmePréprocès) -> bool #enligne
{
    retourne est_lexème_nouvelle_ligne(lexème.lexème)
}

est_littérale_nombre_entier :: fonc (lexème: LexèmePréprocès) -> bool #enligne
{
    retourne lexème.lexème.type == TypeLexème.LittéraleNombreEntier
}

est_littérale_nombre_réel :: fonc (lexème: LexèmePréprocès) -> bool #enligne
{
    retourne lexème.lexème.type == TypeLexème.LittéraleNombreRéel
}

est_ponctuation :: fonc (lexème: LexèmePréprocès, texte: chaine) -> bool #enligne
{
    retourne est_ponctuation(lexème.lexème, texte)
}

est_mot_clé :: fonc (lexème: LexèmePréprocès) -> bool #enligne
{
    retourne lexème.lexème.type == TypeLexème.MotClé
}

est_mot_clé :: fonc (lexème: LexèmePréprocès, texte: chaine) -> bool #enligne
{
    retourne est_mot_clé(lexème.lexème, texte)
}

est_espace_blanche :: fonc (lexème: LexèmePréprocès) -> bool #enligne
{
    retourne lexème.lexème.type == TypeLexème.EspaceBlanche
}

donne_texte :: fonc (lexème: LexèmePréprocès) -> chaine #enligne
{
    retourne donne_texte(lexème.lexème)
}

donne_texte_sans_guillemets :: fonc (lexème: LexèmePréprocès) -> chaine #enligne
{
    retourne donne_texte_sans_guillemets(lexème.lexème)
}

imprime_lexèmes :: fonc (lexèmes: []LexèmePréprocès) -> chaine
{
    enchaineuse: Enchaineuse
    initialise_enchaineuse(*enchaineuse)

    pour lexèmes {
        ajoute_au_tampon(*enchaineuse, donne_texte(it.lexème))
    }

    résultat := chaine_depuis_enchaineuse(*enchaineuse)
    retourne résultat
}

supprime_espace_blanches :: fonc (lexèmes: *[..]LexèmePréprocès) -> []LexèmePréprocès
{
    entrée := lexèmes.pointeur
    sortie := lexèmes.pointeur
    fin := lexèmes.pointeur + lexèmes.taille

    tantque entrée < fin {
        si entrée.lexème.type != TypeLexème.EspaceBlanche {
            mémoire(sortie) = mémoire(entrée)
            sortie += 1
        }

        entrée += 1
    }

    lexèmes.taille = sortie - lexèmes.pointeur

    retourne mémoire(lexèmes)
}

supprime_espace_blanches_autour :: fonc (lexèmes: []LexèmePréprocès) -> []LexèmePréprocès
{
    résultat := lexèmes

    tantque résultat.taille != 0 {
        saufsi est_espace_blanche(résultat[0]) {
            arrête
        }

        résultat.pointeur += 1
        résultat.taille -= 1
    }

    tantque résultat.taille != 0 {
        saufsi est_espace_blanche(résultat[résultat.taille - 1]) {
            arrête
        }

        résultat.taille -= 1
    }

    retourne résultat
}

supprime_espace_blanches_autour :: fonc (lexèmes: *[..]LexèmePréprocès)
{
    tmp: []LexèmePréprocès = mémoire(lexèmes)
    tmp = supprime_espace_blanches_autour(tmp)

    insertion := lexèmes.pointeur

    pour tmp {
        mémoire(insertion) = it
        insertion += 1
    }

    lexèmes.taille = tmp.taille
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Token
 * \{ */

TokenForm :: énum n8 {
    KEYWORD
    IDENTIFIER
    CONSTANT
    STRING_LITERAL
    PONCTUATOR
}

Token :: struct {
    form: TokenForm
    lexème: Lexème
    fichier: z64 = -1
}

convertis_en_tokens :: fonc (lexèmes_préprocès: []LexèmePréprocès) -> [..]Token
{
    résultat: [..]Token

    pour * lexèmes_préprocès {
        si it.lexème.type == TypeLexème.EspaceBlanche {
            continue
        }

        token := tableau_ajoute_élément(*résultat)
        token.lexème = it.lexème
        token.fichier = it.fichier

        discr it.lexème.type {
            MotClé {
                token.form = TokenForm.KEYWORD
            }
            Symbole {
                token.form = TokenForm.IDENTIFIER
            }
            Ponctuation {
                token.form = TokenForm.PONCTUATOR
            }
            ChaineLittérale {
                token.form = TokenForm.STRING_LITERAL
            }
            LittéraleNombreEntier,
            LittéraleNombreRéel,
            CaractèreConstant {
                token.form = TokenForm.CONSTANT
            }
            sinon {
                panique("type de lexème non-géré : %", it.lexème.type)
            }
        }
    }

    retourne résultat
}

est_fin_de_fichier :: fonc (token: Token) -> bool #enligne
{
    retourne token.lexème.type == TypeLexème.FinDeFichier
}

est_mot_clé :: fonc (token: Token, texte: chaine) -> bool #enligne
{
    retourne est_mot_clé(token.lexème, texte)
}

est_symbole :: fonc (token: Token) -> bool #enligne
{
    retourne token.form == TokenForm.IDENTIFIER
}

est_ponctuation :: fonc (token: Token, texte: chaine) -> bool #enligne
{
    retourne est_ponctuation(token.lexème, texte)
}

est_chaine_littérale :: fonc (token: Token) -> bool #enligne
{
    retourne token.form == TokenForm.STRING_LITERAL
}

est_littérale_nombre_entier :: fonc (token: Token) -> bool #enligne
{
    retourne token.lexème.type == TypeLexème.LittéraleNombreEntier
}

est_littérale_nombre_réel :: fonc (token: Token) -> bool #enligne
{
    retourne token.lexème.type == TypeLexème.LittéraleNombreRéel
}

donne_texte :: fonc (token: Token) -> chaine #enligne
{
    retourne donne_texte(token.lexème)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom LexeusePréProcès
 * \{ */

LexeusePréProcès :: struct {
    lexeuse: SimpleLexeuse
    fichier: z64

    /* Pour détecter si une garde d'inclusion nous permettrait de ne pas retraiter
     * un fichier donné, il nous faut prendre en compte plusieurs choses :
     * - la première directive est #ifndef
     * - la dernière directive est le #endif correspondant
     * - il ne doit pas y avoir de branches entre les deux
     */
    texte_garde_inclusion := ""
    dernier_lexème_non_espace_blanche := ""
    est_première_directive := vrai
    une_branche_fut_rencontrée := faux
}

émets_lexème :: fonc (lexeuse: *LexeusePréProcès, lexème: Lexème) -> LexèmePréprocès
{
    si lexème.type != TypeLexème.EspaceBlanche && lexème.type != TypeLexème.FinDeFichier {
        lexeuse.dernier_lexème_non_espace_blanche = donne_texte(lexème)
    }
    résultat: LexèmePréprocès
    résultat.lexème = lexème
    résultat.fichier = lexeuse.fichier
    retourne résultat
}

donne_lexème_suivant :: fonc (lexeuse: *LexeusePréProcès) -> LexèmePréprocès
{
    lexème := donne_lexème_suivant(*lexeuse.lexeuse)
    retourne émets_lexème(lexeuse, lexème)
}

donne_lexème_suivant_sauf_espace_blanche :: fonc (lexeuse: *LexeusePréProcès) -> LexèmePréprocès
{
    lexème := donne_lexème_suivant_sauf_espace_blanche(*lexeuse.lexeuse)
    retourne émets_lexème(lexeuse, lexème)
}

donne_lexème_suivant_sauf_espace_blanche_hors_nouvelle_ligne :: fonc (lexeuse: *LexeusePréProcès) -> LexèmePréprocès
{
    lexème := donne_lexème_suivant_sauf_espace_blanche_hors_nouvelle_ligne(*lexeuse.lexeuse)
    retourne émets_lexème(lexeuse, lexème)
}

donne_texte_jusque_nouvelle_ligne :: fonc (lexeuse: *LexeusePréProcès) -> chaine
{
    retourne donne_texte_jusque_nouvelle_ligne(*lexeuse.lexeuse)
}

consomme_jusque_nouvelle_ligne :: fonc (lexeuse: *LexeusePréProcès)
{
    consomme_jusque_nouvelle_ligne(*lexeuse.lexeuse)
}

reprends_depuis_lexème :: fonc (lexeuse: *LexeusePréProcès, lexème: LexèmePréprocès)
{
    reprends_depuis_lexème(*lexeuse.lexeuse, lexème.lexème)
}

saute_espaces_blanches_sauf_nouvelle_ligne :: fonc (lexeuse: *LexeusePréProcès)
{
    saute_espaces_blanches_sauf_nouvelle_ligne(*lexeuse.lexeuse)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Utilitaires
 * \{ */

donne_lexème_suivant_sauf_espace_blanche :: fonc (lexeuse: *SimpleLexeuse) -> Lexème
{
    résultat := donne_lexème_suivant(lexeuse)
    tantque résultat.type == TypeLexème.EspaceBlanche {
        résultat = donne_lexème_suivant(lexeuse)
    }
    retourne résultat
}

donne_lexème_suivant_sauf_espace_blanche_hors_nouvelle_ligne :: fonc (lexeuse: *SimpleLexeuse) -> Lexème
{
    résultat := donne_lexème_suivant(lexeuse)
    tantque résultat.type == TypeLexème.EspaceBlanche && donne_texte(résultat) != "\n" {
        résultat = donne_lexème_suivant(lexeuse)
    }
    retourne résultat
}

est_lexème_nouvelle_ligne :: fonc (lexème: Lexème) -> bool
{
    retourne lexème.type == TypeLexème.EspaceBlanche && donne_texte(lexème) == "\n"
}

saute_espaces_blanches_sauf_nouvelle_ligne :: fonc (lexeuse: *SimpleLexeuse)
{
    boucle {
        lexème := donne_lexème_suivant(lexeuse)
        si lexème.type == TypeLexème.FinDeFichier {
            arrête
        }
        si est_lexème_nouvelle_ligne(lexème) {
            reprends_depuis_lexème(lexeuse, lexème)
            retourne
        }
        si lexème.type != TypeLexème.EspaceBlanche {
            reprends_depuis_lexème(lexeuse, lexème)
            arrête
        }
    }
}

consomme_jusque_nouvelle_ligne :: fonc (lexeuse: *SimpleLexeuse)
{
    boucle {
        lexème := donne_lexème_suivant(lexeuse)
        si lexème.type == TypeLexème.FinDeFichier || est_lexème_nouvelle_ligne(lexème) {
            reprends_depuis_lexème(lexeuse, lexème)
            arrête
        }
    }
}

crée_lexème_symbole :: fonc (texte: chaine) -> LexèmePréprocès
{
    résultat: Lexème
    résultat.début = texte.pointeur
    résultat.fin = texte.pointeur + texte.taille
    résultat.type = TypeLexème.Symbole
    retourne LexèmePréprocès(résultat)
}

crée_lexème_chaine_littérale :: fonc (texte: chaine) -> LexèmePréprocès
{
    résultat: Lexème
    résultat.début = texte.pointeur
    résultat.fin = texte.pointeur + texte.taille
    résultat.type = TypeLexème.ChaineLittérale
    retourne LexèmePréprocès(résultat)
}

crée_lexème_nombre_naturel :: fonc (valeur: n64) -> LexèmePréprocès
{
    résultat: Lexème
    résultat.type = TypeLexème.Nombre
    résultat.nombre.naturel = valeur
    retourne LexèmePréprocès(résultat)
}

supprime_espace_blanches_autour :: fonc (lexèmes: []Lexème) -> []Lexème
{
    résultat := lexèmes

    tantque résultat.taille != 0 {
        si résultat[0].type != TypeLexème.EspaceBlanche {
            arrête
        }

        résultat.pointeur += 1
        résultat.taille -= 1
    }

    tantque résultat.taille != 0 {
        si résultat[résultat.taille - 1].type != TypeLexème.EspaceBlanche {
            arrête
        }

        résultat.taille -= 1
    }

    retourne résultat
}

supprime_espace_blanches_autour :: fonc (lexèmes: *[..]Lexème)
{
    tmp: []Lexème = mémoire(lexèmes)
    tmp = supprime_espace_blanches_autour(tmp)

    insertion := lexèmes.pointeur

    pour tmp {
        mémoire(insertion) = it
        insertion += 1
    }

    lexèmes.taille = tmp.taille
}

donne_texte_sans_guillemets :: fonc (lexème: Lexème) -> chaine
{
    texte := donne_texte(lexème)
    saufsi texte {
        retourne ""
    }

    si texte[0] == '"' {
        texte = avance(texte, 1)
    }

    saufsi texte {
        retourne ""
    }

    si texte[texte.taille - 1] == '"' {
        texte = recule(texte, 1)
    }

    retourne texte
}

/** \} */
