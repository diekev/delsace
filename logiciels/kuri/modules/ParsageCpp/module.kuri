/* Module de parsage de fichiers C++.
 * Ceci ne permet pas de parser des fichiers C++ selon le standard du langage,
 * et ne permettra pas de créer un compilateur C++. Le but est d'avoir un
 * système pour extraire des données de code C++.
 */

importe Fondation
importe SysFichier

charge "arbre_syntaxique"
charge "fichier_source"
charge "préprocesseur"
charge "parseuse"

est_fichier_cpp :: fonc (chemin: CheminFichier) -> bool
{
    extension := chemin.extension()
    retourne fait_partie_de(extension, ".h", ".hh", ".cc", ".cpp")
}

/* ------------------------------------------------------------------------- */
/** \nom Parseuse C
 * \{ */

importe Introspection

ASTNode :: struct {
    genre := #type_de_cette_structure
}

imprime_arbre :: fonc (node: *ASTNode)
{
    rappel_pour_noeud :: fonc (visiteuse: *VisiteuseArbre(ASTNode), noeud: *ASTNode, info: *InfoTypeStructure) -> VisiteEnfants
    {
        imprime_tabulation(visiteuse.profondeur)
        imprimeln("%", info.nom)
        retourne VisiteEnfants.Oui
    }

    rappel_pour_tableau :: fonc (visiteuse: *VisiteuseArbre(ASTNode), tableau: [..]*ASTNode)
    {
        pour tableau {
            info := it.genre comme *InfoTypeStructure
            rappel_pour_noeud(visiteuse, it, info)
        }
    }

    visiteuse: VisiteuseArbre(ASTNode)
    visiteuse.rappel_pour_noeud = rappel_pour_noeud
    visite_noeud(*visiteuse, node)
}

TypeKind :: énum {
    CHAR
    UNSIGNED_CHAR
    SHORT
    UNSIGNED_SHORT
    INT
    UNSIGNED_INT
    LONG
    UNSIGNED_LONG
    LONG_LONG
    UNSIGNED_LONG_LONG
    FLOAT
    DOUBLE
    LONG_DOUBLE

    POINTER

    VOID

    RECORD
    REFERENCE // Pour TypeRef

    TYPEDEF

    FUNCTION
    CONSTANT_ARRAY
}

Type :: struct {
    empl node: ASTNode
    genre = #type_de_cette_structure

    kind: TypeKind
}

TypeRef :: struct {
    empl base_type: Type
    genre = #type_de_cette_structure
    kind = TypeKind.REFERENCE

    // À FAIRE : type référencé
    nom: chaine
}

PointerType :: struct {
    empl base_type: Type
    genre = #type_de_cette_structure
    kind = TypeKind.POINTER

    pointed_to: *Type
}

FunctionType :: struct {
    empl base_type: Type
    genre = #type_de_cette_structure
    kind = TypeKind.FUNCTION

    return_type: *Type
    parameters: [..]*ParamDecl
}

ParamDecl :: struct {
    empl base: ASTNode
    genre = #type_de_cette_structure

    name: chaine
    type: *Type
}

ConstantArray :: struct {
    empl base_type: Type
    genre = #type_de_cette_structure
    kind = TypeKind.CONSTANT_ARRAY

    size: n64
    element_type: *Type
}

TypedefDecl :: struct {
    empl base_type: Type
    genre = #type_de_cette_structure
    kind = TypeKind.TYPEDEF

    type: *Type
    underlying_type: *Type
}

StructDecl :: struct {
    empl base_type: Type
    genre = #type_de_cette_structure
    kind = TypeKind.RECORD

    name: chaine
    fields: [..]*FieldDecl
}

UnionDecl :: struct {
    empl base_type: Type
    genre = #type_de_cette_structure
    kind = TypeKind.RECORD

    name: chaine
    fields: [..]*FieldDecl
}

FieldDecl :: struct {
    empl node: ASTNode
    genre = #type_de_cette_structure

    name: chaine
    type: *Type
}

Expression :: struct {
    empl node: ASTNode
    genre = #type_de_cette_structure
}

IntegerLiteralExpression :: struct {
    empl expr: Expression
    genre = #type_de_cette_structure

    lexème: Lexème
}

BinaryExpression :: struct {
    empl expr: Expression
    genre = #type_de_cette_structure
    
    // À FAIRE : stocke les lexèmes
    op: chaine
    left: *Expression
    right: *Expression
}

UnaryExpression :: struct {
    empl expr: Expression
    genre = #type_de_cette_structure
    
    // À FAIRE : stocke les lexèmes
    op: chaine
    operand: *Expression
}

SizeOfExpression :: struct {
    empl expr: Expression
    genre = #type_de_cette_structure

    operand: *Expression
}

// À FAIRE : déduplique avec TypeRef (ou supprime ce dernier)
// Expression se trouvant par exemple dans sizeof().
TypeNameExpression :: struct {
    empl expr: Expression
    genre = #type_de_cette_structure
}

// À FAIRE : fusionne avec l'autre TranslationUnit
NewTranslationUnit :: struct {
    external_declarations: [..]*ASTNode
}

ParseuseC :: struct {
    lexeuse: SimpleLexeuse
    noeuds: [..]*ASTNode

    // À FAIRE : meilleure structure
    typedef_names: [..]chaine

    symbole_non_consommé_lors_du_parsage_de_type: chaine
}

initialise_parseuse :: fonc (parseuse: *ParseuseC)
{
    initialise_lexeuse_c(*parseuse.lexeuse)

    // À FAIRE : comprend ce que c'est
    tableau_ajoute(*parseuse.typedef_names, "__builtin_va_list")
}

crée_noeud :: fonc (parseuse: *ParseuseC, $T: type_de_données) -> *T
{
    résultat := loge(T)
    tableau_ajoute(*parseuse.noeuds, résultat)
    retourne résultat
}

crée_type :: fonc (parseuse: *ParseuseC, kind: TypeKind) -> *Type
{
    résultat := crée_noeud(parseuse, Type)
    résultat.kind = kind
    retourne résultat
}

crée_type_ref :: fonc (parseuse: *ParseuseC, nom: chaine) -> *TypeRef
{
    résultat := crée_noeud(parseuse, TypeRef)
    résultat.nom = nom
    retourne résultat
}

crée_pointer_type :: fonc (parseuse: *ParseuseC, pointed_to: *Type) -> *PointerType
{
    résultat := crée_noeud(parseuse, PointerType)
    résultat.pointed_to = pointed_to
    retourne résultat
}

crée_constant_array :: fonc (parseuse: *ParseuseC, element_type: *Type, size: n64) -> *ConstantArray
{
    résultat := crée_noeud(parseuse, ConstantArray)
    résultat.element_type = element_type
    résultat.size = size
    retourne résultat
}

rapporte_erreur :: fonc (parseuse: *ParseuseC, lexème: Lexème, format: chaine, args: ...eini)
{
    ligne := donne_ligne_pour_erreur(*parseuse.lexeuse)
    imprimeln("%", ligne.texte)
    imprimeln("%", lexème.donne_texte())
    imprimeln(format, ...args)
    exit(1)
} @Imprimeuse

parse_texte :: fonc (parseuse: *ParseuseC, texte: chaine) -> *ASTNode
{
    initialise_lexeuse_pour_texte(*parseuse.lexeuse, texte)

    résultat: *ASTNode

    lexème := épie_lexème_suivant(*parseuse.lexeuse)
    si est_mot_clé(lexème, "struct") {
        résultat = parse_struct_decl(parseuse)
    }
    sinon {
        résultat = parse_typedef_decl(parseuse) 
    }

    consomme_ponctuation(*parseuse.lexeuse, ";")

    retourne résultat
}

/* (6.9) translation-unit:
    external-declaration
    translation-unit external-declaration */
parse_translation_unit :: fonc (empl parseuse: *ParseuseC, texte: chaine) -> *NewTranslationUnit
{
    initialise_lexeuse_pour_texte(*parseuse.lexeuse, texte)

    résultat := loge(NewTranslationUnit)

    tantque !fini(*lexeuse) {
        external_declaration := parse_external_declaration(parseuse)
        tableau_ajoute(*résultat.external_declarations, external_declaration)
    }

    retourne résultat
}

est_storage_class_specifier :: fonc (lexème: Lexème) -> bool
{
    mots_clés := ["typedef", "extern", "static", "_Thread_local", "auto", "register"]
    pour mots_clés {
        si est_mot_clé(lexème, it) {
            retourne vrai
        }
    }
    retourne faux
}

est_type_specifier :: fonc (parseuse: *ParseuseC, lexème: Lexème) -> bool
{
    mots_clés := ["void", "char", "short", "int", "long", "float", "double", "signed", "unsigned", "_Bool", "_Complex", "struct", "union", "enum"]
    
    pour mots_clés {
        si est_mot_clé(lexème, it) {
            retourne vrai
        }
    }

    texte := donne_texte(lexème)

    pour parseuse.typedef_names {
        si it == texte {
            retourne vrai
        }
    }

    si texte == "_Atomic" {
        lexème_suivant := épie_lexème_suivant(*parseuse.lexeuse)
        retourne est_ponctuation(lexème_suivant, "(")
    }

    retourne faux
}

est_type_qualifier :: fonc (lexème: Lexème) -> bool
{
    mots_clés := ["const", "restrict", "volatile", "_Atomic"]
    pour mots_clés {
        si est_mot_clé(lexème, it) {
            retourne vrai
        }
    }
    retourne faux
}

est_function_specifier :: fonc (lexème: Lexème) -> bool
{
    mots_clés := ["inline", "_Noreturn"]
    pour mots_clés {
        si est_mot_clé(lexème, it) {
            retourne vrai
        }
    }
    retourne faux
}

est_alignment_specifier :: fonc (lexème: Lexème) -> bool
{
    retourne est_mot_clé(lexème, "_Alignas")
}

InfoDéclaration :: struct {
    storage_class_specifier: chaine
    type_specifiers: [..]chaine
    type_qualifiers: [..]chaine
    function_specifiers: [..]chaine
}

imprime_infos :: fonc (empl infos: *InfoDéclaration)
{
    si storage_class_specifier {
        imprimeln("storage class : %", storage_class_specifier)
    }

    si type_specifiers {
        imprimeln("type specifiers :")
        pour type_specifiers {
            imprimeln("-- %", it)
        }
    }

    si type_qualifiers {
        imprimeln("type qualifiers :")
        pour type_qualifiers {
            imprimeln("-- %", it)
        }
    }

    si function_specifiers {
        imprimeln("function specifiers :")
        pour function_specifiers {
            imprimeln("-- %", it)
        }
    }
}

parse_external_declaration :: fonc (empl parseuse: *ParseuseC) -> *ASTNode
{
    déclaration_courante: InfoDéclaration
    parse_declaration_specifiers(parseuse, *déclaration_courante, faux)

    si est_ponctuation(épie_lexème_suivant(*lexeuse), ";") {
        // À FAIRE : crée noeud.
        consomme(*lexeuse)
        retourne nul
    }

    declarator := parse_declarator(parseuse)
    saufsi declarator {
        rapporte_erreur(parseuse, donne_lexème_suivant(*lexeuse), "Attendu un declarateur")
        retourne nul
    }

    lexème := donne_lexème_suivant(*lexeuse)
    saufsi est_ponctuation(lexème, ";") {
        rapporte_erreur(parseuse, lexème, "Attendu un ';'")
        retourne nul
    }

    imprimeln("-----------")
    imprime_infos(*déclaration_courante)

    si déclaration_courante.storage_class_specifier == "typedef" {
        tantque declarator.genre == PointerDeclarator {
            pointer_decl := declarator comme *PointerDeclarator
            declarator = pointer_decl.direct
        }

        // À FAIRE
        assert(declarator.genre == IdentifierDeclarator)
        identifier := declarator comme *IdentifierDeclarator
        tableau_ajoute(*parseuse.typedef_names, donne_texte(identifier.identifiant))
    }

    // exit(0)

    retourne nul
}

/*
    (6.7) declaration-specifiers:
        storage-class-specifier declaration-specifiersopt
        type-specifier declaration-specifiersopt
        type-qualifier declaration-specifiersopt
        function-specifier declaration-specifiersopt
        alignment-specifier declaration-specifiersop
*/
parse_declaration_specifiers :: fonc (empl parseuse: *ParseuseC, déclaration: *InfoDéclaration, pour_struct_declaration: bool)
{
    boucle {
        lexème := donne_lexème_suivant(*lexeuse)
        si lexème.type == TypeLexème.FinDeFichier {
            rapporte_erreur(parseuse, lexème, "Fin inattendu de l'entrée")
            retourne
        }

        si est_storage_class_specifier(lexème) {
            si pour_struct_declaration {
                rapporte_erreur(parseuse, lexème, "Unexpected storage class specifier '%'", donne_texte(lexème))
                retourne
            }
            déclaration.storage_class_specifier = donne_texte(lexème)
        }
        sinon si est_type_specifier(parseuse, lexème) {
            // À FAIRE : vérifie que l'on peut ajout le spécifiant
            specifier := donne_texte(lexème)

            si specifier == "struct" || specifier == "union" {
                si déclaration.type_specifiers.taille != 0 {
                    rapporte_erreur(parseuse, lexème, "Unexpected type speficier '%'", specifier)
                    retourne
                }

                _ := parse_struct_or_union_specifier(parseuse, specifier)
            }
            sinon si specifier == "enum" {
                si déclaration.type_specifiers.taille != 0 {
                    rapporte_erreur(parseuse, lexème, "Unexpected type speficier '%'", specifier)
                    retourne
                }

                rapporte_erreur(parseuse, lexème, "Lexème non-géré '%'", specifier)
                retourne
            }
            sinon si specifier == "_Atomic" {
                si déclaration.type_specifiers.taille != 0 {
                    rapporte_erreur(parseuse, lexème, "Unexpected type speficier '%'", specifier)
                    retourne
                }

                rapporte_erreur(parseuse, lexème, "Lexème non-géré '%'", specifier)
                retourne
            }

            tableau_ajoute(*déclaration.type_specifiers, specifier)
        }
        sinon si est_type_qualifier(lexème) {
            tableau_ajoute(*déclaration.type_qualifiers, donne_texte(lexème))
        }
        sinon si est_function_specifier(lexème) {
            si pour_struct_declaration {
                rapporte_erreur(parseuse, lexème, "Unexpected function specifier '%'", donne_texte(lexème))
                retourne
            }
            tableau_ajoute(*déclaration.function_specifiers, donne_texte(lexème))
        }
        sinon si est_alignment_specifier(lexème) {
            si pour_struct_declaration {
                rapporte_erreur(parseuse, lexème, "Unexpected alignment specifier '%'", donne_texte(lexème))
                retourne
            }
            rapporte_erreur(parseuse, lexème, "_Alignas non-supporté")
            retourne
        }
        sinon {
            reprends_depuis_lexème(*lexeuse, lexème)
            retourne
        }
    }
}

/* (6.7.6) declarator:
    pointeropt direct-declarator
*/
Declarator :: struct {
    genre: type_de_données
}

parse_declarator :: fonc (empl parseuse: *ParseuseC) -> *Declarator
{
    pointer: *PointerDeclarator

    lexème := épie_lexème_suivant(*lexeuse)
    tantque est_ponctuation(lexème, "*") {
        consomme(*lexeuse)

        pointer_courant := loge(PointerDeclarator)

        lexème = épie_lexème_suivant(*lexeuse)
        tantque est_type_qualifier(lexème) {
            consomme(*lexeuse)
            tableau_ajoute(*pointer_courant.qualifiers, donne_texte(lexème))
        }

        si pointer {
            pointer.direct = pointer_courant
        }

        pointer = pointer_courant
    }

    résultat := parse_direct_declarator(parseuse)
    si pointer {
        pointer.direct = résultat
        résultat = pointer
    }
    retourne résultat
}

/* direct-declarator:
    identifier
    ( declarator )
    direct-declarator [ type-qualifier-listopt assignment-expressionopt ]
    direct-declarator [ static type-qualifier-listopt assignment-expression ]
    direct-declarator [ type-qualifier-list static assignment-expression ]
    direct-declarator [ type-qualifier-listopt * ]
    direct-declarator ( parameter-type-list )
    direct-declarator ( identifier-listopt )
 */
IdentifierDeclarator :: struct {
    empl base: Declarator
    genre = #type_de_cette_structure

    identifiant: Lexème
}

ArrayDeclarator :: struct {
    empl base: Declarator
    genre = #type_de_cette_structure

    direct: *Declarator
    expression: *Expression
}

PointerDeclarator :: struct {
    empl base: Declarator
    genre = #type_de_cette_structure

    qualifiers: [..]chaine
    direct: *Declarator
}

parse_direct_declarator :: fonc (empl parseuse: *ParseuseC) -> *Declarator
{
    lexème := épie_lexème_suivant(*lexeuse)

    direct: *Declarator

    si lexème.type == TypeLexème.Symbole {
        consomme(*lexeuse)

        identifier := loge(IdentifierDeclarator)
        identifier.identifiant = lexème
        direct = identifier
    }
    sinon si est_ponctuation(lexème, "(") {
        consomme(*lexeuse)
        direct = parse_declarator(parseuse)
        consomme_ponctuation(*lexeuse, ")")
    }
    sinon {
        rapporte_erreur(parseuse, lexème, "Lexème non-géré pour declarator")
        retourne nul
    }

    boucle {
        lexème = épie_lexème_suivant(*lexeuse)

        si est_ponctuation(lexème, "[") {
            consomme(*lexeuse)

            expression: *Expression

            lexème = épie_lexème_suivant(*lexeuse)
            saufsi est_ponctuation(lexème, "]") {
                expression = parse_expression(parseuse)
            }

            array := loge(ArrayDeclarator)
            array.direct = direct
            array.expression = expression
            direct = array

            consomme_ponctuation(*lexeuse, "]")
        }
        sinon {
            arrête
        }
    }

    retourne direct
}

/* struct-or-union-specifier:
    struct-or-union identifieropt { struct-declaration-list }
    struct-or-union identifier
 */
parse_struct_or_union_specifier :: fonc (empl parseuse: *ParseuseC, classe: chaine) -> *Type
{
    assert(classe == "struct" || classe == "union")

    lexème := épie_lexème_suivant(*lexeuse)

    eu_nom := faux
    nom: chaine
    si lexème.type == TypeLexème.Symbole {
        consomme_symbole(*lexeuse)
        nom = donne_texte(lexème)
        eu_nom = vrai

        lexème = épie_lexème_suivant(*lexeuse)
    }

    fields: [..]*FieldDecl
    si est_ponctuation(lexème, "{") {
        consomme_ponctuation(*lexeuse, "{")
        parse_struct_declaration_list(parseuse, *fields)
    }
    sinon saufsi eu_nom {
        rapporte_erreur(parseuse, lexème, "Lexème inattendu dans le parsage de la structure : %", donne_texte(lexème))
        retourne nul
    }

    si classe == "union" {
        résultat := crée_noeud(parseuse, UnionDecl)
        résultat.name = nom
        résultat.fields = fields
        retourne résultat
    }

    résultat := crée_noeud(parseuse, StructDecl)
    résultat.name = nom
    résultat.fields = fields
    retourne résultat
}

/* struct-declaration:
    specifier-qualifier-list struct-declarator-listopt ;
    static_assert-declaration */
parse_struct_declaration_list :: fonc (empl parseuse: *ParseuseC, fields: *[..]*FieldDecl)
{
    boucle {
        lexème := épie_lexème_suivant(*lexeuse)
        si lexème.type == TypeLexème.FinDeFichier {
            rapporte_erreur(parseuse, lexème, "Unexpected end of input")
            retourne
        }

        si est_ponctuation(lexème, "}") {
            consomme(*lexeuse)
            retourne
        }

        déclaration_courante: InfoDéclaration
        parse_declaration_specifiers(parseuse, *déclaration_courante, vrai)

        /* struct-declarator:
            declarator
            declaratoropt : constant-expression */
        _ := parse_declarator(parseuse)

        lexème = donne_lexème_suivant(*lexeuse)
        saufsi est_ponctuation(lexème, ";") {
            rapporte_erreur(parseuse, lexème, "Expected a ';'")
            retourne
        }
    }
}

parse_typedef_decl :: fonc (empl parseuse: *ParseuseC) -> *TypedefDecl
{
    consomme_mot_clé(*lexeuse, "typedef")

    lexème := épie_lexème_suivant(*lexeuse)
    si lexème.type == TypeLexème.FinDeFichier {
        rapporte_erreur(parseuse, lexème, "Fin inattendu de l'entrée")
        retourne nul
    }

    underlying_type := parse_type(parseuse)

    type: *Type

    lexème = épie_lexème_suivant(*lexeuse)
    si lexème.type == TypeLexème.Symbole {
        consomme(*lexeuse)
        type = crée_type_ref(parseuse, donne_texte(lexème))
    }
    sinon si parseuse.symbole_non_consommé_lors_du_parsage_de_type {
        type = crée_type_ref(parseuse, parseuse.symbole_non_consommé_lors_du_parsage_de_type)
        parseuse.symbole_non_consommé_lors_du_parsage_de_type = ""
    }
    sinon {
        rapporte_erreur(parseuse, lexème, "Attendu un symbole pour nommer le typedef")
        retourne nul
    }

    résultat := crée_noeud(parseuse, TypedefDecl)
    résultat.underlying_type = underlying_type
    résultat.type = type
    retourne résultat
}

parse_type :: fonc (empl parseuse: *ParseuseC) -> *Type
{
    lexème := épie_lexème_suivant(*lexeuse)

    // À FAIRE : gère "const"
    si est_mot_clé(lexème, "const") {
        consomme(*lexeuse)
        lexème = épie_lexème_suivant(*lexeuse)
    }

    résultat: *Type
    si est_mot_clé(lexème, "char") || est_symbole(lexème, "int8_t") {
        consomme(*lexeuse)
        résultat = crée_type(parseuse, TypeKind.CHAR)
    }
    sinon si est_mot_clé(lexème, "short") || est_symbole(lexème, "int16_t") {
        consomme(*lexeuse)
        résultat = crée_type(parseuse, TypeKind.SHORT)
    }
    sinon si est_mot_clé(lexème, "int") || est_symbole(lexème, "int32_t") {
        consomme(*lexeuse)
        résultat = crée_type(parseuse, TypeKind.INT)
    }
    sinon si est_mot_clé(lexème, "long") || est_symbole(lexème, "int64_t") {
        consomme(*lexeuse)
        résultat = crée_type(parseuse, TypeKind.LONG)
    }
    sinon si est_mot_clé(lexème, "float") {
        consomme(*lexeuse)
        résultat = crée_type(parseuse, TypeKind.FLOAT)
    }
    sinon si est_mot_clé(lexème, "double") {
        consomme(*lexeuse)
        résultat = crée_type(parseuse, TypeKind.DOUBLE)
    }
    sinon si est_mot_clé(lexème, "unsigned") {
        consomme(*lexeuse)
        lexème = épie_lexème_suivant(*lexeuse)

        si est_mot_clé(lexème, "char") || est_symbole(lexème, "uint8_t") {
            consomme(*lexeuse)
            résultat = crée_type(parseuse, TypeKind.UNSIGNED_CHAR)
        }
        sinon si est_mot_clé(lexème, "short") || est_symbole(lexème, "uint16_t") {
            consomme(*lexeuse)
            résultat = crée_type(parseuse, TypeKind.UNSIGNED_SHORT)
        }
        sinon si est_mot_clé(lexème, "int") || est_symbole(lexème, "uint32_t") {
            consomme(*lexeuse)
            résultat = crée_type(parseuse, TypeKind.UNSIGNED_INT)
        }
        sinon si est_mot_clé(lexème, "long") || est_symbole(lexème, "uint64_t") {
            consomme(*lexeuse)
            résultat = crée_type(parseuse, TypeKind.UNSIGNED_LONG)
        }
        sinon {
            rapporte_erreur(parseuse, lexème, "Lexème inconnu pour le parsage des typedefs : '%' (%)", donne_texte(lexème), lexème.type)
            retourne nul
        }
    }
    sinon si est_mot_clé(lexème, "struct") {
        résultat = parse_struct_decl(parseuse)
    }
    sinon si est_mot_clé(lexème, "union") {
        résultat = parse_union_decl(parseuse)
    }
    sinon si est_mot_clé(lexème, "void") {
        consomme(*lexeuse)
        résultat = crée_type(parseuse, TypeKind.VOID)
    }
    sinon si lexème.type == TypeLexème.Symbole {
        consomme_symbole(*lexeuse)
        résultat = crée_type_ref(parseuse, donne_texte(lexème))
    }

    tantque !fini(*lexeuse) {
        lexème = épie_lexème_suivant(*lexeuse)

        si est_ponctuation(lexème, "*") {
            consomme(*lexeuse)
            résultat = crée_pointer_type(parseuse, résultat)
        }
        sinon si est_mot_clé(lexème, "const") {
            consomme(*lexeuse)
        }
        sinon {
            arrête
        }
    }

    lexème = épie_lexème_suivant(*lexeuse)
    si est_ponctuation(lexème, "(") {
        // À FAIRE : gère proprement les pointeurs de fonctions
        consomme_ponctuation(*lexeuse, "(")

        consomme_ponctuation(*lexeuse, "*")

        lexème = donne_lexème_suivant(*lexeuse)
        si lexème.type != TypeLexème.Symbole {
            rapporte_erreur(parseuse, lexème, "Attendu un symbole dans la définition du pointeur de fonction")
            retourne nul
        }

        // À FAIRE : récursion
        parseuse.symbole_non_consommé_lors_du_parsage_de_type = donne_texte(lexème)

        consomme_ponctuation(*lexeuse, ")")

        consomme_ponctuation(*lexeuse, "(")

        params: [..]*ParamDecl
        
        tantque !fini(*lexeuse) {
            lexème = épie_lexème_suivant(*lexeuse)
            si est_ponctuation(lexème, ")") {
                arrête
            }

            type_param := parse_type(parseuse)
            nom_param: chaine

            lexème = épie_lexème_suivant(*lexeuse)
            si lexème.type == TypeLexème.Symbole {
                consomme(*lexeuse)
                nom_param = donne_texte(lexème)
                lexème = épie_lexème_suivant(*lexeuse)
            }

            param := crée_noeud(parseuse, ParamDecl)
            param.name = nom_param
            param.type = type_param
            tableau_ajoute(*params, param)

            saufsi est_ponctuation(lexème, ",") {
                arrête
            }

            consomme_ponctuation(*lexeuse, ",")
        }

        consomme_ponctuation(*lexeuse, ")")

        function_type := crée_noeud(parseuse, FunctionType)
        function_type.return_type = résultat
        function_type.parameters = params

        résultat = crée_pointer_type(parseuse, function_type)
    }

    retourne résultat
}

parse_struct_decl :: fonc (empl parseuse: *ParseuseC) -> *StructDecl
{
    consomme_mot_clé(*parseuse.lexeuse, "struct")
    lexème := épie_lexème_suivant(*lexeuse)

    eu_nom := faux
    nom: chaine
    si lexème.type == TypeLexème.Symbole {
        consomme_symbole(*lexeuse)
        nom = donne_texte(lexème)
        eu_nom = vrai

        lexème = épie_lexème_suivant(*lexeuse)
    }

    fields: [..]*FieldDecl
    si est_ponctuation(lexème, "{") {
        consomme_ponctuation(*lexeuse, "{")
        fields = parse_fields(parseuse)
    }
    sinon saufsi eu_nom {
        rapporte_erreur(parseuse, lexème, "Lexème inattendu dans le parsage de la structure : %", donne_texte(lexème))
        retourne nul
    }

    résultat := crée_noeud(parseuse, StructDecl)
    résultat.name = nom
    résultat.fields = fields
    retourne résultat
}

parse_union_decl :: fonc (empl parseuse: *ParseuseC) -> *UnionDecl
{
    consomme_mot_clé(*parseuse.lexeuse, "union")
    lexème := épie_lexème_suivant(*lexeuse)

    eu_nom := faux
    nom: chaine
    si lexème.type == TypeLexème.Symbole {
        consomme_symbole(*lexeuse)
        nom = donne_texte(lexème)
        eu_nom = vrai

        lexème = épie_lexème_suivant(*lexeuse)
    }

    fields: [..]*FieldDecl
    si est_ponctuation(lexème, "{") {
        consomme_ponctuation(*lexeuse, "{")
        fields = parse_fields(parseuse)
    }
    sinon saufsi eu_nom {
        rapporte_erreur(parseuse, lexème, "Lexème inattendu dans le parsage de l'union : %", donne_texte(lexème))
        retourne nul
    }

    résultat := crée_noeud(parseuse, UnionDecl)
    résultat.name = nom
    résultat.fields = fields
    retourne résultat
}

parse_fields :: fonc (empl parseuse: *ParseuseC) -> [..]*FieldDecl
{
    résultat: [..]*FieldDecl

    tantque !fini(*lexeuse) {
        lexème := épie_lexème_suivant(*lexeuse)
        si est_ponctuation(lexème, "}") {
            arrête
        }

        type := parse_type(parseuse)

        lexème = donne_lexème_suivant(*lexeuse)
        si lexème.type != TypeLexème.Symbole {
            rapporte_erreur(parseuse, lexème, "Attendu un symbole, obtenu : % (%)", donne_texte(lexème), lexème.type)
            retourne résultat
        }

        lexème_nom := lexème

        lexème = épie_lexème_suivant(*lexeuse)
        // À FAIRE : mets ça dans parse_type
        si est_ponctuation(lexème, "[") {
            consomme(*lexeuse)

            lexème_nombre := donne_nombre(*lexeuse)
            type = crée_constant_array(parseuse, type, lexème_nombre.nombre)

            consomme_ponctuation(*lexeuse, "]")
        }

        field := crée_noeud(parseuse, FieldDecl)
        field.name = donne_texte(lexème_nom)
        field.type = type

        tableau_ajoute(*résultat, field)

        lexème = épie_lexème_suivant(*lexeuse)
        tantque est_ponctuation(lexème, ",") {
            consomme(*lexeuse)

            lexème = donne_lexème_suivant(*lexeuse)
            si lexème.type != TypeLexème.Symbole {
                rapporte_erreur(parseuse, lexème, "Attendu un symbole, obtenu : % (%)", donne_texte(lexème), lexème.type)
                retourne résultat
            }

            field = crée_noeud(parseuse, FieldDecl)
            field.name = donne_texte(lexème)
            field.type = type

            tableau_ajoute(*résultat, field)

            lexème = épie_lexème_suivant(*lexeuse)
        }

        consomme_ponctuation(*lexeuse, ";")
    }

    consomme_ponctuation(*lexeuse, "}")

    retourne résultat
}

imprime_type_kuri :: fonc (enchaineuse: *Enchaineuse, type_c: *Type)
{
    discr type_c.kind {
        CHAR {
            ajoute_au_tampon(enchaineuse, "z8")
        }
        UNSIGNED_CHAR {
            ajoute_au_tampon(enchaineuse, "n8")
        }
        SHORT {
            ajoute_au_tampon(enchaineuse, "z16")
        }
        UNSIGNED_SHORT {
            ajoute_au_tampon(enchaineuse, "n16")
        }
        INT {
            ajoute_au_tampon(enchaineuse, "z32")
        }
        UNSIGNED_INT {
            ajoute_au_tampon(enchaineuse, "n32")
        }
        LONG {
            ajoute_au_tampon(enchaineuse, "z64")
        }
        UNSIGNED_LONG {
            ajoute_au_tampon(enchaineuse, "n64")
        }
        LONG_LONG {
            ajoute_au_tampon(enchaineuse, "TYPE_NON_SUPPORTÉ : LONG_LONG")
        }
        UNSIGNED_LONG_LONG {
            ajoute_au_tampon(enchaineuse, "TYPE_NON_SUPPORTÉ : UNSIGNED_LONG_LONG")
        }
        FLOAT {
            ajoute_au_tampon(enchaineuse, "r32")
        }
        DOUBLE {
            ajoute_au_tampon(enchaineuse, "r64")
        }
        LONG_DOUBLE {
            ajoute_au_tampon(enchaineuse, "TYPE_NON_SUPPORTÉ : LONG_DOUBLE")
        }
        POINTER {
            type_pointeur := type_c comme *PointerType

            si type_pointeur.pointed_to.genre == FunctionType {
                imprime_type_kuri(enchaineuse, type_pointeur.pointed_to)
            }
            sinon {
                ajoute_au_tampon(enchaineuse, "*")
                imprime_type_kuri(enchaineuse, type_pointeur.pointed_to)
            }
        }
        VOID {
            ajoute_au_tampon(enchaineuse, "rien")
        }
        RECORD {
            si type_c.genre == StructDecl {
                struct_decl := type_c comme *StructDecl
                ajoute_au_tampon(enchaineuse, struct_decl.name)
            }
            sinon si type_c.genre == UnionDecl {
                union_decl := type_c comme *UnionDecl
                ajoute_au_tampon(enchaineuse, union_decl.name)
            }
            sinon {
                ajoute_au_tampon(enchaineuse, "TYPE_NON_SUPPORTÉ : RECORD")
            }
        }
        REFERENCE {
            type_ref := type_c comme *TypeRef
            ajoute_au_tampon(enchaineuse, type_ref.nom)
        }
        TYPEDEF {

        }
        FUNCTION {
            type_fonction := type_c comme *FunctionType
            ajoute_au_tampon(enchaineuse, "fonc (")
            virgule := ""
            pour type_fonction.parameters {
                si it.type.kind == TypeKind.VOID {
                    assert(indice_it == 0)
                    arrête
                }

                ajoute_au_tampon(enchaineuse, virgule)

                si it.name {
                    ajoute_au_tampon(enchaineuse, it.name, ": ")
                }

                imprime_type_kuri(enchaineuse, it.type)
                virgule = ", "
            }
            ajoute_au_tampon(enchaineuse, ") -> ")
            imprime_type_kuri(enchaineuse, type_fonction.return_type)
        }
        CONSTANT_ARRAY {
            constant_array := type_c comme *ConstantArray
            imprime_dans_enchaineuse(enchaineuse, "[%]", constant_array.size)
            imprime_type_kuri(enchaineuse, constant_array.element_type)
        }
    }
}

déclare_type_kuri :: fonc (enchaineuse: *Enchaineuse, type_c: *Type, nom_typedef := "")
{
    si type_c.genre == StructDecl {
        struct_decl := type_c comme *StructDecl
        saufsi nom_typedef {
            nom_typedef = struct_decl.name
        }
        imprime_dans_enchaineuse(enchaineuse, "% :: struct {\n", nom_typedef)
        pour struct_decl.fields {
            imprime_dans_enchaineuse(enchaineuse, "    %: ", it.name)
            imprime_type_kuri(enchaineuse, it.type)
            ajoute_au_tampon(enchaineuse, "\n")
        }
        ajoute_au_tampon(enchaineuse, "}\n")
    }
    sinon si type_c.genre == UnionDecl {
        union_decl := type_c comme *UnionDecl
        saufsi nom_typedef {
            nom_typedef = union_decl.name
        }
        imprime_dans_enchaineuse(enchaineuse, "% :: union nonsûr {\n", nom_typedef)
        pour union_decl.fields {
            imprime_dans_enchaineuse(enchaineuse, "    %: ", it.name)
            imprime_type_kuri(enchaineuse, it.type)
            ajoute_au_tampon(enchaineuse, "\n")
        }
        ajoute_au_tampon(enchaineuse, "}\n")
    }
}

est_structure_ou_union_anonyme :: fonc (type_c: *Type) -> bool
{
    résultat := faux

    si type_c.genre == StructDecl {
        struct_decl := type_c comme *StructDecl
        résultat = struct_decl.name == ""
    }
    sinon si type_c.genre == UnionDecl {
        union_decl := type_c comme *UnionDecl
        résultat = union_decl.name == ""
    }

    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Parsage des expressions.
 * \{ */

donne_info_parsage_opérateur_binaire_c :: fonc (texte: chaine) -> (bool, InfoParsageOpérateur)
{
    est_opérateur := vrai
    résultat: InfoParsageOpérateur

    si texte == "," {
        résultat.précédence = 1
        résultat.associativité = Associativité.GAUCHE
    }
    sinon si texte == "=" || texte == "+=" || texte == "-=" || texte == "*=" || texte == "/=" || texte == "%=" || texte == "<<=" || texte == ">>=" || texte == "&=" || texte == "|=" || texte == "^=" {
        résultat.précédence = 2
        résultat.associativité = Associativité.DROITE
    }
    sinon si texte == "?" {
        résultat.précédence = 3
        résultat.associativité = Associativité.DROITE
    }
    sinon si texte == "||" {
        résultat.précédence = 4
        résultat.associativité = Associativité.GAUCHE
    }
    sinon si texte == "&&" {
        résultat.précédence = 5
        résultat.associativité = Associativité.GAUCHE
    }
    sinon si texte == "|" {
        résultat.précédence = 6
        résultat.associativité = Associativité.GAUCHE
    }
    sinon si texte == "^" {
        résultat.précédence = 7
        résultat.associativité = Associativité.GAUCHE
    }
    sinon si texte == "&" {
        résultat.précédence = 8
        résultat.associativité = Associativité.GAUCHE
    }
    sinon si texte == "==" || texte == "!=" {
        résultat.précédence = 9
        résultat.associativité = Associativité.GAUCHE
    }
    sinon si texte == ">" || texte == ">=" || texte == "<" || texte == "<=" {
        résultat.précédence = 10
        résultat.associativité = Associativité.GAUCHE
    }
    sinon si texte == "<<" || texte == ">>" {
        résultat.précédence = 11
        résultat.associativité = Associativité.GAUCHE
    }
    sinon si texte == "-" || texte == "+" {
        résultat.précédence = 12
        résultat.associativité = Associativité.GAUCHE
    }
    sinon si texte == "*" || texte == "/" || texte == "%" {
        résultat.précédence = 13
        résultat.associativité = Associativité.GAUCHE
    }
    /* la précédence de 14 est réservée pour les opérateurs unaires */
    sinon si texte == "(" || texte == "[" || texte == "." || texte == "->" {
        résultat.précédence = 15
        résultat.associativité = Associativité.GAUCHE
        // À FAIRE : postfix ++ et --
    }
    sinon {
        est_opérateur = faux
    }

    retourne est_opérateur, résultat
}

parse_expression :: fonc (empl parseuse: *ParseuseC) -> *Expression
{
    retourne parse_expression(parseuse, InfoParsageOpérateur())
}

parse_expression :: fonc (empl parseuse: *ParseuseC, info_courante: InfoParsageOpérateur) -> *Expression
{
    gauche := parse_expression_primaire(parseuse)
    saufsi gauche {
        retourne nul
    }

    résultat := gauche

    boucle {
        lexème := épie_lexème_suivant(*lexeuse)
        si lexème.type == TypeLexème.FinDeFichier {
            rapporte_erreur(parseuse, lexème, "Unexpected end of input")
            retourne nul
        }

        texte := donne_texte(lexème)
        est_opérateur, info := donne_info_parsage_opérateur_binaire_c(texte)
        saufsi est_opérateur {
            arrête
        }

        si info.précédence < info_courante.précédence {
            arrête
        }

        si info.précédence == info_courante.précédence && info_courante.associativité == Associativité.GAUCHE {
            arrête
        }

        si texte == ">" || texte == ">=" || texte == "<" || texte == "<=" || texte == "==" || texte == "!=" || texte == "-" || texte == "+" || texte == "*" || texte == "/" || texte == "<<" || texte == ">>" || texte == "&" || texte == "^" || texte == "|" || texte == "%" {
            consomme(*lexeuse)

            opérateur_binaire := loge(BinaryExpression)
            opérateur_binaire.op = texte
            opérateur_binaire.left = résultat
            opérateur_binaire.right = parse_expression(parseuse, info)

            résultat = opérateur_binaire
        }
        sinon {
            arrête
        }
    }

    retourne résultat
}

parse_expression_primaire :: fonc (empl parseuse: *ParseuseC) -> *Expression
{
    résultat: *Expression

    lexème := épie_lexème_suivant(*lexeuse)

    si est_mot_clé(lexème, "sizeof") {
        consomme(*lexeuse)

        consomme_ponctuation(*lexeuse, "(")

        operand := pase_type_name(parseuse)

        consomme_ponctuation(*lexeuse, ")")

        sizeof := crée_noeud(parseuse, SizeOfExpression)
        sizeof.operand = operand

        résultat = sizeof
    }
    sinon si lexème.type == TypeLexème.LittéraleNombreEntier {
        consomme(*lexeuse)

        literal := crée_noeud(parseuse, IntegerLiteralExpression)
        literal.lexème = lexème

        résultat = literal
    }
    sinon {
        rapporte_erreur(parseuse, lexème, "Expected a primary expression")
    }

    retourne résultat
}

pase_type_name :: fonc (empl parseuse: *ParseuseC) -> *TypeNameExpression
{
    déclaration_courante: InfoDéclaration
    parse_declaration_specifiers(parseuse, *déclaration_courante, vrai)

    /* struct-declarator:
        declarator
        declaratoropt : constant-expression */
    _ := parse_abstract_declarator(parseuse)

    retourne crée_noeud(parseuse, TypeNameExpression)
}

AbstractDeclarator :: struct {
    genre: type_de_données
}

parse_abstract_declarator :: fonc (empl parseuse: *ParseuseC) -> *AbstractDeclarator
{
    pointer: *AbstractPointerDeclarator

    lexème := épie_lexème_suivant(*lexeuse)
    tantque est_ponctuation(lexème, "*") {
        consomme(*lexeuse)

        pointer_courant := loge(AbstractPointerDeclarator)

        lexème = épie_lexème_suivant(*lexeuse)
        tantque est_type_qualifier(lexème) {
            consomme(*lexeuse)
            tableau_ajoute(*pointer_courant.qualifiers, donne_texte(lexème))
        }

        si pointer {
            pointer.direct = pointer_courant
        }

        pointer = pointer_courant
    }

    résultat := parse_direct_abstract_declarator(parseuse)
    si pointer {
        pointer.direct = résultat
        résultat = pointer
    }
    retourne résultat
}

/* direct-abstract-declarator:
    ( abstract-declarator )
    direct-abstract-declaratoropt [ type-qualifier-listopt
    assignment-expressionopt ]
    direct-abstract-declaratoropt [ static type-qualifier-listopt
    assignment-expression ]
    direct-abstract-declaratoropt [ type-qualifier-list static
    assignment-expression ]
    direct-abstract-declaratoropt [*]
    direct-abstract-declaratoropt ( parameter-type-listopt )
 */
AbstractArrayDeclarator :: struct {
    empl base: AbstractDeclarator
    genre = #type_de_cette_structure

    direct: *AbstractDeclarator
    taille: Lexème
}

AbstractPointerDeclarator :: struct {
    empl base: AbstractDeclarator
    genre = #type_de_cette_structure

    qualifiers: [..]chaine
    direct: *AbstractDeclarator
}

parse_direct_abstract_declarator :: fonc (empl parseuse: *ParseuseC) -> *AbstractDeclarator
{
    lexème := épie_lexème_suivant(*lexeuse)

    direct: *AbstractDeclarator

    si est_ponctuation(lexème, "(") {
        consomme(*lexeuse)
        direct = parse_abstract_declarator(parseuse)
        consomme_ponctuation(*lexeuse, ")")
    }

    boucle {
        lexème = épie_lexème_suivant(*lexeuse)

        si est_ponctuation(lexème, "[") {
            consomme(*lexeuse)

            lexème = donne_lexème_suivant(*lexeuse)
            si lexème.type != TypeLexème.LittéraleNombreEntier {
                rapporte_erreur(parseuse, lexème, "Lexème non-géré pour abstract array declarator")
            }

            array := loge(AbstractArrayDeclarator)
            array.direct = direct
            array.taille = lexème
            direct = array

            consomme_ponctuation(*lexeuse, "]")
        }
        sinon {
            arrête
        }
    }

    retourne direct
}

/** \} */
