/* ------------------------------------------------------------------------- */
/** \nom TranslationUnit
 * \{ */

TranslationUnit :: struct {
    chemin_racine: chaine
    info_langage: InfoLangage
    fichiers: [..]FichierSource
    lexèmes_préprocès: [..]LexèmePréprocès
    /* Les lexèmes_préprocès sont convertis en tokens par la parseuse avant le parsage. */
    tokens: [..]Token

    declarations: [..]*ASTNode
}

crée_translation_unit_pour_fichier :: fonc (chemin: chaine) -> *TranslationUnit
{
    info_langage := donne_info_langage_pour_fichier(chemin)
    retourne crée_translation_unit_pour_fichier(chemin, info_langage)
}

crée_translation_unit_pour_fichier :: fonc (chemin: chaine, info: InfoLangage) -> *TranslationUnit
{
    info_langage := donne_info_langage_valide(info)

    résultat := loge(TranslationUnit)
    résultat.chemin_racine = chemin
    résultat.info_langage = info_langage
    retourne résultat
}

détruit :: fonc (unit: *TranslationUnit)
{
    déloge(unit.lexèmes_préprocès)
    déloge(unit.tokens)
    déloge(unit.fichiers)
    déloge(unit)
}

résoud_plage_source :: fonc (unit: *TranslationUnit, lexème: Token) -> PlageSourceRésolue
{
    assert(est_valide(lexème.plage_source))
    
    fichier := *unit.fichiers[lexème.plage_source.début.fichier]

    assert(lexème.plage_source.début.fichier == lexème.plage_source.fin.fichier)

    texte_lexème := chaine(fichier.contenu_prétaité.pointeur + lexème.plage_source.début.décalage, lexème.plage_source.fin.décalage - lexème.plage_source.début.décalage) // donne_texte(lexème)
    texte_ligne := donne_ligne_pour_erreur(fichier.contenu_prétaité, texte_lexème)

    résultat: PlageSourceRésolue
    résultat.fichier = fichier.chemin

    si texte_ligne {
        résultat.texte_ligne = texte_ligne
        résultat.numéro_colonne = (texte_lexème.pointeur - texte_ligne.pointeur) comme n64 + 1
        résultat.numéro_colonne_fin = résultat.numéro_colonne + texte_lexème.taille comme n64
    }

    retourne résultat
}

/** \} */
