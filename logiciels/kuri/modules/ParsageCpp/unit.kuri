/* ------------------------------------------------------------------------- */
/** \nom TranslationUnit
 * \{ */

TranslationUnit :: struct {
    chemin_racine: chaine
    info_langage: InfoLangage
    fichiers: [..]FichierSource
    lexèmes_préprocès: [..]LexèmePréprocès
    /* Les lexèmes_préprocès sont convertis en tokens par la parseuse avant le parsage. */
    tokens: [..]Token

    declarations: [..]*ASTNode
}

crée_translation_unit_pour_fichier :: fonc (chemin: chaine) -> *TranslationUnit
{
    info_langage := donne_info_langage_pour_fichier(chemin)
    retourne crée_translation_unit_pour_fichier(chemin, info_langage)
}

crée_translation_unit_pour_fichier :: fonc (chemin: chaine, info: InfoLangage) -> *TranslationUnit
{
    info_langage := donne_info_langage_valide(info)

    résultat := loge(TranslationUnit)
    résultat.chemin_racine = chemin
    résultat.info_langage = info_langage
    retourne résultat
}

détruit :: fonc (unit: *TranslationUnit)
{
    déloge(unit.lexèmes_préprocès)
    déloge(unit.tokens)
    déloge(unit.fichiers)
    déloge(unit)
}

résoud_plage_source :: fonc (unit: *TranslationUnit, plage_source: PlageSource) -> PlageSourceRésolue
{
    assert(est_valide(plage_source))
    
    fichier := *unit.fichiers[plage_source.début.fichier]

    assert(plage_source.début.fichier == plage_source.fin.fichier)

    texte_lexème := chaine(fichier.contenu_prétaité.pointeur + plage_source.début.décalage, plage_source.fin.décalage - plage_source.début.décalage)
    texte_ligne := donne_ligne_pour_erreur(fichier.contenu_prétaité, texte_lexème)

    résultat: PlageSourceRésolue
    résultat.fichier = fichier.chemin

    si texte_ligne {
        résultat.texte_ligne = texte_ligne
        résultat.numéro_ligne = 1

        début := fichier.contenu_prétaité.pointeur
        fin := texte_ligne.pointeur

        tantque début < fin {
            si mémoire(début) == '\n' {
                résultat.numéro_ligne += 1
            }
            début += 1
        }

        résultat.numéro_colonne = (texte_lexème.pointeur - texte_ligne.pointeur) comme n64 + 1
        résultat.numéro_colonne_fin = résultat.numéro_colonne + texte_lexème.taille comme n64
    }

    retourne résultat
}

TypeDiagnostique :: énum {
    ERREUR
    ERREUR_INTERNE
    AVERTISSEMENT
    NOTE
}

rapporte_diagnostique :: fonc (unit: *TranslationUnit, type: TypeDiagnostique, lexème: LexèmePréprocès, format: chaine, args: ...eini)
{
    rapporte_diagnostique(unit, type, lexème.plage_source, format, ...args)
}

rapporte_diagnostique :: fonc (unit: *TranslationUnit, type: TypeDiagnostique, token: Token, format: chaine, args: ...eini)
{
    rapporte_diagnostique(unit, type, token.plage_source, format, ...args)
}

rapporte_diagnostique :: fonc (unit: *TranslationUnit, type: TypeDiagnostique, plage_source: PlageSource, format: chaine, args: ...eini)
{
    couleur: chaine = ---
    intitulé: chaine = ---
    discr type {
        ERREUR {
            couleur = "\x1b[31m"
            intitulé = "erreur"
        }
        ERREUR_INTERNE {
            couleur = "\x1b[31m"
            intitulé = "erreur interne"
        }
        AVERTISSEMENT {
            couleur = "\x1b[35m"
            intitulé = "avertissement"
        }
        NOTE {
            couleur = "\x1b[36m"
            intitulé = "note"
        }
        sinon {
            couleur = "\x1b[31m"
            intitulé = "erreur inconnue"
        }
    }

    si est_valide(plage_source) {
        empl plage_source_résolue := résoud_plage_source(unit, plage_source)
        imprime("\x1b[1m%:%:% ", plage_source_résolue.fichier, numéro_ligne, numéro_colonne)
        imprime("%% : \x1b[00m", couleur, intitulé)
        imprimeln(format, ...args)

        si texte_ligne {
            assert(numéro_colonne > 0)

            largeur_numéro_ligne := magnitude_décimale(numéro_ligne)
            largeur_goutière := max(6 comme n64, largeur_numéro_ligne + 2)

            pour largeur_goutière - largeur_numéro_ligne - 1 {
                imprime(" ")
            }

            imprime("% | ", numéro_ligne)

            si type != TypeDiagnostique.NOTE {
                texte_avant_erreur := texte_ligne
                texte_avant_erreur.taille = numéro_colonne comme z64 - 1

                si texte_avant_erreur {
                    imprime("%", texte_avant_erreur)
                }

                texte_à_surligner := avance(texte_ligne, numéro_colonne comme z64 - 1)
                texte_à_surligner.taille = (numéro_colonne_fin - numéro_colonne) comme z64

                imprime("\x1b[1m%%\x1b[00m", couleur, texte_à_surligner)

                texte_restant := avance(texte_ligne, numéro_colonne_fin comme z64 - 1)

                imprimeln("%", texte_restant)
            }
            sinon {
                imprimeln("%", texte_ligne)
            }

            pour largeur_goutière {
                imprime(" ")
            }
            imprime("| ")

            si type != TypeDiagnostique.NOTE {
                pour numéro_colonne - 1 {
                    si texte_ligne[it] == '\t' {
                        imprime("\t")
                    }
                    sinon {
                        imprime(" ")
                    }
                }
                imprime("\x1b[1m%^", couleur)
                pour numéro_colonne + 1 ... numéro_colonne_fin - 1 {
                    imprime("~")
                }
            }
            imprime("\x1b[00m\n")
        }
        sinon {
            imprime("\x1b[1m%% : \x1b[00m", couleur, intitulé)
            imprimeln(format, ...args)
        }
    }
    sinon {
        imprime("\x1b[1m%% : \x1b[00m", couleur, intitulé)
        imprimeln(format, ...args)
    }

    si type != TypeDiagnostique.NOTE {
        exit(1)
    }
} @Imprimeuse

/** \} */
