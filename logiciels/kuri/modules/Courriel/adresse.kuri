importe AlÃ©a
importe Alphabet
importe Fondation

/* ReprÃ©sentation d'une adresse courriel. Contient la chaine originelle, et ses composants de nom et d'hÃ´te. */
AdresseCourriel :: struct {
    chn: chaine
    nom: chaine @accessible
    hÃ´te: chaine @accessible
}

est_valide :: fonc (courriel: &AdresseCourriel) -> bool
{
    retourne courriel.chn != ""
}

/* Fonction auxilliaire pour parser un courriel pour les FonctionParsages du module Introspection. */
parse_courriel_pour_info_type :: fonc (chn: chaine) -> bool, AdresseCourriel
{
    courriel := parse_adresse_courriel(copie_chaine(chn))
    retourne courriel.est_valide(), courriel
} @ParsageURL @ParsageJSON

imprime_adresse_courriel :: fonc (enchaineuse: *Enchaineuse, adresse: *AdresseCourriel)
{
    si adresse {
        ajoute_au_tampon(enchaineuse, adresse.nom, "@", adresse.hÃ´te)
    }
} @FormattageImpression

// -----------------------------------------------------

gÃ©nÃ¨re_adresse_courriel_alÃ©atoire :: fonc (gna: *GNA, alphabet: &Alphabet.Alphabet) -> AdresseCourriel
{
    // Ã€ FAIRE: 256 pour la part locale
    // Ã€ FAIRE: forward path @domaine1@domaine2:nom_utilisateur@domaine_final
    nom := chaine_alÃ©atoire(gna, alphabet, 1, 64)
    // Ã€ FAIRE: domaine alÃ©atoire: domaine valide, IPv4, ou IPv6
    hÃ´te := chaine_alÃ©atoire(gna, alphabet, 1, 64)
    adresse := enchaine(nom, "@", hÃ´te)

    courriel : AdresseCourriel = ---
    courriel.chn = adresse
    courriel.nom = nom
    courriel.hÃ´te = adresse
    retourne courriel
}

gÃ©nÃ¨re_adresse_courriel_alÃ©atoire :: fonc (gÃ©nÃ©ratrice: &GÃ©nÃ©ratriceDonnÃ©esAlÃ©atoire) -> AdresseCourriel
{
    alphabet := crÃ©e_alphabet_ascii_courriel()
    diffÃ¨re dÃ©truit_alphabet(alphabet)
    retourne gÃ©nÃ¨re_adresse_courriel_alÃ©atoire(gÃ©nÃ©ratrice.gna, alphabet)
}

rappel_gÃ©nÃ¨re_adresse_courriel_alÃ©atoire :: fonc (gÃ©nÃ©ratrice: &GÃ©nÃ©ratriceDonnÃ©esAlÃ©atoire, ptr: *AdresseCourriel)
{
    adresse := gÃ©nÃ¨re_adresse_courriel_alÃ©atoire(gÃ©nÃ©ratrice)
    mÃ©moire(ptr) = adresse
} @FonctionGNA

// -----------------------------------------------------
// Parsage.

DrapeauxCaractÃ¨res :: Ã©num_drapeau {
    EST_AROBASE
    EST_SÃ‰PARATEUR_RELAI // , ou :
    EST_SÃ‰PARATEUR_ATOME // . ou @
    EST_POINT
    EST_CARACTÃˆRE_LOCAL_VALIDE
    EST_CARACTÃˆRE_SPÃ‰CIAL
    EST_GUILLEMET
    EST_Ã‰CHAPPEMENT
    EST_CROCHET_OUVRANT
    EST_CROCHET_FERMANT

    PEUT_ÃŠTRE_DANS_LABEL
    PEUT_COMMENCER_OU_TERMINER_LABEL
}

ParseAdresseCourriel :: Ã©num {
    /* Parse l'adresse courriel selon les diffÃ©rentes RFC, les deux RFC principalement
     * utilisÃ©es ici sont RFC5321 et RFC5322. */
    SelonRFC
    /* Parse l'adresse courriel selon la spÃ©cification HTML de WHATWG :
     * https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address */
    SelonHTML5
}

// Ã€ FAIRE : valeur globale
construit_table_caractÃ¨res :: fonc () -> [256]DrapeauxCaractÃ¨res
{
    table_caractÃ¨res: [256]DrapeauxCaractÃ¨res

    /* Selon RFC5322, section 3.2.3
     * https://datatracker.ietf.org/doc/html/rfc5322.html#section-3.2.3
     */

    pour "abcdefghijklmnopqrstuvwxyz" {
        table_caractÃ¨res[it comme n8].EST_CARACTÃˆRE_LOCAL_VALIDE = vrai
        table_caractÃ¨res[it comme n8].PEUT_COMMENCER_OU_TERMINER_LABEL = vrai
        table_caractÃ¨res[it comme n8].PEUT_ÃŠTRE_DANS_LABEL = vrai
    }

    pour "ABCDEFGHIJKLMNOPQRSTUVWXYZ" {
        table_caractÃ¨res[it comme n8].EST_CARACTÃˆRE_LOCAL_VALIDE = vrai
        table_caractÃ¨res[it comme n8].PEUT_COMMENCER_OU_TERMINER_LABEL = vrai
        table_caractÃ¨res[it comme n8].PEUT_ÃŠTRE_DANS_LABEL = vrai
    }

    pour "0123456789" {
        table_caractÃ¨res[it comme n8].EST_CARACTÃˆRE_LOCAL_VALIDE = vrai
        table_caractÃ¨res[it comme n8].PEUT_COMMENCER_OU_TERMINER_LABEL = vrai
        table_caractÃ¨res[it comme n8].PEUT_ÃŠTRE_DANS_LABEL = vrai
    }

    pour "!#$%&'*+-/=?^_`{|}~" {
        table_caractÃ¨res[it comme n8].EST_CARACTÃˆRE_LOCAL_VALIDE = vrai
    }

    pour "()<>[..]:;@\\,.\"" {
        table_caractÃ¨res[it comme n8].EST_CARACTÃˆRE_SPÃ‰CIAL = vrai
    }

    table_caractÃ¨res['-'].PEUT_ÃŠTRE_DANS_LABEL = vrai
    table_caractÃ¨res['@'].EST_AROBASE = vrai
    table_caractÃ¨res['.'].EST_POINT = vrai
    table_caractÃ¨res[','].EST_SÃ‰PARATEUR_RELAI = vrai
    table_caractÃ¨res[':'].EST_SÃ‰PARATEUR_RELAI = vrai
    table_caractÃ¨res['['].EST_CROCHET_OUVRANT = vrai
    table_caractÃ¨res[']'].EST_CROCHET_FERMANT = vrai
    table_caractÃ¨res['"'].EST_GUILLEMET = vrai
    table_caractÃ¨res['\\'].EST_Ã‰CHAPPEMENT = vrai
    table_caractÃ¨res['@'].EST_SÃ‰PARATEUR_ATOME = vrai
    table_caractÃ¨res['.'].EST_SÃ‰PARATEUR_ATOME = vrai

    retourne table_caractÃ¨res
}

ParseuseAdresseCourriel :: struct {
    empl base: ParseuseChaine

    table_caractÃ¨res: [256]DrapeauxCaractÃ¨res

    part_locale: chaine
    part_domaine: chaine

    drapeaux_part_locale: DrapeauxCaractÃ¨res
    drapeaux_part_domaine: DrapeauxCaractÃ¨res
}

drapeau_pour_caractÃ¨re :: fonc (parseuse: *ParseuseAdresseCourriel, c: z8) -> DrapeauxCaractÃ¨res #enligne
{
    retourne parseuse.table_caractÃ¨res[c comme n8]
}

parse_adresse_courriel :: fonc (texte: chaine, mÃ©thode := ParseAdresseCourriel.SelonRFC) -> AdresseCourriel
{
    discr mÃ©thode {
        SelonRFC {
            retourne parse_adresse_courriel_selon_rfc(texte)
        }
        SelonHTML5 {
            retourne parse_adresse_courriel_selon_html(texte)
        }
        sinon {
            retourne AdresseCourriel()
        }
    }
}

parse_adresse_courriel_selon_html :: fonc (texte: chaine) -> AdresseCourriel
{
    saufsi texte {
        retourne AdresseCourriel()
    }

    parseuse: ParseuseAdresseCourriel
    parseuse.chn = texte
    parseuse.table_caractÃ¨res = construit_table_caractÃ¨res()

    saufsi parse_part_locale_html(*parseuse) {
        retourne AdresseCourriel()
    }

    saufsi apparie(*parseuse, '@') {
        retourne AdresseCourriel()
    }
    avance(*parseuse, 1)

    saufsi parse_part_domaine_html(*parseuse) {
        retourne AdresseCourriel()
    }

    adresse: AdresseCourriel
    adresse.chn = texte
    adresse.nom = parseuse.part_locale
    adresse.hÃ´te = parseuse.part_domaine
    retourne adresse
}

parse_adresse_courriel_selon_rfc :: fonc (texte: chaine) -> AdresseCourriel
{
    saufsi texte {
        retourne AdresseCourriel()
    }

    parseuse: ParseuseAdresseCourriel
    parseuse.chn = texte
    parseuse.table_caractÃ¨res = construit_table_caractÃ¨res()

    c := caractÃ¨re_courant(*parseuse)
    si c == '@' {
        parse_relais(*parseuse)
    }

    parse_commentaire_au_besoin(*parseuse)

    saufsi parse_part_locale(*parseuse) {
        retourne AdresseCourriel()
    }

    saufsi apparie(*parseuse, '@') {
        retourne AdresseCourriel()
    }
    avance(*parseuse, 1)

    saufsi parse_part_domaine(*parseuse) {
        retourne AdresseCourriel()
    }

    parse_commentaire_au_besoin(*parseuse)

    adresse: AdresseCourriel
    adresse.chn = texte
    adresse.nom = parseuse.part_locale
    adresse.hÃ´te = parseuse.part_domaine
    retourne adresse
}

parse_relais :: fonc (parseuse: *ParseuseAdresseCourriel)
{
    tantque !parseuse.fini() {
        c := parseuse.caractÃ¨re_courant()
        drapeau := parseuse.drapeau_pour_caractÃ¨re(c)

        si drapeau.EST_SÃ‰PARATEUR_RELAI {
            si c == ':' {
                parseuse.avance(1)
                retourne
            }
        }

        parseuse.avance(1)
    }
}

parse_commentaire_au_besoin :: fonc (parseuse: *ParseuseAdresseCourriel)
{
    si parseuse.fini() {
        retourne
    }

    c := parseuse.caractÃ¨re_courant()
    si c != '(' {
        retourne
    }

    parseuse.avance(1)
    tantque !parseuse.fini() {
        c = parseuse.caractÃ¨re_courant()
        parseuse.avance(1)

        si c == ')' {
            retourne
        }
    }
}

parse_part_locale :: fonc (parseuse: *ParseuseAdresseCourriel) -> bool
{
    position : z64 = parseuse.curseur
    taille_part_locale : z64 = 0

    diffÃ¨re {
        parseuse.part_locale.pointeur = parseuse.chn.pointeur + position
        parseuse.part_locale.taille = taille_part_locale
    }

    tantque !parseuse.fini() {
        c := parseuse.caractÃ¨re_courant()
        drapeau := parseuse.drapeau_pour_caractÃ¨re(c)

        si drapeau.EST_SÃ‰PARATEUR_ATOME {
            si taille_part_locale == 0 {
                retourne faux
            }

            si c == '@' {
                retourne vrai
            }

            parseuse.avance(1)

            taille_atome := parseuse.parse_atome()
            si taille_atome == 0 {
                retourne faux
            }

            taille_part_locale += taille_atome + 1
        }
        sinon si drapeau.EST_GUILLEMET {
            taille_atome := parseuse.parse_atome()
            si taille_atome == 0 {
                retourne faux
            }

            taille_part_locale += taille_atome
        }
        sinon si drapeau.EST_CARACTÃˆRE_LOCAL_VALIDE {
            parseuse.avance(1)
            taille_part_locale += 1
        }
        sinon {
            retourne faux
        }
    }

    /* Nous devons avoir trouvÃ© un arobase. */
    retourne faux
}

parse_atome :: fonc (parseuse: *ParseuseAdresseCourriel) -> z64
{
    si parseuse.fini() {
        retourne 0
    }

    taille_atome := 0

    c := parseuse.caractÃ¨re_courant()
    si c == '"' {
        taille_atome += 1
        parseuse.avance(1)

        tantque !parseuse.fini() {
            c = parseuse.caractÃ¨re_courant()

            si c == '\\' {
                taille_atome += 2
                parseuse.avance(2)
                continue
            }

            taille_atome += 1
            parseuse.avance(1)

            si c == '"' {
                arrÃªte
            }
        }

        si parseuse.fini() {
            retourne 0
        }

        c = parseuse.caractÃ¨re_courant()
        drapeau := parseuse.drapeau_pour_caractÃ¨re(c)

        saufsi drapeau.EST_SÃ‰PARATEUR_ATOME {
            retourne 0
        }

        retourne taille_atome
    }

    tantque !parseuse.fini() {
        c = parseuse.caractÃ¨re_courant()
        drapeau := parseuse.drapeau_pour_caractÃ¨re(c)

        si drapeau.EST_SÃ‰PARATEUR_ATOME {
            /* Laisse la fonction appelante dÃ©terminer ce que nous avons. */
            arrÃªte
        }

        saufsi drapeau.EST_CARACTÃˆRE_LOCAL_VALIDE {
            retourne 0
        }

        taille_atome += 1
        parseuse.avance(1)
    }

    retourne taille_atome
}

parse_part_domaine :: fonc (parseuse: *ParseuseAdresseCourriel) -> bool
{
    position : z64 = parseuse.curseur
    taille_domaine : z64 = 0

    diffÃ¨re {
        parseuse.part_domaine.pointeur = parseuse.chn.pointeur + position
        parseuse.part_domaine.taille = taille_domaine
    }

    tantque !parseuse.fini() {
        c := parseuse.caractÃ¨re_courant()

        si c == '@' {
            retourne faux
        }

        si c == '(' {
            retourne vrai
        }

        taille_domaine += 1
        parseuse.avance(1)
    }

    retourne taille_domaine != 0
}

parse_part_locale_html :: fonc (parseuse: *ParseuseAdresseCourriel) -> bool
{
    position : z64 = parseuse.curseur
    taille_part_locale : z64 = 0

    diffÃ¨re {
        parseuse.part_locale.pointeur = parseuse.chn.pointeur + position
        parseuse.part_locale.taille = taille_part_locale
    }

    tantque !parseuse.fini() {
        c := parseuse.caractÃ¨re_courant()
        drapeau := parseuse.drapeau_pour_caractÃ¨re(c)

        si drapeau.EST_AROBASE {
            retourne vrai
        }

        si drapeau.EST_CARACTÃˆRE_LOCAL_VALIDE || drapeau.EST_POINT {
            parseuse.avance(1)
            taille_part_locale += 1
        }
        sinon {
            retourne faux
        }
    }

    /* Nous devons avoir trouvÃ© un arobase. */
    retourne faux
}

parse_part_domaine_html :: fonc (parseuse: *ParseuseAdresseCourriel) -> bool
{
    position : z64 = parseuse.curseur
    taille_domaine : z64 = 0

    // Les labels sont limitÃ©s Ã  une taille de 63 octets.
    // https://tools.ietf.org/html/rfc1034#section-3.5
    TAILLE_MAX_LABEL :: 63
    taille_label := 0

    tantque !parseuse.fini() {
        c := parseuse.caractÃ¨re_courant()
        drapeau := parseuse.drapeau_pour_caractÃ¨re(c)

        si drapeau.EST_POINT {
            /* Une taille label de zÃ©ro veut dire que nous avons un point au dÃ©but, ou plusieurs points Ã  la suite. */
            si taille_label > TAILLE_MAX_LABEL || taille_label == 0 {
                retourne faux
            }

            taille_label = 0
            taille_domaine += 1
            parseuse.avance(1)
            continue
        }

        saufsi drapeau.PEUT_ÃŠTRE_DANS_LABEL {
            retourne faux
        }

        taille_label += 1
        taille_domaine += 1
        parseuse.avance(1)
    }

    /* Une taille label de zÃ©ro veut dire que nous avons un point Ã  la fin. */
    si taille_label > TAILLE_MAX_LABEL || taille_label == 0 {
        retourne faux
    }

    parseuse.part_domaine.pointeur = parseuse.chn.pointeur + position
    parseuse.part_domaine.taille = taille_domaine
    retourne taille_domaine != 0
}

// --------------------------------------------

test_adresse_email_valide :: fonc (texte: chaine, part_locale: chaine, part_domaine: chaine)
{
    adresse := parse_adresse_courriel(texte)

    saufsi adresse.est_valide() {
        imprime("ERREUR ! L'ADRESSE DOIT ÃŠTRE VALIDE : %\n", texte)
        retourne
    }

    si adresse.nom != part_locale {
        imprime("ERREUR ! DIFFÃ‰RENCE DE PARTS LOCALES : % CONTRE %\n", adresse.nom, part_locale)
        retourne
    }

    si adresse.hÃ´te != part_domaine {
        imprime("ERREUR ! DIFFÃ‰RENCE DE PARTS DOMAINES : % CONTRE %\n", adresse.hÃ´te, part_domaine)
        retourne
    }
}

test_adresse_email_invalide :: fonc (texte: chaine)
{
    adresse := parse_adresse_courriel(texte)

    si adresse.est_valide() {
        imprime("ERREUR ! L'ADRESSE NE DOIT PAS ÃŠTRE VALIDE : %\n", texte)
        retourne
    }
}

tests_validitÃ©_adresses :: fonc ()
{
    // Cas de Â« So you think you can validate email addresses? A journey down RFC5321 Â»
    // https://www.youtube.com/watch?v=xxX81WmXjPg
    // Cas de Â« Your E-Mail Validation Logic is Wrong"
    // https://www.netmeister.org/blog/email.html
    // Cas spÃ©ciaux non pris en compte dans ces tests :
    // - Â«relay.domain!user@domainÂ» l'adresse doit Ãªtre user@domain relayer par relay.domain
    // - Â«user%final.domain@1st.relayÂ» l'adresse doit Ãªtre user@final.domain relayer par 1st.relay
    // Mais ceci sont des formes plus ou moins archaÃ¯ques

    parts_locales_valides : [..]chaine = ["salut", "salut+toi", "sal.ut", Â«"[IPv6:::1]"Â», Â«"ÑĞ°Ğ¹Ñ‚"Â», Â«"ğŸŒ®"Â», Â«"ğŸ’©"Â», Â«"ğŸºğŸ•ºğŸ‰"Â», Â«"josÃ©.arraÃ±oÃ§a"Â», "~", "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", "#$%!^/&", "f*ck", "stavros", Â«"hi@you"Â», Â«"hi you"Â», Â«"<>"Â», Â«" "Â», Â«".jdoe"Â», Â«"jdoe."Â», Â«"jd..oe"Â», Â«hi."@".youÂ», Â«"<\\"@\\\\".!.#%$Â», "æˆ‘è²·", "1", "'*+-/=?^_`{|}~#$"]
    parts_domaines_valides : [..]chaine = ["stavros.io", "[dead::beef]", "[IPv6:::1]", "[IPv6:2001:470:30:84:e276:63ff:fe72:3900]", "[166.84.7.99]", "tt", "ws", "ai", "io", "å±‹ä¼.é¦™æ¸¯", "[23456789]", "gtfcy37qyzor7kb6blz2buwuu5u7qjkycasjdf3yaslibkbyhsxub4yd.onion", "xn--ls8h.la", Â«ğŸ’©.laÂ», Â«iâ¤ï¸tacos.wsÂ», Â«Ø´Ø¨ÙƒØ©Ù…Ø§ÙŠØ³ØªØ±..Ø´Ø¨ÙƒØ©Â»]

    parts_locales_invalides : [..]chaine = ["", ".jdoe", "stavros.", "stavros..k", "!#$%&'*(-/=?", "h(a)i", "ema@il", Â«"<\\"@\\".!#%$Â», Â«<\\"@\\\\".!#%$Â», Â«hi"@"youÂ», Â«hi\\ thereÂ», "<>"]

    // Pour les domaines, nous devrons peut-Ãªtre savoir si le domaine peut-Ãªtre rÃ©solus, mais c'est possible qu'il ne soit pas encore enregistrÃ©...
    // Un domaine tel que 23456789 ne drevrait pas Ãªtre valide, mais il est possible qu'un tel TLD soit enregistrÃ© dans le future.
    parts_domaines_invalides : [..]chaine = ["", "il@stavros.io"]

    // commentaires := ["(sta)", "(io)"]

    // Pour les relais, il peuvent Ãªtre arbitrairement long :
    // @qqaazz1122wwssxx33eeddcc44rrffvv55ttggbb66yyhhnn77uujjmm88iikk99ooll00ppQQAAZZ1122WWSSXX33EEDDCC44RRFFVV55TTGGBB66YYHHNN77UUJJMM88IIKK99OOLL00PPQWERTYUIOPASDFGHJKLZXCVBNMpoiuytrewqasdfghjklmnbv.com
    // est valide, pourtant ce devrait Ãªtre un domaine...

    ctx_kuri := initialise_contexte_kuri()
    gna := crÃ©e_gna(*ctx_kuri, 123)

    /* Test des adresses valides */
    pour 2000 {
        part_locale := gna.choisit(parts_locales_valides)
        part_domaine := gna.choisit(parts_domaines_valides)

        adresse := enchaine(part_locale, "@", part_domaine)
        diffÃ¨re dÃ©loge(adresse)

        test_adresse_email_valide(adresse, part_locale, part_domaine)
    }

    /* Test des adresses invalides. */

    /* Locale et domaine invalides. */
    pour 2000 {
        part_locale := gna.choisit(parts_locales_invalides)
        part_domaine := gna.choisit(parts_domaines_invalides)

        adresse := enchaine(part_locale, "@", part_domaine)
        diffÃ¨re dÃ©loge(adresse)

        test_adresse_email_invalide(adresse)
    }

    /* Locale valide, domaine invalide. */
    pour 2000 {
        part_locale := gna.choisit(parts_locales_valides)
        part_domaine := gna.choisit(parts_domaines_invalides)

        adresse := enchaine(part_locale, "@", part_domaine)
        diffÃ¨re dÃ©loge(adresse)

        test_adresse_email_invalide(adresse)
    }

    /* Locale invalide, domaine valide. */
    pour 2000 {
        part_locale := gna.choisit(parts_locales_invalides)
        part_domaine := gna.choisit(parts_domaines_valides)

        adresse := enchaine(part_locale, "@", part_domaine)
        diffÃ¨re dÃ©loge(adresse)

        test_adresse_email_invalide(adresse)
    }
}
