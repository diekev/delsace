importe CodecDonnées
importe Fondation
importe GlibC
importe SysFichier

Courriel :: struct {
    message: chaine
    expéditeur: chaine
    destinataires: []chaine
    destinataires_cc: []chaine
}

détruit_courriel :: fonc (courriel: *Courriel) -> rien
{
    déloge courriel.destinataires
    déloge courriel.destinataires_cc
}

ajoute_destinataire :: fonc (courriel: *Courriel, destinataire: chaine) -> rien
{
    tableau_ajoute(@courriel.destinataires, destinataire)
}

ajoute_destinataire_cc :: fonc (courriel: *Courriel, destinataire: chaine) -> rien
{
    tableau_ajoute(@courriel.destinataires_cc, destinataire)
}

ConfigurationCourriel :: struct {
    serveur : chaine
    port : n16 = 25 // 465 pour ssl
    utilise_ssl := faux
    utilisateur : chaine
    mot_de_passe : chaine
}

envoie_commande_smtp :: fonc (fichier: *Fichier, format: chaine, args: ...eini) -> z32
{
    message := ""
    diffère { si message { déloge message } }

    si format {
        message = imprime_chaine(format, ...args)
        pousse(@message, '\r')
        pousse(@message, '\n')
    }

    taille_écrite := tente fichier.écris(message) piège err {
        retourne 0
    }

    imprime("requête: %", message)

    si taille_écrite == -1 {
        imprime("impossible d'envoyer la requête !\n")
        retourne 0
    }

    réponse := tente lis_tout(fichier) piège err {
        imprime("impossible de lire la réponse !\n")
        retourne 0
    }

    imprime("réponse: %\n", réponse)
    diffère { déloge réponse }

    si réponse.taille < 3 {
        retourne 0
    }

    status := extrait_nombre_entier(réponse.sous_chaine(0, 3))
    retourne status comme z32
}

// https://tools.ietf.org/html/rfc5322
crée_corps_message :: fonc (courriel: Courriel) -> chaine
{
    enchaineuse : Enchaineuse
    initialise_enchaineuse(@enchaineuse)
    diffère { détruit_tampons(@enchaineuse) }

    ajoute_au_tampon(@enchaineuse, "User-Agent: courriel_kuri\r\n")
    // Date: Tue, 15 Jan 2008 16:02:43 -0500
    //ajoute_au_tampon(@enchaineuse, "Date: ")

    imprime_dans_enchaineuse(@enchaineuse, "From:<%>\r\n", courriel.expéditeur)

    ajoute_au_tampon(@enchaineuse, "To:")
    virgule := "<"

    pour courriel.destinataires {
        ajoute_au_tampon(@enchaineuse, virgule)
        ajoute_au_tampon(@enchaineuse, it)
        virgule = ">,<"
    }

    ajoute_au_tampon(@enchaineuse, ">\r\n")

    ajoute_au_tampon(@enchaineuse, "Cc:")
    virgule = "<"

    pour courriel.destinataires_cc {
        ajoute_au_tampon(@enchaineuse, virgule)
        ajoute_au_tampon(@enchaineuse, it)
        virgule = ">,<"
    }

    ajoute_au_tampon(@enchaineuse, ">\r\n")

    ajoute_au_tampon(@enchaineuse, "Subject: Test envoie message\r\n")
    ajoute_au_tampon(@enchaineuse, "\r\n")
    ajoute_au_tampon(@enchaineuse, courriel.message)
    ajoute_au_tampon(@enchaineuse, "\r\n.")

    retourne chaine_depuis_enchaineuse(@enchaineuse)
}

ErreurConnexion :: erreur {
    RésolutionHôteImpossible
    CréationPriseImpossible
    ConnexionPriseImpossible
}

FichierOuErreur :: union {
    e: ErreurConnexion
    f: Fichier
}

ouvre_connexion_serveur :: fonc (config: ConfigurationCourriel) -> FichierOuErreur
{
    ptr_tampon := chaine_c_temp(config.serveur)
    he := gethostbyname(ptr_tampon)

    si he == nul {
        retourne ErreurConnexion.RésolutionHôteImpossible
    }

    prise := socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)

    si prise == -1 {
        retourne ErreurConnexion.CréationPriseImpossible
    }

    their_addr : sockaddr_in
    their_addr.sin_family = AF_INET comme n16
    their_addr.sin_port = htons(config.port)
    their_addr.sin_zero[0] = 0
    their_addr.sin_zero[1] = 0
    their_addr.sin_zero[2] = 0
    their_addr.sin_zero[3] = 0
    their_addr.sin_zero[4] = 0
    their_addr.sin_zero[5] = 0
    their_addr.sin_zero[6] = 0
    their_addr.sin_zero[7] = 0

    x := he.h_addr_list[0]
    their_addr.sin_addr = mémoire(x comme *in_addr)

	si connect(prise, (@their_addr) comme *sockaddr, taille_de(sockaddr) comme z64) == -1 {
        retourne ErreurConnexion.ConnexionPriseImpossible
    }

    linger_option := linger(l_onoff = -1, l_linger = 2)
    _ := setsockopt(prise, SOL_SOCKET, SO_LINGER, @linger_option, taille_de(linger))

    retourne Fichier(desc = prise)
}

CodeRéussite :: énum {
    Message :: 200
	RéponseCommdeHelp :: 214
    ServeurPrêt :: 220
	FermetureCanalTransmission :: 221
    ActionRequiseComplétée :: 250
    UtilisationNonLocaleDevraProjeté :: 251
    NePeutVérifierUtilisateurMaisDélivreraQuandMême :: 252
}

ErreurServeur :: erreur {
    ClientNeFutPasAuthentifié :: 530
}

envoie_courriel :: fonc (config: ConfigurationCourriel, courriel: Courriel) -> z32
{
    fichier := tente ouvre_connexion_serveur(config) piège err {
        discr err {
            RésolutionHôteImpossible {
                imprime("Impossible de résoudre l'hôte selon le nom !\n")
            }
            CréationPriseImpossible {
                imprime("Impossible de créer une prise !\n")
            }
            ConnexionPriseImpossible {
                imprime("Impossible de se connecter à la prise !\n")
            }
        }

        retourne 1
    }

    diffère {
        _ := tente ferme(@fichier) piège nonatteignable
    }

    // 220 ok
    si envoie_commande_smtp(@fichier, "") == 0 {
        retourne 1
    }

    // 250 ok
    si envoie_commande_smtp(@fichier, "EHLO") == 0 {
        retourne 1
    }

    si envoie_commande_smtp(@fichier, "AUTH LOGIN") == 0 {
        retourne 1
    }

    // réponse : 334 VXNlcm5hbWU6
    nom_utilisateur_base64 := encode_base64(config.utilisateur)
    diffère { déloge nom_utilisateur_base64 }
    si envoie_commande_smtp(@fichier, "%", nom_utilisateur_base64) == 0 {
        retourne 1
    }

    // réponse : 334 UGFzc3dvcmQ6
    mot_passe_base64 := encode_base64(config.mot_de_passe)
    diffère { déloge mot_passe_base64 }
    si envoie_commande_smtp(@fichier, "%", mot_passe_base64) == 0 {
        retourne 1
    }
    // 235 2.7.0 Authentication successful

    // 530 5.7.1 Client was not authenticated
    // 250 2.1.0 Ok
    si envoie_commande_smtp(@fichier, "MAIL FROM:<%>", courriel.expéditeur) == 0 {
        retourne 1
    }

    // 530 5.7.1 Client was not authenticated
    // 250 2.1.0 Ok
    pour courriel.destinataires {
        si envoie_commande_smtp(@fichier, "RCPT TO:<%>", it) == 0 {
            retourne 1
        }
    }

    pour courriel.destinataires_cc {
        si envoie_commande_smtp(@fichier, "RCPT TO:<%>", it) == 0 {
            retourne 1
        }
    }

    // 503 Bad sequence of commands
    // 354 End data with <CR><LF>.<CR><LF>
    si envoie_commande_smtp(@fichier, "DATA") == 0 {
        retourne 1
    }

    // 530 5.7.1 Client was not authenticated
    // 250 2.0.0 Ok: queued as ...
    message := crée_corps_message(courriel)
    diffère { déloge message }
    si envoie_commande_smtp(@fichier, "%", message) == 0 {
        retourne 1
    }

    si envoie_commande_smtp(@fichier, "QUIT") == 0 {
        retourne 1
    }

    retourne 0
}
