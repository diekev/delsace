importe CodecDonnées
importe Fondation
importe GlibC
importe Réseau
importe SysFichier

/* Module d'envoie de courriel.
 *
 * Exemple d'utilisation :
 *
 * config : ConfigurationCourriel
 * config.serveur = "adresse.serveur.domaine"
 * config.utilisateur = "utilisateur@courri.el"
 * config.mot_de_passe = "Mot!DeP#s53"
 *
 * courriel : Courriel
 * diffère { détruit_courriel(@courriel) }
 *
 * courriel.expéditeur = "expéditeur@courri.el"
 * courriel.message = "Le Message"
 *
 * ajoute_destinataire(@courriel, "destinataire@courri.el")
 * ajoute_destinataire_cc(@courriel, "detinataire.cc@courri.el")
 *
 * retourne envoie_courriel(config, courriel)
 */

Courriel :: struct {
    message: chaine
    expéditeur: chaine
    destinataires: []chaine
    destinataires_cc: []chaine
}

détruit_courriel :: fonc (courriel: *Courriel) -> rien
{
    déloge courriel.destinataires
    déloge courriel.destinataires_cc
}

ajoute_destinataire :: fonc (courriel: *Courriel, destinataire: chaine) -> rien
{
    tableau_ajoute(*courriel.destinataires, destinataire)
}

ajoute_destinataire_cc :: fonc (courriel: *Courriel, destinataire: chaine) -> rien
{
    tableau_ajoute(*courriel.destinataires_cc, destinataire)
}

ConfigurationCourriel :: struct {
    serveur : chaine
    port : n16 = 25 // 465 pour ssl
    utilise_ssl := faux
    utilisateur : chaine
    mot_de_passe : chaine
}

envoie_commande_smtp :: fonc (fichier: *Fichier, format: chaine, args: ...eini) -> z32
{
    message := ""
    diffère { si message { déloge message } }

    si format {
        message = imprime_chaine(format, ...args)
       chaine_ajoute(*message, '\r')
       chaine_ajoute(*message, '\n')
    }

    taille_écrite := tente fichier.écris(message) piège err {
        retourne 0
    }

    imprime("requête: %", message)

    si taille_écrite == -1 {
        imprime("impossible d'envoyer la requête !\n")
        retourne 0
    }

    réponse := tente lis_tout(fichier) piège err {
        imprime("impossible de lire la réponse !\n")
        retourne 0
    }

    imprime("réponse: %\n", réponse)
    diffère { déloge réponse }

    si réponse.taille < 3 {
        retourne 0
    }

    status := extrait_nombre_entier(réponse.sous_chaine(0, 3))
    retourne status comme z32
}

// https://tools.ietf.org/html/rfc5322
crée_corps_message :: fonc (courriel: Courriel) -> chaine
{
    enchaineuse : Enchaineuse
    initialise_enchaineuse(*enchaineuse)
    diffère { détruit_tampons(*enchaineuse) }

    ajoute_au_tampon(*enchaineuse, "User-Agent: courriel_kuri\r\n")
    // Date: Tue, 15 Jan 2008 16:02:43 -0500
    //ajoute_au_tampon(@enchaineuse, "Date: ")

    imprime_dans_enchaineuse(*enchaineuse, "From:<%>\r\n", courriel.expéditeur)

    ajoute_au_tampon(*enchaineuse, "To:")
    virgule := "<"

    pour courriel.destinataires {
        ajoute_au_tampon(*enchaineuse, virgule)
        ajoute_au_tampon(*enchaineuse, it)
        virgule = ">,<"
    }

    ajoute_au_tampon(*enchaineuse, ">\r\n")

    ajoute_au_tampon(*enchaineuse, "Cc:")
    virgule = "<"

    pour courriel.destinataires_cc {
        ajoute_au_tampon(*enchaineuse, virgule)
        ajoute_au_tampon(*enchaineuse, it)
        virgule = ">,<"
    }

    ajoute_au_tampon(*enchaineuse, ">\r\n")

    ajoute_au_tampon(*enchaineuse, "Subject: Test envoie message\r\n")
    ajoute_au_tampon(*enchaineuse, "\r\n")
    ajoute_au_tampon(*enchaineuse, courriel.message)
    ajoute_au_tampon(*enchaineuse, "\r\n.")

    retourne chaine_depuis_enchaineuse(*enchaineuse)
}

ouvre_connexion_serveur :: fonc (config: ConfigurationCourriel) -> FichierOuErreur
{
    fichier := tente ouvre_connexion_serveur(config.serveur, config.port) piège err {
        retourne err
    }

    linger_option := linger(l_onoff = -1, l_linger = 2)
    _ := setsockopt(fichier.desc, SOL_SOCKET, SO_LINGER, *linger_option, taille_de(linger))

    retourne fichier
}

CodeRéussite :: énum {
    Message :: 200
	RéponseCommdeHelp :: 214
    ServeurPrêt :: 220
	FermetureCanalTransmission :: 221
    ActionRequiseComplétée :: 250
    UtilisationNonLocaleDevraProjeté :: 251
    NePeutVérifierUtilisateurMaisDélivreraQuandMême :: 252
}

ErreurServeur :: erreur {
    ClientNeFutPasAuthentifié :: 530
}

envoie_courriel :: fonc (config: ConfigurationCourriel, courriel: Courriel) -> z32
{
    fichier := tente ouvre_connexion_serveur(config) piège err {
        discr err {
            RésolutionHôteImpossible {
                imprime("Impossible de résoudre l'hôte selon le nom !\n")
            }
            CréationPriseImpossible {
                imprime("Impossible de créer une prise !\n")
            }
            ConnexionPriseImpossible {
                imprime("Impossible de se connecter à la prise !\n")
            }
            sinon {
                imprime("Erreur inattendue : %\n", err)
            }
        }

        retourne 1
    }

    diffère {
        _ := tente ferme(*fichier) piège nonatteignable
    }

    // 220 ok
    si envoie_commande_smtp(*fichier, "") == 0 {
        retourne 1
    }

    // 250 ok
    si envoie_commande_smtp(*fichier, "EHLO") == 0 {
        retourne 1
    }

    si envoie_commande_smtp(*fichier, "AUTH LOGIN") == 0 {
        retourne 1
    }

    // réponse : 334 VXNlcm5hbWU6
    nom_utilisateur_base64 := encode_base64(config.utilisateur)
    diffère { déloge nom_utilisateur_base64 }
    si envoie_commande_smtp(*fichier, "%", nom_utilisateur_base64) == 0 {
        retourne 1
    }

    // réponse : 334 UGFzc3dvcmQ6
    mot_passe_base64 := encode_base64(config.mot_de_passe)
    diffère { déloge mot_passe_base64 }
    si envoie_commande_smtp(*fichier, "%", mot_passe_base64) == 0 {
        retourne 1
    }
    // 235 2.7.0 Authentication successful

    // 530 5.7.1 Client was not authenticated
    // 250 2.1.0 Ok
    si envoie_commande_smtp(*fichier, "MAIL FROM:<%>", courriel.expéditeur) == 0 {
        retourne 1
    }

    // 530 5.7.1 Client was not authenticated
    // 250 2.1.0 Ok
    pour courriel.destinataires {
        si envoie_commande_smtp(*fichier, "RCPT TO:<%>", it) == 0 {
            retourne 1
        }
    }

    pour courriel.destinataires_cc {
        si envoie_commande_smtp(*fichier, "RCPT TO:<%>", it) == 0 {
            retourne 1
        }
    }

    // 503 Bad sequence of commands
    // 354 End data with <CR><LF>.<CR><LF>
    si envoie_commande_smtp(*fichier, "DATA") == 0 {
        retourne 1
    }

    // 530 5.7.1 Client was not authenticated
    // 250 2.0.0 Ok: queued as ...
    message := crée_corps_message(courriel)
    diffère { déloge message }
    si envoie_commande_smtp(*fichier, "%", message) == 0 {
        retourne 1
    }

    si envoie_commande_smtp(*fichier, "QUIT") == 0 {
        retourne 1
    }

    retourne 0
}
