// Interface pour la bibliothèque OpenSSL 1.1

importe GlibC
importe SysFichier

libssl :: #bibliothèque "ssl"
libcrypto :: #bibliothèque "crypto"

#dépendance_bibliothèque libssl libcrypto

//###############################################################################

ssl_method_st :: struct #externe // SSL_METHOD dans l'IPA C
ssl_st :: struct #externe // SSL dans l'IPA C
ssl_ctx_st :: struct #externe // SSL_CTX dans l'IPA C

SSL :: ssl_st
SSL_CTX :: ssl_ctx_st

X509 :: struct #externe
X509_NAME :: struct #externe
X509_REQ :: struct #externe
X509_CRL :: struct #externe
STACK_OF_X509_NAME :: struct #externe // STACK_OF(X509_NAME)
X509_STORE_CTX :: struct #externe

DH :: struct #externe

BIO :: struct #externe
BIO_METHOD :: struct #externe

OPENSSL_INIT_SETTINGS :: struct #externe

OPENSSL_INIT_NO_LOAD_CRYPTO_STRINGS : n64 : 0x00000001
OPENSSL_INIT_LOAD_CRYPTO_STRINGS : n64 : 0x00000002
OPENSSL_INIT_ADD_ALL_CIPHERS : n64 : 0x00000004
OPENSSL_INIT_ADD_ALL_DIGESTS : n64 : 0x00000008

OPENSSL_INIT_NO_LOAD_SSL_STRINGS : n64 : 0x00100000
OPENSSL_INIT_LOAD_SSL_STRINGS    : n64 : 0x00200000

OPENSSL_init_ssl :: fonc (opts: n64, settings: *OPENSSL_INIT_SETTINGS) -> z32 #externe libssl
OPENSSL_init_crypto :: fonc (opts: n64, settings: *OPENSSL_INIT_SETTINGS) -> z32 #externe libssl

// Déprécié, devient un macro
SSL_library_init :: fonc () -> rien #nulctx
{
    _ := OPENSSL_init_ssl(0, nul)
}

// Déprécié, devient un macro
SSL_load_error_strings :: fonc () -> rien #nulctx
{
    _ := OPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS | OPENSSL_INIT_LOAD_CRYPTO_STRINGS, nul)
}

OPENSSL_add_all_algorithms_conf :: fonc () -> rien #externe libssl
OPENSSL_add_all_algorithms_noconf :: fonc () -> rien #nulctx
{
    _ := OPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS | OPENSSL_INIT_ADD_ALL_DIGESTS, nul)
}

TLS_method :: fonc () -> *ssl_method_st #externe libssl
TLS_server_method :: fonc () -> *ssl_method_st #externe libssl
TLS_client_method :: fonc () -> *ssl_method_st #externe libssl

SSL_CTX_new :: fonc (method : *ssl_method_st) -> *SSL_CTX #externe libssl
SSL_new :: fonc (ctx_s : *rien) -> *ssl_st #externe libssl
SSL_set_fd :: fonc (ssl : *ssl_st, prise : z32) -> z32 #externe libssl
SSL_connect :: fonc (ssl : *ssl_st) -> z32 #externe libssl
SSL_free :: fonc (ssl : *ssl_st) -> rien #externe libssl
SSL_get_error :: fonc (ssl : *ssl_st, erreur_ : z32) -> z32 #externe libssl
SSL_write :: fonc (ssl : *ssl_st, ptr : *z8, taille : z32) -> z32 #externe libssl
SSL_read :: fonc (ssl : *ssl_st, tampon : *z8, max : z32) -> z32 #externe libssl
SSL_set_connect_state :: fonc (ssl: *ssl_st) #externe libssl
SSL_set_accept_state :: fonc (ssl: *ssl_st) #externe libssl

SSL_set_bio :: fonc (ssl: *ssl_st, rbio: *BIO, wbio: *BIO) #externe libssl

SSL_MODE_ENABLE_PARTIAL_WRITE :: 0x00000001
SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER :: 0x00000002
SSL_MODE_AUTO_RETRY :: 0x00000004
SSL_MODE_NO_AUTO_CHAIN :: 0x00000008
SSL_MODE_RELEASE_BUFFERS :: 0x00000010

SSL_VERIFY_NONE                 :: 0x00
SSL_VERIFY_PEER                 :: 0x01
SSL_VERIFY_FAIL_IF_NO_PEER_CERT :: 0x02
SSL_VERIFY_CLIENT_ONCE          :: 0x04

TLS1_VERSION    : n16 : 0x0301
TLS1_1_VERSION  : n16 : 0x0302
TLS1_2_VERSION  : n16 : 0x0303
TLS_MAX_VERSION : n16 : TLS1_2_VERSION

pem_password_cb :: #nulctx fonc(*z8, z32, z32, *rien)(z32)

SSL_CTRL_SET_TMP_DH :: 3
SSL_CTRL_MODE :: 33
SSL_CTRL_SET_READ_AHEAD :: 41
SSL_CTRL_SET_MIN_PROTO_VERSION :: 123

SSL_CTX_ctrl :: fonc (ssl: *SSL_CTX, cmd: z32, larg: z64, parg: *rien) -> z64 #externe libssl

// Ceci est un macro en C
SSL_CTX_set_mode :: fonc (ssl: *SSL_CTX, mode: z64) -> z64 #nulctx
{
    retourne SSL_CTX_ctrl(ssl, SSL_CTRL_MODE, mode, nul)
}

// Ceci est un macro en C
SSL_CTX_set_read_ahead :: fonc (ssl: *SSL_CTX, oui_non: z32) -> rien #nulctx
{
    _ := SSL_CTX_ctrl(ssl, SSL_CTRL_SET_READ_AHEAD, oui_non, nul)
}

// Ceci est un macro en C
SSL_CTX_set_min_proto_version :: fonc (ssl: *SSL_CTX, version: n16) -> z64 #nulctx
{
    retourne SSL_CTX_ctrl(ssl, SSL_CTRL_SET_MIN_PROTO_VERSION, version comme z64, nul)
}

// Ceci est un macro en C
SSL_CTX_set_tmp_dh :: fonc (ssl: *SSL_CTX, dh: *DH) -> z64 #nulctx
{
    retourne SSL_CTX_ctrl(ssl, SSL_CTRL_SET_TMP_DH, 0, dh)
}

SSL_CTX_set_default_passwd_cb_userdata :: fonc (ssl: *SSL_CTX, données: *rien) -> rien #externe libssl
SSL_CTX_get_default_passwd_cb_userdata :: fonc (ssl: *SSL_CTX) -> *rien #externe libssl
SSL_CTX_set_default_passwd_cb :: fonc (ssl: *SSL_CTX, rappel : pem_password_cb) -> rien #externe libssl

SSL_CTX_set_cipher_list :: fonc (ssl: *SSL_CTX, control: ChaineC) -> z32 #externe libssl

BIO_TYPE_SOURCE_SINK :: 0x0400

BIO_TYPE_MEM :: (1 | BIO_TYPE_SOURCE_SINK)

BIO_CTRL_FLUSH :: 11

BIO_FLAGS_READ :: 0x01
BIO_FLAGS_WRITE :: 0x02
BIO_FLAGS_IO_SPECIAL :: 0x04
BIO_FLAGS_RWS :: (BIO_FLAGS_READ|BIO_FLAGS_WRITE|BIO_FLAGS_IO_SPECIAL)
BIO_FLAGS_SHOULD_RETRY :: 0x08

BIO_meth_new :: fonc (type: z32, name: ChaineC) -> *BIO_METHOD #externe libssl
BIO_meth_free :: fonc (biom: *BIO_METHOD) -> rien #externe libssl
BIO_meth_set_create :: fonc (bio: *BIO_METHOD, cb: #nulctx fonc(*BIO)(z32)) -> rien #externe libssl
BIO_meth_set_write :: fonc (bio: *BIO_METHOD, cb: #nulctx fonc(*BIO, *octet, z32)(z32)) -> rien #externe libssl
BIO_meth_set_read :: fonc (bio: *BIO_METHOD, cb: #nulctx fonc(*BIO, *octet, z32)(z32)) -> rien #externe libssl
BIO_meth_set_ctrl :: fonc (bio: *BIO_METHOD, cb: #nulctx fonc(*BIO, z32, z64, *rien)(z64)) -> rien #externe libssl

BIO_new :: fonc (type: *BIO_METHOD) -> *BIO #externe libssl
BIO_new_mem_buf :: fonc (buf: *rien, len: z32) -> *BIO #externe libssl
BIO_free :: fonc (a: *BIO) -> z32 #externe libssl
BIO_up_ref :: fonc (a: *BIO) -> z32 #externe libssl
BIO_get_data :: fonc (bio: *BIO) -> *rien #externe libssl
BIO_set_data :: fonc (bio: *BIO, data: *rien) #externe libssl
BIO_set_flags :: fonc (bio: *BIO, flags: z32) #externe libssl
BIO_set_init :: fonc (bio: *BIO, init: z32) #externe libssl

// Macro en C.
BIO_set_retry_read :: fonc (bio: *BIO) #enligne #nulctx
{
    BIO_set_flags(bio, BIO_FLAGS_SHOULD_RETRY | BIO_FLAGS_READ)
}

// Macro en C.
BIO_set_retry_write :: fonc (bio: *BIO) #enligne #nulctx
{
    BIO_set_flags(bio, BIO_FLAGS_SHOULD_RETRY | BIO_FLAGS_WRITE)
}

DH_free :: fonc (dh: *DH) -> rien #externe libssl

PEM_read_bio_DHparams :: fonc (bp: *BIO, x: **DH, cb: pem_password_cb, u: *rien) -> *DH #externe libssl

SSL_CTX_use_certificate_chain_file :: fonc (ctx: *SSL_CTX, file: ChaineC) -> z32 #externe libssl

SSL_load_client_CA_file :: fonc (CApath: ChaineC) -> *STACK_OF_X509_NAME #externe libssl
SSL_CTX_set_client_CA_list :: fonc (contexte_ssl: *SSL_CTX, ca_list: *STACK_OF_X509_NAME) -> rien #externe libssl

SSL_CTX_load_verify_locations :: fonc (ctx: *SSL_CTX, CAfile: ChaineC, CApath: ChaineC) -> z32 #externe libssl

verify_callback_type :: #nulctx fonc (z32, *X509_STORE_CTX)(z32)
SSL_CTX_set_verify :: fonc (ctx: *SSL_CTX, mode: z32, cb: verify_callback_type) -> rien #externe libssl

// ceci est un macro en C
OpenSSL_add_all_algorithms :: fonc () -> rien
{
//#si OPENSSL_LOAD_CONF {
//    OPENSSL_add_all_algorithms_conf()
//}
//#sinon {
    OPENSSL_add_all_algorithms_noconf()
//}
}

// ceci est un macro en C
OpenSSL_add_ssl_algorithms :: fonc ()
{
    SSL_library_init()
}

SSL_ERROR_NONE :: 0
SSL_ERROR_SSL :: 1
SSL_ERROR_WANT_READ :: 2
SSL_ERROR_WANT_WRITE :: 3
SSL_ERROR_WANT_X509_LOOKUP :: 4
SSL_ERROR_SYSCALL :: 5
SSL_ERROR_ZERO_RETURN :: 6
SSL_ERROR_WANT_CONNECT :: 7
SSL_ERROR_WANT_ACCEPT :: 8

SSL_CTX_free :: fonc (ssl: *SSL_CTX) -> rien #externe libssl
SSL_accept :: fonc (ssl: *ssl_st) -> z32 #externe libssl
SSL_get_fd :: fonc (ssl: *ssl_st) -> z32 #externe libssl

SSL_get_peer_certificate :: fonc (ssl: *ssl_st) -> *X509 #externe libssl
X509_free :: fonc (x509: *X509) -> rien #externe libssl

X509_get_subject_name :: fonc (x: *X509) -> *X509_NAME #externe libssl
X509_set_subject_name :: fonc (x: *X509, nom: *X509_NAME) -> z32 #externe libssl

X509_get_issuer_name :: fonc (x: *X509) -> *X509_NAME #externe libssl
X509_set_issuer_name :: fonc (x: *X509, nom: *X509_NAME) -> z32 #externe libssl

X509_REQ_get_subject_name :: fonc (req: *X509_REQ) -> *X509_NAME #externe libssl
X509_REQ_set_subject_name :: fonc (req: *X509_REQ, nom: *X509_NAME) -> z32 #externe libssl

X509_CRL_get_issuer :: fonc (crl: *X509_CRL) -> *X509_NAME #externe libssl
X509_CRL_set_issuer_name :: fonc (crl: *X509_CRL, nom: *X509_NAME) -> z32 #externe libssl

X509_NAME_oneline :: fonc (a: *X509_NAME, buf: *z8, size: z32) -> ChaineC #externe libssl

SSL_CTX_use_certificate_file :: fonc (ctx: *SSL_CTX, CertFile: ChaineC, x: z32) -> z32 #externe libssl
SSL_CTX_use_PrivateKey_file :: fonc (ctx: *SSL_CTX, KeyFile: ChaineC, x: z32) -> z32 #externe libssl
SSL_CTX_check_private_key :: fonc (ctx: *SSL_CTX) -> z32 #externe libssl

X509_FILETYPE_PEM     :: 1
X509_FILETYPE_ASN1    :: 2
X509_FILETYPE_DEFAULT :: 3

SSL_FILETYPE_PEM  :: X509_FILETYPE_PEM
SSL_FILETYPE_ASN1 :: X509_FILETYPE_ASN1

ERR_print_errors_cb :: fonc (cb : fonc(ChaineC,n64,*rien)(z32), u : *rien) -> rien #externe libssl
ERR_clear_error :: fonc () #externe libssl

// ----------------------------------------------------------------------------

importe Fondation
importe SysFichier

ErreurCertificat :: erreur {
    FichierCertificationInvalide
    FichierCléInvalide
    MésappariementClésPubliquePrivée
}

charge_certificats_ssl :: fonc(ctx: *ssl_st, chemin_fichier_certificat: chaine, chemin_fichier_clé: chaine) -> ErreurCertificat
{
    ptr_chemin_certificat := crée_chaine_c(chemin_fichier_certificat)
    diffère détruit_chaine_c(ptr_chemin_certificat)
    si SSL_CTX_use_certificate_file(ctx, ptr_chemin_certificat, SSL_FILETYPE_PEM) <= 0 {
        retourne ErreurCertificat.FichierCertificationInvalide
    }

    ptr_chemin_clé := crée_chaine_c(chemin_fichier_clé)
    diffère détruit_chaine_c(ptr_chemin_clé)
    si SSL_CTX_use_PrivateKey_file(ctx, ptr_chemin_clé, SSL_FILETYPE_PEM) <= 0 {
        retourne ErreurCertificat.FichierCléInvalide
    }

    si SSL_CTX_check_private_key(ctx) == 0 {
        retourne ErreurCertificat.MésappariementClésPubliquePrivée
    }

    retourne 0 comme ErreurCertificat
}

imprime_certificats_ssl :: fonc(ssl: *ssl_st) -> rien
{
    cert := SSL_get_peer_certificate(ssl)

    si cert == nul {
        imprime("Aucun certificats !\n")
        retourne
    }

    imprime("Certificats serveurs :\n")

    line := X509_NAME_oneline(X509_get_subject_name(cert), nul, 0)
    imprime("Sujet :\n%\n", convertis_chaine_c(line))
    free(line comme *z8)

    line = X509_NAME_oneline(X509_get_issuer_name(cert), nul, 0)
    imprime("Émetteur :\n%\n", convertis_chaine_c(line))
    free(line comme *z8)

    X509_free(cert)
}

ErreurInitialisationSSL :: erreur {
    NePeutCréerMéthode
    NePeutCréerContexte
}

ErreurOuContexteSSL :: union {
    c: *ssl_st
    e: ErreurInitialisationSSL
}

initialise_contexte_ssl_client :: fonc () -> ErreurOuContexteSSL
{
    SSL_library_init()
    OpenSSL_add_ssl_algorithms()
    SSL_load_error_strings()

    method := TLS_client_method()

    si method == nul {
        retourne ErreurInitialisationSSL.NePeutCréerMéthode
    }

    ctx := SSL_CTX_new(method)

    si ctx == nul {
        //converti_erreur_ssl(nul, 0)
        retourne ErreurInitialisationSSL.NePeutCréerContexte
    }

    retourne ctx
}

initialise_contexte_ssl_serveur :: fonc () -> ErreurOuContexteSSL
{
    SSL_library_init()
    OpenSSL_add_all_algorithms()
    SSL_load_error_strings()

    method := TLS_server_method()

    si method == nul {
        retourne ErreurInitialisationSSL.NePeutCréerMéthode
    }

    ctx := SSL_CTX_new(method)

    si ctx == nul {
        //converti_erreur_ssl(nul, 0)
        retourne ErreurInitialisationSSL.NePeutCréerContexte
    }

    retourne ctx
}

ErreurSSL :: erreur {
    LectureAttendue
    ÉcritureAttendue
    ConnexionAttendue
    AcceptationAttendue
    RécupérationX509Attendue
    SSL
    Aucune
    RetourneZéro
    AppelSystème
}

converti_erreur_ssl :: fonc (ssl : *ssl_st, code_erreur : z32) -> ErreurSSL
{
    erreur_ssl := SSL_get_error(ssl, code_erreur)

    discr erreur_ssl {
        SSL_ERROR_NONE {
            retourne ErreurSSL.Aucune
        }
        SSL_ERROR_ZERO_RETURN {
            retourne ErreurSSL.RetourneZéro
        }
        SSL_ERROR_WANT_READ {
            retourne ErreurSSL.LectureAttendue
        }
        SSL_ERROR_WANT_WRITE {
            retourne ErreurSSL.ÉcritureAttendue
        }
        SSL_ERROR_WANT_CONNECT {
            retourne ErreurSSL.ConnexionAttendue
        }
        SSL_ERROR_WANT_ACCEPT {
            retourne ErreurSSL.AcceptationAttendue
        }
        SSL_ERROR_WANT_X509_LOOKUP {
            retourne ErreurSSL.RécupérationX509Attendue
        }
        SSL_ERROR_SYSCALL {
            retourne ErreurSSL.AppelSystème
        }
        SSL_ERROR_SSL {
            retourne ErreurSSL.SSL
        }
        sinon {
            retourne ErreurSSL.SSL
        }
    }
}

// Puisque sur les systèmes UNIX tout est un fichier, les prises sont des fichiers, donc utilisons
// l'interface d'un fichier pour envelopper la logique de lecture et d'écriture pour une connexion SSL
FichierSSL :: struct {
    fichier: Fichier
    ssl : *ssl_st
}

FichierOuErreurSSL :: union {
    f: FichierSSL
    e: ErreurSSL
}

ouvre_fichier_ssl :: fonc (ctx_ssl: *ssl_st, fichier: Fichier) -> FichierOuErreurSSL
{
    m_ssl := SSL_new(ctx_ssl)

    si m_ssl == nul {
        retourne converti_erreur_ssl(m_ssl, 0)
    }

    si SSL_set_fd(m_ssl, fichier.desc) == 0 {
        retourne converti_erreur_ssl(m_ssl, 0)
    }

    connexion := SSL_connect(m_ssl)

    si connexion <= 0 {
        retourne converti_erreur_ssl(m_ssl, 0)
    }

    fichier_ssl : FichierSSL
    fichier_ssl.fichier = fichier
    fichier_ssl.ssl = m_ssl
    retourne fichier_ssl
}

écris :: fonc (fichier: *FichierSSL, texte: chaine) -> ErreurSSL
{
    taille := SSL_write(fichier.ssl, texte.pointeur, texte.taille comme z32)

    si taille <= 0 {
        retourne converti_erreur_ssl(fichier.ssl, taille)
    }

    retourne 0 comme ErreurSSL
}

ChaineOuErreurSSL :: union {
    c: chaine
    e: ErreurSSL
}

lis_tout :: fonc (fichier: *FichierSSL) -> ChaineOuErreurSSL
{
    TAILLE_MAX_DONNÉES :: 1024
    tampon : [TAILLE_MAX_DONNÉES]z8
    résultat : chaine

    boucle {
        taille := SSL_read(fichier.ssl, *tampon[0], TAILLE_MAX_DONNÉES)

        si taille > 0 {
            ancienne_taille := résultat.taille
            reloge_chaine(résultat, résultat.taille + taille)
            copie_mem_nonsur(src=*tampon[0], dst=*résultat[ancienne_taille], taille=taille comme z64)
        }
        sinon si taille == 0 {
            arrête
        }
        sinon {
            err := converti_erreur_ssl(fichier.ssl, taille)

            si err != ErreurSSL.Aucune && err != ErreurSSL.RetourneZéro {
                retourne converti_erreur_ssl(fichier.ssl, taille)
            }
        }
    }

    retourne résultat
}

ferme :: fonc (fichier: *FichierSSL) -> rien
{
    _ := tente ferme(*fichier.fichier) piège nonatteignable

    si fichier.ssl {
        SSL_free(fichier.ssl)
    }
}

// ------------------------------------------------------------------------

/* Efface les erreurs du fil d'exécution local. */
efface_file_erreur_locale :: fonc (code: z32)
{
    si code == SSL_ERROR_SSL || code == SSL_ERROR_SYSCALL {
        ERR_clear_error();
    }
}

// ------------------------------------------------------------------------

OptionsCréationContexteSSL :: struct {
    fichier_clé : chaine
    fichier_certificat : chaine
    phrase_de_passe : chaine
    fichier_paramètres_dh : chaine
    fichier_ca : chaine

    /* Cette option est importante pour diminuer la quantité de mémoire utilisée,
     * mais elle dimininue un peu la vittesse d'exécution du programme. */
    préfère_utilisation_mémoire_basse : bool
}

/* Détruit un SSL_CTX créé depuis des OptionsCréationContexteSSL */
détruit_contexte_ssl :: fonc (contexte_ssl: *SSL_CTX)
{
    /* Il est possible qu'un pointeur nul soit passé. */
    saufsi contexte_ssl {
        retourne
    }

    phrase_de_passe := SSL_CTX_get_default_passwd_cb_userdata(contexte_ssl)
    si phrase_de_passe {
        chn_c_phrasse_de_passe := ChaineC(phrase_de_passe comme *z8)
        détruit_chaine_c(chn_c_phrasse_de_passe)
    }

    SSL_CTX_free(contexte_ssl)
}

/* Fonction de rappel pour demander la phrase de passe pour le chiffrage ou déchiffrage d'un fichier certificat.
 * Puisque les OptionsCréationContexteSSL utilise une chaine pour la phrase de passe, ceci ne fait que la copier
 * dans le tampon de sortie. Mais nous pourrions égaelement paramétrer les options pour permettre un système un
 * peu plus complexe où cette fonction affiche un dialogue pour demander la phrase de passe (la fonction ne ferait
 * qu'appeler la logique de l'application cliente qui affiche le dialogue).
 *
 * tampon : le tampon où copier la phrase de passe
 * taille : la taille du tampon
 * drapeaux_lecture_écriture : défini si le mot de passe est utilisé pour le chiffrage (écriture, 1) ou le déchiffrage (lecture, 0)
 * données : les données utilisateur mis en place via SSL_CTX_set_default_passwd_cb_userdata
 */
rappel_pour_phrase_de_passe :: fonc (tampon: *z8, taille: z32 @inutilisée, drapeaux_lecture_écriture: z32 @inutilisée, données: *rien) -> z32 #nulctx
pousse_contexte __contexte_fil_principal {
    phrase_de_passe := données comme *ChaineC
    taille_phrase_de_passe := taille_chaine_c(mémoire(phrase_de_passe))

    copie_mem_nonsur(dst = tampon, src = phrase_de_passe, taille = taille_phrase_de_passe)

    retourne taille_phrase_de_passe comme z32
}

/* Retourne un SSL_CTX paramétré selon les OptionsCréationContexteSSL, ou nul si impossible.
 * Puisqu'une phrase de passe peut-être présente, le SSL_CTX doit être détruit
 * via détruit_contexte_ssl().
 */
crée_contexte_ssl_depuis_options :: fonc (options: &OptionsCréationContexteSSL) -> *SSL_CTX
{
    /* Crée le contexte */
    contexte_ssl := SSL_CTX_new(TLS_method())

    /* Options par défaut pour ConnexionTCP
     * À FAIRE : paramétrise. */
    SSL_CTX_set_read_ahead(contexte_ssl, 1)
    _ := SSL_CTX_set_mode(contexte_ssl, SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER)

    /* Requiers TLS 1.2 minimum.
     * À FAIRE : paramétrise. */
    si SSL_CTX_set_min_proto_version(contexte_ssl, TLS1_2_VERSION) == 0 {
        détruit_contexte_ssl(contexte_ssl)
        retourne nul
    }

    saufsi initialise_contexte_ssl_depuis_options(contexte_ssl, options) {
        détruit_contexte_ssl(contexte_ssl)
        retourne nul
    }

    retourne contexte_ssl
}

initialise_contexte_ssl_depuis_options :: fonc (contexte_ssl: *SSL_CTX, options: &OptionsCréationContexteSSL) -> bool
{
    si options.préfère_utilisation_mémoire_basse {
       _ := SSL_CTX_set_mode(contexte_ssl, SSL_MODE_RELEASE_BUFFERS)
    }

    si options.phrase_de_passe {
        /* Lors de la destruction du SSL_CTX, il faut utiliser SSL_CTX_get_default_passwd_cb_userdata
         * et manuellement libérer la ChaineC si présente. */
        chn_c_phrasse_de_passe := crée_chaine_c(options.phrase_de_passe)
        SSL_CTX_set_default_passwd_cb_userdata(contexte_ssl, chn_c_phrasse_de_passe comme *z8)
        SSL_CTX_set_default_passwd_cb(contexte_ssl, rappel_pour_phrase_de_passe)
    }

    si options.fichier_certificat {
        saufsi contexte_ssl_charge_fichier_certificat(contexte_ssl, options.fichier_certificat) {
            retourne faux
        }
    }

    si options.fichier_clé {
        saufsi contexte_ssl_charge_fichier_clé_privée(contexte_ssl, options.fichier_clé) {
            retourne faux
        }
    }

    si options.fichier_ca {
        saufsi contexte_ssl_charge_fichier_ca(contexte_ssl, options.fichier_ca) {
            retourne faux
        }
    }

    si options.fichier_paramètres_dh {
        saufsi contexte_ssl_charge_paramètres_dh(contexte_ssl, options.fichier_paramètres_dh) {
            retourne faux
        }
    }

    retourne vrai
}

contexte_ssl_charge_fichier_certificat :: fonc (contexte_ssl: *SSL_CTX, fichier_certificat: chaine) -> bool
{
    chn_c_fichier_certificat := crée_chaine_c(fichier_certificat)
    diffère détruit_chaine_c(chn_c_fichier_certificat)
    retourne SSL_CTX_use_certificate_chain_file(contexte_ssl, chn_c_fichier_certificat) == 1
}

contexte_ssl_charge_fichier_clé_privée :: fonc (contexte_ssl: *SSL_CTX, fichier_clé: chaine) -> bool
{
    chn_c_fichier_clé := crée_chaine_c(fichier_clé)
    diffère détruit_chaine_c(chn_c_fichier_clé)
    retourne SSL_CTX_use_PrivateKey_file(contexte_ssl, chn_c_fichier_clé, SSL_FILETYPE_PEM) == 1
}

contexte_ssl_charge_fichier_ca :: fonc (contexte_ssl: *SSL_CTX, fichier_ca: chaine) -> bool
{
    chn_c_fichier_ca := crée_chaine_c(fichier_ca)
    diffère détruit_chaine_c(chn_c_fichier_ca)

    ca_list := SSL_load_client_CA_file(chn_c_fichier_ca)

    si ca_list == nul {
        retourne faux
    }

    SSL_CTX_set_client_CA_list(contexte_ssl, ca_list)

    si SSL_CTX_load_verify_locations(contexte_ssl, chn_c_fichier_ca, ChaineC(nul)) != 1 {
        retourne faux
    }

    SSL_CTX_set_verify(contexte_ssl, SSL_VERIFY_PEER, nul)
    retourne vrai
}

/* Initialise les paramètres DH éphémères depuis un fichier.
 * Retourne vrai en cas de réussite, faux le cas échéant. */
contexte_ssl_charge_paramètres_dh :: fonc (contexte_ssl: *SSL_CTX, fichier_paramètres_dh: chaine) -> bool
{
    contenu := contenu_fichier_texte(fichier_paramètres_dh)

    saufsi contenu {
        retourne faux
    }

    bio := BIO_new_mem_buf(contenu.pointeur, contenu.taille comme z32)
    diffère _ := BIO_free(bio)

    saufsi bio {
        retourne faux
    }

    dh_2048 := PEM_read_bio_DHparams(bio, nul, nul, nul)

    saufsi dh_2048 {
        retourne faux
    }

    diffère DH_free(dh_2048)

    si SSL_CTX_set_tmp_dh(contexte_ssl, dh_2048) != 1 {
        retourne faux
    }

    /* OWASP Cipher String 'A+' (https://www.owasp.org/index.php/TLS_Cipher_String_Cheat_Sheet) */
    controle := crée_chaine_c("DHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256")
    diffère détruit_chaine_c(controle)

    si SSL_CTX_set_cipher_list(contexte_ssl, controle) != 1 {
        retourne faux
    }

    retourne vrai
}
