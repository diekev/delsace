/* Module définissant une lexeuse générique pour lexer des langages de
 * programmation arbitraires.
 *
 * Utilisation :
 *
 *  lexeuse: SimpleLexeuse
 *  lexeuse.ponctuations = ["{", "}", "(", ")", "=", ";"]
 *  lexeuse.mots_clés = [ ... tableau de chaines ... ]
 *  lexeuse.commentaires_ligne_singulière = [ "//" ]
 *  lexeuse.commentaires_multi_lignes = [ [ "/*", "*/" ]
 *  lexeuse.suffixes_nombres_littéraux = [ "f", "n" ]
 *
 *  initialise_lexeuse_pour_texte(*lexeuse, texte)
 *
 *  boucle {
 *      lexème := donne_lexème_suivant(*lexeuse)
 *      si lexème.type == TypeLexème.FinDeFichier {
 *          arrête
 *      }
 *      ...
 *  }
 *
 *
 * Il est également possible d'obtenir tous les lexèmes d'un coup :
 *
 *  lexèmes := donne_tous_les_lexèmes(*lexeuse)
 *
 * Le lexème de fin de fichier sera omis.
 *
 * Par défaut, la SimpleLexeuse ne lèxe que les symboles (contenant
 * des lettres, des tirets-bas, ou des chiffres). Tout autre caractère
 * rencontré terminera le lexage. Pour les lexer, il faut les spécifier
 * via les poncutations ou mots-clés. SimpleLexeuse.caractères_symboliques
 * permet de spécifier d'autres caractères pouvant apparaitre dans les
 * symboles.
 *
 * Par exemple :
 *
 *  lexeuse.caractères_symboliques = "$?"
 *
 * Permettra d'avoir '$' et '?' dans les symboles.
 *
 *
 * À FAIRE : retourne les indices des mots-clés
 * À FAIRE : permet de spécifier les limites des chaines littérales
 * À FAIRE : séparateur dans les valeurs numériques
 * À FAIRE : échappements (caractères unicode etc.)
 */

importe Chaine
importe Fondation
importe Math
importe Numérique

/* ------------------------------------------------------------------------- */
/** \nom Lexème
 * \{ */

TypeLexème :: énum n8 {
    Symbole :: 127
    MotClé
    Ponctuation
    Commentaire
    EspaceBlanche
    FinDeFichier
    ChaineLittérale
    LittéraleNombreEntier
    LittéraleNombreRéel
    CaractèreConstant

    Nombre :: LittéraleNombreEntier
}

Nombre :: union {
    réel: r64
    naturel: n64
    relatif: n64
}

Lexème :: struct {
    type: TypeLexème

    début: *z8
    fin: *z8

    préfixe: chaine

    // Pour les nombres littéraux.
    suffixe: chaine
    nombre: Nombre
}

donne_texte :: fonc (lexème: Lexème) -> chaine
{
    retourne chaine(lexème.début, lexème.fin - lexème.début)
}

est_symbole :: fonc (lexème: Lexème, texte: chaine) -> bool
{
    retourne lexème.type == TypeLexème.Symbole && lexème.donne_texte() == texte
}

est_mot_clé :: fonc (lexème: Lexème, texte: chaine) -> bool
{
    retourne lexème.type == TypeLexème.MotClé && lexème.donne_texte() == texte
}

est_ponctuation :: fonc (lexème: Lexème, texte: chaine) -> bool
{
    retourne lexème.type == TypeLexème.Ponctuation && lexème.donne_texte() == texte
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom SimpleLexeuse
 * \{ */

OptionsLexage :: énum_drapeau {
    INCLUS_ESPACE_BLANCHES
    INCLUS_COMMENTAIRES
    INCLUS_GUILLEMETS

    INCLUS_TOUT :: INCLUS_COMMENTAIRES | INCLUS_ESPACE_BLANCHES | INCLUS_GUILLEMETS
}

SimpleLexeuse :: struct {
    début: *z8
    fin: *z8

    options: OptionsLexage

    taille_mot_clé_min: z32
    taille_mot_clé_max: z32

    supporte_nombre_héxadécimaux_sans_préfixe: bool

    /* Pour le rapport d'erreurs. */
    chemin_fichier: chaine
    texte: chaine

    caractères_symboliques: chaine
    mots_clés: []chaine
    ponctuations: []chaine
    suffixes_nombres_littéraux: []chaine
    préfixes_chaines_littérales: []chaine
    préfixes_constantes_de_caractères: []chaine
    // À FAIRE : utilise une meilleure manière de déterminer ceci
    apostrophe_est_caractère_constant: bool
    commentaires_ligne_singulière: []chaine
    commentaires_multi_lignes: [][2]chaine

    table_drapeaux_caractère: [256]DrapeauxCaractère = ---
    table_peut_suivre: [256]PeutSuivre = ---

    /* Pour les options incluant les espaces blanches et commentaires. */
    lexèmes_extras: [..]Lexème

    /* Pour lexer les commentaires en plusieurs fois (ligne par ligne). */
    dans_commentaire: bool
    paire_commentaire: [2]chaine

    /* Fonction optionnelle utilisée pour lexer les littérales de nombre entier ou réel. */
    sur_lexage_littérale_numérique: fonc (lexeuse: *SimpleLexeuse) -> Lexème
}

initialise_lexeuse_pour_texte :: fonc (lexeuse: *SimpleLexeuse, texte: chaine)
{
    définis_texte_courant(lexeuse, texte)

    construis_tables_de_lexage(lexeuse)

    lexeuse.taille_mot_clé_min = 0x7fffffff
    lexeuse.taille_mot_clé_max = 0

    pour lexeuse.mots_clés {
        si it.taille > lexeuse.taille_mot_clé_max {
            lexeuse.taille_mot_clé_max = it.taille comme z32
        }
        si it.taille < lexeuse.taille_mot_clé_min {
            lexeuse.taille_mot_clé_min = it.taille comme z32
        }
    }
}

définis_texte_courant :: fonc (lexeuse: *SimpleLexeuse, texte: chaine)
{
    lexeuse.début = texte.pointeur
    lexeuse.fin = texte.pointeur + texte.taille
    lexeuse.texte = texte
}

donne_lexème_suivant :: fonc (lexeuse: *SimpleLexeuse) -> Lexème
{
    si lexeuse.lexèmes_extras {
        résultat := lexeuse.lexèmes_extras[0]
        tableau_supprime_indice(*lexeuse.lexèmes_extras, 0)
        retourne résultat
    }

    si lexeuse.fini() {
        retourne Lexème(type = TypeLexème.FinDeFichier)
    }

    si lexeuse.dans_commentaire {
        parse_commentaire_multiligne(lexeuse, lexeuse.début)
        assert(lexeuse.lexèmes_extras.taille == 1)
        résultat := lexeuse.lexèmes_extras[0]
        tableau_supprime_indice(*lexeuse.lexèmes_extras, 0)
        retourne résultat
    }

    consomme_espace_blanches(lexeuse)

    si lexeuse.lexèmes_extras {
        résultat := lexeuse.lexèmes_extras[0]
        tableau_supprime_indice(*lexeuse.lexèmes_extras, 0)
        retourne résultat
    }

    si lexeuse.fini() {
        retourne Lexème(type = TypeLexème.FinDeFichier)
    }

    c := donne_caractère_courant(lexeuse)
    drapeaux := donne_drapeaux_caractère(lexeuse, c)

    si drapeaux.Ponctuation {
        retourne donne_lexème_ponctuation(lexeuse)
    }

    si drapeaux.DébutePréfixeCaractère {
        sauvegarde := lexeuse.début
        préfixe_caractère := donne_préfixe_caractère(lexeuse)
        si préfixe_caractère {
            avance(lexeuse, préfixe_caractère.taille comme z32)

            saufsi fini(lexeuse) {
                c0 := donne_caractère_courant(lexeuse)
                drapeaux0 := donne_drapeaux_caractère(lexeuse, c0)

                si drapeaux0.DébuteCaractère {
                    retourne donne_lexème_chaine_littérale(lexeuse, c0, TypeLexème.CaractèreConstant, préfixe_caractère)
                }
            }
        }

        lexeuse.début = sauvegarde
    }

    si drapeaux.DébuteCaractère {
        retourne donne_lexème_chaine_littérale(lexeuse, c, TypeLexème.CaractèreConstant, "")
    }

    si drapeaux.DébutePréfixeChaine {
        sauvegarde := lexeuse.début
        préfixe_caractère := donne_préfixe_caractère(lexeuse)
        si préfixe_caractère {
            avance(lexeuse, préfixe_caractère.taille comme z32)

            saufsi fini(lexeuse) {
                c0 := donne_caractère_courant(lexeuse)
                drapeaux0 := donne_drapeaux_caractère(lexeuse, c0)

                si drapeaux0.DébuteChaineLittérale {
                    retourne donne_lexème_chaine_littérale(lexeuse, c0, TypeLexème.ChaineLittérale, préfixe_caractère)
                }
            }
        }

        lexeuse.début = sauvegarde
    }

    si drapeaux.DébuteChaineLittérale {
        retourne donne_lexème_chaine_littérale(lexeuse, c, TypeLexème.ChaineLittérale, "")
    }

    si drapeaux.Numérique {
        retourne donne_lexème_numérique(lexeuse)
    }

    si drapeaux.Alphabétique {
        retourne donne_lexème_symbole(lexeuse, drapeaux)
    }

    ligne := donne_ligne_pour_erreur(lexeuse)
    imprimeln("%", ligne.texte)
    imprimeln("Caractère inconnu : '%' (%, drapeaux %)", chaine(*c, 1), c, drapeaux)
    retourne Lexème(type = TypeLexème.FinDeFichier)
}

donne_tous_les_lexèmes :: fonc (lexeuse: *SimpleLexeuse) -> [..]Lexème
{
    résultat: [..]Lexème

    boucle {
        lexème := donne_lexème_suivant(lexeuse)
        si lexème.type == TypeLexème.FinDeFichier {
            arrête
        }
        tableau_ajoute(*résultat, lexème)
    }

    retourne résultat
}

fini :: fonc (lexeuse: *SimpleLexeuse) -> bool
{
    retourne lexeuse.début >= lexeuse.fin
}

consomme :: fonc (lexeuse: *SimpleLexeuse)
{
    _ := donne_lexème_suivant(lexeuse)
}

consomme_ponctuation :: fonc (lexeuse: *SimpleLexeuse, texte: chaine)
{
    _ := donne_lexème(lexeuse, TypeLexème.Ponctuation, texte)
}

consomme_symbole :: fonc (lexeuse: *SimpleLexeuse)
{
    _ := donne_lexème(lexeuse, TypeLexème.Symbole)
}

consomme_symbole :: fonc (lexeuse: *SimpleLexeuse, texte: chaine)
{
    _ := donne_symbole(lexeuse, texte)
}

consomme_mot_clé :: fonc (lexeuse: *SimpleLexeuse, texte: chaine)
{
    _ := donne_mot_clé(lexeuse, texte)
}

épie_lexème_suivant :: fonc (lexeuse: *SimpleLexeuse) -> Lexème
{
    début := lexeuse.début
    diffère lexeuse.début = début
    résultat := donne_lexème_suivant(lexeuse)
    retourne résultat
}

donne_nombre :: fonc (lexeuse: *SimpleLexeuse) -> Lexème
{
    retourne donne_lexème(lexeuse, TypeLexème.Nombre)
}

donne_symbole :: fonc (lexeuse: *SimpleLexeuse) -> Lexème
{
    retourne donne_lexème(lexeuse, TypeLexème.Symbole)
}

donne_symbole :: fonc (lexeuse: *SimpleLexeuse, texte: chaine) -> Lexème
{
    retourne donne_lexème(lexeuse, TypeLexème.Symbole, texte)
}

donne_mot_clé :: fonc (lexeuse: *SimpleLexeuse) -> Lexème
{
    retourne donne_lexème(lexeuse, TypeLexème.MotClé)
}

donne_mot_clé :: fonc (lexeuse: *SimpleLexeuse, texte: chaine) -> Lexème
{
    retourne donne_lexème(lexeuse, TypeLexème.MotClé, texte)
}

reprends_depuis_lexème :: fonc (lexeuse: *SimpleLexeuse, lexème: Lexème)
{
    assert(lexème.début >= lexeuse.texte.pointeur)
    assert(lexème.début < lexeuse.fin)
    assert(lexème.fin >= lexeuse.texte.pointeur)
    assert(lexème.fin <= lexeuse.fin)

    lexeuse.début = lexème.début
}

donne_texte_jusque_nouvelle_ligne :: fonc (lexeuse: *SimpleLexeuse) -> chaine
{
    // À FAIRE : gère lexèmes extras
    lexeuse.lexèmes_extras.taille = 0
    lexeuse.consomme_espace_blanches()
    lexeuse.lexèmes_extras.taille = 0

    début := lexeuse.début

    tantque !fini(lexeuse) {
        si mémoire(lexeuse.début) == '\n' {
            lexeuse.début += 1
            arrête
        }

        lexeuse.début += 1
    }

    résultat := chaine(début, lexeuse.début - début - 1)
    retourne résultat
}

#portée_fichier

donne_lexème :: fonc (lexeuse: *SimpleLexeuse, type: TypeLexème) -> Lexème
{
    lexème := donne_lexème_suivant(lexeuse)
    saufsi lexème.type == type {
        rapporte_erreur(lexeuse, lexème, type)
    }
    retourne lexème
}

donne_lexème :: fonc (lexeuse: *SimpleLexeuse, type: TypeLexème, texte: chaine) -> Lexème
{
    lexème := donne_lexème_suivant(lexeuse)
    si lexème.type == type && lexème.donne_texte() == texte {
        retourne lexème
    }
    rapporte_erreur(lexeuse, lexème, texte)
}

rapporte_erreur :: fonc (lexeuse: *SimpleLexeuse, lexème: Lexème, type_voulu: TypeLexème) #sansretour
{
    voulu := "non-spécifié"
    discr type_voulu {
        Symbole {
            voulu = "un symbole"
        }
        MotClé {
            voulu = "un mot-clé"
        }
        Ponctuation {
            voulu = "une ponctuation"
        }
        Nombre {
            voulu = "un nombre"
        }
        Commentaire {
            voulu = "un commentaire"
        }
        EspaceBlanche {
            voulu = "une espace blanche"
        }
        FinDeFichier {
            voulu = "la fin de fichier"
        }
        ChaineLittérale {
            voulu = "une chaine littérale"
        }
    }

    rapporte_erreur(lexeuse, lexème, voulu)
}

rapporte_erreur :: fonc (lexeuse: *SimpleLexeuse, lexème: Lexème, voulu: chaine) #sansretour
{
    lexeuse.début = lexème.donne_texte().pointeur
    ligne := donne_ligne_pour_erreur(lexeuse)
    imprimeln("%", ligne.texte)
    imprimeln("Attendu '%', obtenu '%'", voulu, lexème.donne_texte())
    exit(1)
}

DrapeauxCaractère :: énum_drapeau n16 {
    Numérique
    Alphabétique
    HorsMotClé
    EspaceBlanche
    NouvelleLigne
    Ponctuation
    ChiffreHexadécimal
    HorsChiffreHexadécimal

    DébutePréfixeChaine
    DébuteChaineLittérale

    DébutePréfixeCaractère    
    DébuteCaractère

    DébuteCommentaireLigneSingulière
    DébuteCommentaireMultiLignes

    DébuteSuffixeNombre
    DébutePartDécimale

    DébuteCommentaire :: DébuteCommentaireLigneSingulière | DébuteCommentaireMultiLignes
}

PeutSuivre :: énum_drapeau n8 {
    Symbole
    Ponctuation
    Nombre
    DébutCommentaire
    SuffixeNombre
}

construis_tables_de_lexage :: fonc (lexeuse: *SimpleLexeuse)
{
    construis_table_drapeaux_caractères(lexeuse)
    construis_table_peut_suivre(lexeuse)
}

construis_table_drapeaux_caractères :: fonc (lexeuse: *SimpleLexeuse)
{
    pour & lexeuse.table_drapeaux_caractère {
        it = DrapeauxCaractère.zéro
    }

    caractères_alphabétique :: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_"
    pour caractères_alphabétique {
        lexeuse.table_drapeaux_caractère[it] = DrapeauxCaractère.Alphabétique
    }

    pour lexeuse.caractères_symboliques {
        lexeuse.table_drapeaux_caractère[it] |= DrapeauxCaractère.Alphabétique
    }

    pour "0123456789abcdefABCDEF" {
        lexeuse.table_drapeaux_caractère[it] |= DrapeauxCaractère.ChiffreHexadécimal
    }

    pour & lexeuse.table_drapeaux_caractère {
        si (it & DrapeauxCaractère.ChiffreHexadécimal) != DrapeauxCaractère.zéro {
            continue
        }
        it |= DrapeauxCaractère.HorsChiffreHexadécimal
    }

    /* 2 passes pour définir si un caractère n'apparait pas dans un mot-clé. */
    pour mot_clé dans lexeuse.mots_clés {
        pour mot_clé {
            lexeuse.table_drapeaux_caractère[it comme n8] |= DrapeauxCaractère.HorsMotClé
        }
    }

    pour & lexeuse.table_drapeaux_caractère {
        si (it & DrapeauxCaractère.HorsMotClé) != DrapeauxCaractère.zéro {
            it &= ~DrapeauxCaractère.HorsMotClé
            continue
        }
        it |= DrapeauxCaractère.HorsMotClé
    }

    caractères_numérique :: "0123456789"
    pour caractères_numérique {
        lexeuse.table_drapeaux_caractère[it] |= DrapeauxCaractère.Numérique
    }

    lexeuse.table_drapeaux_caractère['\n'] |= DrapeauxCaractère.NouvelleLigne | DrapeauxCaractère.EspaceBlanche

    lexeuse.table_drapeaux_caractère['\f'] |= DrapeauxCaractère.EspaceBlanche
    lexeuse.table_drapeaux_caractère['\r'] |= DrapeauxCaractère.EspaceBlanche
    lexeuse.table_drapeaux_caractère['\t'] |= DrapeauxCaractère.EspaceBlanche
    lexeuse.table_drapeaux_caractère['\v'] |= DrapeauxCaractère.EspaceBlanche
    lexeuse.table_drapeaux_caractère[' '] |= DrapeauxCaractère.EspaceBlanche

    lexeuse.table_drapeaux_caractère['.'] |= DrapeauxCaractère.Ponctuation | DrapeauxCaractère.DébutePartDécimale

    lexeuse.table_drapeaux_caractère['"'] |= DrapeauxCaractère.DébuteChaineLittérale
    si lexeuse.apostrophe_est_caractère_constant {
        lexeuse.table_drapeaux_caractère['\''] |= DrapeauxCaractère.DébuteCaractère
    }
    sinon {
        lexeuse.table_drapeaux_caractère['\''] |= DrapeauxCaractère.DébuteChaineLittérale
    }

    pour lexeuse.ponctuations {
        pour c dans it {
            lexeuse.table_drapeaux_caractère[c comme n8] |= DrapeauxCaractère.Ponctuation
        }
    }

    définis_drapeau_depuis_premier_caractère(lexeuse, lexeuse.préfixes_chaines_littérales, DrapeauxCaractère.DébutePréfixeChaine)
    définis_drapeau_depuis_premier_caractère(lexeuse, lexeuse.préfixes_constantes_de_caractères, DrapeauxCaractère.DébutePréfixeCaractère)
    définis_drapeau_depuis_premier_caractère(lexeuse, lexeuse.suffixes_nombres_littéraux, DrapeauxCaractère.DébuteSuffixeNombre)
    définis_drapeau_depuis_premier_caractère(lexeuse, lexeuse.commentaires_ligne_singulière, DrapeauxCaractère.DébuteCommentaireLigneSingulière)
    définis_drapeau_depuis_premier_caractère(lexeuse, lexeuse.commentaires_multi_lignes, DrapeauxCaractère.DébuteCommentaireMultiLignes)
}

définis_drapeau_depuis_premier_caractère :: fonc (lexeuse: *SimpleLexeuse, chaines: []chaine, drapeau: DrapeauxCaractère)
{
    pour chaines {
        si it.taille == 0 {
            continue
        }

        lexeuse.table_drapeaux_caractère[it[0] comme n8] |= drapeau
    }
}

définis_drapeau_depuis_premier_caractère :: fonc (lexeuse: *SimpleLexeuse, chaines: [][2]chaine, drapeau: DrapeauxCaractère)
{
    pour chaines {
        si it[0].taille == 0 {
            continue
        }

        lexeuse.table_drapeaux_caractère[it[0][0] comme n8] |= drapeau
    }
}

construis_table_peut_suivre :: fonc (lexeuse: *SimpleLexeuse)
{
    pour & lexeuse.table_peut_suivre {
        it = PeutSuivre.zéro
    }

    caractères_alphabétique :: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_"
    pour caractères_alphabétique {
        lexeuse.table_peut_suivre[it] |= PeutSuivre.Symbole
    }

    pour lexeuse.caractères_symboliques {
        lexeuse.table_peut_suivre[it] |= PeutSuivre.Symbole
    }

    pour "0123456789abcdefABCDEF" {
        lexeuse.table_peut_suivre[it] |= PeutSuivre.Nombre
    }

    caractères_numérique :: "0123456789"
    pour caractères_numérique {
        lexeuse.table_peut_suivre[it] |= PeutSuivre.Symbole | PeutSuivre.Nombre
    }

    lexeuse.table_peut_suivre['.'] |= PeutSuivre.Nombre

    pour mot_clé dans lexeuse.mots_clés {
        pour 1 ... mot_clé.taille - 1 {
            lexeuse.table_peut_suivre[mot_clé[it] comme n8] |= PeutSuivre.Symbole
        }
    }

    pour ponctuation dans lexeuse.ponctuations {
        pour 1 ... ponctuation.taille - 1 {
            lexeuse.table_peut_suivre[ponctuation[it] comme n8] |= PeutSuivre.Ponctuation
        }
    }

    pour suffixe dans lexeuse.suffixes_nombres_littéraux {
        pour 1 ... suffixe.taille - 1 {
            lexeuse.table_peut_suivre[suffixe[it] comme n8] |= PeutSuivre.SuffixeNombre
        }
    }

    pour commentaire dans lexeuse.commentaires_ligne_singulière {
        pour 1 ... commentaire.taille - 1 {
            lexeuse.table_peut_suivre[commentaire[it] comme n8] |= PeutSuivre.DébutCommentaire
        }
    }

    pour paire dans lexeuse.commentaires_multi_lignes {
        pour 1 ... paire[0].taille - 1 {
            lexeuse.table_peut_suivre[paire[0][it] comme n8] |= PeutSuivre.DébutCommentaire
        }
    }
}

imprime_tables_de_lexage :: fonc (lexeuse: *SimpleLexeuse)
{
    imprime_table :: fonc (table: []$T)
    {
        pour table {
            si it == it.zéro {
                continue
            }

            si indice_it >= 127 {
                continue
            }

            caractère := indice_it comme z8
            imprimeln("% : %", chaine(*caractère, 1), it)
        }
    }

    imprime_table(lexeuse.table_drapeaux_caractère)
    imprimeln("------------------------------------------")
    imprime_table(lexeuse.table_peut_suivre)
}

donne_caractère_courant :: fonc (lexeuse: *SimpleLexeuse) -> z8
{
    retourne mémoire(lexeuse.début)
}

donne_caractère_suivant :: fonc (lexeuse: *SimpleLexeuse) -> z8
{
    retourne mémoire(lexeuse.début + 1)
}

avance :: fonc (lexeuse: *SimpleLexeuse, n : z32 = 1)
{
    lexeuse.début += n
}

donne_lexème_ponctuation :: fonc (lexeuse: *SimpleLexeuse) -> Lexème
{
    début_lexème := lexeuse.début
    fin_lexème := début_lexème + 1

    lexeuse.avance()

    tantque !lexeuse.fini() {
        c := donne_caractère_courant(lexeuse)
        peut_suivre := donne_drapeaux_peut_suivre(lexeuse, c)

        saufsi peut_suivre.Ponctuation {
            arrête
        }

        lexeuse.avance()
        fin_lexème += 1
    }

    candidat := chaine(début_lexème, fin_lexème - début_lexème)

    /* Comparons avec 1 puisque nous savons que nous avons une ponctuation. */
    tantque candidat.taille > 1 {
        si est_ponctuation(lexeuse, candidat) {
            arrête
        }
        candidat.taille -= 1
    }

    fin_lexème = début_lexème + candidat.taille
    lexeuse.début = fin_lexème

    retourne Lexème(type = TypeLexème.Ponctuation, début = début_lexème, fin = fin_lexème)
}

est_ponctuation :: fonc (lexeuse: *SimpleLexeuse, ponctuation: chaine) -> bool
{
    pour lexeuse.ponctuations {
        si it == ponctuation {
            retourne vrai
        }
    }
    retourne faux
}

donne_lexème_symbole :: fonc (lexeuse: *SimpleLexeuse, drapeaux: DrapeauxCaractère) -> Lexème
{
    début_lexème := lexeuse.début
    fin_lexème := début_lexème

    drapeaux_résultat := drapeaux

    peut_suivre := PeutSuivre.Symbole

    tantque peut_suivre.Symbole {
        drapeaux_résultat |= drapeaux
        fin_lexème += 1
        lexeuse.avance()

        si lexeuse.fini() {
            arrête
        }

        c := donne_caractère_courant(lexeuse)
        drapeaux = donne_drapeaux_caractère(lexeuse, c)
        peut_suivre = donne_drapeaux_peut_suivre(lexeuse, c)
    }

    résultat := Lexème(type = TypeLexème.Symbole, début = début_lexème, fin = fin_lexème)
    résultat.type = donne_type_lexème_symbole(lexeuse, résultat.donne_texte(), drapeaux_résultat)
    si résultat.type == TypeLexème.Nombre {
        assert(drapeaux_résultat.ChiffreHexadécimal != faux)
        résultat.nombre.naturel = tente parse_hexadécimal_n64(résultat.donne_texte()) piège nonatteignable
    }
    retourne résultat
}

donne_type_lexème_symbole :: fonc (lexeuse: *SimpleLexeuse, texte: chaine, drapeaux: DrapeauxCaractère) -> TypeLexème
{
    si drapeaux.ChiffreHexadécimal && drapeaux.HorsChiffreHexadécimal == faux && lexeuse.supporte_nombre_héxadécimaux_sans_préfixe {
        retourne TypeLexème.Nombre
    }

    si drapeaux.HorsMotClé {
        retourne TypeLexème.Symbole
    }

    si texte.taille < lexeuse.taille_mot_clé_min || texte.taille > lexeuse.taille_mot_clé_max {
        retourne TypeLexème.Symbole
    }

    pour lexeuse.mots_clés {
        si it == texte {
            retourne TypeLexème.MotClé
        }
    }

    retourne TypeLexème.Symbole
}

donne_lexème_chaine_littérale :: fonc (lexeuse: *SimpleLexeuse, début: z8, type: TypeLexème, préfixe: chaine) -> Lexème
{
    lexeuse.avance()

    début_lexème := lexeuse.début
    fin_lexème := début_lexème

    tantque !lexeuse.fini() {
        c := donne_caractère_courant(lexeuse)

        si c == '\\' {
            lexeuse.avance(2)
            fin_lexème += 2
            continue
        }

        si c == début {
            arrête
        }

        lexeuse.avance()
        fin_lexème += 1
    }

    lexeuse.avance()

    si lexeuse.options.INCLUS_GUILLEMETS {
        début_lexème -= 1
        fin_lexème += 1
    }

    retourne Lexème(type = type, début = début_lexème, fin = fin_lexème, préfixe = préfixe)
}

donne_lexème_numérique :: fonc (lexeuse: *SimpleLexeuse) -> Lexème
{
    si lexeuse.sur_lexage_littérale_numérique {
        retourne lexeuse.sur_lexage_littérale_numérique(lexeuse)
    }

    début_lexème := lexeuse.début
    fin_lexème := début_lexème

    peut_suivre := PeutSuivre.Nombre
    drapeaux: DrapeauxCaractère
    drapeaux_accumulés: DrapeauxCaractère

    tantque peut_suivre.Nombre {
        fin_lexème += 1
        lexeuse.avance()

        si lexeuse.fini() {
            arrête
        }

        c := donne_caractère_courant(lexeuse)
        drapeaux = donne_drapeaux_caractère(lexeuse, c)
        drapeaux_accumulés |= drapeaux
        peut_suivre = donne_drapeaux_peut_suivre(lexeuse, c)
    }

    résultat := Lexème(type = TypeLexème.Nombre, début = début_lexème, fin = fin_lexème)
    si drapeaux_accumulés.DébutePartDécimale {
        nombre_parsé := tente extrait_r64(résultat.donne_texte()) piège nonatteignable
        résultat.nombre.réel = nombre_parsé
    }
    sinon si drapeaux_accumulés.ChiffreHexadécimal && lexeuse.supporte_nombre_héxadécimaux_sans_préfixe {
        résultat.nombre.naturel = tente parse_hexadécimal_n64(résultat.donne_texte()) piège nonatteignable
    }
    sinon {
        résultat.nombre.naturel = tente extrait_n64(résultat.donne_texte()) piège nonatteignable
    }

    début_lexème = lexeuse.début
    fin_lexème = début_lexème

    si drapeaux.DébuteSuffixeNombre {
        fin_lexème += 1
        lexeuse.avance()

        tantque !fini(lexeuse) {
            c := donne_caractère_courant(lexeuse)
            peut_suivre = donne_drapeaux_peut_suivre(lexeuse, c)

            saufsi peut_suivre.SuffixeNombre {
                arrête
            }

            suffixe := chaine(début_lexème, fin_lexème - début_lexème + 1)
            saufsi est_suffixe(lexeuse, suffixe) {
                arrête
            }

            fin_lexème += 1
            lexeuse.avance()
        }

        résultat.suffixe = chaine(début_lexème, fin_lexème - début_lexème)
    }

    retourne résultat
}

est_suffixe :: fonc (lexeuse: *SimpleLexeuse, suffixe_possible: chaine) -> bool
{
    pour lexeuse.suffixes_nombres_littéraux {
        si it == suffixe_possible {
            retourne vrai
        }
    }
    retourne faux
}

consomme_espace_blanches :: fonc (lexeuse: *SimpleLexeuse)
{
    tantque !lexeuse.fini() {
        c := donne_caractère_courant(lexeuse)
        drapeaux := donne_drapeaux_caractère(lexeuse, c)

        si drapeaux.EspaceBlanche {
            si lexeuse.options.INCLUS_ESPACE_BLANCHES {
                début_lexème := lexeuse.début
                fin_lexème := début_lexème + 1
                lexème := Lexème(type = TypeLexème.EspaceBlanche, début = début_lexème, fin = fin_lexème)
                tableau_ajoute(*lexeuse.lexèmes_extras, lexème)
            }

            lexeuse.avance()
            continue
        }

        si drapeaux.DébuteCommentaireLigneSingulière && est_début_commentaire_ligne_singulière(lexeuse) {
            début_lexème := lexeuse.début
            
            tantque !fini(lexeuse) {
                c = donne_caractère_courant(lexeuse)
                si c == '\n' {
                    arrête
                }
                lexeuse.avance()
            }

            si lexeuse.options.INCLUS_ESPACE_BLANCHES {
                fin_lexème := lexeuse.début
                lexème := Lexème(type = TypeLexème.Commentaire, début = début_lexème, fin = fin_lexème)
                tableau_ajoute(*lexeuse.lexèmes_extras, lexème)
            }
            continue
        }

        si drapeaux.DébuteCommentaireMultiLignes {
            paire_possible := donne_paire_commentaire_multilignes(lexeuse)
            saufsi paire_possible.possède_valeur() {
                arrête
            }

            début_lexème := lexeuse.début

            paire := paire_possible.Quelque
            lexeuse.avance(paire[1].taille comme z32)

            lexeuse.dans_commentaire = vrai
            lexeuse.paire_commentaire = paire

            parse_commentaire_multiligne(lexeuse, début_lexème)
            continue
        }

        arrête
    }
}

parse_commentaire_multiligne :: fonc (lexeuse: *SimpleLexeuse, début_lexème: *z8)
{
    paire := lexeuse.paire_commentaire

    assert(lexeuse.dans_commentaire == vrai)

    tantque !lexeuse.fini() {
        texte := chaine(lexeuse.début, lexeuse.fin - lexeuse.début)
        si commence_par(texte, paire[1]) {
            lexeuse.dans_commentaire = faux
            lexeuse.avance(paire[1].taille comme z32)
            arrête
        }
        lexeuse.avance(1)
    }

    si lexeuse.options.INCLUS_ESPACE_BLANCHES {
        fin_lexème := lexeuse.début
        lexème := Lexème(type = TypeLexème.Commentaire, début = début_lexème, fin = fin_lexème)
        tableau_ajoute(*lexeuse.lexèmes_extras, lexème)
    }
}

est_début_commentaire_ligne_singulière :: fonc (lexeuse: *SimpleLexeuse) -> bool
{
    texte := chaine(lexeuse.début, lexeuse.fin - lexeuse.début)
    pour lexeuse.commentaires_ligne_singulière {
        si texte.commence_par(it) {
            retourne vrai
        }
    }
    retourne faux
}

donne_paire_commentaire_multilignes :: fonc (lexeuse: *SimpleLexeuse) -> Optionnel([2]chaine)
{
    texte := chaine(lexeuse.début, lexeuse.fin - lexeuse.début)
    pour lexeuse.commentaires_multi_lignes {
        si texte.commence_par(it[0]) {
            retourne it
        }
    }
}

donne_préfixe_caractère :: fonc (lexeuse: *SimpleLexeuse) -> chaine
{
    texte := chaine(lexeuse.début, lexeuse.fin - lexeuse.début)
    pour lexeuse.préfixes_constantes_de_caractères {
        si texte.commence_par(it[0]) {
            retourne it
        }
    }
    retourne ""
}

donne_préfixe_chaine :: fonc (lexeuse: *SimpleLexeuse) -> chaine
{
    texte := chaine(lexeuse.début, lexeuse.fin - lexeuse.début)
    pour lexeuse.préfixes_chaines_littérales {
        si texte.commence_par(it[0]) {
            retourne it
        }
    }
    retourne ""
}

donne_drapeaux_caractère :: fonc (lexeuse: *SimpleLexeuse, c: z8) -> DrapeauxCaractère
{
    valeur := c comme n8
    si valeur < 128 {
        retourne lexeuse.table_drapeaux_caractère[valeur]
    }

    retourne DrapeauxCaractère.Alphabétique
}

donne_drapeaux_peut_suivre :: fonc (lexeuse: *SimpleLexeuse, c: z8) -> PeutSuivre
{
    valeur := c comme n8
    si valeur < 128 {
        retourne lexeuse.table_peut_suivre[valeur]
    }

    retourne PeutSuivre.Symbole
}

#portée_export

LignePourErreur :: struct {
    texte: chaine
}

// @copié de JSON
donne_ligne_pour_erreur :: fonc (lexeuse: *SimpleLexeuse) -> LignePourErreur
{
    début := lexeuse.texte.pointeur
    fin := lexeuse.texte.pointeur + lexeuse.texte.taille
    ptr_position := lexeuse.début

    ptr_début_ligne := ptr_position
    tantque ptr_début_ligne > début {
        si mémoire(ptr_début_ligne) == '\n' {
            ptr_début_ligne += 1
            arrête
        }
        ptr_début_ligne -= 1
    }

    ptr_fin_ligne := ptr_début_ligne
    tantque ptr_fin_ligne < fin {
        si mémoire(ptr_fin_ligne) == '\n' {
            arrête
        }
        ptr_fin_ligne += 1
    }

    texte := chaine(ptr_début_ligne, ptr_fin_ligne - ptr_début_ligne)
    retourne LignePourErreur(texte)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Lexeuses pour C et C++.
 * \{ */

#portée_fichier

__mots_clés_c := [
    "auto",
    "break",
    "case",
    "char",
    "const",
    "continue",
    "default",
    "do",
    "double",
    "else",
    "enum",
    "extern",
    "float",
    "for",
    "goto",
    "if",
    "inline",
    "int",
    "long",
    "register",
    "restrict",
    "return",
    "short",
    "signed",
    "sizeof",
    "static",
    "struct",
    "switch",
    "typedef",
    "union",
    "unsigned",
    "void",
    "volatile",
    "while",
    "_Alignas",
    "_Alignof",
    "_Atomic",
    "_Bool",
    "_Complex",
    "_Generic",
    "_Imaginary",
    "_Noreturn",
    "_Static_assert",
    "_Thread_local",
]

__mots_clés_cpp := [
    "if",
    "do",
    "for",
    "int",
    "auto",
    "bool",
    "char",
    "else",
    "enum",
    "final",
    "float",
    "long",
    "void",
    "true",
    "class",
    "const",
    "false",
    "short",
    "using",
    "while",
    "delete",
    "double",
    "extern",
    "public",
    "return",
    "static",
    "struct",
    "default",
    "private",
    "typedef",
    "template",
    "unsigned",
    "constexpr",
    "namespace",
    "protected",
    "thread_local",
    "static_assert"
]

/* A.1.7 Punctuators */
__ponctuation_c := [
    "[", "]", "(", ")", "{", "}", ".", "->",
    "++", "--", "&", "*", "+", "-", "~", "!",
    "/", "%", "<<", ">>", "<", ">", "<=", ">=", "==", "!=", "^", "|", "&&", "||",
    "?", ":", ";", "...",
    "=", "*=", "/=", "%=", "+=", "-=", "<<=", ">>=", "&=", "^=", "|=",
    ",", "#", "##",
    "<:", ":>", "<%", "%>", "%:", "%:%:",
    /* Non-spécifié, ceci est pour les processeurs. */
     "\\"
]

__ponctuation_cpp := [
    "+", "-", "[", "]", "(", ")", "{", "}", "/", "*", "=", "&", "|", "^", "%", "!", ":", ";", ",", "?", ".", "~", "<", ">",
    "+=", "++", "-=", "--", "*=", "/=", "%=", "^=", "|=", "&=", "~=", "==", "!=", "<=", ">=", "||", "&&", "#", "##", "::", "->", "<<", ">>", "<<=", ">>=", "\\"
]

__commentaires_ligne_singulière_c := [ "//" ]
__commentaires_multi_lignes_c := [ ["/*", "*/"] ]

__suffixes_nombres_littéraux_c := ["f", "F", "u", "U", "l", "L", "ll", "LL", "llu", "LLU", "z", "Z", "i", "I", "j", "J", "iF", "IF", "if", "If", "Fi", "FI", "fi", "fI"]

__préfixes_constantes_de_caractères_c := ["L", "u", "U"]
__préfixes_chaines_littérales_c := ["u8", "u", "U", "L"]

parse_lexème_numérique_c :: fonc (lexeuse: *SimpleLexeuse) -> Lexème
{
    début_lexème := lexeuse.début
    fin_lexème := début_lexème

    c := donne_caractère_courant(lexeuse)

    nombre_entier: n64 = 0

    si c == '0' {
        fin_lexème += 1
        lexeuse.avance()

        saufsi fini(lexeuse) {
            c = donne_caractère_courant(lexeuse)
            si c == 'x' || c == 'X' {
                fin_lexème += 1
                lexeuse.avance()

                début_nombre := fin_lexème
                fin_nombre := début_nombre

                tantque !fini(lexeuse) {
                    c = donne_caractère_courant(lexeuse)
                    drapeaux := donne_drapeaux_caractère(lexeuse, c)

                    saufsi drapeaux.ChiffreHexadécimal {
                        arrête
                    }

                    fin_lexème += 1
                    fin_nombre += 1
                    lexeuse.avance()
                }

                texte_nombre := chaine(début_nombre, fin_nombre - début_nombre)
                nombre_entier = tente parse_hexadécimal_n64(texte_nombre) piège nonatteignable
            }
            sinon si c != '.' {
                tantque '0' <= c <= '7' {
                    nombre_entier *= 8
                    nombre_entier += (c - '0') comme n64

                    fin_lexème += 1
                    lexeuse.avance()
                    c = donne_caractère_courant(lexeuse)
                }
            }
        }
    }
    sinon si '1' <= c <= '9' {
        tantque '0' <= c <= '9' {
            nombre_entier *= 10
            nombre_entier += (c - '0') comme n64

            fin_lexème += 1
            lexeuse.avance()
            c = donne_caractère_courant(lexeuse)
        }
    }

    est_nombre_réel := faux
    nombre_réel: r64

    si c == '.' {
        est_nombre_réel = vrai
        fin_lexème += 1
        lexeuse.avance()
        nombre_réel = nombre_entier comme r64

        diviseur := 10.0

        tantque !fini(lexeuse) {
            c = donne_caractère_courant(lexeuse)
            saufsi '0' <= c <= '9' {
                arrête
            }
            fin_lexème += 1
            lexeuse.avance()

            valeur := (c - '0') comme r64
            nombre_réel += valeur / diviseur

            diviseur *= 10.0
        }
    }

    exposant: r64
    possède_exposant := faux
    si c == 'e' || c == 'E' {
        saufsi est_nombre_réel {
            nombre_réel = nombre_entier comme r64
        }

        est_nombre_réel = vrai
        possède_exposant = vrai
        fin_lexème += 1
        lexeuse.avance()

        signe := '+'

        saufsi fini(lexeuse) {
            c = donne_caractère_courant(lexeuse)
            si c == '-' || c == '+' {
                signe = c
                fin_lexème += 1
                avance(lexeuse)
            }
        }

        tantque !fini(lexeuse) {
            c = donne_caractère_courant(lexeuse)
            saufsi '0' <= c <= '9' {
                arrête
            }
            exposant *= 10.0
            exposant += (c - '0') comme r64
            fin_lexème += 1
            lexeuse.avance()
        }

        si signe == '-' {
            exposant = -exposant
        }
    }

    résultat: Lexème

    si est_nombre_réel {
        si possède_exposant {
            nombre_réel *= puissance(10.0, exposant)
        }

        suffixe: chaine
        si c == 'f' || c == 'F' || c == 'l' || c == 'L' || c == 'i' || c == 'I' || c == 'j' || c == 'J' {
            suffixe = chaine(fin_lexème, 1)
            fin_lexème += 1
            avance(lexeuse)

            tantque !fini(lexeuse) {
                c = donne_caractère_courant(lexeuse)
                saufsi (c == 'f' || c == 'F' || c == 'l' || c == 'L' || c == 'i' || c == 'I' || c == 'j' || c == 'J') {
                    arrête
                }

                suffixe.taille += 1
                fin_lexème += 1
                avance(lexeuse)
            }

            // À FAIRE : valide suffixe
        }

        résultat.type = TypeLexème.LittéraleNombreRéel
        résultat.nombre.réel = nombre_réel
        résultat.début = début_lexème
        résultat.fin = fin_lexème
        résultat.suffixe = suffixe
    }
    sinon {
        suffixe: chaine
        si c == 'l' || c == 'L' || c == 'u' || c == 'U' {
            suffixe = chaine(fin_lexème, 1)
            fin_lexème += 1
            avance(lexeuse)

            tantque !fini(lexeuse) {
                c = donne_caractère_courant(lexeuse)
                saufsi (c == 'l' || c == 'L' || c == 'u' || c == 'U') {
                    arrête
                }

                suffixe.taille += 1
                fin_lexème += 1
                avance(lexeuse)
            }

            // À FAIRE : valide suffixe
        }

        résultat.type = TypeLexème.LittéraleNombreEntier
        résultat.début = début_lexème
        résultat.fin = fin_lexème
        résultat.nombre.naturel = nombre_entier
        résultat.suffixe = suffixe
    }

    retourne résultat
}

#portée_export

initialise_lexeuse_c :: fonc (lexeuse: *SimpleLexeuse)
{
    lexeuse.ponctuations = __ponctuation_c
    lexeuse.sur_lexage_littérale_numérique = parse_lexème_numérique_c
    lexeuse.mots_clés = __mots_clés_c
    lexeuse.commentaires_ligne_singulière = __commentaires_ligne_singulière_c
    lexeuse.commentaires_multi_lignes = __commentaires_multi_lignes_c
    lexeuse.suffixes_nombres_littéraux = __suffixes_nombres_littéraux_c
    lexeuse.préfixes_constantes_de_caractères = __préfixes_constantes_de_caractères_c
    lexeuse.préfixes_chaines_littérales = __préfixes_chaines_littérales_c
    lexeuse.apostrophe_est_caractère_constant = vrai
}

initialise_lexeuse_cpp :: fonc (lexeuse: *SimpleLexeuse)
{
    lexeuse.ponctuations = __ponctuation_cpp
    lexeuse.sur_lexage_littérale_numérique = parse_lexème_numérique_c
    lexeuse.mots_clés = __mots_clés_cpp
    lexeuse.commentaires_ligne_singulière = __commentaires_ligne_singulière_c
    lexeuse.commentaires_multi_lignes = __commentaires_multi_lignes_c
    lexeuse.suffixes_nombres_littéraux = __suffixes_nombres_littéraux_c
    lexeuse.préfixes_constantes_de_caractères = __préfixes_constantes_de_caractères_c
    lexeuse.préfixes_chaines_littérales = __préfixes_chaines_littérales_c
    lexeuse.apostrophe_est_caractère_constant = vrai
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Lexeuse pour Kuri
 * \{ */

#portée_fichier

__ponctuation_kuri := [
    "+", "-", "[", "]", "(", ")", "{", "}", "/", "*", "=", "&", "|", "^", "%", "!", ":", ";", ",", "?", ".", "~", "<", ">",
    "+=", "++", "-=", "--", "*=", "/=", "%=", "^=", "|=", "&=", "~=", "==", "!=", "<=", ">=", "||", "&&", "#", "::", "->", "<<", ">>", "<<=", ">>=",
    "@", "$"
]

__commentaires_ligne_singulière_kuri := [ "//" ]
__commentaires_multi_lignes_kuri := [ ["/*", "*/"] ]

__mots_clés_kuri := [
    // Instructions
    "retourne", "si", "saufsi", "sinon", "boucle", "tantque", "répète", "pour", "dans", "arrête", "continue", "reprends", "discr", "sansarrêt", "diffère", "pousse_contexte", "tente", "piège", "nonatteignable",
    // Autres
    "struct", "énum", "énum_drapeau", "erreur", "eini_erreur", "importe", "charge", "fonc", "empl", "union", "nonsûr", "externe", "mémoire", "info_de", "init_de", "type_de", "taille_de", "opérateur", "comme",
    "vrai", "faux", "nul",
    // Types
    "bool", "chaine", "eini", "n8", "n16", "n32", "n64", "rien", "r16", "r32", "r64", "z8", "z16", "z32", "z64"
]

#portée_export

initialise_lexeuse_kuri :: fonc (lexeuse: *SimpleLexeuse)
{
    lexeuse.commentaires_ligne_singulière = __commentaires_ligne_singulière_kuri
    lexeuse.commentaires_multi_lignes = __commentaires_multi_lignes_kuri
    lexeuse.ponctuations = __ponctuation_kuri
    lexeuse.mots_clés = __mots_clés_kuri
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Lexeuse pour Python
 * \{ */

#portée_fichier

__ponctuation_python := [
    "+", "-", "[", "]", "(", ")", "{", "}", "/", "*", "=", ",", ":"
]

__commentaires_ligne_singulière_python := [ "#" ]
__commentaires_multi_lignes_python := [ ["\"\"\"", "\"\"\""], ["'''", "'''"] ]

__mots_clés_python := [
    "False", "None", "True", "and", "as", "assert", "async", "await", "break", "class", "continue", "def", "del", "elif", "else", "except", "finally", "for", "from", "global", "if", "import", "in", "is", "lambda", "nonlocal", "not", "or", "pass", "raise", "return", "try", "while", "with", "yield"
]

#portée_export

initialise_lexeuse_python :: fonc (lexeuse: *SimpleLexeuse)
{
    lexeuse.commentaires_ligne_singulière = __commentaires_ligne_singulière_python
    lexeuse.commentaires_multi_lignes = __commentaires_multi_lignes_python
    lexeuse.ponctuations = __ponctuation_python
    lexeuse.mots_clés = __mots_clés_python
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Lexeuse pour Rust
 * \{ */

#portée_fichier

__ponctuation_rust := [
    "+", "-", "[", "]", "(", ")", "{", "}", "/", "*", "=", "&", "|", "^", "%", "!", ":", ";", ",", "?", ".", "~", "<", ">",
    "+=", "++", "-=", "--", "*=", "/=", "%=", "^=", "|=", "&=", "~=", "==", "!=", "<=", ">=", "||", "&&", "#", "::", "->", "<<", ">>", "<<=", ">>="
]

__commentaires_ligne_singulière_rust := [ "//" ]
__commentaires_multi_lignes_rust := [ ["/*", "*/"] ]

/* https://doc.rust-lang.org/reference/keywords.html */
__mots_clés_rust := [
    "as", "break", "const", "continue", "crate", "else", "enum", "extern", "false", "fn", "for", "if", "impl", "in", "let", "loop", "match", "mod", "move", "mut", "pub", "ref", "return", "self", "Self", "static", "struct", "super", "trait", "true", "type", "unsafe", "use", "where", "while", "async", "await", "dyn", 
    // Reserved
    "abstract", "become", "box", "do", "final", "macro", "override", "priv", "typeof", "unsized", "virtual", "yield"
]

#portée_export

initialise_lexeuse_rust :: fonc (lexeuse: *SimpleLexeuse)
{
    lexeuse.commentaires_ligne_singulière = __commentaires_ligne_singulière_rust
    lexeuse.commentaires_multi_lignes = __commentaires_multi_lignes_rust
    lexeuse.ponctuations = __ponctuation_rust
    lexeuse.mots_clés = __mots_clés_rust
}

/** \} */
