libalembic :: #bibliothèque "alembic"

ArchiveCache :: struct #externe;

LectriceCache :: struct #externe;

eAbcPoliceErreur :: énum n32 {
    SILENCIEUSE
    BRUYANTE
    LANCE_EXCEPTION
}

eAbcStrategieLectureOgawa :: énum n32 {
    FLUX_DE_FICHIERS
    FICHIERS_MAPPES_MEMOIRE
}

ContexteOuvertureArchive :: struct {
    nombre_de_chemins :  fonc (*ContexteOuvertureArchive)(z32)
    chemin :  fonc (*ContexteOuvertureArchive,n64,**z8,*n64)(rien)
    police_erreur :  fonc (*ContexteOuvertureArchive)(eAbcPoliceErreur)
    nombre_de_flux_ogawa_desires :  fonc (*ContexteOuvertureArchive)(z32)
    strategie_lecture_ogawa :  fonc (*ContexteOuvertureArchive)(eAbcStrategieLectureOgawa)
    erreur_aucun_chemin :  fonc (*ContexteOuvertureArchive)(rien)
    erreur_archive_invalide :  fonc (*ContexteOuvertureArchive)(rien)
    donnees_utilisateur : *rien
}

ContexteTraverseArchive :: struct {
    extrait_nom_courant :  fonc (*ContexteTraverseArchive,*z8,n64)(rien)
    annule :  fonc (*ContexteTraverseArchive)(bool)
    donnees_utilisateur : *rien
}

TypeRappelReserveMemoire :: fonc (*rien, n64)(rien);

TypeRappelAjouteUnPoint :: fonc (*rien, r32, r32, r32)(rien);

TypeRappelAjouteTousLesPoints :: fonc (*rien, *r32, n64)(rien);

TypeRappelAjoutepolygone :: fonc (*rien, n64, *z32, z32)(rien);

TypeRappelAjouteTousLesPolygones :: fonc (*rien, *z32, n64)(rien);

TypeRappelReserveCoinsPolygone :: fonc (*rien, n64, z32)(rien);

TypeRappelAjouteCoinPolygone :: fonc (*rien, n64, z32)(rien);

TypeRappelAjouteTousLesCoins :: fonc (*rien, *z32, n64)(rien);

TypeRappelMarquePolygoneTrou :: fonc (*rien, z32)(rien);

TypeRappelMarquePlisVertex :: fonc (*rien, z32, r32)(rien);

TypeRappelMarquePlisAretes :: fonc (*rien, z32, z32, r32)(rien);

TypeRappelMarqueSchemaSubdivision :: fonc (*rien, *z8, n64)(rien);

TypeRappelMarquePropagationCoinsFaceVarying :: fonc (*rien, z32)(rien);

TypeRappelMarqueInterpolationFrontiereFaceVarying :: fonc (*rien, z32)(rien);

TypeRappelMarqueInterpolationFrontiere :: fonc (*rien, z32)(rien);

TypeRappelAjouteIndexPoint :: fonc (*rien, n64, n64)(rien);

ConvertisseusePolyMesh :: struct {
    donnees : *rien
    reserve_points : TypeRappelReserveMemoire
    ajoute_un_point : TypeRappelAjouteUnPoint
    ajoute_tous_les_points : TypeRappelAjouteTousLesPoints
    reserve_polygones : TypeRappelReserveMemoire
    ajoute_polygone : TypeRappelAjoutepolygone
    ajoute_tous_les_polygones : TypeRappelAjouteTousLesPolygones
    reserve_coin : TypeRappelReserveMemoire
    reserve_coins_polygone : TypeRappelReserveCoinsPolygone
    ajoute_coin_polygone : TypeRappelAjouteCoinPolygone
    ajoute_tous_les_coins : TypeRappelAjouteTousLesCoins
}

ConvertisseuseSubD :: struct {
    donnees : *rien
    reserve_points : TypeRappelReserveMemoire
    ajoute_un_point : TypeRappelAjouteUnPoint
    ajoute_tous_les_points : TypeRappelAjouteTousLesPoints
    reserve_polygones : TypeRappelReserveMemoire
    ajoute_polygone : TypeRappelAjoutepolygone
    ajoute_tous_les_polygones : TypeRappelAjouteTousLesPolygones
    reserve_coin : TypeRappelReserveMemoire
    reserve_coins_polygone : TypeRappelReserveCoinsPolygone
    ajoute_coin_polygone : TypeRappelAjouteCoinPolygone
    ajoute_tous_les_coins : TypeRappelAjouteTousLesCoins
    reserve_trous : TypeRappelReserveMemoire
    marque_polygone_trou : TypeRappelMarquePolygoneTrou
    reserve_plis_sommets : TypeRappelReserveMemoire
    marque_plis_vertex : TypeRappelMarquePlisVertex
    reserve_plis_aretes : TypeRappelReserveMemoire
    marque_plis_aretes : TypeRappelMarquePlisAretes
    marque_schema_subdivision : TypeRappelMarqueSchemaSubdivision
    marque_propagation_coins_face_varying : TypeRappelMarquePropagationCoinsFaceVarying
    marque_interpolation_frontiere_face_varying : TypeRappelMarqueInterpolationFrontiereFaceVarying
    marque_interpolation_frontiere : TypeRappelMarqueInterpolationFrontiere
}

ConvertisseusePoints :: struct {
    donnees : *rien
    reserve_points : TypeRappelReserveMemoire
    ajoute_un_point : TypeRappelAjouteUnPoint
    ajoute_tous_les_points : TypeRappelAjouteTousLesPoints
    reserve_index : TypeRappelReserveMemoire
    ajoute_index_point : TypeRappelAjouteIndexPoint
}

ConvertisseuseCourbes :: struct {
    donnees : *rien
}

ConvertisseuseNurbs :: struct {
    donnees : *rien
}

ConvertisseuseXform :: struct {
    donnees : *rien
}

ConvertisseuseFaceSet :: struct {
    donnees : *rien
}

ConvertisseuseLumiere :: struct {
    donnees : *rien
}

ConvertisseuseCamera :: struct {
    donnees : *rien
}

ConvertisseuseMateriau :: struct {
    donnees : *rien
}

ContexteLectureCache :: struct {
    initialise_convertisseuse_polymesh :  fonc (*ConvertisseusePolyMesh)(rien)
    initialise_convertisseuse_subd :  fonc (*ConvertisseuseSubD)(rien)
    initialise_convertisseuse_points :  fonc (*ConvertisseusePoints)(rien)
    initialise_convertisseuse_courbes :  fonc (*ConvertisseuseCourbes)(rien)
    initialise_convertisseuse_nurbs :  fonc (*ConvertisseuseNurbs)(rien)
    initialise_convertisseuse_xform :  fonc (*ConvertisseuseXform)(rien)
    initialise_convertisseuse_face_set :  fonc (*ConvertisseuseFaceSet)(rien)
    initialise_convertisseuse_lumiere :  fonc (*ConvertisseuseLumiere)(rien)
    initialise_convertisseuse_camera :  fonc (*ConvertisseuseCamera)(rien)
    initialise_convertisseuse_materiau :  fonc (*ConvertisseuseMateriau)(rien)
}

eTypeObjetAbc :: énum n32 {
    CAMERA
    COURBES
    FACE_SET
    LUMIERE
    MATERIAU
    NURBS
    POINTS
    POLY_MESH
    SUBD
    XFORM
}

AbcOptionsExport :: struct {
    exporte_hierarchie : bool
}

ConvertisseuseExportPolyMesh :: struct {
    donnnees : *rien
    nombre_de_points :  fonc (*ConvertisseuseExportPolyMesh)(n64)
    point_pour_index :  fonc (*ConvertisseuseExportPolyMesh,n64,*r32,*r32,*r32)(rien)
    nombre_de_polygones :  fonc (*ConvertisseuseExportPolyMesh)(n64)
    nombre_de_coins_polygone :  fonc (*ConvertisseuseExportPolyMesh,n64)(z32)
    coins_pour_polygone :  fonc (*ConvertisseuseExportPolyMesh,n64,*z32)(rien)
}

ConvertisseuseExportMateriau :: struct {
    donnees : *rien
    nom_cible :  fonc (*ConvertisseuseExportMateriau,**z8,*n64)(rien)
    type_nuanceur :  fonc (*ConvertisseuseExportMateriau,**z8,*n64)(rien)
    nom_nuanceur :  fonc (*ConvertisseuseExportMateriau,**z8,*n64)(rien)
    nom_sortie_graphe :  fonc (*ConvertisseuseExportMateriau,**z8,*n64)(rien)
    nombre_de_noeuds :  fonc (*ConvertisseuseExportMateriau)(n64)
    nom_noeud :  fonc (*ConvertisseuseExportMateriau,n64,**z8,*n64)(rien)
    type_noeud :  fonc (*ConvertisseuseExportMateriau,n64,**z8,*n64)(rien)
    nombre_entrees_noeud :  fonc (*ConvertisseuseExportMateriau,n64)(n64)
    nom_entree_noeud :  fonc (*ConvertisseuseExportMateriau,n64,n64,**z8,*n64)(rien)
    nombre_de_connexions :  fonc (*ConvertisseuseExportMateriau,n64,n64)(n64)
    nom_connexion_entree :  fonc (*ConvertisseuseExportMateriau,n64,n64,n64,**z8,*n64)(rien)
    nom_noeud_connexion :  fonc (*ConvertisseuseExportMateriau,n64,n64,n64,**z8,*n64)(rien)
}

eAbcPortee :: énum n32 {
    AUCUNE
    POINT
    PRIMITIVE
    POINT_PRIMITIVE
    OBJECT
}

ConvertisseuseImportAttributs :: struct {
    lis_tous_les_attributs :  fonc (*ConvertisseuseImportAttributs)(bool)
    nombre_attributs_requis :  fonc (*ConvertisseuseImportAttributs)(z32)
    nom_attribut_requis :  fonc (*ConvertisseuseImportAttributs,n64,**z8,*n64)(rien)
    ajoute_attribut :  fonc (*ConvertisseuseImportAttributs,*z8,n64,eAbcPortee)(*rien)
    information_portee :  fonc (*ConvertisseuseImportAttributs,*z32,*z32,*z32)(rien)
    ajoute_bool :  fonc (*rien,n64,*bool,z32)(rien)
    ajoute_n8 :  fonc (*rien,n64,*n8,z32)(rien)
    ajoute_n16 :  fonc (*rien,n64,*n16,z32)(rien)
    ajoute_n32 :  fonc (*rien,n64,*n32,z32)(rien)
    ajoute_n64 :  fonc (*rien,n64,*n64,z32)(rien)
    ajoute_z8 :  fonc (*rien,n64,*z8,z32)(rien)
    ajoute_z16 :  fonc (*rien,n64,*z16,z32)(rien)
    ajoute_z32 :  fonc (*rien,n64,*z32,z32)(rien)
    ajoute_z64 :  fonc (*rien,n64,*z64,z32)(rien)
    ajoute_r16 :  fonc (*rien,n64,*r16,z32)(rien)
    ajoute_r32 :  fonc (*rien,n64,*r32,z32)(rien)
    ajoute_r64 :  fonc (*rien,n64,*r64,z32)(rien)
    ajoute_chaine :  fonc (*rien,n64,*z8,n64)(rien)
}

/**
 * \brief Crée une archive pour lire des objets Alembic.
 *
 * Si l'archive ne peut être ouverte, retourne nul, et rapporte une erreur via le ctx.
 */
ABC_cree_archive :: fonc (ctx_kuri : *ContexteKuri, ctx : *ContexteOuvertureArchive) -> *ArchiveCache #externe libalembic

ABC_detruit_archive :: fonc (ctx : *ContexteKuri, archive : *ArchiveCache) -> rien #externe libalembic

ABC_traverse_archive :: fonc (ctx_kuri : *ContexteKuri, archive : *ArchiveCache, ctx : *ContexteTraverseArchive) -> rien #externe libalembic

ABC_cree_lectrice_cache :: fonc (ctx_kuri : *ContexteKuri, archive : *ArchiveCache, ptr_nom : *z8, taille_nom : n64) -> *LectriceCache #externe libalembic

ABC_detruit_lectrice :: fonc (ctx_kuri : *ContexteKuri, lectrice : *LectriceCache) -> rien #externe libalembic

ABC_lectrice_ajourne_donnees :: fonc (lectrice : *LectriceCache, donnees : *rien) -> rien #externe libalembic

ABC_lis_objet :: fonc (ctx_kuri : *ContexteKuri, contexte : *ContexteLectureCache, lectrice : *LectriceCache, temps : r64) -> rien #externe libalembic

ABC_lis_attributs :: fonc (ctx_kuri : *ContexteKuri, lectrice : *LectriceCache, convertisseuse : *ConvertisseuseImportAttributs, temps : r64) -> rien #externe libalembic

