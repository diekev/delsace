importe Géométrie
importe Math

Caméra2D :: struct {
    /* Dimension de la fenêtre en pixels. */
    hauteur := 0 @mutable
    largeur := 0 @mutable

    /* Position mondiale. */
    pos_x := 0.0 @mutable
    pos_y := 0.0 @mutable

    /* Zoom. */
    zoom := 1.0 @mutable

    monde_vers_caméra: Mat4r
    projection: Mat4r

    besoin_ajournement := vrai
}

ajourne_matrice :: fonc (empl caméra: *Caméra2D)
{
    saufsi besoin_ajournement {
        retourne
    }

    position := Vec3(pos_x, pos_y, 1.0)
    cible := Vec3(pos_x, pos_y, 0.0)
    vecteur_haut := Vec3(0.0, 1.0, 0.0)

    monde_vers_caméra = mire(position, cible, vecteur_haut)

    largeur_ := largeur comme r32 / zoom
    hauteur_ := hauteur comme r32 / zoom
    projection = crée_matrice_projection_orthographique(0.0, largeur_, 0.0, hauteur_, -1.0, 1.0)

    besoin_ajournement = faux
} @Python "méthode"

modèle_vue_projection :: fonc (empl caméra: *Caméra2D) -> Mat4r
{
    retourne projection * monde_vers_caméra
}

définis_dimension_fenêtre :: fonc (caméra: *Caméra2D, largeur: z32, hauteur: z32)
{
    caméra.largeur = largeur
    caméra.hauteur = hauteur
    caméra.besoin_ajournement = vrai
}

ratio_d_aspect :: fonc (caméra: *Caméra2D) -> r32
{
    retourne (caméra.largeur comme r32) / (caméra.hauteur comme r32)
}

applique_zoom :: fonc (empl caméra: *Caméra2D, delta: r32, où: Point2D(z32))
{
    quantité := si delta >= 0.0 {
        Constantes(r32).PHI
    }
    sinon {
        Constantes(r32).PHI_INV
    }

    /* Zoom vers la souris. */
    vieux_zoom := caméra.zoom
    neuf_zoom := vieux_zoom * quantité

    taille_vue := Vec2(caméra.largeur comme r32, caméra.hauteur comme r32)
    souris := Vec2(où.x comme r32, où.y comme r32)

    différence_pixels := taille_vue / vieux_zoom - taille_vue / neuf_zoom
    ratio := souris / taille_vue

    delta_position := différence_pixels * ratio

    pos_x += delta_position.x
    pos_y += delta_position.y
    zoom = neuf_zoom
    besoin_ajournement = vrai
}

applique_pan :: fonc (empl caméra: *Caméra2D, dx: r32, dy: r32)
{
    pos_x -= dx / zoom
    pos_y -= dy / zoom
    besoin_ajournement = vrai
}

/* Retourne le niveau MIP d'une image qui devrait être affiché selon les paramètres de la caméra.
 * Le niveau 0 est considéré comme étant l'image de base (2^0 = 1). */
donne_niveau_image_mip :: fonc (empl caméra: *Caméra2D, largeur_image: z64) -> z32
{
    si largeur == 0 || zoom == 0.0 {
        retourne 0
    }

    largeur_caméra := largeur comme r32 / zoom
    ratio_image_caméra :=  min(1.0, (largeur_image comme r32) / largeur_caméra)
    niveau_mip_map := (1.0 / ratio_image_caméra + 0.5) comme z32
    retourne 31 - intrinsèque_compte_zéros_en_tête(niveau_mip_map comme n32)
}
