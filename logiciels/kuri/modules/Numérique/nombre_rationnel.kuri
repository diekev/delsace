// Nombre fractionnel nous permettant de faire des calculs sur des
// fractions, afin d'être plus précis que des nombres à point flottant.
// https://iquilezles.org/www/articles/floatingbar/floatingbar.htm

importe GlibC

NombreRationnel :: struct {
    N: n32
    D: n32
    s: bool
}

construit_nombre_rationnel :: fonc(n: n32, d: n32, positif: bool) -> NombreRationnel
{
    dyn r : NombreRationnel
    r.N = n
    r.D = d
    r.s = !positif

    retourne r
}

ajoute :: fonc(a: NombreRationnel, b: NombreRationnel) -> NombreRationnel
{
    // augmente la taille des types pour éviter les problèmes de surflot
    a_n := transtype(a.N: n64)
    a_d := transtype(a.D: n64)
    b_n := transtype(b.N: n64)
    b_d := transtype(b.D: n64)

    dyn r_N : n64
    r_N0 := a_n * b_d
    r_N1 := a_d * b_n

    dyn r : NombreRationnel

    si transtype(a.s: z8) == transtype(b.s: z8) {
        r_N = r_N0 + r_N1
        r.s = a.s
    }
    sinon si r_N0 <= r_N1 {
        r_N = r_N1 - r_N0
        r.s = vrai
    }
    sinon {
        r_N = r_N0 - r_N1
        r.s = vrai
    }

    dyn r_D : n64 = a_d * b_d

    // réduit la fraction selon le plus grand dénominateur commun,
    // afin d'éviter des problèmes de surflot
    dc := pgdc(r_N, r_D)

    r_N = r_N / dc
    r_D = r_D / dc

    // normalise en décalant les valeurs selon le nombre de bits 0 en fin de mot
    nb_N := nombre_de_bits_zéro_en_fin(r_N)
    nb_D := nombre_de_bits_zéro_en_fin(r_D)

    si nb_N != transtype(0: n32) && nb_D != transtype(0: n32) {
        si nb_N < nb_D {
            r_N = r_N >> nb_N
            r_D = r_D >> nb_N
        }
        sinon {
            r_N = r_N >> nb_D
            r_D = r_D >> nb_D
        }
    }

    // restaure la précision
    r.N = transtype(r_N: n32)
    r.D = transtype(r_D: n32)

    retourne r
}

soustrait :: fonc(a: NombreRationnel, b: NombreRationnel) -> NombreRationnel
{
    dyn tmp := b
    tmp.s = vrai

    retourne ajoute(a, tmp)
}

multiplie :: fonc(a: NombreRationnel, b: NombreRationnel) -> NombreRationnel
{
    // augmente la taille des types pour éviter les problèmes de surflot
    a_n := transtype(a.N: n64)
    a_d := transtype(a.D: n64)
    b_n := transtype(b.N: n64)
    b_d := transtype(b.D: n64)

    dyn r_N := a_n * b_n
    dyn r_D := a_d * b_d

    // réduit la fraction selon le plus grand dénominateur commun,
    // afin d'éviter des problèmes de surflot
    dc := pgdc(r_N, r_D)

    r_N = r_N / dc
    r_D = r_D / dc

    // normalise en décalant les valeurs selon le nombre de bits 0 en fin de mot
    nb_N := nombre_de_bits_zéro_en_fin(r_N)
    nb_D := nombre_de_bits_zéro_en_fin(r_D)

    si nb_N != transtype(0: n32) && nb_D != transtype(0: n32) {
        si nb_N < nb_D {
            r_N = r_N >> nb_N
            r_D = r_D >> nb_N
        }
        sinon {
            r_N = r_N >> nb_D
            r_D = r_D >> nb_D
        }
    }

    dyn r : NombreRationnel
    // restaure la précision
    r.N = transtype(r_N: n32)
    r.D = transtype(r_D: n32)
    r.s = (a.s || b.s) && !(a.s && b.s)

    retourne r
}

divise :: fonc(a: NombreRationnel, b: NombreRationnel) -> NombreRationnel
{
    dyn tmp := b
    tmp.N = b.D
    tmp.D = b.N

    retourne multiplie(a, tmp)
}

imprime_nombre_rationnel :: fonc(a: NombreRationnel) -> rien
{
    si a.s {
        printf("- %u / %u\n".pointeur, a.N, a.D)
    }
    sinon {
        printf("%u / %u\n".pointeur, a.N, a.D)
    }
}

// https://en.wikipedia.org/wiki/Binary_GCD_algorithm
pgdc_récursif :: fonc(u: n64, v: n64) -> n64
{
    // cas simples (terminaison)
    si u == v {
        retourne u
    }

    si u == _0 {
        retourne v
    }

    si v == _0 {
        retourne u
    }

    // cherche des facteurs de 2
    si (~u & _1) != _0 { // u est pair
        si (v & _1) != _0 { // v est impair
            retourne pgdc_récursif(u >> _1, v)
        }

        retourne pgdc_récursif(u >> _1, v >> _1) << _1
    }

    si (~v & _1) != _0 { // u est impair, v est pair
        retourne pgdc_récursif(u, v >> _1)
    }

    // réduis l'argument le plus grand
    si (u > v) {
        retourne pgdc_récursif((u - v) >> _1, v)
    }

    retourne pgdc_récursif((v - u) >> _1, u)
}

pgdc :: fonc(dyn u: n64, dyn v: n64) -> n64
{
    si u == v {
        retourne u
    }

    // GCD(0,v) == v GCD(u,0) == u, GCD(0,0) == 0
    si u == _0 {
        retourne v
    }

    si v == _0 {
        retourne u
    }

    dyn shift : n64 = _0

    //Let shift := lg K, where K is the greatest power of 2
    // dividing both u and v.
    tantque (((u | v) & _1) == _0) {
        shift = shift + _1
        u = u >> _1
        v = v >> _1
    }

    tantque ((u & _1) == _0) {
        u = u >> _1
    }

    // From here on, u is always odd. */
    répète {
        // remove all factors of 2 in v -- they are not common */
        //   note: v is not zero, so while will terminate */
        tantque ((v & _1) == _0) {
            v = v >> _1
        }

        // Now u and v are both odd. Swap if necessary so u <= v,
        //    then set v = v - u (which is even). For bignums, the
        //     swapping is just pointer movement, and the subtraction
        //      can be done in-place. */
        si u > v {
            t := v
            v = u
            u = t
        }

        v = v - u // Here v >= u.
    } tantque (v != _0)

    // restore common factors of 2 */
    retourne u << shift
}

nombre_de_bits_zéro_en_fin :: fonc(dyn i: n64) -> n32
{
    si i == _0 {
        retourne transtype(64: n32)
    }

    _63 := transtype(63: n64)
    _32 := transtype(32: n64)
    _16 := transtype(16: n64)
    _8 := transtype(8: n64)
    _4 := transtype(4: n64)
    _2 := transtype(2: n64)

    dyn n := _63
    dyn y : n64

    y = i << _32; si y != _0 { n = n - _32; i = y; }
    y = i << _16; si y != _0 { n = n - _16; i = y; }
    y = i <<  _8; si y != _0 { n = n -  _8; i = y; }
    y = i <<  _4; si y != _0 { n = n -  _4; i = y; }
    y = i <<  _2; si y != _0 { n = n -  _2; i = y; }

	retourne transtype(n - ((i << _1) >> _63): n32)
}
