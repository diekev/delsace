/* Diverses fonctions de travail sur les nombres. */

probabilité_n_est_premier :: fonc (n: n64) -> r64
{
    si n < 2 {
        retourne 0.0
    }

    retourne 1.0 / log(n comme r64)
}

est_divisible_par :: fonc (n: n64, d: n64) -> bool
{
    retourne n % d == 0
}

/* détermine si un nombre est premier via force brute */
est_premier :: fonc (n: n64) -> bool
{
    /* on peut améliorer la chose en ne considérant que si un nombre premier le divise
     * et en ne considérant que les nombres premiers inférieurs à la racine carrée du nombre
     * on peut utiliser les tests de Lucas
     */
    pour 2 ... n - 1 {
        si est_divisible_par(n, it) {
            retourne faux
        }
    }

    retourne vrai
}

est_puissance_de_2 :: fonc (n: n64) -> bool
{
    retourne (n & (n - 1)) == 0
}

est_un_moins_une_puissance_de_2 :: fonc (n: n64) -> bool
{
    retourne est_puissance_de_2(n + 1)
}

est_premier_de_mersenne :: fonc (n: n64) -> bool
{
    /* Un nombre premier de Mersenne a la forme 2^P - 1 */
    si !est_un_moins_une_puissance_de_2(n) {
        retourne faux
    }

    retourne est_premier(n)
}

trouve_premier_bit :: fonc (n: n64) -> n64
{
    position := 0

    pour 0 comme n64 ... 63 comme n64 {
        si (n & (1 << it)) != 0 {
            retourne it
        }
    }

    retourne 0
}

// Après n == 92, un n64 ne peut contenir le résultat
n_ième_nombre_de_lucas :: fonc (n: n64) -> n64
{
    précédent : n64 = 2
    courant : n64 = 1

    pour n - 1 {
        tmp := précédent
        précédent = courant
        courant += tmp
    }

    retourne courant
}

// Après n == 6, un n64 ne peut contenir le résultat
n_ième_nombre_de_lucas_lehmer :: fonc (n: n64) -> n64
{
    courant : n64 = 4

    pour n - 1 {
        courant *= courant
        courant -= 2
    }

    retourne courant
}

n_ième_nombre_de_lucas_lehmer_mod_m :: fonc (n: n64, m: n64) -> n64
{
    courant : n64 = 4

    si n <= 1 {
        retourne courant % m
    }

    pour n - 1 {
        courant *= courant
        courant -= 2
        courant %= m
    }

    retourne courant
}

/* Un nombre est peut-être premier si n|Lucas(n) - 1 */
est_premier_méthode_de_lucas :: fonc (n: n64) -> bool
{
    nombre_de_lucas := n_ième_nombre_de_lucas(n)

    si !est_divisible_par(nombre_de_lucas - 1, n) {
        retourne faux
    }

    retourne est_premier(n)
}

nombre_de_mersenne_depuis_puissance :: fonc (p: n64) -> n64
{
    retourne (1 << p) - 1
}

/* Un nombre n = 2^p - 1 est premier si le nombre Lucas-Lehmer(p - 1) est divisible par n. */
est_premier_de_mersenne_puissance_seulement :: fonc (p: n64) -> bool
{
    n := nombre_de_mersenne_depuis_puissance(p)
    nombre_de_lucas := n_ième_nombre_de_lucas_lehmer_mod_m(p - 1, n)
    retourne nombre_de_lucas == 0
}

// rapide en ce que nous n'utilisons pas la force brute pour les nombres de Mersenne
// il y a beaucoup à améliorer
est_premier_rapide :: fonc (n: n64) -> bool
{
    si n == 0 {
        retourne faux
    }

    si n <= 3 {
        retourne vrai
    }

    si est_un_moins_une_puissance_de_2(n) {
        puissance := trouve_premier_bit(n - 1)
        retourne est_premier_de_mersenne_puissance_seulement(puissance)
    }

    retourne est_premier(n)
}

// ---------------------------------------

// multiplie les chiffres du nombre n entre eux
// p.e pour 123 retourne 1 * 2 * 3
multiplication_des_chiffres :: fonc (n: n64) -> n64
{
    résultat : n64 = 1

    tantque n != 0 {
        chiffre := n % 10
        résultat *= chiffre
        n /= 10
    }

    retourne résultat
}

// somme les chiffres du nombre n entre eux
// p.e pour 123 retourne 1 + 2 + 3
somme_des_chiffres :: fonc (n: n64) -> n64
{
    résultat : n64 = 0

    tantque n != 0 {
        chiffre := n % 10
        résultat += chiffre
        n /= 10
    }

    retourne résultat
}

// inverses l'ordre des chiffres du nombre n
// p.e pour 123 retourne 321
inverse_chiffres :: fonc (n: n64) -> n64
{
    résultat : n64 = 0

    tantque n != 0 {
        chiffre := n % 10
        résultat *= 10
        résultat += chiffre
        n /= 10
    }

    retourne résultat
}

// retourne le nombre de fois que nous pouvons multiplier
// les chiffres du nombre n jusqu'à l'obtention d'un nombre
// inférieur à 10
// p.e. 1789 -> 1 * 7 * 8 * 9 ->
//       504 -> 5 * 0 * 4 ->
//         0
// retournera 2, car l'opération est effecutuée 2 fois
résistance_multiplicative :: fonc (n: n64) -> n64
{
    répétitions : n64 = 0

    tantque n > 10 {
        n = multiplication_des_chiffres(n)
        répétitions += 1
    }

    retourne répétitions
}

// retourne le nombre de chiffres du nombre passé en paramètre
magnitude :: fonc (n: n64) -> n64
{
    résultat : n64 = 0

    tantque n != 0 {
        résultat += 1
        n /= 10
    }

    retourne résultat
}

/*
    À CONSIDÉRER : bibliothèque de nombre avec des bases
    Nombre :: struct {
        valeur: n64
        base: n64
    }
*/
