importe Fondation

/* Réprésentation d'un nombre « infini », c'est-à-dire un nombre qui n'a pas de limite quant au nombre de
 * de chiffres qu'il peut posséder.
 *
 * L'implémentation est rudimentaire et inefficiente, mais reste utile pour commencer à avoir ce
 * genre de structures dans la language.
 */

NombreInfini :: struct {
    chiffres : []n8
}

factorielle :: fonc (n: NombreInfini) -> NombreInfini
{
    si n == 0 {
        retourne crée_nombre_infini(0)
    }

    résultat := crée_nombre_infini(1)

    répète {
        résultat *= n
        n -= 1
    } tantque n != 0

    retourne résultat
}

crée_nombre_infini :: fonc (chn: n64) -> NombreInfini
{
    résultat : NombreInfini

    tableau_ajoute(*résultat.chiffres, chn comme n8)

    retourne résultat
}

crée_nombre_infini :: fonc (chn: chaine) -> NombreInfini
{
    résultat : NombreInfini

    pour chn {
        chiffre := (it - '0') comme n8
        tableau_ajoute(*résultat.chiffres, chiffre)
    }

    retourne résultat
}

chiffre_pour_index :: fonc (n: NombreInfini, index: z64) -> n8
{
    si index >= n.chiffres.taille {
        retourne 0
    }

    retourne n.chiffres[index]
}

nombre_de_chiffres :: fonc (n: NombreInfini) -> z64
{
    retourne n.chiffres.taille
}

chaine_depuis_nombre_infini :: fonc (n: NombreInfini) -> chaine
{
    enchaineuse: Enchaineuse
    initialise_enchaineuse(*enchaineuse)
    diffère détruit_tampons(*enchaineuse)

    si n.chiffres {
        pour n.chiffres {
            imprime_dans_enchaineuse(*enchaineuse, "%", it)
        }
    }
    sinon {
        ajoute_au_tampon(*enchaineuse, "0")
    }

    retourne chaine_depuis_enchaineuse(*enchaineuse)
}

opérateur + :: fonc (n0: NombreInfini, n1: NombreInfini) -> NombreInfini
{
    résultat : NombreInfini

    tableau_inverse(*n0.chiffres)
    tableau_inverse(*n1.chiffres)

    diffère {
        tableau_inverse(*n0.chiffres)
        tableau_inverse(*n1.chiffres)
    }

    taille := n0.nombre_de_chiffres()
    si n1.nombre_de_chiffres() > taille {
        taille = n1.nombre_de_chiffres()
    }

    retenue : n8

    pour taille {
        c0 := n0.chiffre_pour_index(index_it)
        c1 := n1.chiffre_pour_index(index_it)

        tmp := c0 + c1 + retenue

        si tmp > 10 {
            retenue = tmp / 10
            tmp %= 10
        }
        sinon {
            retenue = 0
        }

        tableau_ajoute(*résultat.chiffres, tmp)
    }

    si retenue != 0 {
        tableau_ajoute(*résultat.chiffres, retenue)
    }

    tableau_inverse(*résultat.chiffres)

    retourne résultat
}

opérateur + :: fonc (n0: NombreInfini, n1: n64) -> NombreInfini
{
    résultat : NombreInfini

    si n0.nombre_de_chiffres() == 0 {
        tantque n1 != 0 {
            tmp := n1 % 10
            n1 /= 10
            tableau_ajoute(*résultat.chiffres, tmp comme n8)
        }

        tableau_inverse(*résultat.chiffres)
        retourne résultat
    }

    résultat.chiffres = tableau_copie(n0.chiffres)

    tableau_inverse(*résultat.chiffres)

    retenue := n1
    index := 0

    répète {
        tmp := résultat.chiffres[index] + retenue

        si tmp >= 10 {
            retenue = tmp / 10
            tmp %= 10
        }
        sinon {
            retenue = 0
        }

        résultat.chiffres[index] = tmp comme n8
        index += 1
    } tantque retenue != 0 && index < résultat.nombre_de_chiffres()

    tantque retenue != 0 {
        tmp := retenue % 10
        retenue /= 10
        tableau_ajoute(*résultat.chiffres, tmp comme n8)
    }

    tableau_inverse(*résultat.chiffres)

    retourne résultat
}

opérateur - :: fonc (n0: NombreInfini, n1: NombreInfini) -> NombreInfini
{
    résultat : NombreInfini

    taille := n0.nombre_de_chiffres()
    si n1.nombre_de_chiffres() > taille {
        // nombres négatifs non supportés
        retourne résultat
    }

    tableau_inverse(*n0.chiffres)
    tableau_inverse(*n1.chiffres)

    diffère {
        tableau_inverse(*n0.chiffres)
        tableau_inverse(*n1.chiffres)
    }

    emprunt : n8

    pour taille {
        c0 := n0.chiffre_pour_index(index_it)
        c1 := n1.chiffre_pour_index(index_it)

        tmp := 10 + c0 - c1 - emprunt

        si tmp < 10 {
            emprunt = 1

            si index_it == 0 {
                // nous avons une opération de type : 1 - 2, puisque nous ne supportons
                // pas les nombre négatifs, met l'emprunt à zéro, et n'ajoute pas de chiffres
                // au résultat afin de pouvoir de renvoier un résultat de 0
                emprunt = 0
                continue
            }
        }
        sinon {
            emprunt = 0
            tmp -= 10
        }

        tableau_ajoute(*résultat.chiffres, tmp)
    }

    supprime_zéro_en_début(*résultat)

    tableau_inverse(*résultat.chiffres)

    retourne résultat
}

opérateur - :: fonc (n0: NombreInfini, n1: n64) -> NombreInfini
{
    //  À FAIRE : nombre inférieur à 0

    si n1 >= 10 {
        imprime("les soustractions > 10 ne sont pas définies pour les NombreInfini\n")
        retourne n0
    }

    résultat : NombreInfini

    si n0.nombre_de_chiffres() == 0 {
        retourne résultat
    }

    résultat.chiffres = tableau_copie(n0.chiffres)

    tableau_inverse(*résultat.chiffres)

    emprunt := n1 comme n8
    index := 0

    répète {
        tmp := 10 + résultat.chiffres[index] - emprunt

        si tmp < 10 {
            emprunt = 1
        }
        sinon {
            emprunt = 0
            tmp -= 10
        }

        résultat.chiffres[index] = tmp
        index += 1
    } tantque emprunt == 1 && index < résultat.nombre_de_chiffres()

    supprime_zéro_en_début(*résultat)

    tableau_inverse(*résultat.chiffres)

    retourne résultat
}

supprime_zéro_en_début :: fonc (n: *NombreInfini)
{
    tantque n.chiffres.taille > 1 && n.chiffres[n.chiffres.taille - 1] == 0 {
        n.chiffres.taille -= 1
    }
}

opérateur * :: fonc (n0: NombreInfini, n1: NombreInfini) -> NombreInfini
{
    résultat : NombreInfini

    pour n1.chiffres {
        tmp := n0 * it

        si index_it > 0 {
            tableau_ajoute(*résultat.chiffres, 0)
        }

        résultat += tmp
    }

    retourne résultat
}

opérateur * :: fonc (n0: NombreInfini, n2: n64) -> NombreInfini
{
    résultat : NombreInfini
    résultat.chiffres = tableau_copie(n0.chiffres)

    tableau_inverse(*résultat.chiffres)

    retenue : n64
    index := 0

    répète {
        tmp := résultat.chiffres[index] * n2 + retenue

        si tmp >= 10 {
            retenue = tmp / 10
            tmp %= 10
        }
        sinon {
            retenue = 0
        }

        résultat.chiffres[index] = tmp comme n8
        index += 1
    } tantque index < résultat.nombre_de_chiffres()

    tantque retenue != 0 {
        tmp := retenue % 10
        retenue /= 10
        tableau_ajoute(*résultat.chiffres, tmp comme n8)
    }

    tableau_inverse(*résultat.chiffres)

    retourne résultat
}

opérateur / :: fonc (n0: NombreInfini, n1: NombreInfini) -> NombreInfini
{

}

opérateur == :: fonc (n0: NombreInfini, n1: n64) -> bool
{
    si n1 >= 10 {
        retourne faux
    }

    si n0.chiffres[n0.chiffres.taille - 1] != n1 {
        retourne faux
    }

    pour n0.chiffres {
        si it != n1 {
            retourne faux
        }
    }

    retourne vrai
}

opérateur != :: fonc (n0: NombreInfini, n1: n64) -> bool
{
    retourne !(n0 == n1)
}
