importe Fondation

est_caractère_réservé_url :: fonc (c: z8) -> bool
{
    chn :: "&$+,/:;=?@"
    pour chn {
        si it == c {
            retourne vrai
        }
    }

    retourne faux
}

est_caractère_nonsûr_url :: fonc (c: z8) -> bool
{
    chn :: " \"<>#%{}|\\^~[]`"
    pour chn {
        si it == c {
            retourne vrai
        }
    }

    retourne faux
}

caractères_hex_minuscules :: "0123456789abcdef"
caractères_hex_majuscules :: "0123456789ABCDEF"

encode_format_url :: fonc (texte: chaine) -> chaine
{
    résultat : chaine


    pour texte {
        si est_caractère_réservé_url(it) || est_caractère_nonsûr_url(it) {
            chaine_ajoute(*résultat, '%')
            chaine_ajoute(*résultat, caractères_hex_minuscules[((it comme z32) / 16)])
            chaine_ajoute(*résultat, caractères_hex_minuscules[((it comme z32) % 16)])
        }
        sinon {
            chaine_ajoute(*résultat, it)
        }
    }

    retourne résultat
}

encode_format_url :: fonc (enchaineuse: *Enchaineuse, texte: chaine)
{
    //caractères_réservés := "\r\n !#$&'()*+,/:;=?@[]"

    caractères_non_réservés :: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~"


    pour texte {
        si it == ' ' {
            ajoute_au_tampon(enchaineuse, "+")
        }
        sinon {
            pour c dans caractères_non_réservés {
                si c == it {
                    ajoute_au_tampon(enchaineuse, it)
                    arrête
                }
            }
            sansarrêt {
                a := (it comme n8 >> 4) & 0xff
                // À FAIRE(langage) : n8 & 0xff donne des valeurs étranges
                b := (it comme n8) % 16
                // À FAIRE(enchaineuse, langage) : type pour les caractères
                ajoute_au_tampon(enchaineuse, "%")
                ajoute_au_tampon(enchaineuse, caractères_hex_majuscules[a])
                ajoute_au_tampon(enchaineuse, caractères_hex_majuscules[b])
            }
        }
    }
}

résoud_échappement_url :: fonc (chn: chaine) -> chaine
{
    nchn : chaine

    i := 0

    tantque i < chn.taille {
        si chn[i] == '%' {
            i += 1

            si i + 2 >= chn.taille {
                arrête
            }

            c := chn[i]

            v : z8

            si 'a' <= c <= 'f' {
                v = (c - 'a') + 10
            }
            sinon si 'A' <= c <= 'F' {
                v = (c - 'a') + 10
            }
            sinon si '0' <= c <= '9' {
                v = (c - '0')
            }

            i += 1
            c = chn[i]

            v *= 16

            si 'a' <= c <= 'f' {
                v += (c - 'a') + 10
            }
            sinon si 'A' <= c <= 'F' {
                v += (c - 'a') + 10
            }
            sinon si '0' <= c <= '9' {
                v += (c - '0')
            }

            chaine_ajoute(*nchn, v)
            i += 1
        }
        sinon {
            chaine_ajoute(*nchn, chn[i])
            i += 1
        }
    }

    retourne nchn
}

résoud_échappement_url_localement :: fonc (chn: &chaine)
{
    index_d_insertion := 0
    index_courant := 0

    tantque index_courant < chn.taille {
        si chn[index_courant] == '%' {
            index_courant += 1

            si index_courant + 1 >= chn.taille {
                arrête
            }

            c := chn[index_courant]

            v : z8

            si 'a' <= c <= 'f' {
                v = (c - 'a') + 10
            }
            sinon si 'A' <= c <= 'F' {
                v = (c - 'A') + 10
            }
            sinon si '0' <= c <= '9' {
                v = (c - '0')
            }

            index_courant += 1
            c = chn[index_courant]

            v *= 16

            si 'a' <= c <= 'f' {
                v += (c - 'a') + 10
            }
            sinon si 'A' <= c <= 'F' {
                v += (c - 'A') + 10
            }
            sinon si '0' <= c <= '9' {
                v += (c - '0')
            }

            chn[index_d_insertion] = v
        }
        // Google utilise des + pour les espaces, à voir si c'est standard.
        sinon si chn[index_courant] == '+' {
            chn[index_d_insertion] = ' '
        }
        sinon {
            chn[index_d_insertion] = chn[index_courant]
        }

        index_courant += 1
        index_d_insertion += 1
    }

    chn.taille = index_d_insertion
}
