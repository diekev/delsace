/*
    Bibliothèque de réseautage TCP.

    La bibliothèque fonctionne de manière asynchrone où une boucle d'évènements
    dispatche les connexions entrante ou sortante.

    Il n'est pour l'instant possible que de créer des clients.

 */

importe Fondation
importe GlibC
importe OpenSSL
importe POSIX
importe SysFichier
importe Internet
importe Réseau
importe Temps

crée_prise_pour_écoute :: fonc (contexte_: *Contexte, adresse_ip: AdresseIPv4, port: n16, connexions_max: z32, $TypeDonnées: type_de_données) -> *Prise
{
    saufsi contexte_ {
        retourne nul
    }

    // imprime("crée_prise_pour_écoute\n")
    fichier := tente ouvre_connexion_pour_écoute(adresse_ip, port, connexions_max) piège err {
        // imprime("erreur lors de l'ouverture d'une connexion pour écoute : %\n", err)
        retourne nul
    }

    prise := crée_prise_interne(contexte_, fichier, info_de(TypeDonnées))
    prise.type = TypePrise.SEMI_PRISE

    // À FAIRE : SSL

    si !ajoute_prise(contexte_.boucle_prises, prise, EPOLL_EVENTS.EPOLLIN) {
        prise.ferme(prise)
        retourne nul
    }

    retourne prise
}

crée_prise_connexion :: fonc (contexte_: *Contexte, uri: &URI, $TypeDonnées: type_de_données) -> *Prise
{
    saufsi contexte_ {
        retourne nul
    }

    // imprime("crée_prise_connexion\n")

    port := port_pour_uri(uri)

    fichier := tente ouvre_connexion_serveur(uri.hôte, port, vrai) piège err {
        // imprime("erreur lors de l'ouverture d'une connexion: %\n", err)
        retourne nul
    }

    prise := crée_prise_interne(contexte_, fichier, info_de(TypeDonnées))
    prise.type = TypePrise.SEMI_PRISE

    // À FAIRE : meilleure manière de déterminer si SSL doit être utilisé
    si port == 443 || port == 465 {
        saufsi prise.initialise_contexte_ssl_client() {
            prise.ferme()
            retourne nul
        }
    }

    si !ajoute_prise(contexte_.boucle_prises, prise, EPOLL_EVENTS.EPOLLOUT) {
        prise.ferme()
        retourne nul
    }

    retourne prise
}

crée_chronomètre :: fonc (ctx: *Contexte, interval: z32, commence_dans: z32, rappel: fonc(*Contexte)(rien)) -> *Prise
{
    saufsi ctx {
        retourne nul
    }

    fd := timerfd_create(CLOCK_REALTIME, TFD_NONBLOCK)

    si fd < 0 {
        // imprime("Impossible de créer le fd pour le chronomètre !\n")
        retourne nul
    }

    nouvelle_valeur : itimerspec = ---
    nouvelle_valeur.it_interval = timespec_depuis_ms(interval)
    nouvelle_valeur.it_value = timespec_depuis_ms(commence_dans)

    si timerfd_settime(fd, 0, *nouvelle_valeur, nul) == -1 {
        // imprime("Impossible de mettre en place timerfd_settime !\n")
        retourne nul
    }

    fichier := Fichier(fd)
    prise := crée_prise_interne(ctx, fichier, info_de(fonc(*Contexte)(rien)))
    prise.type = TypePrise.RAPPEL
    ptr_fonc := prise.données_utilisateur(fonc(*Contexte)(rien))
    mémoire(ptr_fonc) = rappel

    si !ajoute_prise(ctx.boucle_prises, prise, EPOLL_EVENTS.EPOLLIN) {
        // imprime("Impossible d'ajouter la prise !\n")
        détruit_prise(prise)
        retourne nul
    }

    retourne prise
}

crée_prise_interne :: fonc (contexte_: *Contexte, fichier: Fichier, info_données_externes: *InfoType) -> *Prise
{
    taille_à_loger := (taille_de(Prise) + info_données_externes.taille_en_octet) comme z64
    mém_prise := loge_mémoire(taille_à_loger, info_de(Prise), PositionCodeSource())

    prise := mém_prise comme *Prise
    init_de(Prise)(prise)

    prise.fichier = fichier
    prise.contexte_ = contexte_
    prise.taille_mémoire = taille_à_loger
    prise.info_utilisateur = info_données_externes

    retourne prise
}

ajoute_prise :: fonc (boucle_prises: *Boucle, prise: *Prise, évènements: EPOLL_EVENTS) -> bool
{
    // imprime("ajoute une prise.\n")
    ev: epoll_event
    ev.events = évènements | EPOLL_EVENTS.EPOLLET
    ev.data.ptr = prise

    si (epoll_ctl(boucle_prises.fd, EPOLL_CTL_OP.ADD, prise.fichier.desc, *ev) == -1) {
        // imprime("[epoll_ctl] impossible de créer un control pour la prise !\n")
        retourne faux
    }

    retourne vrai
}

change_évènement :: fonc (prise: *Prise, boucle_prises: *Boucle, évènement: EPOLL_EVENTS)
{
    // imprime("change_évènement.\n")
    ev: epoll_event
    ev.events = évènement | EPOLL_EVENTS.EPOLLET
    ev.data.ptr = prise

    si (epoll_ctl(boucle_prises.fd, EPOLL_CTL_OP.MOD, prise.fichier.desc, *ev) == -1) {
        // imprime("[epoll_ctl] impossible de changer un control pour la prise !\n")
        retourne
    }
}

enlève_prise :: fonc (boucle_prises: *Boucle, prise: *Prise)
{
    // imprime("enlève_prise.\n")
    ev: epoll_event
    si (epoll_ctl(boucle_prises.fd, EPOLL_CTL_OP.DEL, prise.fichier.desc, *ev) == -1) {
        // imprime("[epoll_ctl] impossible de changer un control pour la prise !\n")
        retourne
    }
}

Boucle :: struct {
    MAX_EVENTS :: 1024
    évènements: [MAX_EVENTS]epoll_event
    fd: z32

    prises_fermées: *Prise

    stop := faux
}

crée_boucle :: fonc () -> *Boucle
{
    fd := epoll_create1(0)

    si fd == -1 {
        //imprime("[epoll_create1] impossible de créer l'epoll !\n")
        retourne nul
    }

    boucle_prises := loge(Boucle)
    boucle_prises.fd = fd;

    // imprime("boucle créée !\n")

    // À FAIRE: us_internal_loop_data_init, timer

    retourne boucle_prises
}

détruit_boucle :: fonc (boucle_évènements: *Boucle)
{
    prise := boucle_évènements.prises_fermées
    tantque prise != nul {
        suivante := prise.suivante
        détruit_prise(prise)
        prise = suivante
    }

    _ := close(boucle_évènements.fd)
    déloge(boucle_évènements)
}

lance :: fonc (boucle_prises: *Boucle)
{
    // À FAIRE: chronomètre de délai
    // us_loop_integrate(loop);

    // tantque boucle_prises.num_fds
    tantque !boucle_prises.stop {
        /* Emit pre callback */
        //us_internal_loop_pre(loop);

        // imprime("attente sur un évènement !\n")
        nfds := epoll_wait(boucle_prises.fd, *boucle_prises.évènements[0], Boucle.MAX_EVENTS, -1);

        si (nfds == -1) {
            // imprime("[epoll_wait] erreur !\n")
            // perror("epoll_wait");
            // exit(EXIT_FAILURE);
            retourne
        }

        évènements_prêts : []epoll_event
        évènements_prêts.pointeur = *boucle_prises.évènements[0]
        évènements_prêts.taille = nfds

        pour évènements_prêts {
            prise := it.data.ptr comme *Prise

            si !prise {
                continue
            }

            // À FAIRE: traduit vers nos types
            évènements := it.events;
            erreurs := (it.events & (EPOLL_EVENTS.EPOLLERR | EPOLL_EVENTS.EPOLLHUP))

            // events &= us_poll_events(poll);

            // À FAIRE(langage) : conditions pour les énumérations
            si évènements != EPOLL_EVENTS.zéro || erreurs != EPOLL_EVENTS.zéro {
                dispatch_évènement(prise, évènements, erreurs)
            }
        }

        /* Emit post callback */
        // À FAIRE: libération de la mémoire
        // us_internal_loop_post(loop);
    }
}

dispatch_évènement :: fonc (prise: *Prise, évènements: EPOLL_EVENTS, erreurs: EPOLL_EVENTS)
{
    // imprime("dispatch_évènement: % % %\n", prise.type, évènements, erreurs)

    discr prise.type {
        RAPPEL {
            ptr_rappel := prise.données_utilisateur(fonc(*Contexte)(rien))
            rappel := mémoire(ptr_rappel)
            rappel(prise.contexte_)

            // il faut lire le fichier pour dire au système que nous avons pris en compte l'évènement
            données := tente lis_tout(*prise.fichier) piège err {
                retourne
            }
            /* À FAIRE : évite d'allouer de la mémoire ici */
            déloge(données)
        }
        SEMI_PRISE {
            si évènements.EPOLLOUT {
                si erreurs != EPOLL_EVENTS.zéro {
                    prise.contexte_.quand_erreur_connexion(prise)
                    prise.ferme_connexion_en_cours()
                }
                sinon {
                    // /* All sockets poll for readable */
                    // us_poll_change(p, s->context->loop, LIBUS_SOCKET_READABLE);

                    // /* We always use nodelay */
                    // bsd_socket_nodelay(us_poll_fd(p), 1);

                    // /* We are now a proper socket */
                    // us_internal_poll_set_type(p, POLL_TYPE_SOCKET);

                    // /* If we used a connection timeout we have to reset it here */
                    // us_socket_timeout(0, s, 0);

                    // s->context->on_open(s, 1, 0, 0);
                    change_évènement(prise, prise.contexte_.boucle_prises, EPOLL_EVENTS.EPOLLIN)

                    prise.type = TypePrise.PRISE

                    prise.contexte_.quand_ouverture(prise)
                }
            }
            sinon {
                fichier_client := accepte(prise.fichier.desc)

                si fichier_client == -1 {
                    // À FAIRE: commence chronomètre
                }
                sinon {
                    // À FAIRE: termine chronomètre si aucun
                    répète {
                        prise_acceptée := crée_prise_interne(prise.contexte_, Fichier(fichier_client), prise.info_utilisateur)
                        prise_acceptée.type = TypePrise.PRISE

                        si !ajoute_prise(prise.contexte_.boucle_prises, prise_acceptée, EPOLL_EVENTS.EPOLLIN) {
                            déloge(prise_acceptée)
                        }

                        // /* We always use nodelay */
                        // bsd_socket_nodelay(client_fd, 1);

                        // us_internal_socket_context_link(listen_socket->s.context, s);

                        prise.contexte_.quand_ouverture(prise_acceptée)

                        si prise_acceptée.est_fermée() {
                            arrête
                        }

                        fichier_client = accepte(prise.fichier.desc)
                    } tantque fichier_client != -1
                }
            }
        }
        PRISE {
            si erreurs != EPOLL_EVENTS.zéro {
                prise.ferme()
                retourne
            }

            si évènements.EPOLLOUT {
                // À FAIRE: last write failed

                prise.contexte_.quand_écriture(prise)
                // À FAIRE: fermetures

                // le serveur a demandé la fermeture de la connexion
                si prise.est_fermée() {
                    retourne
                }

                change_évènement(prise, prise.contexte_.boucle_prises, EPOLL_EVENTS.EPOLLIN)
            }

            si évènements.EPOLLIN {
                prise.contexte_.quand_lecture(prise)

                //change_évènement(prise, prise.contexte_.boucle_prises, EPOLL_EVENTS.EPOLLOUT)
                // À FAIRE: fermeture si nous n'arrivons pas à lire
            }
        }
    }
}

/* Initialise les fonctions de rappels pour un contexte « vide », c'est-à-dire qui ne fait rien.
 * Ceci nous sers principalement pour nous assurer que les pointeurs de fonction du contexte sont
 * propremenet initialisés et nous évite de toujours les vérifier avant de les appeler. */
initialise_rappels_pour_contexte_vide :: fonc (ctx: *Contexte)
{
    rappel_vide_quand_ouverture :: fonc (prise: *Prise @inutilisée)
    {
    }

    rappel_vide_quand_lecture :: fonc (prise: *Prise @inutilisée)
    {
    }

    rappel_vide_quand_écriture :: fonc (prise: *Prise @inutilisée)
    {
    }

    rappel_vide_quand_fermeture :: fonc (prise: *Prise @inutilisée)
    {
    }

    rappel_vide_quand_timeout :: fonc (prise: *Prise @inutilisée)
    {
    }

    rappel_vide_quand_fin :: fonc (prise: *Prise @inutilisée)
    {
    }

    rappel_vide_quand_erreur_connexion :: fonc (prise: *Prise @inutilisée)
    {
    }

    ctx.quand_ouverture = rappel_vide_quand_ouverture
    ctx.quand_lecture = rappel_vide_quand_lecture
    ctx.quand_écriture = rappel_vide_quand_écriture
    ctx.quand_fermeture = rappel_vide_quand_fermeture
    ctx.quand_timeout = rappel_vide_quand_timeout
    ctx.quand_fin = rappel_vide_quand_fin
    ctx.quand_erreur_connexion = rappel_vide_quand_erreur_connexion
}

// Fonction auxilliaire pour créer un contexte valide, mais dont les rappels ne font rien
// utile pour les développements.
crée_contexte_vide :: fonc (boucle_évènements: *Boucle, $T: type_de_données) -> *Contexte
{
    ctx := crée_contexte(boucle_évènements, T)
    initialise_rappels_pour_contexte_vide(ctx)
    retourne ctx
}
