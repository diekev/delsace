importe OpenSSL

// ------------------------------------------------------
// ContextePriseSSL

ContextePriseSSL :: struct {
    empl base: Contexte

    /* Ces rappels correspondent aux rappels mis en place via mute_quand_* par l'application cliente.
     * Les rappels situés dans le Contexte de base sont remplacés par des fonctions définies ci-après
     * afin de gérer manuellement les logiques d'écritures/lectures/etc. nécessaires pour SSL. Ces
     * fonctions appeleront a leurs tours les rappels de l'application qui sont stockés ici.
     */
    sur_écriture_base : fonc(*Prise)(rien)
    sur_ouverture_base : fonc(*Prise)(rien)
    sur_fermeture_base : fonc(*Prise)(rien)
}

// ------------------------------------------------------
// Création/Destruction

crée_contexte_ssl :: fonc (boucle_évènements: *Boucle, $TypeDonnées: type_de_données) -> *Contexte
{
    ctx_ := crée_contexte_impl(boucle_évènements, ContextePriseSSL, TypeDonnées)
    ctx_.est_ssl_ = vrai
    retourne ctx_
}

détruit_contexte_ssl :: fonc (ctx: *ContextePriseSSL)
{
    déloge_mémoire(ctx.taille_mémoire, ctx, info_de(ContextePriseSSL), PositionCodeSource())
}

// ------------------------------------------------------
// Fonctions de rappels pour parasiter le contexte de base
// avec un contexte SSL

sur_écriture_ssl :: fonc (prise: *Prise) -> rien
{
    ctx_prise_ssl := prise.contexte_ comme *ContextePriseSSL


    ctx_prise_ssl.sur_écriture_base(prise)
}

sur_ouverture_ssl :: fonc (prise: *Prise) -> rien
{
    ctx_prise_ssl := prise.contexte_ comme *ContextePriseSSL

    ctx_prise_ssl.sur_ouverture_base(prise)
}

sur_fermeture_ssl :: fonc (prise: *Prise) -> rien
{
    ctx_prise_ssl := prise.contexte_ comme *ContextePriseSSL
    SSL_CTX_free(prise.ctx_ssl)
    ctx_prise_ssl.sur_fermeture_base(prise)
}

sur_fin_ssl :: fonc (prise: *Prise) -> rien
{
    prise.ferme()
}

// ------------------------------------------------------
// Mutation des rappels de base.

contexte_ssl_parasite_quand_ouverture :: fonc (ctx: *ContextePriseSSL, rappel: fonc (*Prise)(rien)) -> type_de(rappel)
{
    ctx.sur_ouverture_base = rappel
    retourne sur_ouverture_ssl
}

contexte_ssl_parasite_quand_données_reçues :: fonc (ctx: *ContextePriseSSL @inutilisée, rappel: fonc (*Prise, []octet)(rien)) -> type_de(rappel)
{
    retourne rappel
}

contexte_ssl_parasite_quand_écriture :: fonc (ctx: *ContextePriseSSL, rappel: fonc (*Prise)(rien)) -> type_de(rappel)
{
    ctx.sur_écriture_base = rappel
    retourne sur_écriture_ssl
}

contexte_ssl_parasite_quand_fermeture :: fonc (ctx: *ContextePriseSSL, rappel: fonc (*Prise)(rien)) -> type_de(rappel)
{
    ctx.sur_fermeture_base = rappel
    retourne sur_fermeture_ssl
}

contexte_ssl_parasite_quand_timeout :: fonc (ctx: *ContextePriseSSL @inutilisée, rappel: fonc (*Prise)(rien)) -> type_de(rappel)
{
    retourne rappel
}

contexte_ssl_parasite_quand_fin :: fonc (ctx: *ContextePriseSSL @inutilisée, rappel: fonc (*Prise)(rien) @inutilisée) -> type_de(rappel)
{
    /* Si SSL est utilisée, nous n'utilisons pas le rappel renseigné par l'application, car SSL ne supporte pas les prises à moitié fermées.
     * Nous fermons directement la prise. */
    retourne sur_fin_ssl
}

contexte_ssl_parasite_quand_erreur_connexion :: fonc (ctx: *ContextePriseSSL @inutilisée, rappel: fonc (*Prise)(rien)) -> type_de(rappel)
{
    retourne rappel
}
