// Interface Kuri pour Krypto

#bibliothèque_statique "libkrypto.a"

importe Fondation

// À FAIRE : implémente avec notre langage toutes ces fonctions (il semble qu'il y a un problème de boutisme ou de signe dans le langage)
// À FAIRE : ne retourne pas des chaines, mais les tampons de données crues
// À FAIRE : la bibliothèque BCrypt à l'air brisée ?, il faudra de toute manière utiliser Argon2 qui a l'air d'être une meilleure fonction

BCrypt_taille_tampon :: fonc () -> z64 #externe

BCrypt_genere_empreinte :: fonc (mot_de_passe: *z8, charge_travail: z32, sortie: *z8) -> rien #externe

BCrypt_compare_empreinte :: fonc (mot_de_passe: *z8, empreinte: *z8) -> z32 #externe

CRC32_taille_tampon :: fonc () -> z64 #externe

CRC32_genere_empreinte :: fonc (entree: *z8, taille: z64, sortie: *z8) -> rien #externe

HMAC_taille_tampon :: fonc () -> z64 #externe

HMAC_genere_empreinte :: fonc (cle: *n8, taille_cle: z64, message: *n8, taille_message: z64, sortie: *z8) #externe

MD5_taille_tampon :: fonc () -> z64 #externe

MD5_genere_empreinte :: fonc (entree: *z8, taille: z64, sortie: *z8) -> rien #externe

SHA1_taille_tampon :: fonc () -> z64 #externe

SHA1_genere_empreinte :: fonc (entree: *z8, taille: z64, sortie: *z8) -> rien #externe

SHA256_taille_tampon :: fonc () -> z64 #externe

SHA256_genere_empreinte :: fonc (entree: *z8, taille: z64, sortie: *z8) -> rien #externe

SHA384_taille_tampon :: fonc () -> z64 #externe

SHA384_genere_empreinte :: fonc (entree: *z8, taille: z64, sortie: *z8) -> rien #externe

SHA512_taille_tampon :: fonc () -> z64 #externe

SHA512_genere_empreinte :: fonc (entree: *z8, taille: z64, sortie: *z8) -> rien #externe

BCrypt_genere_empreinte :: fonc (mot_de_passe: chaine, charge_travail := 12) -> chaine
{
    // loge un tampon afin de pouvoir gérer la mémoire de notre côté
    résultat := loge chaine(BCrypt_taille_tampon())

    BCrypt_genere_empreinte(mot_de_passe.pointeur, charge_travail, résultat.pointeur)

    retourne résultat
}

BCrypt_compare_empreinte :: fonc (mot_de_passe: chaine, empreinte: chaine) -> bool
{
    nempreinte := BCrypt_genere_empreinte(mot_de_passe)

    ok := nempreinte == empreinte

    déloge nempreinte

    retourne ok
//    retourne BCrypt_compare_empreinte(mot_de_passe.pointeur, empreinte.pointeur) == 0
}

CRC32_genere_empreinte :: fonc (entree: chaine) -> chaine
{
    // loge un tampon afin de pouvoir gérer la mémoire de notre côté
    résultat := loge chaine(CRC32_taille_tampon())

    CRC32_genere_empreinte(entree.pointeur, entree.taille, résultat.pointeur)

    retourne résultat
}

MD5_genere_empreinte :: fonc (entree: chaine) -> chaine
{
    // loge un tampon afin de pouvoir gérer la mémoire de notre côté
    résultat := loge chaine(MD5_taille_tampon())

    MD5_genere_empreinte(entree.pointeur, entree.taille, résultat.pointeur)

    retourne résultat
}

SHA1_genere_empreinte :: fonc (entree: chaine) -> chaine
{
    // loge un tampon afin de pouvoir gérer la mémoire de notre côté
    résultat := loge chaine(SHA1_taille_tampon())

    SHA1_genere_empreinte(entree.pointeur, entree.taille, résultat.pointeur)

    retourne résultat
}

SHA256_genere_empreinte :: fonc (entree: chaine) -> chaine
{
    // loge un tampon afin de pouvoir gérer la mémoire de notre côté
    résultat := loge chaine(SHA256_taille_tampon())

    SHA256_genere_empreinte(entree.pointeur, entree.taille, résultat.pointeur)

    retourne résultat
}

SHA384_genere_empreinte :: fonc (entree: chaine) -> chaine
{
    // loge un tampon afin de pouvoir gérer la mémoire de notre côté
    résultat := loge chaine(SHA384_taille_tampon())

    SHA384_genere_empreinte(entree.pointeur, entree.taille, résultat.pointeur)

    retourne résultat
}

SHA512_genere_empreinte :: fonc (entree: chaine) -> chaine
{
    // loge un tampon afin de pouvoir gérer la mémoire de notre côté
    résultat := loge chaine(SHA512_taille_tampon())

    SHA512_genere_empreinte(entree.pointeur, entree.taille, résultat.pointeur)

    retourne résultat
}

HMAC_genere_empreinte :: fonc (clé: chaine, message: chaine) -> chaine
{
    résultat := loge chaine(HMAC_taille_tampon())
    HMAC_genere_empreinte(clé.pointeur comme *n8, clé.taille, message.pointeur comme *n8, message.taille, résultat.pointeur)
    retourne résultat
}
