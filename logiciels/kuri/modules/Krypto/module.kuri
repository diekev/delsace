// Interface Kuri pour Krypto

#bibliothèque_statique "libkrypto.a"

#inclus "krypto.hh"

importe Fondation


// À FAIRE : la bibliothèque BCrypt à l'air brisée ?, il faudra de toute manière utiliser Argon2 qui a l'air d'être une meilleure fonction

BCrypt_taille_tampon :: fonc externe () -> z64

BCrypt_genere_empreinte :: fonc externe (mot_de_passe: *z8, charge_travail: z32, sortie: *z8) -> rien

BCrypt_compare_empreinte :: fonc externe (mot_de_passe: *z8, empreinte: *z8) -> z32

SHA256_taille_tampon :: fonc externe () -> z64

SHA256_genere_empreinte :: fonc externe (entree: *z8, taille: z64, sortie: *z8) -> rien

BCrypt_genere_empreinte :: fonc (mot_de_passe: chaine, charge_travail := 12) -> chaine
{
    // loge un tampon afin de pouvoir gérer la mémoire de notre côté
    résultat := loge chaine(BCrypt_taille_tampon())

    BCrypt_genere_empreinte(mot_de_passe.pointeur, charge_travail, résultat.pointeur)

    retourne résultat
}

BCrypt_compare_empreinte :: fonc (mot_de_passe: chaine, empreinte: chaine) -> bool
{
    nempreinte := BCrypt_genere_empreinte(mot_de_passe)

    ok := nempreinte == empreinte

    déloge nempreinte

    retourne ok
//    retourne BCrypt_compare_empreinte(mot_de_passe.pointeur, empreinte.pointeur) == 0
}

SHA256_genere_empreinte :: fonc (entree: chaine) -> chaine
{
    // loge un tampon afin de pouvoir gérer la mémoire de notre côté
    résultat := loge chaine(SHA256_taille_tampon())

    SHA256_genere_empreinte(entree.pointeur, entree.taille, résultat.pointeur)

    retourne résultat
}

HMAC_genere_empreinte :: fonc externe (cle: *n8, taille_cle: z64, message: *n8, taille_message: z64)

HMAC_genere_empreinte :: fonc (clé: chaine, message: chaine)
{
    HMAC_genere_empreinte(clé.pointeur comme *n8, clé.taille, message.pointeur comme *n8, message.taille)
}

// implémentation de la méthode HMAC
// https://tools.ietf.org/html/rfc2104.html
hmac :: fonc (clé: chaine, message: chaine) -> chaine
{
    si clé.taille > SHA256_taille_tampon() {
        clé = SHA256_genere_empreinte(clé)
    }
    sinon si clé.taille < SHA256_taille_tampon() {
        clé = copie_chaine(clé)

        marge := SHA256_taille_tampon() - clé.taille

        pour 0 ... marge - 1 {
            chaine_ajoute(@clé, 0)
        }
    }
    sinon {
        clé = copie_chaine(clé)
    }

    o_clé := copie_chaine(clé)
    i_clé := copie_chaine(clé)

    imprime("o_clé : %\n", o_clé)

    pour o_clé {
        it ^= 0x5c
    }

    imprime("o_clé : %\n", o_clé)

    pour i_clé {
        it ^= 0x36
    }

    xi := copie_chaine(i_clé)
    chaine_ajoute(@xi, message)

    hxi := SHA256_genere_empreinte(xi)

    xo := copie_chaine(o_clé)
    chaine_ajoute(@xo, hxi)

    résultat := SHA256_genere_empreinte(xo)

    déloge o_clé
    déloge i_clé
    déloge clé
    déloge xi
    déloge hxi
    déloge xo

    retourne résultat
}
