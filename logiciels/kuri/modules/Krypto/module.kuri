// Interface Kuri pour Krypto

#bibliothèque_statique "libkrypto.a"

importe Fondation

// À FAIRE : implémente avec notre langage toutes ces fonctions (il semble qu'il y a un problème de boutisme ou de signe dans le langage)
// À FAIRE : la bibliothèque BCrypt à l'air brisée ?, il faudra de toute manière utiliser Argon2 qui a l'air d'être une meilleure fonction
// À FAIRE : type Condensat (voir Alembic)
// À FAIRE : bibliothèque de fonctions non cryptographiques
// À FAIRE : ne passe pas des chaines mais des tableaux d'octets

BCrypt_taille_tampon :: fonc () -> z64 #externe

BCrypt_genere_empreinte :: fonc (mot_de_passe: *z8, charge_travail: z32, sortie: *z8) -> rien #externe

BCrypt_compare_empreinte :: fonc (mot_de_passe: *z8, empreinte: *z8) -> z32 #externe

CRC32_taille_tampon :: fonc () -> z64 #externe

CRC32_genere_empreinte :: fonc (entree: *z8, taille: z64, sortie: *z8) -> rien #externe

HMAC_taille_tampon :: fonc () -> z64 #externe

HMAC_genere_empreinte :: fonc (cle: *n8, taille_cle: z64, message: *n8, taille_message: z64, sortie: *z8) #externe

MD5_taille_tampon :: fonc () -> z64 #externe

MD5_genere_empreinte :: fonc (entree: *z8, taille: z64, sortie: *z8) -> rien #externe

SHA1_taille_tampon :: fonc () -> z64 #externe

SHA1_genere_empreinte :: fonc (entree: *z8, taille: z64, sortie: *z8) -> rien #externe

SHA256_taille_tampon :: fonc () -> z64 #externe

SHA256_genere_empreinte :: fonc (entree: *z8, taille: z64, sortie: *z8) -> rien #externe

SHA384_taille_tampon :: fonc () -> z64 #externe

SHA384_genere_empreinte :: fonc (entree: *z8, taille: z64, sortie: *z8) -> rien #externe

SHA512_taille_tampon :: fonc () -> z64 #externe

SHA512_genere_empreinte :: fonc (entree: *z8, taille: z64, sortie: *z8) -> rien #externe

BCrypt_genere_empreinte :: fonc (mot_de_passe: chaine, charge_travail := 12) -> chaine
{
    // loge un tampon afin de pouvoir gérer la mémoire de notre côté
    résultat := loge_chaine(BCrypt_taille_tampon())

    BCrypt_genere_empreinte(mot_de_passe.pointeur, charge_travail, résultat.pointeur)

    retourne résultat
}

BCrypt_compare_empreinte :: fonc (mot_de_passe: chaine, empreinte: chaine) -> bool
{
    nempreinte := BCrypt_genere_empreinte(mot_de_passe)

    ok := nempreinte == empreinte

    déloge(nempreinte)

    retourne ok
//    retourne BCrypt_compare_empreinte(mot_de_passe.pointeur, empreinte.pointeur) == 0
}

CRC32_genere_empreinte :: fonc (entree: chaine) -> chaine
{
    // loge un tampon afin de pouvoir gérer la mémoire de notre côté
    résultat := loge_chaine(CRC32_taille_tampon())

    CRC32_genere_empreinte(entree.pointeur, entree.taille, résultat.pointeur)

    retourne résultat
}

MD5_genere_empreinte :: fonc (entree: chaine) -> chaine
{
    // loge un tampon afin de pouvoir gérer la mémoire de notre côté
    résultat := loge_chaine(MD5_taille_tampon())

    MD5_genere_empreinte(entree.pointeur, entree.taille, résultat.pointeur)

    retourne résultat
}

SHA1_genere_empreinte :: fonc (entree: chaine) -> chaine
{
    // loge un tampon afin de pouvoir gérer la mémoire de notre côté
    résultat := loge_chaine(SHA1_taille_tampon())

    SHA1_genere_empreinte(entree.pointeur, entree.taille, résultat.pointeur)

    retourne résultat
}

SHA256_genere_empreinte :: fonc (entree: chaine) -> chaine
{
    // loge un tampon afin de pouvoir gérer la mémoire de notre côté
    résultat := loge_chaine(SHA256_taille_tampon())

    SHA256_genere_empreinte(entree.pointeur, entree.taille, résultat.pointeur)

    retourne résultat
}

SHA384_genere_empreinte :: fonc (entree: chaine) -> chaine
{
    // loge un tampon afin de pouvoir gérer la mémoire de notre côté
    résultat := loge_chaine(SHA384_taille_tampon())

    SHA384_genere_empreinte(entree.pointeur, entree.taille, résultat.pointeur)

    retourne résultat
}

SHA512_genere_empreinte :: fonc (entree: chaine) -> chaine
{
    // loge un tampon afin de pouvoir gérer la mémoire de notre côté
    résultat := loge_chaine(SHA512_taille_tampon())

    SHA512_genere_empreinte(entree.pointeur, entree.taille, résultat.pointeur)

    retourne résultat
}

HMAC_genere_empreinte :: fonc (clé: chaine, message: chaine) -> chaine
{
    résultat := loge_chaine(HMAC_taille_tampon())
    HMAC_genere_empreinte(clé.pointeur comme *n8, clé.taille, message.pointeur comme *n8, message.taille, résultat.pointeur)
    retourne résultat
}

HACHEUSE :: struct #externe

KRYPTO_HACHEUSE_cree_sha1 :: fonc () -> *HACHEUSE #externe
KRYPTO_HACHEUSE_cree_sha256 :: fonc () -> *HACHEUSE #externe
KRYPTO_HACHEUSE_cree_md5 :: fonc () -> *HACHEUSE #externe
KRYPTO_HACHEUSE_cree_crc32 :: fonc () -> *HACHEUSE #externe

KRYPTO_HACHEUSE_cree_hmac_md5 :: fonc (clé: *rien, taille_clé: n64, données: *rien, taille_données: n64) -> *HACHEUSE #externe
KRYPTO_HACHEUSE_cree_hmac_sha1 :: fonc (clé: *rien, taille_clé: n64, données: *rien, taille_données: n64) -> *HACHEUSE #externe
KRYPTO_HACHEUSE_cree_hmac_sha256 :: fonc (clé: *rien, taille_clé: n64, données: *rien, taille_données: n64) -> *HACHEUSE #externe

KRYPTO_HACHEUSE_detruit :: fonc (hacheuse: *HACHEUSE) #externe
KRYPTO_HACHEUSE_ajourne :: fonc (hacheuse: *HACHEUSE, données: *rien, taille_données: n64) #externe
KRYPTO_HACHEUSE_condensat :: fonc (hacheuse: *HACHEUSE, sortie: *z8) #externe
KRYPTO_HACHEUSE_condensat_hex :: fonc (hacheuse: *HACHEUSE, sortie: *z8) #externe
KRYPTO_HACHEUSE_taille_condensat :: fonc (hacheuse: *HACHEUSE) -> z32 #externe
KRYPTO_HACHEUSE_taille_bloc :: fonc (hacheuse: *HACHEUSE) -> z32  #externe

KRYPTO_HACHEUSE_compare_condensat :: fonc (a: *n8, taille_a: n64, b: *n8, taille_b: n64) -> z32 #externe

crée_rc32 :: fonc () -> *HACHEUSE
{
    retourne KRYPTO_HACHEUSE_cree_crc32()
}

crée_md5 :: fonc () -> *HACHEUSE
{
    retourne KRYPTO_HACHEUSE_cree_md5()
}

crée_sha1 :: fonc () -> *HACHEUSE
{
    retourne KRYPTO_HACHEUSE_cree_sha1()
}

crée_sha256 :: fonc () -> *HACHEUSE
{
    retourne KRYPTO_HACHEUSE_cree_sha256()
}

TypeHMAC :: énum {
    MD5
    SHA1
    SHA256
}

crée_hmac :: fonc (clé: chaine, type := TypeHMAC.SHA256) -> *HACHEUSE
{
    si type == TypeHMAC.MD5 {
        retourne KRYPTO_HACHEUSE_cree_hmac_md5(clé.pointeur, clé.taille comme n64, nul, 0)
    }

    si type == TypeHMAC.SHA1 {
        retourne KRYPTO_HACHEUSE_cree_hmac_sha1(clé.pointeur, clé.taille comme n64, nul, 0)
    }

    retourne KRYPTO_HACHEUSE_cree_hmac_sha256(clé.pointeur, clé.taille comme n64, nul, 0)
}

crée_hmac :: fonc (clé: chaine, message: chaine, type := TypeHMAC.SHA256) -> *HACHEUSE
{
    si type == TypeHMAC.MD5 {
        retourne KRYPTO_HACHEUSE_cree_hmac_md5(clé.pointeur, clé.taille comme n64, message.pointeur, message.taille comme n64)
    }

    si type == TypeHMAC.SHA1 {
        retourne KRYPTO_HACHEUSE_cree_hmac_sha1(clé.pointeur, clé.taille comme n64, message.pointeur, message.taille comme n64)
    }

    retourne KRYPTO_HACHEUSE_cree_hmac_sha256(clé.pointeur, clé.taille comme n64, message.pointeur, message.taille comme n64)
}

détruit :: fonc (hacheuse: &*HACHEUSE)
{
    KRYPTO_HACHEUSE_detruit(hacheuse)
    hacheuse = nul
}

ajourne :: fonc (hacheuse: *HACHEUSE, message: chaine)
{
    KRYPTO_HACHEUSE_ajourne(hacheuse, message.pointeur, message.taille comme n64)
}

condensat :: fonc (hacheuse: *HACHEUSE) -> chaine
{
    résultat := loge_chaine(taille_condensat(hacheuse))
    KRYPTO_HACHEUSE_condensat(hacheuse, résultat.pointeur)
    retourne résultat
}

condensat_hex :: fonc (hacheuse: *HACHEUSE) -> chaine
{
    résultat := loge_chaine(2 * taille_condensat(hacheuse))
    KRYPTO_HACHEUSE_condensat_hex(hacheuse, résultat.pointeur)
    retourne résultat
}

taille_bloc :: fonc (hacheuse: *HACHEUSE) -> z32
{
    retourne KRYPTO_HACHEUSE_taille_bloc(hacheuse)
}

taille_condensat :: fonc (hacheuse: *HACHEUSE) -> z32
{
    retourne KRYPTO_HACHEUSE_taille_condensat(hacheuse)
}

compare_condensat :: fonc (a: chaine, b: chaine) -> bool
{
    retourne KRYPTO_HACHEUSE_compare_condensat(a.pointeur comme *n8, a.taille comme n64, b.pointeur comme *n8, b.taille comme n64) == 0
}
