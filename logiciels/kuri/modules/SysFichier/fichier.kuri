importe Fondation
importe Structures

Fichier :: struct {
    desc: TypePoignéeFichier
}

RésultatFichier :: union {
    e: ErreurFichier
    f: Fichier
}

// ----------------------------------------------------------
// Raison ouverture fichier

RaisonOuvertureFichier :: énum_drapeau {
    Lecture
    Écriture
    Création
    /* Le fichier sera tronqué. */
    Troncage
    /* L'écriture ajoutera des données à la fin du fichier */
    Ajout
}

/* Constantes communes. */

pour_écriture :: RaisonOuvertureFichier.Écriture

pour_écriture_supplémentaire :: RaisonOuvertureFichier.Écriture | RaisonOuvertureFichier.Ajout

pour_écriture_tronquée :: RaisonOuvertureFichier.Écriture | RaisonOuvertureFichier.Troncage

pour_lecture :: RaisonOuvertureFichier.Lecture

pour_lecture_écriture :: RaisonOuvertureFichier.Écriture | RaisonOuvertureFichier.Lecture

pour_lecture_écriture_tronquée :: pour_lecture_écriture | RaisonOuvertureFichier.Troncage

// ----------------------------------------------------------
// Ouverture de fichier

ouvre_fichier :: fonc (chemin: CheminFichier, raison: RaisonOuvertureFichier, permissions: z32) -> RésultatFichier
{
    desc := tente système_ouvre(chemin, raison, permissions) piège err {
        retourne err
    }

    fichier: Fichier
    fichier.desc = TypePoignéeFichier(desc)
    retourne fichier
}

// ouvre_fichier_existant
// ouvre_fichier_existant_crée_sinon
ouvre_fichier :: fonc (chemin: CheminFichier) -> RésultatFichier
{
    retourne ouvre_fichier(chemin, pour_lecture_écriture, 0o644)
}

ouvre_fichier_pour_lecture :: fonc (chemin: CheminFichier) -> RésultatFichier
{
    retourne ouvre_fichier(chemin, pour_lecture, 0o644)
}

/* Garantie l'existence de tous les dossiers menant vers la feuille du chemin. */
crée_dossiers_pour_chemin :: fonc (chemin: CheminFichier, avec_feuille: bool) -> ErreurFichier
{
    pile := divise_et_empile_chemin(chemin)
    diffère détruit(pile)

    si pile.est_vide() {
        retourne 0 comme ErreurFichier
    }

    saufsi avec_feuille {
        /* Supprime le dernier élément du chemin. */
        _ := pile.dépile()
    }

    si pile.est_vide() {
        /* Nous sommes à la racine sans doute. */
        retourne 0 comme ErreurFichier
    }

    pile.renverse()

    chemin_dossier : chaine
    diffère déloge(chemin_dossier)

    saute_premier_slash := chemin.est_relatif()

    tantque !pile.est_vide() {
        saufsi saute_premier_slash {
            chaine_ajoute(*chemin_dossier, séparateur_chemin())
        }
        chaine_ajoute(*chemin_dossier, pile.dépile())

        saute_premier_slash = faux

        si est_un_dossier(CheminFichier(chemin_dossier)) {
            continue
        }

        tente système_crée_dossier(chemin_dossier, 0o755) piège err {
            retourne err
        }
    }

    retourne 0 comme ErreurFichier
}

ouvre_fichier_crée_si_non_existant :: fonc (chemin: CheminFichier, raison: RaisonOuvertureFichier) -> RésultatFichier
{
    tente crée_dossiers_pour_chemin(chemin, faux) piège err {
        retourne err
    }

    /* Garantie la présence de ce drapeau. */
    raison.Création = vrai

    retourne ouvre_fichier(chemin, raison, 0o644)
}

ferme :: fonc (fichier: *Fichier) -> ErreurFichier
{
    retourne système_ferme(fichier.desc)
}

// ----------------------------------------------------------
// Positionnement dans le fichier.

PositionDébut :: #opaque z64
PositionFin :: #opaque z64
PositionRelative :: #opaque z64

PositionFichier :: union {
    Début: PositionDébut
    Fin: PositionFin
    Décalage: PositionRelative
}

positionne_fichier :: fonc (fichier: *Fichier, position: PositionFichier) -> RésultatOpérationFichier
{
    rés := tente système_positionne_fichier(fichier.desc, position) piège err {
        retourne err
    }

    retourne rés
}

// ----------------------------------------------------------

copie_fichier :: fonc (source: CheminFichier, destination: CheminFichier) -> bool
{
    contenu_source := contenu_fichier_texte(source)

    fichier_destination := tente ouvre_fichier_crée_si_non_existant(destination, pour_lecture_écriture_tronquée) piège err {
        retourne faux
    }

    _ := écris(*fichier_destination, contenu_source)
    _ := ferme(*fichier_destination)
    retourne vrai
}

taille_fichier :: fonc (fichier: *Fichier) -> z64
{
    taille_fichier := tente positionne_fichier(fichier, PositionFin(0)) piège err {
        retourne 0
    }

    _ := tente positionne_fichier(fichier, PositionDébut(0)) piège err {
        retourne 0
    }

    retourne taille_fichier
}

est_fin_de_fichier :: fonc (fichier: *Fichier) -> bool
{
    résultat := tente système_fin_de_fichier(fichier.desc) piège err {
        retourne vrai
    }

    retourne résultat == 1
}

// ----------------------------------------------------------
// Lecture

lis :: fonc (fichier: *Fichier, tampon: []octet) -> RésultatOpérationFichier
{
    octets_lus := tente système_lis(fichier.desc, tampon.pointeur comme *z8, tampon.taille) piège err {
        retourne err
    }

    retourne octets_lus comme z32
}

RésultatLectureN64 :: union {
    e : ErreurFichier
    r : n64
}

lis_n64 :: fonc (fichier: *Fichier) -> RésultatLectureN64
{
    tampon : n64

    octets_lus := tente système_lis(fichier.desc, *tampon comme *z8, 8) piège err {
        retourne err
    }

    si octets_lus != 8 {
        retourne ErreurFichier.Inconnue
    }

    retourne tampon
}

lis_entier :: fonc (fichier: *Fichier, $T: type_de_données) -> Optionnel(T)
{
    valeur : T

    octets_lus := tente lis(fichier, valeur) piège err {
        retourne
    }

    si octets_lus != taille_de(T) {
        retourne
    }

    retourne valeur
}

lis_chaine :: fonc (fichier: *Fichier, taille: z64) -> chaine
{
    résultat := loge_chaine(taille)

    _ := fichier.lis(résultat)

    retourne résultat
}

CaractèreOuErreurFichier :: union {
    c: z8
    e: ErreurFichier
}

lis_caractère :: fonc (fichier: *Fichier) -> CaractèreOuErreurFichier
{
	c : z8

    octets_lus := tente système_lis(fichier.desc, *c, 1) piège err {
        retourne err
    }

    si octets_lus == 0 {
        retourne '\0'
    }

    retourne c
}

ChaineOuErreurFichier :: union {
    e: ErreurFichier
    c: chaine
}

lis_tout :: fonc (fichier: *Fichier) -> ChaineOuErreurFichier
{
    TAILLE_MAX :: 1024

    tampon : [TAILLE_MAX]z8
    résultat : chaine

    boucle {
        octets_lus := tente système_lis(fichier.desc, *tampon[0], TAILLE_MAX) piège err {
            déloge(résultat)
            retourne err
        }

        si octets_lus > 0 {
            ancienne_taille := résultat.taille
            reloge_chaine(résultat, résultat.taille + octets_lus)
            copie_mem_nonsur(src=*tampon[0], dst=*résultat[ancienne_taille], taille=octets_lus)

            si octets_lus < TAILLE_MAX {
                arrête
            }
        }
        sinon si octets_lus == 0 {
            arrête
        }
    }

    retourne résultat
}

lis_ligne :: fonc (fichier: *Fichier) -> ChaineOuErreurFichier
{
	résultat : chaine
	c : z8

	boucle {
        octets_lus := tente système_lis(fichier.desc, *c, 1) piège err {
            déloge(résultat)
            retourne err
        }

        si octets_lus == 0 {
            arrête
        }

		chaine_ajoute(*résultat, c)

		si c == '\n' {
			arrête
		}
	}

    retourne résultat
}

// fonction spécialisée pour tout lire depuis un fichier sur le disque, où l'on
// calcule la taille du fichier avant de tout lire au lieu de faire une boucle
// pour accumuler les données dans un tampon
lis_tout_depuis_fichier :: fonc (fichier: *Fichier) -> ChaineOuErreurFichier
{
    taille_fichier := tente positionne_fichier(fichier, PositionFin(0)) piège err {
        retourne err
    }

    si taille_fichier == 0 {
        retourne ""
    }

    _ := tente positionne_fichier(fichier, PositionDébut(0)) piège err {
        retourne err
    }

    résultat := loge_chaine(taille_fichier)

    octets_lus := tente système_lis(fichier.desc, résultat.pointeur, résultat.taille) piège err {
        déloge(résultat)
        retourne err
    }

    retourne résultat
}

// ----------------------------------------------------------
// Écriture

// écris_à_la_position
// écris_fin
écris :: fonc (fichier: *Fichier, chn: chaine) -> RésultatOpérationFichier
{
    retourne système_écris(fichier.desc, chn.pointeur, chn.taille)
}

écris :: fonc (fichier: *Fichier, octets: []octet) -> RésultatOpérationFichier
{
    retourne système_écris(fichier.desc, octets.pointeur comme *z8, octets.taille)
}

// -----------------------------------------------------------------------
// Fichiers communs

entrée_standarde :: fonc () -> *Fichier
{
    retourne système_entrée_standarde()
}

sortie_standarde :: fonc () -> *Fichier
{
    retourne système_sortie_standarde()
}

sortie_erreur :: fonc () -> *Fichier
{
    retourne système_sortie_erreur()
}

fichier_invalide :: fonc () -> Fichier
{
    retourne Fichier(système_poignée_fichier_invalide())
}

// -----------------------------------------------------------------------

/* Fais pointer ancien_fichier vers nouveau_fichier. Après cette opération lire
 * depuis et écrire dans ancien_fichier aura le même effet que lire depuis et
 * écrire dans nouveau_fichier. */
référence_fichier :: fonc (ancien_fichier: &Fichier, nouveau_fichier: *Fichier)
{
    système_référence_fichier(ancien_fichier.desc, nouveau_fichier.desc)

    si ancien_fichier.desc != nouveau_fichier.desc {
        _ := ferme(*ancien_fichier)
    }
}

// ---------------------------------------------------------
// Verrouillage de fichier.

TypeVerrou :: énum {
    Partagé
    Exclusif
}

verrouille :: fonc (fichier: *Fichier, verrou: TypeVerrou) -> bool
{
    retourne système_verrouille_fichier(fichier, verrou)
}

déverrouille :: fonc (fichier: *Fichier)
{
    système_déverrouille_fichier(fichier)
}
