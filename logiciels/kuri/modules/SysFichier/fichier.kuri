importe Fondation
importe GlibC

Fichier :: struct {
    desc : z32
}

// ouvre_fichier_existant
// ouvre_fichier_existant_crée_sinon
ouvre :: fonc (chemin: chaine) -> Fichier
{
   	ptr_chemin := chaine_c_temp(chemin)

    // @erreur
    desc := open(ptr_chemin, LECTURE_ÉCRITURE)

    fichier: Fichier
    fichier.desc = desc

    retourne fichier
}

ferme :: fonc (fichier: *Fichier) -> rien
{
    si fichier.desc < 3 {
        retourne
    }

    // @erreur
    si close(fichier.desc) == -1 {
        retourne
    }
}

lis :: fonc (fichier: *Fichier, tampon: chaine) -> rien
{
    si fichier.desc == -1 || fichier.desc == 1 || fichier.desc == 2 {
        retourne
    }

    // @erreur
    octets_lus := read(fichier.desc, tampon.pointeur, transtype(tampon.taille: n32))
}

lis :: fonc (fichier: *Fichier) -> chaine
{
    TAILLE_MAX : n64 = 1024

    tampon : [1024]z8
    contenu : chaine

    boucle {
        taille_reçue := read(fichier.desc, @tampon[0], TAILLE_MAX)

        si taille_reçue > 0 {
            ancienne_taille := contenu.taille
            reloge contenu : chaine(contenu.taille + taille_reçue)
            copie_mem_nonsur(src=@tampon[0], dst=@contenu[ancienne_taille], taille=taille_reçue)

            si taille_reçue < transtype(TAILLE_MAX: z64) {
                arrête
            }
        }
        sinon si taille_reçue == 0 {
            arrête
        }
        sinon si taille_reçue == -1 {
            // À FAIRE : erreur
            arrête
        }
    }

    retourne contenu
}

lis_ligne :: fonc (fichier: *Fichier) -> chaine
{
	chn : chaine
	c : z8

	tantque read(fichier.desc, @c, 1) != 0 {
		pousse(@chn, c)

		si c == '\n' {
			arrête
		}
	}

    retourne chn
}

lis_tout :: fonc (fichier: *Fichier) -> chaine
{
    taille_fichier := lseek(fichier.desc, 0, SEEK_END)

    si taille_fichier == 0 {
        retourne ""
    }

    // @erreur
    _ := lseek(fichier.desc, 0, SEEK_SET)

    résultat := loge chaine(taille_fichier)

    octets_lus := read(fichier.desc, résultat.pointeur, transtype(résultat.taille: n32))

    si octets_lus == -1 {
        déloge résultat
        retourne ""
    }

    retourne résultat
}

// écris_à_la_position
// écris_fin
écris :: fonc (fichier: *Fichier, chn: chaine) -> z64
{
    // On ne peut pas écrire ni dans l'entrée standarde, ni dans un fichier « erroné »
    si fichier.desc == -1 || fichier.desc == 0 {
        retourne -1
    }

    retourne write(fichier.desc, chn.pointeur, chn.taille)
}

fichier_entrée_standarde := Fichier{ desc = 0 }
fichier_sortie_standarde := Fichier{ desc = 1 }
fichier_sortie_erreur    := Fichier{ desc = 2 }

entrée_standarde :: fonc () -> *Fichier
{
    retourne @fichier_entrée_standarde
}

sortie_standarde :: fonc () -> *Fichier
{
    retourne @fichier_sortie_standarde
}

sortie_erreur :: fonc () -> *Fichier
{
    retourne @fichier_sortie_erreur
}
