importe Fondation
importe GlibC
importe POSIX
importe Structures

/*

// pour la gestion des fichiers

gestion centralisé de l'ouverture et la fermeture des fichiers, avec détection des changements
peut-être une politique de cache (MRU, etc.)

les bibliothèques devant ouvrir des fichiers devraient prendre un pointeur vers un gestionnaire
le gestionnaire résoud les chemins et indique

peut-être un système de catalogue par type de fichiers ?

- fichier temporaire
- compression/décompression
- flux
- (USD) FileSystemDiscovery

notifie les applications quand un fichier change

il nous faudrait des lecteurs et des écrivains ?

fichier_fut_changé_sur_dique :: fonc (fichier: *Fichier)

fichier_fut_ouvert :: fonc (fichier: *Fichier)

fichier_ne_pas_trouvé :: fonc (chemin: CheminFichier)

fichier_existe

crée_fichier_pour_écriture

ouvre_fichier_pour_écriture

fichier_fut_fermé

ferme_fichier

- le fichier peut-être dans un catalogue
- le fichier peut-être dans un cache
- le fichier peut-être utilisé par plusieurs personnes
- le fichier peut-être sur le réseau

 */

espace_disque_disponible :: fonc (chemin: &CheminFichier) -> n64
{
	ptr_chemin := crée_chaine_c(chemin.chn)
    diffère détruit_chaine_c(ptr_chemin)

    s : struct_statvfs
    résultat := statvfs(ptr_chemin, *s)

    // À FAIRE : erreur
    // Si le fichier ou dossier n'exite pas, il y aura aussi une erreur
    si résultat == -1 {
        retourne 0
    }

    // À FAIRE : on peut avoir un compte différent pour les utilisateurs privilégiés.
    retourne s.f_bavail * s.f_bsize
}

contenu_fichier_binaire :: fonc(chemin : &CheminFichier) -> []octet
{
    contenu : []octet

	fichier := tente ouvre_fichier(chemin.chn) piège err {
        retourne contenu
    }

	diffère { _ := ferme(*fichier) }

    discr lis_tout(*fichier) {
        c(c_) {
            contenu = c_
        }
        sinon {
        }
    }

    retourne contenu
}

contenu_fichier_texte :: fonc(chemin : &CheminFichier) -> chaine
{
    contenu := contenu_fichier_binaire(chemin)
    chn : chaine;

    nonsûr {
        chn.pointeur = contenu.pointeur comme *z8
        chn.taille = contenu.taille
    }

    retourne chn
}

contenu_fichier_texte :: fonc (chemin: chaine) -> chaine
{
    chm := CheminFichier(chn = chemin)
    retourne contenu_fichier_texte(chm)
}

//###############################################################################

chemin_courant :: fonc() -> CheminFichier
{
    tampon : [1024]z8
    pointeur := getcwd(ChaineC(*tampon[0]), 1024)

    si (pointeur comme *z8) == nul {
        // @erreur
        retourne construit_chemin("")
    }

    ret := copie_chaine_c(pointeur)
    retourne construit_chemin(ret)
}

chemin_courant :: fonc(chemin : CheminFichier) -> rien
{
	ptr_chemin := crée_chaine_c(chemin.chn)
    diffère détruit_chaine_c(ptr_chemin)
    chdir(ptr_chemin)
}

chemin_répertoire_personnel :: fonc () -> CheminFichier
{
    via_environnement := chaine_environnement("HOME")

    si via_environnement {
        retourne CheminFichier(via_environnement)
    }

    retourne CheminFichier()
}

chemin_véritable :: fonc (chemin: CheminFichier) -> CheminFichier
{
    tampon : [TAILLE_MAX_CHEMIN]z8
    ptr_tampon := *tampon[0]

    chn_c_chemin := crée_chaine_c(chemin.chn)
    diffère détruit_chaine_c(chn_c_chemin)

    résultat := realpath(chn_c_chemin, ChaineC(ptr_tampon))

    si résultat comme *z8 == nul {
        // À FAIRE : errno
        retourne CheminFichier()
    }

    retourne CheminFichier(convertis_chaine_c(résultat))
}

// À FAIRE : créer fichier, dossier (récurisevement), mettre à la corbeille, trouver le chemin vers HOME/TMP, copier, opérations sur les chemins

//###############################################################################

renomme :: fonc(orig : &CheminFichier, dest : &CheminFichier) -> z32
{
	ptr_chemin_orig := crée_chaine_c(orig.chn)
    diffère détruit_chaine_c(ptr_chemin_orig)
	ptr_chemin_dest := crée_chaine_c(dest.chn)
    diffère détruit_chaine_c(ptr_chemin_dest)

	retourne rename(ptr_chemin_orig, ptr_chemin_dest)
}

supprime :: fonc(chm : &CheminFichier) -> z32
{
	ptr_chemin := crée_chaine_c(chm.chn)
    diffère détruit_chaine_c(ptr_chemin)
    retourne remove(ptr_chemin)
}

/*

    Opération sur les chemins de fichiers :
    - trouve le nom du dossier
    - trouve le nom du fichier
    - trouve l'extension
    - remplace l'extension
    - chemin relatif (crée_chemin_relatif, est_chemin_relatif, est_relatif_à)
    - chemin absolu (crée_chemin_absolu, est_chemin_absolu)
    - chemins sont équivalents
    - normalisation de chemin
    - crée un nom sûr (pour éviter les problèmes sur Windows dûs à des noms réservés)
    - ajout d'un suffixe avant l'extension (manipulations générales)

    - détermine une séquence de fichier (a001.ext, a0002.ext, etc.)
        -- séquence d'images
        -- séquence de caches
        -- séquence UDIM
        -- avoir un système de token pour définir où se trouve la quantité à trouver
            -- mon_image.<UDIM>.ext
            -- mon_image.<u0_v0>.ext
            -- mon_image.<u1_v1>.ext
            -- etc.
    - crée une séquence de fichier
        -- pour les séquences, l'application cliente peut se charger de créer le bon chemin

 */
