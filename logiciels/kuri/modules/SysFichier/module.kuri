importe Fondation
importe GlibC

CheminFichier :: struct {
    chn : chaine
}

construit_chemin :: fonc(chn : chaine) -> CheminFichier
{
    chemin := CheminFichier( chn = chn )
    retourne chemin
}

obtiens_stmode :: fonc(chemin : &CheminFichier) -> n32
{
	ptr_chemin := chaine_c_temp(chemin.chn)

	st : struct_stat
	ok := stat(ptr_chemin, *st)

	si ok == -1 {
		retourne 0xffffffff
	}

	retourne st.st_mode
}

fichier_existe :: fonc(chemin : &CheminFichier) -> bool
{
    retourne obtiens_stmode(chemin) != 0xffffffff
}

est_dossier :: fonc(chemin : &CheminFichier) -> bool
{
    mode := obtiens_stmode(chemin)

	si mode == 0xffffffff {
		retourne faux
	}

    retourne (mode & __S_IFMT) == __S_IFDIR
}

est_fichier_régulier :: fonc(chemin : &CheminFichier) -> bool
{
    mode := obtiens_stmode(chemin)

	si mode == 0xffffffff {
		retourne faux
	}

    retourne (mode & __S_IFMT) == __S_IFREG
}

est_prise :: fonc(chemin : &CheminFichier) -> bool
{
    mode := obtiens_stmode(chemin)

	si mode == 0xffffffff {
		retourne faux
	}

    retourne (mode & __S_IFMT) == __S_IFSOCK
}

est_lien_symbolique :: fonc(chemin : &CheminFichier) -> bool
{
    mode := obtiens_stmode(chemin)

	si mode == 0xffffffff {
		retourne faux
	}

    retourne (mode & __S_IFMT) == __S_IFLNK
}

est_fichier_périphérique :: fonc(chemin : &CheminFichier) -> bool
{
    mode := obtiens_stmode(chemin)

	si mode == 0xffffffff {
		retourne faux
	}

    retourne (mode & __S_IFMT) == __S_IFBLK
}

est_fichier_caractère :: fonc(chemin : &CheminFichier) -> bool
{
    mode := obtiens_stmode(chemin)

	si mode == 0xffffffff {
		retourne faux
	}

    retourne (mode & __S_IFMT) == __S_IFCHR
}

est_pipe :: fonc(chemin : &CheminFichier) -> bool
{
    mode := obtiens_stmode(chemin)

	si mode == 0xffffffff {
		retourne faux
	}

    retourne (mode & __S_IFMT) == __S_IFIFO
}

ouvre_fichier :: fonc(chemin : &CheminFichier) -> z32
{
	si !fichier_existe(chemin) {
		retourne -1
	}

	ptr_chemin := chaine_c_temp(chemin.chn)
    // @erreur
	retourne open(ptr_chemin, LECTURE_SEULE)
}

ouvre_fichier_ecriture :: fonc(chemin : &CheminFichier) -> z32
{
	ptr_chemin := chaine_c_temp(chemin.chn)
    // @erreur
	retourne open(ptr_chemin, CREATION | ÉCRITURE_SEULE, 0o777)
}

ferme_fichier :: fonc(desc : z32) -> rien
{
	si desc == -1 {
        retourne
	}

    // @erreur
    si close(desc) == -1 {
        retourne
    }
}

contenu_fichier_binaire :: fonc(chemin : &CheminFichier) -> []octet
{
    contenu : []octet

	fd := ouvre_fichier(chemin)
	diffère { ferme_fichier(fd) }

	si fd == -1 {
		retourne contenu
	}

	tampon : [1024]z8

    boucle {
	    // À FAIRE(langage) : prend pointeur automatiquement
		lu := read(fd, *tampon[0], 1024)

		si lu == 0 {
			arrête
		}

		si lu == -1 {
			// À FAIRE : erreur
			déloge contenu
			arrête
		}

		taille_courante := contenu.taille

		reloge contenu : [taille_courante + lu]octet
        contenu.taille += lu

		src := *tampon[0]
		dst := *contenu[taille_courante]

		copie_mem_nonsur(src=src, dst=dst, taille=lu)
	}

    retourne contenu
}

contenu_fichier_texte :: fonc(chemin : &CheminFichier) -> chaine
{
    contenu := contenu_fichier_binaire(chemin)
    chn : chaine;

    nonsûr {
        chn.pointeur = contenu.pointeur comme *z8
        chn.taille = contenu.taille
    }

    retourne chn
}

écris_fichier :: fonc(fd : z32, contenu : chaine) -> rien
{
    // @erreur
    octets_écris := write(fd, contenu.pointeur, contenu.taille)
}

ouvre_dossier :: fonc(chemin : &CheminFichier) -> *DIR
{
	ptr_chemin := chaine_c_temp(chemin.chn)
    retourne opendir(ptr_chemin)
}

chemin_pour_dirname :: fonc(dir : *dirent) -> CheminFichier
{
    taille := taille_chaine_c(*dir.d_name[0])
    chn := construit_chaine(*dir.d_name[0], taille)

    retourne construit_chemin(chn)
}

chaque_chemin :: corout(chemin : &CheminFichier) -> CheminFichier
{
    si !est_dossier(chemin) {
        retourne
    }

    d := ouvre_dossier(chemin)

    si d == nul {
        retourne
    }

    boucle {
        dir := readdir(d)

        si dir == nul {
            arrête
        }

        retiens chemin_pour_dirname(dir)
    }

    _ := closedir(d)
}

//###############################################################################

// File spécialisé pour les DIR.
FileDir :: struct {
	taille : z64
	capacité : z64
	tampon : []*DIR
}

crée_file_dir :: fonc() -> *FileDir
{
	q := loge FileDir
	retourne q
}

decrée_file :: fonc(q : *FileDir) -> rien
{
	q.taille = 0
	q.capacité = 0
	déloge q.tampon
	déloge q
}

enfile :: fonc(q : *FileDir, d : *DIR) -> rien
{
    si q.taille == q.capacité {
		reloge q.tampon : [(q.taille + 1)]*DIR
		q.capacité += 1
    }

	q.tampon[q.taille] = d
	q.taille += 1
}

est_vide :: fonc(q : *FileDir) -> bool
{
	retourne q.taille == 0
}

défile :: fonc(q : *FileDir) -> *DIR
{
    si est_vide(q) {
		retourne nul
    }

    ret := q.tampon[0]
	q.taille -= 1

    pour i dans 1 ... q.taille - 1 {
        q.tampon[i - 1] = q.tampon[i]
    }

    retourne ret
}

//###############################################################################

enfile_dossier :: fonc(file : *FileDir, dir : *dirent, chemin : &CheminFichier) -> rien
{
    chm := chemin_pour_dirname(dir)

    si chm.chn == "." {
        retourne
    }

    si chm.chn == ".." {
        retourne
    }

    // Trouve le chemin absolu.
    chn : chaine
    diffère { déloge chn; }

    si chemin.chn[chemin.chn.taille - 1] != '/' {
        chn = enchaine(chemin.chn, "/", chm.chn)
    }
    sinon {
        chn = enchaine(chemin.chn, chm.chn)
    }

    chm.chn = chn

    nd := ouvre_dossier(chm)

    si nd == nul {
        retourne
    }

    enfile(file, nd)
}

chaque_chemin_récursif :: corout(chemin : &CheminFichier) -> CheminFichier
{
    si !est_dossier(chemin) {
        imprime("Le chemin n'est pas un dossier")
        retourne
    }

    d := ouvre_dossier(chemin)

    si d == nul {
        retourne
    }

    file := crée_file_dir()

    enfile(file, d)

    tantque !est_vide(file) {
        d = défile(file)

        boucle {
            dir := readdir(d)

            si dir == nul {
                arrête
            }

            si dir.d_type == (DT_DIR comme n8) {
                enfile_dossier(file, dir, chemin)
            }

            retiens chemin_pour_dirname(dir)
        }

        _ := closedir(d)
    }

    decrée_file(file)
}

//###############################################################################

chemin_courant :: fonc() -> CheminFichier
{
    // À FAIRE(langage) : dans les métaprogrammes, la prise de pointeur vers *tampon[0] ne semble pas fonctionner
    // tampon : [1024]z8
    // pointeur := getcwd(*tampon[0], 1024)

    tampon := loge chaine(1024)
    diffère { déloge tampon }

    pointeur := getcwd(tampon.pointeur, tampon.taille)

    si pointeur == nul {
        // @erreur
        retourne construit_chemin("")
    }

    ret := copie_chaine_c(pointeur)
    retourne construit_chemin(ret)
}

chemin_courant :: fonc(chemin : CheminFichier) -> rien
{
	ptr_chemin := chaine_c_temp(chemin.chn)
    chdir(ptr_chemin)
}

// À FAIRE : créer fichier, dossier (récurisevement), mettre à la corbeille, trouver le chemin vers HOME/TMP, copier, opérations sur les chemins

//###############################################################################

renomme :: fonc(orig : &CheminFichier, dest : &CheminFichier) -> z32
{
	ptr_chemin_orig := chaine_c_temp(orig.chn)
	ptr_chemin_dest := chaine_c_temp(dest.chn)

	retourne rename(ptr_chemin_orig, ptr_chemin_dest)
}

supprime :: fonc(chm : &CheminFichier) -> z32
{
	ptr_chemin := chaine_c_temp(chm.chn)
    retourne remove(ptr_chemin)
}
