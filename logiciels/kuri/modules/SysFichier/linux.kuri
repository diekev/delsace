importe Chaine
importe Fondation
importe GlibC
importe POSIX

TypePoignéeFichier :: #opaque z32

système_poignée_fichier_invalide :: fonc () -> TypePoignéeFichier
{
    retourne TypePoignéeFichier(-1)
}

opérateur != :: fonc (p0: TypePoignéeFichier, p1: TypePoignéeFichier) -> bool
{
    retourne (p0 comme z32) != (p1 comme z32)
}

initialise_tableau_correspondances :: fonc () -> [NOMBRE_VALEUR_ERRNO]ErreurFichier
{
    résultat : [NOMBRE_VALEUR_ERRNO]ErreurFichier

    pour & résultat {
        it = ErreurFichier.Inconnue
    }

    // système_chemin_courant : Search permission is denied for one of the components of path.  (See also path_resolution(7).)
    résultat[EACCES] = ErreurFichier.PermissionNonAccordé
    // système_chemin_courant : path points outside your accessible address space.
    résultat[EFAULT] = ErreurFichier.MauvaisEspaceAdressage
    // système_chemin_courant : An I/O error occurred.
    résultat[EIO] = ErreurFichier.EntréeSortie
    // système_chemin_courant : Too many symbolic links were encountered in resolving path.
    // système_ouvre : dépend du drapeau
    résultat[ELOOP] = ErreurFichier.TropDeLiensSymboliques
    // système_chemin_courant : path is too long.
    résultat[ENAMETOOLONG] = ErreurFichier.NomTropGrand
    // système_chemin_courant : The directory specified in path does not exist.
    // système_ouvre : dépend du drapeau
    résultat[ENOENT] = ErreurFichier.FichierInexistant
    // système_chemin_courant : Insufficient kernel memory was available.
    // système_ouvre : dépend du type de fichier
    résultat[ENOMEM] = ErreurFichier.MémoireInsuffisante
    // système_chemin_courant : A component of path is not a directory.
    résultat[ENOTDIR] = ErreurFichier.PasDansUnDossier
    // système_ouvre : dépend du drapeau
    // À FAIRE : système_synchronise : SynchronisationImpossiblePourFichier
    // À FAIRE : système_synchronise_données : SynchronisationImpossiblePourFichier
    // système_positionne_fichier : le paramètre « où » est invalide
    résultat[EINVAL] = ErreurFichier.ValeurInvalide
    // système_ouvre : dépend du drapeau
    // À FAIRE : système_synchronise : SynchronisationImpossiblePourFichier
    // À FAIRE : système_synchronise_données : SynchronisationImpossiblePourFichier
    résultat[EROFS] = ErreurFichier.FichierEstLectureSeul
    // système_synchronise : ErreurFichier.EspaceDisqueInexistant
    résultat[ENOSPC] = ErreurFichier.EspaceDisqueInsuffisant
    // système_ouvre : dépend du drapeau
    résultat[EWOULDBLOCK] = ErreurFichier.ActionPeutBloquer
    // À FAIRE : peut-être une erreur séparée ? C'est la même valeur que pour EWOULDBLOCK
    résultat[EAGAIN] = ErreurFichier.ActionPeutBloquer
    résultat[EINTR] = ErreurFichier.InterrompuParSignal
    // système_ouvre : dépend du drapeau
    résultat[EPERM] = ErreurFichier.PermissionNonAccordé
    // système_ouvre : Si O_WRONLY | O_RDWR ou O_TMPFILE and one of O_WRONLY or O_RDWR
    résultat[EISDIR] = ErreurFichier.ActionImpossibleSurDossier
    // À FAIRE
    résultat[ENXIO] = ErreurFichier.EntréeSortieSpéciale // système_ouvre dépend du type de fichier
    résultat[ENXIO] = ErreurFichier.FichierTropPetit // système_positionne_fichier où est SEEK_DATA ou SEEK_HOLE, et le décalage dépasse la taille du fichier
    // À FAIRE : statvfs -> valeurs trop grande pour la structure
    // stat ->  pathname  or  fd  refers to a file whose size, inode number, or number of blocks cannot be represented in, respectively, the types off_t, ino_t, or blkcnt_t.  This error can occur when, for example, an application com‐
    //          piled on a 32-bit platform without -D_FILE_OFFSET_BITS=64 calls stat() on a file whose size exceeds (1<<31)-1 bytes.
    résultat[EOVERFLOW] = ErreurFichier.FichierTropGrand // système_ouvre
    résultat[EOVERFLOW] = ErreurFichier.FichierTropPetit // système_positionne_fichier

    // système_ouvre
    résultat[EDQUOT] = ErreurFichier.EspaceDisqueInsuffisant // O_CREAT
    résultat[EEXIST] = ErreurFichier.FichierExisteDéjà // O_CREAT & O_EXCL
    résultat[EFBIG] = ErreurFichier.FichierTropGrand
    résultat[EMFILE] = ErreurFichier.LimiteOuvertureFichierAtteinte
    résultat[ENFILE] = ErreurFichier.LimiteOuvertureFichierAtteinte
    résultat[ENODEV] = ErreurFichier.MatérielInconnu
    résultat[EOPNOTSUPP] = ErreurFichier.FichierTemporaireNonSupporté
    résultat[ETXTBSY] = ErreurFichier.ImageEnLecture // dépend du drapeau

    // système_ferme
    résultat[EBADF] = ErreurFichier.FichierInvalide

    // système_écris
    résultat[EDESTADDRREQ] = ErreurFichier.PaireNonRenseigné
    // À FAIRE : pas assez général
    résultat[EPIPE] = ErreurFichier.PipeFerméPourÉcriture

    // système_positionne_fichier
    résultat[ESPIPE] = ErreurFichier.FichierEstPipe

    // système_crée_dossier  
    résultat[EMLINK] = ErreurFichier.TropDeLiensSymboliques

    résultat[ENOLCK] = ErreurFichier.ÀCourtDeVerrouxDeFichier

    résultat[ENOSYS] = ErreurFichier.OpérationImpossiblePourLeSystème

    // système_chemin_courant : la taille du nom de fichier est plus grande que le tampon donnée
    résultat[ERANGE] = ErreurFichier.TamponSortieTropPetit

    retourne résultat
}

tableau_correspondances_erreur_fichier_errno := initialise_tableau_correspondances()

convertis_errno_en_erreur_fichier :: fonc () -> ErreurFichier
{
    err := lis_errno()

    si err < 0 || err >= NOMBRE_VALEUR_ERRNO {
        retourne ErreurFichier.Inconnue
    }

    retourne tableau_correspondances_erreur_fichier_errno[err]
}

donne_erreur_si_résultat_invalide :: fonc (résultat: z32) -> Optionnel(ErreurFichier)
{
    si résultat == -1 {
        retourne convertis_errno_en_erreur_fichier()
    }
}

RésultatOpérationFichier :: union {
    e: ErreurFichier
    r: z32
}

système_convertis_raison :: fonc (raison: RaisonOuvertureFichier) -> z32
{
    drapeaux := 0
    si raison.Lecture && raison.Écriture {
        drapeaux |= LECTURE_ÉCRITURE
    }
    sinon si raison.Lecture {
        drapeaux |= LECTURE_SEULE
    }
    sinon si raison.Écriture {
        drapeaux |= ÉCRITURE_SEULE
    }
    si raison.Création {
        drapeaux |= CREATION
    }
    si raison.Troncage {
        drapeaux |= TRONCAGE
    }
    si raison.Ajout {
        drapeaux |= APPEND
    }
    retourne drapeaux
}

système_ouvre :: fonc (chemin: CheminFichier, raison: RaisonOuvertureFichier, permissions: z32) -> RésultatOpérationFichier
{
  	ptr_chemin := crée_chaine_c(chemin.chn)
    diffère détruit_chaine_c(ptr_chemin)

    drapeaux := système_convertis_raison(raison)

    résultat := open(ptr_chemin, drapeaux, permissions)

    // À FAIRE : certaine valeur dépendent des drapeaux (création, écriture, ...)
    // il faudra atomiser l'interface, la préciser pour savoir quoi faire
    si résultat == -1 {
        retourne convertis_errno_en_erreur_fichier()
    }

    retourne résultat
}

système_ferme :: fonc (fd: TypePoignéeFichier) -> Optionnel(ErreurFichier)
{
    résultat := close(fd comme z32)
    retourne donne_erreur_si_résultat_invalide(résultat)
}

système_synchronise :: fonc (fd: TypePoignéeFichier) -> Optionnel(ErreurFichier)
{
    résultat := fsync(fd comme z32)
    retourne donne_erreur_si_résultat_invalide(résultat)
}

système_synchronise_données :: fonc (fd: TypePoignéeFichier) -> Optionnel(ErreurFichier)
{
    résultat := fdatasync(fd comme z32)
    retourne donne_erreur_si_résultat_invalide(résultat)
}

système_écris :: fonc (fd: TypePoignéeFichier, ptr:  *z8, taille: z64) -> RésultatOpérationFichier
{
    résultat := write(fd comme z32, ptr, taille)

    si résultat == -1 {
        retourne convertis_errno_en_erreur_fichier()
    }

    retourne résultat
}

RésultatLecture :: union {
    e: ErreurFichier
    r: z64
}

système_lis :: fonc (fd: TypePoignéeFichier, ptr:  *z8, taille: z64) -> RésultatLecture
{
    résultat := read(fd comme z32, ptr, taille comme n64)

    si résultat == -1 {
        retourne convertis_errno_en_erreur_fichier()
    }

    retourne résultat
}

système_positionne_fichier :: fonc (fd: TypePoignéeFichier, position: PositionFichier) -> RésultatOpérationFichier
{
    décalage: z32
    où: z32

    discr position {
        Début(pos) {
            décalage = (pos comme z64) comme z32
            où = SEEK_SET
        }
        Fin(pos) {
            décalage = (pos comme z64) comme z32
            où = SEEK_END
        }
        Décalage(pos) {
            décalage = (pos comme z64) comme z32
            où = SEEK_CUR
        }
        sinon {
            retourne ErreurFichier.ValeurInvalide
        }
    }

    résultat := lseek(fd comme z32, décalage, où)

    si résultat == -1 {
        retourne convertis_errno_en_erreur_fichier()
    }

    retourne résultat comme z32
}

système_position_courante_fichier :: fonc (fd: TypePoignéeFichier) -> RésultatOpérationFichier
{
    retourne système_positionne_fichier(fd, PositionRelative(0))
}

système_position_début_fichier :: fonc (fd: TypePoignéeFichier) -> RésultatOpérationFichier
{
    retourne système_positionne_fichier(fd, PositionDébut(0))
}

système_position_fin_fichier :: fonc (fd: TypePoignéeFichier) -> RésultatOpérationFichier
{
    retourne système_positionne_fichier(fd, PositionFin(0))
}

système_fin_de_fichier :: fonc (fd: TypePoignéeFichier) -> RésultatOpérationFichier
{
    position_courante := tente système_position_courante_fichier(fd) piège err {
        retourne err
    }

    fin_de_fichier := tente système_position_fin_fichier(fd) piège err {
        retourne err
    }

    // repositionne là où nous étions
    _ := tente système_positionne_fichier(fd, PositionDébut(position_courante)) piège err {
        retourne err
    }

    si position_courante >= fin_de_fichier {
        retourne 1
    }

    retourne 0
}

crée_lien_symbolique :: fonc (cible: chaine, chemin_lien: chaine) -> Optionnel(ErreurFichier)
{
    chn_c_cible := crée_chaine_c(cible)
    diffère { détruit_chaine_c(chn_c_cible) }

    chn_c_chemin_lien := crée_chaine_c(chemin_lien)
    diffère { détruit_chaine_c(chn_c_chemin_lien) }

    résultat := symlink(chn_c_cible, chn_c_chemin_lien)
    retourne donne_erreur_si_résultat_invalide(résultat)
}

// À FAIRE : tests
système_crée_dossier :: fonc (chemin_dossier: chaine, mode: z32) -> Optionnel(ErreurFichier)
{
    ptr_chemin := crée_chaine_c(chemin_dossier)
    diffère détruit_chaine_c(ptr_chemin)

    résultat := mkdir(ptr_chemin, mode)

    si résultat == 0 {
        // Succès.
        retourne
    }

    err := convertis_errno_en_erreur_fichier()

    /* Ignore l'erreur si le dossier existe déjà, car vérifier si le dossier existe
     * avant d'appeler cette fonction peut laisser la porte ouverte à des
     * pirates pour créer leur propre dossier. */
    si err == ErreurFichier.FichierExisteDéjà {
        retourne
    }

    retourne err
}

système_découvre_type_fichier :: fonc (chemin: CheminFichier) -> Résultat(TypeFichier, ErreurFichier)
{
    ptr_chemin := crée_chaine_c(chemin.chn)
    diffère détruit_chaine_c(ptr_chemin)

	st : struct_stat
	ok := stat(ptr_chemin, *st)

	si ok == -1 {
		retourne convertis_errno_en_erreur_fichier()
	}

	discr (st.st_mode & __S_IFMT) {
        __S_IFDIR {
            retourne TypeFichier.Dossier
        }
        __S_IFREG {
            retourne TypeFichier.Régulier
        }
        __S_IFSOCK {
            retourne TypeFichier.Prise
        }
        __S_IFLNK {
            retourne TypeFichier.LienSymbolique
        }
        __S_IFBLK {
            retourne TypeFichier.Périphérique
        }
        __S_IFCHR {
            retourne TypeFichier.Caractère
        }
        __S_IFIFO {
            retourne TypeFichier.Canal
        }
        sinon {
            retourne ErreurFichier.Inconnue
        }
    }
}

système_séparateur_chemin_préféré :: fonc () -> z8 #enligne
{
    retourne '/'
}

// -----------------------------------------------------------------------
// Fichiers communs

fichier_entrée_standarde := Fichier( desc = TypePoignéeFichier(STDIN_FILENO) )
fichier_sortie_standarde := Fichier( desc = TypePoignéeFichier(STDOUT_FILENO) )
fichier_sortie_erreur    := Fichier( desc = TypePoignéeFichier(STDERR_FILENO) )

système_entrée_standarde :: fonc () -> *Fichier
{
    retourne *fichier_entrée_standarde
}

système_sortie_standarde :: fonc () -> *Fichier
{
    retourne *fichier_sortie_standarde
}

système_sortie_erreur :: fonc () -> *Fichier
{
    retourne *fichier_sortie_erreur
}

// -----------------------------------------------------------------------
// Pour la lecture des entrées des dossiers

TypePoignéeDossier :: #opaque *DIR
TypePoignéeEntréeDossier :: #opaque *dirent

système_ouvre_dossier :: fonc (chemin : CheminFichier) -> Optionnel(TypePoignéeDossier)
{
    ptr_chemin := crée_chaine_c(chemin.chn)
    diffère détruit_chaine_c(ptr_chemin)

    dir := opendir(ptr_chemin)
    saufsi dir {
        retourne
    }

    retourne TypePoignéeDossier(dir)
}

système_chemin_pour_dossier :: fonc (poignée: TypePoignéeEntréeDossier) -> CheminFichier
{
    entrée := poignée comme *dirent
    chn_c := ChaineC(*entrée.d_name[0])
    taille := taille_chaine_c(chn_c)
    chn := construit_chaine(chn_c comme *z8, taille)
    retourne construit_chemin(chn)
}

système_lis_une_entrée_du_dossier :: fonc (poignée: TypePoignéeDossier) -> Optionnel(TypePoignéeEntréeDossier)
{
    // À FAIRE : erreur
    entrée := readdir(poignée comme *DIR)
    si entrée == nul {
        retourne
    }
    retourne TypePoignéeEntréeDossier(entrée)
}

système_ferme_dossier :: fonc (poignée: TypePoignéeDossier)
{
    _ := closedir(poignée comme *DIR)
}

// ---------------------------------------------------------
// Verrouillage de fichier.

système_verrouille_fichier :: fonc (fichier: *Fichier, verrou: TypeVerrou) -> Optionnel(ErreurFichier)
{
    param_flock := si verrou == TypeVerrou.Partagé {
        LOCK_SH
    }
    sinon {
        LOCK_EX
    }

    résultat := flock(fichier.desc comme z32, param_flock)
    retourne donne_erreur_si_résultat_invalide(résultat)
}

système_déverrouille_fichier :: fonc (fichier: *Fichier)
{
    _ := flock(fichier.desc comme z32, LOCK_UN)
}

// -----------------------------------------------------------------------

système_référence_fichier :: fonc (ancien_fd: TypePoignéeFichier, nouveau_fd: TypePoignéeFichier)
{
    _ := dup2(ancien_fd comme z32, nouveau_fd comme z32)
}

système_espace_disque_disponible :: fonc (chemin: CheminFichier) -> Résultat(n64, ErreurFichier)
{
	ptr_chemin := crée_chaine_c(chemin.chn)
    diffère détruit_chaine_c(ptr_chemin)

    s : struct_statvfs
    résultat := statvfs(ptr_chemin, *s)

    // Si le fichier ou dossier n'exite pas, il y aura aussi une erreur
    si résultat == -1 {
        retourne convertis_errno_en_erreur_fichier()
    }

    // À FAIRE : on peut avoir un compte différent pour les utilisateurs privilégiés.
    retourne s.f_bavail * s.f_bsize
}

système_chemin_courant :: fonc() -> Résultat(CheminFichier, ErreurFichier)
{
    tampon : [1024]z8
    pointeur := getcwd(ChaineC(*tampon[0]), 1024)

    si (pointeur comme *z8) == nul {
        retourne convertis_errno_en_erreur_fichier()
    }

    ret := copie_chaine_c(pointeur)
    retourne construit_chemin(ret)
}

système_chemin_courant :: fonc(chemin : CheminFichier) -> Optionnel(ErreurFichier)
{
	ptr_chemin := crée_chaine_c(chemin.chn)
    diffère détruit_chaine_c(ptr_chemin)
    résultat := chdir(ptr_chemin)
    retourne donne_erreur_si_résultat_invalide(résultat)
}

système_chemin_répertoire_personnel :: fonc () -> CheminFichier
{
    via_environnement := chaine_environnement("HOME")

    si via_environnement {
        retourne CheminFichier(via_environnement)
    }

    // À FAIRE : erreur
    retourne CheminFichier()
}

système_chemin_véritable :: fonc (chemin: CheminFichier) -> Résultat(CheminFichier, ErreurFichier)
{
    tampon : [TAILLE_MAX_CHEMIN]z8
    ptr_tampon := *tampon[0]

    chn_c_chemin := crée_chaine_c(chemin.chn)
    diffère détruit_chaine_c(chn_c_chemin)

    résultat := realpath(chn_c_chemin, ChaineC(ptr_tampon))

    si résultat comme *z8 == nul {
        retourne convertis_errno_en_erreur_fichier()
    }

    retourne CheminFichier(convertis_chaine_c(résultat))
}

système_renomme :: fonc(orig : CheminFichier, dest : CheminFichier) -> Optionnel(ErreurFichier)
{
	ptr_chemin_orig := crée_chaine_c(orig.chn)
    diffère détruit_chaine_c(ptr_chemin_orig)
	ptr_chemin_dest := crée_chaine_c(dest.chn)
    diffère détruit_chaine_c(ptr_chemin_dest)

	résultat := rename(ptr_chemin_orig, ptr_chemin_dest)
    retourne donne_erreur_si_résultat_invalide(résultat)
}

système_supprime :: fonc(chm : CheminFichier) -> Optionnel(ErreurFichier)
{
	ptr_chemin := crée_chaine_c(chm.chn)
    diffère détruit_chaine_c(ptr_chemin)
    résultat := remove(ptr_chemin)
    retourne donne_erreur_si_résultat_invalide(résultat)
}

système_chemin_exécutable :: fonc () -> CheminFichier
{
    résultat : CheminFichier

    TAILLE_TAMPON_READLINK :: 1024
    tampon: [TAILLE_TAMPON_READLINK]z8

    // À FAIRE : erreur
    lus := readlink(ChaineC("/proc/self/exe\0".pointeur), *tampon[0], TAILLE_TAMPON_READLINK comme n64)
    si lus < 0 {
        retourne résultat
    }

    chn := loge_chaine(lus)
    copie_mem_nonsur(src = *tampon[0], dst = chn.pointeur, taille = lus)
    
    résultat.chn = chn

    retourne résultat
}
