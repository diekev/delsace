importe Chaine
importe Fondation
importe Math
importe NumÃ©rique

/* Ceux-lÃ  ne sont pas dans le standard, ce n'est que pour avoir des types pour l'union. */
UndefinedType :: #opaque z32
NullType :: #opaque z32

/* ------------------------------------------------------------------------- */
/** \nom The BigInt Type
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-ecmascript-language-types-symbol-type
 * \{ */

BigInt :: struct {
    // Ã€ FAIRE : implÃ©mente proprement
    valeur: z64
}

big_int_equal :: fonc (x: Valeur @inutilisÃ©e, y: Valeur @inutilisÃ©e) -> bool
{
    panique("big_int equal non-implÃ©mentÃ©")
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 6.1.5 The Symbol Type
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-ecmascript-language-types-symbol-type
 * \{ */

Symbol :: struct {
    /* Soit undefined ou une chaine. */
    description: Optionnel(ECMAString)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 6.1.6.1 The Number Type
 * \{ */

/* 6.1.6.1.3 Number::exponentiate
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-numeric-types-number-exponentiate */
number_exponentiate :: fonc (b: Valeur, e: Valeur) -> Valeur
{
    // Ã€ FAIRE : standardise le reste
    base := b.Number
    exponent := e.Number

    // 1. If exponent is NaN, return NaN.
    si est_nan(exponent) {
        retourne Valeur(Number = NaN)
    }

    // 2. If exponent is either +0ğ”½ or -0ğ”½, return 1ğ”½.
    si exponent == 0.0 || exponent == -0.0 {
        retourne Valeur(Number = 1.0)
    }

    // 3. If base is NaN, return NaN.
    si est_nan(base) {
        retourne Valeur(Number = NaN)
    }

    retourne Valeur(Number = puissance(b, e))
}

/* 6.1.6.1.13 Number::equal ( x, y )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-numeric-types-number-equal */
number_equal :: fonc (vx: Valeur, vy: Valeur) -> bool
{
    x := vx.Number
    y := vy.Number

    // 1. If x is NaN, return false.
    si est_nan(x) {
        retourne faux
    }

    // 2. If y is NaN, return false.
    si est_nan(y) {
        retourne faux
    }

    // 3. If x is y, return true.
    // NOTE : la comparaison x == y est pour les valeurs infinies.
    si abs(x - y) <= 1e-15 || (x == y) {
        retourne vrai
    }

    // 4. If x is +0ğ”½ and y is -0ğ”½, return true.
    si x == 0.0 && y == -0.0 {
        retourne vrai
    }

    // 5. If x is -0ğ”½ and y is +0ğ”½, return true.
    si x == -0.0 && y == 0.0 {
        retourne vrai
    }

    // 6. Return false.
    retourne faux
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom PropertyDescriptor
 * 6.2.6 The Property Descriptor Specification Type
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-property-descriptor-specification-type
 * \{ */

PropertyDescriptor :: struct {
    value: Optionnel(Valeur)
    get: Optionnel(*Object) // ou undefined
    set: Optionnel(*Object) // ou undefined
    writable: Optionnel(bool)
    configurable: Optionnel(bool)
    enumerable: Optionnel(bool)
}

initialise_property_descriptor :: fonc (desc: *PropertyDescriptor, valeur: Valeur, drapeaux: DrapeauxPropriÃ©tÃ©)
{
    /* Pour les rÃ©utilisation de variable. */
    init_de(PropertyDescriptor)(desc)

    desc.value = valeur

    si drapeaux.CONFIGURABLE {
        desc.configurable = vrai
    }
    si drapeaux.ENUMERABLE {
        desc.enumerable = vrai
    }
    si drapeaux.WRITABLE {
        desc.writable = vrai
    }
}

/* 6.2.6.1 IsAccessorDescriptor ( Desc )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-isaccessordescriptor */
is_accessor_descriptor :: fonc (desc: &PropertyDescriptor) -> bool
{
    // Ã€ FAIRE 1. If Desc is undefined, return false.

    // 2. If Desc has a [[Get]] field, return true.
    si desc.get.possÃ¨de_valeur() {
        retourne vrai
    }
    // 3. If Desc has a [[Set]] field, return true.
    si desc.set.possÃ¨de_valeur() {
        retourne vrai
    }
    // 4. Return false.
    retourne faux
}

/* 6.2.6.2 IsDataDescriptor ( Desc )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-isdatadescriptor */
is_data_descriptor :: fonc (desc: &PropertyDescriptor) -> bool
{
    // Ã€ FAIRE 1. If Desc is undefined, return false.

    // 2. If Desc has a [[Value]] field, return true.
    si desc.value.possÃ¨de_valeur() {
        retourne vrai
    }
    // 3. If Desc has a [[Writable]] field, return true.
    si desc.writable.possÃ¨de_valeur() {
        retourne vrai
    }
    // 4. Return false.
    retourne faux
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom PropertyKey
 * \{ */

PropertyKey :: union {
    String: ECMAString
    Symbol: *Symbol
}

est_chaine :: fonc (key: PropertyKey) -> bool
{
    discr key {
        String {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_symbol :: fonc (key: PropertyKey) -> bool
{
    discr key {
        Symbol {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

opÃ©rateur == :: fonc (p1: PropertyKey, p2: PropertyKey) -> bool
{
    discr p1 {
        String(s1) {
            discr p2 {
                String(s2) {
                    retourne s1 == s2
                }
                sinon {
                    retourne faux
                }
            }
        }
        Symbol(s1) {
            discr p2 {
                Symbol(s2) {
                    retourne s1 == s2
                }
                sinon {
                    retourne faux
                }
            }
        }
        sinon {
            retourne faux
        }
    }
}

opÃ©rateur != :: fonc (p1: PropertyKey, p2: PropertyKey) -> bool
{
    retourne !(p1 == p2)
}

/* https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#array-index */
is_array_index :: fonc (property_key: PropertyKey) -> bool
{
    saufsi property_key.est_chaine() {
        retourne faux
    }

    /* Ã€ FAIRE */
    texte := property_key.String.donne_chaine_utf16()

    texte_utf8 := converti_vers_chaine(texte)
    diffÃ¨re dÃ©loge(texte_utf8)

    rÃ©sultat := tente extrait_r64(texte_utf8) piÃ¨ge _ {
        retourne faux
    }

    retourne is_non_negative_integral_number(rÃ©sultat)
}

to_uint32 :: fonc (property_key: PropertyKey) -> n32
{
    texte := property_key.String.donne_chaine_utf16()

    /* Ã€ FAIRE */
    texte_utf8 := converti_vers_chaine(texte)
    diffÃ¨re dÃ©loge(texte_utf8)

    rÃ©sultat := tente extrait_r64(texte_utf8) piÃ¨ge nonatteignable
    retourne rÃ©sultat comme n32
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom PrimitiveChaine
 * \{ */

#portÃ©e_fichier

table_virtuelle_primitive_chaine := TableVirtuelleCellule(classe = PrimitiveChaine)

#portÃ©e_export

PrimitiveChaine :: struct {
    empl cellule: Cellule
    table = *table_virtuelle_primitive_chaine

    texte: ECMAString
    objet: *Object
}

crÃ©e_chaine :: fonc (realm: *Realm, texte: ECMAString) -> *PrimitiveChaine
{
    pour realm.chaines {
        si it.texte == texte {
            retourne it
        }
    }

    tas_de_mÃ©moire := realm.donne_tas_de_mÃ©moire()
    rÃ©sultat := tas_de_mÃ©moire.alloue(PrimitiveChaine)
    rÃ©sultat.texte = texte
    tableau_ajoute(*realm.chaines, rÃ©sultat)
    retourne rÃ©sultat
}

crÃ©e_chaine :: fonc (tas_de_mÃ©moire: *TasDeMÃ©moire, texte: ECMAString) -> *PrimitiveChaine
{
    rÃ©sultat := tas_de_mÃ©moire.alloue(PrimitiveChaine)
    rÃ©sultat.texte = texte
    retourne rÃ©sultat
}

concatÃ¨ne :: fonc (realm: *Realm, str_gauche: *PrimitiveChaine, str_droite: *PrimitiveChaine) -> Valeur
{
    chn1 := str_gauche.texte.donne_chaine_utf16()
    chn2 := str_droite.texte.donne_chaine_utf16()

    enchaineuse: EnchaineuseUTF16
    initialise_enchaineuse(enchaineuse)
    diffÃ¨re dÃ©truit_tampons(enchaineuse)

    ajoute(enchaineuse, chn1)
    ajoute(enchaineuse, chn2)

    chn := chaine_depuis_enchaineuse(enchaineuse)
    diffÃ¨re dÃ©truit_chaine(chn)
    chn_rÃ©sultat := crÃ©e_chaine_utf16_unique(chn)

    retourne Valeur(String = crÃ©e_chaine(realm, chn_rÃ©sultat))
}

/** \} */
