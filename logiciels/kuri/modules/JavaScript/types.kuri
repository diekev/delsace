importe Algorithmes

/* Ceux-lÃ  ne sont pas dans le standard, ce n'est que pour avoir des types pour l'union. */
UndefinedType :: #opaque z32
NullType :: #opaque z32

/* ------------------------------------------------------------------------- */
/** \nom The BigInt Type
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-ecmascript-language-types-symbol-type
 * \{ */

BigInt :: struct {
    // Ã€ FAIRE : implÃ©mente proprement
    valeur: z64
}

big_int_equal :: fonc (x: Valeur @inutilisÃ©e, y: Valeur @inutilisÃ©e) -> bool
{
    panique("big_int equal non-implÃ©mentÃ©")
}

big_int_bitwise_not :: fonc (x: Valeur @inutilisÃ©e) -> Valeur
{
    panique("big_int_bitwise_not non-implÃ©mentÃ©")
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 6.1.5 The Symbol Type
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-ecmascript-language-types-symbol-type
 * \{ */

Symbol :: struct {
    /* Soit undefined ou une chaine. */
    description: Optionnel(ECMAString)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 6.1.6.1 The Number Type
 * \{ */

/* 6.1.6.1.1 Number::unaryMinus ( x )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-numeric-types-number-unaryMinus */
number_unary_minus :: fonc (x: Valeur) -> Valeur
{
    // 1. If x is NaN, return NaN.
    si est_nan(x) {
        retourne Valeur(Number = NaN)
    }

    // 2. Return the negation of x; that is, compute a Number with the same magnitude but opposite sign.
    retourne Valeur(Number = -x.Number)
}

/* 6.1.6.1.2 Number::bitwiseNOT ( x )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-numeric-types-number-bitwiseNOT */
number_bitwise_not :: fonc (x: Valeur) -> Valeur
{
    // 1. Let oldValue be ! ToInt32(x).
    old_value := to_int32(x) comme z32

    // 2. Return the bitwise complement of oldValue.
    // The mathematical value of the result is exactly representable as a 32-bit two's complement bit string.
    retourne Valeur(Number = ~old_value comme r64)
}

/* 6.1.6.1.3 Number::exponentiate
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-numeric-types-number-exponentiate */
number_exponentiate :: fonc (b: Valeur, e: Valeur) -> Valeur
{
    // Ã€ FAIRE : standardise le reste
    base := b.Number
    exponent := e.Number

    // 1. If exponent is NaN, return NaN.
    si est_nan(exponent) {
        retourne Valeur(Number = NaN)
    }

    // 2. If exponent is either +0ğ”½ or -0ğ”½, return 1ğ”½.
    si exponent == 0.0 || exponent == -0.0 {
        retourne Valeur(Number = 1.0)
    }

    // 3. If base is NaN, return NaN.
    si est_nan(base) {
        retourne Valeur(Number = NaN)
    }

    retourne Valeur(Number = puissance(b, e))
}

/* 6.1.6.1.4 Number::multiply ( x, y )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-numeric-types-number-multiply */
number_multiply :: fonc (gauche: Valeur, droite: Valeur) -> Valeur
{
    // Ã€ FAIRE : standardise
    assert(gauche.est_nombre())
    assert(droite.est_nombre())
    retourne Valeur(Number = gauche.Number * droite.Number)
}

/* 6.1.6.1.5 Number::divide ( x, y )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-numeric-types-number-divide */
number_divide :: fonc (gauche: Valeur, droite: Valeur) -> Valeur
{
    // Ã€ FAIRE : standardise
    assert(gauche.est_nombre())
    assert(droite.est_nombre())
    retourne Valeur(Number = gauche.Number / droite.Number)
}

/* 6.1.6.1.6 Number::remainder ( n, d )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-numeric-types-number-remainder */
number_remainder :: fonc (gauche: Valeur, droite: Valeur) -> Valeur
{
    assert(gauche.est_nombre())
    assert(droite.est_nombre())
    retourne Valeur(Number = mod(gauche.Number, droite.Number))
}

/* 6.1.6.1.7 Number::add ( x, y )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-numeric-types-number-add */
number_add :: fonc (gauche: Valeur, droite: Valeur) -> Valeur
{
    assert(gauche.est_nombre())
    assert(droite.est_nombre())
    retourne Valeur(Number = gauche.Number + droite.Number)
}

/* 6.1.6.1.8 Number::subtract ( x, y )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-numeric-types-number-subtract */
number_subtract :: fonc (gauche: Valeur, droite: Valeur) -> Valeur
{
    assert(gauche.est_nombre())
    assert(droite.est_nombre())
    retourne Valeur(Number = gauche.Number - droite.Number)
}

/* 6.1.6.1.9 Number::leftShift ( x, y )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-numeric-types-number-leftShift */
number_left_shift :: fonc (gauche: Valeur, droite: Valeur) -> Valeur
{
    assert(gauche.est_nombre())
    assert(droite.est_nombre())
    g := gauche.Number comme z32
    d := droite.Number comme z32
    r := g << d
    retourne Valeur(Number = r comme r64)
}

/* 6.1.6.1.10 Number::signedRightShift ( x, y )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-numeric-types-number-signedRightShift */
number_signed_right_shift :: fonc (gauche: Valeur, droite: Valeur) -> Valeur
{
    assert(gauche.est_nombre())
    assert(droite.est_nombre())
    g := gauche.Number comme z32
    d := droite.Number comme z32
    r := g >> d
    retourne Valeur(Number = r comme r64)
}

/* 6.1.6.1.11 Number::unsignedRightShift ( x, y )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-numeric-types-number-unsignedRightShift */
number_unsigned_right_shift :: fonc (gauche: Valeur, droite: Valeur) -> Valeur
{
    assert(gauche.est_nombre())
    assert(droite.est_nombre())
    g := gauche.Number comme n32
    d := droite.Number comme n32
    r := g >> d
    retourne Valeur(Number = r comme r64)
}

/* 6.1.6.1.12 Number::lessThan ( x, y )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-numeric-types-number-lessThan */
number_less_than :: fonc (gauche: Valeur, droite: Valeur) -> Valeur
{
    retourne Valeur(Boolean = gauche.Number < droite.Number)
}

/* 6.1.6.1.13 Number::equal ( x, y )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-numeric-types-number-equal */
number_equal :: fonc (vx: Valeur, vy: Valeur) -> bool
{
    x := vx.Number
    y := vy.Number

    // 1. If x is NaN, return false.
    si est_nan(x) {
        retourne faux
    }

    // 2. If y is NaN, return false.
    si est_nan(y) {
        retourne faux
    }

    // 3. If x is y, return true.
    // NOTE : la comparaison x == y est pour les valeurs infinies.
    si abs(x - y) <= 1e-15 || (x == y) {
        retourne vrai
    }

    // 4. If x is +0ğ”½ and y is -0ğ”½, return true.
    si x == 0.0 && y == -0.0 {
        retourne vrai
    }

    // 5. If x is -0ğ”½ and y is +0ğ”½, return true.
    si x == -0.0 && y == 0.0 {
        retourne vrai
    }

    // 6. Return false.
    retourne faux
}

/* 6.1.6.1.14 Number::sameValue ( x, y )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-numeric-types-number-sameValue */
number_same_value :: fonc (vx: Valeur, vy: Valeur) -> Valeur
{
    x := vx.Number
    y := vy.Number

    // 1. If x is NaN and y is NaN, return true.
    si est_nan(x) && est_nan(y) {
        retourne vrai
    }

    // 2. If x is +0ğ”½ and y is -0ğ”½, return false.
    si x == 0.0 && y == -0.0 {
        retourne faux
    }

    // 3. If x is -0ğ”½ and y is +0ğ”½, return false.
    si x == -0.0 && y == 0.0 {
        retourne faux
    }

    // 4. If x is y, return true.
    si x == y {
        retourne vrai
    }

    // 5. Return false.
    retourne faux
}

/* 6.1.6.1.15 Number::sameValueZero ( x, y )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-numeric-types-number-sameValueZero */
number_same_value_zero :: fonc (vx: Valeur, vy: Valeur) -> Valeur
{
    x := vx.Number
    y := vy.Number

    // 1. If x is NaN and y is NaN, return true.
    si est_nan(x) && est_nan(y) {
        retourne vrai
    }

    // 2. If x is +0ğ”½ and y is -0ğ”½, return true.
    si x == 0.0 && y == -0.0 {
        retourne vrai
    }

    // 3. If x is -0ğ”½ and y is +0ğ”½, return true.
    si x == -0.0 && y == 0.0 {
        retourne vrai
    }

    // 4. If x is y, return true.
    si x == y {
        retourne vrai
    }

    // 5. Return false.
    retourne faux
}

/* 6.1.6.1.17 Number::bitwiseAND ( x, y )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-numeric-types-number-bitwiseAND */
number_bitwise_and :: fonc (gauche: Valeur, droite: Valeur) -> Valeur
{
    assert(gauche.est_nombre())
    assert(droite.est_nombre())
    g := gauche.Number comme z32
    d := droite.Number comme z32
    r := g & d
    retourne Valeur(Number = r comme r64)
}

/* 6.1.6.1.18 Number::bitwiseXOR ( x, y )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-numeric-types-number-bitwiseXOR */
number_bitwise_xor :: fonc (gauche: Valeur, droite: Valeur) -> Valeur
{
    assert(gauche.est_nombre())
    assert(droite.est_nombre())
    g := gauche.Number comme z32
    d := droite.Number comme z32
    r := g ^ d
    retourne Valeur(Number = r comme r64)
}

/* 6.1.6.1.19 Number::bitwiseOR ( x, y )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-numeric-types-number-bitwiseOR */
number_bitwise_or :: fonc (gauche: Valeur, droite: Valeur) -> Valeur
{
    assert(gauche.est_nombre())
    assert(droite.est_nombre())
    g := gauche.Number comme z32
    d := droite.Number comme z32
    r := g | d
    retourne Valeur(Number = r comme r64)
}

prÃ©cision_max_pour_radix := n8.[
    0,  0,  52, 32, 26, 22, 20, 18, 17, 16,
    15, 15, 14, 14, 13, 13, 13, 12, 12, 12,
    12, 11, 11, 11, 11, 11, 11, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10]

/* 6.1.6.1.20 Number::toString ( x, radix )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-numeric-types-number-tostring */
number_to_string :: fonc (realm: *Realm, valeur: Valeur, radix_mv: n32) -> Valeur
{
    x := valeur.Number
    // 1. If x is NaN, return "NaN".
    si est_nan(x) {
        retourne crÃ©e_chaine(realm, STR_NaN)
    }

    // 2. If x is either +0ğ”½ or -0ğ”½, return "0".
    si x == 0.0 || x == -0.0 {
        retourne crÃ©e_chaine(realm, crÃ©e_chaine_utf16_unique("0"))
    }

    // 3. If x < -0ğ”½, return the string-concatenation of "-" and Number::toString(-x, radix_mv).
    si x < -0.0 {
        chn_moins := crÃ©e_chaine(realm, crÃ©e_chaine_utf16_unique("-"))
        chn_x := number_to_string(realm, Valeur(Number = -x), radix_mv)
        retourne concatÃ¨ne(realm, chn_moins, chn_x.String)
    }

    // 4. If x is +âˆğ”½, return "Infinity".
    si x == R64_INFINITÃ‰ {
        retourne crÃ©e_chaine(realm, STR_Infinity)
    }

    // Ã€ FAIRE : implÃ©mente selon le standard.

    nÃ©gatif := x < 0.0
    si nÃ©gatif {
        x *= -1.0
    }

    part_entiÃ¨re := plancher(x)
    part_dÃ©cimale := x - part_entiÃ¨re

    caractÃ¨res: [..]z8
    diffÃ¨re dÃ©loge(caractÃ¨res)

    chiffres :: "0123456789abcdefghijklmnopqrstuvwxyz"

    radix := radix_mv comme r64

    si part_entiÃ¨re == 0.0 {
        tableau_ajoute(*caractÃ¨res, '0')
    }
    sinon tantque part_entiÃ¨re > 0.0 {
        caractÃ¨re := chiffres[plancher(mod(part_entiÃ¨re, radix)) comme n64]
        tableau_ajoute(*caractÃ¨res, caractÃ¨re)
        part_entiÃ¨re /= radix
        part_entiÃ¨re = plancher(part_entiÃ¨re)
    }

    si nÃ©gatif {
        tableau_ajoute(*caractÃ¨res, '-')
    }

    tableau_inverse(caractÃ¨res)

    si part_dÃ©cimale != 0.0 {
        tableau_ajoute(*caractÃ¨res, '.')

        prÃ©cision := prÃ©cision_max_pour_radix[radix_mv]
        pour prÃ©cision {
            part_dÃ©cimale *= radix;
            intÃ©grale := plancher(part_dÃ©cimale) comme n64
            tableau_ajoute(*caractÃ¨res, chiffres[intÃ©grale])
            part_dÃ©cimale -= intÃ©grale comme r64
        }

        tantque caractÃ¨res.taille > 0 && caractÃ¨res[caractÃ¨res.taille - 1] == '0' {
            caractÃ¨res.taille -= 1
        }
    }

    chn := chaine(caractÃ¨res.pointeur, caractÃ¨res.taille)
    rÃ©sultat := crÃ©e_chaine_utf16_unique(chn)
    retourne crÃ©e_chaine(realm, rÃ©sultat)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Utilitaire
 * \{ */

est_intÃ©gral :: fonc (n: r64) -> bool
{
    retourne (n comme n64) comme r64 == n
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 6.2.5 The Reference Record Specification Type
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-reference-record-specification-type
 * \{ */

/* Donne des informations sur oÃ¹ fut trouvÃ©e une rÃ©fÃ©rence, dans un DeclarativeEnvironment,
 * par rapport Ã  l'environnement courant. */
CoordonnÃ©eEnvironnement :: struct {
    /* L'index de la rÃ©fÃ©rence dans DeclarativeEnvironment.bindings. */
    index: z32
    /* Le nombre de sauts Ã  effectuer pour aller de l'environnement courant Ã  celui oÃ¹ se
     * trouve la rÃ©fÃ©rence. */
    sauts: z32
}

ReferenceRecord :: struct {
    Base :: union {
        V: Valeur
        E: *Environment
        UNRESOLVABLE: TypeUnresolvable
    }

    base: Base
    referenced_name: ReferencedName
    strict: bool
    valeur_this: Optionnel(Valeur)
    coordonnÃ©e: Optionnel(CoordonnÃ©eEnvironnement)
}

rÃ©fÃ©rence_non_rÃ©solvable :: fonc (nom: ReferencedName, strict: bool) -> ReferenceRecord
{
    rÃ©sultat: ReferenceRecord
    rÃ©sultat.base = TypeUnresolvable(0)
    rÃ©sultat.strict = strict
    rÃ©sultat.referenced_name = nom
    retourne rÃ©sultat
}

/* 6.2.5.1 IsPropertyReference ( V )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-ispropertyreference */
is_property_reference :: fonc (rÃ©fÃ©rence: ReferenceRecord) -> bool
{
    discr rÃ©fÃ©rence.base {
        // 1. If V.[[Base]] is unresolvable, return false.
        UNRESOLVABLE {
            retourne faux
        }
        // 2. If V.[[Base]] is an Environment Record, return false; otherwise return true.
        E {
            retourne faux
        }
        sinon {
            retourne vrai
        }
    }
}

/* 6.2.5.2 IsUnresolvableReference ( V )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-isunresolvablereference */
is_unresolvable_reference :: fonc (rÃ©fÃ©rence: ReferenceRecord) -> bool
{
    // 1. If V.[[Base]] is unresolvable, return true; otherwise return false.
    discr rÃ©fÃ©rence.base {
        UNRESOLVABLE {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

/* 6.2.5.3 IsSuperReference ( V )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-issuperreference */
is_super_reference :: fonc (reference: ReferenceRecord) -> bool
{
    /* 1. If V.[[ThisValue]] is not EMPTY, return true; otherwise return false. */
    discr reference.valeur_this {
        Quelque {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

/* 6.2.5.4 IsPrivateReference ( V )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-isprivatereference */
is_private_reference :: fonc (reference_record: &ReferenceRecord) -> bool
{
    // 1. If V.[[ReferencedName]] is a Private Name, return true; otherwise return false.
    discr reference_record.referenced_name {
        private_name {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

/* 6.2.5.5 GetValue
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-getvalue */
get_value :: fonc (interprÃ©teuse: *InterprÃ©teuse, valeur: ValeurCompletion) -> Valeur
{
    retourne get_value(interprÃ©teuse.donne_realm(), valeur)
}

get_value :: fonc (realm: *Realm, valeur: ValeurCompletion) -> Valeur
{
    saufsi est_reference_record(valeur) {
        si est_empty(valeur) {
            retourne js_undefined
        }
        retourne valeur.V
    }

    retourne get_value(realm, valeur.R)
}

get_value :: fonc (interprÃ©teuse: *InterprÃ©teuse, valeur: ReferenceRecord) -> Valeur
{
    retourne get_value(interprÃ©teuse.donne_realm(), valeur)
}

get_value :: fonc (realm: *Realm, V: ReferenceRecord) -> Valeur
{
    // 1. If V is not a Reference Record, return V.

    // 2. If IsUnresolvableReference(V) is true, throw a ReferenceError exception.
    si is_unresolvable_reference(V) {
        message := imprime_chaine("\"%\" is not defined", V.referenced_name)
        retourne lance_reference_error(realm, message)
    }

    // 3. If IsPropertyReference(V) is true, then
    si is_property_reference(V) {
        // a. Let baseObj be ? ToObject(V.[[Base]]).
        base_object := to_object(realm, V.base.V)
        si realm.possÃ¨de_exception() {
            retourne js_undefined
        }

        // b. If IsPrivateReference(V) is true, then
        si is_private_reference(V) {
            // i. Return ? PrivateGet(baseObj, V.[[ReferencedName]]).
            rÃ©sultat := private_get(base_object, V.referenced_name.private_name)
            retourne rÃ©sultat
        }

        si is_array_key(V.referenced_name) {
            index := to_uint32(V.referenced_name.valeur)
            retourne base_object.internal_get_by_index(index, get_this_value(V))
        }

        // c. If V.[[ReferencedName]] is not a property key, then
        saufsi is_property_key(V.referenced_name) {
            // i. Set V.[[ReferencedName]] to ? ToPropertyKey(V.[[ReferencedName]]).
            property_key := to_property_key(realm, V.referenced_name.valeur)
            si realm.possÃ¨de_exception() {
                retourne js_undefined
            }
            V.referenced_name = property_key.donne_valeur(realm)
        }

        // d. Return ? baseObj.[[Get]](V.[[ReferencedName]], GetThisValue(V)).
        retourne base_object.internal_get(V.referenced_name.donne_property_key(), get_this_value(V))
    }

    // 4. Else,

    // a. Let base be V.[[Base]].
    base := V.base.E
    // b. Assert: base is an Environment Record.

    si V.coordonnÃ©e.possÃ¨de_valeur() {
        coordonnÃ©e := V.coordonnÃ©e.Quelque
        declarative_environment := base.vÃ©rifie_comme(DeclarativeEnvironment)
        retourne declarative_environment.bindings[coordonnÃ©e.index].valeur
    }

    // c. Return ? base.GetBindingValue(V.[[ReferencedName]], V.[[Strict]]) (see 9.1).
    retourne base.get_binding_value(realm, V.referenced_name.donne_property_key(), V.strict)
}

/* 6.2.5.6 PutValue
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-putvalue */
put_value :: fonc (interprÃ©teuse: *InterprÃ©teuse, rÃ©fÃ©rence: ValeurCompletion, valeur: Valeur) -> Valeur
{
    // 1. If V is not a Reference Record, throw a ReferenceError exception.
    saufsi est_reference_record(rÃ©fÃ©rence) {
        message := imprime_chaine("'%' is not assignable", rÃ©fÃ©rence)
        retourne lance_reference_error(interprÃ©teuse.donne_realm(), message)
    }

    record := rÃ©fÃ©rence.R

    // 2. If IsUnresolvableReference(V) is true, then
    si is_unresolvable_reference(record) {
        // a. If V.[[Strict]] is true, throw a ReferenceError exception.
        si record.strict {
            message := imprime_chaine("assignment to undeclared variable \"%\"", record.referenced_name)
            retourne lance_reference_error(interprÃ©teuse, message)
        }

        // b. Let globalObj be GetGlobalObject().
        global_obj := get_global_object(interprÃ©teuse)

        // c. Perform ? Set(globalObj, V.[[ReferencedName]], W, false).
        set(global_obj, record.referenced_name.donne_property_key(), valeur, faux)
        si interprÃ©teuse.possÃ¨de_exception() {
            retourne js_undefined
        }

        // d. Return UNUSED.
        retourne js_undefined
    }

    // 3. If IsPropertyReference(V) is true, then
    si is_property_reference(record) {
        // a. Let baseObj be ? ToObject(V.[[Base]]).
        base_obj := to_object(interprÃ©teuse.donne_realm(), record.base.V)
        si interprÃ©teuse.possÃ¨de_exception() {
            retourne js_undefined
        }

        // b. If IsPrivateReference(V) is true, then
        si is_private_reference(record) {
            // i. Return ? PrivateSet(baseObj, V.[[ReferencedName]], W).
            private_set(base_obj, record.referenced_name.private_name, valeur)
            retourne js_undefined
        }

        succeeded: bool

        si is_array_key(record.referenced_name) {
            index := to_uint32(record.referenced_name.valeur)
            succeeded = base_obj.internal_set_by_index(index, valeur, get_this_value(record))
        }
        sinon {
            // c. If V.[[ReferencedName]] is not a property key, then
            saufsi is_property_key(record.referenced_name) {
                // i. Set V.[[ReferencedName]] to ? ToPropertyKey(V.[[ReferencedName]]).
                property_key := to_property_key(interprÃ©teuse.donne_realm(), record.referenced_name.valeur)
                si interprÃ©teuse.possÃ¨de_exception() {
                    retourne js_undefined
                }
                record.referenced_name = property_key.donne_valeur(interprÃ©teuse.donne_realm())
            }

            succeeded = base_obj.internal_set(record.referenced_name.donne_property_key(), valeur, get_this_value(record))
        }

        // d. Let succeeded be ? baseObj.[[Set]](V.[[ReferencedName]], W, GetThisValue(V)).
        si interprÃ©teuse.possÃ¨de_exception() {
            retourne js_undefined
        }

        // e. If succeeded is false and V.[[Strict]] is true, throw a TypeError exception.
        si succeeded == faux && record.strict {
            retourne lance_type_error(interprÃ©teuse.donne_realm(), "cannot add property on type")
        }
        // f. Return UNUSED.
        retourne js_undefined
    }

    // 4. Else,
    // a. Let base be V.[[Base]].
    base := record.base.E
    // b. Assert: base is an Environment Record.

    si record.coordonnÃ©e.possÃ¨de_valeur() {
        coordonnÃ©e := record.coordonnÃ©e.Quelque
        declarative_environment := base.vÃ©rifie_comme(DeclarativeEnvironment)
        declarative_environment.bindings[coordonnÃ©e.index].valeur = valeur
        retourne vrai
    }

    // c. Return ? base.SetMutableBinding(V.[[ReferencedName]], W, V.[[Strict]]) (see 9.1).
    base.set_mutable_binding(interprÃ©teuse.donne_realm(), record.referenced_name.donne_property_key(), valeur, record.strict)
    retourne vrai
}

/* 6.2.5.7 GetThisValue ( V )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-getthisvalue */
get_this_value :: fonc (reference: ReferenceRecord) -> Valeur
{
    // 1. Assert: IsPropertyReference(V) is true.
    assert(is_property_reference(reference))
    // 2. If IsSuperReference(V) is true, return V.[[ThisValue]]; otherwise return V.[[Base]].
    si is_super_reference(reference) {
        retourne reference.valeur_this.Quelque
    }
    retourne reference.base.V
}

/* 6.2.5.8 InitializeReferencedBinding ( V, W )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-initializereferencedbinding */
initialize_reference_binding :: fonc (reference: ReferenceRecord, valeur: Valeur)
{
    // 1. Assert: IsUnresolvableReference(V) is false.
    assert(!is_unresolvable_reference(reference))

    // 2. Let base be V.[[Base]].
    base := reference.base.E

    // 3. Assert: base is an Environment Record.

    // 4. Return ? base.InitializeBinding(V.[[ReferencedName]], W).
    base.initialize_binding(reference.referenced_name.valeur.String.texte, valeur)
}

/* 6.2.5.9 MakePrivateReference ( baseValue, privateIdentifier )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-makeprivatereference */
make_private_reference :: fonc (interprÃ©teuse: *InterprÃ©teuse, base_value: Valeur, private_identifier: ECMAString) -> ReferenceRecord
{
    // 1. Let privateEnv be the running execution context's PrivateEnvironment.
    mv := interprÃ©teuse.mv
    running_execution_context := donne_running_execution_context(mv)
    private_env := running_execution_context.private_environment

    // 2. Assert: privateEnv is not null.
    assert(private_env != nul)

    // 3. Let privateName be ResolvePrivateIdentifier(privateEnv, privateIdentifier).
    private_name := resolve_private_identifier(private_env, private_identifier)

    // 4. Return the Reference Record { [[Base]]: baseValue, [[ReferencedName]]: privateName, [[Strict]]: true, [[ThisValue]]: empty }.
    retourne ReferenceRecord(base = base_value, referenced_name = private_name, strict = vrai)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom PropertyDescriptor
 * 6.2.6 The Property Descriptor Specification Type
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-property-descriptor-specification-type
 * \{ */

PropertyDescriptor :: struct {
    value: Optionnel(Valeur)
    get: Optionnel(*Object) // ou undefined
    set: Optionnel(*Object) // ou undefined
    writable: Optionnel(bool)
    configurable: Optionnel(bool)
    enumerable: Optionnel(bool)
}

initialise_property_descriptor :: fonc (desc: *PropertyDescriptor, valeur: Valeur, drapeaux: DrapeauxPropriÃ©tÃ©)
{
    /* Pour les rÃ©utilisation de variable. */
    init_de(PropertyDescriptor)(desc)

    desc.value = valeur

    si drapeaux.CONFIGURABLE {
        desc.configurable = vrai
    }
    si drapeaux.ENUMERABLE {
        desc.enumerable = vrai
    }
    si drapeaux.WRITABLE {
        desc.writable = vrai
    }
}

est_vide :: fonc (desc: PropertyDescriptor) -> bool
{
    retourne !(desc.value.possÃ¨de_valeur() || desc.get.possÃ¨de_valeur() || desc.set.possÃ¨de_valeur() || desc.writable.possÃ¨de_valeur() || desc.enumerable.possÃ¨de_valeur() || desc.configurable.possÃ¨de_valeur())
}

donne_drapeaux_propriÃ©tÃ©s :: fonc (desc: PropertyDescriptor) -> DrapeauxPropriÃ©tÃ©
{
    drapeaux: DrapeauxPropriÃ©tÃ©
    si desc.writable.possÃ¨de_valeur() {
        writable := desc.writable.Quelque
        si writable {
            drapeaux.WRITABLE = vrai
        }
    }
    si desc.configurable.possÃ¨de_valeur() {
        configurable := desc.configurable.Quelque
        si configurable {
            drapeaux.CONFIGURABLE = vrai
        }
    }
    si desc.enumerable.possÃ¨de_valeur() {
        enumerable := desc.enumerable.Quelque
        si enumerable {
            drapeaux.ENUMERABLE = vrai
        }
    }
    retourne drapeaux
}

/* 6.2.6.1 IsAccessorDescriptor ( Desc )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-isaccessordescriptor */
is_accessor_descriptor :: fonc (desc: &PropertyDescriptor) -> bool
{
    // Ã€ FAIRE 1. If Desc is undefined, return false.

    // 2. If Desc has a [[Get]] field, return true.
    si desc.get.possÃ¨de_valeur() {
        retourne vrai
    }
    // 3. If Desc has a [[Set]] field, return true.
    si desc.set.possÃ¨de_valeur() {
        retourne vrai
    }
    // 4. Return false.
    retourne faux
}

/* 6.2.6.2 IsDataDescriptor ( Desc )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-isdatadescriptor */
is_data_descriptor :: fonc (desc: &PropertyDescriptor) -> bool
{
    // Ã€ FAIRE 1. If Desc is undefined, return false.

    // 2. If Desc has a [[Value]] field, return true.
    si desc.value.possÃ¨de_valeur() {
        retourne vrai
    }
    // 3. If Desc has a [[Writable]] field, return true.
    si desc.writable.possÃ¨de_valeur() {
        retourne vrai
    }
    // 4. Return false.
    retourne faux
}

/* 6.2.6.3 IsGenericDescriptor ( Desc )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-isgenericdescriptor */
is_generic_descriptor :: fonc (desc: &PropertyDescriptor) -> bool
{
    // 1. If IsAccessorDescriptor(Desc) is true, return false.
    si is_accessor_descriptor(desc) {
        retourne faux
    }

    // 2. If IsDataDescriptor(Desc) is true, return false.
    si is_data_descriptor(desc) {
        retourne faux
    }

    // 3. Return true.
    retourne vrai
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 6.2.10 The PrivateElement Specification Type
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-privateelement-specification-type
 * \{ */

PrivateElement :: struct {
    Kind :: Ã©num {
        FIELD
        METHOD
        ACCESSOR
    }

    key: PrivateName
    kind: Kind
    value: Valeur
    get: *Object
    set: *Object
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 6.2.11 The ClassFieldDefinition Record Specification Type
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-private-names
 * \{ */

FieldName :: union {
    PrivateName: PrivateName
    String: ECMAString
    Symbol: *Symbol
}

est_private_name :: fonc (field_name: FieldName) -> bool
{
    discr field_name {
        PrivateName {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_symbol :: fonc (field_name: FieldName) -> bool
{
    discr field_name {
        Symbol {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_property_key :: fonc (field_name: FieldName) -> bool
{
    discr field_name {
        String {
            retourne vrai
        }
        Symbol {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

donne_property_key :: fonc (field_name: FieldName) -> PropertyKey
{
    discr field_name {
        String(s) {
            retourne s
        }
        Symbol(s) {
            retourne s
        }
        sinon {
        }
    }
    panique("FieldName n'est pas une PropertyKey")
}

ClassFieldDefinition :: struct {
    name: FieldName
    initializer: *ECMAScriptFunction
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 6.2.12 Private Names
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-private-names
 * \{ */

PrivateName :: struct {
    description: ECMAString // ou StringPrimitive?
}

opÃ©rateur == :: (a: PrivateName, b: PrivateName) -> bool
{
    retourne a.description == b.description
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 6.2.13 The ClassStaticBlockDefinition Record Specification Type
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-classstaticblockdefinition-record-specification-type
 * \{ */

ClassStaticBlockDefinition :: struct {
    body_function: *ECMAScriptFunction
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom PropertyKey
 * \{ */

PropertyKey :: union {
    String: ECMAString
    Symbol: *Symbol
}

formatte_property_key :: fonc (enchaineuse: *Enchaineuse, prop: *PropertyKey)
{
    discr mÃ©moire(prop) {
        String(s) {
            ajoute_au_tampon(enchaineuse, s)
        }
        Symbol(s) {
            ajoute_au_tampon(enchaineuse, "%", s, "%")
        }
        sinon {}
    }
} @FormattageImpression

donne_empreinte :: fonc (key: PropertyKey) -> n64
{
    discr key {
        String(s) {
            retourne s.valeur
        }
        Symbol(s) {
            retourne s comme n64
        }
        sinon {}
    }

    retourne 0
}

est_chaine :: fonc (key: PropertyKey) -> bool
{
    discr key {
        String {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_symbol :: fonc (key: PropertyKey) -> bool
{
    discr key {
        Symbol {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

opÃ©rateur == :: (p1: PropertyKey, p2: PropertyKey) -> bool
{
    discr p1 {
        String(s1) {
            discr p2 {
                String(s2) {
                    retourne s1 == s2
                }
                sinon {
                    retourne faux
                }
            }
        }
        Symbol(s1) {
            discr p2 {
                Symbol(s2) {
                    retourne s1 == s2
                }
                sinon {
                    retourne faux
                }
            }
        }
        sinon {
            retourne faux
        }
    }
}

/* https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#array-index */
is_array_index :: fonc (property_key: PropertyKey) -> bool
{
    saufsi property_key.est_chaine() {
        retourne faux
    }

    /* Ã€ FAIRE */
    texte := property_key.String.donne_chaine_utf16()

    texte_utf8 := converti_vers_chaine(texte)
    diffÃ¨re dÃ©loge(texte_utf8)

    rÃ©sultat := tente extrait_r64(texte_utf8) piÃ¨ge _ {
        retourne faux
    }

    retourne is_non_negative_integral_number(rÃ©sultat)
}

to_uint32 :: fonc (property_key: PropertyKey) -> n32
{
    texte := property_key.String.donne_chaine_utf16()

    /* Ã€ FAIRE */
    texte_utf8 := converti_vers_chaine(texte)
    diffÃ¨re dÃ©loge(texte_utf8)

    rÃ©sultat := tente extrait_r64(texte_utf8) piÃ¨ge nonatteignable
    retourne rÃ©sultat comme n32
}

donne_valeur :: fonc (property_key: PropertyKey, realm: *Realm) -> Valeur
{
    discr property_key {
        String(s) {
            retourne crÃ©e_chaine(realm, s)
        }
        Symbol(s) {
            retourne s
        }
        sinon {}
    }
    retourne js_undefined
}

donne_field_name :: fonc (property_key: PropertyKey) -> FieldName
{
    discr property_key {
        String(s) {
            retourne s
        }
        Symbol(s) {
            retourne s
        }
        sinon {}
    }
    panique("property_key non-initialisÃ©e")
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom PrimitiveChaine
 * \{ */

#portÃ©e_fichier

table_virtuelle_primitive_chaine := TableVirtuelleCellule(classe = PrimitiveChaine)

#portÃ©e_export

PrimitiveChaine :: struct {
    empl cellule: Cellule
    table = *table_virtuelle_primitive_chaine

    texte: ECMAString
    objet: *Object
}

crÃ©e_chaine :: fonc (realm: *Realm, texte: ECMAString) -> *PrimitiveChaine
{
    pour realm.chaines {
        si it.texte == texte {
            retourne it
        }
    }

    tas_de_mÃ©moire := realm.donne_tas_de_mÃ©moire()
    rÃ©sultat := tas_de_mÃ©moire.alloue(PrimitiveChaine)
    rÃ©sultat.texte = texte
    tableau_ajoute(*realm.chaines, rÃ©sultat)
    retourne rÃ©sultat
}

crÃ©e_chaine :: fonc (tas_de_mÃ©moire: *TasDeMÃ©moire, texte: ECMAString) -> *PrimitiveChaine
{
    rÃ©sultat := tas_de_mÃ©moire.alloue(PrimitiveChaine)
    rÃ©sultat.texte = texte
    retourne rÃ©sultat
}

concatÃ¨ne :: fonc (realm: *Realm, str_gauche: *PrimitiveChaine, str_droite: *PrimitiveChaine) -> Valeur
{
    chn1 := str_gauche.texte.donne_chaine_utf16()
    chn2 := str_droite.texte.donne_chaine_utf16()

    enchaineuse: EnchaineuseUTF16
    initialise_enchaineuse(enchaineuse)

    ajoute(enchaineuse, chn1)
    ajoute(enchaineuse, chn2)

    chn := chaine_depuis_enchaineuse(enchaineuse)
    diffÃ¨re dÃ©truit_chaine(chn)
    chn_rÃ©sultat := crÃ©e_chaine_utf16_unique(chn)

    retourne Valeur(String = crÃ©e_chaine(realm, chn_rÃ©sultat))
}

/** \} */
