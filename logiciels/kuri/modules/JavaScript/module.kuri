importe Chaine
importe Fondation
importe Math

charge "arbre"
charge "enveloppe"
charge "environment"
charge "interpr√©teuse"
charge "lexage"
charge "lex√®mes"
charge "parsage"
charge "realm"
charge "script"
charge "tas_de_m√©moire"
charge "terminologie"

charge "Objets/array"
charge "Objets/error"
charge "Objets/function"
charge "Objets/object"
charge "Objets/math"
charge "Objets/string"

ECMAString :: ChaineUTF16Unique

/* ------------------------------------------------------------------------- */
/** \nom Valeur
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof
 * \{ */

NaN : r64 : 0r7ff8000000000000

/* Ceux-l√† ne sont pas dans le standard, ce n'est que pour avoir des types pour l'union. */
UndefinedType :: #opaque z32
NullType :: #opaque z32

BigInt :: struct {
    // √Ä FAIRE : impl√©mente proprement
    valeur: z64
}

big_int_equal :: fonc (x: Valeur @inutilis√©e, y: Valeur @inutilis√©e) -> bool
{
    panique("big_int equal non-impl√©ment√©")
}

/* ------------------------------------------------------------------------- */
/** \nom 6.1.5 The Symbol Type
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-ecmascript-language-types-symbol-type
 * \{ */

Symbol :: struct {
    /* Soit undefined ou une chaine. */
    description: Optionnel(ECMAString)
}

/** \} */

Valeur :: union {
    Undefined: UndefinedType
    Null: NullType
    Boolean: bool
    Number: r64
    BigInt: BigInt
    String: *PrimitiveChaine
    Symbol: *Symbol
    Function: *Function
    Object: *Object
}

imprime_valeur :: fonc (enchaineuse: *Enchaineuse, valeur: *Valeur)
{
    saufsi valeur {
        ajoute_au_tampon(enchaineuse, "nul")
        retourne
    }

    discr m√©moire(valeur) {
        Undefined {
            ajoute_au_tampon(enchaineuse, "undefined")
        }
        Null {
            ajoute_au_tampon(enchaineuse, "null")
        }
        Boolean(b) {
            si b {
                ajoute_au_tampon(enchaineuse, "true")
            }
            sinon {
                ajoute_au_tampon(enchaineuse, "false")
            }
        }
        Number(n) {
            ajoute_au_tampon(enchaineuse, n)
        }
        Object(o) {
            si o.donne_classe() == ReferenceError {
                error := o comme *ReferenceError
                ajoute_au_tampon(enchaineuse, error.donne_nom_classe(), ": ", error.message.texte)
            }
            sinon si o.donne_classe() == TypeError {
                error := o comme *TypeError
                ajoute_au_tampon(enchaineuse, error.donne_nom_classe(), ": ", error.message.texte)
            }
            sinon {
                ajoute_au_tampon(enchaineuse, "[object ", o.donne_nom_classe(), "]")
            }
        }
        Function(o) {
            ajoute_au_tampon(enchaineuse, "[object ", o.donne_nom_classe(), "]")
        }
        String(s) {
            ajoute_au_tampon(enchaineuse, "\"", s.texte, "\"")
        }
        sinon {
            ajoute_au_tampon(enchaineuse, "Valeur inconnue.")
        }
    }
} @FormattageImpression

/* √Ä FAIRE(language) : index_de(valeur) == Number  */
est_fonction :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Function {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_object :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Object {
            retourne vrai
        }
        sinon {
            retourne est_fonction(valeur)
        }
    }
}

donne_objet :: fonc (valeur: Valeur) -> *Object
{
    discr valeur {
        Object(objet) {
            retourne objet
        }
        Function(function) {
            retourne function
        }
        sinon {
            retourne nul
        }
    }
}

est_cellule :: fonc (valeur: Valeur) -> bool
{
    retourne valeur.est_object() || valeur.est_chaine()
}

donne_cellule :: fonc (valeur: Valeur) -> *Cellule
{
    discr valeur {
        Object(o) {
            retourne o
        }
        Function(f) {
            retourne f
        }
        String(s) {
            retourne s
        }
        sinon {
            retourne nul
        }
    }
}

est_nombre :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Number {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_nan :: fonc (valeur: Valeur) -> bool
{
    retourne est_nombre(valeur) && est_nan(valeur.Number)
}

est_chaine :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        String {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_nulle :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Null {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_undefined :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Undefined {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_boolean :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Boolean {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_true :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Boolean {
            retourne valeur.Boolean
        }
        sinon {
            retourne faux
        }
    }
}

est_false :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Boolean {
            retourne !valeur.Boolean
        }
        sinon {
            retourne faux
        }
    }
}

est_big_int :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        BigInt {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_symbol :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Symbol {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

concat√®ne :: fonc (str_gauche: *PrimitiveChaine, str_droite: *PrimitiveChaine) -> Valeur
{
    chn1 := str_gauche.texte.donne_chaine_utf16()
    chn2 := str_droite.texte.donne_chaine_utf16()

    enchaineuse: EnchaineuseUTF16
    initialise_enchaineuse(enchaineuse)
    diff√®re d√©truit_tampons(enchaineuse)

    ajoute(enchaineuse, chn1)
    ajoute(enchaineuse, chn2)

    chn := chaine_depuis_enchaineuse(enchaineuse)
    diff√®re d√©truit_chaine(chn)
    chn_r√©sultat := cr√©e_chaine_utf16_unique(chn)

    retourne Valeur(String = cr√©e_chaine(str_gauche.donne_tas_de_m√©moire(), chn_r√©sultat))
}

js_null := Valeur(Null = NullType(0))
js_undefined := Valeur(Undefined = UndefinedType(0))

TypePr√©f√©r√© :: √©num {
    Aucun
    Number
    String
}

/* 7.1.18 ToObject ( argument )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-toobject */
vers_objet :: fonc (realm: *Realm, valeur: Valeur) -> CompletionRecord
{
    si valeur.est_undefined() {
        retourne lance_type_error(realm, "undefined is not an Object")
    }

    si valeur.est_nulle() {
        retourne lance_type_error(realm, "null is not an Object")
    }

    si valeur.est_object() {
        retourne normal_completion(Valeur(Object = valeur.donne_objet()))
    }

    si valeur.est_chaine() {
        chn := valeur.String
        saufsi chn.objet {
            chn.objet = cr√©e_chaine(realm.donne_tas_de_m√©moire(), realm.intrinsics.string_prototype, valeur.String)
        }
        retourne normal_completion(Valeur(Object = chn.objet))
    }

    panique("vers_objet non-impl√©ment√© pour type")
}

/* 7.1.19 ToPropertyKey ( argument )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-topropertykey */
to_property_key :: fonc (interpr√©teuse: *Interpr√©teuse, argument: Valeur) -> CompletionRecord
{
    retourne to_property_key(interpr√©teuse.donne_realm(), argument)
}

to_property_key :: fonc (realm: *Realm, argument: Valeur) -> CompletionRecord
{
    // 1. Let key be ? ToPrimitive(argument, STRING).
    completion := vers_primitive(realm, argument, TypePr√©f√©r√©.String)
    saufsi completion.est_normal() {
        retourne completion
    }
    key := completion.valeur.V

    // 2. If key is a Symbol, then
    si key.est_symbol() {
        // a. Return key.
        retourne normal_completion(key)
    }

    // 3. Return ! ToString(key).
    retourne vers_chaine(realm, key)
}

/* 7.1.20 ToLength ( argument )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-tolength */
to_length :: fonc (argument: Valeur) -> CompletionRecord
{
    assert(argument.est_nombre())
    /* √Ä FAIRE : ToIntegerOrInfinity. */
    // 1. Let len be ? ToIntegerOrInfinity(argument).
    len := argument.Number

    // 2. If len ‚â§ 0, return +0ùîΩ.
    si len <= 0.0 {
        retourne normal_completion(Valeur(Number = 0.0))
    }

    // 3. Return ùîΩ(min(len, 2**53 - 1)).
    retourne normal_completion(argument)
}

/* 7.1.1 ToPrimitive ( input [ , preferredType ] )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-toprimitive */
vers_primitive :: fonc (interpr√©teuse: *Interpr√©teuse, valeur: Valeur, type_pr√©f√©r√© := TypePr√©f√©r√©.Aucun) -> CompletionRecord
{
    retourne vers_primitive(interpr√©teuse.donne_realm(), valeur, type_pr√©f√©r√©)
}

vers_primitive :: fonc (realm: *Realm, valeur: Valeur, type_pr√©f√©r√© := TypePr√©f√©r√©.Aucun) -> CompletionRecord
{
    // 1. If input is an Object, then
    si valeur.est_object() {
        // √Ä FAIRE : a. Let exoticToPrim be ? GetMethod(input, %Symbol.toPrimitive%).
        // b. If exoticToPrim is not undefined, then
            // i. If preferredType is not present, then
                // 1. Let hint be "default".
            // ii. Else if preferredType is STRING, then
                // 1. Let hint be "string".
            // iii. Else,
                // 1. Assert: preferredType is NUMBER.
                // 2. Let hint be "number".
            // iv. Let result be ? Call(exoticToPrim, input, ¬´ hint ¬ª).
            // v. If result is not an Object, return result.
            // vi. Throw a TypeError exception.

        // c. If preferredType is not present, let preferredType be NUMBER.
        si type_pr√©f√©r√© == TypePr√©f√©r√©.Aucun {
            type_pr√©f√©r√© = TypePr√©f√©r√©.Number
        }

        // d. Return ? OrdinaryToPrimitive(input, preferredType).
        retourne ordinary_to_primitive(realm, valeur.donne_objet(), type_pr√©f√©r√©)
    }

    // 2. Return input.
    retourne normal_completion(valeur)
}

/* 7.1.1.1 OrdinaryToPrimitive ( O, hint )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-ordinarytoprimitive */
ordinary_to_primitive :: fonc (realm: *Realm, object: *Object, hint: TypePr√©f√©r√©) -> CompletionRecord
{
    method_names: [2]ECMAString

    // 1. If hint is string, then
    si hint == TypePr√©f√©r√©.String {
        // a. Let methodNames be ¬´ "toString", "valueOf" ¬ª.
        method_names = [STR_toString, STR_valueOf]
    }
    // 2. Else,
    sinon {
        // a. Let methodNames be ¬´ "valueOf", "toString" ¬ª.
        method_names = [STR_valueOf, STR_toString]
    }

    // 3. For each element name of methodNames, do
    pour method_names {
        // a. Let method be ? Get(O, name).
        completion := get(object, it)
        saufsi completion.est_normal() {
            retourne completion
        }
        method := completion.valeur.V

        // b. If IsCallable(method) is true, then
        si is_callable(method) {
            // i. Let result be ? Call(method, O).
            interpr√©teuse: Interpr√©teuse
            diff√®re d√©truit_donn√©es_interpreteuse(*interpr√©teuse)
            interpr√©teuse.mv = realm.donne_tas_de_m√©moire().donne_mv()
            completion = call(*interpr√©teuse, method, object)
            saufsi completion.est_normal() {
                retourne completion
            }
            result := completion.valeur.V

            // ii. If result is not an Object, return result.
            saufsi result.est_object() {
                retourne normal_completion(result)
            }
        }
    }

    // 4. Throw a TypeError exception.
    retourne lance_type_error(realm, "object cannot be made into a primitive")
}

/* 7.1.2 ToBoolean ( argument )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-toboolean */
to_boolean :: fonc (valeur: Valeur) -> Valeur
{
    // 1. If argument is a Boolean, return argument.
    si valeur.est_boolean() {
        retourne valeur
    }

    // 2. If argument is one of undefined, null, +0ùîΩ, -0ùîΩ, NaN, 0‚Ñ§, or the empty String, return false.
    discr valeur {
        Null {
            retourne Valeur(Boolean = faux)
        }
        Undefined {
            retourne Valeur(Boolean = faux)
        }
        Number(n) {
            si n == 0.0 || n == -0.0 {
                retourne Valeur(Boolean = faux)
            }

            si est_nan(n) {
                retourne faux
            }

            // √Ä FAIRE : 0‚Ñ§
        }
        String(s) {
            si s.texte == cr√©e_chaine_utf16_unique("") {
                retourne Valeur(Boolean = faux)
            }
        }
        sinon {}
    }

    // √Ä FAIRE : 3. If argument is an Object and argument has an [[IsHTMLDDA]] internal slot, return false.

    // 4. Return true.
    retourne Valeur(Boolean = vrai)
}

/* 7.1.3 ToNumeric ( value )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-tonumeric */
to_numeric :: fonc (interpr√©teuse: *Interpr√©teuse, valeur: Valeur) -> CompletionRecord
{
    // 1. Let primValue be ? ToPrimitive(value, NUMBER).
    compl√©tion_valeur_primitive := vers_primitive(interpr√©teuse, valeur, TypePr√©f√©r√©.Number)
    saufsi compl√©tion_valeur_primitive.est_normal() {
        retourne compl√©tion_valeur_primitive
    }
    valeur_primitive := compl√©tion_valeur_primitive.valeur.V

    // 2. If primValue is a BigInt, return primValue.
    si valeur_primitive.est_big_int() {
        retourne normal_completion(valeur_primitive)
    }

    // 3. Return ? ToNumber(primValue).
    retourne vers_nombre(interpr√©teuse, valeur_primitive)
}

/* https://tc39.es/ecma262/multipage/abstract-operations.html#sec-tonumber */
vers_nombre :: fonc (interpr√©teuse: *Interpr√©teuse, valeur: Valeur) -> CompletionRecord
{
    // 1. If argument is a Number, return argument.
    si valeur.est_nombre() {
        retourne normal_completion(valeur)
    }

    // 2. If argument is either a Symbol or a BigInt, throw a TypeError exception.
    si valeur.est_symbol() {
        retourne lance_type_error(interpr√©teuse, "can't convert Symbol to number")
    }
    si valeur.est_big_int() {
        retourne lance_type_error(interpr√©teuse, "can't convert BigInt to number")
    }

    // 3. If argument is undefined, return NaN.
    si valeur.est_undefined() {
        retourne normal_completion(Valeur(Number = NaN))
    }

    // 4. If argument is either null or false, return +0ùîΩ.
    si valeur.est_nulle() || valeur.est_false() {
        retourne normal_completion(Valeur(Number = 0.0))
    }

    // 5. If argument is true, return 1ùîΩ.
    si valeur.est_true() {
        retourne normal_completion(Valeur(Number = 1.0))
    }

    // 6. If argument is a String, return StringToNumber(argument).
    si valeur.est_chaine() {
        retourne normal_completion(string_to_number(valeur))
    }

    // 7. Assert: argument is an Object.
    assert(valeur.est_object())

    // 8. Let primValue be ? ToPrimitive(argument, NUMBER).
    completion_primitive := vers_primitive(interpr√©teuse, valeur, TypePr√©f√©r√©.Number)
    saufsi completion_primitive.est_normal() {
        retourne completion_primitive
    }
    prim_value := completion_primitive.valeur.V

    // 9. Assert: primValue is not an Object.
    assert(prim_value.est_object() == faux)

    // 10. Return ? ToNumber(primValue).
    retourne vers_nombre(interpr√©teuse, prim_value)
}

/* 7.1.4.1.1 StringToNumber ( str )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-stringtonumber */
string_to_number :: fonc (valeur: Valeur) -> Valeur
{
    str := valeur.String.texte

    // √Ä FAIRE : standardise
    // 1. Let literal be ParseText(str, StringNumericLiteral).
    // 2. If literal is a List of errors, return NaN.
    // 3. Return the StringNumericValue of literal.

    source: TexteSource
    source.texte = converti_vers_chaine(str.donne_chaine_utf16())
    diff√®re d√©loge(source.texte)

    lex√®mes: [..]Lex√®me
    diff√®re d√©loge(lex√®mes)

    r√©sultat_lexage := l√®xe(source)
    discr r√©sultat_lexage {
        Ok(l) {
            lex√®mes = l
        }
        sinon {
            retourne Valeur(Number = NaN)
        }
    }

    si lex√®mes.taille != 1 {
        retourne Valeur(Number = NaN)
    }

    /* √Ä FAIRE : prend en compte les signes +/-. */
    si lex√®mes[0].genre != GenreLex√®me.NombreLitt√©ral {
        retourne Valeur(Number = NaN)
    }

    retourne Valeur(Number = parse_nombre_depuis_lex√®me(*lex√®mes[0]))
}

/* 7.1.17 ToString ( argument )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-tostring */
vers_chaine :: fonc (interpr√©teuse: *Interpr√©teuse, argument: Valeur) -> CompletionRecord
{
    retourne vers_chaine(interpr√©teuse.donne_realm(), argument)
}

vers_chaine :: fonc (realm: *Realm, argument: Valeur) -> CompletionRecord
{
    // 1. If argument is a String, return argument.
    si argument.est_chaine() {
        retourne normal_completion(argument)
    }

    // 2. If argument is a Symbol, throw a TypeError exception.
    si argument.est_symbol() {
        retourne lance_type_error(realm, "can't convert Symbol to string")
    }

    // 3. If argument is undefined, return "undefined".
    si argument.est_undefined() {
        retourne normal_completion(cr√©e_chaine(realm.donne_tas_de_m√©moire(), STR_undefined))
    }

    // 4. If argument is null, return "null".
    si argument.est_nulle() {
        retourne normal_completion(cr√©e_chaine(realm.donne_tas_de_m√©moire(), STR_null))
    }

    // 5. If argument is true, return "true".
    si argument.est_true() {
        retourne normal_completion(cr√©e_chaine(realm.donne_tas_de_m√©moire(), STR_true))
    }

    // 6. If argument is false, return "false".
    si argument.est_false() {
        retourne normal_completion(cr√©e_chaine(realm.donne_tas_de_m√©moire(), STR_false))
    }

    // 7. If argument is a Number, return Number::toString(argument, 10).
    si argument.est_nombre() {
        // √Ä FAIRE : impl√©mente selon le standard.
        n := argument.Number
        chn := imprime_chaine("%", n)
        diff√®re d√©loge(chn)

        r√©sultat := cr√©e_chaine_utf16_unique(chn)
        retourne normal_completion(cr√©e_chaine(realm.donne_tas_de_m√©moire(), r√©sultat))
    }

    // 8. If argument is a BigInt, return BigInt::toString(argument, 10).
    si argument.est_big_int() {
        panique("vers_chaine sur big_int non-impl√©ment√©")
    }

    // 9. Assert: argument is an Object.
    assert(argument.est_object())

    // 10. Let primValue be ? ToPrimitive(argument, STRING).
    completion_prim_value := vers_primitive(realm, argument, TypePr√©f√©r√©.String)
    saufsi completion_prim_value.est_normal() {
        retourne completion_prim_value
    }
    prim_value := completion_prim_value.valeur.V

    // 11. Assert: primValue is not an Object.
    assert(!prim_value.est_object())

    // 12. Return ? ToString(primValue).
    retourne vers_chaine(realm, prim_value)
}

/* 7.2.3 IsCallable ( argument )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-iscallable */
is_callable :: fonc (argument: Valeur) -> bool
{
    // 1. If argument is not an Object, return false.
    saufsi argument.est_object() {
        retourne faux
    }

    // 2. If argument has a [[Call]] internal method, return true.
    object := argument.donne_objet()
    si object.donne_table().sur_call {
        retourne vrai
    }

    // 3. Return false.
    retourne faux
}

/* 7.2.4 IsConstructor ( argument )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-isconstructor */
is_constructor :: fonc (argument: Valeur) -> bool
{
    // 1. If argument is not an Object, return false.
    saufsi argument.est_object() {
        retourne faux
    }

    // 2. If argument has a [[Construct]] internal method, return true.
    object := argument.donne_objet()
    si object.donne_table().sur_construct {
        retourne vrai
    }

    // 3. Return false.
    retourne faux
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom PropertyDescriptor
 * 6.2.6 The Property Descriptor Specification Type
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-property-descriptor-specification-type
 * \{ */

PropertyDescriptor :: struct {
    value: Optionnel(Valeur)
    get: Optionnel(*Object) // ou undefined
    set: Optionnel(*Object) // ou undefined
    writable: Optionnel(bool)
    configurable: Optionnel(bool)
    enumerable: Optionnel(bool)
}

/* 6.2.6.1 IsAccessorDescriptor ( Desc )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-isaccessordescriptor */
is_accessor_descriptor :: fonc (desc: &PropertyDescriptor) -> bool
{
    // √Ä FAIRE 1. If Desc is undefined, return false.

    // 2. If Desc has a [[Get]] field, return true.
    si desc.get.poss√®de_valeur() {
        retourne vrai
    }
    // 3. If Desc has a [[Set]] field, return true.
    si desc.set.poss√®de_valeur() {
        retourne vrai
    }
    // 4. Return false.
    retourne faux
}

/* 6.2.6.2 IsDataDescriptor ( Desc )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-isdatadescriptor */
is_data_descriptor :: fonc (desc: &PropertyDescriptor) -> bool
{
    // √Ä FAIRE 1. If Desc is undefined, return false.

    // 2. If Desc has a [[Value]] field, return true.
    si desc.value.poss√®de_valeur() {
        retourne vrai
    }
    // 3. If Desc has a [[Writable]] field, return true.
    si desc.writable.poss√®de_valeur() {
        retourne vrai
    }
    // 4. Return false.
    retourne faux
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom PropertyKey
 * \{ */

PropertyKey :: union {
    String: ECMAString
    Symbol: *Symbol
}

est_symbol :: fonc (key: PropertyKey) -> bool
{
    discr key {
        Symbol {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

op√©rateur == :: fonc (p1: PropertyKey, p2: PropertyKey) -> bool
{
    discr p1 {
        String(s1) {
            discr p2 {
                String(s2) {
                    retourne s1 == s2
                }
                sinon {
                    retourne faux
                }
            }
        }
        Symbol(s1) {
            discr p2 {
                Symbol(s2) {
                    retourne s1 == s2
                }
                sinon {
                    retourne faux
                }
            }
        }
        sinon {
            retourne faux
        }
    }
}

op√©rateur != :: fonc (p1: PropertyKey, p2: PropertyKey) -> bool
{
    retourne !(p1 == p2)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 7.3 Operations on Objects
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-operations-on-objects
 * \{ */

/* 7.3.2 Get
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-get-o-p */
get :: fonc (object: *Object, property_key: PropertyKey) -> CompletionRecord
{
    // 1. Return ? O.[[Get]](P, O).
    retourne object.internal_get(property_key, Valeur(Object = object))
}

/* 7.3.4 Set
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-set-o-p-v-throw */
set :: fonc (object: *Object, property_key: PropertyKey, valeur: Valeur, throw: bool) -> CompletionRecord
{
    // 1. Let success be ? O.[[Set]](P, V, O).
    completion := object.internal_set(property_key, valeur, Valeur(Object = object))
    saufsi completion.est_normal() {
        retourne completion
    }
    succ√®s := completion.valeur.V
    // 2. If success is false and Throw is true, throw a TypeError exception.
    si succ√®s.est_false() && throw == vrai {
        panique("exceptions non-impl√©ment√©es")
    }

    // 3. Return UNUSED.
    retourne normal_completion(js_undefined)
}

/* 7.3.5 CreateDataProperty ( O, P, V )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-createdataproperty */
create_data_property :: fonc (object: *Object, property_key: PropertyKey, valeur: Valeur) -> CompletionRecord
{
    // 1. Let newDesc be the PropertyDescriptor { [[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true }.
    new_desc: PropertyDescriptor
    new_desc.value = valeur
    new_desc.writable = vrai
    new_desc.enumerable = vrai
    new_desc.configurable = vrai

    // 2. Return ? O.[[DefineOwnProperty]](P, newDesc).
    retourne internal_define_own_property(object, property_key, new_desc)
}

/* 7.3.6 CreateDataPropertyOrThrow ( O, P, V )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-createdatapropertyorthrow */
create_data_property_or_throw :: fonc (object: *Object, property_key: PropertyKey, valeur: Valeur) -> CompletionRecord
{
    // 1. Let success be ? CreateDataProperty(O, P, V).
    completion := create_data_property(object, property_key, valeur)
    saufsi completion.est_normal() {
        retourne completion
    }
    success := completion.valeur.V

    // 2. If success is false, throw a TypeError exception.
    si success.est_false() {
        panique("Exception non-impl√©ment√©e")
    }

    // 3. Return UNUSED.
    retourne normal_completion(js_undefined)
}

/* 7.3.8 DefinePropertyOrThrow ( O, P, desc )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-definepropertyorthrow */
define_property_or_throw :: fonc (object: *Object, property_key: PropertyKey, desc: &PropertyDescriptor) -> CompletionRecord
{
    // 1. Let success be ? O.[[DefineOwnProperty]](P, desc).
    completion := internal_define_own_property(object, property_key, desc)
    saufsi completion.est_normal() {
        retourne completion
    }
    success := completion.valeur.V

    // 2. If success is false, throw a TypeError exception.
    si success.est_false() {
        panique("Exception non-impl√©ment√©e")
    }

    // 3. Return UNUSED.
    retourne normal_completion(js_undefined)
}

/* 7.3.11 HasProperty ( O, P ) 
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-hasproperty */
has_property :: fonc (object: *Object, property_key: PropertyKey) -> CompletionRecord
{
    // 1. Return ? O.[[HasProperty]](P).
    retourne internal_has_property(object, property_key)
}

/* 7.3.12 HasOwnProperty ( O, P )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-hasownproperty */
has_own_property :: fonc (object: *Object, nom: PropertyKey) -> CompletionRecord
{
    completion_desc := internal_get_own_property(object, nom)
    saufsi completion_desc.est_normal() {
        retourne completion_desc
    }

    desc := completion_desc.valeur
    si desc.est_undefined() {
        retourne normal_completion(Valeur(Boolean = faux))
    }

    retourne normal_completion(Valeur(Boolean = vrai))
}

/* 7.3.13 Call ( F, V [ , argumentsList ] )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-call */
call :: fonc (interpr√©teuse: *Interpr√©teuse, valeur: Valeur, this_value: Valeur) -> CompletionRecord
{
    // 1. If argumentsList is not present, set argumentsList to a new empty List.
    arguments: []Valeur
    retourne call(interpr√©teuse, valeur, this_value, arguments)
}

call :: fonc (interpr√©teuse: *Interpr√©teuse, valeur: Valeur, this_value: Valeur, arguments: []Valeur) -> CompletionRecord
{
    // Continuation de la version sans arguments.
    // 2. If IsCallable(F) is false, throw a TypeError exception.
    saufsi is_callable(valeur) {
        message := imprime_chaine("'%' is not callable", valeur)
        retourne lance_type_error(interpr√©teuse, message)
    }

    object := valeur.donne_objet()

    // 3. Return ? F.[[Call]](V, argumentsList).
    retourne object.internal_call(interpr√©teuse, this_value, arguments)
}


/* 7.3.14 Construct ( F [ , argumentsList [ , newTarget ] ] )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-call */
construct :: fonc (interpr√©teuse: *Interpr√©teuse, F: Valeur, arguments: []Valeur) -> CompletionRecord
{
    // 1. If newTarget is not present, set newTarget to F.
    new_target := F
    retourne construct(interpr√©teuse, F, arguments, new_target)
}

construct :: fonc (interpr√©teuse: *Interpr√©teuse, F: Valeur, arguments: []Valeur, new_target: Valeur) -> CompletionRecord
{
    // Continuation de la version sans new_target.
    // 2. If argumentsList is not present, set argumentsList to a new empty List.
    // 3. Return ? F.[[Construct]](argumentsList, newTarget).
    object := F.donne_objet()
    retourne object.internal_construct(interpr√©teuse, arguments, new_target)
}

/*7.3.18 LengthOfArrayLike ( obj )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-lengthofarraylike */
length_of_array_like :: fonc (obj: *Object) -> CompletionRecord
{
    // 1. Return ‚Ñù(? ToLength(? Get(obj, "length"))).
    completion := get(obj, STR_length)
    saufsi completion.est_normal() {
        retourne completion
    }
    completion = to_length(completion.valeur.V)
    saufsi completion.est_normal() {
        retourne completion
    }
    retourne normal_completion(completion.valeur.V)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 10.1 Ordinary Object Internal Methods and Internal Slots
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ordinary-object-internal-methods-and-internal-slots
 * \{ */

/* 10.1.1.1 OrdinaryGetPrototypeOf ( O )
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ordinarygetprototypeof */
ordinary_get_prototype_of :: fonc (object: *Object) -> *Object
{
    // Return O.[[Prototype]].
    retourne object.prototype
}

/* 10.1.5.1 OrdinaryGetOwnProperty ( O, P )
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ordinarygetownproperty */
ordinary_get_own_property :: fonc (object: *Object, property_key: PropertyKey) -> CompletionRecord
{
    propri√©t√© := object.trouve_propri√©t√©(property_key)

    // 1. If O does not have an own property with key P, return undefined.
    saufsi propri√©t√© {
        retourne normal_completion(js_undefined)
    }

    // 2. Let D be a newly created Property Descriptor with no fields.
    D: PropertyDescriptor

    // 3. Let X be O's own property whose key is P.
    X := m√©moire(propri√©t√©)

    // 4. If X is a data property, then
    si is_data_propery(X) {
        // a. Set D.[[Value]] to the value of X's [[Value]] attribute.
        D.value = propri√©t√©.valeur

        // b. Set D.[[Writable]] to the value of X's [[Writable]] attribute.
        D.writable = propri√©t√©.drapeaux.WRITABLE == vrai
    }
    // 5. Else,
    sinon {
        // a. Assert: X is an accessor property.
        assert(is_accessor_propery(X))

        // b. Set D.[[Get]] to the value of X's [[Get]] attribute.
        si propri√©t√©.get {
            D.get = propri√©t√©.get
        }

        // c. Set D.[[Set]] to the value of X's [[Set]] attribute.
        si propri√©t√©.set {
            D.set = propri√©t√©.set
        }
    }

    // 6. Set D.[[Enumerable]] to the value of X's [[Enumerable]] attribute.
    D.enumerable = propri√©t√©.drapeaux.ENUMERABLE == vrai

    // 7. Set D.[[Configurable]] to the value of X's [[Configurable]] attribute.
    D.configurable = propri√©t√©.drapeaux.CONFIGURABLE == vrai

    // 8. Return D.
    retourne normal_completion(D)
}

/* 10.1.6 [[DefineOwnProperty]] ( P, Desc )
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ordinarydefineownproperty */
ordinary_define_own_property :: fonc (object: *Object, property_key: PropertyKey, desc: &PropertyDescriptor) -> CompletionRecord
{
    // √Ä FAIRE : standardise
    saufsi desc.value.poss√®de_valeur() {
        retourne normal_completion(Valeur(Boolean = faux))
    }

    valeur := desc.value.Quelque
    drapeaux: DrapeauxPropri√©t√©
    si desc.writable.poss√®de_valeur() {
        writable := desc.writable.Quelque
        si writable {
            drapeaux.WRITABLE = vrai
        }
    }
    si desc.configurable.poss√®de_valeur() {
        configurable := desc.configurable.Quelque
        si configurable {
            drapeaux.CONFIGURABLE = vrai
        }
    }
    si desc.enumerable.poss√®de_valeur() {
        enumerable := desc.enumerable.Quelque
        si enumerable {
            drapeaux.ENUMERABLE = vrai
        }
    }

    propri√©t√© := trouve_propri√©t√©(object, property_key)
    si propri√©t√© {
        propri√©t√©.valeur = valeur
        retourne normal_completion(Valeur(Boolean = vrai))
    }

    object.ajoute_propri√©t√©(property_key, valeur, drapeaux)
    retourne normal_completion(Valeur(Boolean = vrai))
}

/* 10.1.7.1 OrdinaryHasProperty ( O, P )
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ordinaryhasproperty */
ordinary_has_property :: fonc (object: *Object, property_key: PropertyKey) -> CompletionRecord
{
    // 1. Let hasOwn be ? O.[[GetOwnProperty]](P).
    completion := internal_get_own_property(object, property_key)
    saufsi completion.est_normal() {
        retourne completion
    }
    has_own := completion.valeur

    // 2. If hasOwn is not undefined, return true.
    saufsi has_own.est_undefined() {
        retourne normal_completion(Valeur(Boolean = vrai))
    }

    // 3. Let parent be ? O.[[GetPrototypeOf]]().
    parent := internal_get_prototype_of(object)

    // 4. If parent is not null, then
    si parent {
        // a. Return ? parent.[[HasProperty]](P).
        retourne internal_has_property(parent, property_key)
    }

    // 5. Return false.
    retourne normal_completion(Valeur(Boolean = faux))
}

/* 10.1.8.1 OrdinaryGet ( O, P, Receiver )
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver */
ordinary_get :: fonc (object: *Object, property_key: PropertyKey, receiver: Valeur) -> CompletionRecord
{
    // 1. Let desc be ? O.[[GetOwnProperty]](P).
    completion_desc := internal_get_own_property(object, property_key)
    saufsi completion_desc.est_normal() {
        retourne completion_desc
    }

    desc := completion_desc.valeur

    // 2. If desc is undefined, then
    si desc.est_undefined() {
        // a. Let parent be ? O.[[GetPrototypeOf]]().
        parent := internal_get_prototype_of(object)

        // b. If parent is null, return undefined.
        si parent == nul {
            retourne normal_completion(desc)
        }

        // c. Return ? parent.[[Get]](P, Receiver).
        retourne parent.internal_get(property_key, receiver)
    }

    // 3. If IsDataDescriptor(desc) is true, return desc.[[Value]].
    si is_data_descriptor(desc.P) {
        retourne normal_completion(desc.P.value.Quelque)
    }

    // 4. Assert: IsAccessorDescriptor(desc) is true.
    assert(is_accessor_descriptor(desc.P))

    // 5. Let getter be desc.[[Get]].
    getter := desc.P.get

    // 6. If getter is undefined, return undefined.
    saufsi getter.poss√®de_valeur() {
        retourne normal_completion(js_undefined)
    }

    // 7. Return ? Call(getter, Receiver).
    interpr√©teuse: Interpr√©teuse
    interpr√©teuse.mv = receiver.donne_objet().donne_tas_de_m√©moire().donne_mv()
    diff√®re d√©truit_donn√©es_interpreteuse(*interpr√©teuse)
    retourne call(*interpr√©teuse, getter.Quelque, receiver)
}

/* 10.1.9.1 OrdinarySet ( O, P, V, Receiver )
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ordinaryset */
ordinary_set :: fonc (object: *Object, property_key: PropertyKey, valeur: Valeur, receiver: Valeur) -> CompletionRecord
{
    // 1. Let ownDesc be ? O.[[GetOwnProperty]](P).
    completion_desc := internal_get_own_property(object, property_key)
    saufsi completion_desc.est_normal() {
        retourne completion_desc
    }
    own_desc := completion_desc.valeur

    // 2. Return ? OrdinarySetWithOwnDescriptor(O, P, V, Receiver, ownDesc).
    retourne ordinary_set_with_own_descriptor(object, property_key, valeur, receiver, own_desc)
}

/* 10.1.9.2 OrdinarySetWithOwnDescriptor ( O, P, V, Receiver, ownDesc )
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ordinarysetwithowndescriptor */
ordinary_set_with_own_descriptor :: fonc (object: *Object, property_key: PropertyKey, valeur: Valeur, receiver: Valeur, own_desc: ValeurCompletion) -> CompletionRecord
{
    // 1. If ownDesc is undefined, then
    si own_desc.est_undefined() {
        // a. Let parent be ? O.[[GetPrototypeOf]]().
        parent := internal_get_prototype_of(object)

        // b. If parent is not null, then
        si parent {
            // i. Return ? parent.[[Set]](P, V, Receiver).
            retourne internal_set(parent, property_key, valeur, receiver)
        }
        // c. Else,
        sinon {
            // i. Set ownDesc to the PropertyDescriptor { [[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true }.
            own_desc = PropertyDescriptor(value = js_undefined, writable = vrai, enumerable = vrai, configurable = vrai)
        }
    }

    // 2. If IsDataDescriptor(ownDesc) is true, then
    si is_data_descriptor(own_desc.P) {
        // a. If ownDesc.[[Writable]] is false, return false.
        si own_desc.P.writable == faux {
            retourne normal_completion(Valeur(Boolean = faux))
        }

        // b. If Receiver is not an Object, return false.
        saufsi receiver.est_object() {
            retourne normal_completion(Valeur(Boolean = faux))
        }

        // c. Let existingDescriptor be ? Receiver.[[GetOwnProperty]](P).
        completion := internal_get_own_property(receiver.donne_objet(), property_key)
        saufsi completion.est_normal() {
            retourne completion
        }
        existing_descriptor := completion.valeur

        // d. If existingDescriptor is not undefined, then
        saufsi existing_descriptor.est_undefined() {
            // i. If IsAccessorDescriptor(existingDescriptor) is true, return false.
            si is_accessor_descriptor(existing_descriptor.P) {
                retourne normal_completion(Valeur(Boolean = faux))
            }

            // ii. If existingDescriptor.[[Writable]] is false, return false.
            si existing_descriptor.P.writable == faux {
                retourne normal_completion(Valeur(Boolean = faux))
            }

            // iii. Let valueDesc be the PropertyDescriptor { [[Value]]: V }.
            value_desc := PropertyDescriptor(value = valeur)

            // iv. Return ? Receiver.[[DefineOwnProperty]](P, valueDesc).
            retourne internal_define_own_property(receiver.donne_objet(), property_key, value_desc)
        }
        // e. Else,
        sinon {
            // √Ä FAIRE : i. Assert: Receiver does not currently have a property P.

            // ii. Return ? CreateDataProperty(Receiver, P, V).
            retourne create_data_property(receiver, property_key, valeur)
        }
    }

    // 3. Assert: IsAccessorDescriptor(ownDesc) is true.
    assert(is_accessor_descriptor(own_desc.P))

    // 4. Let setter be ownDesc.[[Set]].
    setter := own_desc.P.set

    // 5. If setter is undefined, return false.
    saufsi setter.poss√®de_valeur() {
        retourne normal_completion(Valeur(Boolean = faux))
    }

    // 6. Perform ? Call(setter, Receiver, ¬´ V ¬ª).
    interpr√©teuse: Interpr√©teuse
    interpr√©teuse.mv = receiver.donne_objet().donne_tas_de_m√©moire().donne_mv()
    diff√®re d√©truit_donn√©es_interpreteuse(*interpr√©teuse)

    arguments: []Valeur
    arguments.pointeur = *valeur
    arguments.taille = 1

    completion := call(*interpr√©teuse, setter.Quelque, receiver, arguments)
    saufsi completion.est_normal() {
        retourne completion
    }

    // 7. Return true.
    retourne normal_completion(Valeur(Boolean = vrai))
}

/** \} */

/* 15.2.3 Runtime Semantics: EvaluateFunctionBody
 * https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-runtime-semantics-evaluatefunctionbody */
evaluate_function_body :: fonc (interpr√©teuse: *Interpr√©teuse, function_object: *ECMAScriptFunction, arguments_list: []Valeur) -> CompletionRecord
{
    // 1. Perform ? FunctionDeclarationInstantiation(functionObject, argumentsList).
    completion := function_declaration_instantiation(interpr√©teuse, function_object, arguments_list)
    saufsi completion.est_normal() {
        retourne completion
    }
    // 2. Return ? Evaluation of FunctionStatementList.
    retourne interpr√©teuse.ex√©cute(function_object.corps, TypeScope.FUNCTION)
}

/* ------------------------------------------------------------------------- */
/** \nom 19.2.1 eval ( x )
 * \{ */

#port√©e_fichier

/* Table virtuelle pour "eval()" */
table_virtuelle_function_eval := TableVirtuelleObject(classe = Function, sur_destruction = sur_destruction_objet, sur_call = eval_sur_call)

#port√©e_export

cr√©e_eval :: fonc (function_prototype: *FunctionPrototype) -> *Function
{
    r√©sultat := cr√©e_fonction(function_prototype)
    set_function_name(r√©sultat, STR_eval)
    r√©sultat.table = *table_virtuelle_function_eval
    retourne r√©sultat
}

/* https://tc39.es/ecma262/multipage/global-object.html#sec-eval-x */
eval_sur_call :: fonc (empl params: *Param√®tresObjectCall) -> CompletionRecord
{
    si arguments.taille == 0 {
        retourne normal_completion(js_undefined)
    }

    retourne perform_eval(interpr√©teuse, arguments[0], faux, faux)
}

/* 19.2.1.1 PerformEval ( x, strictCaller, direct )
 * https://tc39.es/ecma262/multipage/global-object.html#sec-performeval */
perform_eval :: fonc (interpr√©teuse: *Interpr√©teuse, x: Valeur, strict_caller: bool, direct: bool) -> CompletionRecord
{
    // 1. Assert: If direct is false, then strictCaller is also false.
    assert(direct == vrai || (direct == faux && strict_caller == faux))

    // 2. If x is not a String, return x.
    saufsi x.est_chaine() {
        retourne normal_completion(x)
    }

    // 3. Let evalRealm be the current Realm Record.
    // 4. NOTE: In the case of a direct eval, evalRealm is the realm of both the caller of eval and of the eval function itself.
    eval_realm := interpr√©teuse.donne_realm()

    // √Ä FAIRE : 5. Perform ? HostEnsureCanCompileStrings(evalRealm, ¬´ ¬ª, x, direct).

    // 6. Let inFunction be false.
    in_function := faux

    // 7. Let inMethod be false.
    // in_method := faux

    // 8. Let inDerivedConstructor be false.
    // in_derived_constructor := faux

    // 9. Let inClassFieldInitializer be false.
    // in_class_field_initializer := faux

    // 10. If direct is true, then
    si direct {
        // a. Let thisEnvRec be GetThisEnvironment().
        this_env_rec := get_this_environment(interpr√©teuse)

        // b. If thisEnvRec is a Function Environment Record, then
        si this_env_rec.table.classe == FunctionEnvironment {
            // √Ä FAIRE : i. Let F be thisEnvRec.[[FunctionObject]].

            // ii. Set inFunction to true.
            in_function = vrai

            // iii. Set inMethod to thisEnvRec.HasSuperBinding().
            // iv. If F.[[ConstructorKind]] is DERIVED, set inDerivedConstructor to true.
            // v. Let classFieldInitializerName be F.[[ClassFieldInitializerName]].
            // vi. If classFieldInitializerName is not EMPTY, set inClassFieldInitializer to true.
        }
    }

    // √Ä FAIRE : 11. Perform the following substeps in an implementation-defined order, possibly interleaving parsing and error detection:
    // √Ä FAIRE : a. Let script be ParseText(x, Script).
    // b. If script is a List of errors, throw a SyntaxError exception.
    script: *Script
    contenu := converti_vers_chaine(x.String.texte.donne_chaine_utf16())
    diff√®re d√©loge(contenu)

    discr parse_script(contenu, eval_realm) {
        Ok(s) {
            script = s
        }
        Erreur(e) {
            diff√®re d√©loge(e.message)
            retourne interpr√©teuse.lance_syntax_error(e.message)
        }
        sinon {
            chn := "Erreur inconnue"
            retourne interpr√©teuse.lance_syntax_error(chn)
        }
    }

    // √Ä FAIRE : c. If script Contains ScriptBody is false, return undefined.
    // √Ä FAIRE : d. Let body be the ScriptBody of script.
    body := script.ecma_script_code

    // √Ä FAIRE : e. If inFunction is false and body Contains NewTarget, throw a SyntaxError exception.
    // √Ä FAIRE : f. If inMethod is false and body Contains SuperProperty, throw a SyntaxError exception.
    // √Ä FAIRE : g. If inDerivedConstructor is false and body Contains SuperCall, throw a SyntaxError exception.
    // √Ä FAIRE : h. If inClassFieldInitializer is true and ContainsArguments of body is true, throw a SyntaxError exception.

    // 12. If strictCaller is true, let strictEval be true.
    strict_eval := si strict_caller {
        vrai
    }
    // 13. Else, let strictEval be ScriptIsStrict of script.
    sinon {
        // √Ä FAIRE : ScriptIsStrict
        faux
    }

    // 14. Let runningContext be the running execution context.
    // 15. NOTE: If direct is true, runningContext will be the execution context that performed the direct eval. If direct is false, runningContext will be the execution context for the invocation of the eval function.
    running_context := interpr√©teuse.donne_running_execution_context()

    lex_env: *Environment
    var_env: *Environment
    private_env: *PrivateEnvironment

    // 16. If direct is true, then
    si direct {
        // a. Let lexEnv be NewDeclarativeEnvironment(runningContext's LexicalEnvironment).
        lex_env = new_declarative_environment(interpr√©teuse.donne_tas_de_m√©moire(), running_context.lexical_environment)

        // b. Let varEnv be runningContext's VariableEnvironment.
        var_env = running_context.variable_environment
    
        // c. Let privateEnv be runningContext's PrivateEnvironment.
        private_env = running_context.private_environment
    }
    // 17. Else,
    sinon {
        // a. Let lexEnv be NewDeclarativeEnvironment(evalRealm.[[GlobalEnv]]).
        lex_env = new_declarative_environment(interpr√©teuse.donne_tas_de_m√©moire(), eval_realm.global_environment)

        // b. Let varEnv be evalRealm.[[GlobalEnv]].
        var_env = eval_realm.global_environment

        // c. Let privateEnv be null.
        private_env = nul
    }

    // 18. If strictEval is true, set varEnv to lexEnv.
    si strict_eval {
        var_env = lex_env
    }

    // 19. If runningContext is not already suspended, suspend runningContext.
    mv := interpr√©teuse.mv
    mv.suspend_running_execution_context()

    // 20. Let evalContext be a new ECMAScript code execution context.
    eval_context := cr√©e_execution_context(interpr√©teuse.donne_tas_de_m√©moire())

    // 21. Set evalContext's Function to null.
    eval_context.function = nul

    // 22. Set evalContext's Realm to evalRealm.
    eval_context.realm = eval_realm

    // 23. Set evalContext's ScriptOrModule to runningContext's ScriptOrModule.
    eval_context.script_or_module = running_context.script_or_module

    // 24. Set evalContext's VariableEnvironment to varEnv.
    eval_context.variable_environment = var_env

    // 25. Set evalContext's LexicalEnvironment to lexEnv.
    eval_context.lexical_environment = lex_env

    // 26. Set evalContext's PrivateEnvironment to privateEnv.
    eval_context.private_environment = private_env

    // 27. Push evalContext onto the execution context stack; evalContext is now the running execution context.
    mv.empile_execution_context(eval_context)

    // √Ä FAIRE : 28. Let result be Completion(EvalDeclarationInstantiation(body, varEnv, lexEnv, privateEnv, strictEval)).
    result := normal_completion(js_undefined)

    // 29. If result is a normal completion, then
    si result.est_normal() {
        // a. Set result to Completion(Evaluation of body).
        result = interpr√©teuse.ex√©cute(body)
    }

    // 30. If result is a normal completion and result.[[Value]] is EMPTY, then
        // a. Set result to NormalCompletion(undefined).

    // 31. Suspend evalContext and remove it from the execution context stack.
    mv.suspend_running_execution_context()
    mv.d√©pile_execution_context()

    // √Ä FAIRE : 32. Resume the context that is now on the top of the execution context stack as the running execution context.

    // 33. Return ? result.
    retourne result
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom PrimitiveChaine
 * \{ */

#port√©e_fichier

table_virtuelle_primitive_chaine := TableVirtuelleCellule(classe = PrimitiveChaine)

#port√©e_export

PrimitiveChaine :: struct {
    empl cellule: Cellule
    table = *table_virtuelle_primitive_chaine

    texte: ECMAString
    objet: *Object
}

cr√©e_chaine :: fonc (tas_de_m√©moire: *TasDeM√©moire, texte: ECMAString) -> *PrimitiveChaine
{
    r√©sultat := tas_de_m√©moire.alloue(PrimitiveChaine)
    r√©sultat.texte = texte
    retourne r√©sultat
}

/** \} */
