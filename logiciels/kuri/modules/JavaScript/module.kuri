importe Fondation

charge "arbre"
charge "enveloppe"
charge "environment"
charge "interpr√©teuse"
charge "lexage"
charge "lex√®mes"
charge "parsage"
charge "realm"
charge "script"
charge "tas_de_m√©moire"

ECMAString :: chaine

/* ------------------------------------------------------------------------- */
/** \nom Valeur
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof
 * \{ */

NaN : r64 : 0r7ff8000000000000

/* Ceux-l√† ne sont pas dans le standard, ce n'est que pour avoir des types pour l'union. */
UndefinedType :: #opaque z32
NullType :: #opaque z32

Valeur :: union {
    Undefined: UndefinedType
    Null: NullType
    Boolean: bool
    Number: r64
    // BigInt
    String: *PrimitiveChaine
    // Symbol
    Function: *Function
    Object: *Object
}

imprime_valeur :: fonc (enchaineuse: *Enchaineuse, valeur: *Valeur)
{
    saufsi valeur {
        ajoute_au_tampon(enchaineuse, "nul")
        retourne
    }

    discr m√©moire(valeur) {
        Undefined {
            ajoute_au_tampon(enchaineuse, "undefined")
        }
        Null {
            ajoute_au_tampon(enchaineuse, "null")
        }
        Boolean(b) {
            si b {
                ajoute_au_tampon(enchaineuse, "true")
            }
            sinon {
                ajoute_au_tampon(enchaineuse, "false")
            }
        }
        Number(n) {
            ajoute_au_tampon(enchaineuse, n)
        }
        Object(o) {
            si o.type == ReferenceError {
                error := o comme *ReferenceError
                ajoute_au_tampon(enchaineuse, error.donne_nom_classe(), ": ", error.message.texte)
            }
            sinon si o.type == TypeError {
                error := o comme *TypeError
                ajoute_au_tampon(enchaineuse, error.donne_nom_classe(), ": ", error.message.texte)
            }
            sinon {
                ajoute_au_tampon(enchaineuse, "[object ", o.donne_nom_classe(), "]")
            }
        }
        Function(o) {
            ajoute_au_tampon(enchaineuse, "[object ", o.donne_nom_classe(), "]")
        }
        String(s) {
            ajoute_au_tampon(enchaineuse, "\"", s.texte, "\"")
        }
        sinon {
            ajoute_au_tampon(enchaineuse, "Valeur inconnue.")
        }
    }
} @FormattageImpression

/* √Ä FAIRE(language) : index_de(valeur) == Number  */
est_fonction :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Function {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_object :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Object {
            retourne vrai
        }
        sinon {
            retourne est_fonction(valeur)
        }
    }
}

donne_objet :: fonc (valeur: Valeur) -> *Object
{
    discr valeur {
        Object(objet) {
            retourne objet
        }
        Function(function) {
            retourne function
        }
        sinon {
            retourne nul
        }
    }
}

est_cellule :: fonc (valeur: Valeur) -> bool
{
    retourne valeur.est_object() || valeur.est_chaine()
}

donne_cellule :: fonc (valeur: Valeur) -> *Cellule
{
    discr valeur {
        Object(o) {
            retourne o
        }
        Function(f) {
            retourne f
        }
        String(s) {
            retourne s
        }
        sinon {
            retourne nul
        }
    }
}

est_nombre :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Number {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_chaine :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        String {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_nulle :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Null {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_undefined :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Undefined {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_boolean :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Boolean {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_true :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Boolean {
            retourne valeur.Boolean
        }
        sinon {
            retourne faux
        }
    }
}

est_false :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Boolean {
            retourne !valeur.Boolean
        }
        sinon {
            retourne faux
        }
    }
}

concat√®ne :: fonc (str_gauche: ECMAString, str_droite: ECMAString) -> Valeur
{
    r√©sultat := enchaine(str_gauche, str_droite)
    retourne Valeur(String = r√©sultat)
}

js_null := Valeur(Null = NullType(0))
js_undefined := Valeur(Undefined = UndefinedType(0))

TypePr√©f√©r√© :: √©num {
    Aucun
    Number
}

vers_objet :: fonc (interpr√©teuse: &Interpr√©teuse, valeur: Valeur) -> *Object
{
    si valeur.est_object() {
        retourne valeur.donne_objet()
    }

    assert(valeur.est_chaine())

    chn := valeur.String
    saufsi chn.objet {
        chn.objet = cr√©e_chaine(*interpr√©teuse.tas_de_m√©moire, interpr√©teuse.realm.intrinsics.string_prototype, valeur.String)
    }
    retourne Valeur(Object = chn.objet)
}

vers_chaine :: fonc (valeur: Valeur) -> ECMAString
{

}

/* 7.1.1 ToPrimitive ( input [ , preferredType ] )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-toprimitive */
vers_primitive :: fonc (interpr√©teuse: &Interpr√©teuse, valeur: Valeur, type_pr√©f√©r√© := TypePr√©f√©r√©.Aucun) -> CompletionRecord
{
    // 1. If input is an Object, then
    si valeur.est_object() {
        panique("to_primitive non-impl√©ment√©")
        // a. Let exoticToPrim be ? GetMethod(input, %Symbol.toPrimitive%).
        // b. If exoticToPrim is not undefined, then
        // i. If preferredType is not present, then
        // 1. Let hint be "default".
        // ii. Else if preferredType is STRING, then
        // 1. Let hint be "string".
        // iii. Else,
        // 1. Assert: preferredType is NUMBER.
        // 2. Let hint be "number".
        // iv. Let result be ? Call(exoticToPrim, input, ¬´ hint ¬ª).
        // v. If result is not an Object, return result.
        // vi. Throw a TypeError exception.
        // c. If preferredType is not present, let preferredType be NUMBER.
        // d. Return ? OrdinaryToPrimitive(input, preferredType).
    }

    // 2. Return input.
    retourne normal_completion(valeur)
}

/* 7.1.3 ToNumeric ( value )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-tonumeric */
to_numeric :: fonc (interpr√©teuse: &Interpr√©teuse, valeur: Valeur) -> CompletionRecord
{
    // 1. Let primValue be ? ToPrimitive(value, NUMBER).
    compl√©tion_valeur_primitive := vers_primitive(interpr√©teuse, valeur, TypePr√©f√©r√©.Number)
    saufsi compl√©tion_valeur_primitive.est_normal() {
        retourne compl√©tion_valeur_primitive
    }
    valeur_primitive := compl√©tion_valeur_primitive.valeur.V

    // √Ä FAIRE(BigInt)
    // 2. If primValue is a BigInt, return primValue.

    // 3. Return ? ToNumber(primValue).
    retourne vers_nombre(interpr√©teuse, valeur_primitive)
}

/* https://tc39.es/ecma262/multipage/abstract-operations.html#sec-tonumber */
vers_nombre :: fonc (interpr√©teuse: &Interpr√©teuse @inutilis√©e, valeur: Valeur) -> CompletionRecord
{
    // 1. If argument is a Number, return argument.
    si valeur.est_nombre() {
        retourne normal_completion(valeur)
    }

    // 2. If argument is either a Symbol or a BigInt, throw a TypeError exception.

    // 3. If argument is undefined, return NaN.
    si valeur.est_undefined() {
        retourne normal_completion(Valeur(Number = NaN))
    }

    // 4. If argument is either null or false, return +0ùîΩ.
    si valeur.est_nulle() || valeur.est_false() {
        retourne normal_completion(Valeur(Number = 0.0))
    }

    // 5. If argument is true, return 1ùîΩ.
    si valeur.est_true() {
        retourne normal_completion(Valeur(Number = 1.0))
    }

    // 6. If argument is a String, return StringToNumber(argument).
    // 7. Assert: argument is an Object.
    // 8. Let primValue be ? ToPrimitive(argument, NUMBER).
    // 9. Assert: primValue is not an Object.
    // 10. Return ? ToNumber(primValue).
    panique("to_number non-impl√©ment√©")
}

/* 7.2.3 IsCallable ( argument )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-iscallable */
is_callable :: fonc (argument: Valeur) -> bool
{
    // 1. If argument is not an Object, return false.
    saufsi argument.est_object() {
        retourne faux
    }

    // 2. If argument has a [[Call]] internal method, return true.
    object := argument.donne_objet()
    si object.sur_call {
        retourne vrai
    }

    // 3. Return false.
    retourne faux
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom PropertyDescriptor
 * 6.2.6 The Property Descriptor Specification Type
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-property-descriptor-specification-type
 * \{ */

PropertyDescriptor :: struct {
    value: Optionnel(Valeur)
    get: Optionnel(*Object) // ou undefined
    set: Optionnel(*Object) // ou undefined
    writable: Optionnel(bool)
    configurable: Optionnel(bool)
    enumerable: Optionnel(bool)
}

/* 6.2.6.1 IsAccessorDescriptor ( Desc )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-isaccessordescriptor */
is_accessor_descriptor :: fonc (desc: &PropertyDescriptor) -> bool
{
    // √Ä FAIRE 1. If Desc is undefined, return false.

    // 2. If Desc has a [[Get]] field, return true.
    si desc.get.poss√®de_valeur() {
        retourne vrai
    }
    // 3. If Desc has a [[Set]] field, return true.
    si desc.set.poss√®de_valeur() {
        retourne vrai
    }
    // 4. Return false.
    retourne faux
}

/* 6.2.6.2 IsDataDescriptor ( Desc )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-isdatadescriptor */
is_data_descriptor :: fonc (desc: &PropertyDescriptor) -> bool
{
    // √Ä FAIRE 1. If Desc is undefined, return false.

    // 2. If Desc has a [[Value]] field, return true.
    si desc.value.poss√®de_valeur() {
        retourne vrai
    }
    // 3. If Desc has a [[Writable]] field, return true.
    si desc.writable.poss√®de_valeur() {
        retourne vrai
    }
    // 4. Return false.
    retourne faux
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Object
 * \{ */

TypeFonctionObjectCall :: fonc(*Object, &Interpr√©teuse, Valeur, []Valeur)(CompletionRecord)

Object :: struct {
    empl base: Cellule
    type = #type_de_cette_structure
    sur_destruction = sur_destruction_objet
    sur_visite_graphe = sur_visite_graphe_objet

    /* https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-property-attributes */
    Propri√©t√© :: struct {
        nom: ECMAString
        valeur: Valeur
        get: fonc(*Object)(Valeur)
        set: fonc(*Object, Valeur)(rien)
        /* √Ä FAIRE : traite proprement ces valeurs. */
        writable := vrai
        configurable := vrai
        enumerable := vrai
    }

    propri√©t√©s: [..]Propri√©t√©

    prototype: *Object

    /* Table virtuelle. */
    sur_get_prototype_of := ordinary_get_prototype_of
    sur_get_own_property := ordinary_get_own_property
    sur_get := ordinary_get
    sur_call: TypeFonctionObjectCall
}

is_data_propery :: fonc (propri√©t√©: &Object.Propri√©t√©) -> bool
{
    retourne propri√©t√©.get == nul && propri√©t√©.set == nul
}

is_accessor_propery :: fonc (propri√©t√©: &Object.Propri√©t√©) -> bool
{
    retourne !is_data_propery(propri√©t√©)
}

cr√©e_objet :: fonc (tas_de_m√©moire: *TasDeM√©moire, prototype: *ObjectPrototype) -> *Object
{
    r√©sultat := tas_de_m√©moire.alloue(Object)
    r√©sultat.prototype = prototype
    retourne r√©sultat
}

sur_destruction_objet :: fonc (base: *Cellule)
{
    objet := base comme *Object
    d√©loge(objet.propri√©t√©s)
}

d√©finis_valeur :: fonc (objet: *Object, nom: ECMAString, valeur: Valeur)
{
    propri√©t√© := trouve_propri√©t√©(objet, nom)
    si propri√©t√© {
        propri√©t√©.valeur = valeur
        retourne
    }

    tableau_ajoute(*objet.propri√©t√©s, Object.Propri√©t√©(nom, valeur))
}

ajoute_propri√©t√© :: fonc (objet: *Object, nom: ECMAString, valeur: Valeur, writable: bool, enumerable: bool, configurable: bool)
{
    tableau_ajoute(*objet.propri√©t√©s, Object.Propri√©t√©(nom, valeur, writable = writable, enumerable = enumerable, configurable = configurable))
}

get_prototype_of :: fonc (object: *Object) -> *Object
{
    retourne ordinary_get_prototype_of(object)
}

/* 7.3.2 Get
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-get-o-p */
get :: fonc (object: *Object, property_key: ECMAString) -> CompletionRecord
{
    // √Ä FAIRE : type property_key
    // 1. Return ? O.[[Get]](P, O).
    retourne object.sur_get(object, property_key, Valeur(Object = object))
}

get_own_property :: fonc (object: *Object, property_key: ECMAString) -> CompletionRecord
{
    retourne ordinary_get_own_property(object, property_key)
}

/* 7.3.4 Set
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-set-o-p-v-throw */
set :: fonc (object: *Object, property_key: ECMAString, valeur: Valeur, throw: bool) -> CompletionRecord
{
    // √Ä FAIRE : type property_key

    // 1. Let success be ? O.[[Set]](P, V, O).
    // √Ä FAIRE : diff√©rentes m√©thodes pour diff√©rents objets
    d√©finis_valeur(object, property_key, valeur)
    succ√®s := vrai

    // 2. If success is false and Throw is true, throw a TypeError exception.
    si succ√®s == faux && throw == vrai {
        panique("exceptions non-impl√©ment√©es")
    }

    // 3. Return UNUSED.
    retourne normal_completion(js_undefined)
}

trouve_propri√©t√© :: fonc (objet: *Object, nom: ECMAString) -> *Object.Propri√©t√©
{
    pour * objet.propri√©t√©s {
        si it.nom == nom {
            retourne it
        }
    }
    retourne nul
}

sur_visite_graphe_objet :: fonc (base: *Cellule, visiteuse: *VisiteuseCellule)
{
    cellule_sur_visite_graphe(base, visiteuse)

    objet := base comme *Object

    si objet.prototype {
        visite_graphe(objet.prototype, visiteuse)
    }

    pour objet.propri√©t√©s {
        si it.valeur.est_cellule() {
            visite_graphe(it.valeur.donne_cellule(), visiteuse)
        }
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Ordinary Object
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ordinary-object-internal-methods-and-internal-slots
 * \{ */

/* 10.1.1.1 OrdinaryGetPrototypeOf ( O )
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ordinarygetprototypeof */
ordinary_get_prototype_of :: fonc (object: *Object) -> *Object
{
    // Return O.[[Prototype]].
    retourne object.prototype
}

/* 10.1.5.1 OrdinaryGetOwnProperty ( O, P )
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ordinarygetownproperty */
ordinary_get_own_property :: fonc (object: *Object, property_key: ECMAString) -> CompletionRecord
{
    propri√©t√© := object.trouve_propri√©t√©(property_key)

    // 1. If O does not have an own property with key P, return undefined.
    saufsi propri√©t√© {
        retourne normal_completion(js_undefined)
    }

    // 2. Let D be a newly created Property Descriptor with no fields.
    D: PropertyDescriptor

    // 3. Let X be O's own property whose key is P.
    X := m√©moire(propri√©t√©)

    // 4. If X is a data property, then
    si is_data_propery(X) {
        // a. Set D.[[Value]] to the value of X's [[Value]] attribute.
        D.value = propri√©t√©.valeur

        // b. Set D.[[Writable]] to the value of X's [[Writable]] attribute.
        D.writable = propri√©t√©.writable
    }
    // 5. Else,
    sinon {
        // a. Assert: X is an accessor property.
        assert(is_accessor_propery(X))
        panique("accessor property non-impl√©ment√©")

        // b. Set D.[[Get]] to the value of X's [[Get]] attribute.
        // c. Set D.[[Set]] to the value of X's [[Set]] attribute.
    }

    // 6. Set D.[[Enumerable]] to the value of X's [[Enumerable]] attribute.
    D.enumerable = propri√©t√©.enumerable

    // 7. Set D.[[Configurable]] to the value of X's [[Configurable]] attribute.
    D.configurable = propri√©t√©.configurable

    // 8. Return D.
    retourne normal_completion(D)
}

/* 10.1.8.1 OrdinaryGet ( O, P, Receiver )
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver */
ordinary_get :: fonc (object: *Object, property_key: ECMAString, receiver: Valeur) -> CompletionRecord
{
    // 1. Let desc be ? O.[[GetOwnProperty]](P).
    completion_desc := get_own_property(object, property_key)
    saufsi completion_desc.est_normal() {
        retourne completion_desc
    }

    desc := completion_desc.valeur

    // 2. If desc is undefined, then
    si desc.est_undefined() {
        // a. Let parent be ? O.[[GetPrototypeOf]]().
        parent := get_prototype_of(object)

        // b. If parent is null, return undefined.
        si parent == nul {
            retourne normal_completion(desc)
        }

        // c. Return ? parent.[[Get]](P, Receiver).
        retourne parent.sur_get(parent, property_key, receiver)
    }

    // 3. If IsDataDescriptor(desc) is true, return desc.[[Value]].
    si is_data_descriptor(desc.P) {
        retourne normal_completion(desc.P.value.Quelque)
    }

    panique("accessor property non-impl√©ment√©")
    // 4. Assert: IsAccessorDescriptor(desc) is true.
    // 5. Let getter be desc.[[Get]].
    // 6. If getter is undefined, return undefined.
    // 7. Return ? Call(getter, Receiver).
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ObjetChaine
 * https://tc39.es/ecma262/multipage/text-processing.html#sec-string-objects
 * \{ */

ObjetChaine :: struct {
    empl objet: Object
    type = #type_de_cette_structure
    sur_visite_graphe = sur_visite_graphe_chaine

    chn: *PrimitiveChaine
}

cr√©e_chaine :: fonc (tas_de_m√©moire: *TasDeM√©moire, string_prototype: *StringPrototype, chn: *PrimitiveChaine) -> *ObjetChaine
{
    r√©sultat := tas_de_m√©moire.alloue(ObjetChaine)
    r√©sultat.prototype = string_prototype
    r√©sultat.chn = chn

    r√©sultat.ajoute_propri√©t√©("length", Valeur(Number = chn.texte.taille comme r64), faux, faux, faux)
    r√©sultat.ajoute_propri√©t√©("prototype", Valeur(Object = string_prototype), faux, faux, faux)

    retourne r√©sultat
}

sur_visite_graphe_chaine :: fonc (base: *Cellule, visiteuse: *VisiteuseCellule)
{
    objet_chaine := base comme *ObjetChaine
    sur_visite_graphe_objet(objet_chaine, visiteuse)
    cellule_sur_visite_graphe(objet_chaine.chn, visiteuse)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ObjectPrototype
 * \{ */

ObjectPrototype :: struct {
    empl objet: Object
    type = #type_de_cette_structure
}

cr√©e_object_prototype :: fonc (tas_de_m√©moire: *TasDeM√©moire) -> *ObjectPrototype
{
    r√©sultat := tas_de_m√©moire.alloue(ObjectPrototype)
    retourne r√©sultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom StringPrototype
 * https://tc39.es/ecma262/multipage/text-processing.html#sec-properties-of-the-string-prototype-object
 * \{ */

StringPrototype :: struct {
    empl objet: Object
    type = #type_de_cette_structure
    sur_visite_graphe = string_prototype_sur_visite_graphe

    string_data: *PrimitiveChaine
}

cr√©e_string_prototype :: fonc (tas_de_m√©moire: *TasDeM√©moire, prototype: *ObjectPrototype) -> *StringPrototype
{
    r√©sultat := tas_de_m√©moire.alloue(StringPrototype)
    r√©sultat.prototype = prototype
    r√©sultat.string_data = cr√©e_chaine(tas_de_m√©moire, "")
    r√©sultat.ajoute_propri√©t√©("length", Valeur(Number = 0.0), faux, faux, faux)

    retourne r√©sultat
}

string_prototype_sur_visite_graphe :: fonc (base: *Cellule, visiteuse: *VisiteuseCellule)
{
    string_prototype := base comme *StringPrototype
    sur_visite_graphe_objet(string_prototype, visiteuse)
    cellule_sur_visite_graphe(string_prototype.string_data, visiteuse)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Fonction
 * \{ */

Function :: struct {
    empl objet: Object
    type = #type_de_cette_structure

    nom: ECMAString
    corps: *NoeudSyntaxique
}

cr√©e_fonction :: fonc (tas_de_m√©moire: *TasDeM√©moire, nom: ECMAString, corps: *NoeudSyntaxique) -> *Function
{
    r√©sultat := tas_de_m√©moire.alloue(Function)
    r√©sultat.nom = nom
    r√©sultat.corps = corps
    r√©sultat.sur_call = sur_appel_fonction_instruite
    retourne r√©sultat
}

/* 7.3.13 Call ( F, V [ , argumentsList ] )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-call */
call :: fonc (interpr√©teuse: &Interpr√©teuse, valeur: Valeur, this_value: Valeur) -> CompletionRecord
{
    // 1. If argumentsList is not present, set argumentsList to a new empty List.
    arguments: []Valeur
    retourne call(interpr√©teuse, valeur, this_value, arguments)
}

call :: fonc (interpr√©teuse: &Interpr√©teuse, valeur: Valeur, this_value: Valeur, arguments: []Valeur) -> CompletionRecord
{
    // Continuation de la version sans arguments.
    // 2. If IsCallable(F) is false, throw a TypeError exception.
    saufsi is_callable(valeur) {
        message := imprime_chaine("'%' is not callable", valeur)
        retourne lance_type_error(interpr√©teuse, message)
    }

    object := valeur.donne_objet()

    // 3. Return ? F.[[Call]](V, argumentsList).
    retourne object.sur_call(object, interpr√©teuse, this_value, arguments)
}

sur_appel_fonction_instruite :: fonc (object: *Object, interpr√©teuse: &Interpr√©teuse, this_value: Valeur @inutilis√©e, arguments: []Valeur @inutilis√©e) -> CompletionRecord
{
    assert(object.type == Function)
    fonction := object comme *Function
    retourne interpr√©teuse.ex√©cute(fonction.corps, TypeScope.FUNCTION)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom FunctionNative
 * \{ */

FunctionNative :: struct {
    empl function: Function
    type = #type_de_cette_structure
}

cr√©e_fonction_native :: fonc (tas_de_m√©moire: *TasDeM√©moire, nom: ECMAString, sur_appel: TypeFonctionObjectCall) -> *FunctionNative
{
    r√©sultat := tas_de_m√©moire.alloue(FunctionNative)
    r√©sultat.nom = nom
    r√©sultat.sur_call = sur_appel
    retourne r√©sultat
}

ajoute_fonction_native :: fonc (objet: *Object, nom: ECMAString, sur_appel: TypeFonctionObjectCall)
{
    tas_de_m√©moire := objet.donne_tas_de_m√©moire()
    fonction := cr√©e_fonction_native(tas_de_m√©moire, nom, sur_appel)
    ajoute_propri√©t√©(objet, nom, Valeur(Function = fonction), faux, faux, faux)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom PrimitiveChaine
 * \{ */

PrimitiveChaine :: struct {
    empl cellule: Cellule
    type = #type_de_cette_structure
    sur_visite_graphe = string_primitive_sur_visite_graphe
    sur_destruction = sur_destruction_primitive_chaine

    texte: ECMAString
    objet: *Object
}

cr√©e_chaine :: fonc (tas_de_m√©moire: *TasDeM√©moire, texte: ECMAString) -> *PrimitiveChaine
{
    r√©sultat := tas_de_m√©moire.alloue(PrimitiveChaine)
    r√©sultat.texte = copie_chaine(texte)
    retourne r√©sultat
}

string_primitive_sur_visite_graphe :: fonc (base: *Cellule, visiteuse: *VisiteuseCellule)
{
    string_primitive := base comme *PrimitiveChaine
    cellule_sur_visite_graphe(string_primitive, visiteuse)
    si string_primitive.objet {
        sur_visite_graphe_objet(string_primitive.objet, visiteuse)
    }
}

sur_destruction_primitive_chaine :: fonc (base: *Cellule)
{
    primitive := base comme *PrimitiveChaine
    d√©loge(primitive.texte)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Error
 * https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-error-objects
 * \{ */

Error :: struct {
    empl objet: Object
    type = Error
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ErrorPrototype
 * https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-properties-of-the-error-prototype-object
 * \{ */

ErrorPrototype :: struct {
    empl objet: Object
    type = ErrorPrototype
}

cr√©e_error_prototype :: fonc (tas_de_m√©moire: *TasDeM√©moire, prototype: *ObjectPrototype) -> *ErrorPrototype
{
    r√©sultat := tas_de_m√©moire.alloue(ErrorPrototype)
    r√©sultat.prototype = prototype
    retourne r√©sultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ReferenceError
 * https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-native-error-types-used-in-this-standard-referenceerror
 * \{ */

ReferenceError :: struct {
    empl error: Error
    type = ReferenceError
    sur_visite_graphe = reference_error_sur_visite_graphe

    message: *PrimitiveChaine
}

cr√©e_reference_error :: fonc (tas_de_m√©moire: *TasDeM√©moire, prototype: *ReferenceErrorPrototype, message: chaine) -> *ReferenceError
{
    r√©sultat := tas_de_m√©moire.alloue(ReferenceError)
    r√©sultat.prototype = prototype
    r√©sultat.message = cr√©e_chaine(tas_de_m√©moire, message)
    retourne r√©sultat
}

reference_error_sur_visite_graphe :: fonc (base: *Cellule, visiteuse: *VisiteuseCellule)
{
    reference_error := base comme *ReferenceError
    sur_visite_graphe_objet(reference_error, visiteuse)
    cellule_sur_visite_graphe(reference_error.message, visiteuse)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ReferenceErrorPrototype
 * https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-properties-of-the-nativeerror-prototype-objects
 * \{ */

ReferenceErrorPrototype :: struct {
    empl objet: Object
    type = ReferenceErrorPrototype
}

cr√©e_reference_error_prototype :: fonc (tas_de_m√©moire: *TasDeM√©moire, prototype: *ErrorPrototype) -> *ReferenceErrorPrototype
{
    r√©sultat := tas_de_m√©moire.alloue(ReferenceErrorPrototype)
    r√©sultat.prototype = prototype
    retourne r√©sultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom TypeError
 * https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-native-error-types-used-in-this-standard-typeerror
 * \{ */

TypeError :: struct {
    empl error: Error
    type = TypeError
    sur_visite_graphe = type_error_sur_visite_graphe

    message: *PrimitiveChaine
}

cr√©e_type_error :: fonc (tas_de_m√©moire: *TasDeM√©moire, prototype: *TypeErrorPrototype, message: chaine) -> *TypeError
{
    r√©sultat := tas_de_m√©moire.alloue(TypeError)
    r√©sultat.prototype = prototype
    r√©sultat.message = cr√©e_chaine(tas_de_m√©moire, message)
    retourne r√©sultat
}

type_error_sur_visite_graphe :: fonc (base: *Cellule, visiteuse: *VisiteuseCellule)
{
    type_error := base comme *TypeError
    sur_visite_graphe_objet(type_error, visiteuse)
    cellule_sur_visite_graphe(type_error.message, visiteuse)
}

lance_type_error :: fonc (interpr√©teuse: &Interpr√©teuse, message: chaine) -> CompletionRecord
{
    exception := cr√©e_type_error(*interpr√©teuse.tas_de_m√©moire, interpr√©teuse.realm.intrinsics.type_error_prototype, message)
    retourne throw_completion(exception)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom TypeErrorPrototype
 * https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-properties-of-the-nativeerror-prototype-objects
 * \{ */

TypeErrorPrototype :: struct {
    empl objet: Object
    type = TypeErrorPrototype
}

cr√©e_type_error_prototype :: fonc (tas_de_m√©moire: *TasDeM√©moire, prototype: *ErrorPrototype) -> *TypeErrorPrototype
{
    r√©sultat := tas_de_m√©moire.alloue(TypeErrorPrototype)
    r√©sultat.prototype = prototype
    retourne r√©sultat
}

/** \} */
