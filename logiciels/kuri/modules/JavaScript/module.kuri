importe Chaine
importe Fondation

charge "arbre"
charge "enveloppe"
charge "environment"
charge "interpr√©teuse"
charge "lexage"
charge "lex√®mes"
charge "parsage"
charge "realm"
charge "script"
charge "tas_de_m√©moire"
charge "terminologie"

charge "Objets/array"
charge "Objets/error"
charge "Objets/function"
charge "Objets/object"
charge "Objets/string"

ECMAString :: ChaineUTF16Unique

/* ------------------------------------------------------------------------- */
/** \nom Valeur
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof
 * \{ */

NaN : r64 : 0r7ff8000000000000

/* Ceux-l√† ne sont pas dans le standard, ce n'est que pour avoir des types pour l'union. */
UndefinedType :: #opaque z32
NullType :: #opaque z32

BigInt :: struct {
    // √Ä FAIRE : impl√©mente proprement
    valeur: z64
}

big_int_equal :: fonc (x: Valeur @inutilis√©e, y: Valeur @inutilis√©e) -> bool
{
    panique("big_int equal non-impl√©ment√©")
}

/* ------------------------------------------------------------------------- */
/** \nom 6.1.5 The Symbol Type
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-ecmascript-language-types-symbol-type
 * \{ */

Symbol :: struct {
    /* Soit undefined ou une chaine. */
    description: Optionnel(ECMAString)
}

/** \} */

Valeur :: union {
    Undefined: UndefinedType
    Null: NullType
    Boolean: bool
    Number: r64
    BigInt: BigInt
    String: *PrimitiveChaine
    Symbol: *Symbol
    Function: *Function
    Object: *Object
}

imprime_valeur :: fonc (enchaineuse: *Enchaineuse, valeur: *Valeur)
{
    saufsi valeur {
        ajoute_au_tampon(enchaineuse, "nul")
        retourne
    }

    discr m√©moire(valeur) {
        Undefined {
            ajoute_au_tampon(enchaineuse, "undefined")
        }
        Null {
            ajoute_au_tampon(enchaineuse, "null")
        }
        Boolean(b) {
            si b {
                ajoute_au_tampon(enchaineuse, "true")
            }
            sinon {
                ajoute_au_tampon(enchaineuse, "false")
            }
        }
        Number(n) {
            ajoute_au_tampon(enchaineuse, n)
        }
        Object(o) {
            si o.donne_classe() == ReferenceError {
                error := o comme *ReferenceError
                ajoute_au_tampon(enchaineuse, error.donne_nom_classe(), ": ", error.message.texte)
            }
            sinon si o.donne_classe() == TypeError {
                error := o comme *TypeError
                ajoute_au_tampon(enchaineuse, error.donne_nom_classe(), ": ", error.message.texte)
            }
            sinon {
                ajoute_au_tampon(enchaineuse, "[object ", o.donne_nom_classe(), "]")
            }
        }
        Function(o) {
            ajoute_au_tampon(enchaineuse, "[object ", o.donne_nom_classe(), "]")
        }
        String(s) {
            ajoute_au_tampon(enchaineuse, "\"", s.texte, "\"")
        }
        sinon {
            ajoute_au_tampon(enchaineuse, "Valeur inconnue.")
        }
    }
} @FormattageImpression

/* √Ä FAIRE(language) : index_de(valeur) == Number  */
est_fonction :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Function {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_object :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Object {
            retourne vrai
        }
        sinon {
            retourne est_fonction(valeur)
        }
    }
}

donne_objet :: fonc (valeur: Valeur) -> *Object
{
    discr valeur {
        Object(objet) {
            retourne objet
        }
        Function(function) {
            retourne function
        }
        sinon {
            retourne nul
        }
    }
}

est_cellule :: fonc (valeur: Valeur) -> bool
{
    retourne valeur.est_object() || valeur.est_chaine()
}

donne_cellule :: fonc (valeur: Valeur) -> *Cellule
{
    discr valeur {
        Object(o) {
            retourne o
        }
        Function(f) {
            retourne f
        }
        String(s) {
            retourne s
        }
        sinon {
            retourne nul
        }
    }
}

est_nombre :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Number {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_chaine :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        String {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_nulle :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Null {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_undefined :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Undefined {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_boolean :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Boolean {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_true :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Boolean {
            retourne valeur.Boolean
        }
        sinon {
            retourne faux
        }
    }
}

est_false :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Boolean {
            retourne !valeur.Boolean
        }
        sinon {
            retourne faux
        }
    }
}

est_big_int :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        BigInt {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_symbol :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Symbol {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

concat√®ne :: fonc (str_gauche: *PrimitiveChaine, str_droite: *PrimitiveChaine) -> Valeur
{
    chn1 := str_gauche.texte.donne_chaine_utf16()
    chn2 := str_droite.texte.donne_chaine_utf16()

    enchaineuse: EnchaineuseUTF16
    initialise_enchaineuse(enchaineuse)
    diff√®re d√©truit_tampons(enchaineuse)

    ajoute(enchaineuse, chn1)
    ajoute(enchaineuse, chn2)

    chn := chaine_depuis_enchaineuse(enchaineuse)
    chn_r√©sultat := cr√©e_chaine_utf16_unique(chn)

    retourne Valeur(String = cr√©e_chaine(str_gauche.donne_tas_de_m√©moire(), chn_r√©sultat))
}

js_null := Valeur(Null = NullType(0))
js_undefined := Valeur(Undefined = UndefinedType(0))

TypePr√©f√©r√© :: √©num {
    Aucun
    Number
    String
}

/* 7.1.18 ToObject ( argument )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-toobject */
vers_objet :: fonc (realm: *Realm, valeur: Valeur) -> CompletionRecord
{
    si valeur.est_undefined() {
        retourne lance_type_error(realm, "undefined is not an Object")
    }

    si valeur.est_nulle() {
        retourne lance_type_error(realm, "null is not an Object")
    }

    si valeur.est_object() {
        retourne normal_completion(Valeur(Object = valeur.donne_objet()))
    }

    si valeur.est_chaine() {
        chn := valeur.String
        saufsi chn.objet {
            chn.objet = cr√©e_chaine(realm.donne_tas_de_m√©moire(), realm.intrinsics.string_prototype, valeur.String)
        }
        retourne normal_completion(Valeur(Object = chn.objet))
    }

    panique("vers_objet non-impl√©ment√© pour type")
}

/* 7.1.19 ToPropertyKey ( argument )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-topropertykey */
to_property_key :: fonc (interpr√©teuse: *Interpr√©teuse, argument: Valeur) -> CompletionRecord
{
    retourne to_property_key(interpr√©teuse.donne_realm(), argument)
}

to_property_key :: fonc (realm: *Realm, argument: Valeur) -> CompletionRecord
{
    // 1. Let key be ? ToPrimitive(argument, STRING).
    completion := vers_primitive(realm, argument, TypePr√©f√©r√©.String)
    saufsi completion.est_normal() {
        retourne completion
    }
    key := completion.valeur.V

    // 2. If key is a Symbol, then
    si key.est_symbol() {
        // a. Return key.
        retourne normal_completion(key)
    }

    // 3. Return ! ToString(key).
    retourne vers_chaine(realm, key)
}

/* 7.1.20 ToLength ( argument )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-tolength */
to_length :: fonc (argument: Valeur) -> CompletionRecord
{
    assert(argument.est_nombre())
    /* √Ä FAIRE : ToIntegerOrInfinity. */
    // 1. Let len be ? ToIntegerOrInfinity(argument).
    len := argument.Number

    // 2. If len ‚â§ 0, return +0ùîΩ.
    si len <= 0.0 {
        retourne normal_completion(Valeur(Number = 0.0))
    }

    // 3. Return ùîΩ(min(len, 2**53 - 1)).
    retourne normal_completion(argument)
}

/* 7.1.1 ToPrimitive ( input [ , preferredType ] )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-toprimitive */
vers_primitive :: fonc (interpr√©teuse: *Interpr√©teuse, valeur: Valeur, type_pr√©f√©r√© := TypePr√©f√©r√©.Aucun) -> CompletionRecord
{
    retourne vers_primitive(interpr√©teuse.donne_realm(), valeur, type_pr√©f√©r√©)
}

vers_primitive :: fonc (realm: *Realm, valeur: Valeur, type_pr√©f√©r√© := TypePr√©f√©r√©.Aucun) -> CompletionRecord
{
    // 1. If input is an Object, then
    si valeur.est_object() {
        // √Ä FAIRE : a. Let exoticToPrim be ? GetMethod(input, %Symbol.toPrimitive%).
        // b. If exoticToPrim is not undefined, then
            // i. If preferredType is not present, then
                // 1. Let hint be "default".
            // ii. Else if preferredType is STRING, then
                // 1. Let hint be "string".
            // iii. Else,
                // 1. Assert: preferredType is NUMBER.
                // 2. Let hint be "number".
            // iv. Let result be ? Call(exoticToPrim, input, ¬´ hint ¬ª).
            // v. If result is not an Object, return result.
            // vi. Throw a TypeError exception.

        // c. If preferredType is not present, let preferredType be NUMBER.
        si type_pr√©f√©r√© == TypePr√©f√©r√©.Aucun {
            type_pr√©f√©r√© = TypePr√©f√©r√©.Number
        }

        // d. Return ? OrdinaryToPrimitive(input, preferredType).
        retourne ordinary_to_primitive(realm, valeur.donne_objet(), type_pr√©f√©r√©)
    }

    // 2. Return input.
    retourne normal_completion(valeur)
}

/* 7.1.1.1 OrdinaryToPrimitive ( O, hint )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-ordinarytoprimitive */
ordinary_to_primitive :: fonc (realm: *Realm, object: *Object, hint: TypePr√©f√©r√©) -> CompletionRecord
{
    method_names: [2]ECMAString

    // 1. If hint is string, then
    si hint == TypePr√©f√©r√©.String {
        // a. Let methodNames be ¬´ "toString", "valueOf" ¬ª.
        method_names = [STR_toString, STR_valueOf]
    }
    // 2. Else,
    sinon {
        // a. Let methodNames be ¬´ "valueOf", "toString" ¬ª.
        method_names = [STR_valueOf, STR_toString]
    }

    // 3. For each element name of methodNames, do
    pour method_names {
        // a. Let method be ? Get(O, name).
        completion := get(object, it)
        saufsi completion.est_normal() {
            retourne completion
        }
        method := completion.valeur.V

        // b. If IsCallable(method) is true, then
        si is_callable(method) {
            // i. Let result be ? Call(method, O).
            interpr√©teuse: Interpr√©teuse
            diff√®re d√©truit_donn√©es_interpreteuse(*interpr√©teuse)
            interpr√©teuse.mv = realm.donne_tas_de_m√©moire().donne_mv()
            completion = call(*interpr√©teuse, method, object)
            saufsi completion.est_normal() {
                retourne completion
            }
            result := completion.valeur.V

            // ii. If result is not an Object, return result.
            saufsi result.est_object() {
                retourne normal_completion(result)
            }
        }
    }

    // 4. Throw a TypeError exception.
    retourne lance_type_error(realm, "object cannot be made into a primitive")
}

/* 7.1.2 ToBoolean ( argument )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-toboolean */
to_boolean :: fonc (valeur: Valeur) -> Valeur
{
    // 1. If argument is a Boolean, return argument.
    si valeur.est_boolean() {
        retourne valeur
    }

    // 2. If argument is one of undefined, null, +0ùîΩ, -0ùîΩ, NaN, 0‚Ñ§, or the empty String, return false.
    discr valeur {
        Null {
            retourne Valeur(Boolean = faux)
        }
        Undefined {
            retourne Valeur(Boolean = faux)
        }
        Number(n) {
            si n == 0.0 || n == -0.0 {
                retourne Valeur(Boolean = faux)
            }

            // √Ä FAIRE : NaN, 0‚Ñ§
        }
        String(s) {
            si s.texte == cr√©e_chaine_utf16_unique("") {
                retourne Valeur(Boolean = faux)
            }
        }
        sinon {}
    }

    // √Ä FAIRE : 3. If argument is an Object and argument has an [[IsHTMLDDA]] internal slot, return false.

    // 4. Return true.
    retourne Valeur(Boolean = vrai)
}

/* 7.1.3 ToNumeric ( value )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-tonumeric */
to_numeric :: fonc (interpr√©teuse: *Interpr√©teuse, valeur: Valeur) -> CompletionRecord
{
    // 1. Let primValue be ? ToPrimitive(value, NUMBER).
    compl√©tion_valeur_primitive := vers_primitive(interpr√©teuse, valeur, TypePr√©f√©r√©.Number)
    saufsi compl√©tion_valeur_primitive.est_normal() {
        retourne compl√©tion_valeur_primitive
    }
    valeur_primitive := compl√©tion_valeur_primitive.valeur.V

    // 2. If primValue is a BigInt, return primValue.
    si valeur_primitive.est_big_int() {
        retourne normal_completion(valeur_primitive)
    }

    // 3. Return ? ToNumber(primValue).
    retourne vers_nombre(interpr√©teuse, valeur_primitive)
}

/* https://tc39.es/ecma262/multipage/abstract-operations.html#sec-tonumber */
vers_nombre :: fonc (interpr√©teuse: *Interpr√©teuse, valeur: Valeur) -> CompletionRecord
{
    // 1. If argument is a Number, return argument.
    si valeur.est_nombre() {
        retourne normal_completion(valeur)
    }

    // 2. If argument is either a Symbol or a BigInt, throw a TypeError exception.
    si valeur.est_symbol() {
        retourne lance_type_error(interpr√©teuse, "can't convert Symbol to number")
    }
    si valeur.est_big_int() {
        retourne lance_type_error(interpr√©teuse, "can't convert BigInt to number")
    }

    // 3. If argument is undefined, return NaN.
    si valeur.est_undefined() {
        retourne normal_completion(Valeur(Number = NaN))
    }

    // 4. If argument is either null or false, return +0ùîΩ.
    si valeur.est_nulle() || valeur.est_false() {
        retourne normal_completion(Valeur(Number = 0.0))
    }

    // 5. If argument is true, return 1ùîΩ.
    si valeur.est_true() {
        retourne normal_completion(Valeur(Number = 1.0))
    }

    // 6. If argument is a String, return StringToNumber(argument).
    si valeur.est_chaine() {
        retourne normal_completion(string_to_number(valeur))
    }

    // 7. Assert: argument is an Object.
    assert(valeur.est_object())

    // 8. Let primValue be ? ToPrimitive(argument, NUMBER).
    completion_primitive := vers_primitive(interpr√©teuse, valeur, TypePr√©f√©r√©.Number)
    saufsi completion_primitive.est_normal() {
        retourne completion_primitive
    }
    prim_value := completion_primitive.valeur.V

    // 9. Assert: primValue is not an Object.
    assert(prim_value.est_object() == faux)

    // 10. Return ? ToNumber(primValue).
    retourne vers_nombre(interpr√©teuse, prim_value)
}

/* 7.1.4.1.1 StringToNumber ( str )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-stringtonumber */
string_to_number :: fonc (valeur: Valeur) -> Valeur
{
    str := valeur.String.texte

    // √Ä FAIRE : standardise
    // 1. Let literal be ParseText(str, StringNumericLiteral).
    // 2. If literal is a List of errors, return NaN.
    // 3. Return the StringNumericValue of literal.

    source: TexteSource
    source.texte = converti_vers_chaine(str.donne_chaine_utf16())
    diff√®re d√©loge(source.texte)

    lex√®mes: [..]Lex√®me
    diff√®re d√©loge(lex√®mes)

    r√©sultat_lexage := l√®xe(source)
    discr r√©sultat_lexage {
        Ok(l) {
            lex√®mes = l
        }
        sinon {
            retourne Valeur(Number = NaN)
        }
    }

    si lex√®mes.taille != 1 {
        retourne Valeur(Number = NaN)
    }

    /* √Ä FAIRE : prend en compte les signes +/-. */
    si lex√®mes[0].genre != GenreLex√®me.NombreLitt√©ral {
        retourne Valeur(Number = NaN)
    }

    retourne Valeur(Number = parse_nombre_depuis_lex√®me(*lex√®mes[0]))
}

/* 7.1.17 ToString ( argument )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-tostring */
vers_chaine :: fonc (interpr√©teuse: *Interpr√©teuse, argument: Valeur) -> CompletionRecord
{
    retourne vers_chaine(interpr√©teuse.donne_realm(), argument)
}

vers_chaine :: fonc (realm: *Realm, argument: Valeur) -> CompletionRecord
{
    // 1. If argument is a String, return argument.
    si argument.est_chaine() {
        retourne normal_completion(argument)
    }

    // 2. If argument is a Symbol, throw a TypeError exception.
    si argument.est_symbol() {
        retourne lance_type_error(realm, "can't convert Symbol to string")
    }

    // 3. If argument is undefined, return "undefined".
    si argument.est_undefined() {
        retourne normal_completion(cr√©e_chaine(realm.donne_tas_de_m√©moire(), STR_undefined))
    }

    // 4. If argument is null, return "null".
    si argument.est_nulle() {
        retourne normal_completion(cr√©e_chaine(realm.donne_tas_de_m√©moire(), STR_null))
    }

    // 5. If argument is true, return "true".
    si argument.est_true() {
        retourne normal_completion(cr√©e_chaine(realm.donne_tas_de_m√©moire(), STR_true))
    }

    // 6. If argument is false, return "false".
    si argument.est_false() {
        retourne normal_completion(cr√©e_chaine(realm.donne_tas_de_m√©moire(), STR_false))
    }

    // 7. If argument is a Number, return Number::toString(argument, 10).
    si argument.est_nombre() {
        // √Ä FAIRE : impl√©mente selon le standard.
        n := argument.Number
        chn := imprime_chaine("%", n)
        diff√®re d√©loge(chn)

        r√©sultat := cr√©e_chaine_utf16_unique(chn)
        retourne normal_completion(cr√©e_chaine(realm.donne_tas_de_m√©moire(), r√©sultat))
    }

    // 8. If argument is a BigInt, return BigInt::toString(argument, 10).
    si argument.est_big_int() {
        panique("vers_chaine sur big_int non-impl√©ment√©")
    }

    // 9. Assert: argument is an Object.
    assert(argument.est_object())

    // 10. Let primValue be ? ToPrimitive(argument, STRING).
    completion_prim_value := vers_primitive(realm, argument, TypePr√©f√©r√©.String)
    saufsi completion_prim_value.est_normal() {
        retourne completion_prim_value
    }
    prim_value := completion_prim_value.valeur.V

    // 11. Assert: primValue is not an Object.
    assert(!prim_value.est_object())

    // 12. Return ? ToString(primValue).
    retourne vers_chaine(realm, prim_value)
}

/* 7.2.3 IsCallable ( argument )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-iscallable */
is_callable :: fonc (argument: Valeur) -> bool
{
    // 1. If argument is not an Object, return false.
    saufsi argument.est_object() {
        retourne faux
    }

    // 2. If argument has a [[Call]] internal method, return true.
    object := argument.donne_objet()
    si object.donne_table().sur_call {
        retourne vrai
    }

    // 3. Return false.
    retourne faux
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom PropertyDescriptor
 * 6.2.6 The Property Descriptor Specification Type
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-property-descriptor-specification-type
 * \{ */

PropertyDescriptor :: struct {
    value: Optionnel(Valeur)
    get: Optionnel(*Object) // ou undefined
    set: Optionnel(*Object) // ou undefined
    writable: Optionnel(bool)
    configurable: Optionnel(bool)
    enumerable: Optionnel(bool)
}

/* 6.2.6.1 IsAccessorDescriptor ( Desc )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-isaccessordescriptor */
is_accessor_descriptor :: fonc (desc: &PropertyDescriptor) -> bool
{
    // √Ä FAIRE 1. If Desc is undefined, return false.

    // 2. If Desc has a [[Get]] field, return true.
    si desc.get.poss√®de_valeur() {
        retourne vrai
    }
    // 3. If Desc has a [[Set]] field, return true.
    si desc.set.poss√®de_valeur() {
        retourne vrai
    }
    // 4. Return false.
    retourne faux
}

/* 6.2.6.2 IsDataDescriptor ( Desc )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-isdatadescriptor */
is_data_descriptor :: fonc (desc: &PropertyDescriptor) -> bool
{
    // √Ä FAIRE 1. If Desc is undefined, return false.

    // 2. If Desc has a [[Value]] field, return true.
    si desc.value.poss√®de_valeur() {
        retourne vrai
    }
    // 3. If Desc has a [[Writable]] field, return true.
    si desc.writable.poss√®de_valeur() {
        retourne vrai
    }
    // 4. Return false.
    retourne faux
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom PropertyKey
 * \{ */

PropertyKey :: union {
    String: ECMAString
    Symbol: *Symbol
}

est_symbol :: fonc (key: PropertyKey) -> bool
{
    discr key {
        Symbol {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

op√©rateur == :: fonc (p1: PropertyKey, p2: PropertyKey) -> bool
{
    discr p1 {
        String(s1) {
            discr p2 {
                String(s2) {
                    retourne s1 == s2
                }
                sinon {
                    retourne faux
                }
            }
        }
        Symbol(s1) {
            discr p2 {
                Symbol(s2) {
                    retourne s1 == s2
                }
                sinon {
                    retourne faux
                }
            }
        }
        sinon {
            retourne faux
        }
    }
}

op√©rateur != :: fonc (p1: PropertyKey, p2: PropertyKey) -> bool
{
    retourne !(p1 == p2)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 7.3 Operations on Objects
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-operations-on-objects
 * \{ */

/* 7.3.2 Get
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-get-o-p */
get :: fonc (object: *Object, property_key: PropertyKey) -> CompletionRecord
{
    // 1. Return ? O.[[Get]](P, O).
    retourne object.internal_get(property_key, Valeur(Object = object))
}

/* 7.3.4 Set
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-set-o-p-v-throw */
set :: fonc (object: *Object, property_key: PropertyKey, valeur: Valeur, throw: bool) -> CompletionRecord
{
    // 1. Let success be ? O.[[Set]](P, V, O).
    completion := object.internal_set(property_key, valeur, Valeur(Object = object))
    saufsi completion.est_normal() {
        retourne completion
    }
    succ√®s := completion.valeur.V
    // 2. If success is false and Throw is true, throw a TypeError exception.
    si succ√®s.est_false() && throw == vrai {
        panique("exceptions non-impl√©ment√©es")
    }

    // 3. Return UNUSED.
    retourne normal_completion(js_undefined)
}

/* 7.3.5 CreateDataProperty ( O, P, V )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-createdataproperty */
create_data_property :: fonc (object: *Object, property_key: PropertyKey, valeur: Valeur) -> CompletionRecord
{
    // 1. Let newDesc be the PropertyDescriptor { [[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true }.
    new_desc: PropertyDescriptor
    new_desc.value = valeur
    new_desc.writable = vrai
    new_desc.enumerable = vrai
    new_desc.configurable = vrai

    // 2. Return ? O.[[DefineOwnProperty]](P, newDesc).
    retourne internal_define_own_property(object, property_key, new_desc)
}

/* 7.3.6 CreateDataPropertyOrThrow ( O, P, V )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-createdatapropertyorthrow */
create_data_property_or_throw :: fonc (object: *Object, property_key: PropertyKey, valeur: Valeur) -> CompletionRecord
{
    // 1. Let success be ? CreateDataProperty(O, P, V).
    completion := create_data_property(object, property_key, valeur)
    saufsi completion.est_normal() {
        retourne completion
    }
    success := completion.valeur.V

    // 2. If success is false, throw a TypeError exception.
    si success.est_false() {
        panique("Exception non-impl√©ment√©e")
    }

    // 3. Return UNUSED.
    retourne normal_completion(js_undefined)
}

/* 7.3.8 DefinePropertyOrThrow ( O, P, desc )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-definepropertyorthrow */
define_property_or_throw :: fonc (object: *Object, property_key: PropertyKey, desc: &PropertyDescriptor) -> CompletionRecord
{
    // 1. Let success be ? O.[[DefineOwnProperty]](P, desc).
    completion := internal_define_own_property(object, property_key, desc)
    saufsi completion.est_normal() {
        retourne completion
    }
    success := completion.valeur.V

    // 2. If success is false, throw a TypeError exception.
    si success.est_false() {
        panique("Exception non-impl√©ment√©e")
    }

    // 3. Return UNUSED.
    retourne normal_completion(js_undefined)
}

/* 7.3.11 HasProperty ( O, P ) 
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-hasproperty */
has_property :: fonc (object: *Object, property_key: PropertyKey) -> CompletionRecord
{
    // 1. Return ? O.[[HasProperty]](P).
    retourne internal_has_property(object, property_key)
}

/* 7.3.12 HasOwnProperty ( O, P )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-hasownproperty */
has_own_property :: fonc (object: *Object, nom: PropertyKey) -> CompletionRecord
{
    completion_desc := internal_get_own_property(object, nom)
    saufsi completion_desc.est_normal() {
        retourne completion_desc
    }

    desc := completion_desc.valeur
    si desc.est_undefined() {
        retourne normal_completion(Valeur(Boolean = faux))
    }

    retourne normal_completion(Valeur(Boolean = vrai))
}

/* 7.3.13 Call ( F, V [ , argumentsList ] )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-call */
call :: fonc (interpr√©teuse: *Interpr√©teuse, valeur: Valeur, this_value: Valeur) -> CompletionRecord
{
    // 1. If argumentsList is not present, set argumentsList to a new empty List.
    arguments: []Valeur
    retourne call(interpr√©teuse, valeur, this_value, arguments)
}

call :: fonc (interpr√©teuse: *Interpr√©teuse, valeur: Valeur, this_value: Valeur, arguments: []Valeur) -> CompletionRecord
{
    // Continuation de la version sans arguments.
    // 2. If IsCallable(F) is false, throw a TypeError exception.
    saufsi is_callable(valeur) {
        message := imprime_chaine("'%' is not callable", valeur)
        retourne lance_type_error(interpr√©teuse, message)
    }

    object := valeur.donne_objet()

    // 3. Return ? F.[[Call]](V, argumentsList).
    retourne object.internal_call(interpr√©teuse, this_value, arguments)
}

/*7.3.18 LengthOfArrayLike ( obj )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-lengthofarraylike */
length_of_array_like :: fonc (obj: *Object) -> CompletionRecord
{
    // 1. Return ‚Ñù(? ToLength(? Get(obj, "length"))).
    completion := get(obj, STR_length)
    saufsi completion.est_normal() {
        retourne completion
    }
    completion = to_length(completion.valeur.V)
    saufsi completion.est_normal() {
        retourne completion
    }
    retourne normal_completion(completion.valeur.V)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 10.1 Ordinary Object Internal Methods and Internal Slots
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ordinary-object-internal-methods-and-internal-slots
 * \{ */

/* 10.1.1.1 OrdinaryGetPrototypeOf ( O )
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ordinarygetprototypeof */
ordinary_get_prototype_of :: fonc (object: *Object) -> *Object
{
    // Return O.[[Prototype]].
    retourne object.prototype
}

/* 10.1.5.1 OrdinaryGetOwnProperty ( O, P )
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ordinarygetownproperty */
ordinary_get_own_property :: fonc (object: *Object, property_key: PropertyKey) -> CompletionRecord
{
    propri√©t√© := object.trouve_propri√©t√©(property_key)

    // 1. If O does not have an own property with key P, return undefined.
    saufsi propri√©t√© {
        retourne normal_completion(js_undefined)
    }

    // 2. Let D be a newly created Property Descriptor with no fields.
    D: PropertyDescriptor

    // 3. Let X be O's own property whose key is P.
    X := m√©moire(propri√©t√©)

    // 4. If X is a data property, then
    si is_data_propery(X) {
        // a. Set D.[[Value]] to the value of X's [[Value]] attribute.
        D.value = propri√©t√©.valeur

        // b. Set D.[[Writable]] to the value of X's [[Writable]] attribute.
        D.writable = propri√©t√©.drapeaux.WRITABLE == vrai
    }
    // 5. Else,
    sinon {
        // a. Assert: X is an accessor property.
        assert(is_accessor_propery(X))

        // b. Set D.[[Get]] to the value of X's [[Get]] attribute.
        si propri√©t√©.get {
            D.get = propri√©t√©.get
        }

        // c. Set D.[[Set]] to the value of X's [[Set]] attribute.
        si propri√©t√©.set {
            D.set = propri√©t√©.set
        }
    }

    // 6. Set D.[[Enumerable]] to the value of X's [[Enumerable]] attribute.
    D.enumerable = propri√©t√©.drapeaux.ENUMERABLE == vrai

    // 7. Set D.[[Configurable]] to the value of X's [[Configurable]] attribute.
    D.configurable = propri√©t√©.drapeaux.CONFIGURABLE == vrai

    // 8. Return D.
    retourne normal_completion(D)
}

/* 10.1.6 [[DefineOwnProperty]] ( P, Desc )
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ordinarydefineownproperty */
ordinary_define_own_property :: fonc (object: *Object, property_key: PropertyKey, desc: &PropertyDescriptor) -> CompletionRecord
{
    // √Ä FAIRE : standardise
    saufsi desc.value.poss√®de_valeur() {
        retourne normal_completion(Valeur(Boolean = faux))
    }

    valeur := desc.value.Quelque
    drapeaux: DrapeauxPropri√©t√©
    si desc.writable.poss√®de_valeur() {
        writable := desc.writable.Quelque
        si writable {
            drapeaux.WRITABLE = vrai
        }
    }
    si desc.configurable.poss√®de_valeur() {
        configurable := desc.configurable.Quelque
        si configurable {
            drapeaux.CONFIGURABLE = vrai
        }
    }
    si desc.enumerable.poss√®de_valeur() {
        enumerable := desc.enumerable.Quelque
        si enumerable {
            drapeaux.ENUMERABLE = vrai
        }
    }

    object.ajoute_propri√©t√©(property_key, valeur, drapeaux)
    retourne normal_completion(Valeur(Boolean = vrai))
}

/* 10.1.8.1 OrdinaryGet ( O, P, Receiver )
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver */
ordinary_get :: fonc (object: *Object, property_key: PropertyKey, receiver: Valeur) -> CompletionRecord
{
    // 1. Let desc be ? O.[[GetOwnProperty]](P).
    completion_desc := internal_get_own_property(object, property_key)
    saufsi completion_desc.est_normal() {
        retourne completion_desc
    }

    desc := completion_desc.valeur

    // 2. If desc is undefined, then
    si desc.est_undefined() {
        // a. Let parent be ? O.[[GetPrototypeOf]]().
        parent := internal_get_prototype_of(object)

        // b. If parent is null, return undefined.
        si parent == nul {
            retourne normal_completion(desc)
        }

        // c. Return ? parent.[[Get]](P, Receiver).
        retourne parent.internal_get(property_key, receiver)
    }

    // 3. If IsDataDescriptor(desc) is true, return desc.[[Value]].
    si is_data_descriptor(desc.P) {
        retourne normal_completion(desc.P.value.Quelque)
    }

    // 4. Assert: IsAccessorDescriptor(desc) is true.
    assert(is_accessor_descriptor(desc.P))

    // 5. Let getter be desc.[[Get]].
    getter := desc.P.get

    // 6. If getter is undefined, return undefined.
    saufsi getter.poss√®de_valeur() {
        retourne normal_completion(js_undefined)
    }

    // 7. Return ? Call(getter, Receiver).
    // √Ä FAIRE : passe une interpr√©teuse
    retourne call(nul, getter.Quelque, receiver)
}

/** \} */

/* 10.2.3 OrdinaryFunctionCreate ( functionPrototype, sourceText, ParameterList, Body, thisMode, env, privateEnv )
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ordinaryfunctioncreate 
 * √Ä FAIRE : param√®tres et √©tapes manquants */
ordinary_function_create :: fonc (realm: *Realm, function_prototype: *FunctionPrototype, params: [..]*NoeudSyntaxique, corps: *NoeudSyntaxique, this_mode: bool, env: *Environment, private_env: *PrivateEnvironment) -> *Function
{
    tas_de_m√©moire := function_prototype.donne_tas_de_m√©moire()

    // 1. Let internalSlotsList be the internal slots listed in Table 30.
    // 2. Let F be OrdinaryObjectCreate(functionPrototype, internalSlotsList).
    F := tas_de_m√©moire.alloue(Function)
    F.prototype = function_prototype

    // 3. Set F.[[Call]] to the definition specified in 10.2.1.
    // Ceci est fait via la table virtuelle.

    // 4. Set F.[[SourceText]] to sourceText.

    // 5. Set F.[[FormalParameters]] to ParameterList.
    F.formal_parameters = params

    // 6. Set F.[[ECMAScriptCode]] to Body.
    F.corps = corps

    // 7. Let Strict be IsStrict(Body).
    strict := is_strict(corps)

    // 8. Set F.[[Strict]] to Strict.
    F.strict = strict

    // 9. If thisMode is LEXICAL-THIS, set F.[[ThisMode]] to LEXICAL.
    si this_mode == LEXICAL_THIS {
        F.this_mode = ThisMode.LEXICAL
    }
    // 10. Else if Strict is true, set F.[[ThisMode]] to STRICT.
    sinon si strict {
        F.this_mode = ThisMode.STRICT
    }
    // 11. Else, set F.[[ThisMode]] to GLOBAL.
    sinon {
        F.this_mode = ThisMode.GLOBAL
    }

    // 12. Set F.[[IsClassConstructor]] to false.
    F.is_class_constructor = faux

    // 13. Set F.[[Environment]] to env.
    F.environment = env

    // 14. Set F.[[PrivateEnvironment]] to privateEnv.
    F.private_environment = private_env

    // 15. Set F.[[ScriptOrModule]] to GetActiveScriptOrModule().
    F.script_or_module = get_active_script_or_module(realm.donne_mv())

    // 16. Set F.[[Realm]] to the current Realm Record.
    F.realm = realm

    // 17. Set F.[[HomeObject]] to undefined.
    // 18. Set F.[[Fields]] to a new empty List.
    // 19. Set F.[[PrivateMethods]] to a new empty List.
    // 20. Set F.[[ClassFieldInitializerName]] to EMPTY.
    // 21. Let len be the ExpectedArgumentCount of ParameterList.

    // 22. Perform SetFunctionLength(F, len).
    set_function_length(F, params.taille comme n64)

    // 23. Return F.
    retourne F
}

/* 10.2.1 [[Call]] ( thisArgument, argumentsList )
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ecmascript-function-objects-call-thisargument-argumentslist */
sur_appel_fonction_instruite :: fonc (empl params: *Param√®tresObjectCall) -> CompletionRecord
{
    assert(object.donne_classe() == Function)
    F := object comme *Function

    mv := interpr√©teuse.mv

    // 1. Let callerContext be the running execution context.
    caller_context := interpr√©teuse.donne_running_execution_context()

    // 2. Let calleeContext be PrepareForOrdinaryCall(F, undefined).
    callee_context := prepare_for_ordinary_call(interpr√©teuse, F, js_undefined)

    // 3. Assert: calleeContext is now the running execution context.
    assert(callee_context == interpr√©teuse.donne_running_execution_context())

    // 4. If F.[[IsClassConstructor]] is true, then
    si F.is_class_constructor {
        // a. Let error be a newly created TypeError object.
        // b. NOTE: error is created in calleeContext with F's associated Realm Record.
        // c. Remove calleeContext from the execution context stack and restore callerContext as the running execution context.
        mv.d√©pile_execution_context()
        assert(caller_context == mv.donne_running_execution_context())

        // d. Return ThrowCompletion(error).
        panique("[[Call]] sur class constructor non-impl√©ment√©")
    }

    // 5. Perform OrdinaryCallBindThis(F, calleeContext, thisArgument).
    ordinary_call_bind_this(F, callee_context, this_value)

    // 6. Let result be Completion(OrdinaryCallEvaluateBody(F, argumentsList)).
    result := ordinary_call_evaluate_body(interpr√©teuse, F, arguments)

    // 7. Remove calleeContext from the execution context stack and restore callerContext as the running execution context.
    mv.d√©pile_execution_context()
    assert(caller_context == mv.donne_running_execution_context())

    // 8. If result is a return completion, return result.[[Value]].
    si result.est_return() {
        retourne normal_completion(result.valeur)
    }

    // 9. ReturnIfAbrupt(result).
    si result.est_abrupt() {
        retourne result
    }

    // 10. Return undefined.
    retourne normal_completion(js_undefined)
}

/* 10.2.1.1 PrepareForOrdinaryCall ( F, newTarget )
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-prepareforordinarycall */
prepare_for_ordinary_call :: fonc (interpr√©teuse: *Interpr√©teuse, F: *Function, new_target: Valeur) -> *ExecutionContext
{
    // 1. Let callerContext be the running execution context.
    caller_context := interpr√©teuse.donne_running_execution_context()

    // 2. Let calleeContext be a new ECMAScript code execution context.
    callee_context := cr√©e_execution_context(interpr√©teuse.donne_tas_de_m√©moire())

    // 3. Set the Function of calleeContext to F.
    callee_context.function = F

    // 4. Let calleeRealm be F.[[Realm]].
    callee_realm := F.realm

    // 5. Set the Realm of calleeContext to calleeRealm.
    callee_context.realm = callee_realm

    // 6. Set the ScriptOrModule of calleeContext to F.[[ScriptOrModule]].
    callee_context.script_or_module = F.script_or_module

    // 7. Let localEnv be NewFunctionEnvironment(F, newTarget).
    local_env := new_function_environment(F, new_target)

    // 8. Set the LexicalEnvironment of calleeContext to localEnv.
    callee_context.lexical_environment = local_env

    // 9. Set the VariableEnvironment of calleeContext to localEnv.
    callee_context.variable_environment = local_env

    // 10. Set the PrivateEnvironment of calleeContext to F.[[PrivateEnvironment]].
    callee_context.private_environment = F.private_environment

    // 11. If callerContext is not already suspended, suspend callerContext.
    caller_context.suspend()

    // 12. Push calleeContext onto the execution context stack; calleeContext is now the running execution context.
    mv := interpr√©teuse.mv
    mv.empile_execution_context(callee_context)

    // 13. NOTE: Any exception objects produced after this point are associated with calleeRealm.

    // 14. Return calleeContext.
    retourne callee_context
}

/* 10.2.1.2 OrdinaryCallBindThis ( F, calleeContext, thisArgument )
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ordinarycallbindthis */
ordinary_call_bind_this :: fonc (F: *Function, callee_context: *ExecutionContext, this_argument: Valeur)
{
    // 1. Let thisMode be F.[[ThisMode]].
    this_mode := F.this_mode

    // 2. If thisMode is LEXICAL, return UNUSED.
    si this_mode == ThisMode.LEXICAL {
        retourne
    }

    // 3. Let calleeRealm be F.[[Realm]].
    callee_realm := F.realm

    // 4. Let localEnv be the LexicalEnvironment of calleeContext.
    local_env := callee_context.lexical_environment

    this_value: Valeur
    // 5. If thisMode is STRICT, then
    si this_mode == ThisMode.STRICT {
        // a. Let thisValue be thisArgument.
        this_value = this_argument
    }
    // 6. Else,
    sinon {
        // a. If thisArgument is either undefined or null, then
        si this_argument.est_undefined() || this_argument.est_nulle() {
            // i. Let globalEnv be calleeRealm.[[GlobalEnv]].
            global_env := callee_realm.global_environment

            // ii. Assert: globalEnv is a Global Environment Record.
            assert(global_env.donne_classe() == GlobalEnvironment)

            // iii. Let thisValue be globalEnv.[[GlobalThisValue]].
            this_value = global_env.global_this_value
        }
        // b. Else,
        sinon {
            // i. Let thisValue be ! ToObject(thisArgument).
            // ii. NOTE: ToObject produces wrapper objects using calleeRealm.
            this_value = vers_objet(callee_realm, this_argument).valeur.V
        }
    }

    // 7. Assert: localEnv is a Function Environment Record.
    assert(local_env.donne_classe() == FunctionEnvironment)

    // 8. Assert: The next step never returns an abrupt completion because localEnv.[[ThisBindingStatus]] is not INITIALIZED.
    // 9. Perform ! localEnv.BindThisValue(thisValue).
    completion := bind_this_value(local_env comme *FunctionEnvironment, this_value)
    assert(completion.est_normal())

    // 10. Return UNUSED.
    retourne
}

/* 10.2.1.3 Runtime Semantics: EvaluateBody
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-runtime-semantics-evaluatebody */
evaluate_body :: fonc (interpr√©teuse: *Interpr√©teuse, function_object: *Function, arguments_list: []Valeur) -> CompletionRecord
{
    // √Ä FAIRE : tous les cas
    // FunctionBody : FunctionStatementList
    // 1. Return ? EvaluateFunctionBody of FunctionBody with arguments functionObject and argumentsList.
    retourne evaluate_function_body(interpr√©teuse, function_object, arguments_list)
}

/* 10.2.1.4 OrdinaryCallEvaluateBody ( F, argumentsList )
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ordinarycallevaluatebody */
ordinary_call_evaluate_body :: fonc (interpr√©teuse: *Interpr√©teuse, F: *Function, arguments_list: []Valeur) -> CompletionRecord
{
    // 1. Return ? EvaluateBody of F.[[ECMAScriptCode]] with arguments F and argumentsList.
    retourne evaluate_body(interpr√©teuse, F, arguments_list)
}

/* 10.2.9 SetFunctionName ( F, name [ , prefix ] )
 * https://tc39.es/ecma262/#sec-setfunctionname */
set_function_name :: fonc (F: *Object, name: PropertyKey)
{
    // √Ä FAIRE : 1. Assert: F is an extensible object that does not have a "name" own property.
    assert(has_own_property(F, STR_name).valeur.V.est_false())

    // 2. If name is a Symbol, then
    si name.est_symbol() {
        // a. Let description be name's [[Description]] value.
        description := name.Symbol.description

        // b. If description is undefined, set name to the empty String.
        saufsi description.poss√®de_valeur() {
            name = cr√©e_chaine_utf16_unique_vide()
        }
        // c. Else, set name to the string-concatenation of "[", description, and "]".
        sinon {
            chn := imprime_chaine("[%]", description.Quelque)
            diff√®re d√©loge(chn)

            name = cr√©e_chaine_utf16_unique(chn)
        }
    }

    // √Ä FAIRE : 3. Else if name is a Private Name, then
        // a. Set name to name.[[Description]].

    // 4. If F has an [[InitialName]] internal slot, then
        // a. Set F.[[InitialName]] to name.

    // 5. If prefix is present, then
        // a. Set name to the string-concatenation of prefix, the code unit 0x0020 (SPACE), and name.
        // b. If F has an [[InitialName]] internal slot, then
            // i. Optionally, set F.[[InitialName]] to name.

    // 6. Perform ! DefinePropertyOrThrow(F, "name", PropertyDescriptor { [[Value]]: name, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }).
    desc: PropertyDescriptor
    desc.value = Valeur(String = cr√©e_chaine(F.donne_tas_de_m√©moire(), name.String))
    desc.configurable = vrai
    completion := define_property_or_throw(F, STR_name, desc)
    assert(completion.est_normal())

    // 7. Return unused.
}

/* 10.2.10 SetFunctionLength ( F, length )
 * https://tc39.es/ecma262/#sec-setfunctionname */
set_function_length :: fonc (F: *Object, length: n64)
{
    // 1. Assert: F is an extensible object that does not have a "length" own property.
    // √Ä FAIRE : extensible object
    assert(has_own_property(F, STR_length).valeur.V.est_false())

    // 2. Perform ! DefinePropertyOrThrow(F, "length", PropertyDescriptor { [[Value]]: ùîΩ(length), [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }).
    desc: PropertyDescriptor
    desc.value = Valeur(Number = length comme r64)
    desc.configurable = vrai
    completion := define_property_or_throw(F, STR_length, desc)
    assert(completion.est_normal())

    // 3. Return unused.
}

/* 10.2.11 FunctionDeclarationInstantiation ( func, argumentsList )
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-functiondeclarationinstantiation */
function_declaration_instantiation :: fonc (interpr√©teuse: *Interpr√©teuse, func: *Function, arguments_list: []Valeur) -> CompletionRecord
{
    // √Ä FAIRE

    // 1. Let calleeContext be the running execution context.
    callee_context := interpr√©teuse.donne_running_execution_context()

    // 2. Let code be func.[[ECMAScriptCode]].
    // code := func.corps

    // 3. Let strict be func.[[Strict]].
    strict := func.strict

    // 4. Let formals be func.[[FormalParameters]].
    formals := func.formal_parameters

    // 5. Let parameterNames be the BoundNames of formals.
    // √Ä FAIRE : BoundNames
    parameter_names: [..]ECMAString
    diff√®re d√©loge(parameter_names)

    pour formals {
        assert(it.type == Identifier)
        tableau_ajoute(*parameter_names, (it comme *Identifier).nom)
    }

    // 6. If parameterNames has any duplicate entries, let hasDuplicates be true. Otherwise, let hasDuplicates be false.
    // 7. Let simpleParameterList be IsSimpleParameterList of formals.

    // 8. Let hasParameterExpressions be ContainsExpression of formals.
    // √Ä FAIRE : ContainsExpression
    has_parameter_expression := faux

    // 9. Let varNames be the VarDeclaredNames of code.
    // 10. Let varDeclarations be the VarScopedDeclarations of code.
    // 11. Let lexicalNames be the LexicallyDeclaredNames of code.
    // 12. Let functionNames be a new empty List.
    // 13. Let functionsToInitialize be a new empty List.
    // 14. For each element d of varDeclarations, in reverse List order, do
        // a. If d is neither a VariableDeclaration nor a ForBinding nor a BindingIdentifier, then
            // i. Assert: d is either a FunctionDeclaration, a GeneratorDeclaration, an AsyncFunctionDeclaration, or an AsyncGeneratorDeclaration.
            // ii. Let fn be the sole element of the BoundNames of d.
            // iii. If functionNames does not contain fn, then
                // 1. Insert fn as the first element of functionNames.
                // 2. NOTE: If there are multiple function declarations for the same name, the last declaration is used.
                // 3. Insert d as the first element of functionsToInitialize.
    // 15. Let argumentsObjectNeeded be true.
    // 16. If func.[[ThisMode]] is LEXICAL, then
        // a. NOTE: Arrow functions never have an arguments object.
        // b. Set argumentsObjectNeeded to false.
    // 17. Else if parameterNames contains "arguments", then
        // a. Set argumentsObjectNeeded to false.
    // 18. Else if hasParameterExpressions is false, then
        // a. If functionNames contains "arguments" or lexicalNames contains "arguments", then
            // i. Set argumentsObjectNeeded to false.

    env: *Environment
    // 19. If strict is true or hasParameterExpressions is false, then
    si strict || has_parameter_expression == faux {
        // a. NOTE: Only a single Environment Record is needed for the parameters, since calls to eval in strict mode code cannot create new bindings which are visible outside of the eval.
        // b. Let env be the LexicalEnvironment of calleeContext.
        env = callee_context.lexical_environment
    }
    // 20. Else,
    sinon {
        // a. NOTE: A separate Environment Record is needed to ensure that bindings created by direct eval calls in the formal parameter list are outside the environment where parameters are declared.
        // b. Let calleeEnv be the LexicalEnvironment of calleeContext.
        // c. Let env be NewDeclarativeEnvironment(calleeEnv).
        // d. Assert: The VariableEnvironment of calleeContext and calleeEnv are the same Environment Record.
        // e. Set the LexicalEnvironment of calleeContext to env.
    }

    // 21. For each String paramName of parameterNames, do
    pour param_name dans parameter_names {
        // a. Let alreadyDeclared be ! env.HasBinding(paramName).
        already_declared := env.has_binding(param_name).valeur.V

        // b. NOTE: Early errors ensure that duplicate parameter names can only occur in non-strict functions that do not have parameter default values or rest parameters.

        // c. If alreadyDeclared is false, then
        si already_declared.est_false() {
            // i. Perform ! env.CreateMutableBinding(paramName, false).
            env.create_mutable_binding(param_name, faux)

            // ii. If hasDuplicates is true, then
                // 1. Perform ! env.InitializeBinding(paramName, undefined).
        }
    }

    // 22. If argumentsObjectNeeded is true, then
        // a. If strict is true or simpleParameterList is false, then
            // i. Let ao be CreateUnmappedArgumentsObject(argumentsList).
        // b. Else,
            // i. NOTE: A mapped argument object is only provided for non-strict functions that don't have a rest parameter, any parameter default value initializers, or any destructured parameters.
            // ii. Let ao be CreateMappedArgumentsObject(func, formals, argumentsList, env).
        // c. If strict is true, then
            // i. Perform ! env.CreateImmutableBinding("arguments", false).
            // ii. NOTE: In strict mode code early errors prevent attempting to assign to this binding, so its mutability is not observable.
        // d. Else,
            // i. Perform ! env.CreateMutableBinding("arguments", false).
        // e. Perform ! env.InitializeBinding("arguments", ao).
        // f. Let parameterBindings be the list-concatenation of parameterNames and ¬´ "arguments" ¬ª.
    // 23. Else,
        // a. Let parameterBindings be parameterNames.

    // 24. Let iteratorRecord be CreateListIteratorRecord(argumentsList).
    // 25. If hasDuplicates is true, then
        // a. Perform ? IteratorBindingInitialization of formals with arguments iteratorRecord and undefined.
    // 26. Else,
        // a. Perform ? IteratorBindingInitialization of formals with arguments iteratorRecord and env.
    pour parameter_names {
        si index_it >= arguments_list.taille {
            arr√™te
        }

        _ := env.initialize_binding(it, arguments_list[index_it])
    }

    // 27. If hasParameterExpressions is false, then
        // a. NOTE: Only a single Environment Record is needed for the parameters and top-level vars.
        // b. Let instantiatedVarNames be a copy of the List parameterBindings.
        // c. For each element n of varNames, do
            // i. If instantiatedVarNames does not contain n, then
                // 1. Append n to instantiatedVarNames.
                // 2. Perform ! env.CreateMutableBinding(n, false).
                // 3. Perform ! env.InitializeBinding(n, undefined).
        // d. Let varEnv be env.
    // 28. Else,
        // a. NOTE: A separate Environment Record is needed to ensure that closures created by expressions in the formal parameter list do not have visibility of declarations in the function body.
        // b. Let varEnv be NewDeclarativeEnvironment(env).
        // c. Set the VariableEnvironment of calleeContext to varEnv.
        // d. Let instantiatedVarNames be a new empty List.
        // e. For each element n of varNames, do
            // i. If instantiatedVarNames does not contain n, then
                // 1. Append n to instantiatedVarNames.
                // 2. Perform ! varEnv.CreateMutableBinding(n, false).
                // 3. If parameterBindings does not contain n, or if functionNames contains n, then
                    // a. Let initialValue be undefined.
                // 4. Else,
                    // a. Let initialValue be ! env.GetBindingValue(n, false).
                // 5. Perform ! varEnv.InitializeBinding(n, initialValue).
                // 6. NOTE: A var with the same name as a formal parameter initially has the same value as the corresponding initialized parameter.
    // 29. NOTE: Annex B.3.2.1 adds additional steps at this point.
    // 30. If strict is false, then
        // a. Let lexEnv be NewDeclarativeEnvironment(varEnv).
        // b. NOTE: Non-strict functions use a separate Environment Record for top-level lexical declarations so that a direct eval can determine whether any var scoped declarations introduced by the eval code conflict with pre-existing top-level lexically scoped declarations. This is not needed for strict functions because a strict direct eval always places all declarations into a new Environment Record.
    // 31. Else,
        // a. Let lexEnv be varEnv.
    // 32. Set the LexicalEnvironment of calleeContext to lexEnv.
    // 33. Let lexDeclarations be the LexicallyScopedDeclarations of code.
    // 34. For each element d of lexDeclarations, do
        // a. NOTE: A lexically declared name cannot be the same as a function/generator declaration, formal parameter, or a var name. Lexically declared names are only instantiated here but not initialized.
        // b. For each element dn of the BoundNames of d, do
            // i. If IsConstantDeclaration of d is true, then
                // 1. Perform ! lexEnv.CreateImmutableBinding(dn, true).
            // ii. Else,
                // 1. Perform ! lexEnv.CreateMutableBinding(dn, false).
    // 35. Let privateEnv be the PrivateEnvironment of calleeContext.
    // 36. For each Parse Node f of functionsToInitialize, do
        // a. Let fn be the sole element of the BoundNames of f.
        // b. Let fo be InstantiateFunctionObject of f with arguments lexEnv and privateEnv.
        // c. Perform ! varEnv.SetMutableBinding(fn, fo, false).

    // 37. Return UNUSED.
    retourne normal_completion(js_undefined)
}

/* 15.2.3 Runtime Semantics: EvaluateFunctionBody
 * https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-runtime-semantics-evaluatefunctionbody */
evaluate_function_body :: fonc (interpr√©teuse: *Interpr√©teuse, function_object: *Function, arguments_list: []Valeur) -> CompletionRecord
{
    // 1. Perform ? FunctionDeclarationInstantiation(functionObject, argumentsList).
    completion := function_declaration_instantiation(interpr√©teuse, function_object, arguments_list)
    saufsi completion.est_normal() {
        retourne completion
    }
    // 2. Return ? Evaluation of FunctionStatementList.
    retourne interpr√©teuse.ex√©cute(function_object.corps, TypeScope.FUNCTION)
}

/* ------------------------------------------------------------------------- */
/** \nom 19.2.1 eval ( x )
 * \{ */

#port√©e_fichier

/* Table virtuelle pour "eval()" */
table_virtuelle_function_eval := TableVirtuelleObject(classe = Function, sur_destruction = sur_destruction_objet, sur_call = eval_sur_call)

#port√©e_export

cr√©e_eval :: fonc (realm: *Realm, function_prototype: *FunctionPrototype) -> *Function
{
    r√©sultat := cr√©e_fonction(realm, function_prototype, nul)
    set_function_name(r√©sultat, STR_eval)
    r√©sultat.table = *table_virtuelle_function_eval
    retourne r√©sultat
}

/* https://tc39.es/ecma262/multipage/global-object.html#sec-eval-x */
eval_sur_call :: fonc (empl params: *Param√®tresObjectCall) -> CompletionRecord
{
    si arguments.taille == 0 {
        retourne normal_completion(js_undefined)
    }

    retourne perform_eval(interpr√©teuse, arguments[0], faux, faux)
}

/* 19.2.1.1 PerformEval ( x, strictCaller, direct )
 * https://tc39.es/ecma262/multipage/global-object.html#sec-performeval */
perform_eval :: fonc (interpr√©teuse: *Interpr√©teuse, x: Valeur, strict_caller: bool, direct: bool) -> CompletionRecord
{
    // 1. Assert: If direct is false, then strictCaller is also false.
    assert(direct == vrai || (direct == faux && strict_caller == faux))

    // 2. If x is not a String, return x.
    saufsi x.est_chaine() {
        retourne normal_completion(x)
    }

    // 3. Let evalRealm be the current Realm Record.
    // 4. NOTE: In the case of a direct eval, evalRealm is the realm of both the caller of eval and of the eval function itself.
    eval_realm := interpr√©teuse.donne_realm()

    // √Ä FAIRE : 5. Perform ? HostEnsureCanCompileStrings(evalRealm, ¬´ ¬ª, x, direct).

    // 6. Let inFunction be false.
    in_function := faux

    // 7. Let inMethod be false.
    // in_method := faux

    // 8. Let inDerivedConstructor be false.
    // in_derived_constructor := faux

    // 9. Let inClassFieldInitializer be false.
    // in_class_field_initializer := faux

    // 10. If direct is true, then
    si direct {
        // a. Let thisEnvRec be GetThisEnvironment().
        this_env_rec := get_this_environment(interpr√©teuse)

        // b. If thisEnvRec is a Function Environment Record, then
        si this_env_rec.table.classe == FunctionEnvironment {
            // √Ä FAIRE : i. Let F be thisEnvRec.[[FunctionObject]].

            // ii. Set inFunction to true.
            in_function = vrai

            // iii. Set inMethod to thisEnvRec.HasSuperBinding().
            // iv. If F.[[ConstructorKind]] is DERIVED, set inDerivedConstructor to true.
            // v. Let classFieldInitializerName be F.[[ClassFieldInitializerName]].
            // vi. If classFieldInitializerName is not EMPTY, set inClassFieldInitializer to true.
        }
    }

    // √Ä FAIRE : 11. Perform the following substeps in an implementation-defined order, possibly interleaving parsing and error detection:
    // √Ä FAIRE : a. Let script be ParseText(x, Script).
    // b. If script is a List of errors, throw a SyntaxError exception.
    script: *Script
    contenu := converti_vers_chaine(x.String.texte.donne_chaine_utf16())
    diff√®re d√©loge(contenu)

    discr parse_script(contenu, eval_realm) {
        Ok(s) {
            script = s
        }
        Erreur(e) {
            diff√®re d√©loge(e.message)
            retourne interpr√©teuse.lance_syntax_error(e.message)
        }
        sinon {
            chn := "Erreur inconnue"
            retourne interpr√©teuse.lance_syntax_error(chn)
        }
    }

    // √Ä FAIRE : c. If script Contains ScriptBody is false, return undefined.
    // √Ä FAIRE : d. Let body be the ScriptBody of script.
    body := script.ecma_script_code

    // √Ä FAIRE : e. If inFunction is false and body Contains NewTarget, throw a SyntaxError exception.
    // √Ä FAIRE : f. If inMethod is false and body Contains SuperProperty, throw a SyntaxError exception.
    // √Ä FAIRE : g. If inDerivedConstructor is false and body Contains SuperCall, throw a SyntaxError exception.
    // √Ä FAIRE : h. If inClassFieldInitializer is true and ContainsArguments of body is true, throw a SyntaxError exception.

    // 12. If strictCaller is true, let strictEval be true.
    strict_eval := si strict_caller {
        vrai
    }
    // 13. Else, let strictEval be ScriptIsStrict of script.
    sinon {
        // √Ä FAIRE : ScriptIsStrict
        faux
    }

    // 14. Let runningContext be the running execution context.
    // 15. NOTE: If direct is true, runningContext will be the execution context that performed the direct eval. If direct is false, runningContext will be the execution context for the invocation of the eval function.
    running_context := interpr√©teuse.donne_running_execution_context()

    lex_env: *Environment
    var_env: *Environment
    private_env: *PrivateEnvironment

    // 16. If direct is true, then
    si direct {
        // a. Let lexEnv be NewDeclarativeEnvironment(runningContext's LexicalEnvironment).
        lex_env = new_declarative_environment(interpr√©teuse.donne_tas_de_m√©moire(), running_context.lexical_environment)

        // b. Let varEnv be runningContext's VariableEnvironment.
        var_env = running_context.variable_environment
    
        // c. Let privateEnv be runningContext's PrivateEnvironment.
        private_env = running_context.private_environment
    }
    // 17. Else,
    sinon {
        // a. Let lexEnv be NewDeclarativeEnvironment(evalRealm.[[GlobalEnv]]).
        lex_env = new_declarative_environment(interpr√©teuse.donne_tas_de_m√©moire(), eval_realm.global_environment)

        // b. Let varEnv be evalRealm.[[GlobalEnv]].
        var_env = eval_realm.global_environment

        // c. Let privateEnv be null.
        private_env = nul
    }

    // 18. If strictEval is true, set varEnv to lexEnv.
    si strict_eval {
        var_env = lex_env
    }

    // 19. If runningContext is not already suspended, suspend runningContext.
    mv := interpr√©teuse.mv
    mv.suspend_running_execution_context()

    // 20. Let evalContext be a new ECMAScript code execution context.
    eval_context := cr√©e_execution_context(interpr√©teuse.donne_tas_de_m√©moire())

    // 21. Set evalContext's Function to null.
    eval_context.function = nul

    // 22. Set evalContext's Realm to evalRealm.
    eval_context.realm = eval_realm

    // 23. Set evalContext's ScriptOrModule to runningContext's ScriptOrModule.
    eval_context.script_or_module = running_context.script_or_module

    // 24. Set evalContext's VariableEnvironment to varEnv.
    eval_context.variable_environment = var_env

    // 25. Set evalContext's LexicalEnvironment to lexEnv.
    eval_context.lexical_environment = lex_env

    // 26. Set evalContext's PrivateEnvironment to privateEnv.
    eval_context.private_environment = private_env

    // 27. Push evalContext onto the execution context stack; evalContext is now the running execution context.
    mv.empile_execution_context(eval_context)

    // √Ä FAIRE : 28. Let result be Completion(EvalDeclarationInstantiation(body, varEnv, lexEnv, privateEnv, strictEval)).
    result := normal_completion(js_undefined)

    // 29. If result is a normal completion, then
    si result.est_normal() {
        // a. Set result to Completion(Evaluation of body).
        result = interpr√©teuse.ex√©cute(body)
    }

    // 30. If result is a normal completion and result.[[Value]] is EMPTY, then
        // a. Set result to NormalCompletion(undefined).

    // 31. Suspend evalContext and remove it from the execution context stack.
    mv.suspend_running_execution_context()
    mv.d√©pile_execution_context()

    // √Ä FAIRE : 32. Resume the context that is now on the top of the execution context stack as the running execution context.

    // 33. Return ? result.
    retourne result
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom PrimitiveChaine
 * \{ */

#port√©e_fichier

table_virtuelle_primitive_chaine := TableVirtuelleCellule(classe = PrimitiveChaine)

#port√©e_export

PrimitiveChaine :: struct {
    empl cellule: Cellule
    table = *table_virtuelle_primitive_chaine

    texte: ECMAString
    objet: *Object
}

cr√©e_chaine :: fonc (tas_de_m√©moire: *TasDeM√©moire, texte: ECMAString) -> *PrimitiveChaine
{
    r√©sultat := tas_de_m√©moire.alloue(PrimitiveChaine)
    r√©sultat.texte = texte
    retourne r√©sultat
}

/** \} */
