importe Chaine
importe Fondation

charge "arbre"
charge "enveloppe"
charge "environment"
charge "interpr√©teuse"
charge "lexage"
charge "lex√®mes"
charge "parsage"
charge "realm"
charge "script"
charge "tas_de_m√©moire"
charge "terminologie"

ECMAString :: ChaineUTF16Unique

/* ------------------------------------------------------------------------- */
/** \nom Valeur
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof
 * \{ */

NaN : r64 : 0r7ff8000000000000

/* Ceux-l√† ne sont pas dans le standard, ce n'est que pour avoir des types pour l'union. */
UndefinedType :: #opaque z32
NullType :: #opaque z32

BigInt :: struct {
    // √Ä FAIRE : impl√©mente proprement
    valeur: z64
}

big_int_equal :: fonc (x: Valeur @inutilis√©e, y: Valeur @inutilis√©e) -> bool
{
    panique("big_int equal non-impl√©ment√©")
}

/* ------------------------------------------------------------------------- */
/** \nom 6.1.5 The Symbol Type
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-ecmascript-language-types-symbol-type
 * \{ */

Symbol :: struct {
    /* Soit undefined ou une chaine. */
    description: Optionnel(ECMAString)
}

/** \} */

Valeur :: union {
    Undefined: UndefinedType
    Null: NullType
    Boolean: bool
    Number: r64
    BigInt: BigInt
    String: *PrimitiveChaine
    Symbol: *Symbol
    Function: *Function
    Object: *Object
}

imprime_valeur :: fonc (enchaineuse: *Enchaineuse, valeur: *Valeur)
{
    saufsi valeur {
        ajoute_au_tampon(enchaineuse, "nul")
        retourne
    }

    discr m√©moire(valeur) {
        Undefined {
            ajoute_au_tampon(enchaineuse, "undefined")
        }
        Null {
            ajoute_au_tampon(enchaineuse, "null")
        }
        Boolean(b) {
            si b {
                ajoute_au_tampon(enchaineuse, "true")
            }
            sinon {
                ajoute_au_tampon(enchaineuse, "false")
            }
        }
        Number(n) {
            ajoute_au_tampon(enchaineuse, n)
        }
        Object(o) {
            si o.donne_classe() == ReferenceError {
                error := o comme *ReferenceError
                ajoute_au_tampon(enchaineuse, error.donne_nom_classe(), ": ", error.message.texte)
            }
            sinon si o.donne_classe() == TypeError {
                error := o comme *TypeError
                ajoute_au_tampon(enchaineuse, error.donne_nom_classe(), ": ", error.message.texte)
            }
            sinon {
                ajoute_au_tampon(enchaineuse, "[object ", o.donne_nom_classe(), "]")
            }
        }
        Function(o) {
            ajoute_au_tampon(enchaineuse, "[object ", o.donne_nom_classe(), "]")
        }
        String(s) {
            ajoute_au_tampon(enchaineuse, "\"", s.texte, "\"")
        }
        sinon {
            ajoute_au_tampon(enchaineuse, "Valeur inconnue.")
        }
    }
} @FormattageImpression

/* √Ä FAIRE(language) : index_de(valeur) == Number  */
est_fonction :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Function {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_object :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Object {
            retourne vrai
        }
        sinon {
            retourne est_fonction(valeur)
        }
    }
}

donne_objet :: fonc (valeur: Valeur) -> *Object
{
    discr valeur {
        Object(objet) {
            retourne objet
        }
        Function(function) {
            retourne function
        }
        sinon {
            retourne nul
        }
    }
}

est_cellule :: fonc (valeur: Valeur) -> bool
{
    retourne valeur.est_object() || valeur.est_chaine()
}

donne_cellule :: fonc (valeur: Valeur) -> *Cellule
{
    discr valeur {
        Object(o) {
            retourne o
        }
        Function(f) {
            retourne f
        }
        String(s) {
            retourne s
        }
        sinon {
            retourne nul
        }
    }
}

est_nombre :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Number {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_chaine :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        String {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_nulle :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Null {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_undefined :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Undefined {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_boolean :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Boolean {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_true :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Boolean {
            retourne valeur.Boolean
        }
        sinon {
            retourne faux
        }
    }
}

est_false :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Boolean {
            retourne !valeur.Boolean
        }
        sinon {
            retourne faux
        }
    }
}

est_big_int :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        BigInt {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_symbol :: fonc (valeur: Valeur) -> bool
{
    discr valeur {
        Symbol {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

concat√®ne :: fonc (str_gauche: *PrimitiveChaine, str_droite: *PrimitiveChaine) -> Valeur
{
    chn1 := str_gauche.texte.donne_chaine_utf16()
    chn2 := str_droite.texte.donne_chaine_utf16()

    enchaineuse: EnchaineuseUTF16
    initialise_enchaineuse(enchaineuse)
    diff√®re d√©truit_tampons(enchaineuse)

    ajoute(enchaineuse, chn1)
    ajoute(enchaineuse, chn2)

    chn := chaine_depuis_enchaineuse(enchaineuse)
    chn_r√©sultat := cr√©e_chaine_utf16_unique(chn)

    retourne Valeur(String = cr√©e_chaine(str_gauche.donne_tas_de_m√©moire(), chn_r√©sultat))
}

js_null := Valeur(Null = NullType(0))
js_undefined := Valeur(Undefined = UndefinedType(0))

TypePr√©f√©r√© :: √©num {
    Aucun
    Number
    String
}

/* 7.1.18 ToObject ( argument )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-toobject */
vers_objet :: fonc (realm: *Realm, valeur: Valeur) -> CompletionRecord
{
    si valeur.est_undefined() {
        retourne lance_type_error(realm, "undefined is not an Object")
    }

    si valeur.est_nulle() {
        retourne lance_type_error(realm, "null is not an Object")
    }

    si valeur.est_object() {
        retourne normal_completion(Valeur(Object = valeur.donne_objet()))
    }

    si valeur.est_chaine() {
        chn := valeur.String
        saufsi chn.objet {
            chn.objet = cr√©e_chaine(realm.donne_tas_de_m√©moire(), realm.intrinsics.string_prototype, valeur.String)
        }
        retourne normal_completion(Valeur(Object = chn.objet))
    }

    panique("vers_objet non-impl√©ment√© pour type")
}

/* 7.1.19 ToPropertyKey ( argument )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-topropertykey */
to_property_key :: fonc (interpr√©teuse: &Interpr√©teuse, argument: Valeur) -> CompletionRecord
{
    retourne to_property_key(interpr√©teuse.donne_realm(), argument)
}

to_property_key :: fonc (realm: *Realm, argument: Valeur) -> CompletionRecord
{
    // 1. Let key be ? ToPrimitive(argument, STRING).
    completion := vers_primitive(realm, argument, TypePr√©f√©r√©.String)
    saufsi completion.est_normal() {
        retourne completion
    }
    key := completion.valeur.V

    // 2. If key is a Symbol, then
    si key.est_symbol() {
        // a. Return key.
        retourne normal_completion(key)
    }

    // 3. Return ! ToString(key).
    retourne vers_chaine(realm, key)
}

/* 7.1.20 ToLength ( argument )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-tolength */
to_length :: fonc (argument: Valeur) -> CompletionRecord
{
    assert(argument.est_nombre())
    /* √Ä FAIRE : ToIntegerOrInfinity. */
    // 1. Let len be ? ToIntegerOrInfinity(argument).
    len := argument.Number

    // 2. If len ‚â§ 0, return +0ùîΩ.
    si len <= 0.0 {
        retourne normal_completion(Valeur(Number = 0.0))
    }

    // 3. Return ùîΩ(min(len, 2**53 - 1)).
    retourne normal_completion(argument)
}

/* 7.1.1 ToPrimitive ( input [ , preferredType ] )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-toprimitive */
vers_primitive :: fonc (interpr√©teuse: &Interpr√©teuse, valeur: Valeur, type_pr√©f√©r√© := TypePr√©f√©r√©.Aucun) -> CompletionRecord
{
    retourne vers_primitive(interpr√©teuse.donne_realm(), valeur, type_pr√©f√©r√©)
}

vers_primitive :: fonc (realm: *Realm @inutilis√©e, valeur: Valeur, type_pr√©f√©r√© := TypePr√©f√©r√©.Aucun @inutilis√©e) -> CompletionRecord
{
    // 1. If input is an Object, then
    si valeur.est_object() {
        panique("to_primitive non-impl√©ment√©")
        // a. Let exoticToPrim be ? GetMethod(input, %Symbol.toPrimitive%).
        // b. If exoticToPrim is not undefined, then
        // i. If preferredType is not present, then
        // 1. Let hint be "default".
        // ii. Else if preferredType is STRING, then
        // 1. Let hint be "string".
        // iii. Else,
        // 1. Assert: preferredType is NUMBER.
        // 2. Let hint be "number".
        // iv. Let result be ? Call(exoticToPrim, input, ¬´ hint ¬ª).
        // v. If result is not an Object, return result.
        // vi. Throw a TypeError exception.
        // c. If preferredType is not present, let preferredType be NUMBER.
        // d. Return ? OrdinaryToPrimitive(input, preferredType).
    }

    // 2. Return input.
    retourne normal_completion(valeur)
}

/* 7.1.2 ToBoolean ( argument )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-toboolean */
to_boolean :: fonc (valeur: Valeur) -> Valeur
{
    // 1. If argument is a Boolean, return argument.
    si valeur.est_boolean() {
        retourne valeur
    }

    // 2. If argument is one of undefined, null, +0ùîΩ, -0ùîΩ, NaN, 0‚Ñ§, or the empty String, return false.
    discr valeur {
        Null {
            retourne Valeur(Boolean = faux)
        }
        Undefined {
            retourne Valeur(Boolean = faux)
        }
        Number(n) {
            si n == 0.0 || n == -0.0 {
                retourne Valeur(Boolean = faux)
            }

            // √Ä FAIRE : NaN, 0‚Ñ§
        }
        String(s) {
            si s.texte == cr√©e_chaine_utf16_unique("") {
                retourne Valeur(Boolean = faux)
            }
        }
        sinon {}
    }

    // √Ä FAIRE : 3. If argument is an Object and argument has an [[IsHTMLDDA]] internal slot, return false.

    // 4. Return true.
    retourne Valeur(Boolean = vrai)
}

/* 7.1.3 ToNumeric ( value )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-tonumeric */
to_numeric :: fonc (interpr√©teuse: &Interpr√©teuse, valeur: Valeur) -> CompletionRecord
{
    // 1. Let primValue be ? ToPrimitive(value, NUMBER).
    compl√©tion_valeur_primitive := vers_primitive(interpr√©teuse, valeur, TypePr√©f√©r√©.Number)
    saufsi compl√©tion_valeur_primitive.est_normal() {
        retourne compl√©tion_valeur_primitive
    }
    valeur_primitive := compl√©tion_valeur_primitive.valeur.V

    // 2. If primValue is a BigInt, return primValue.
    si valeur_primitive.est_big_int() {
        retourne normal_completion(valeur_primitive)
    }

    // 3. Return ? ToNumber(primValue).
    retourne vers_nombre(interpr√©teuse, valeur_primitive)
}

/* https://tc39.es/ecma262/multipage/abstract-operations.html#sec-tonumber */
vers_nombre :: fonc (interpr√©teuse: &Interpr√©teuse, valeur: Valeur) -> CompletionRecord
{
    // 1. If argument is a Number, return argument.
    si valeur.est_nombre() {
        retourne normal_completion(valeur)
    }

    // 2. If argument is either a Symbol or a BigInt, throw a TypeError exception.
    si valeur.est_symbol() {
        retourne lance_type_error(interpr√©teuse, "can't convert Symbol to number")
    }
    si valeur.est_big_int() {
        retourne lance_type_error(interpr√©teuse, "can't convert BigInt to number")
    }

    // 3. If argument is undefined, return NaN.
    si valeur.est_undefined() {
        retourne normal_completion(Valeur(Number = NaN))
    }

    // 4. If argument is either null or false, return +0ùîΩ.
    si valeur.est_nulle() || valeur.est_false() {
        retourne normal_completion(Valeur(Number = 0.0))
    }

    // 5. If argument is true, return 1ùîΩ.
    si valeur.est_true() {
        retourne normal_completion(Valeur(Number = 1.0))
    }

    // 6. If argument is a String, return StringToNumber(argument).
    si valeur.est_chaine() {
        retourne normal_completion(string_to_number(valeur))
    }

    // 7. Assert: argument is an Object.
    assert(valeur.est_object())

    // 8. Let primValue be ? ToPrimitive(argument, NUMBER).
    completion_primitive := vers_primitive(interpr√©teuse, valeur, TypePr√©f√©r√©.Number)
    saufsi completion_primitive.est_normal() {
        retourne completion_primitive
    }
    prim_value := completion_primitive.valeur.V

    // 9. Assert: primValue is not an Object.
    assert(prim_value.est_object() == faux)

    // 10. Return ? ToNumber(primValue).
    retourne vers_nombre(interpr√©teuse, prim_value)
}

/* 7.1.4.1.1 StringToNumber ( str )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-stringtonumber */
string_to_number :: fonc (valeur: Valeur) -> Valeur
{
    str := valeur.String.texte

    // √Ä FAIRE : standardise
    // 1. Let literal be ParseText(str, StringNumericLiteral).
    // 2. If literal is a List of errors, return NaN.
    // 3. Return the StringNumericValue of literal.

    source: TexteSource
    source.texte = converti_vers_chaine(str.donne_chaine_utf16())
    diff√®re d√©loge(source.texte)

    lex√®mes: [..]Lex√®me
    diff√®re d√©loge(lex√®mes)

    r√©sultat_lexage := l√®xe(source)
    discr r√©sultat_lexage {
        Ok(l) {
            lex√®mes = l
        }
        sinon {
            retourne Valeur(Number = NaN)
        }
    }

    si lex√®mes.taille != 1 {
        retourne Valeur(Number = NaN)
    }

    /* √Ä FAIRE : prend en compte les signes +/-. */
    si lex√®mes[0].genre != GenreLex√®me.NombreLitt√©ral {
        retourne Valeur(Number = NaN)
    }

    retourne Valeur(Number = parse_nombre_depuis_lex√®me(*lex√®mes[0]))
}

/* 7.1.17 ToString ( argument )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-tostring */
vers_chaine :: fonc (interpr√©teuse: &Interpr√©teuse, argument: Valeur) -> CompletionRecord
{
    retourne vers_chaine(interpr√©teuse.donne_realm(), argument)
}

vers_chaine :: fonc (realm: *Realm, argument: Valeur) -> CompletionRecord
{
    // 1. If argument is a String, return argument.
    si argument.est_chaine() {
        retourne normal_completion(argument)
    }

    // 2. If argument is a Symbol, throw a TypeError exception.
    si argument.est_symbol() {
        retourne lance_type_error(realm, "can't convert Symbol to string")
    }

    // 3. If argument is undefined, return "undefined".
    si argument.est_undefined() {
        retourne normal_completion(cr√©e_chaine(realm.donne_tas_de_m√©moire(), STR_undefined))
    }

    // 4. If argument is null, return "null".
    si argument.est_nulle() {
        retourne normal_completion(cr√©e_chaine(realm.donne_tas_de_m√©moire(), STR_null))
    }

    // 5. If argument is true, return "true".
    si argument.est_true() {
        retourne normal_completion(cr√©e_chaine(realm.donne_tas_de_m√©moire(), STR_true))
    }

    // 6. If argument is false, return "false".
    si argument.est_false() {
        retourne normal_completion(cr√©e_chaine(realm.donne_tas_de_m√©moire(), STR_false))
    }

    // 7. If argument is a Number, return Number::toString(argument, 10).
    si argument.est_nombre() {
        // √Ä FAIRE : impl√©mente selon le standard.
        n := argument.Number
        chn := imprime_chaine("%", n)
        diff√®re d√©loge(chn)

        r√©sultat := cr√©e_chaine_utf16_unique(chn)
        retourne normal_completion(cr√©e_chaine(realm.donne_tas_de_m√©moire(), r√©sultat))
    }

    // 8. If argument is a BigInt, return BigInt::toString(argument, 10).
    si argument.est_big_int() {
        panique("vers_chaine sur big_int non-impl√©ment√©")
    }

    // 9. Assert: argument is an Object.
    assert(argument.est_object())

    // 10. Let primValue be ? ToPrimitive(argument, STRING).
    completion_prim_value := vers_primitive(realm, argument, TypePr√©f√©r√©.String)
    saufsi completion_prim_value.est_normal() {
        retourne completion_prim_value
    }
    prim_value := completion_prim_value.valeur.V

    // 11. Assert: primValue is not an Object.
    assert(!prim_value.est_object())

    // 12. Return ? ToString(primValue).
    retourne vers_chaine(realm, prim_value)
}

/* 7.2.3 IsCallable ( argument )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-iscallable */
is_callable :: fonc (argument: Valeur) -> bool
{
    // 1. If argument is not an Object, return false.
    saufsi argument.est_object() {
        retourne faux
    }

    // 2. If argument has a [[Call]] internal method, return true.
    object := argument.donne_objet()
    si object.sur_call {
        retourne vrai
    }

    // 3. Return false.
    retourne faux
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom PropertyDescriptor
 * 6.2.6 The Property Descriptor Specification Type
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-property-descriptor-specification-type
 * \{ */

PropertyDescriptor :: struct {
    value: Optionnel(Valeur)
    get: Optionnel(*Object) // ou undefined
    set: Optionnel(*Object) // ou undefined
    writable: Optionnel(bool)
    configurable: Optionnel(bool)
    enumerable: Optionnel(bool)
}

/* 6.2.6.1 IsAccessorDescriptor ( Desc )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-isaccessordescriptor */
is_accessor_descriptor :: fonc (desc: &PropertyDescriptor) -> bool
{
    // √Ä FAIRE 1. If Desc is undefined, return false.

    // 2. If Desc has a [[Get]] field, return true.
    si desc.get.poss√®de_valeur() {
        retourne vrai
    }
    // 3. If Desc has a [[Set]] field, return true.
    si desc.set.poss√®de_valeur() {
        retourne vrai
    }
    // 4. Return false.
    retourne faux
}

/* 6.2.6.2 IsDataDescriptor ( Desc )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-isdatadescriptor */
is_data_descriptor :: fonc (desc: &PropertyDescriptor) -> bool
{
    // √Ä FAIRE 1. If Desc is undefined, return false.

    // 2. If Desc has a [[Value]] field, return true.
    si desc.value.poss√®de_valeur() {
        retourne vrai
    }
    // 3. If Desc has a [[Writable]] field, return true.
    si desc.writable.poss√®de_valeur() {
        retourne vrai
    }
    // 4. Return false.
    retourne faux
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Object
 * \{ */

TypeFonctionObjectCall :: fonc(*Object, &Interpr√©teuse, Valeur, []Valeur)(CompletionRecord)

#port√©e_fichier

table_virtuelle_objet := TableVirtuelleCellule(classe = Object, sur_destruction = sur_destruction_objet)

#port√©e_export

DrapeauxPropri√©t√© :: √©num_drapeau n8 {
    WRITABLE
    ENUMERABLE
    CONFIGURABLE
}

Configurable :: DrapeauxPropri√©t√©.CONFIGURABLE
Enumerable :: DrapeauxPropri√©t√©.ENUMERABLE
Writable :: DrapeauxPropri√©t√©.WRITABLE

PropertyKey :: union {
    String: ECMAString
    Symbol: *Symbol
}

op√©rateur == :: fonc (p1: PropertyKey, p2: PropertyKey) -> bool
{
    discr p1 {
        String(s1) {
            discr p2 {
                String(s2) {
                    retourne s1 == s2
                }
                sinon {
                    retourne faux
                }
            }
        }
        Symbol(s1) {
            discr p2 {
                Symbol(s2) {
                    retourne s1 == s2
                }
                sinon {
                    retourne faux
                }
            }
        }
        sinon {
            retourne faux
        }
    }
}

op√©rateur != :: fonc (p1: PropertyKey, p2: PropertyKey) -> bool
{
    retourne !(p1 == p2)
}

Object :: struct {
    empl base: Cellule
    table = *table_virtuelle_objet

    /* https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-property-attributes */
    Propri√©t√© :: struct {
        nom: PropertyKey
        valeur: Valeur
        get: fonc(*Object)(Valeur)
        set: fonc(*Object, Valeur)(rien)
        drapeaux: DrapeauxPropri√©t√©
    }

    propri√©t√©s: [..]Propri√©t√©

    prototype: *Object

    /* Table virtuelle. */
    sur_get_prototype_of := ordinary_get_prototype_of
    sur_get_own_property := ordinary_get_own_property
    sur_define_own_property := ordinary_define_own_property
    sur_get := ordinary_get
    sur_call: TypeFonctionObjectCall
}

is_data_propery :: fonc (propri√©t√©: &Object.Propri√©t√©) -> bool
{
    retourne propri√©t√©.get == nul && propri√©t√©.set == nul
}

is_accessor_propery :: fonc (propri√©t√©: &Object.Propri√©t√©) -> bool
{
    retourne !is_data_propery(propri√©t√©)
}

cr√©e_objet :: fonc (tas_de_m√©moire: *TasDeM√©moire, prototype: *ObjectPrototype) -> *Object
{
    r√©sultat := tas_de_m√©moire.alloue(Object)
    r√©sultat.prototype = prototype
    retourne r√©sultat
}

sur_destruction_objet :: fonc (base: *Cellule)
{
    objet := base comme *Object
    d√©loge(objet.propri√©t√©s)
}

ajoute_propri√©t√© :: fonc (objet: *Object, nom: PropertyKey, valeur: Valeur, drapeaux: DrapeauxPropri√©t√©)
{
    tableau_ajoute(*objet.propri√©t√©s, Object.Propri√©t√©(nom, valeur, drapeaux = drapeaux))
}

/* [[GetPrototypeOf]] */
internal_get_prototype_of :: fonc (object: *Object) -> *Object
{
    retourne object.sur_get_prototype_of(object)
}

/* [[GetOwnProperty]] */
internal_get_own_property :: fonc (object: *Object, property_key: PropertyKey) -> CompletionRecord
{
    retourne object.sur_get_own_property(object, property_key)
}

/* [[DefineOwnProperty]] */
internal_define_own_property :: fonc (object: *Object, property_key: PropertyKey, desc: &PropertyDescriptor) -> CompletionRecord
{
    retourne object.sur_define_own_property(object, property_key, desc)
}

/* [[HasProperty]] */
internal_has_property :: fonc (object: *Object, property_key: PropertyKey) -> CompletionRecord
{
    // √Ä FAIRE : sur_has_property
    propri√©t√© := trouve_propri√©t√©(object, property_key)
    si propri√©t√© {
        retourne normal_completion(Valeur(Boolean = vrai))
    }
    retourne normal_completion(Valeur(Boolean = faux))
}

/* [[Get]] */
internal_get :: fonc (object: *Object, property_key: PropertyKey, receiver: Valeur) -> CompletionRecord
{
    retourne object.sur_get(object, property_key, receiver)
}

/* [[Set]] */
internal_set :: fonc (object: *Object, property_key: PropertyKey, valeur: Valeur, receiver: Valeur @inutilis√©e) -> CompletionRecord
{
    // √Ä FAIRE : sur_set
    propri√©t√© := trouve_propri√©t√©(object, property_key)
    si propri√©t√© {
        propri√©t√©.valeur = valeur
        retourne normal_completion(Valeur(Boolean = vrai))
    }

    tableau_ajoute(*object.propri√©t√©s, Object.Propri√©t√©(property_key, valeur))
    retourne normal_completion(Valeur(Boolean = vrai))
}

/* [[Call]] */
internal_call :: fonc (object: *Object, interpr√©teuse: &Interpr√©teuse, this_value: Valeur, arguments: []Valeur) -> CompletionRecord
{
    retourne object.sur_call(object, interpr√©teuse, this_value, arguments)
}

trouve_propri√©t√© :: fonc (objet: *Object, nom: PropertyKey) -> *Object.Propri√©t√©
{
    pour * objet.propri√©t√©s {
        si it.nom == nom {
            retourne it
        }
    }
    retourne nul
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 7.3 Operations on Objects
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-operations-on-objects
 * \{ */

/* 7.3.2 Get
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-get-o-p */
get :: fonc (object: *Object, property_key: PropertyKey) -> CompletionRecord
{
    // 1. Return ? O.[[Get]](P, O).
    retourne object.internal_get(property_key, Valeur(Object = object))
}

/* 7.3.4 Set
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-set-o-p-v-throw */
set :: fonc (object: *Object, property_key: PropertyKey, valeur: Valeur, throw: bool) -> CompletionRecord
{
    // 1. Let success be ? O.[[Set]](P, V, O).
    completion := object.internal_set(property_key, valeur, Valeur(Object = object))
    saufsi completion.est_normal() {
        retourne completion
    }
    succ√®s := completion.valeur.V
    // 2. If success is false and Throw is true, throw a TypeError exception.
    si succ√®s.est_false() && throw == vrai {
        panique("exceptions non-impl√©ment√©es")
    }

    // 3. Return UNUSED.
    retourne normal_completion(js_undefined)
}

/* 7.3.5 CreateDataProperty ( O, P, V )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-createdataproperty */
create_data_property :: fonc (object: *Object, property_key: PropertyKey, valeur: Valeur) -> CompletionRecord
{
    // 1. Let newDesc be the PropertyDescriptor { [[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true }.
    new_desc: PropertyDescriptor
    new_desc.value = valeur
    new_desc.writable = vrai
    new_desc.enumerable = vrai
    new_desc.configurable = vrai

    // 2. Return ? O.[[DefineOwnProperty]](P, newDesc).
    retourne internal_define_own_property(object, property_key, new_desc)
}

/* 7.3.6 CreateDataPropertyOrThrow ( O, P, V )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-createdatapropertyorthrow */
create_data_property_or_throw :: fonc (object: *Object, property_key: PropertyKey, valeur: Valeur) -> CompletionRecord
{
    // 1. Let success be ? CreateDataProperty(O, P, V).
    completion := create_data_property(object, property_key, valeur)
    saufsi completion.est_normal() {
        retourne completion
    }
    success := completion.valeur.V

    // 2. If success is false, throw a TypeError exception.
    si success.est_false() {
        panique("Exception non-impl√©ment√©e")
    }

    // 3. Return UNUSED.
    retourne normal_completion(js_undefined)
}

/* 7.3.8 DefinePropertyOrThrow ( O, P, desc )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-definepropertyorthrow */
define_property_or_throw :: fonc (object: *Object, property_key: PropertyKey, desc: &PropertyDescriptor) -> CompletionRecord
{
    // 1. Let success be ? O.[[DefineOwnProperty]](P, desc).
    completion := internal_define_own_property(object, property_key, desc)
    saufsi completion.est_normal() {
        retourne completion
    }
    success := completion.valeur.V

    // 2. If success is false, throw a TypeError exception.
    si success.est_false() {
        panique("Exception non-impl√©ment√©e")
    }

    // 3. Return UNUSED.
    retourne normal_completion(js_undefined)
}

/* 7.3.11 HasProperty ( O, P ) 
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-hasproperty */
has_property :: fonc (object: *Object, property_key: PropertyKey) -> CompletionRecord
{
    // 1. Return ? O.[[HasProperty]](P).
    retourne internal_has_property(object, property_key)
}

/* 7.3.12 HasOwnProperty ( O, P )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-hasownproperty */
has_own_property :: fonc (object: *Object, nom: PropertyKey) -> CompletionRecord
{
    completion_desc := internal_get_own_property(object, nom)
    saufsi completion_desc.est_normal() {
        retourne completion_desc
    }

    desc := completion_desc.valeur
    si desc.est_undefined() {
        retourne normal_completion(Valeur(Boolean = faux))
    }

    retourne normal_completion(Valeur(Boolean = vrai))
}

/* 7.3.13 Call ( F, V [ , argumentsList ] )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-call */
call :: fonc (interpr√©teuse: &Interpr√©teuse, valeur: Valeur, this_value: Valeur) -> CompletionRecord
{
    // 1. If argumentsList is not present, set argumentsList to a new empty List.
    arguments: []Valeur
    retourne call(interpr√©teuse, valeur, this_value, arguments)
}

call :: fonc (interpr√©teuse: &Interpr√©teuse, valeur: Valeur, this_value: Valeur, arguments: []Valeur) -> CompletionRecord
{
    // Continuation de la version sans arguments.
    // 2. If IsCallable(F) is false, throw a TypeError exception.
    saufsi is_callable(valeur) {
        message := imprime_chaine("'%' is not callable", valeur)
        retourne lance_type_error(interpr√©teuse, message)
    }

    object := valeur.donne_objet()

    // 3. Return ? F.[[Call]](V, argumentsList).
    retourne object.internal_call(interpr√©teuse, this_value, arguments)
}

/*7.3.18 LengthOfArrayLike ( obj )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-lengthofarraylike */
length_of_array_like :: fonc (obj: *Object) -> CompletionRecord
{
    // 1. Return ‚Ñù(? ToLength(? Get(obj, "length"))).
    completion := get(obj, STR_length)
    saufsi completion.est_normal() {
        retourne completion
    }
    completion = to_length(completion.valeur.V)
    saufsi completion.est_normal() {
        retourne completion
    }
    retourne normal_completion(completion.valeur.V)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 10.1 Ordinary Object Internal Methods and Internal Slots
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ordinary-object-internal-methods-and-internal-slots
 * \{ */

/* 10.1.1.1 OrdinaryGetPrototypeOf ( O )
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ordinarygetprototypeof */
ordinary_get_prototype_of :: fonc (object: *Object) -> *Object
{
    // Return O.[[Prototype]].
    retourne object.prototype
}

/* 10.1.5.1 OrdinaryGetOwnProperty ( O, P )
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ordinarygetownproperty */
ordinary_get_own_property :: fonc (object: *Object, property_key: PropertyKey) -> CompletionRecord
{
    propri√©t√© := object.trouve_propri√©t√©(property_key)

    // 1. If O does not have an own property with key P, return undefined.
    saufsi propri√©t√© {
        retourne normal_completion(js_undefined)
    }

    // 2. Let D be a newly created Property Descriptor with no fields.
    D: PropertyDescriptor

    // 3. Let X be O's own property whose key is P.
    X := m√©moire(propri√©t√©)

    // 4. If X is a data property, then
    si is_data_propery(X) {
        // a. Set D.[[Value]] to the value of X's [[Value]] attribute.
        D.value = propri√©t√©.valeur

        // b. Set D.[[Writable]] to the value of X's [[Writable]] attribute.
        D.writable = propri√©t√©.drapeaux.WRITABLE == vrai
    }
    // 5. Else,
    sinon {
        // a. Assert: X is an accessor property.
        assert(is_accessor_propery(X))
        panique("accessor property non-impl√©ment√©")

        // b. Set D.[[Get]] to the value of X's [[Get]] attribute.
        // c. Set D.[[Set]] to the value of X's [[Set]] attribute.
    }

    // 6. Set D.[[Enumerable]] to the value of X's [[Enumerable]] attribute.
    D.enumerable = propri√©t√©.drapeaux.ENUMERABLE == vrai

    // 7. Set D.[[Configurable]] to the value of X's [[Configurable]] attribute.
    D.configurable = propri√©t√©.drapeaux.CONFIGURABLE == vrai

    // 8. Return D.
    retourne normal_completion(D)
}

/* 10.1.6 [[DefineOwnProperty]] ( P, Desc )
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ordinarydefineownproperty */
ordinary_define_own_property :: fonc (object: *Object, property_key: PropertyKey, desc: &PropertyDescriptor) -> CompletionRecord
{
    // √Ä FAIRE : standardise
    saufsi desc.value.poss√®de_valeur() {
        retourne normal_completion(Valeur(Boolean = faux))
    }

    valeur := desc.value.Quelque
    drapeaux: DrapeauxPropri√©t√©
    si desc.writable.poss√®de_valeur() {
        writable := desc.writable.Quelque
        si writable {
            drapeaux.WRITABLE = vrai
        }
    }
    si desc.configurable.poss√®de_valeur() {
        configurable := desc.configurable.Quelque
        si configurable {
            drapeaux.CONFIGURABLE = vrai
        }
    }
    si desc.enumerable.poss√®de_valeur() {
        enumerable := desc.enumerable.Quelque
        si enumerable {
            drapeaux.ENUMERABLE = vrai
        }
    }

    object.ajoute_propri√©t√©(property_key, valeur, drapeaux)
    retourne normal_completion(Valeur(Boolean = vrai))
}

/* 10.1.8.1 OrdinaryGet ( O, P, Receiver )
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver */
ordinary_get :: fonc (object: *Object, property_key: PropertyKey, receiver: Valeur) -> CompletionRecord
{
    // 1. Let desc be ? O.[[GetOwnProperty]](P).
    completion_desc := internal_get_own_property(object, property_key)
    saufsi completion_desc.est_normal() {
        retourne completion_desc
    }

    desc := completion_desc.valeur

    // 2. If desc is undefined, then
    si desc.est_undefined() {
        // a. Let parent be ? O.[[GetPrototypeOf]]().
        parent := internal_get_prototype_of(object)

        // b. If parent is null, return undefined.
        si parent == nul {
            retourne normal_completion(desc)
        }

        // c. Return ? parent.[[Get]](P, Receiver).
        retourne parent.internal_get(property_key, receiver)
    }

    // 3. If IsDataDescriptor(desc) is true, return desc.[[Value]].
    si is_data_descriptor(desc.P) {
        retourne normal_completion(desc.P.value.Quelque)
    }

    panique("accessor property non-impl√©ment√©")
    // 4. Assert: IsAccessorDescriptor(desc) is true.
    // 5. Let getter be desc.[[Get]].
    // 6. If getter is undefined, return undefined.
    // 7. Return ? Call(getter, Receiver).
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ObjetChaine
 * https://tc39.es/ecma262/multipage/text-processing.html#sec-string-objects
 * \{ */

#port√©e_fichier

table_virtuelle_objet_chaine := TableVirtuelleCellule(classe = ObjetChaine, sur_destruction = sur_destruction_objet)

#port√©e_export

ObjetChaine :: struct {
    empl objet: Object
    table = *table_virtuelle_objet_chaine

    chn: *PrimitiveChaine
}

cr√©e_chaine :: fonc (tas_de_m√©moire: *TasDeM√©moire, string_prototype: *StringPrototype, chn: *PrimitiveChaine) -> *ObjetChaine
{
    r√©sultat := tas_de_m√©moire.alloue(ObjetChaine)
    r√©sultat.prototype = string_prototype
    r√©sultat.chn = chn

    r√©sultat.ajoute_propri√©t√©(STR_length, Valeur(Number = chn.texte.donne_chaine_utf16().taille() comme r64), DrapeauxPropri√©t√©.z√©ro)
    r√©sultat.ajoute_propri√©t√©(STR_prototype, Valeur(Object = string_prototype), DrapeauxPropri√©t√©.z√©ro)

    retourne r√©sultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ObjectPrototype
 * https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-properties-of-the-object-prototype-object
 * \{ */

#port√©e_fichier

table_virtuelle_object_prototype := TableVirtuelleCellule(classe = ObjectPrototype, sur_destruction = sur_destruction_objet)

#port√©e_export

ObjectPrototype :: struct {
    empl objet: Object
    table = *table_virtuelle_object_prototype
}

cr√©e_object_prototype :: fonc (tas_de_m√©moire: *TasDeM√©moire) -> *ObjectPrototype
{
    r√©sultat := tas_de_m√©moire.alloue(ObjectPrototype)
    r√©sultat.ajoute_fonction_native(STR_hasOwnProperty, object_prototype_has_own_property)
    r√©sultat.ajoute_fonction_native(STR_toString, object_prototype_to_string)
    retourne r√©sultat
}

/* 20.1.3.2 Object.prototype.hasOwnProperty ( V )
 * https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.prototype.hasownproperty */ 
object_prototype_has_own_property :: fonc (object: *Object @inutilis√©e, interpr√©teuse: &Interpr√©teuse, this: Valeur, args: []Valeur) -> CompletionRecord
{
    si args.taille != 1 {
        retourne normal_completion(js_undefined)
    }

    // 1. Let P be ? ToPropertyKey(V).
    compl√©tion_nom := to_property_key(interpr√©teuse, args[0])
    saufsi compl√©tion_nom.est_normal() {
        retourne compl√©tion_nom
    }
    nom := compl√©tion_nom.valeur.V.String.texte

    // 2. Let O be ? ToObject(this value).
    compl√©tion_obj := vers_objet(interpr√©teuse.donne_realm(), this)
    saufsi compl√©tion_obj.est_normal() {
        retourne compl√©tion_obj
    }
    obj := compl√©tion_obj.valeur.V.donne_objet()

    // 3. Return ? HasOwnProperty(O, P).
    retourne has_own_property(obj, nom)
}

/* 20.1.3.6 Object.prototype.toString ( )
 * https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.prototype.tostring */
object_prototype_to_string :: fonc (object: *Object @inutilis√©e, interpr√©teuse: &Interpr√©teuse, this: Valeur, args: []Valeur @inutilis√©e) -> CompletionRecord
{
    // 1. If the this value is undefined, return "[object Undefined]".
    si this.est_undefined() {
        retourne cr√©e_string_value_completion(interpr√©teuse, "[object Undefined]")
    }

    // 2. If the this value is null, return "[object Null]".
    si this.est_nulle() {
        retourne cr√©e_string_value_completion(interpr√©teuse, "[object Null]")
    }

    // 3. Let O be ! ToObject(this value).
    O := vers_objet(interpr√©teuse.donne_realm(), this).valeur.V.donne_objet()

    // √Ä FAIRE : 4. Let isArray be ? IsArray(O).

    builtin_tag: chaine

    // 5. If isArray is true, let builtinTag be "Array".
    si O.donne_classe() == ObjetArray {
        builtin_tag = "Array"
    }
    // √Ä FAIRE : 6. Else if O has a [[ParameterMap]] internal slot, let builtinTag be "Arguments".
    // 7. Else if O has a [[Call]] internal method, let builtinTag be "Function".
    sinon si O.sur_call {
        builtin_tag = "Function"
    }
    // 8. Else if O has an [[ErrorData]] internal slot, let builtinTag be "Error".
    sinon si O.donne_classe() == Error || O.donne_classe() == ReferenceError || O.donne_classe() == TypeError {
        builtin_tag = "Error"
    }
    // √Ä FAIRE : 9. Else if O has a [[BooleanData]] internal slot, let builtinTag be "Boolean".
    // √Ä FAIRE : 10. Else if O has a [[NumberData]] internal slot, let builtinTag be "Number".
    // 11. Else if O has a [[StringData]] internal slot, let builtinTag be "String".
    sinon si O.donne_classe() == ObjetChaine {
        builtin_tag = "String"
    }
    // √Ä FAIRE : 12. Else if O has a [[DateValue]] internal slot, let builtinTag be "Date".
    // √Ä FAIRE : 13. Else if O has a [[RegExpMatcher]] internal slot, let builtinTag be "RegExp".
    // 14. Else, let builtinTag be "Object".
    sinon {
        builtin_tag = "Object"
    }

    // √Ä FAIRE : 15. Let tag be ? Get(O, %Symbol.toStringTag%).
    // 16. If tag is not a String, set tag to builtinTag.
    tag := builtin_tag

    // 17. Return the string-concatenation of "[object ", tag, and "]".
    r√©sultat := enchaine("[object ", tag, "]")
    diff√®re d√©loge(r√©sultat)
    retourne cr√©e_string_value_completion(interpr√©teuse, r√©sultat)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom StringPrototype
 * https://tc39.es/ecma262/multipage/text-processing.html#sec-properties-of-the-string-prototype-object
 * \{ */

#port√©e_fichier

table_virtuelle_string_prototype := TableVirtuelleCellule(classe = StringPrototype, sur_destruction = sur_destruction_objet)

#port√©e_export

StringPrototype :: struct {
    empl objet: Object
    table = *table_virtuelle_string_prototype

    string_data: *PrimitiveChaine
}

cr√©e_string_prototype :: fonc (tas_de_m√©moire: *TasDeM√©moire, prototype: *ObjectPrototype) -> *StringPrototype
{
    r√©sultat := tas_de_m√©moire.alloue(StringPrototype)
    r√©sultat.prototype = prototype
    r√©sultat.string_data = cr√©e_chaine(tas_de_m√©moire, cr√©e_chaine_utf16_unique(""))
    r√©sultat.ajoute_propri√©t√©(STR_length, Valeur(Number = 0.0), DrapeauxPropri√©t√©.z√©ro)

    retourne r√©sultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Fonction
 * \{ */

#port√©e_fichier

table_virtuelle_function := TableVirtuelleCellule(classe = Function, sur_destruction = sur_destruction_objet)

#port√©e_export

LEXICAL_THIS :: vrai
NON_LEXICAL_THIS :: faux

ThisMode :: √©num {
    GLOBAL
    LEXICAL
    STRICT
}

Function :: struct {
    empl objet: Object
    table = *table_virtuelle_function

    nom: ECMAString
    corps: *NoeudSyntaxique
    formal_parameters: [..]*NoeudSyntaxique

    environment: *Environment
    private_environment: *PrivateEnvironment
    this_mode: ThisMode
    strict := faux
    is_class_constructor := faux
}

cr√©e_fonction :: fonc (function_prototype: *FunctionPrototype, nom: ECMAString, corps: *NoeudSyntaxique) -> *Function
{
    tas_de_m√©moire := function_prototype.donne_tas_de_m√©moire()
    r√©sultat := tas_de_m√©moire.alloue(Function)
    r√©sultat.nom = nom
    r√©sultat.corps = corps
    r√©sultat.prototype = function_prototype
    r√©sultat.sur_call = sur_appel_fonction_instruite
    retourne r√©sultat
}

/* 10.2.3 OrdinaryFunctionCreate ( functionPrototype, sourceText, ParameterList, Body, thisMode, env, privateEnv )
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ordinaryfunctioncreate 
 * √Ä FAIRE : param√®tres et √©tapes manquants */
ordinary_function_create :: fonc (function_prototype: *FunctionPrototype, params: [..]*NoeudSyntaxique, corps: *NoeudSyntaxique, this_mode: bool, env: *Environment, private_env: *PrivateEnvironment) -> *Function
{
    tas_de_m√©moire := function_prototype.donne_tas_de_m√©moire()

    // 1. Let internalSlotsList be the internal slots listed in Table 30.
    // 2. Let F be OrdinaryObjectCreate(functionPrototype, internalSlotsList).
    F := tas_de_m√©moire.alloue(Function)
    F.prototype = function_prototype

    // 3. Set F.[[Call]] to the definition specified in 10.2.1.
    F.sur_call = sur_appel_fonction_instruite

    // 4. Set F.[[SourceText]] to sourceText.

    // 5. Set F.[[FormalParameters]] to ParameterList.
    F.formal_parameters = params

    // 6. Set F.[[ECMAScriptCode]] to Body.
    F.corps = corps

    // 7. Let Strict be IsStrict(Body).
    strict := is_strict(corps)

    // 8. Set F.[[Strict]] to Strict.
    F.strict = strict

    // 9. If thisMode is LEXICAL-THIS, set F.[[ThisMode]] to LEXICAL.
    si this_mode == LEXICAL_THIS {
        F.this_mode = ThisMode.LEXICAL
    }
    // 10. Else if Strict is true, set F.[[ThisMode]] to STRICT.
    sinon si strict {
        F.this_mode = ThisMode.STRICT
    }
    // 11. Else, set F.[[ThisMode]] to GLOBAL.
    sinon {
        F.this_mode = ThisMode.GLOBAL
    }

    // 12. Set F.[[IsClassConstructor]] to false.
    F.is_class_constructor = faux

    // 13. Set F.[[Environment]] to env.
    F.environment = env

    // 14. Set F.[[PrivateEnvironment]] to privateEnv.
    F.private_environment = private_env

    // 15. Set F.[[ScriptOrModule]] to GetActiveScriptOrModule().
    // 16. Set F.[[Realm]] to the current Realm Record.
    // 17. Set F.[[HomeObject]] to undefined.
    // 18. Set F.[[Fields]] to a new empty List.
    // 19. Set F.[[PrivateMethods]] to a new empty List.
    // 20. Set F.[[ClassFieldInitializerName]] to EMPTY.
    // 21. Let len be the ExpectedArgumentCount of ParameterList.

    // 22. Perform SetFunctionLength(F, len).
    // 23. Return F.
    retourne F
}

sur_appel_fonction_instruite :: fonc (object: *Object, interpr√©teuse: &Interpr√©teuse, this_value: Valeur @inutilis√©e, arguments: []Valeur @inutilis√©e) -> CompletionRecord
{
    assert(object.donne_classe() == Function)
    fonction := object comme *Function
    retourne interpr√©teuse.ex√©cute(fonction.corps, TypeScope.FUNCTION)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom 19.2.1 eval ( x )
 * \{ */

cr√©e_eval :: fonc (function_prototype: *FunctionPrototype) -> *Function
{
    r√©sultat := cr√©e_fonction(function_prototype, STR_eval, nul)
    r√©sultat.sur_call = eval_sur_call
    retourne r√©sultat
}

/* https://tc39.es/ecma262/multipage/global-object.html#sec-eval-x */
eval_sur_call :: fonc (object: *Object @inutilis√©e, interpr√©teuse: &Interpr√©teuse, this_value: Valeur @inutilis√©e, arguments: []Valeur) -> CompletionRecord
{
    si arguments.taille == 0 {
        retourne normal_completion(js_undefined)
    }

    retourne perform_eval(interpr√©teuse, arguments[0], faux, faux)
}

/* 19.2.1.1 PerformEval ( x, strictCaller, direct )
 * https://tc39.es/ecma262/multipage/global-object.html#sec-performeval */
perform_eval :: fonc (interpr√©teuse: &Interpr√©teuse, x: Valeur, strict_caller: bool, direct: bool) -> CompletionRecord
{
    // 1. Assert: If direct is false, then strictCaller is also false.
    assert(direct == vrai || (direct == faux && strict_caller == faux))

    // 2. If x is not a String, return x.
    saufsi x.est_chaine() {
        retourne normal_completion(x)
    }

    // 3. Let evalRealm be the current Realm Record.
    // 4. NOTE: In the case of a direct eval, evalRealm is the realm of both the caller of eval and of the eval function itself.
    eval_realm := interpr√©teuse.donne_realm()

    // √Ä FAIRE : 5. Perform ? HostEnsureCanCompileStrings(evalRealm, ¬´ ¬ª, x, direct).

    // 6. Let inFunction be false.
    // in_function := faux

    // 7. Let inMethod be false.
    // in_method := faux

    // 8. Let inDerivedConstructor be false.
    // in_derived_constructor := faux

    // 9. Let inClassFieldInitializer be false.
    // in_class_field_initializer := faux

    // 10. If direct is true, then
    si direct {
        // a. Let thisEnvRec be GetThisEnvironment().
        // b. If thisEnvRec is a Function Environment Record, then
            // i. Let F be thisEnvRec.[[FunctionObject]].
            // ii. Set inFunction to true.
            // iii. Set inMethod to thisEnvRec.HasSuperBinding().
            // iv. If F.[[ConstructorKind]] is DERIVED, set inDerivedConstructor to true.
            // v. Let classFieldInitializerName be F.[[ClassFieldInitializerName]].
            // vi. If classFieldInitializerName is not EMPTY, set inClassFieldInitializer to true.
        panique("direct eval non-impl√©ment√©")
    }

    // √Ä FAIRE : 11. Perform the following substeps in an implementation-defined order, possibly interleaving parsing and error detection:
    // √Ä FAIRE : a. Let script be ParseText(x, Script).
    // b. If script is a List of errors, throw a SyntaxError exception.
    script: *Script
    contenu := converti_vers_chaine(x.String.texte.donne_chaine_utf16())
    diff√®re d√©loge(contenu)

    discr parse_script(contenu, eval_realm) {
        Ok(s) {
            script = s
        }
        Erreur(e) {
            diff√®re d√©loge(e.message)
            retourne interpr√©teuse.lance_syntax_error(e.message)
        }
        sinon {
            chn := "Erreur inconnue"
            retourne interpr√©teuse.lance_syntax_error(chn)
        }
    }

    // √Ä FAIRE : c. If script Contains ScriptBody is false, return undefined.
    // √Ä FAIRE : d. Let body be the ScriptBody of script.
    body := script.ecma_script_code

    // √Ä FAIRE : e. If inFunction is false and body Contains NewTarget, throw a SyntaxError exception.
    // √Ä FAIRE : f. If inMethod is false and body Contains SuperProperty, throw a SyntaxError exception.
    // √Ä FAIRE : g. If inDerivedConstructor is false and body Contains SuperCall, throw a SyntaxError exception.
    // √Ä FAIRE : h. If inClassFieldInitializer is true and ContainsArguments of body is true, throw a SyntaxError exception.

    // 12. If strictCaller is true, let strictEval be true.
    strict_eval := si strict_caller {
        vrai
    }
    // 13. Else, let strictEval be ScriptIsStrict of script.
    sinon {
        // √Ä FAIRE : ScriptIsStrict
        faux
    }

    // 14. Let runningContext be the running execution context.
    // 15. NOTE: If direct is true, runningContext will be the execution context that performed the direct eval. If direct is false, runningContext will be the execution context for the invocation of the eval function.
    running_context := interpr√©teuse.donne_running_execution_context()

    lex_env: *Environment
    var_env: *Environment
    private_env: *PrivateEnvironment

    // 16. If direct is true, then
    si direct {
        // a. Let lexEnv be NewDeclarativeEnvironment(runningContext's LexicalEnvironment).
        lex_env = new_declarative_environment(interpr√©teuse.donne_tas_de_m√©moire(), running_context.lexical_environment)

        // b. Let varEnv be runningContext's VariableEnvironment.
        var_env = running_context.variable_environment
    
        // c. Let privateEnv be runningContext's PrivateEnvironment.
        private_env = running_context.private_environment
    }
    // 17. Else,
    sinon {
        // a. Let lexEnv be NewDeclarativeEnvironment(evalRealm.[[GlobalEnv]]).
        lex_env = new_declarative_environment(interpr√©teuse.donne_tas_de_m√©moire(), eval_realm.global_environment)

        // b. Let varEnv be evalRealm.[[GlobalEnv]].
        var_env = eval_realm.global_environment

        // c. Let privateEnv be null.
        private_env = nul
    }

    // 18. If strictEval is true, set varEnv to lexEnv.
    si strict_eval {
        var_env = lex_env
    }

    // 19. If runningContext is not already suspended, suspend runningContext.
    mv := interpr√©teuse.mv
    mv.suspend_running_execution_context()

    // 20. Let evalContext be a new ECMAScript code execution context.
    eval_context := cr√©e_execution_context(interpr√©teuse.donne_tas_de_m√©moire())

    // 21. Set evalContext's Function to null.
    eval_context.function = nul

    // 22. Set evalContext's Realm to evalRealm.
    eval_context.realm = eval_realm

    // 23. Set evalContext's ScriptOrModule to runningContext's ScriptOrModule.
    eval_context.script_or_module = running_context.script_or_module

    // 24. Set evalContext's VariableEnvironment to varEnv.
    eval_context.variable_environment = var_env

    // 25. Set evalContext's LexicalEnvironment to lexEnv.
    eval_context.lexical_environment = lex_env

    // 26. Set evalContext's PrivateEnvironment to privateEnv.
    eval_context.private_environment = private_env

    // 27. Push evalContext onto the execution context stack; evalContext is now the running execution context.
    mv.empile_execution_context(eval_context)

    // √Ä FAIRE : 28. Let result be Completion(EvalDeclarationInstantiation(body, varEnv, lexEnv, privateEnv, strictEval)).
    result := normal_completion(js_undefined)

    // 29. If result is a normal completion, then
    si result.est_normal() {
        // a. Set result to Completion(Evaluation of body).
        result = interpr√©teuse.ex√©cute(body)
    }

    // 30. If result is a normal completion and result.[[Value]] is EMPTY, then
        // a. Set result to NormalCompletion(undefined).

    // 31. Suspend evalContext and remove it from the execution context stack.
    mv.suspend_running_execution_context()
    mv.d√©pile_execution_context()

    // √Ä FAIRE : 32. Resume the context that is now on the top of the execution context stack as the running execution context.

    // 33. Return ? result.
    retourne result
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom FunctionPrototype
 * https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-properties-of-the-function-prototype-object
 * \{ */

#port√©e_fichier

table_virtuelle_function_prototype := TableVirtuelleCellule(classe = FunctionPrototype, sur_destruction = sur_destruction_objet)

#port√©e_export

/* √Ä FAIRE : is builtin function object */
FunctionPrototype :: struct {
    empl function: Function
    table = *table_virtuelle_function_prototype
}

cr√©e_function_prototype :: fonc (tas_de_m√©moire: *TasDeM√©moire, prototype: *ObjectPrototype) -> *FunctionPrototype
{
    r√©sultat := tas_de_m√©moire.alloue(FunctionPrototype)
    r√©sultat.prototype = prototype
    r√©sultat.sur_call = fonction_prototype_sur_call
    r√©sultat.ajoute_propri√©t√©(STR_length, Valeur(Number = 0.0), DrapeauxPropri√©t√©.z√©ro)
    r√©sultat.ajoute_propri√©t√©(STR_name, Valeur(String = cr√©e_chaine(tas_de_m√©moire, cr√©e_chaine_utf16_unique(""))), DrapeauxPropri√©t√©.z√©ro)
    retourne r√©sultat
}

fonction_prototype_sur_call :: fonc (object: *Object @inutilis√©e, interpr√©teuse: &Interpr√©teuse @inutilis√©e, this_value: Valeur @inutilis√©e, arguments: []Valeur @inutilis√©e) -> CompletionRecord
{
    retourne normal_completion(js_undefined)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom FunctionNative
 * \{ */

#port√©e_fichier

table_virtuelle_function_native := TableVirtuelleCellule(classe = FunctionNative, sur_destruction = sur_destruction_objet)

#port√©e_export

FunctionNative :: struct {
    empl function: Function
    table = *table_virtuelle_function_native
}

cr√©e_fonction_native :: fonc (tas_de_m√©moire: *TasDeM√©moire, nom: ECMAString, sur_appel: TypeFonctionObjectCall, length: z64) -> *FunctionNative
{
    r√©sultat := tas_de_m√©moire.alloue(FunctionNative)
    r√©sultat.nom = nom
    r√©sultat.sur_call = sur_appel
    r√©sultat.ajoute_propri√©t√©(STR_length, Valeur(Number = length comme r64), DrapeauxPropri√©t√©.z√©ro)
    retourne r√©sultat
}

ajoute_fonction_native :: fonc (objet: *Object, nom: ECMAString, sur_appel: TypeFonctionObjectCall, length := 0)
{
    tas_de_m√©moire := objet.donne_tas_de_m√©moire()
    fonction := cr√©e_fonction_native(tas_de_m√©moire, nom, sur_appel, length)
    ajoute_propri√©t√©(objet, nom, Valeur(Function = fonction), DrapeauxPropri√©t√©.z√©ro)
}

ajoute_fonction_native :: fonc (objet: *Object, nom: chaine, sur_appel: TypeFonctionObjectCall, length := 0)
{
    ajoute_fonction_native(objet, cr√©e_chaine_utf16_unique(nom), sur_appel, length)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom PrimitiveChaine
 * \{ */

#port√©e_fichier

table_virtuelle_primitive_chaine := TableVirtuelleCellule(classe = PrimitiveChaine)

#port√©e_export

PrimitiveChaine :: struct {
    empl cellule: Cellule
    table = *table_virtuelle_primitive_chaine

    texte: ECMAString
    objet: *Object
}

cr√©e_chaine :: fonc (tas_de_m√©moire: *TasDeM√©moire, texte: ECMAString) -> *PrimitiveChaine
{
    r√©sultat := tas_de_m√©moire.alloue(PrimitiveChaine)
    r√©sultat.texte = texte
    retourne r√©sultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ObjetArray
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-array-exotic-objects
 * \{ */

#port√©e_fichier

table_virtuelle_objet_array := TableVirtuelleCellule(classe = ObjetArray, sur_destruction = sur_destruction_objet)

#port√©e_export

ObjetArray :: struct {
    empl objet: Object
    table = *table_virtuelle_objet_array
}

cr√©e_array :: fonc (tas_de_m√©moire: *TasDeM√©moire, array_prototype: *ArrayPrototype, nombre_√©l√©ments: z64) -> *ObjetArray
{
    r√©sultat := tas_de_m√©moire.alloue(ObjetArray)
    r√©sultat.prototype = array_prototype

    r√©sultat.ajoute_propri√©t√©(STR_length, Valeur(Number = nombre_√©l√©ments comme r64), DrapeauxPropri√©t√©.z√©ro)

    retourne r√©sultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ArrayConstructor
 * https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array-constructor
 * \{ */

#port√©e_fichier

table_virtuelle_array_constructor := TableVirtuelleCellule(classe = ArrayConstructor, sur_destruction = sur_destruction_objet)

#port√©e_export

ArrayConstructor :: struct {
    empl objet: Object
    table = *table_virtuelle_objet_array
}

/* √Ä FAIRE : standardise */
cr√©e_array_constructor :: fonc (tas_de_m√©moire: *TasDeM√©moire, array_prototype: *ArrayPrototype) -> *ArrayConstructor
{
    r√©sultat := tas_de_m√©moire.alloue(ArrayConstructor)
    /* https://tc39.es/ecma262/multipage/indexed-collections.html#sec-properties-of-the-array-constructor */
    r√©sultat.ajoute_propri√©t√©(STR_length, Valeur(Number = 1.0), DrapeauxPropri√©t√©.z√©ro)
    /* https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype */
    r√©sultat.ajoute_propri√©t√©(STR_prototype, Valeur(Object = array_prototype), DrapeauxPropri√©t√©.z√©ro)
    r√©sultat.sur_call = array_constructor_call

    /* https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.constructor */
    array_prototype.ajoute_propri√©t√©(STR_constructor, Valeur(Object = r√©sultat), DrapeauxPropri√©t√©.z√©ro)

    retourne r√©sultat
}

/* √Ä FAIRE : standardise
 * https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array */
array_constructor_call :: fonc (object: *Object @inutilis√©e, interpr√©teuse: &Interpr√©teuse, this_value: Valeur @inutilis√©e, arguments: []Valeur) -> CompletionRecord
{
    realm := interpr√©teuse.donne_realm()

    r√©sultat := cr√©e_array(realm.donne_tas_de_m√©moire(), realm.intrinsics.array_prototype, 0)

    si arguments.taille != 0 {
        completion := vers_nombre(interpr√©teuse, arguments[0])
        saufsi completion.est_normal() {
            retourne completion
        }
        len := completion.valeur.V.Number

        completion = set(r√©sultat, STR_length, Valeur(Number = len), vrai)
        saufsi completion.est_normal() {
            retourne completion
        }
    }

    retourne normal_completion(Valeur(Object = r√©sultat))
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ArrayPrototype
 * https://tc39.es/ecma262/multipage/indexed-collections.html#sec-properties-of-the-array-prototype-object
 * \{ */

#port√©e_fichier

table_virtuelle_array_prototype := TableVirtuelleCellule(classe = ArrayPrototype, sur_destruction = sur_destruction_objet)

#port√©e_export

ArrayPrototype :: struct {
    empl objet: Object
    table = *table_virtuelle_array_prototype
}

cr√©e_array_prototype :: fonc (tas_de_m√©moire: *TasDeM√©moire, prototype: *ObjectPrototype) -> *ArrayPrototype
{
    r√©sultat := tas_de_m√©moire.alloue(ArrayPrototype)
    r√©sultat.prototype = prototype

    r√©sultat.ajoute_propri√©t√©(STR_length, Valeur(Number = 0.0), Writable)
    r√©sultat.ajoute_fonction_native(STR_join, array_prototype_join)
    r√©sultat.ajoute_fonction_native(STR_push, array_prototype_push, 1)
    r√©sultat.ajoute_fonction_native(STR_toString, array_prototype_to_string)

    retourne r√©sultat
}

/* 23.1.3.18 Array.prototype.join ( separator )
 * https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.join */
array_prototype_join :: fonc (object: *Object @inutilis√©e, interpr√©teuse: &Interpr√©teuse, this_value: Valeur, arguments: []Valeur) -> CompletionRecord
{
    // 1. Let O be ? ToObject(this value).
    completion := vers_objet(interpr√©teuse.donne_realm(), this_value)
    saufsi completion.est_normal() {
        retourne completion
    }
    O := completion.valeur.V.donne_objet()

    // 2. Let len be ? LengthOfArrayLike(O).
    completion = length_of_array_like(O)
    saufsi completion.est_normal() {
        retourne completion
    }
    len := completion.valeur.V.Number

    // 3. If separator is undefined, let sep be ",".
    sep: ECMAString
    si arguments.taille == 0 {
        sep = cr√©e_chaine_utf16_unique(",")
    }
    // 4. Else, let sep be ? ToString(separator).
    sinon {
        completion = vers_chaine(interpr√©teuse, arguments[0])
        saufsi completion.est_normal() {
            retourne completion
        }
        sep = completion.valeur.V.String.texte
    }

    // 5. Let R be the empty String.
    R: EnchaineuseUTF16
    initialise_enchaineuse(R)
    diff√®re d√©truit_tampons(R)

    // 6. Let k be 0.
    k := 0.0

    // 7. Repeat, while k < len,
    tantque k < len {
        // a. If k > 0, set R to the string-concatenation of R and sep.
        si k > 0.0 {
            ajoute(R, sep.donne_chaine_utf16())
        }

        // b. Let element be ? Get(O, ! ToString(ùîΩ(k))).
        nom_propri√©t√© := vers_chaine(interpr√©teuse, Valeur(Number = k)).valeur.V.String.texte
        completion = get(O, nom_propri√©t√©)
        saufsi completion.est_normal() {
            retourne completion
        }
        element := completion.valeur.V

        // c. If element is neither undefined nor null, then
        saufsi element.est_nulle() || element.est_undefined() {
            // i. Let S be ? ToString(element).
            completion = vers_chaine(interpr√©teuse, element)
            saufsi completion.est_normal() {
                retourne completion
            }
            S := completion.valeur.V.String.texte

            // ii. Set R to the string-concatenation of R and S.
            ajoute(R, S.donne_chaine_utf16())
        }

        // d. Set k to k + 1.
        k += 1.0
    }

    // 8. Return R.
    r√©sultat := chaine_depuis_enchaineuse(R)
    valeur_r√©sultat := cr√©e_chaine(interpr√©teuse.donne_tas_de_m√©moire(), cr√©e_chaine_utf16_unique(r√©sultat))
    retourne normal_completion(Valeur(String = valeur_r√©sultat))
}

/* 23.1.3.23 Array.prototype.push ( ...items )
 * https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.push */
array_prototype_push :: fonc (object: *Object @inutilis√©e, interpr√©teuse: &Interpr√©teuse, this_value: Valeur, arguments: []Valeur) -> CompletionRecord
{
    // 1. Let O be ? ToObject(this value).
    completion := vers_objet(interpr√©teuse.donne_realm(), this_value)
    saufsi completion.est_normal() {
        retourne completion
    }
    O := completion.valeur.V.donne_objet()

    // 2. Let len be ? LengthOfArrayLike(O).
    completion = length_of_array_like(O)
    saufsi completion.est_normal() {
        retourne completion
    }
    len := completion.valeur.V.Number

    // 3. Let argCount be the number of elements in items.
    // arg_count := arguments.taille

    // √Ä FAIRE : 4. If len + argCount > 2**53 - 1, throw a TypeError exception.

    // 5. For each element E of items, do
    pour arguments {
        // a. Perform ? Set(O, ! ToString(ùîΩ(len)), E, true).
        nom_propri√©t√© := vers_chaine(interpr√©teuse, Valeur(Number = len)).valeur.V.String.texte
        completion = set(O, nom_propri√©t√©, it, vrai)
        saufsi completion.est_normal() {
            retourne completion
        }

        // b. Set len to len + 1.
        len += 1.0
    }

    // 6. Perform ? Set(O, "length", ùîΩ(len), true).
    completion = set(O, STR_length, Valeur(Number = len), vrai)
    saufsi completion.est_normal() {
        retourne completion
    }

    // 7. Return ùîΩ(len).
    retourne normal_completion(Valeur(Number = len))
}

/* 23.1.3.36 Array.prototype.toString ( )
 * https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.tostring */
array_prototype_to_string :: fonc (object: *Object @inutilis√©e, interpr√©teuse: &Interpr√©teuse, this_value: Valeur, arguments: []Valeur @inutilis√©e) -> CompletionRecord
{
    // 1. Let array be ? ToObject(this value).
    completion := vers_objet(interpr√©teuse.donne_realm(), this_value)
    saufsi completion.est_normal() {
        retourne completion
    }
    array := completion.valeur.V.donne_objet()

    // 2. Let func be ? Get(array, "join").
    completion = get(array, STR_join)
    saufsi completion.est_normal() {
        retourne completion
    }
    func := completion.valeur.V

    // 3. If IsCallable(func) is false, set func to the intrinsic function %Object.prototype.toString%.
    saufsi is_callable(func) {
        panique("%Object.prototype.toString% non-impl√©ment√©")
    }

    // 4. Return ? Call(func, array).
    retourne call(interpr√©teuse, func, Valeur(Object = array))
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Error
 * https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-error-objects
 * \{ */

#port√©e_fichier

table_virtuelle_error := TableVirtuelleCellule(classe = Error, sur_destruction = sur_destruction_objet)

#port√©e_export

Error :: struct {
    empl objet: Object
    table = *table_virtuelle_error
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ErrorPrototype
 * https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-properties-of-the-error-prototype-object
 * \{ */

#port√©e_fichier

table_virtuelle_error_prototype := TableVirtuelleCellule(classe = ErrorPrototype, sur_destruction = sur_destruction_objet)

#port√©e_export

ErrorPrototype :: struct {
    empl objet: Object
    table = *table_virtuelle_error_prototype
}

cr√©e_error_prototype :: fonc (tas_de_m√©moire: *TasDeM√©moire, prototype: *ObjectPrototype) -> *ErrorPrototype
{
    r√©sultat := tas_de_m√©moire.alloue(ErrorPrototype)
    r√©sultat.prototype = prototype
    retourne r√©sultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ReferenceError
 * https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-native-error-types-used-in-this-standard-referenceerror
 * \{ */

#port√©e_fichier

table_virtuelle_reference_error := TableVirtuelleCellule(classe = ReferenceError, sur_destruction = sur_destruction_objet)

#port√©e_export

ReferenceError :: struct {
    empl error: Error
    table = *table_virtuelle_reference_error

    message: *PrimitiveChaine
}

cr√©e_reference_error :: fonc (tas_de_m√©moire: *TasDeM√©moire, prototype: *ReferenceErrorPrototype, message: chaine) -> *ReferenceError
{
    r√©sultat := tas_de_m√©moire.alloue(ReferenceError)
    r√©sultat.prototype = prototype
    r√©sultat.message = cr√©e_chaine(tas_de_m√©moire, cr√©e_chaine_utf16_unique(message))
    retourne r√©sultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ReferenceErrorPrototype
 * https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-properties-of-the-nativeerror-prototype-objects
 * \{ */

#port√©e_fichier

table_virtuelle_reference_error_prototype := TableVirtuelleCellule(classe = ReferenceErrorPrototype, sur_destruction = sur_destruction_objet)

#port√©e_export

ReferenceErrorPrototype :: struct {
    empl objet: Object
    table = *table_virtuelle_reference_error_prototype
}

cr√©e_reference_error_prototype :: fonc (tas_de_m√©moire: *TasDeM√©moire, prototype: *ErrorPrototype) -> *ReferenceErrorPrototype
{
    r√©sultat := tas_de_m√©moire.alloue(ReferenceErrorPrototype)
    r√©sultat.prototype = prototype
    retourne r√©sultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom SyntaxError
 * https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-native-error-types-used-in-this-standard-syntaxerror
 * \{ */

#port√©e_fichier

table_virtuelle_syntax_error := TableVirtuelleCellule(classe = SyntaxError, sur_destruction = sur_destruction_objet)

#port√©e_export

SyntaxError :: struct {
    empl error: Error
    table = *table_virtuelle_syntax_error

    message: *PrimitiveChaine
}

cr√©e_syntax_error :: fonc (tas_de_m√©moire: *TasDeM√©moire, prototype: *SyntaxErrorPrototype, message: chaine) -> *SyntaxError
{
    r√©sultat := tas_de_m√©moire.alloue(SyntaxError)
    r√©sultat.prototype = prototype
    r√©sultat.message = cr√©e_chaine(tas_de_m√©moire, cr√©e_chaine_utf16_unique(message))
    retourne r√©sultat
}

lance_syntax_error :: fonc (interpr√©teuse: &Interpr√©teuse, message: chaine) -> CompletionRecord
{
    retourne lance_syntax_error(interpr√©teuse.donne_realm(), message)
}

lance_syntax_error :: fonc (realm: *Realm, message: chaine) -> CompletionRecord
{
    exception := cr√©e_syntax_error(realm.donne_tas_de_m√©moire(), realm.intrinsics.syntax_error_prototype, message)
    retourne throw_completion(exception)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom SyntaxErrorPrototype
 * https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-properties-of-the-nativeerror-prototype-objects
 * \{ */

#port√©e_fichier

table_virtuelle_syntax_error_prototype := TableVirtuelleCellule(classe = SyntaxErrorPrototype, sur_destruction = sur_destruction_objet)

#port√©e_export

SyntaxErrorPrototype :: struct {
    empl objet: Object
    table = *table_virtuelle_syntax_error_prototype
}

cr√©e_syntax_error_prototype :: fonc (tas_de_m√©moire: *TasDeM√©moire, prototype: *ErrorPrototype) -> *SyntaxErrorPrototype
{
    r√©sultat := tas_de_m√©moire.alloue(SyntaxErrorPrototype)
    r√©sultat.prototype = prototype
    retourne r√©sultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom TypeError
 * https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-native-error-types-used-in-this-standard-typeerror
 * \{ */

#port√©e_fichier

table_virtuelle_type_error := TableVirtuelleCellule(classe = TypeError, sur_destruction = sur_destruction_objet)

#port√©e_export

TypeError :: struct {
    empl error: Error
    table = *table_virtuelle_type_error

    message: *PrimitiveChaine
}

cr√©e_type_error :: fonc (tas_de_m√©moire: *TasDeM√©moire, prototype: *TypeErrorPrototype, message: chaine) -> *TypeError
{
    r√©sultat := tas_de_m√©moire.alloue(TypeError)
    r√©sultat.prototype = prototype
    r√©sultat.message = cr√©e_chaine(tas_de_m√©moire, cr√©e_chaine_utf16_unique(message))
    retourne r√©sultat
}

lance_type_error :: fonc (interpr√©teuse: &Interpr√©teuse, message: chaine) -> CompletionRecord
{
    retourne lance_type_error(interpr√©teuse.donne_realm(), message)
}

lance_type_error :: fonc (realm: *Realm, message: chaine) -> CompletionRecord
{
    exception := cr√©e_type_error(realm.donne_tas_de_m√©moire(), realm.intrinsics.type_error_prototype, message)
    retourne throw_completion(exception)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom TypeErrorPrototype
 * https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-properties-of-the-nativeerror-prototype-objects
 * \{ */

#port√©e_fichier

table_virtuelle_type_error_prototype := TableVirtuelleCellule(classe = TypeErrorPrototype, sur_destruction = sur_destruction_objet)

#port√©e_export

TypeErrorPrototype :: struct {
    empl objet: Object
    table = *table_virtuelle_type_error_prototype
}

cr√©e_type_error_prototype :: fonc (tas_de_m√©moire: *TasDeM√©moire, prototype: *ErrorPrototype) -> *TypeErrorPrototype
{
    r√©sultat := tas_de_m√©moire.alloue(TypeErrorPrototype)
    r√©sultat.prototype = prototype
    retourne r√©sultat
}

/** \} */
