importe BoiteFlexible
importe CréationFenêtre
importe Chaine
importe Couleur
importe Fondation
HTML :: importe HTML
importe JavaScript
importe PeintureInterface
importe Périphériques
importe SysFichier
importe Temps
importe Typographie

/* ------------------------------------------------------------------------- */
/** \nom Fonction principale.
 * \{ */

principale :: fonc ()
{
    mémoire_entrée := mémoire_utilisée()
    diffère imprime("mémoire_utilisée %\n", mémoire_utilisée() - mémoire_entrée)

    application: Application
    _, contenu := contenu_fichier_texte("/tmp/test.js")
    application.texte = contenu

    application.fonte = donne_fonte_mono_défaut(14.0)

    fenêtre := crée_fenêtre(800, 600, "ECMAScript", vrai)

    doit_fermer := faux

    tantque !doit_fermer {
        évènements := ajourne_évènements_fenêtre(fenêtre)

        largeur, hauteur := donne_taille_fenêtre(fenêtre)

        pour évènements {
            si it.type == TypeÉvènement.Fermeture {
                doit_fermer = vrai
                arrête
            }

            si it.touche_pressée {
                si it.modificateurs == ModificateurClavier.CONTROL && it.touche == ToucheClavier.S && !it.est_répétée {
                    sauvegarde_texte(*application)
                }
            }

            gère_évènement(*application.emboiteuse, it)
        }

        dessine_fenêtre(*application, largeur, hauteur)

        permute_tampons_fenêtre(fenêtre)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Application.
 * \{ */

Application :: struct {
    texte: chaine
    sortie: chaine
    sortie_console: chaine

    emboiteuse: Emboiteuse
    fonte: *Fonte
    peintre: *Peintre

    lignes: [..]chaine
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Interface
 * \{ */

GRIS_157 := CouleurRVBA(0.157, 0.157, 0.157, 1.0)
GRIS_325 := CouleurRVBA(0.325, 0.325, 0.325, 1.0)

TEXTE_ACTIF := CouleurRVBA(0.900, 0.900, 0.900, 1.0)
TEXTE_INACTIF := CouleurRVBA(0.660, 0.660, 0.660, 1.0)

dessine_fenêtre :: fonc (empl application: *Application, largeur: z32, hauteur: z32)
{
    marque := donne_marque_stockage_temporaire()
    diffère définis_marque_stockage_temporaire(marque)

    taille_canevas := Taille(largeur = Largeur(largeur), hauteur = Hauteur(hauteur))
    saufsi application.peintre {
        peintre = crée_peintre_igumi(taille_canevas)
    }

    peintre.définis_taille_canevas(taille_canevas)
    peintre.efface_cible_rendu(CouleurRVBA(1.0, 1.0, 1.0, 1.0))

    commandes := crée_interface(application, largeur, hauteur)
    dessine_commandes(peintre, *commandes)
}

crée_interface :: fonc (application: *Application, largeur: z32, hauteur: z32) -> CommandesDeRendu
{
    emboiteuse := *application.emboiteuse

    commence_disposition(emboiteuse, largeur, hauteur)

    dispose_rectangle()
    {
        définis_cotation(Cotation(CROISSANTE(), CROISSANTE()))
        définis_arrière_plan(GRIS_325)
        définis_rembourrage(RembourrageUniforme(8))
        définis_séparation_enfant(8)

        /* Texte. */
        dispose_rectangle()
        {
            définis_cotation(Cotation(CROISSANTE(), CROISSANTE()))
            définis_arrière_plan(GRIS_157)
            définis_direction(Direction.Verticale)
            définis_rembourrage(RembourrageUniforme(8))

            dispose_texte(application, application.texte)
        }
        termine_rectangle()

        dispose_rectangle()
        {
            définis_cotation(Cotation(CROISSANTE(), CROISSANTE()))
            définis_arrière_plan(GRIS_325)
            définis_séparation_enfant(8)
            définis_direction(Direction.Verticale)

            dispose_rectangle()
            {
                définis_cotation(Cotation(CROISSANTE(), CROISSANTE()))
                définis_arrière_plan(GRIS_157)
                définis_direction(Direction.Verticale)
                définis_rembourrage(RembourrageUniforme(8))

                dispose_texte(application, application.sortie)
            }
            termine_rectangle()

            dispose_rectangle()
            {
                définis_cotation(Cotation(CROISSANTE(), CROISSANTE()))
                définis_arrière_plan(GRIS_157)
                définis_direction(Direction.Verticale)
                définis_rembourrage(RembourrageUniforme(8))

                dispose_texte(application, application.sortie_console)
            }
            termine_rectangle()
        }
        termine_rectangle()
    }
    termine_rectangle()

    retourne termine_disposition(emboiteuse)
}

dispose_texte :: fonc (application: *Application, texte: chaine)
{
    divise(texte, '\n', *application.lignes)

    pour application.lignes {
        dispose_texte(it, ConfigurationTexte(application.fonte, TEXTE_ACTIF))
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ObjetHTML
 * \{ */

ObjetHTML :: struct {
    empl enveloppable: Enveloppable
    sur_création_enveloppe = objet_html_sur_création_enveloppe
}

objet_html_sur_création_enveloppe :: fonc (base: *Enveloppable @inutilisée, enveloppe: *Enveloppe)
{
    fonction_native_ouvre_document :: fonc (empl params: *ParamètresObjectCall) -> Valeur
    {
        si arguments.taille == 0 {
            retourne lance_type_error(interpréteuse, "ouvre_document requiers 1 argument")
        }

        saufsi params.donne_argument(0).est_chaine() {
            retourne lance_type_error(interpréteuse, "argument n'est pas une chaine")
        }

        valeur_arg := params.donne_argument(0).String.texte
        valeur_arg_utf16 := valeur_arg.donne_chaine_utf16()
        chemin := imprime_chaine("%", valeur_arg_utf16)
        diffère déloge(chemin)

        _, contenu := contenu_fichier_texte(chemin)
        diffère déloge(contenu)

        parsat := HTML.parse_document(interpréteuse.donne_realm(), contenu)
        diffère HTML.détruit(parsat)

        retourne parsat.document
    }

    enveloppe.ajoute_fonction_native("ouvre_document", fonction_native_ouvre_document)
}

/** \} */

ConfigurationRealmTest :: struct {
    empl base: ConfigurationRealm

    application: *Application
    html: ObjetHTML
}

crée_propriétés_hôte_objet_global :: fonc (base: *ConfigurationRealm, global: *Object)
{
    configuration := base comme *ConfigurationRealmTest

    FluxSortieConsoleQt :: struct {
        empl base: FluxSortieConsole

        application: *Application
    }

    flux_sortie_sur_destruction :: fonc (base: *FluxSortieConsole)
    {
        flux := base comme *FluxSortieConsoleQt
        déloge(flux)
    }

    flux_sortie_sur_log :: fonc (base: *FluxSortieConsole, texte: chaine)
    {
        flux := base comme *FluxSortieConsoleQt
        application := flux.application
        application.sortie_console = copie_chaine(texte)
    }

    flux_sortie_sur_efface :: fonc (base: *FluxSortieConsole)
    {
        flux := base comme *FluxSortieConsoleQt
        application := flux.application
        déloge(application.sortie_console)
    }

    flux := loge(FluxSortieConsoleQt)
    flux.application = configuration.application
    flux.sur_destruction = flux_sortie_sur_destruction
    flux.sur_log = flux_sortie_sur_log
    flux.sur_efface = flux_sortie_sur_efface

    console := crée_console(global.donne_tas_de_mémoire(), flux, nul)

    global.ajoute_fonction_native("rm", fonction_native_éboue)
    global.ajoute_propriété(crée_chaine_utf16_unique("console"), Valeur(Object = console), Enumerable | Configurable | Writable)
    global.ajoute_objet_natif("html", *configuration.html)
}

sauvegarde_texte :: fonc (application: *Application)
{
    déloge_si_logée(application.sortie)

    _ := écris_fichier_entier("/tmp/test.js", application.texte)

    début := maintenant_précis()

    mv: MachineVirtuelle
    diffère détruit_données_mv(*mv)
    initialise_mv(nul, *mv)

    diffère éboue(donne_tas_de_mémoire(*mv))

    rappels_hôte: ConfigurationRealmTest
    rappels_hôte.crée_host_instrinsics = HTML.initialise_host_intrinsics
    rappels_hôte.application = application
    rappels_hôte.crée_propriétés_hôte_objet_global = crée_propriétés_hôte_objet_global

    realm := initialise_host_defined_realm(*mv, *rappels_hôte)

    script: *Script
    discr parse_script(application.texte, realm) {
        Ok(s) {
            script = s
        }
        Erreur(e) {
            application.sortie = imprime_chaine("%", Valeur(Object = e))
            retourne
        }
        sinon {
            application.sortie = "Erreur inconnue"
            retourne
        }
    }

    résultat := script_evaluation(script)

    application.sortie = imprime_chaine("%\n\nTemps d'exécution : % ms\n", get_value(realm, résultat.valeur), début.temps_écoulé_millisecondes())
}
