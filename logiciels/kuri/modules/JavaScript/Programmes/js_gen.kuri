/* Ce programme g√©n√®re du code Kuri depuis la sp√©cification d'une fonction
 * du standard ECMAScript. */

importe Chaine
importe Compilatrice
importe Fondation
importe SysFichier

principale :: fonc ()
{
    contenu := contenu_fichier_texte(CheminFichier("js_gen.txt"))
    lignes := divise(contenu, '\n')

    parseuse: Parseuse
    parseuse.bloc = cr√©e_bloc(*parseuse)

    pour lignes {
        si it.commence_par("// ") {
            continue
        }

        si it.taille > 0 && (it[it.taille - 1] == '.' || it[it.taille - 1] == ',') {
            it.taille -= 1
        }

        // imprime("\n    // %\n", it)
        parse_ligne(*parseuse, it)
    }

    g√©n√©ratrice: G√©n√©ratriceCode
    imprime_instruction(*g√©n√©ratrice, parseuse.bloc)
}

parse_ligne :: fonc (parseuse: *Parseuse, ligne: chaine)
{
    initialise_pour_ligne(parseuse, ligne)

    indentation := compte_indentation(parseuse)
    ligne.pointeur += indentation
    ligne.taille -= indentation

    si parseuse.bloc.indentation == -1 {
        parseuse.bloc.indentation = indentation comme z32
    }
    sinon si indentation < parseuse.bloc.indentation {
        tantque indentation < parseuse.bloc.indentation {
            parseuse.bloc = parseuse.bloc.bloc_parent
        }
    }

    assert(parseuse.bloc.indentation == indentation)

    lex√®me := donne_lex√®me_suivant(parseuse)
    _ := consomme_caract√®re(parseuse, '.')

    lex√®me = donne_lex√®me_suivant(parseuse)

    si lex√®me == "Let" {
        instruction := parseuse.cr√©e_instruction(ligne, InstructionLet)
        instruction.variable = donne_lex√®me_suivant(parseuse)

        lex√®me = donne_lex√®me_suivant(parseuse)
        saufsi lex√®me == "be" {
            rapporte_erreur(parseuse, "attendu 'be'", lex√®me)
            retourne
        }

        instruction.expression = parse_expression(parseuse)
        retourne
    }

    si lex√®me == "Assert" {
        retourne
    }

    si lex√®me == "If" {
        _ := parse_instruction_if(parseuse, ligne)
        retourne
    }

    si lex√®me == "Return" {
        return := parseuse.cr√©e_instruction(ligne, InstructionReturn)
        return.expression = parse_expression(parseuse)
        retourne
    }

    si lex√®me == "Repeat" {
        repeat := parseuse.cr√©e_instruction(ligne, InstructionRepeat)

        saufsi parseuse.consomme_caract√®re(',') {
            parseuse.rapporte_erreur("attendu ','")
            retourne
        }

        lex√®me = donne_lex√®me_suivant(parseuse)
        saufsi lex√®me == "while" {
            parseuse.rapporte_erreur("attendu 'while'", lex√®me)
            retourne
        }

        repeat.expression = parse_expression(parseuse)
        repeat.instruction = parseuse.cr√©e_bloc()
        parseuse.bloc = repeat.instruction
        retourne
    }

    si lex√®me == "Else" {
        instruction := parseuse.bloc.instructions[parseuse.bloc.instructions.taille - 1]
        assert(instruction.type == InstructionIf || instruction.type == InstructionElseIf)

        bloc := parseuse.cr√©e_bloc()

        lex√®me = parseuse.donne_lex√®me_suivant()
        si lex√®me == "if" {
            else_if := parseuse.cr√©e_instruction(ligne, InstructionElseIf)
            else_if.bloc = bloc
            else_if.expression = parse_expression(parseuse)

            saufsi consomme_caract√®re(parseuse, ',') {
                rapporte_erreur(parseuse, "attendu ','", parseuse.donne_lex√®me_suivant())
                retourne
            }

            parseuse.parse_bloc_if(else_if.bloc)
            retourne
        }

        else := parseuse.cr√©e_instruction(ligne, InstructionElse)
        else.bloc = bloc
        parseuse.bloc = bloc
        retourne
    }

    si lex√®me == "Set" {
        _ := parse_instruction_set(parseuse, ligne)
        retourne
    }

    si ligne {
        imprimeln("%", ligne)
        rapporte_erreur(parseuse, "lex√®me inattendu", lex√®me)
    }
}

parse_instruction_if :: fonc (parseuse: *Parseuse, ligne: chaine) -> *InstructionIf
{
    instruction := parseuse.cr√©e_instruction(ligne, InstructionIf)

    instruction.expression = parse_expression(parseuse)
    instruction.bloc = parseuse.cr√©e_bloc()

    saufsi consomme_caract√®re(parseuse, ',') {
        rapporte_erreur(parseuse, "attendu ','", parseuse.donne_lex√®me_suivant())
        retourne instruction
    }

    parse_bloc_if(parseuse, instruction.bloc)

    retourne instruction
}

parse_bloc_if :: fonc (parseuse: *Parseuse, bloc: *InstructionBloc)
{
    lex√®me := parseuse.donne_lex√®me_suivant()
    si lex√®me == "then" {
        parseuse.bloc = bloc
    }
    sinon si lex√®me == "set" {
        parseuse.bloc = bloc
        _ := parse_instruction_set(parseuse, "")
        parseuse.bloc = bloc.bloc_parent
    }
    sinon si lex√®me == "return" {
        return := loge(InstructionReturn)
        return.expression = parse_expression(parseuse)
        tableau_ajoute(*bloc.instructions, return)
    }
    sinon si lex√®me == "throw" {
        throw := loge(InstructionThrow)

        lex√®me = parseuse.donne_lex√®me_suivant()
        si lex√®me != "a" {
            rapporte_erreur(parseuse, "attendu 'a' apr√®s 'throw'", lex√®me)
        }

        lex√®me = parseuse.donne_lex√®me_suivant()
        si lex√®me != "TypeError" {
            rapporte_erreur(parseuse, "type d'exception inconnue", lex√®me)
        }
        throw.type_exception = lex√®me

        lex√®me = parseuse.donne_lex√®me_suivant()
        si lex√®me != "exception" {
            rapporte_erreur(parseuse, "attendu 'a' apr√®s 'throw'", lex√®me)
        }

        tableau_ajoute(*bloc.instructions, throw)
    }
    sinon {
        rapporte_erreur(parseuse, "lex√®me inattendu", lex√®me)
    }
}

parse_instruction_set :: fonc (parseuse: *Parseuse, ligne: chaine) -> *InstructionSet
{
    variable := parseuse.donne_lex√®me_suivant()

    lex√®me := parseuse.donne_lex√®me_suivant()
    saufsi lex√®me == "to" {
        rapporte_erreur(parseuse, "attendu 'to'", lex√®me)
        retourne nul
    }

    r√©sultat := parseuse.cr√©e_instruction(ligne, InstructionSet)
    r√©sultat.variable = variable
    r√©sultat.expression = parse_expression(parseuse)
    retourne r√©sultat
}

InfoExpressionBinaire :: struct {
    lex√®me: chaine
    op: chaine
}

__infos_expressions_binaire := [
    InfoExpressionBinaire("+", "+"),
    InfoExpressionBinaire("-", "-"),
    InfoExpressionBinaire("*", "*"),
    InfoExpressionBinaire("-", "-"),
    InfoExpressionBinaire("<", "<"),
    InfoExpressionBinaire(">", ">"),
    InfoExpressionBinaire("=", "=="),
    InfoExpressionBinaire("is", "=="),
    InfoExpressionBinaire("‚â•", ">=")
]

parse_expression :: fonc (parseuse: *Parseuse) -> *Expression
{
    r√©sultat := parse_expression_primaire(parseuse)
    saufsi r√©sultat {
        retourne nul
    }

    parseuse.consomme_espaces_blanches()

    pour __infos_expressions_binaire {
        si parseuse.apparie(it.lex√®me) {
            parseuse.d√©but += it.lex√®me.taille
            op := loge(ExpressionBinaire)
            op.op = it.op
            op.gauche = r√©sultat
            op.droite = parse_expression(parseuse)
            retourne op
        }
    }

    retourne r√©sultat
}

InfoVariable :: struct {
    lex√®me_sp√©cifi√©: chaine
    lex√®me_corrig√©: chaine
}

__infos_variables := [
    InfoVariable("+‚àû", "R64_INFINIT√â"),
    InfoVariable("-‚àû", "R64_INFINIT√â_N√âGATIVE"),
    InfoVariable("-1ùîΩ", "-1.0"),
    InfoVariable("true", "vrai"),
    InfoVariable("false", "faux"),
    InfoVariable("this value", "this_value")
]

parse_expression_primaire :: fonc (parseuse: *Parseuse) -> *Expression
{
    si consomme_caract√®re(parseuse, '?') {
        retourne parse_expression_appel(parseuse, '?')
    }

    si consomme_caract√®re(parseuse, '!') {
        retourne parse_expression_appel(parseuse, '!')
    }

    pour __infos_variables {
        si parseuse.apparie(it.lex√®me_sp√©cifi√©) {
            parseuse.d√©but += it.lex√®me_sp√©cifi√©.taille
            r√©sultat := loge(ExpressionR√©f√©rence)
            r√©sultat.texte = it.lex√®me_corrig√©
            retourne r√©sultat
        }
    }

    d√©but := parseuse.d√©but

    lex√®me := donne_lex√®me_suivant(parseuse)

    si parseuse.consomme_caract√®re('(') {
        parseuse.d√©but = d√©but
        retourne parse_expression_appel(parseuse, 0)
    }

    r√©sultat := loge(ExpressionR√©f√©rence)
    r√©sultat.texte = lex√®me
    retourne r√©sultat
}

parse_expression_appel :: fonc (parseuse: *Parseuse, gestion_exception: z8) -> *ExpressionAppel
{
    fonction := parseuse.donne_lex√®me_suivant()

    saufsi consomme_caract√®re(parseuse, '(') {
        rapporte_erreur(parseuse, "attendu '('", parseuse.donne_lex√®me_suivant())
        retourne nul
    }

    r√©sultat := loge(ExpressionAppel)
    r√©sultat.fonction = fonction
    r√©sultat.gestion_exception = gestion_exception

    tantque parseuse.d√©but < parseuse.fin {
        si consomme_caract√®re(parseuse, ')') {
            retourne r√©sultat
        }

        expression := parse_expression(parseuse)
        saufsi expression {
            rapporte_erreur(parseuse, "attendu une expression", parseuse.donne_lex√®me_suivant())
            arr√™te
        }

        tableau_ajoute(*r√©sultat.params, expression)

        saufsi parseuse.consomme_caract√®re(',') {
            arr√™te
        }
    }

    saufsi consomme_caract√®re(parseuse, ')') {
        rapporte_erreur(parseuse, "attendu ')'", parseuse.donne_lex√®me_suivant())
    }

    retourne r√©sultat
}

Parseuse :: struct {
    d√©but: *z8
    fin: *z8

    bloc: *InstructionBloc
}

initialise_pour_ligne :: fonc (parseuse: *Parseuse, ligne: chaine)
{
    parseuse.d√©but = ligne.pointeur
    parseuse.fin = ligne.pointeur + ligne.taille
}

cr√©e_instruction :: fonc (parseuse: *Parseuse, ligne: chaine, $T: type_de_donn√©es) -> *T
{
    r√©sultat := loge(T)
    r√©sultat.ligne = ligne
    tableau_ajoute(*parseuse.bloc.instructions, r√©sultat)
    retourne r√©sultat
}

cr√©e_bloc :: fonc (parseuse: *Parseuse) -> *InstructionBloc
{
    r√©sultat := loge(InstructionBloc)
    r√©sultat.bloc_parent = parseuse.bloc
    retourne r√©sultat
}

rapporte_erreur :: fonc (parseuse: *Parseuse, message: chaine)
{
    rapporte_erreur(parseuse, message, donne_lex√®me_suivant(parseuse))
}

rapporte_erreur :: fonc (parseuse: *Parseuse @inutilis√©e, message: chaine, lex√®me_obtenu: chaine)
{
    imprime("%, obtenu '%'\n", message, lex√®me_obtenu)
}

donne_lex√®me_suivant :: fonc (parseuse: *Parseuse) -> chaine
{
    consomme_espaces_blanches(parseuse)

    si parseuse.d√©but >= parseuse.fin {
        retourne ""
    }

    si parseuse.apparie("ùîΩ") {
        parseuse.d√©but += "ùîΩ".taille
        retourne "ùîΩ"
    }

    r√©sultat := chaine(parseuse.d√©but, 0)

    si m√©moire(parseuse.d√©but) == '%' {
        parseuse.d√©but += 1
        r√©sultat.taille += 1
        tantque parseuse.d√©but < parseuse.fin {
            c := m√©moire(parseuse.d√©but)
            si ('a' <= c <= 'z') || ('A' <= c <= 'Z') || ('0' <= c <= '9') || c == '.' {
                parseuse.d√©but += 1
                r√©sultat.taille += 1
                continue
            }

            arr√™te
        }

        si parseuse.d√©but >= parseuse.fin || m√©moire(parseuse.d√©but) != '%' {
            parseuse.rapporte_erreur("fin de fichier dans le parsage d'un symbole")
            retourne ""
        }

        parseuse.d√©but += 1
        r√©sultat.taille += 1
        retourne r√©sultat
    }

    tantque parseuse.d√©but < parseuse.fin {
        c := m√©moire(parseuse.d√©but)
        si ('a' <= c <= 'z') || ('A' <= c <= 'Z') || ('0' <= c <= '9') {
            parseuse.d√©but += 1
            r√©sultat.taille += 1
            continue
        }

        arr√™te
    }

    retourne r√©sultat
}

apparie :: fonc (parseuse: *Parseuse, texte: chaine) -> bool
{
    consomme_espaces_blanches(parseuse)
    si parseuse.d√©but >= parseuse.fin {
        retourne faux
    }

    taille := parseuse.fin - parseuse.d√©but
    si taille < texte.taille {
        retourne faux
    }

    chn := chaine(parseuse.d√©but, texte.taille)
    retourne chn == texte
}

consomme_caract√®re :: fonc (parseuse: *Parseuse, c: z8) -> bool
{
    consomme_espaces_blanches(parseuse)
    si parseuse.d√©but >= parseuse.fin {
        retourne faux
    }

    caract√®re := m√©moire(parseuse.d√©but)
    si c != caract√®re {
        retourne faux
    }

    parseuse.d√©but += 1
    retourne vrai
}

consomme_point_virgule :: fonc (parseuse: *Parseuse)
{
    saufsi consomme_caract√®re(parseuse, ';') {
        rapporte_erreur(parseuse, "attendu ';", donne_lex√®me_suivant(parseuse))
    }
}

consomme_espaces_blanches :: fonc (parseuse: *Parseuse)
{
    tantque parseuse.d√©but < parseuse.fin {
        si est_espace_blanche(m√©moire(parseuse.d√©but)) {
            parseuse.d√©but += 1
            continue
        }

        arr√™te
    }
}

compte_indentation :: fonc (parseuse: *Parseuse) -> z64
{
    d√©but := parseuse.d√©but

    tantque d√©but < parseuse.fin {
        si est_espace_blanche(m√©moire(d√©but)) {
            d√©but += 1
            continue
        }

        arr√™te
    }

    retourne d√©but - parseuse.d√©but
}

Instruction :: struct {
    type := type_de_donn√©es
    ligne: chaine
}

InstructionBloc :: struct {
    empl base: Instruction
    type = #type_de_cette_structure

    indentation : z32 = -1
    bloc_parent: *InstructionBloc

    instructions: [..]*Instruction
}

InstructionIf :: struct {
    empl base: Instruction
    type = #type_de_cette_structure

    expression: *Expression
    bloc: *InstructionBloc
}

InstructionElseIf :: struct {
    empl base: Instruction
    type = #type_de_cette_structure

    expression: *Expression
    bloc: *InstructionBloc
}

InstructionElse :: struct {
    empl base: Instruction
    type = #type_de_cette_structure

    bloc: *InstructionBloc
}

InstructionLet :: struct {
    empl base: Instruction
    type = #type_de_cette_structure

    variable: chaine
    expression: *Expression
}

InstructionSet :: struct {
    empl base: Instruction
    type = #type_de_cette_structure

    variable: chaine
    expression: *Expression
}

InstructionRepeat :: struct {
    empl base: Instruction
    type = #type_de_cette_structure

    expression: *Expression
    instruction: *InstructionBloc
}

InstructionReturn :: struct {
    empl base: Instruction
    type = #type_de_cette_structure

    expression: *Expression
}

InstructionThrow :: struct {
    empl base: Instruction
    type = #type_de_cette_structure

    type_exception: chaine
}

imprime_instruction :: fonc (g√©n√©ratrice: *G√©n√©ratriceCode, base: *Instruction)
{
    discr base.type {
        InstructionBloc {
            bloc := base comme *InstructionBloc
            g√©n√©ratrice.commence_bloc()
            pour bloc.instructions {
                si it.ligne {
                    g√©n√©ratrice.ajoute_chaine("// ", it.ligne)
                    g√©n√©ratrice.ajoute_nouvelle_ligne()
                }
                imprime_instruction(g√©n√©ratrice, it)
                si index_it < bloc.instructions.taille - 1 {
                    g√©n√©ratrice.ajoute_nouvelle_ligne()
                }
            }
            g√©n√©ratrice.termine_bloc()
        }
        InstructionIf {
            if := base comme *InstructionIf
            g√©n√©ratrice.ajoute_chaine("si ")
            imprime_expression(g√©n√©ratrice, if.expression)
            g√©n√©ratrice.ajoute_chaine(" ")
            imprime_instruction(g√©n√©ratrice, if.bloc)
        }
        InstructionElseIf {
            else_if := base comme *InstructionElseIf
            g√©n√©ratrice.ajoute_chaine("sinon si ")
            imprime_expression(g√©n√©ratrice, else_if.expression)
            g√©n√©ratrice.ajoute_chaine(" ")
            imprime_instruction(g√©n√©ratrice, else_if.bloc)
        }
        InstructionElse {
            else := base comme *InstructionElse
            g√©n√©ratrice.ajoute_chaine("sinon ")
            imprime_instruction(g√©n√©ratrice, else.bloc)
        }
        InstructionLet {
            let := base comme *InstructionLet
            g√©n√©ratrice.ajoute_chaine(let.variable, " := ")
            imprime_expression(g√©n√©ratrice, let.expression)
            v√©rifie_exception(g√©n√©ratrice, let.expression)
        }
        InstructionSet {
            set := base comme *InstructionSet
            g√©n√©ratrice.ajoute_chaine(set.variable, " = ")
            imprime_expression(g√©n√©ratrice, set.expression)
            v√©rifie_exception(g√©n√©ratrice, set.expression)
        }
        InstructionRepeat {
            repeat := base comme *InstructionRepeat
            g√©n√©ratrice.ajoute_chaine("tantque ")
            imprime_expression(g√©n√©ratrice, repeat.expression)
            g√©n√©ratrice.ajoute_chaine(" ")
            imprime_instruction(g√©n√©ratrice, repeat.instruction)
        }
        InstructionReturn {
            instruction := base comme *InstructionReturn
            g√©n√©ratrice.ajoute_chaine("retourne")
            si instruction.expression {
                g√©n√©ratrice.ajoute_chaine(" ")
                imprime_expression(g√©n√©ratrice, instruction.expression)
            }
        }
        InstructionThrow {
            instruction := base comme *InstructionThrow
            si instruction.type_exception == "TypeError" {
                g√©n√©ratrice.ajoute_chaine("_ := lance_type_error(interpr√©teuse, message)")
            }
        }
        sinon {}
    }
}

v√©rifie_exception :: fonc (g√©n√©ratrice: *G√©n√©ratriceCode, expression: *Expression)
{
    si expression.type != ExpressionAppel {
        retourne
    }

    appel := expression comme *ExpressionAppel
    
    si appel.gestion_exception == '?' {
        g√©n√©ratrice.ajoute_nouvelle_ligne()
        g√©n√©ratrice.ajoute_chaine("si interpr√©teuse.poss√®de_exception() ")
        g√©n√©ratrice.commence_bloc()
        g√©n√©ratrice.ajoute_chaine("retourne")
        g√©n√©ratrice.termine_bloc()
        retourne
    }

    si appel.gestion_exception == '!' {
        g√©n√©ratrice.ajoute_nouvelle_ligne()
        g√©n√©ratrice.ajoute_chaine("assert(!interpr√©teuse.poss√®de_exception())")
        g√©n√©ratrice.ajoute_nouvelle_ligne()
        retourne
    }
}

Expression :: struct {
    type := type_de_donn√©es
}

ExpressionR√©f√©rence :: struct {
    empl base: Expression
    type = #type_de_cette_structure

    texte: chaine
}

ExpressionBinaire :: struct {
    empl base: Expression
    type = #type_de_cette_structure

    op: chaine

    gauche: *Expression
    droite: *Expression
}

ExpressionAppel :: struct {
    empl base: Expression
    type = #type_de_cette_structure

    gestion_exception: z8

    fonction: chaine
    params: [..]*Expression
}

imprime_expression :: fonc (g√©n√©ratrice: *G√©n√©ratriceCode, base: *Expression)
{
    discr base.type {
        ExpressionR√©f√©rence {
            expression := base comme *ExpressionR√©f√©rence

            texte := expression.texte

            si texte[0] == '%' {
                texte = avance(texte, 1)
                texte = recule(texte, 1)

                remplace_sans_copie(*texte, '.', '_')
            }

            g√©n√©ratrice.ajoute_chaine(texte)
        }
        ExpressionBinaire {
            expression := base comme *ExpressionBinaire
            g√©n√©ratrice.imprime_expression(expression.gauche)
            g√©n√©ratrice.ajoute_chaine(" ", expression.op, " ")
            g√©n√©ratrice.imprime_expression(expression.droite)
        }
        ExpressionAppel {
            appel := base comme *ExpressionAppel

            g√©n√©ratrice.ajoute_chaine(donne_nom_snake_case(appel.fonction))

            saufsi appel.params {
                si appel.gestion_exception != 0 {
                    g√©n√©ratrice.ajoute_chaine("(interpr√©teuse)")
                }
                sinon {
                    g√©n√©ratrice.ajoute_chaine("()")
                }
            }
            sinon {
                virgule := "("
                si appel.gestion_exception != 0 {
                    virgule = "(interpr√©teuse, "
                }

                pour appel.params {
                    g√©n√©ratrice.ajoute_chaine(virgule)
                    imprime_expression(g√©n√©ratrice, it)
                    virgule = ", "
                }

                g√©n√©ratrice.ajoute_chaine(")")
            }
        }
        sinon {}
    }
}

G√©n√©ratriceCode :: struct {
    indentation: z32
}

ajoute_chaine :: fonc (g√©n√©ratrice: *G√©n√©ratriceCode @inutilis√©e, chns: ...chaine)
{
    pour chns {
        imprime("%", it)
    }
}

ajoute_nouvelle_ligne :: fonc (g√©n√©ratrice: *G√©n√©ratriceCode)
{
    chn := donne_chaine_indentation(g√©n√©ratrice.indentation)
    imprime("\n%", chn)
}

commence_bloc :: fonc (g√©n√©ratrice: *G√©n√©ratriceCode)
{
    ajoute_chaine(g√©n√©ratrice, "{")
    g√©n√©ratrice.indentation += 1
    ajoute_nouvelle_ligne(g√©n√©ratrice)
}

termine_bloc :: fonc (g√©n√©ratrice: *G√©n√©ratriceCode)
{
    g√©n√©ratrice.indentation -= 1
    ajoute_nouvelle_ligne(g√©n√©ratrice)
    ajoute_chaine(g√©n√©ratrice, "}")
    ajoute_nouvelle_ligne(g√©n√©ratrice)
}

importe S√©rialisation

Griffonier :: TamponFixe(T = z8, N = 128)

__griffonier: Griffonier

donne_nom_snake_case :: fonc (chn: chaine) -> chaine
{
    retourne donne_nom_snake_case(chn, *__griffonier)
}

donne_nom_snake_case :: fonc (chn: chaine, griffonier: *Griffonier) -> chaine
{
    premier := vrai

    griffonier.curseur = 0

    curseur := 0

    tantque curseur < chn.taille {
        it := chn[curseur]

        si 'A' <= it <= 'Z' {
            saufsi premier {
                ajoute(griffonier, '_')
            }

            ajoute(griffonier, it - 'A' + 'a')
        }
        sinon {
            ajoute(griffonier, it)
        }

        premier = faux
        curseur += 1
    }

    retourne chaine(*griffonier.donn√©es[0], griffonier.curseur)
}
