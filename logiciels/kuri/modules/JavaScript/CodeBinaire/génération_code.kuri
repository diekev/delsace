importe Fondation

/* ------------------------------------------------------------------------- */
/** \nom G√©n√©ratriceCodeBinaire
 * \{ */

Label :: struct {
    id: n32
    d√©calage: D√©calageBranche
}

LabelsBoucle :: struct {
    id_label_continue: n32
    id_label_break: n32
}

PatchLabelBranche :: struct {
    label: n32
    branche: IndexBranche
}

G√©n√©ratriceCodeBinaire :: struct {
    flux: *FluxDInstructions

    labels: [..]Label
    labels_boucle: [..]LabelsBoucle
    patchs_labels_branches: [..]PatchLabelBranche
}

g√©n√®re_code_binaire :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, noeud: *NoeudSyntaxique) -> Optionnel(Registre)
{
    saufsi noeud.sur_g√©n√©ration_code_binaire {
        infos := donne_info_pour_type_noeud(noeud)
        panique("[%] noeud non-support√© : %\n", #nom_de_cette_fonction, infos.nom)
    }

    retourne noeud.sur_g√©n√©ration_code_binaire(noeud, g√©n√©ratrice)
}

cr√©e_label :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Label
{
    r√©sultat: Label = ---
    r√©sultat.id = g√©n√©ratrice.labels.taille comme n32
    tableau_ajoute(*g√©n√©ratrice.labels, r√©sultat)
    retourne r√©sultat
}

ins√®re_label :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, label: Label)
{
    g√©n√©ratrice.labels[label.id].d√©calage = g√©n√©ratrice.donne_d√©calage()
}

empile_labels_boucle :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, label_continue: Label, label_break: Label)
{
    labels: LabelsBoucle
    labels.id_label_continue = label_continue.id
    labels.id_label_break = label_break.id
    tableau_ajoute(*g√©n√©ratrice.labels_boucle, labels)
}

d√©pile_labels_boucle :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire)
{
    g√©n√©ratrice.labels_boucle.taille -= 1
}

donne_labels_boucle_courante :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> LabelsBoucle
{
    retourne g√©n√©ratrice.labels_boucle[g√©n√©ratrice.labels_boucle.taille - 1]
}

ajoute_patch_label_branche :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, label: n32, branche: IndexBranche)
{
    patch := tableau_ajoute_√©l√©ment(*g√©n√©ratrice.patchs_labels_branches)
    patch.label = label
    patch.branche = branche
}

applique_patchs :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire)
{
    pour g√©n√©ratrice.patchs_labels_branches {
        label := g√©n√©ratrice.labels[it.label]
        g√©n√©ratrice.d√©finis_d√©calage_branche(it.branche, label.d√©calage)
    }
}

donne_d√©calage :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> D√©calageBranche
{
    flux := g√©n√©ratrice.flux
    retourne D√©calageBranche(flux.instructions.taille)
}

d√©finis_d√©calage_branche :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, branche: IndexBranche)
{
    d√©finis_d√©calage_branche(g√©n√©ratrice, branche, g√©n√©ratrice.donne_d√©calage())
}

d√©finis_d√©calage_branche :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, branche: IndexBranche, d√©calage: D√©calageBranche)
{
    flux := g√©n√©ratrice.flux
    instruction := *flux.instructions[branche comme z64] comme *InstructionBranche
    instruction.d√©calage = d√©calage
}

cr√©e_instruction :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, $T: type_de_donn√©es) -> *T
{
    flux := g√©n√©ratrice.flux

    d√©calage := flux.instructions.taille
    tableau_redimensionne(flux.instructions, d√©calage + taille_de(T) comme z64)
    r√©sultat := *flux.instructions[d√©calage] comme *T
    init_de(T)(r√©sultat)
    retourne r√©sultat
}

cr√©e_branche :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, d√©calage: D√©calageBranche)
{
    branche := g√©n√©ratrice.cr√©e_instruction(InstructionBranche)
    branche.d√©calage = d√©calage
}

cr√©e_branche :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> IndexBranche
{
    r√©sultat := g√©n√©ratrice.donne_d√©calage()
    _ := g√©n√©ratrice.cr√©e_instruction(InstructionBranche)
    retourne IndexBranche(r√©sultat comme z64)
}

cr√©e_branche_si_faux :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> IndexBranche
{
    r√©sultat := g√©n√©ratrice.donne_d√©calage()
    _ := g√©n√©ratrice.cr√©e_instruction(InstructionBrancheSiFaux)
    retourne IndexBranche(r√©sultat comme z64)
}

cr√©e_branche_si_vrai :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> IndexBranche
{
    r√©sultat := g√©n√©ratrice.donne_d√©calage()
    _ := g√©n√©ratrice.cr√©e_instruction(InstructionBrancheSiVrai)
    retourne IndexBranche(r√©sultat comme z64)
}

cr√©e_branche_saufsi_null_ou_undefined :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> IndexBranche
{
    r√©sultat := g√©n√©ratrice.donne_d√©calage()
    _ := g√©n√©ratrice.cr√©e_instruction(InstructionBrancheSaufsiNullOuUndefined)
    retourne IndexBranche(r√©sultat comme z64)
}

cr√©e_charge :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, valeur: Valeur) -> Registre
{
    gauche := g√©n√©ratrice.cr√©e_instruction(InstructionCharge)
    gauche.vlr = valeur
    retourne Registre(0)
}

cr√©e_charge_registre :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, src: Registre)
{
    gauche := g√©n√©ratrice.cr√©e_instruction(InstructionChargeRegistre)
    gauche.src = src
}

cr√©e_stocke :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Registre
{
    dst := g√©n√©ratrice.alloue_registre()
    gauche := g√©n√©ratrice.cr√©e_instruction(InstructionStocke)
    gauche.dst = dst
    retourne dst
}

cr√©e_cr√©e_chaine :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, chn: ECMAString) -> Registre
{
    r√©sultat := g√©n√©ratrice.cr√©e_instruction(InstructionCr√©eChaine)
    r√©sultat.chn = chn
    retourne Registre(0)
}

cr√©e_cr√©e_objet :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Registre
{
    _ := g√©n√©ratrice.cr√©e_instruction(InstructionCr√©eObjet)
    retourne Registre(0)
}

cr√©e_cr√©e_array :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Registre
{
    _ := g√©n√©ratrice.cr√©e_instruction(InstructionCr√©eArray)
    retourne Registre(0)
}

cr√©e_expression_binaire :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, gauche: Registre, $T: type_de_donn√©es) -> Registre
{
    ajout := g√©n√©ratrice.cr√©e_instruction(T)
    ajout.gch = gauche
    retourne Registre(0)
}

cr√©e_ajoute :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, gauche: Registre) -> Registre
{
    retourne cr√©e_expression_binaire(g√©n√©ratrice, gauche, InstructionAjoute)
}

cr√©e_soustrait :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, gauche: Registre) -> Registre
{
    retourne cr√©e_expression_binaire(g√©n√©ratrice, gauche, InstructionSoustrait)
}

cr√©e_multiplie :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, gauche: Registre) -> Registre
{
    retourne cr√©e_expression_binaire(g√©n√©ratrice, gauche, InstructionMultiplie)
}

cr√©e_divise :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, gauche: Registre) -> Registre
{
    retourne cr√©e_expression_binaire(g√©n√©ratrice, gauche, InstructionDivise)
}

cr√©e_modulo :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, gauche: Registre) -> Registre
{
    retourne cr√©e_expression_binaire(g√©n√©ratrice, gauche, InstructionModulo)
}

cr√©e_d√©calage_gauche :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, gauche: Registre) -> Registre
{
    retourne cr√©e_expression_binaire(g√©n√©ratrice, gauche, InstructionD√©calageGauche)
}

cr√©e_d√©calage_droite :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, gauche: Registre) -> Registre
{
    retourne cr√©e_expression_binaire(g√©n√©ratrice, gauche, InstructionD√©calageDroite)
}

cr√©e_d√©calage_droite_naturel :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, gauche: Registre) -> Registre
{
    retourne cr√©e_expression_binaire(g√©n√©ratrice, gauche, InstructionD√©calageDroiteNaturel)
}

cr√©e_et_binaire :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, gauche: Registre) -> Registre
{
    retourne cr√©e_expression_binaire(g√©n√©ratrice, gauche, InstructionEtBinaire)
}

cr√©e_ou_binaire :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, gauche: Registre) -> Registre
{
    retourne cr√©e_expression_binaire(g√©n√©ratrice, gauche, InstructionOuBinaire)
}

cr√©e_ou_exclusif :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, gauche: Registre) -> Registre
{
    retourne cr√©e_expression_binaire(g√©n√©ratrice, gauche, InstructionOuExBinaire)
}

cr√©e_exponentiation :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, gauche: Registre) -> Registre
{
    retourne cr√©e_expression_binaire(g√©n√©ratrice, gauche, InstructionExponentiation)
}

cr√©e_relation_inf√©rieure :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, gauche: Registre) -> Registre
{
    retourne cr√©e_expression_binaire(g√©n√©ratrice, gauche, InstructionRelationInf√©rieure)
}

cr√©e_relation_sup√©rieure :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, gauche: Registre) -> Registre
{
    retourne cr√©e_expression_binaire(g√©n√©ratrice, gauche, InstructionRelationSup√©rieure)
}

cr√©e_relation_inf√©rieure_√©gale :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, gauche: Registre) -> Registre
{
    retourne cr√©e_expression_binaire(g√©n√©ratrice, gauche, InstructionRelationInf√©rieure√âgale)
}

cr√©e_relation_sup√©rieure_√©gale :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, gauche: Registre) -> Registre
{
    retourne cr√©e_expression_binaire(g√©n√©ratrice, gauche, InstructionRelationSup√©rieure√âgale)
}

cr√©e_instance_of :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, gauche: Registre) -> Registre
{
    retourne cr√©e_expression_binaire(g√©n√©ratrice, gauche, InstructionInstanceOf)
}

cr√©e_in :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, gauche: Registre) -> Registre
{
    retourne cr√©e_expression_binaire(g√©n√©ratrice, gauche, InstructionIn)
}

cr√©e_comparaison_√©gal :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, gauche: Registre) -> Registre
{
    retourne cr√©e_expression_binaire(g√©n√©ratrice, gauche, InstructionComparaison√âgal)
}

cr√©e_comparaison_in√©gal :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, gauche: Registre) -> Registre
{
    retourne cr√©e_expression_binaire(g√©n√©ratrice, gauche, InstructionComparaisonIn√©gal)
}

cr√©e_comparaison_√©gal_strict :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, gauche: Registre) -> Registre
{
    retourne cr√©e_expression_binaire(g√©n√©ratrice, gauche, InstructionComparaison√âgalStrict)
}

cr√©e_comparaison_in√©gal_strict :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, gauche: Registre) -> Registre
{
    retourne cr√©e_expression_binaire(g√©n√©ratrice, gauche, InstructionComparaisonIn√©galStrict)
}

cr√©e_d√©finis_locale :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, nom: ECMAString)
{
    r√©sultat := g√©n√©ratrice.cr√©e_instruction(InstructionD√©finisLocale)
    r√©sultat.nom = nom
}

cr√©e_charge_locale :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, nom: ECMAString) -> Registre
{
    r√©sultat := g√©n√©ratrice.cr√©e_instruction(InstructionChargeLocale)
    r√©sultat.nom = nom
    retourne Registre(0)
}

cr√©e_initialise_r√©f√©rence :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, nom: ECMAString)
{
    r√©sultat := g√©n√©ratrice.cr√©e_instruction(InstructionInitialiseR√©f√©rence)
    r√©sultat.nom = nom
}

cr√©e_d√©finis_membre :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, nom: ECMAString, src: Registre)
{
    r√©sultat := g√©n√©ratrice.cr√©e_instruction(InstructionD√©finisMembre)
    r√©sultat.nom = nom
    r√©sultat.src = src
}

cr√©e_charge_membre :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, reg_objet: Registre, nom: ECMAString) -> Registre
{
    r√©sultat := g√©n√©ratrice.cr√©e_instruction(InstructionChargeMembre)
    r√©sultat.obj = reg_objet
    r√©sultat.nom = nom
    retourne Registre(0)
}

cr√©e_d√©finis_index :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, obj: Registre, src: Registre)
{
    r√©sultat := g√©n√©ratrice.cr√©e_instruction(InstructionD√©finisIndex)
    r√©sultat.obj = obj
    r√©sultat.src = src
}

cr√©e_charge_index :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, reg_objet: Registre) -> Registre
{
    r√©sultat := g√©n√©ratrice.cr√©e_instruction(InstructionChargeIndex)
    r√©sultat.obj = reg_objet
    retourne Registre(0)
}

cr√©e_propri√©t√©_array :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, obj: Registre, index: z32)
{
    r√©sultat := g√©n√©ratrice.cr√©e_instruction(InstructionCr√©ePropri√©t√©Array)
    r√©sultat.obj = obj
    r√©sultat.index = index
}

cr√©e_data_property_or_throw :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, obj: Registre, nom: ECMAString)
{
    r√©sultat := g√©n√©ratrice.cr√©e_instruction(InstructionCDPOT)
    r√©sultat.obj = obj
    r√©sultat.nom = nom
}

cr√©e_appel :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, func: Registre, this_value: Registre, args: []Registre) -> Registre
{
    flux := g√©n√©ratrice.flux
    d√©calage := flux.instructions.taille
    tableau_redimensionne(flux.instructions, d√©calage + taille_de(InstructionAppel) comme z64 + args.taille * taille_de(Registre) comme z64)
    r√©sultat := *flux.instructions[d√©calage] comme *InstructionAppel
    init_de(InstructionAppel)(r√©sultat)

    r√©sultat.func = func
    r√©sultat.this_value = this_value
    r√©sultat.nombre_arguments = args.taille comme z32

    pointeur_args := ((r√©sultat + 1) comme *octet) comme *Registre

    pour args {
        m√©moire(pointeur_args) = it
        pointeur_args += 1
    }

    retourne Registre(0)
}

cr√©e_appel_eval :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, func: Registre, this_value: Registre, args: []Registre) -> Registre
{
    flux := g√©n√©ratrice.flux
    d√©calage := flux.instructions.taille
    tableau_redimensionne(flux.instructions, d√©calage + taille_de(InstructionAppelEval) comme z64 + args.taille * taille_de(Registre) comme z64)
    r√©sultat := *flux.instructions[d√©calage] comme *InstructionAppelEval
    init_de(InstructionAppelEval)(r√©sultat)

    r√©sultat.func = func
    r√©sultat.this_value = this_value
    r√©sultat.nombre_arguments = args.taille comme z32

    pointeur_args := ((r√©sultat + 1) comme *octet) comme *Registre

    pour args {
        m√©moire(pointeur_args) = it
        pointeur_args += 1
    }

    retourne Registre(0)
}

cr√©e_new :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, func: Registre, args: []Registre) -> Registre
{
    flux := g√©n√©ratrice.flux
    d√©calage := flux.instructions.taille
    tableau_redimensionne(flux.instructions, d√©calage + taille_de(InstructionNew) comme z64 + args.taille * taille_de(Registre) comme z64)
    r√©sultat := *flux.instructions[d√©calage] comme *InstructionNew
    init_de(InstructionNew)(r√©sultat)

    r√©sultat.func = func
    r√©sultat.nombre_arguments = args.taille comme z32

    pointeur_args := ((r√©sultat + 1) comme *octet) comme *Registre

    pour args {
        m√©moire(pointeur_args) = it
        pointeur_args += 1
    }

    retourne Registre(0)
}

cr√©e_this_value_appel :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, noeud: *NoeudSyntaxique) -> Registre
{
    r√©sultat := g√©n√©ratrice.cr√©e_instruction(InstructionThisValueAppel)
    r√©sultat.noeud = noeud
    retourne Registre(0)
}

cr√©e_retour :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire)
{
    _ := g√©n√©ratrice.cr√©e_instruction(InstructionRetour)
}

cr√©e_this :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Registre
{
    _ := g√©n√©ratrice.cr√©e_instruction(InstructionThis)
    retourne Registre(0)
}

cr√©e_incr√©mente :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire)
{
    _ := g√©n√©ratrice.cr√©e_instruction(InstructionIncr√©mente)
}

cr√©e_d√©cr√©mente :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire)
{
    _ := g√©n√©ratrice.cr√©e_instruction(InstructionD√©cr√©mente)
}

cr√©e_typeof :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Registre
{
    _ := g√©n√©ratrice.cr√©e_instruction(InstructionTypeof)
    retourne Registre(0)
}

cr√©e_unary_plus :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Registre
{
    _ := g√©n√©ratrice.cr√©e_instruction(InstructionUnaryPlus)
    retourne Registre(0)
}

cr√©e_unary_minus :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Registre
{
    _ := g√©n√©ratrice.cr√©e_instruction(InstructionUnaryMinus)
    retourne Registre(0)
}

cr√©e_instancie_fonction :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, noeud: *FunctionExpression) -> Registre
{
    r√©sultat := g√©n√©ratrice.cr√©e_instruction(InstructionInstancieFonction)
    r√©sultat.fonction = noeud
    retourne Registre(0)
}

cr√©e_instancie_arrow_fonction :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, noeud: *ArrowFunction) -> Registre
{
    r√©sultat := g√©n√©ratrice.cr√©e_instruction(InstructionInstancieArrowFunction)
    r√©sultat.fonction = noeud
    retourne Registre(0)
}

cr√©e_named_evaluation :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, noeud: *NoeudSyntaxique, nom: ECMAString) -> Registre
{
    r√©sultat := g√©n√©ratrice.cr√©e_instruction(InstructionNamedEvaluation)
    r√©sultat.noeud = noeud
    r√©sultat.nom = nom
    retourne Registre(0)
}

cr√©e_logical_not :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Registre
{
    _ := g√©n√©ratrice.cr√©e_instruction(InstructionLogicalNot)
    retourne Registre(0)
}

cr√©e_binary_not :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Registre
{
    _ := g√©n√©ratrice.cr√©e_instruction(InstructionBinaryNot)
    retourne Registre(0)
}

cr√©e_entr√©e_bloc_catch :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, nom: ECMAString)
{
    r√©sultat := g√©n√©ratrice.cr√©e_instruction(InstructionEntr√©eBlocCatch)
    r√©sultat.nom = nom
}

cr√©e_sortie_bloc_catch :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire)
{
    _ := g√©n√©ratrice.cr√©e_instruction(InstructionSortieBlocCatch)
}

cr√©e_throw :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire)
{
    _ := g√©n√©ratrice.cr√©e_instruction(InstructionThrow)
}

empile_exception_handler :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> ExceptionHandler
{
    d√©calage := g√©n√©ratrice.donne_d√©calage()
    _ := g√©n√©ratrice.cr√©e_instruction(InstructionEmpileExceptionHandler)
    retourne ExceptionHandler(d√©calage)
}

d√©pile_exception_handler :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire, handler: ExceptionHandler)
{
    instruction := *g√©n√©ratrice.flux.instructions[handler comme z64] comme *InstructionEmpileExceptionHandler
    instruction.d√©calage = g√©n√©ratrice.donne_d√©calage()

    _ := g√©n√©ratrice.cr√©e_instruction(InstructionD√©pileExceptionHandler)
}

cr√©e_entr√©e_switch :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire)
{
    _ := g√©n√©ratrice.cr√©e_instruction(InstructionEntr√©eSwitch)
}

cr√©e_sortie_switch :: fonc (g√©n√©ratrice: &G√©n√©ratriceCodeBinaire)
{
    _ := g√©n√©ratrice.cr√©e_instruction(InstructionSortieSwitch)
}

alloue_registre :: fonc (empl g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Registre
{
    r√©sultat := Registre(flux.registres)
    flux.registres += 1
    retourne r√©sultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom G√©n√©ration de code pour les noeuds.
 * \{ */

array_literal_sur_code_binaire :: fonc (noeud: *ArrayLiteral, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    _ := cr√©e_cr√©e_array(g√©n√©ratrice)
    reg_array := g√©n√©ratrice.cr√©e_stocke()

    pour noeud.√©l√©ments {
        _ := g√©n√©ratrice.g√©n√®re_code_binaire(it)
        g√©n√©ratrice.cr√©e_propri√©t√©_array(reg_array, index_it comme z32)
    }

    _ := g√©n√©ratrice.cr√©e_charge(Valeur(Number = noeud.√©l√©ments.taille comme r64))
    opt_reg := g√©n√©ratrice.cr√©e_stocke()
    g√©n√©ratrice.cr√©e_charge_registre(reg_array)

    // √Ä FAIRE : app√®le set directement
    // 2. Perform ?¬†Set(array, "length", ùîΩ(len), true).
    g√©n√©ratrice.cr√©e_d√©finis_membre(STR_length, opt_reg)

    retourne Registre(0)
}

arrow_function_sur_code_binaire :: fonc (noeud: *ArrowFunction, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    retourne g√©n√©ratrice.cr√©e_instancie_arrow_fonction(noeud)
}

assignment_expression_sur_code_binaire :: fonc (noeud: *AssignmentExpression, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    opt_reg: Optionnel(Registre)

    doit_lier_branche: bool
    branche: IndexBranche

    discr noeud.op√©ration {
        Assigne {
            opt_reg = compile_expression_assign√©e(noeud, g√©n√©ratrice)
            assert(opt_reg.poss√®de_valeur())
        }
        EtLogique {
            _ := g√©n√®re_code_binaire(g√©n√©ratrice, noeud.gauche)
            branche = g√©n√©ratrice.cr√©e_branche_si_faux()
            doit_lier_branche = vrai

            opt_reg = compile_expression_assign√©e(noeud, g√©n√©ratrice)
            assert(opt_reg.poss√®de_valeur())
        }
        OuLogique {
            _ := g√©n√®re_code_binaire(g√©n√©ratrice, noeud.gauche)
            branche = g√©n√©ratrice.cr√©e_branche_si_vrai()
            doit_lier_branche = vrai

            opt_reg = compile_expression_assign√©e(noeud, g√©n√©ratrice)
            assert(opt_reg.poss√®de_valeur())
        }
        Coalesce {
            _ := g√©n√®re_code_binaire(g√©n√©ratrice, noeud.gauche)
            branche = g√©n√©ratrice.cr√©e_branche_saufsi_null_ou_undefined()
            doit_lier_branche = vrai

            opt_reg = compile_expression_assign√©e(noeud, g√©n√©ratrice)
            assert(opt_reg.poss√®de_valeur())
        }
        Ajoute {
            _ := g√©n√®re_code_binaire(g√©n√©ratrice, noeud.gauche)
            reg_gauche := g√©n√©ratrice.cr√©e_stocke()

            opt_reg = g√©n√®re_code_binaire(g√©n√©ratrice, noeud.droite)
            assert(opt_reg.poss√®de_valeur())

            opt_reg = g√©n√©ratrice.cr√©e_ajoute(reg_gauche)
        }
        Soustrait {
            _ := g√©n√®re_code_binaire(g√©n√©ratrice, noeud.gauche)
            reg_gauche := g√©n√©ratrice.cr√©e_stocke()

            opt_reg = g√©n√®re_code_binaire(g√©n√©ratrice, noeud.droite)
            assert(opt_reg.poss√®de_valeur())

            opt_reg = g√©n√©ratrice.cr√©e_soustrait(reg_gauche)
        }
        Multiplie {
            _ := g√©n√®re_code_binaire(g√©n√©ratrice, noeud.gauche)
            reg_gauche := g√©n√©ratrice.cr√©e_stocke()

            opt_reg = g√©n√®re_code_binaire(g√©n√©ratrice, noeud.droite)
            assert(opt_reg.poss√®de_valeur())

            opt_reg = g√©n√©ratrice.cr√©e_multiplie(reg_gauche)
        }
        Divise {
            _ := g√©n√®re_code_binaire(g√©n√©ratrice, noeud.gauche)
            reg_gauche := g√©n√©ratrice.cr√©e_stocke()

            opt_reg = g√©n√®re_code_binaire(g√©n√©ratrice, noeud.droite)
            assert(opt_reg.poss√®de_valeur())

            opt_reg = g√©n√©ratrice.cr√©e_divise(reg_gauche)
        }
        Modulo {
            _ := g√©n√®re_code_binaire(g√©n√©ratrice, noeud.gauche)
            reg_gauche := g√©n√©ratrice.cr√©e_stocke()

            opt_reg = g√©n√®re_code_binaire(g√©n√©ratrice, noeud.droite)
            assert(opt_reg.poss√®de_valeur())

            opt_reg = g√©n√©ratrice.cr√©e_modulo(reg_gauche)
        }
        D√©calageGauche {
            _ := g√©n√®re_code_binaire(g√©n√©ratrice, noeud.gauche)
            reg_gauche := g√©n√©ratrice.cr√©e_stocke()

            opt_reg = g√©n√®re_code_binaire(g√©n√©ratrice, noeud.droite)
            assert(opt_reg.poss√®de_valeur())

            opt_reg = g√©n√©ratrice.cr√©e_d√©calage_gauche(reg_gauche)
        }
        D√©calageDroite {
            _ := g√©n√®re_code_binaire(g√©n√©ratrice, noeud.gauche)
            reg_gauche := g√©n√©ratrice.cr√©e_stocke()

            opt_reg = g√©n√®re_code_binaire(g√©n√©ratrice, noeud.droite)
            assert(opt_reg.poss√®de_valeur())

            opt_reg = g√©n√©ratrice.cr√©e_d√©calage_droite(reg_gauche)
        }
        D√©calageDroiteNaturel {
            _ := g√©n√®re_code_binaire(g√©n√©ratrice, noeud.gauche)
            reg_gauche := g√©n√©ratrice.cr√©e_stocke()

            opt_reg = g√©n√®re_code_binaire(g√©n√©ratrice, noeud.droite)
            assert(opt_reg.poss√®de_valeur())

            opt_reg = g√©n√©ratrice.cr√©e_d√©calage_droite_naturel(reg_gauche)
        }
        EtBinaire {
            _ := g√©n√®re_code_binaire(g√©n√©ratrice, noeud.gauche)
            reg_gauche := g√©n√©ratrice.cr√©e_stocke()

            opt_reg = g√©n√®re_code_binaire(g√©n√©ratrice, noeud.droite)
            assert(opt_reg.poss√®de_valeur())

            opt_reg = g√©n√©ratrice.cr√©e_et_binaire(reg_gauche)
        }
        OuBinaire {
            _ := g√©n√®re_code_binaire(g√©n√©ratrice, noeud.gauche)
            reg_gauche := g√©n√©ratrice.cr√©e_stocke()

            opt_reg = g√©n√®re_code_binaire(g√©n√©ratrice, noeud.droite)
            assert(opt_reg.poss√®de_valeur())

            opt_reg = g√©n√©ratrice.cr√©e_ou_binaire(reg_gauche)
        }
        OuExBinaire {
            _ := g√©n√®re_code_binaire(g√©n√©ratrice, noeud.gauche)
            reg_gauche := g√©n√©ratrice.cr√©e_stocke()

            opt_reg = g√©n√®re_code_binaire(g√©n√©ratrice, noeud.droite)
            assert(opt_reg.poss√®de_valeur())

            opt_reg = g√©n√©ratrice.cr√©e_ou_exclusif(reg_gauche)
        }
        Exponentiation {
            _ := g√©n√®re_code_binaire(g√©n√©ratrice, noeud.gauche)
            reg_gauche := g√©n√©ratrice.cr√©e_stocke()

            opt_reg = g√©n√®re_code_binaire(g√©n√©ratrice, noeud.droite)
            assert(opt_reg.poss√®de_valeur())

            opt_reg = g√©n√©ratrice.cr√©e_exponentiation(reg_gauche)
        }
        sinon {
            panique("op√©ration d'assignement non-impl√©ment√© pour %", noeud.op√©ration)
        }
    }

    si noeud.gauche.type == Identifier {
        nom := (noeud.gauche comme *Identifier).nom
        g√©n√©ratrice.cr√©e_d√©finis_locale(nom)
    }
    sinon si noeud.gauche.type == MemberExpression {
        membre := noeud.gauche comme *MemberExpression

        opt_reg = g√©n√©ratrice.cr√©e_stocke()

        opt_reg_objet := g√©n√©ratrice.g√©n√®re_code_binaire(membre.objet)
        assert(opt_reg_objet.poss√®de_valeur())

        saufsi membre.calcul√© {
            assert(membre.propri√©t√©.type == Identifier)
            identifier := membre.propri√©t√© comme *Identifier

            g√©n√©ratrice.cr√©e_d√©finis_membre(identifier.nom, opt_reg.Quelque)
        }
        sinon {
            opt_reg_objet = g√©n√©ratrice.cr√©e_stocke()
            _ := g√©n√©ratrice.g√©n√®re_code_binaire(membre.propri√©t√©)
            g√©n√©ratrice.cr√©e_d√©finis_index(opt_reg_objet.Quelque, opt_reg.Quelque)
        }

        /* Nous devons retourner la valeur assign√©e. */
        si opt_reg.Quelque comme n32 != 0 {
            g√©n√©ratrice.cr√©e_charge_registre(opt_reg.Quelque)
            opt_reg = Registre(0)
        }
    }
    sinon {
        panique("non-impl√©ment√©")
    }


    si doit_lier_branche {
        g√©n√©ratrice.d√©finis_d√©calage_branche(branche)
    }

    retourne opt_reg
}

compile_expression_assign√©e :: fonc (noeud: *AssignmentExpression, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    si is_anonymous_function_definition(noeud.droite) && is_identifier_ref(noeud.gauche) {
        assert(noeud.gauche.type == Identifier)
        lhs := (noeud.gauche comme *Identifier).nom
        retourne g√©n√©ratrice.cr√©e_named_evaluation(noeud.droite, lhs)
    }
    retourne g√©n√©ratrice.g√©n√®re_code_binaire(noeud.droite)
}

binary_expression_sur_code_binaire :: fonc (expression: *BinaryExpression, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    opt_reg_gauche := g√©n√®re_code_binaire(g√©n√©ratrice, expression.gauche)
    assert(opt_reg_gauche.poss√®de_valeur())
    gauche := g√©n√©ratrice.cr√©e_stocke()
    opt_reg_droite := g√©n√®re_code_binaire(g√©n√©ratrice, expression.droite)
    assert(opt_reg_droite.poss√®de_valeur())

    discr expression.op√©ration {
        Plus {
            retourne g√©n√©ratrice.cr√©e_ajoute(gauche)
        }
        Moins {
            retourne g√©n√©ratrice.cr√©e_soustrait(gauche)
        }
        Multiplie {
            retourne g√©n√©ratrice.cr√©e_multiplie(gauche)
        }
        Divise {
            retourne g√©n√©ratrice.cr√©e_divise(gauche)
        }
        Modulo {
            retourne g√©n√©ratrice.cr√©e_modulo(gauche)
        }
        EtBinaire {
            retourne g√©n√©ratrice.cr√©e_et_binaire(gauche)
        }
        OuBinaire {
            retourne g√©n√©ratrice.cr√©e_ou_binaire(gauche)
        }
        OuExclusif {
            retourne g√©n√©ratrice.cr√©e_ou_exclusif(gauche)
        }
        D√©calageGauche {
            retourne g√©n√©ratrice.cr√©e_d√©calage_gauche(gauche)
        }
        D√©calageDroite {
            retourne g√©n√©ratrice.cr√©e_d√©calage_droite(gauche)
        }
        D√©calageDroiteNaturel {
            retourne g√©n√©ratrice.cr√©e_d√©calage_droite_naturel(gauche)
        }
        Exponentiation {
            retourne g√©n√©ratrice.cr√©e_exponentiation(gauche)
        }
    }

    panique("op√©rateur binaire non-impl√©ment√© pour %", expression.op√©ration)
}

binary_not_sur_code_binaire :: fonc (noeud: *BinaryNot, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    _ := g√©n√©ratrice.g√©n√®re_code_binaire(noeud.argument)
    retourne g√©n√©ratrice.cr√©e_binary_not()
}

block_statement_sur_code_binaire :: fonc (block: *BlockStatement, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    r√©sultat: Optionnel(Registre)
    pour block.enfants {
        r√©sultat = g√©n√©ratrice.g√©n√®re_code_binaire(it)
    }
    retourne r√©sultat
}

boolean_literal_sur_code_binaire :: fonc (noeud: *BooleanLiteral, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    retourne g√©n√©ratrice.cr√©e_charge(Valeur(Boolean = noeud.valeur))
}

break_statement_sur_code_binaire :: fonc (statement: *BreakStatement, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    assert(statement.target == nul)
    label := g√©n√©ratrice.donne_labels_boucle_courante().id_label_break
    branche := g√©n√©ratrice.cr√©e_branche()
    g√©n√©ratrice.ajoute_patch_label_branche(label, branche)
}

call_expression_sur_code_binaire :: fonc (noeud: *CallExpression, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    assert(noeud.appel√©.type != CallExpression)

    reg_opt_func := g√©n√©ratrice.g√©n√®re_code_binaire(noeud.appel√©)
    assert(reg_opt_func.poss√®de_valeur())
    reg_opt_func = g√©n√©ratrice.cr√©e_stocke()

    this_value := g√©n√©ratrice.cr√©e_this_value_appel(noeud.appel√©)
    this_value = g√©n√©ratrice.cr√©e_stocke()

    registres_arguments: [..]Registre
    diff√®re d√©loge(registres_arguments)

    pour noeud.arguments {
        reg_opt_arg := g√©n√©ratrice.g√©n√®re_code_binaire(it)
        assert(reg_opt_arg.poss√®de_valeur())
        reg_arg := g√©n√©ratrice.cr√©e_stocke()
        tableau_ajoute(*registres_arguments, reg_arg)
    }

    si noeud.appel√©.type == Identifier && (noeud.appel√© comme *Identifier).nom == STR_eval {
        retourne g√©n√©ratrice.cr√©e_appel_eval(reg_opt_func.Quelque, this_value, registres_arguments)
    }

    retourne g√©n√©ratrice.cr√©e_appel(reg_opt_func.Quelque, this_value, registres_arguments)
}

catch_clause_sur_code_binaire :: fonc (catch: *CatchClause, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    saufsi catch.param {
        retourne g√©n√©ratrice.g√©n√®re_code_binaire(catch.body)
    }

    assert(catch.param.type == Identifier)
    identifier := catch.param comme *Identifier

    g√©n√©ratrice.cr√©e_entr√©e_bloc_catch(identifier.nom)

    r√©sultat := g√©n√©ratrice.g√©n√®re_code_binaire(catch.body)

    g√©n√©ratrice.cr√©e_sortie_bloc_catch()
    retourne r√©sultat
}

coalesce_sur_code_binaire :: fonc (noeud: *Coalesce, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    _ := g√©n√©ratrice.g√©n√®re_code_binaire(noeud.left)
    branche_si_faux := g√©n√©ratrice.cr√©e_branche_saufsi_null_ou_undefined()
    r√©sultat := g√©n√©ratrice.g√©n√®re_code_binaire(noeud.right)
    g√©n√©ratrice.d√©finis_d√©calage_branche(branche_si_faux)
    retourne r√©sultat
}

comma_statement_sur_code_binaire :: fonc (comma: *CommaExpression, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    _ := g√©n√©ratrice.g√©n√®re_code_binaire(comma.left)
    retourne g√©n√©ratrice.g√©n√®re_code_binaire(comma.right)
}

concise_body_sur_code_binaire :: fonc (concise_body: *ConciseBody, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    // ExpressionBody : FunctionBody
    si concise_body.statement.type == BlockStatement {
        retourne g√©n√©ratrice.g√©n√®re_code_binaire(concise_body.statement)
    }

    // ExpressionBody : AssignmentExpression
    // 1. Let exprRef be ? Evaluation of AssignmentExpression.
    // 2. Let exprValue be ? GetValue(exprRef).
    _ := g√©n√©ratrice.g√©n√®re_code_binaire(concise_body.statement)

    // 3. Return ReturnCompletion(exprValue).
    g√©n√©ratrice.cr√©e_retour()
    retourne
}

conditional_expression_sur_code_binaire :: fonc (noeud: *ConditionalExpression, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    reg_opt_test := g√©n√©ratrice.g√©n√®re_code_binaire(noeud.test)
    assert(reg_opt_test.poss√®de_valeur())

    branche_si_faux := g√©n√©ratrice.cr√©e_branche_si_faux()

    _ := g√©n√©ratrice.g√©n√®re_code_binaire(noeud.consequent)

    branche := g√©n√©ratrice.cr√©e_branche()

    g√©n√©ratrice.d√©finis_d√©calage_branche(branche_si_faux)
    _ := g√©n√©ratrice.g√©n√®re_code_binaire(noeud.alternate)

    g√©n√©ratrice.d√©finis_d√©calage_branche(branche)

    retourne Registre(0)
}

continue_statement_sur_code_binaire :: fonc (statement: *ContinueStatement, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    assert(statement.target == nul)
    label := g√©n√©ratrice.donne_labels_boucle_courante().id_label_continue
    branche := g√©n√©ratrice.cr√©e_branche()
    g√©n√©ratrice.ajoute_patch_label_branche(label, branche)
}

do_while_statement_sur_code_binaire :: fonc (noeud: *DoWhileStatement, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    d√©calage := g√©n√©ratrice.donne_d√©calage()
    label_continue := g√©n√©ratrice.cr√©e_label()

    label_break := g√©n√©ratrice.cr√©e_label()

    g√©n√©ratrice.empile_labels_boucle(label_continue, label_break)
    diff√®re g√©n√©ratrice.d√©pile_labels_boucle()

    _ := g√©n√©ratrice.g√©n√®re_code_binaire(noeud.body)

    g√©n√©ratrice.ins√®re_label(label_continue)

    reg_opt_test := g√©n√©ratrice.g√©n√®re_code_binaire(noeud.test)
    assert(reg_opt_test.poss√®de_valeur())

    branche_test := g√©n√©ratrice.cr√©e_branche_si_vrai()
    g√©n√©ratrice.d√©finis_d√©calage_branche(branche_test, d√©calage)
    g√©n√©ratrice.ins√®re_label(label_break)

    retourne g√©n√©ratrice.cr√©e_charge(js_undefined)
}

empty_statement_sur_code_binaire :: fonc (statement: *NoeudSyntaxique @inutilis√©e, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire @inutilis√©e) -> Optionnel(Registre)
{
    retourne
}

equality_expression_sur_code_binaire :: fonc (noeud: *EqualityExpression, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    opt_reg_gauche := g√©n√®re_code_binaire(g√©n√©ratrice, noeud.gauche)
    assert(opt_reg_gauche.poss√®de_valeur())
    gauche := g√©n√©ratrice.cr√©e_stocke()
    opt_reg_droite := g√©n√®re_code_binaire(g√©n√©ratrice, noeud.droite)
    assert(opt_reg_droite.poss√®de_valeur())

    discr noeud.op√©ration {
        √âgal {
            retourne g√©n√©ratrice.cr√©e_comparaison_√©gal(gauche)
        }
        In√©gal {
            retourne g√©n√©ratrice.cr√©e_comparaison_in√©gal(gauche)
        }
        √âgalStrict {
            retourne g√©n√©ratrice.cr√©e_comparaison_√©gal_strict(gauche)
        }
        In√©galStrict {
            retourne g√©n√©ratrice.cr√©e_comparaison_in√©gal_strict(gauche)
        }
        sinon {
            panique("noeud.op√©ration non-initialis√©")
        }
    }
}

expression_statement_sur_code_binaire :: fonc (statement: *ExpressionStatement, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    retourne g√©n√®re_code_binaire(g√©n√©ratrice, statement.expression)
}

for_statement_sur_code_binaire :: fonc (for: *ForStatement, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    si for.init {
        _ := g√©n√©ratrice.g√©n√®re_code_binaire(for.init)
    }

    d√©calage_entr√©e_boucle := g√©n√©ratrice.donne_d√©calage()
    label_boucle := g√©n√©ratrice.cr√©e_label()
    label_continue := g√©n√©ratrice.cr√©e_label()
    label_break := g√©n√©ratrice.cr√©e_label()

    g√©n√©ratrice.ins√®re_label(label_boucle)

    branche_test: IndexBranche
    si for.test {
        _ := g√©n√©ratrice.g√©n√®re_code_binaire(for.test)
        branche_test = g√©n√©ratrice.cr√©e_branche_si_faux()
    }

    g√©n√©ratrice.empile_labels_boucle(label_continue, label_break)
    diff√®re g√©n√©ratrice.d√©pile_labels_boucle()

    _ := g√©n√©ratrice.g√©n√®re_code_binaire(for.body)

    g√©n√©ratrice.ins√®re_label(label_continue)
    si for.update {
        _ := g√©n√©ratrice.g√©n√®re_code_binaire(for.update)
    }
    g√©n√©ratrice.cr√©e_branche(d√©calage_entr√©e_boucle)

    d√©calage := g√©n√©ratrice.donne_d√©calage()
    g√©n√©ratrice.d√©finis_d√©calage_branche(branche_test, d√©calage)
    g√©n√©ratrice.ins√®re_label(label_break)
    
    retourne g√©n√©ratrice.cr√©e_charge(js_undefined)
}

function_declaration_sur_code_binaire :: fonc (noeud: *FunctionDeclaration @inutilis√©e, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire @inutilis√©e) -> Optionnel(Registre)
{
    // 1. Return empty.
    retourne
}

function_expression_sur_code_binaire :: fonc (noeud: *FunctionExpression, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    retourne g√©n√©ratrice.cr√©e_instancie_fonction(noeud)
}

identifier_sur_code_binaire :: fonc (noeud: *Identifier, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    retourne g√©n√©ratrice.cr√©e_charge_locale(noeud.nom)
}

if_statement_sur_code_binaire :: fonc (noeud: *IfStatement, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    reg_opt_test := g√©n√©ratrice.g√©n√®re_code_binaire(noeud.test)
    assert(reg_opt_test.poss√®de_valeur())

    branche_si_faux := g√©n√©ratrice.cr√©e_branche_si_faux()

    _ := g√©n√©ratrice.g√©n√®re_code_binaire(noeud.consequent)

    si noeud.alternate {
        branche := g√©n√©ratrice.cr√©e_branche()

        g√©n√©ratrice.d√©finis_d√©calage_branche(branche_si_faux)
        _ := g√©n√©ratrice.g√©n√®re_code_binaire(noeud.alternate)

        g√©n√©ratrice.d√©finis_d√©calage_branche(branche)
    }
    sinon {
        g√©n√©ratrice.d√©finis_d√©calage_branche(branche_si_faux)
    }

    retourne g√©n√©ratrice.cr√©e_charge(js_undefined)
}

logical_and_sur_code_binaire :: fonc (noeud: *LogicalAnd, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    _ := g√©n√©ratrice.g√©n√®re_code_binaire(noeud.left)
    branche_si_faux := g√©n√©ratrice.cr√©e_branche_si_faux()
    r√©sultat := g√©n√©ratrice.g√©n√®re_code_binaire(noeud.right)
    g√©n√©ratrice.d√©finis_d√©calage_branche(branche_si_faux)
    retourne r√©sultat
}

logical_not_sur_code_binaire :: fonc (noeud: *LogicalNot, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    _ := g√©n√©ratrice.g√©n√®re_code_binaire(noeud.argument)
    retourne g√©n√©ratrice.cr√©e_logical_not()
}

logical_or_sur_code_binaire :: fonc (noeud: *LogicalAnd, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    _ := g√©n√©ratrice.g√©n√®re_code_binaire(noeud.left)
    branche_si_faux := g√©n√©ratrice.cr√©e_branche_si_vrai()
    r√©sultat := g√©n√©ratrice.g√©n√®re_code_binaire(noeud.right)
    g√©n√©ratrice.d√©finis_d√©calage_branche(branche_si_faux)
    retourne r√©sultat
}

membre_expression_sur_code_binaire :: fonc (noeud: *MemberExpression, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    opt_reg_objet := g√©n√©ratrice.g√©n√®re_code_binaire(noeud.objet)

    saufsi noeud.calcul√© {
        assert(noeud.propri√©t√©.type == Identifier)
        identifier := noeud.propri√©t√© comme *Identifier

        retourne g√©n√©ratrice.cr√©e_charge_membre(opt_reg_objet.Quelque, identifier.nom)
    }

    opt_reg_objet = g√©n√©ratrice.cr√©e_stocke()
    _ := g√©n√©ratrice.g√©n√®re_code_binaire(noeud.propri√©t√©)
    retourne g√©n√©ratrice.cr√©e_charge_index(opt_reg_objet.Quelque)
}

new_expression_sur_code_binaire :: fonc (noeud: *NewExpression, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    construct_expr: *NoeudSyntaxique
    arguments: []*Expression

    si noeud.argument.type == CallExpression {
        call := noeud.argument comme *CallExpression
        construct_expr = call.appel√©
        arguments = call.arguments
    }
    sinon {
        construct_expr = noeud.argument
    }

    reg_opt_func := g√©n√©ratrice.g√©n√®re_code_binaire(construct_expr)
    assert(reg_opt_func.poss√®de_valeur())
    reg_opt_func = g√©n√©ratrice.cr√©e_stocke()

    registres_arguments: [..]Registre
    diff√®re d√©loge(registres_arguments)

    pour arguments {
        reg_opt_arg := g√©n√©ratrice.g√©n√®re_code_binaire(it)
        assert(reg_opt_arg.poss√®de_valeur())
        reg_arg := g√©n√©ratrice.cr√©e_stocke()
        tableau_ajoute(*registres_arguments, reg_arg)
    }

    retourne g√©n√©ratrice.cr√©e_new(reg_opt_func.Quelque, registres_arguments)
}

noeud_script_body_sur_code_binaire :: fonc (noeud: *ScriptBody, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    r√©sultat: Optionnel(Registre)

    pour noeud.enfants {
        r√©sultat = g√©n√®re_code_binaire(g√©n√©ratrice, it)
    }

    retourne r√©sultat
}

noeud_script_sur_code_binaire :: fonc (noeud: *NoeudScript, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    retourne g√©n√®re_code_binaire(g√©n√©ratrice, noeud.script_body)
}

null_literal_sur_code_binaire :: fonc (noeud: *NullLiteral @inutilis√©e, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    retourne g√©n√©ratrice.cr√©e_charge(js_null)
}

numeric_literal_sur_code_binaire :: fonc (noeud: *NumericLiteral, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    retourne g√©n√©ratrice.cr√©e_charge(Valeur(Number = noeud.valeur))
}

object_expression_sur_code_binaire :: fonc (noeud: *ObjectExpression, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    reg_objet_src := g√©n√©ratrice.cr√©e_cr√©e_objet()
    si noeud.properties.taille == 0 {
        retourne reg_objet_src
    }

    reg_objet := g√©n√©ratrice.cr√©e_stocke()

    pour noeud.properties {
        assert(it.property_name.type == Identifier)
        ident := it.property_name comme *Identifier
        nom_prop := ident.nom

        // √Ä FAIRE : is_proto_setter

        si is_anonymous_function_definition(it.expression) {
            _ := g√©n√©ratrice.cr√©e_named_evaluation(it.expression, nom_prop)
        }
        sinon {
            _ := g√©n√©ratrice.g√©n√®re_code_binaire(it.expression)
        }

        g√©n√©ratrice.cr√©e_data_property_or_throw(reg_objet, nom_prop)
    }

    g√©n√©ratrice.cr√©e_charge_registre(reg_objet)
    retourne Registre(0)
}

parenthesized_expression_sur_code_binaire :: fonc (noeud: *ParenthesizedExpression, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    saufsi noeud.expression {
        retourne g√©n√©ratrice.cr√©e_charge(js_undefined)
    }

    retourne g√©n√©ratrice.g√©n√®re_code_binaire(noeud.expression)
}

relational_expression_sur_code_binaire :: fonc (noeud: *RelationalExpression, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    opt_reg_gauche := g√©n√®re_code_binaire(g√©n√©ratrice, noeud.gauche)
    assert(opt_reg_gauche.poss√®de_valeur())
    gauche := g√©n√©ratrice.cr√©e_stocke()
    opt_reg_droite := g√©n√®re_code_binaire(g√©n√©ratrice, noeud.droite)
    assert(opt_reg_droite.poss√®de_valeur())

    discr noeud.op√©ration {
        Inf√©rieur {
            retourne g√©n√©ratrice.cr√©e_relation_inf√©rieure(gauche)
        }
        Sup√©rieur {
            retourne g√©n√©ratrice.cr√©e_relation_sup√©rieure(gauche)
        }
        Inf√©rieur√âgal {
            retourne g√©n√©ratrice.cr√©e_relation_inf√©rieure_√©gale(gauche)
        }
        Sup√©rieur√âgal {
            retourne g√©n√©ratrice.cr√©e_relation_sup√©rieure_√©gale(gauche)
        }
        InstanceOf {
            retourne g√©n√©ratrice.cr√©e_instance_of(gauche)
        }
        In {
            retourne g√©n√©ratrice.cr√©e_in(gauche)
        }
        sinon {
            panique("relation non-impl√©ment√©e : %", noeud.op√©ration)
        }
    }
}

return_statement_sur_code_binaire :: fonc (noeud: *ReturnStatement, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    si noeud.argument {
        _ := g√©n√©ratrice.g√©n√®re_code_binaire(noeud.argument)
    }
    sinon {
        _ := g√©n√©ratrice.cr√©e_charge(js_undefined)
    }

    g√©n√©ratrice.cr√©e_retour()
}

string_literal_sur_code_binaire :: fonc (noeud: *StringLiteral, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    retourne g√©n√©ratrice.cr√©e_cr√©e_chaine(noeud.valeur)
}

switch_statement_sur_code_binaire :: fonc (switch: *SwitchStatement, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    _ := g√©n√©ratrice.g√©n√®re_code_binaire(switch.discriminant)

    g√©n√©ratrice.cr√©e_entr√©e_switch()

    si switch.cases.taille == 0 {
        _ := g√©n√©ratrice.cr√©e_charge(js_undefined)
    }
    sinon {
        reg_valeur_discriminant := g√©n√©ratrice.cr√©e_stocke()

        index_branches_pour_cas: [..]IndexBranche
        diff√®re d√©loge(index_branches_pour_cas)

        label_pour_break := g√©n√©ratrice.cr√©e_label()

        g√©n√©ratrice.empile_labels_boucle(Label(-1 comme n32), label_pour_break)
        diff√®re g√©n√©ratrice.d√©pile_labels_boucle()

        /* G√©n√®re le code pour les tests. */
        pour switch.cases {
            si index_it == switch.index_default_clause {
                tableau_ajoute(*index_branches_pour_cas, IndexBranche(-1))
                continue
            }

            assert(it.type == CaseClause)

            _ := g√©n√©ratrice.g√©n√®re_code_binaire(it.test)
            _ := g√©n√©ratrice.cr√©e_comparaison_√©gal_strict(reg_valeur_discriminant)
            branche := g√©n√©ratrice.cr√©e_branche_si_vrai()
            tableau_ajoute(*index_branches_pour_cas, branche)
        }

        branche_si_faux := g√©n√©ratrice.cr√©e_branche()
        si switch.index_default_clause != -1 {
            index_branches_pour_cas[switch.index_default_clause] = branche_si_faux
        }

        pour switch.cases {
            g√©n√©ratrice.d√©finis_d√©calage_branche(index_branches_pour_cas[index_it])

            si it.consequent == nul {
                continue
            }

            _ := g√©n√©ratrice.g√©n√®re_code_binaire(it.consequent)
        }

        si switch.index_default_clause == -1 {
            g√©n√©ratrice.d√©finis_d√©calage_branche(branche_si_faux)
        }
        g√©n√©ratrice.ins√®re_label(label_pour_break)
    }

    g√©n√©ratrice.cr√©e_sortie_switch()
}

this_expression_sur_code_binaire :: fonc (noeud: *ThisExpression @inutilis√©e, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    retourne g√©n√©ratrice.cr√©e_this()
}

throw_statement_sur_code_binaire :: fonc (noeud: *ThrowStatement, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    reg_opt_valeur := g√©n√©ratrice.g√©n√®re_code_binaire(noeud.argument)
    assert(reg_opt_valeur.poss√®de_valeur())
    g√©n√©ratrice.cr√©e_throw()
}

try_statement_sur_code_binaire :: fonc (try: *TryStatement, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    exception_handler: ExceptionHandler
    si try.handler != nul {
        exception_handler = g√©n√©ratrice.empile_exception_handler()
    }

    _ := g√©n√©ratrice.g√©n√®re_code_binaire(try.block)

    /* Branche pour sauteur le catch si aucune exception n'est lanc√©e. */
    branche := g√©n√©ratrice.cr√©e_branche()

    si try.handler != nul {
        g√©n√©ratrice.d√©pile_exception_handler(exception_handler)
        _ := catch_clause_sur_code_binaire(try.handler, g√©n√©ratrice)
    }

    g√©n√©ratrice.d√©finis_d√©calage_branche(branche)
    si try.finalizer != nul {
        _ := g√©n√©ratrice.g√©n√®re_code_binaire(try.finalizer)
    }
}

typeof_operator_sur_code_binaire :: fonc (typeof: *TypeofOperator, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    // √Ä FAIRE : 2. If val is a Reference Record, then
    _ := g√©n√®re_code_binaire(g√©n√©ratrice, typeof.argument)
    retourne g√©n√©ratrice.cr√©e_typeof()
}

unary_minus_operator_sur_code_binaire :: fonc (noeud: *UnaryMinusOperator, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    _ := g√©n√©ratrice.g√©n√®re_code_binaire(noeud.argument)
    retourne g√©n√©ratrice.cr√©e_unary_minus()
}

unary_plus_operator_sur_code_binaire :: fonc (noeud: *UnaryPlusOperator, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    _ := g√©n√©ratrice.g√©n√®re_code_binaire(noeud.argument)
    retourne g√©n√©ratrice.cr√©e_unary_plus()
}

update_expression_sur_code_binaire :: fonc (update: *UpdateExpression, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    argument := update.argument

    reg_opt_old_value := g√©n√©ratrice.g√©n√®re_code_binaire(argument)
    assert(reg_opt_old_value.poss√®de_valeur())

    r√©sultat := reg_opt_old_value
    si update.operation == UpdateOperation.PostfixIncrement || update.operation == UpdateOperation.PostfixDecrement {
        r√©sultat = g√©n√©ratrice.cr√©e_stocke()
    }

    si update.operation == UpdateOperation.PostfixIncrement || update.operation == UpdateOperation.PrefixIncrement {
        g√©n√©ratrice.cr√©e_incr√©mente()
    }
    sinon {
        g√©n√©ratrice.cr√©e_d√©cr√©mente()
    }

    si argument.type == Identifier {
        identifier := argument comme *Identifier
        g√©n√©ratrice.cr√©e_d√©finis_locale(identifier.nom)
    }
    sinon si argument.type == MemberExpression {
        membre := argument comme *MemberExpression
        assert(!membre.calcul√©)

        sauvegarde := g√©n√©ratrice.cr√©e_stocke()

        opt_reg_objet := g√©n√©ratrice.g√©n√®re_code_binaire(membre.objet)
        assert(opt_reg_objet.poss√®de_valeur())

        assert(membre.propri√©t√©.type == Identifier)
        identifier := membre.propri√©t√© comme *Identifier

        g√©n√©ratrice.cr√©e_d√©finis_membre(identifier.nom, sauvegarde)

        si update.operation == UpdateOperation.PrefixIncrement || update.operation == UpdateOperation.PrefixDecrement {
            r√©sultat = sauvegarde
        }
    }
    sinon {
        panique("non-impl√©ment√©")
    }

    si r√©sultat.Quelque comme n32 != 0 {
        g√©n√©ratrice.cr√©e_charge_registre(r√©sultat.Quelque)
        r√©sultat = Registre(0)
    }

    retourne r√©sultat
}

variable_declaration_sur_code_binaire :: fonc (noeud: *VariableDeclaration, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    derni√®re_valeur: Optionnel(Registre)

    si noeud.nature == VariableDeclarationKind.Var {
        pour noeud.expressions {
            derni√®re_valeur = variable_declarator_sur_code_binaire(it, g√©n√©ratrice)
        }
    }
    sinon {
        pour noeud.expressions {
            derni√®re_valeur = lexical_declarator_sur_code_binaire(it, g√©n√©ratrice)
        }
    }

    retourne derni√®re_valeur
}

variable_declarator_sur_code_binaire :: fonc (noeud: *VariableDeclarator, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    assert(noeud.id.type == Identifier)
    identifier := noeud.id comme *Identifier

    saufsi noeud.init {
        // 1. Return EMPTY
        retourne
    }

    // 1. Let bindingId be the StringValue of BindingIdentifier.
    binding_id := identifier.nom

    // 2. Let lhs be ? ResolveBinding(bindingId).
    // √Ä FAIRE : nous pourrions avoir une exception ici.

    // 3. If IsAnonymousFunctionDefinition(Initializer) is true, then
    si is_anonymous_function_definition(noeud.init) {
        // a. Let value be ? NamedEvaluation of Initializer with argument bindingId.
        _ := g√©n√©ratrice.cr√©e_named_evaluation(noeud.init, binding_id)
    }
    // 4. Else,
    sinon {
        // a. Let rhs be ? Evaluation of Initializer.
        // b. Let value be ? GetValue(rhs).
        _ := g√©n√©ratrice.g√©n√®re_code_binaire(noeud.init)
    }

    // 5. Perform ? PutValue(lhs, value).
    g√©n√©ratrice.cr√©e_d√©finis_locale(binding_id)

    // 6. Return EMPTY.
    retourne
}

lexical_declarator_sur_code_binaire :: fonc (noeud: *VariableDeclarator, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    assert(noeud.id.type == Identifier)
    binding_identifier := noeud.id comme *Identifier

    saufsi noeud.init {
        // 1. Let lhs be ! ResolveBinding(StringValue of BindingIdentifier).
        binding_id := binding_identifier.nom

        // 2. Perform ! InitializeReferencedBinding(lhs, undefined).
        _ := g√©n√©ratrice.cr√©e_charge(js_undefined)
        g√©n√©ratrice.cr√©e_initialise_r√©f√©rence(binding_id)

        // 3. Return empty.
        retourne
    }

    // 1. Let bindingId be the StringValue of BindingIdentifier.
    binding_id := binding_identifier.nom

    // 2. Let lhs be ! ResolveBinding(bindingId).

    // 3. If IsAnonymousFunctionDefinition(Initializer) is true, then
    si is_anonymous_function_definition(noeud.init) {
        // a. Let value be ? NamedEvaluation of Initializer with argument bindingId.
        _ := g√©n√©ratrice.cr√©e_named_evaluation(noeud.init, binding_id)
    }
    // 4. Else,
    sinon {
        // a. Let rhs be ? Evaluation of Initializer.
        // b. Let value be ? GetValue(rhs).
        _ := g√©n√©ratrice.g√©n√®re_code_binaire(noeud.init)
    }

    // 5. Perform !¬†InitializeReferencedBinding(lhs, value).
    g√©n√©ratrice.cr√©e_initialise_r√©f√©rence(binding_id)

    // 6. Return empty.
    retourne
}

void_operator_sur_code_binaire :: fonc (noeud: *VoidOperator, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    _ := g√©n√©ratrice.g√©n√®re_code_binaire(noeud.argument)
    retourne g√©n√©ratrice.cr√©e_charge(js_undefined)
}

while_statement_sur_code_binaire :: fonc (noeud: *WhileStatement, g√©n√©ratrice: &G√©n√©ratriceCodeBinaire) -> Optionnel(Registre)
{
    d√©calage := g√©n√©ratrice.donne_d√©calage()
    label_continue := g√©n√©ratrice.cr√©e_label()
    g√©n√©ratrice.ins√®re_label(label_continue)

    label_break := g√©n√©ratrice.cr√©e_label()

    g√©n√©ratrice.empile_labels_boucle(label_continue, label_break)
    diff√®re g√©n√©ratrice.d√©pile_labels_boucle()

    reg_opt_test := g√©n√©ratrice.g√©n√®re_code_binaire(noeud.test)
    assert(reg_opt_test.poss√®de_valeur())

    branche_test := g√©n√©ratrice.cr√©e_branche_si_faux()

    _ := g√©n√©ratrice.g√©n√®re_code_binaire(noeud.body)

    g√©n√©ratrice.cr√©e_branche(d√©calage)

    d√©calage = g√©n√©ratrice.donne_d√©calage()
    g√©n√©ratrice.d√©finis_d√©calage_branche(branche_test, d√©calage)
    g√©n√©ratrice.ins√®re_label(label_break)

    retourne g√©n√©ratrice.cr√©e_charge(js_undefined)
}

/** \} */
