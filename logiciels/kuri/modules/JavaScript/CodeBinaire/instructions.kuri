importe Fondation

/* ------------------------------------------------------------------------- */
/** \nom Instruction
 * \{ */

FluxDInstructions :: struct {
    instructions: [..]octet
    registres: n32
}

imprime_instructions :: fonc (flux: *FluxDInstructions)
{
    pour ItéractriceInstruction(flux) {
        imprime_instruction(it, index_it)
    }
}

ItéractriceInstruction :: struct {
    flux: *FluxDInstructions
}

opérateur pour :: fonc (itératrice: ItéractriceInstruction) -> *Instruction
{
    assert(itératrice.flux != nul)

    début := itératrice.flux.instructions.pointeur
    fin := début + itératrice.flux.instructions.taille

    index : z64 = 0

    tantque début < fin {
        instruction := début comme *Instruction

        `it = instruction
        `index_it = index

        #corps_boucle

        index += 1

        début += donne_taille_octet(instruction)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Instruction
 * \{ */

Registre :: #opaque n32

Instruction :: struct {
    type: type_de_données
}

donne_taille_octet :: fonc (instruction: *Instruction) -> n32
{
    infos := __table_des_types[instruction.type]
    retourne infos.taille_en_octet
}

imprime_instruction :: fonc (instruction: *Instruction, index: z64)
{
    infos := __table_des_types[instruction.type] comme *InfoTypeStructure
 
    nom := infos.nom
    si nom.commence_par("Instruction") {
        nom = avance(nom, 11)
    }

    imprime("[%] %", index, nom)

    pointeur_membre := instruction comme *octet

    virgule := " "

    pour infos.membres {
        si it.id == info_de(ECMAString) {
            valeur := (pointeur_membre + it.décalage) comme *ECMAString
            imprime("%%", virgule, mémoire(valeur))
            virgule = ", "
        }
        sinon si it.id == info_de(Registre) {
            valeur := (pointeur_membre + it.décalage) comme *Registre
            imprime("%r:%", virgule, mémoire(valeur))
            virgule = ", "
        }
        sinon si it.id == info_de(Valeur) {
            valeur := (pointeur_membre + it.décalage) comme *Valeur
            imprime("%%", virgule, mémoire(valeur))
            virgule = ", "
        }
    }

    imprime("\n")
}

IndexBranche :: #opaque z64
DécalageBranche :: #opaque z64

InstructionBranche :: struct {
    empl inst: Instruction
    type = #type_de_cette_structure

    décalage: DécalageBranche
}

InstructionBrancheSiFaux :: struct {
    empl inst_branche: InstructionBranche
    type = #type_de_cette_structure

    reg: Registre
}

InstructionBrancheSiVrai :: struct {
    empl inst_branche: InstructionBranche
    type = #type_de_cette_structure

    reg: Registre
}

InstructionCharge :: struct {
    empl inst: Instruction
    type = #type_de_cette_structure

    reg: Registre
    vlr: Valeur
}

InstructionCréeChaine :: struct {
    empl inst: Instruction
    type = #type_de_cette_structure

    dst: Registre
    chn: ECMAString

    /* Cache pour l'exécution. */
    index_chaine : z64 = -1
}

InstructionCréeObjet :: struct {
    empl inst: Instruction
    type = #type_de_cette_structure

    dst: Registre
}

InstructionExpressionBinaire :: struct {
    empl inst: Instruction

    dst: Registre
    gch: Registre
    drt: Registre
}

InstructionAjoute :: struct {
    empl inst_binaire: InstructionExpressionBinaire
    type = #type_de_cette_structure
}

InstructionSoustrait :: struct {
    empl inst_binaire: InstructionExpressionBinaire
    type = #type_de_cette_structure
}

InstructionRelationInférieure :: struct {
    empl inst_binaire: InstructionExpressionBinaire
    type = #type_de_cette_structure
}

InstructionComparaisonÉgal :: struct {
    empl inst_binaire: InstructionExpressionBinaire
    type = #type_de_cette_structure
}

InstructionComparaisonInégal :: struct {
    empl inst_binaire: InstructionExpressionBinaire
    type = #type_de_cette_structure
}

InstructionDéfinisLocale :: struct {
    empl inst: Instruction
    type = #type_de_cette_structure

    nom: ECMAString
    src: Registre

    index_chaine_en_cache : z32 = -1
}

donne_chaine_primitive :: fonc (instruction: *InstructionDéfinisLocale, realm: *Realm) -> *PrimitiveChaine
{
    si instruction.index_chaine_en_cache == -1 {
        pour realm.chaines {
            si it.texte == instruction.nom {
                instruction.index_chaine_en_cache = index_it comme z32
                retourne it
            }
        }

        résultat := realm.crée_chaine(instruction.nom)
        instruction.index_chaine_en_cache = realm.chaines.taille comme z32 - 1
        retourne résultat
    }

    retourne realm.chaines[instruction.index_chaine_en_cache]
}

InstructionChargeLocale :: struct {
    empl inst: Instruction
    type = #type_de_cette_structure

    dst: Registre
    nom: ECMAString

    index_chaine_en_cache : z32 = -1
}

donne_chaine_primitive :: fonc (instruction: *InstructionChargeLocale, realm: *Realm) -> *PrimitiveChaine
{
    si instruction.index_chaine_en_cache == -1 {
        pour realm.chaines {
            si it.texte == instruction.nom {
                instruction.index_chaine_en_cache = index_it comme z32
                retourne it
            }
        }

        résultat := realm.crée_chaine(instruction.nom)
        instruction.index_chaine_en_cache = realm.chaines.taille comme z32 - 1
        retourne résultat
    }

    retourne realm.chaines[instruction.index_chaine_en_cache]
}

InstructionDéfinisMembre :: struct {
    empl inst: Instruction
    type = #type_de_cette_structure

    obj: Registre
    nom: ECMAString
    src: Registre
}

InstructionChargeMembre :: struct {
    empl inst: Instruction
    type = #type_de_cette_structure

    dst: Registre
    obj: Registre
    nom: ECMAString
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom GénératriceCodeBinaire
 * \{ */

GénératriceCodeBinaire :: struct {
    flux: *FluxDInstructions
}

génère_code_binaire :: fonc (génératrice: &GénératriceCodeBinaire, noeud: *NoeudSyntaxique) -> Optionnel(Registre)
{
    saufsi noeud.sur_génération_code_binaire {
        infos := donne_info_pour_type_noeud(noeud)
        imprime("[%] noeud non-supporté : %\n", #nom_de_cette_fonction, infos.nom)
        retourne
    }

    retourne noeud.sur_génération_code_binaire(noeud, génératrice)
}

donne_décalage :: fonc (génératrice: &GénératriceCodeBinaire) -> DécalageBranche
{
    flux := génératrice.flux
    retourne DécalageBranche(flux.instructions.taille)
}

définis_décalage_branche :: fonc (génératrice: &GénératriceCodeBinaire, branche: IndexBranche, décalage: DécalageBranche)
{
    flux := génératrice.flux
    instruction := *flux.instructions[branche comme z64] comme *InstructionBranche
    instruction.décalage = décalage
}

crée_instruction :: fonc (génératrice: &GénératriceCodeBinaire, $T: type_de_données) -> *T
{
    flux := génératrice.flux

    décalage := flux.instructions.taille
    tableau_redimensionne(flux.instructions, décalage + taille_de(T) comme z64)
    résultat := *flux.instructions[décalage] comme *T
    init_de(T)(résultat)
    retourne résultat
}

crée_branche :: fonc (génératrice: &GénératriceCodeBinaire, décalage: DécalageBranche)
{
    branche := génératrice.crée_instruction(InstructionBranche)
    branche.décalage = décalage
}

crée_branche_si_faux :: fonc (génératrice: &GénératriceCodeBinaire, registre: Registre) -> IndexBranche
{
    résultat := génératrice.donne_décalage()
    branche := génératrice.crée_instruction(InstructionBrancheSiFaux)
    branche.reg = registre
    retourne IndexBranche(résultat comme z64)
}

crée_branche_si_vrai :: fonc (génératrice: &GénératriceCodeBinaire, registre: Registre) -> IndexBranche
{
    résultat := génératrice.donne_décalage()
    branche := génératrice.crée_instruction(InstructionBrancheSiVrai)
    branche.reg = registre
    retourne IndexBranche(résultat comme z64)
}

crée_charge :: fonc (génératrice: &GénératriceCodeBinaire, valeur: Valeur) -> Registre
{
    dst := génératrice.alloue_registre()
    gauche := génératrice.crée_instruction(InstructionCharge)
    gauche.reg = dst
    gauche.vlr = valeur
    retourne dst
}

crée_crée_chaine :: fonc (génératrice: &GénératriceCodeBinaire, chn: ECMAString) -> Registre
{
    dst := génératrice.alloue_registre()
    résultat := génératrice.crée_instruction(InstructionCréeChaine)
    résultat.dst = dst
    résultat.chn = chn
    retourne dst
}

crée_crée_objet :: fonc (génératrice: &GénératriceCodeBinaire) -> Registre
{
    dst := génératrice.alloue_registre()
    résultat := génératrice.crée_instruction(InstructionCréeObjet)
    résultat.dst = dst
    retourne dst
}

crée_expression_binaire :: fonc (génératrice: &GénératriceCodeBinaire, gauche: Registre, droite: Registre, $T: type_de_données) -> Registre
{
    dst := génératrice.alloue_registre()
    ajout := génératrice.crée_instruction(T)
    ajout.dst = dst
    ajout.gch = gauche
    ajout.drt = droite
    retourne dst
}

crée_ajoute :: fonc (génératrice: &GénératriceCodeBinaire, gauche: Registre, droite: Registre) -> Registre
{
    retourne crée_expression_binaire(génératrice, gauche, droite, InstructionAjoute)
}

crée_soustrait :: fonc (génératrice: &GénératriceCodeBinaire, gauche: Registre, droite: Registre) -> Registre
{
    retourne crée_expression_binaire(génératrice, gauche, droite, InstructionSoustrait)
}

crée_relation_inférieure :: fonc (génératrice: &GénératriceCodeBinaire, gauche: Registre, droite: Registre) -> Registre
{
    retourne crée_expression_binaire(génératrice, gauche, droite, InstructionRelationInférieure)
}

crée_comparaison_égal :: fonc (génératrice: &GénératriceCodeBinaire, gauche: Registre, droite: Registre) -> Registre
{
    retourne crée_expression_binaire(génératrice, gauche, droite, InstructionComparaisonÉgal)
}

crée_comparaison_inégal :: fonc (génératrice: &GénératriceCodeBinaire, gauche: Registre, droite: Registre) -> Registre
{
    retourne crée_expression_binaire(génératrice, gauche, droite, InstructionComparaisonInégal)
}

crée_définis_locale :: fonc (génératrice: &GénératriceCodeBinaire, nom: ECMAString, src: Registre) -> Registre
{
    résultat := génératrice.crée_instruction(InstructionDéfinisLocale)
    résultat.nom = nom
    résultat.src = src
    retourne Registre(-1 comme n32) // À FAIRE : Optionnel(Registre)
}

crée_charge_locale :: fonc (génératrice: &GénératriceCodeBinaire, nom: ECMAString) -> Registre
{
    dst := génératrice.alloue_registre()
    résultat := génératrice.crée_instruction(InstructionChargeLocale)
    résultat.dst = dst
    résultat.nom = nom
    retourne dst
}

alloue_registre :: fonc (empl génératrice: &GénératriceCodeBinaire) -> Registre
{
    résultat := Registre(flux.registres)
    flux.registres += 1
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom InterprèteCodeBinaire
 * \{ */

InterprèteCodeBinaire :: struct {
    empl base: Interpréteuse
    registres: [..]Valeur
}

interprète_code_binaire :: fonc (mv: *MachineVirtuelle, noeud: *NoeudScript) -> CompletionRecord
{
    flux := loge(FluxDInstructions)
    génératrice := GénératriceCodeBinaire(flux)

    _ := génère_code_binaire(génératrice, noeud)

    imprime_instructions(flux)

    interprète: InterprèteCodeBinaire
    interprète.mv = mv
    tableau_redimensionne(interprète.registres, flux.registres comme z64)

    début := flux.instructions.pointeur
    courant := début
    fin := début + flux.instructions.taille

    tantque courant < fin {
        it := courant comme *Instruction
        courant += donne_taille_octet(it)

        discr it.type {
            InstructionBranche {
                branche := it comme *InstructionBranche
                courant = début + branche.décalage comme z64
                continue
            }
            InstructionBrancheSiFaux {
                branche := it comme *InstructionBrancheSiFaux

                valeur := interprète.registres[branche.reg]

                si est_false(valeur) {
                    courant = début + branche.décalage comme z64
                    continue
                }
            }
            InstructionBrancheSiVrai {
                branche := it comme *InstructionBrancheSiVrai

                valeur := interprète.registres[branche.reg]

                si est_true(valeur) {
                    courant = début + branche.décalage comme z64
                    continue
                }
            }
            InstructionCharge {
                inst_charge := it comme *InstructionCharge
                interprète.registres[inst_charge.reg] = inst_charge.vlr
            }
            InstructionAjoute {
                inst_ajout := it comme *InstructionAjoute
                gauche := interprète.registres[inst_ajout.gch]
                droite := interprète.registres[inst_ajout.drt]

                completion := apply_string_or_numeric_binary_operator(*interprète, BinaryOperation.Plus, gauche, droite)
                saufsi completion.est_normal() {
                    retourne completion
                }
                interprète.registres[inst_ajout.dst] = completion.valeur.V
            }
            InstructionSoustrait {
                inst := it comme *InstructionSoustrait
                gauche := interprète.registres[inst.gch]
                droite := interprète.registres[inst.drt]

                completion := apply_string_or_numeric_binary_operator(*interprète, BinaryOperation.Moins, gauche, droite)
                saufsi completion.est_normal() {
                    retourne completion
                }
                interprète.registres[inst.dst] = completion.valeur.V
            }
            InstructionRelationInférieure {
                relat := it comme *InstructionRelationInférieure
                gauche := interprète.registres[relat.gch]
                droite := interprète.registres[relat.drt]

                completion := is_less_than(*interprète, gauche, droite, vrai)
                saufsi completion.est_normal() {
                    retourne completion
                }
                r := completion.valeur.V

                si r.est_undefined() {
                    r = Valeur(Boolean = faux)
                }
                interprète.registres[relat.dst] = completion.valeur.V
            }
            InstructionComparaisonÉgal {
                inst_ajout := it comme *InstructionComparaisonÉgal
                gauche := interprète.registres[inst_ajout.gch]
                droite := interprète.registres[inst_ajout.drt]

                completion := is_loosely_equal(*interprète, gauche, droite)
                saufsi completion.est_normal() {
                    retourne completion
                }
                interprète.registres[inst_ajout.dst] = completion.valeur.V
            }
            InstructionComparaisonInégal {
                inst_ajout := it comme *InstructionComparaisonInégal
                gauche := interprète.registres[inst_ajout.gch]
                droite := interprète.registres[inst_ajout.drt]

                completion := is_loosely_equal(*interprète, gauche, droite)
                saufsi completion.est_normal() {
                    retourne completion
                }
                résultat := completion.valeur.V
                si résultat.est_true() {
                    résultat.Boolean = faux
                }
                sinon {
                    résultat.Boolean = vrai
                }
                interprète.registres[inst_ajout.dst] = résultat
            }
            InstructionCréeChaine {
                crée_chaine := it comme *InstructionCréeChaine

                realm := donne_realm(*interprète)

                chn: *PrimitiveChaine
                si crée_chaine.index_chaine == -1 {
                    chn = crée_chaine(realm, crée_chaine.chn)
                    tableau_ajoute(*realm.chaines_littérales, chn)
                    crée_chaine.index_chaine = realm.chaines_littérales.taille - 1
                }
                sinon {
                    chn = realm.chaines_littérales[crée_chaine.index_chaine]
                }

                interprète.registres[crée_chaine.dst] = Valeur(String = chn)
            }
            InstructionCréeObjet {
                crée_objet := it comme *InstructionCréeObjet

                realm := donne_realm(*interprète)
                objet := ordinary_object_create(realm, realm.intrinsics.object_prototype, object_instance_crée)
                interprète.registres[crée_objet.dst] = Valeur(Object = objet)
            }
            InstructionDéfinisLocale {
                définis_locale := it comme *InstructionDéfinisLocale
                realm := donne_realm(*interprète)

                résultat := resolve_binding(*interprète, définis_locale.donne_chaine_primitive(realm))
                saufsi résultat.est_normal() {
                    retourne résultat
                }

                // À FAIRE
                // référence := résultat.valeur.R
                // noeud.coordonnée = référence.coordonnée

                valeur := interprète.registres[définis_locale.src]
                completion_assignment := put_value(*interprète, résultat.valeur, valeur)
                saufsi completion_assignment.est_normal() {
                    retourne completion_assignment
                }
            }
            InstructionChargeLocale {
                charge_locale := it comme *InstructionChargeLocale
                realm := donne_realm(*interprète)

                résultat := resolve_binding(*interprète, charge_locale.donne_chaine_primitive(realm))
                saufsi résultat.est_normal() {
                    retourne résultat
                }

                completion_rval := get_value(*interprète, résultat.valeur)
                saufsi completion_rval.est_normal() {
                    retourne completion_rval
                }
                interprète.registres[charge_locale.dst] = completion_rval.valeur.V
            }
            sinon {
                imprime("intruction inconnue!\n")
                arrête
            }
        }
    }

    imprime_registres(*interprète)
    retourne normal_completion(js_undefined)
}

imprime_registres :: fonc (interprète: *InterprèteCodeBinaire)
{
    imprime("Registres :\n")

    pour interprète.registres {
        imprime("- [%] %\n", index_it, it)
    }
}

/** \} */
