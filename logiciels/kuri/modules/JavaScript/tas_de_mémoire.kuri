importe Ensemble
importe Fondation

DÉBOGUGE_MÉMOIRE :: vrai

/* ------------------------------------------------------------------------- */
/** \nom TasDeMémoire
 * Allocatrice servant de ramasse-miette "marque et balaie"
 * \{ */

TasDeMémoire :: struct {
    realm: *Realm
    blocs: [..]*BlocDeMémoire

    doit_ébouer_à_chaque_allocation := faux
    allocations_entre_ébouages := 1000
    allocations_depuis_dernier_ébouage := 0
}

détruit_données_tas_de_mémoire :: fonc (tas_de_mémoire: *TasDeMémoire)
{
    pour tas_de_mémoire.blocs {
        déloge_mémoire(BlocDeMémoire.TAILLE_BLOC comme z64, it, info_de(BlocDeMémoire), PositionCodeSource())
    }

    déloge(tas_de_mémoire.blocs)
}

alloue :: fonc (tas_de_mémoire: *TasDeMémoire, $T: type_de_données) -> *T
{
    résultat := alloue_cellule(tas_de_mémoire, taille_de(T)) comme *T
    init_de(T)(résultat)
    retourne résultat
}

alloue_cellule :: fonc (tas_de_mémoire: *TasDeMémoire, taille: n64) -> *rien
{
    si tas_de_mémoire.doit_ébouer_à_chaque_allocation {
        éboue(tas_de_mémoire)
    }
    sinon si tas_de_mémoire.allocations_depuis_dernier_ébouage > tas_de_mémoire.allocations_entre_ébouages {
        éboue(tas_de_mémoire)
    }

    pour tas_de_mémoire.blocs {
        si taille > it.taille_cellule {
            continue
        }

        cellule := it.alloue_cellule()
        si cellule {
            retourne cellule
        }

        arrête
    }

    mémoire_bloc := loge_mémoire_alignée(BlocDeMémoire.TAILLE_BLOC comme z64, BlocDeMémoire.TAILLE_BLOC comme z64, info_de(BlocDeMémoire), PositionCodeSource())
    bloc := mémoire_bloc comme *BlocDeMémoire
    init_de(BlocDeMémoire)(bloc)

    initialise_bloc(bloc, taille)

    bloc.tas_de_mémoire = tas_de_mémoire
    tableau_ajoute(*tas_de_mémoire.blocs, bloc)

    tas_de_mémoire.allocations_depuis_dernier_ébouage += 1

    retourne bloc.alloue_cellule()
}

TypeÉbouage :: énum {
    RAMASSE_MIETTES
    /* À n'utiliser que pour la destruction. */
    RAMASSE_TOUT
}

/* Ramasse les miettes. */
éboue :: fonc (tas_de_mémoire: *TasDeMémoire, type_ébouage := TypeÉbouage.RAMASSE_MIETTES)
{
    racines: [..]*Cellule
    diffère déloge(racines)
    si type_ébouage == TypeÉbouage.RAMASSE_MIETTES {
        rassemble_racines(tas_de_mémoire, *racines)
    }

    cellules_vivantes: [..]*Cellule
    diffère déloge(cellules_vivantes)
    visite_cellules_vivantes(tas_de_mémoire, racines, *cellules_vivantes)

    réinitialise_bits_de_marquage(tas_de_mémoire)
    marque_cellules_vivantes(tas_de_mémoire, *cellules_vivantes)
    balaie_cellules_mortes(tas_de_mémoire)

    tas_de_mémoire.allocations_depuis_dernier_ébouage = 0
}

rassemble_racines :: fonc (tas_de_mémoire: *TasDeMémoire, racines: *[..]*Cellule)
{
    si tas_de_mémoire.realm {
        ensemble_ajoute(racines, tas_de_mémoire.realm)
    }

    rassemble_racines_en_mémoire(tas_de_mémoire, racines)

    #si DÉBOGUGE_MÉMOIRE {
        imprime("% (% racine(s))\n", #nom_de_cette_fonction, racines.taille)
        pour mémoire(racines) {
            imprime("    + %\n", it)
        }
    }
}

rassemble_racines_en_mémoire :: fonc (tas_de_mémoire: *TasDeMémoire, racines: *[..]*Cellule)
{
    /* Marqueur pour savoir la fin de la pile de données d'exécution. */
    marqueur_pile: n64

    /* Rassemble les cellules sur la pile d'exécution. */
    début_pile := (*marqueur_pile) - 1
    fin_pile := __début_pile
    tantque début_pile < fin_pile {
        cellule_possible := mémoire(début_pile) comme *Cellule
        ajoute_racine_depuis_cellule_possible(tas_de_mémoire, cellule_possible, racines)
        début_pile += 1
    }
}

ajoute_racine_depuis_cellule_possible :: fonc (tas_de_mémoire: *TasDeMémoire, cellule_possible: *Cellule, racines: *[..]*Cellule)
{
    pour tas_de_mémoire.blocs {
        saufsi it == donne_bloc_de_mémoire(cellule_possible) {
            continue
        }

        adresse_bloc := (it + 1) comme *octet
        assert(adresse_bloc == it.donne_cellule(0))
        fin_bloc := it comme *octet + BlocDeMémoire.TAILLE_BLOC

        saufsi adresse_bloc <= cellule_possible < fin_bloc {
            continue
        }

        décalage_cellule := (cellule_possible - adresse_bloc) comme n64
        index_cellule := décalage_cellule / it.taille_cellule

        si cellule_possible.vivante && cellule_possible == it.donne_cellule(index_cellule) {
            ensemble_ajoute(racines, cellule_possible)
        }
    }
}

visite_cellules_vivantes :: fonc (tas_de_mémoire: *TasDeMémoire @inutilisée, racines: []*Cellule, cellules_vivantes: *[..]*Cellule)
{
    VisiteuseVivance :: struct {
        empl base: VisiteuseCellule

        cellules_vivantes: *[..]*Cellule
    }

    sur_a_visité :: fonc (base: *VisiteuseCellule, cellule: *Cellule)
    {
        visiteuse := base comme *VisiteuseVivance
        ensemble_ajoute(visiteuse.cellules_vivantes, cellule)
    }

    sur_a_déjà_visité :: fonc (base: *VisiteuseCellule, cellule: *Cellule) -> bool
    {
        visiteuse := base comme *VisiteuseVivance
        retourne ensemble_possède(visiteuse.cellules_vivantes, cellule)
    }

    visiteuse: VisiteuseVivance
    visiteuse.cellules_vivantes = cellules_vivantes
    visiteuse.sur_a_visité = sur_a_visité
    visiteuse.sur_a_déjà_visité = sur_a_déjà_visité

    pour racines {
        it.visite_graphe(*visiteuse)
    }

    #si DÉBOGUGE_MÉMOIRE {
        imprime("%\n", #nom_de_cette_fonction)
        pour mémoire(cellules_vivantes) {
            imprime("    @ %\n", it)
        }
    }
}

réinitialise_bits_de_marquage :: fonc (tas_de_mémoire: *TasDeMémoire)
{
    pour tas_de_mémoire.blocs {
        pour cellule dans it {
            cellule.marqué = faux
        }
    }
}

marque_cellules_vivantes :: fonc (tas_de_mémoire: *TasDeMémoire, cellules_vivantes: *[..]*Cellule)
{
    #si DÉBOGUGE_MÉMOIRE {
        imprime("%\n", #nom_de_cette_fonction)
    }

    pour tas_de_mémoire.blocs {
        pour cellule dans it {
            si ensemble_possède(cellules_vivantes, cellule) {
                cellule.marqué = vrai
                #si DÉBOGUGE_MÉMOIRE {
                    imprime("    ! %\n", cellule)
                }
            }
        }
    }
}

balaie_cellules_mortes :: fonc (tas_de_mémoire: *TasDeMémoire)
{
    #si DÉBOGUGE_MÉMOIRE {
        imprime("%\n", #nom_de_cette_fonction)
    }

    pour tas_de_mémoire.blocs {
        pour cellule dans it {
            si cellule.vivante && !cellule.marqué {
                it.désalloue(cellule)
                #si DÉBOGUGE_MÉMOIRE {
                    imprime("    ~ %\n", cellule)
                }
            }
        }
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom BlocDeMémoire
 * Mémoire pour allouer des Cellules.
 * \{ */

BlocDeMémoire :: struct {
    TAILLE_BLOC : n64 : 16 * 1024
    
    taille_cellule: n64
    tas_de_mémoire: *TasDeMémoire

    EntréeListeLibre :: struct {
        empl base: Cellule
        suivante: *EntréeListeLibre
    }

    liste_libre: *EntréeListeLibre
}

initialise_bloc :: fonc (bloc: *BlocDeMémoire, taille_cellule: n64)
{
    bloc.taille_cellule = taille_cellule

    pour bloc {
        liste := it comme *BlocDeMémoire.EntréeListeLibre
        liste.vivante = faux

        si index_it comme n64 == bloc.nombre_de_cellules() - 1 {
            liste.suivante = nul
        }
        sinon {
            liste.suivante = bloc.donne_cellule(index_it comme n64 + 1) comme *BlocDeMémoire.EntréeListeLibre
        }
    }

    bloc.liste_libre = bloc.donne_cellule(0) comme *BlocDeMémoire.EntréeListeLibre
}

nombre_de_cellules :: fonc (bloc: *BlocDeMémoire) -> n64
{
    retourne (BlocDeMémoire.TAILLE_BLOC - taille_de(BlocDeMémoire)) / bloc.taille_cellule
}

donne_cellule :: fonc (bloc: *BlocDeMémoire, index: n64) -> *Cellule
{
    stockage := (bloc + 1) comme *octet
    retourne (stockage + index * bloc.taille_cellule) comme *Cellule
}

alloue_cellule :: fonc (bloc: *BlocDeMémoire) -> *Cellule
{
    saufsi bloc.liste_libre {
        retourne nul
    }

    résultat := bloc.liste_libre
    bloc.liste_libre = bloc.liste_libre.suivante
    retourne résultat
}

désalloue :: fonc (bloc: *BlocDeMémoire, cellule: *Cellule)
{
    assert(cellule.vivante == vrai)
    assert(cellule.marqué == faux)

    détruit_cellule(cellule)

    entrée := cellule comme *BlocDeMémoire.EntréeListeLibre
    entrée.vivante = faux
    entrée.suivante = bloc.liste_libre
    bloc.liste_libre = entrée
}

opérateur pour :: fonc (bloc: *BlocDeMémoire) -> *Cellule
{
    pour bloc.nombre_de_cellules() {
        cellule := bloc.donne_cellule(index_it)

        `it = cellule
        `index_it = index_it comme z64

        #corps_boucle
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Cellule
 * Structure de base pour être éboué.
 * \{ */

Cellule :: struct {
    type := #type_de_cette_structure
    sur_destruction: fonc(*Cellule)(rien)
    sur_visite_graphe := cellule_sur_visite_graphe

    marqué := faux
    vivante := vrai
}

donne_nom_classe :: fonc (cellule: *Cellule) -> chaine
{
    infos := __table_des_types[cellule.type] comme *InfoTypeStructure
    retourne infos.nom
}

imprime_cellule :: fonc (enchaineuse: *Enchaineuse, addr_cellule: **Cellule)
{
    saufsi addr_cellule && mémoire(addr_cellule) {
        ajoute_au_tampon(enchaineuse, "{nul}")
        retourne
    }

    cellule := mémoire(addr_cellule)
    imprime_dans_enchaineuse(enchaineuse, "%{%}", cellule.donne_nom_classe(), cellule comme *rien)
} @FormattageImpression

cellule_sur_visite_graphe :: fonc (cellule: *Cellule, visiteuse: *VisiteuseCellule)
{
    visiteuse.a_visité(cellule)
}

détruit_cellule :: fonc (cellule: *Cellule)
{
    si cellule.sur_destruction {
        cellule.sur_destruction(cellule)
    }
}

visite_graphe :: fonc (cellule: *Cellule, visiteuse: *VisiteuseCellule)
{
    saufsi cellule {
        retourne
    }

    si visiteuse.a_déjà_visité(cellule) {
        retourne
    }

    si cellule.sur_visite_graphe {
        cellule.sur_visite_graphe(cellule, visiteuse)
    }
}

donne_bloc_de_mémoire :: fonc (cellule: *Cellule) -> *BlocDeMémoire #enligne
{
    v := cellule comme n64
    retourne (v & ~(BlocDeMémoire.TAILLE_BLOC - 1)) comme *BlocDeMémoire
}

donne_tas_de_mémoire :: fonc (cellule: *Cellule) -> *TasDeMémoire #enligne
{
    bloc := cellule.donne_bloc_de_mémoire()
    retourne bloc.tas_de_mémoire
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom VisiteuseCellule
 * \{ */

VisiteuseCellule :: struct {
    sur_a_visité: fonc(*VisiteuseCellule, *Cellule)(rien)
    sur_a_déjà_visité: fonc(*VisiteuseCellule, *Cellule)(bool)
}

a_visité :: fonc (visiteuse: *VisiteuseCellule, cellule: *Cellule)
{
    si visiteuse.sur_a_visité {
        visiteuse.sur_a_visité(visiteuse, cellule)
    }
}

a_déjà_visité :: fonc (visiteuse: *VisiteuseCellule, cellule: *Cellule) -> bool
{
    si visiteuse.sur_a_déjà_visité {
        retourne visiteuse.sur_a_déjà_visité(visiteuse, cellule)
    }

    retourne faux
}

/** \} */
