importe Fondation
importe Introspection


/* ------------------------------------------------------------------------- */
/** \nom NoeudSyntaxique
 * \{ */

NoeudSyntaxique :: struct {
    type := #type_de_cette_structure

    sur_ex√©cution: fonc(*NoeudSyntaxique, &Interpr√©teuse)(CompletionRecord)
}

ex√©cute_noeud :: fonc (noeud: *NoeudSyntaxique, interpr√©teuse: &Interpr√©teuse) -> CompletionRecord
{
    // imprime("Ex√©cution de %\n", noeud.type)
    retourne noeud.sur_ex√©cution(noeud, interpr√©teuse)
}

/* 8.4.3 Static Semantics: IsAnonymousFunctionDefinition
 * https://tc39.es/ecma262/multipage/syntax-directed-operations.html#sec-isanonymousfunctiondefinition */
is_anonymous_function_definition :: fonc (noeud: *NoeudSyntaxique @inutilis√©e) -> bool
{
    // √Ä FAIRE
    retourne faux
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NoeudScope
 * Type Utilis√© pour Interpr√©teuse.ex√©cute
 * \{ */

NoeudScope :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_scope

    enfants: [..]*NoeudSyntaxique
}

sur_ex√©cution_scope :: fonc (noeud: *NoeudSyntaxique, interpr√©teuse: &Interpr√©teuse) -> CompletionRecord
{
    retourne interpr√©teuse.ex√©cute(noeud comme *NoeudScope, TypeScope.BLOC)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Programme
 * \{ */

Programme :: struct {
    empl scope: NoeudScope
    type = #type_de_cette_structure

    type_source := "script"
}

cr√©e_programme :: fonc (expressions: ...*NoeudSyntaxique) -> *Programme
{
    r√©sultat := loge(Programme)
    pour expressions {
        tableau_ajoute(*r√©sultat.enfants, it)
    }
    retourne r√©sultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom FunctionDeclaration
 * \{ */

FunctionDeclaration :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_function_declaration

    id: *Identifier
    params: [..]*NoeudSyntaxique
    corps: *NoeudSyntaxique

    generator := faux
    expression := faux
    async := faux
}

cr√©e_function_d√©claration :: fonc (id: *Identifier, params: []*NoeudSyntaxique, corps: *NoeudSyntaxique) -> *FunctionDeclaration
{
    r√©sultat := loge(FunctionDeclaration)
    r√©sultat.id = id
    r√©sultat.corps = corps
    pour params {
        tableau_ajoute(*r√©sultat.params, it)
    }
    retourne r√©sultat
}

sur_ex√©cution_function_declaration :: fonc (base: *NoeudSyntaxique, interpr√©teuse: &Interpr√©teuse) -> CompletionRecord
{
    noeud := base comme *FunctionDeclaration

    fonction := cr√©e_fonction(interpr√©teuse.donne_tas_de_m√©moire(), noeud.id.nom, noeud.corps)

    objet_global := interpr√©teuse.objet_global
    objet_global.d√©finis_valeur(noeud.id.nom, Valeur(Function = fonction))

    retourne normal_completion(Valeur(Function = fonction))
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Identifier
 * \{ */

Identifier :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_identifier

    nom: ECMAString
}

cr√©e_identifier :: fonc (nom: ECMAString) -> *Identifier
{
    r√©sultat := loge(Identifier)
    r√©sultat.nom = nom
    retourne r√©sultat
}

sur_ex√©cution_identifier :: fonc (base: *NoeudSyntaxique, interpr√©teuse: &Interpr√©teuse) -> CompletionRecord
{
    noeud := base comme *Identifier
    retourne resolve_binding(interpr√©teuse, noeud.nom)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom BlockStatement
 * \{ */

BlockStatement :: struct {
    empl scope: NoeudScope
    type = #type_de_cette_structure
}

cr√©e_block_statement :: fonc (expressions: ...*NoeudSyntaxique) -> *BlockStatement
{
    r√©sultat := loge(BlockStatement)
    pour expressions {
        tableau_ajoute(*r√©sultat.enfants, it)
    }
    retourne r√©sultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ReturnStatement
 * \{ */

ReturnStatement :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_return

    argument: *NoeudSyntaxique
}

cr√©e_return_statement :: fonc (argument: *NoeudSyntaxique) -> *ReturnStatement
{
    r√©sultat := loge(ReturnStatement)
    r√©sultat.argument = argument
    retourne r√©sultat
}

sur_ex√©cution_return :: fonc (base: *NoeudSyntaxique, interpr√©teuse: &Interpr√©teuse) -> CompletionRecord
{
    noeud := base comme *ReturnStatement

    r√©sultat := return_completion(js_null)

    si noeud.argument {
        r√©sultat = ex√©cute_noeud(noeud.argument, interpr√©teuse)
        si r√©sultat.est_normal() {
            retourne return_completion(r√©sultat.valeur)
        }
    }

    retourne r√©sultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom BinaryExpression
 * \{ */

BinaryOperation :: √©num {
    Plus
    Moins
    Multiplie
    Divise

    Sup√©rieur
    Inf√©rieur
    Sup√©rieur√âgal
    Inf√©rieur√âgal

    √âgal
    In√©gal
}

BinaryExpression :: struct {
    empl  base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_binary_expression

    op√©ration: BinaryOperation
    gauche: *NoeudSyntaxique
    droite: *NoeudSyntaxique
}

cr√©e_binary_expression :: fonc (op√©ration: BinaryOperation, gauche: *NoeudSyntaxique, droite: *NoeudSyntaxique) -> *BinaryExpression
{
    r√©sultat := loge(BinaryExpression)
    r√©sultat.op√©ration = op√©ration
    r√©sultat.gauche = gauche
    r√©sultat.droite = droite
    retourne r√©sultat
}


sur_ex√©cution_binary_expression :: fonc (base: *NoeudSyntaxique, interpr√©teuse: &Interpr√©teuse) -> CompletionRecord
{
    noeud := base comme *BinaryExpression
    completion_gauche := ex√©cute_noeud(noeud.gauche, interpr√©teuse)
    saufsi completion_gauche.est_normal() {
        retourne completion_gauche
    }
    completion_droite := ex√©cute_noeud(noeud.droite, interpr√©teuse)
    saufsi completion_droite.est_normal() {
        retourne completion_droite
    }
    valeur_compl√©tion_gauche := get_value(interpr√©teuse, completion_gauche.valeur)
    si valeur_compl√©tion_gauche.poss√®de_erreur() {
        retourne valeur_compl√©tion_gauche.Erreur
    }
    valeur_compl√©tion_droite := get_value(interpr√©teuse, completion_droite.valeur)
    si valeur_compl√©tion_droite.poss√®de_erreur() {
        retourne valeur_compl√©tion_droite.Erreur
    }
    gauche := valeur_compl√©tion_gauche.Ok
    droite := valeur_compl√©tion_droite.Ok
    retourne normal_completion(√©value_expression_binaire(noeud.op√©ration, gauche, droite))
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-applystringornumericbinaryoperator */
√©value_expression_binaire :: fonc (op√©ration: BinaryOperation, gauche: Valeur, droite: Valeur) -> Valeur
{
    // si op√©ration == BinaryOperation.Plus {
    //     primitive_gauche := vers_primitive(gauche)
    //     primitive_droite := vers_primitive(droite)

    //     si primitive_gauche.est_chaine() || primitive_droite.est_chaine() {
    //         str_gauche := primitive_gauche.vers_chaine()
    //         str_droite := primitive_droite.vers_chaine()

    //         retourne concat√®ne(str_gauche, str_droite)
    //     }

    //     gauche = primitive_gauche
    //     droite = primitive_droite
    // }

    // nombre_gauche := vers_numeric(gauche)
    // nombre_droite := vers_numeric(droite)

    // If Type(lnum) != Type(rnum)

    discr op√©ration {
        Plus {
            retourne ajoute_valeurs(gauche, droite)
        }
        Moins {
            retourne soustrait_valeurs(gauche, droite)
        }
        Multiplie {
            retourne multiplie_valeurs(gauche, droite)
        }
        Divise {
            retourne divise_valeurs(gauche, droite)
        }
        Sup√©rieur {
            retourne compare_sup√©rieur_valeurs(gauche, droite)
        }
        Inf√©rieur {
            retourne compare_inf√©rieur_valeurs(gauche, droite)
        }
        Sup√©rieur√âgal {
            retourne compare_sup√©rieur_√©gal_valeurs(gauche, droite)
        }
        Inf√©rieur√âgal {
            retourne compare_inf√©rieur_√©gal_valeurs(gauche, droite)
        }
        √âgal {
            retourne compare_√©gal_valeurs(gauche, droite)
        }
        In√©gal {
            retourne compare_in√©gal_valeurs(gauche, droite)
        }
    }

    retourne js_undefined
}

ajoute_valeurs :: fonc (gauche: Valeur, droite: Valeur) -> Valeur
{
    assert(gauche.est_nombre())
    assert(droite.est_nombre())
    retourne Valeur(Number = gauche.Number + droite.Number)
}

soustrait_valeurs :: fonc (gauche: Valeur, droite: Valeur) -> Valeur
{
    assert(gauche.est_nombre())
    assert(droite.est_nombre())
    retourne Valeur(Number = gauche.Number - droite.Number)
}

multiplie_valeurs :: fonc (gauche: Valeur, droite: Valeur) -> Valeur
{
    assert(gauche.est_nombre())
    assert(droite.est_nombre())
    retourne Valeur(Number = gauche.Number * droite.Number)
}

divise_valeurs :: fonc (gauche: Valeur, droite: Valeur) -> Valeur
{
    assert(gauche.est_nombre())
    assert(droite.est_nombre())
    retourne Valeur(Number = gauche.Number / droite.Number)
}

compare_sup√©rieur_valeurs :: fonc (gauche: Valeur, droite: Valeur) -> Valeur
{
    assert(gauche.est_nombre())
    assert(droite.est_nombre())
    retourne Valeur(Boolean = gauche.Number > droite.Number)
}

compare_inf√©rieur_valeurs :: fonc (gauche: Valeur, droite: Valeur) -> Valeur
{
    assert(gauche.est_nombre())
    assert(droite.est_nombre())
    retourne Valeur(Boolean = gauche.Number < droite.Number)
}

compare_sup√©rieur_√©gal_valeurs :: fonc (gauche: Valeur, droite: Valeur) -> Valeur
{
    assert(gauche.est_nombre())
    assert(droite.est_nombre())
    retourne Valeur(Boolean = gauche.Number >= droite.Number)
}

compare_inf√©rieur_√©gal_valeurs :: fonc (gauche: Valeur, droite: Valeur) -> Valeur
{
    assert(gauche.est_nombre())
    assert(droite.est_nombre())
    retourne Valeur(Boolean = gauche.Number <= droite.Number)
}

compare_√©gal_valeurs :: fonc (gauche: Valeur, droite: Valeur) -> Valeur
{
    assert(gauche.est_nombre())
    assert(droite.est_nombre())
    retourne Valeur(Boolean = gauche.Number == droite.Number)
}

compare_in√©gal_valeurs :: fonc (gauche: Valeur, droite: Valeur) -> Valeur
{
    assert(gauche.est_nombre())
    assert(droite.est_nombre())
    retourne Valeur(Boolean = gauche.Number != droite.Number)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NumericLiteral
 * \{ */

NumericLiteral :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_numeric_literal

    valeur: r64
    // raw: ECMAString
}

cr√©e_literal :: fonc (valeur: r64) -> *NumericLiteral
{
    r√©sultat := loge(NumericLiteral)
    r√©sultat.valeur = valeur
    retourne r√©sultat
}

sur_ex√©cution_numeric_literal :: fonc (base: *NoeudSyntaxique, interpr√©teuse: &Interpr√©teuse @inutilis√©e) -> CompletionRecord
{
    noeud := base comme *NumericLiteral
    retourne normal_completion(Valeur(Number = noeud.valeur))
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom StringLiteral
 * \{ */

StringLiteral :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_string_literal

    valeur: ECMAString
}

cr√©e_literal :: fonc (valeur: ECMAString) -> *StringLiteral
{
    r√©sultat := loge(StringLiteral)
    r√©sultat.valeur = valeur
    retourne r√©sultat
}

sur_ex√©cution_string_literal :: fonc (base: *NoeudSyntaxique, interpr√©teuse: &Interpr√©teuse) -> CompletionRecord
{
    noeud := base comme *StringLiteral
    retourne normal_completion(cr√©e_chaine(interpr√©teuse.donne_tas_de_m√©moire(), noeud.valeur))
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ExpressionStatement
 * \{ */

ExpressionStatement :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_expression_statement

    expression: *NoeudSyntaxique
}

cr√©e_expression_statement :: fonc (expression: *NoeudSyntaxique) -> *NoeudSyntaxique
{
    r√©sultat := loge(ExpressionStatement)
    r√©sultat.expression = expression
    retourne r√©sultat
}

sur_ex√©cution_expression_statement :: fonc (base: *NoeudSyntaxique, interpr√©teuse: &Interpr√©teuse) -> CompletionRecord
{
    noeud := base comme *ExpressionStatement
    si noeud.expression {
        retourne ex√©cute_noeud(noeud.expression, interpr√©teuse)
    }
    retourne normal_completion(js_undefined)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom CallExpression
 * \{ */

CallExpression :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_call_expression

    appel√©: *NoeudSyntaxique
    arguments: [..]*NoeudSyntaxique
}

cr√©e_call_expression :: fonc (appel√©: *NoeudSyntaxique, arguments: ...*NoeudSyntaxique) -> *CallExpression
{
    r√©sultat := loge(CallExpression)
    r√©sultat.appel√© = appel√©
    pour arguments {
        tableau_ajoute(*r√©sultat.arguments, it)
    }
    retourne r√©sultat
}

sur_ex√©cution_call_expression :: fonc (base: *NoeudSyntaxique, interpr√©teuse: &Interpr√©teuse) -> CompletionRecord
{
    noeud := base comme *CallExpression

    si noeud.appel√©.type == Identifier {
        id := noeud.appel√© comme *Identifier
        si id.nom == "rm" {
            √©boue(interpr√©teuse.donne_tas_de_m√©moire())
            retourne normal_completion(js_undefined)
        }
    }

    completion_valeur_appel√©e := ex√©cute_noeud(noeud.appel√©, interpr√©teuse)
    saufsi completion_valeur_appel√©e.est_normal() {
        retourne completion_valeur_appel√©e
    }

    valeur_compl√©tion := get_value(interpr√©teuse, completion_valeur_appel√©e.valeur)
    si valeur_compl√©tion.poss√®de_erreur() {
        retourne valeur_compl√©tion.Erreur
    }

    valeur_appel√©e := valeur_compl√©tion.Ok
    assert(valeur_appel√©e.est_fonction())

    fonction := valeur_appel√©e.Function
    retourne interpr√©teuse.ex√©cute(fonction.corps, TypeScope.FUNCTION)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom AssignmentExpression
 * \{ */

AssignmentOperation :: √©num {
    Assigne /* = */
}

AssignmentExpression :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_assignment_expression

    op√©ration: AssignmentOperation
    gauche: *NoeudSyntaxique
    droite: *NoeudSyntaxique
}

cr√©e_assignment_expression :: fonc (op√©ration: AssignmentOperation, gauche: *NoeudSyntaxique, droite: *NoeudSyntaxique) -> *AssignmentExpression
{
    r√©sultat := loge(AssignmentExpression)
    r√©sultat.op√©ration = op√©ration
    r√©sultat.gauche = gauche
    r√©sultat.droite = droite
    retourne r√©sultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-assignment-operators-runtime-semantics-evaluation */
sur_ex√©cution_assignment_expression :: fonc (base: *NoeudSyntaxique, interpr√©teuse: &Interpr√©teuse) -> CompletionRecord
{
    noeud := base comme *AssignmentExpression
    assert(noeud.op√©ration == AssignmentOperation.Assigne)

    // √Ä FAIRE : array literal
    // 1. If LeftHandSideExpression is neither an ObjectLiteral nor an ArrayLiteral, then
    si noeud.gauche.type != ObjectExpression {
        // a. Let lref be ? Evaluation of LeftHandSideExpression.
        completion_lref := ex√©cute_noeud(noeud.gauche, interpr√©teuse)
        saufsi completion_lref.est_normal() {
            retourne completion_lref
        }
        lref := completion_lref.valeur

        rval: Valeur
        // √Ä FAIRE
        // b. If IsAnonymousFunctionDefinition(AssignmentExpression) is true and IsIdentifierRef of LeftHandSideExpression is true, then
            // i. Let lhs be the StringValue of LeftHandSideExpression.
            // ii. Let rval be ? NamedEvaluation of AssignmentExpression with argument lhs.
        // c. Else,
        {
            // i. Let rref be ? Evaluation of AssignmentExpression.
            completion_rref := ex√©cute_noeud(noeud.droite, interpr√©teuse)
            saufsi completion_rref.est_normal() {
                retourne completion_rref
            }
            rref := completion_rref.valeur

            // ii. Let rval be ? GetValue(rref).
            completion_rval := get_value(interpr√©teuse, rref)
            si completion_rval.poss√®de_erreur() {
                retourne completion_rval.Erreur
            }
            rval = completion_rval.Ok
        }

        // d. Perform ? PutValue(lref, rval).
        completion_assignment := put_value(interpr√©teuse, lref, rval)
        si completion_assignment.est_normal() {
            retourne completion_assignment
        }

        // e. Return rval.
        retourne normal_completion(rval)
    }

    panique("assignement expression non-impl√©ment√©")
    // 2. Let assignmentPattern be the AssignmentPattern that is covered by LeftHandSideExpression.
    // 3. Let rref be ? Evaluation of AssignmentExpression.
    // 4. Let rval be ? GetValue(rref).
    // 5. Perform ? DestructuringAssignmentEvaluation of assignmentPattern with argument rval.
    // 6. Return rval.
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom VariableDeclaration
 * \{ */

VariableDeclarationKind :: √©num {
    Let
    Var
}

VariableDeclaration :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_variable_declaration

    nature: VariableDeclarationKind
    expressions: [..]*NoeudSyntaxique
}

cr√©e_variable_declaration :: fonc (nature: VariableDeclarationKind, expressions: ...*NoeudSyntaxique) -> *VariableDeclaration
{
    r√©sultat := loge(VariableDeclaration)
    r√©sultat.nature = nature
    pour expressions {
        tableau_ajoute(*r√©sultat.expressions, it)
    }
    retourne r√©sultat
}

sur_ex√©cution_variable_declaration :: fonc (base: *NoeudSyntaxique, interpr√©teuse: &Interpr√©teuse) -> CompletionRecord
{
    noeud := base comme *VariableDeclaration
    
    derni√®re_valeur := normal_completion(js_undefined)

    /* √Ä FAIRE : diff√©rence entre let et var. */
    pour noeud.expressions {
        derni√®re_valeur = ex√©cute_noeud(it, interpr√©teuse)
    }

    retourne derni√®re_valeur
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom VariableDeclarator
 * \{ */

VariableDeclarator :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_variable_declarator

    id: *NoeudSyntaxique
    init: *NoeudSyntaxique
}

cr√©e_variable_declarator :: fonc (id: *NoeudSyntaxique, init: *NoeudSyntaxique) -> *VariableDeclarator
{
    r√©sultat := loge(VariableDeclarator)
    r√©sultat.id = id
    r√©sultat.init = init
    retourne r√©sultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-variable-statement */
sur_ex√©cution_variable_declarator :: fonc (base: *NoeudSyntaxique, interpr√©teuse: &Interpr√©teuse) -> CompletionRecord
{
    noeud := base comme *VariableDeclarator
    assert(noeud.id.type == Identifier)
    identifier := noeud.id comme *Identifier

    // √Ä FAIRE : cas sans init
    assert(noeud.init != nul)

    // 1. Let bindingId be the StringValue of BindingIdentifier.
    binding_id := identifier.nom

    // 2. Let lhs be ? ResolveBinding(bindingId).
    completion_lhs := interpr√©teuse.resolve_binding(binding_id)
    saufsi completion_lhs.est_normal() {
        retourne completion_lhs
    }
    lhs := completion_lhs.valeur

    valeur := js_undefined
    // 3. If IsAnonymousFunctionDefinition(Initializer) is true, then
    si is_anonymous_function_definition(noeud.init) {
        // a. Let value be ? NamedEvaluation of Initializer with argument bindingId.
        panique("init avec is_anonymous_function non-impl√©ment√©")
    }
    // 4. Else,
    sinon {
        // a. Let rhs be ? Evaluation of Initializer.
        completion_valeur := ex√©cute_noeud(noeud.init, interpr√©teuse)
        saufsi completion_valeur.est_normal() {
            retourne completion_valeur
        }
        // b. Let value be ? GetValue(rhs).
        valeur_compl√©tion := get_value(interpr√©teuse, completion_valeur.valeur)
        si valeur_compl√©tion.poss√®de_erreur() {
            retourne valeur_compl√©tion.Erreur
        }
        valeur = valeur_compl√©tion.Ok
    }

    // 5. Perform ? PutValue(lhs, value).
    completion_put_value := put_value(interpr√©teuse, lhs, valeur)
    saufsi completion_put_value.est_normal() {
        retourne completion_put_value
    }

    // 6. Return EMPTY.
    retourne normal_completion(js_undefined)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ObjectExpression
 * \{ */

ObjectExpression :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_object_expression
}

cr√©e_object_expression :: fonc () -> *ObjectExpression
{
    r√©sultat := loge(ObjectExpression)
    retourne r√©sultat
}

sur_ex√©cution_object_expression :: fonc (base: *NoeudSyntaxique @inutilis√©e, interpr√©teuse: &Interpr√©teuse) -> CompletionRecord
{
    objet := cr√©e_objet(interpr√©teuse.donne_tas_de_m√©moire(), interpr√©teuse.object_prototype)
    retourne normal_completion(Valeur(Object = objet))
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ObjectExpression
 * \{ */

MemberExpression :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_member_expression

    objet: *NoeudSyntaxique
    propri√©t√©: *NoeudSyntaxique
    calcul√© := faux
}

cr√©e_member_expression :: fonc (objet: *NoeudSyntaxique, propri√©t√©: *NoeudSyntaxique) -> *MemberExpression
{
    r√©sultat := loge(MemberExpression)
    r√©sultat.objet = objet
    r√©sultat.propri√©t√© = propri√©t√©
    retourne r√©sultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-property-accessors-runtime-semantics-evaluation */
sur_ex√©cution_member_expression :: fonc (base: *NoeudSyntaxique, interpr√©teuse: &Interpr√©teuse) -> CompletionRecord
{
    membre := base comme *MemberExpression

    assert(membre.propri√©t√©.type == Identifier)
    identifier := membre.propri√©t√© comme *Identifier

    // MemberExpression : MemberExpression . IdentifierName

    // 1. Let baseReference be ? Evaluation of MemberExpression.
    completion_base_reference := ex√©cute_noeud(membre.objet, interpr√©teuse)
    saufsi completion_base_reference.est_normal() {
        retourne completion_base_reference
    }
    base_reference := completion_base_reference.valeur

    // 2. Let baseValue be ? GetValue(baseReference).
    valeur_base_reference := get_value(interpr√©teuse, base_reference)
    si valeur_base_reference.poss√®de_erreur() {
        retourne valeur_base_reference.Erreur
    }
    base_value := valeur_base_reference.Ok

    // 3. Let strict be IsStrict(this MemberExpression).
    // √Ä FAIRE : strict
    strict := faux

    retourne evaluate_property_access_with_identifier_key(base_value, identifier, strict)
}

/* 13.3.4 EvaluatePropertyAccessWithIdentifierKey ( baseValue, identifierName, strict )
 * https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-evaluate-property-access-with-identifier-key */
evaluate_property_access_with_identifier_key :: fonc (base_value: Valeur, identifier_name: *Identifier, strict: bool) -> CompletionRecord
{
    // 1. Let propertyNameString be the StringValue of identifierName.
    property_name_string := identifier_name.nom

    // 2. Return the Reference Record { [[Base]]: baseValue, [[ReferencedName]]: propertyNameString, [[Strict]]: strict, [[ThisValue]]: EMPTY }.
    r√©sultat: ReferenceRecord
    r√©sultat.base = base_value
    r√©sultat.referenced_name = property_name_string
    r√©sultat.strict = strict
    retourne normal_completion(r√©sultat)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom UpdateExpression
 * \{ */

UpdateOperation :: √©num {
    Increment
    Decrement
}

UpdateExpression :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_update_expression

    argument: *NoeudSyntaxique
    operation: UpdateOperation
}

cr√©e_update_expression :: fonc (argument: *NoeudSyntaxique, operation: UpdateOperation) -> *UpdateExpression
{
    r√©sultat := loge(UpdateExpression)
    r√©sultat.argument = argument
    r√©sultat.operation = operation
    retourne r√©sultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-postfix-increment-operator */
sur_ex√©cution_update_expression :: fonc (base: *NoeudSyntaxique, interpr√©teuse: &Interpr√©teuse) -> CompletionRecord
{
    update := base comme *UpdateExpression
    assert(update.argument.type == Identifier)

    // 1. Let lhs be ? Evaluation of LeftHandSideExpression.
    compl√©tion_lhs := ex√©cute_noeud(update.argument, interpr√©teuse)
    saufsi compl√©tion_lhs.est_normal() {
        retourne compl√©tion_lhs
    }
    lhs := compl√©tion_lhs.valeur

    // 2. Let oldValue be ? ToNumeric(? GetValue(lhs)).
    lhs_value := get_value(interpr√©teuse, lhs)
    si lhs_value.poss√®de_erreur() {
        retourne lhs_value.Erreur
    }

    old_value := to_numeric(lhs_value.Ok)

    nouvelle_valeur: Valeur

    // 3. If oldValue is a Number, then
    si est_nombre(old_value) {
        // a. Let newValue be Number::add(oldValue, 1ùîΩ).
        // NOTE : nous faison ++ et -- directement.
        si update.operation == UpdateOperation.Increment {
            nouvelle_valeur = ajoute_valeurs(old_value, Valeur(Number = 1))
        }
        sinon {
            nouvelle_valeur = soustrait_valeurs(old_value, Valeur(Number = 1))
        }
    }
    // 4. Else,
    sinon {
        // a. Assert: oldValue is a BigInt.
        // b. Let newValue be BigInt::add(oldValue, 1‚Ñ§).
        panique("update expression sur BigInt non-impl√©ment√©e")
    }

    // 5. Perform ? PutValue(lhs, newValue).
    compl√©tion_update := put_value(interpr√©teuse, lhs, nouvelle_valeur)
    saufsi compl√©tion_update.est_normal() {
        retourne compl√©tion_update
    }

    // 6. Return oldValue.
    retourne normal_completion(old_value)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ForStatement
 * \{ */

ForStatement :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_for_statement

    init: *NoeudSyntaxique
    test: *NoeudSyntaxique
    update: *NoeudSyntaxique
    body: *NoeudSyntaxique
}

cr√©e_for_statement :: fonc (init: *NoeudSyntaxique, test: *NoeudSyntaxique, update: *NoeudSyntaxique, body: *NoeudSyntaxique) -> *ForStatement
{
    r√©sultat := loge(ForStatement)
    r√©sultat.init = init
    r√©sultat.test = test
    r√©sultat.update = update
    r√©sultat.body = body
    retourne r√©sultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-for-statement */
sur_ex√©cution_for_statement :: fonc (base: *NoeudSyntaxique, interpr√©teuse: &Interpr√©teuse) -> CompletionRecord
{
    for := base comme *ForStatement

    si for.init {
        doit_continuer := ex√©cute_noeud(for.init, interpr√©teuse)
        saufsi doit_continuer.est_normal() {
            retourne doit_continuer
        }
    }

    boucle {
        si for.test {
            doit_continuer := ex√©cute_noeud(for.test, interpr√©teuse)
            saufsi doit_continuer.est_normal() {
                retourne doit_continuer
            }
            valeur_compl√©tion := get_value(interpr√©teuse, doit_continuer.valeur)
            si valeur_compl√©tion.poss√®de_erreur() {
                retourne valeur_compl√©tion.Erreur
            }

            valeur := valeur_compl√©tion.Ok
            assert(valeur.est_boolean())

            si valeur.est_false() {
                arr√™te
            }
        }

        si for.update {
            doit_continuer := ex√©cute_noeud(for.update, interpr√©teuse)
            saufsi doit_continuer.est_normal() {
                retourne doit_continuer
            }
        }

        doit_continuer := ex√©cute_noeud(for.body, interpr√©teuse)
        saufsi doit_continuer.est_normal() {
            retourne doit_continuer
        }
    }

    retourne normal_completion(js_undefined)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Visiteuse arbre.
 * \{ */

DirectionVisiteNoeud :: √©num {
    PR√â_ORDRE
    POST_ORDRE
}

VisiteuseNoeud :: struct {
    arbre: *NoeudSyntaxique
    rappel_pour_noeud: fonc(*VisiteuseNoeud, *NoeudSyntaxique, *InfoTypeStructure)(rien)
    rappel_pour_tableau: fonc(*VisiteuseNoeud, [..]*NoeudSyntaxique)(rien)
    profondeur: z32
    direction_visite: DirectionVisiteNoeud
}

donne_info_pour_type_noeud :: fonc (racine: *NoeudSyntaxique) -> *InfoTypeStructure
{
    r√©sultat := __table_des_types[racine.type] comme *InfoTypeStructure
    assert(est_struct_ou_employeuse_de(r√©sultat, info_de(NoeudSyntaxique)))
    retourne r√©sultat
}

visite_noeud :: fonc (visiteuse: *VisiteuseNoeud, racine: *NoeudSyntaxique, $Rappel: fonc(*VisiteuseNoeud, *NoeudSyntaxique, *InfoTypeStructure)(rien))
{
    infos := donne_info_pour_type_noeud(racine)
    Rappel(visiteuse, racine, infos)
}

visite_noeud_g√©n√©rique :: fonc (visiteuse: *VisiteuseNoeud, racine: *NoeudSyntaxique, info: *InfoTypeStructure)
{
    si visiteuse.direction_visite == DirectionVisiteNoeud.PR√â_ORDRE && visiteuse.rappel_pour_noeud {
        visiteuse.rappel_pour_noeud(visiteuse, racine, info)
    }

    valeur_eini : eini = ---
    valeur_eini.pointeur = racine
    valeur_eini.info = info

    pour info.membres {
        si it.id == info_de(*NoeudSyntaxique) {
            membre := eini_depuis_info_membre(valeur_eini, it)
            expression := m√©moire(membre.pointeur comme **NoeudSyntaxique)
            si expression == nul {
                continue
            }

            si poss√®de_annotation(it, "NeVisitePas") {
                continue
            }

            visiteuse.profondeur += 1
            visite_noeud(visiteuse, expression, visite_noeud_g√©n√©rique)
            visiteuse.profondeur -= 1
            continue
        }

        si it.id == info_de([..]*NoeudSyntaxique) {
            membre := eini_depuis_info_membre(valeur_eini, it)

            tableau := m√©moire(membre.pointeur comme *[..]*NoeudSyntaxique)

            pour noeud dans tableau {
                visiteuse.profondeur += 1
                visite_noeud(visiteuse, noeud, visite_noeud_g√©n√©rique)
                visiteuse.profondeur -= 1
            }

            si visiteuse.rappel_pour_tableau {
                visiteuse.profondeur += 1
                visiteuse.rappel_pour_tableau(visiteuse, tableau)
                visiteuse.profondeur -= 1
            }

            continue
        }

        si it.id == info_de(NoeudScope) {
            // √Ä FAIRE : assert(est_base)
            scope := racine comme *NoeudScope
            tableau := scope.enfants

            pour noeud dans tableau {
                visiteuse.profondeur += 1
                visite_noeud(visiteuse, noeud, visite_noeud_g√©n√©rique)
                visiteuse.profondeur -= 1
            }

            si visiteuse.rappel_pour_tableau {
                visiteuse.profondeur += 1
                visiteuse.rappel_pour_tableau(visiteuse, tableau)
                visiteuse.profondeur -= 1
            }

            continue
        }
    }

    si visiteuse.direction_visite == DirectionVisiteNoeud.POST_ORDRE && visiteuse.rappel_pour_noeud {
        visiteuse.rappel_pour_noeud(visiteuse, racine, info)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Impression arbre.
 * \{ */

cr√©e_visiteuse_pour_impression :: fonc (noeud: *NoeudSyntaxique) -> VisiteuseNoeud
{
    rappel_pour_noeud :: fonc (visiteuse: *VisiteuseNoeud, noeud: *NoeudSyntaxique @inutilis√©e, info: *InfoTypeStructure)
    {
        imprime_tabulation(visiteuse.profondeur)
        imprime("%\n", info.nom)
    }

    r√©sultat: VisiteuseNoeud
    r√©sultat.arbre = noeud
    r√©sultat.rappel_pour_noeud = rappel_pour_noeud
    r√©sultat.direction_visite = DirectionVisiteNoeud.PR√â_ORDRE
    retourne r√©sultat
}

imprime_arbre :: fonc (noeud: *NoeudSyntaxique)
{
    visiteuse := cr√©e_visiteuse_pour_impression(noeud)
    visite_noeud(*visiteuse, noeud, visite_noeud_g√©n√©rique)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Destruction arbre.
 * \{ */

cr√©e_visiteuse_pour_destruction :: fonc (noeud: *NoeudSyntaxique) -> VisiteuseNoeud
{
    rappel_pour_noeud :: fonc (visiteuse: *VisiteuseNoeud @inutilis√©e, noeud: *NoeudSyntaxique, info: *InfoTypeStructure)
    {
        d√©loge_m√©moire(info.taille_en_octet comme z64, noeud, info, PositionCodeSource())
    }

    rappel_pour_tableau :: fonc (visiteuse: *VisiteuseNoeud @inutilis√©e, tableau: [..]*NoeudSyntaxique)
    {
        d√©loge(tableau)
    }

    r√©sultat: VisiteuseNoeud
    r√©sultat.arbre = noeud
    r√©sultat.rappel_pour_noeud = rappel_pour_noeud
    r√©sultat.rappel_pour_tableau = rappel_pour_tableau
    r√©sultat.direction_visite = DirectionVisiteNoeud.POST_ORDRE
    retourne r√©sultat
}

d√©truit_arbre :: fonc (noeud: *NoeudSyntaxique)
{
    visiteuse := cr√©e_visiteuse_pour_destruction(noeud)
    visite_noeud(*visiteuse, noeud, visite_noeud_g√©n√©rique)
}

/** \} */
