importe Introspection
importe Math

/* ------------------------------------------------------------------------- */
/** \nom NoeudSyntaxique
 * \{ */

NoeudSyntaxique :: struct {
    type := #type_de_cette_structure
    lexème: *Lexème

    // À FAIRE : ceci est pour différencier les blocs qui appartiennent à des
    // fonctions des autres blocs. Il faudrait plutôt parsé les différents
    // noeuds *Body pour qu'ils contiennents leurs propres StatementList.
    appartient_à_fonction: bool

    sur_exécution: fonc(*NoeudSyntaxique, *InterprèteArbre)(CompletionRecord)
    sur_génération_code_binaire: fonc(*NoeudSyntaxique, &GénératriceCodeBinaire)(Optionnel(Registre))
}

exécute_noeud :: fonc (noeud: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    ancien_noeud_courant := mémoire(interpréteuse.noeud_exécuté_courant)
    diffère mémoire(interpréteuse.noeud_exécuté_courant) = ancien_noeud_courant

    running_execution_context := interpréteuse.donne_running_execution_context()
    assert(interpréteuse.noeud_exécuté_courant == *running_execution_context.noeud_exécuté_courant)

    mémoire(interpréteuse.noeud_exécuté_courant) = noeud
    // imprime("Exécution de %\n", noeud.type)
    retourne noeud.sur_exécution(noeud, interpréteuse)
}

/* https://tc39.es/ecma262/multipage/notational-conventions.html#sec-algorithm-conventions-syntax-directed-operations
 *
 * The source text matched by a grammar production or Parse Node derived from
 * it is the portion of the source text that starts at the beginning of the
 * first terminal that participated in the match and ends at the end of the
 * last terminal that participated in the match. */
donne_texte_source :: fonc (noeud: *NoeudSyntaxique) -> chaine
{
    // À FAIRE : retourne tout le code dans la portée du noeud
    saufsi noeud.lexème {
        retourne ""
    }
    retourne noeud.lexème.texte
}

/* 11.2.2.1 Static Semantics: IsStrict ( node )
 * https://tc39.es/ecma262/multipage/ecmascript-language-source-code.html#sec-isstrict */
is_strict :: fonc (noeud: *NoeudSyntaxique @inutilisée) -> bool
{
    // À FAIRE 1. If the source text matched by node is strict mode code, return true; else return false.
    retourne faux
}

/* 8.4.1 Static Semantics: HasName
 * https://tc39.es/ecma262/multipage/syntax-directed-operations.html#sec-static-semantics-hasname */
has_name :: fonc (noeud: *NoeudSyntaxique) -> bool
{
    // À FAIRE : implémente tous les cas
    si noeud.type == FunctionExpression {
        retourne (noeud comme *FunctionExpression).id != nul
    }
    si noeud.type == ClassExpression {
        retourne (noeud comme *ClassExpression).identifier != nul
    }
    retourne faux
}

/* 8.4.2 Static Semantics: IsFunctionDefinition
 * https://tc39.es/ecma262/multipage/syntax-directed-operations.html#sec-static-semantics-isfunctiondefinition */
is_function_definition :: fonc (noeud: *NoeudSyntaxique) -> bool
{
    // À FAIRE : implémente tous les cas
    retourne noeud.type == FunctionExpression || noeud.type == ArrowFunction || noeud.type == ClassExpression
}

/* 8.4.3 Static Semantics: IsAnonymousFunctionDefinition
 * https://tc39.es/ecma262/multipage/syntax-directed-operations.html#sec-isanonymousfunctiondefinition */
is_anonymous_function_definition :: fonc (noeud: *NoeudSyntaxique) -> bool
{
    // 1. If IsFunctionDefinition of expr is false, return false.
    saufsi is_function_definition(noeud) {
        retourne faux
    }

    // 2. Let hasName be HasName of expr.
    // 3. If hasName is true, return false.
    si has_name(noeud) {
        retourne faux
    }

    // 4. Return true.
    retourne vrai
}

/* 8.4.4 Static Semantics: IsIdentifierRef
 * https://tc39.es/ecma262/multipage/syntax-directed-operations.html#sec-static-semantics-isidentifierref */
is_identifier_ref :: fonc (noeud: *NoeudSyntaxique) -> bool
{
    retourne noeud.type == Identifier
}

/* 8.4.5 Runtime Semantics: NamedEvaluation
 * https://tc39.es/ecma262/multipage/syntax-directed-operations.html#sec-runtime-semantics-namedevaluation */
named_evaluation :: fonc (interpréteuse: *Interpréteuse, noeud: *NoeudSyntaxique, name: FieldName) -> CompletionRecord
{
    si noeud.type == FunctionExpression {
        // 1. Return InstantiateOrdinaryFunctionExpression of FunctionExpression with argument name.
        résultat := instantiate_ordinary_function_expression(interpréteuse, noeud comme *FunctionExpression, *name)
        retourne normal_completion(Valeur(Function = résultat))
    }

    si noeud.type == ArrowFunction {
        // 1. Return InstantiateArrowFunctionExpression of ArrowFunction with argument name.
        résultat := instantiate_arrow_function_expression(interpréteuse, noeud comme *ArrowFunction, *name)
        retourne normal_completion(Valeur(Function = résultat))
    }

    si noeud.type == ClassExpression {
        // ClassExpression : class ClassTail
        class_expression := noeud comme *ClassExpression
        assert(class_expression.identifier == nul)
        assert(interpréteuse.type == InterprèteArbre)
        interprète := interpréteuse comme *InterprèteArbre

        // 1. Let value be ? ClassDefinitionEvaluation of ClassTail with arguments undefined and name.
        class_binding: Optionnel(ECMAString)
        value := class_definition_evaluation(interprète, class_expression.héritage, class_expression.body, class_binding, name)
        si interpréteuse.possède_exception() {
            retourne throw_completion(interpréteuse.donne_exception())
        }

        // 2. Set value.[[SourceText]] to the source text matched by ClassExpression.
        définis_source_text(value, donne_texte_source(class_expression))

        // 3. Return value.
        retourne normal_completion(Valeur(Function = value))
    }

    panique("name_evaluation non-implémenté")
}

/* 8.6.1 Runtime Semantics: InstantiateFunctionObject
 * https://tc39.es/ecma262/multipage/syntax-directed-operations.html#sec-runtime-semantics-instantiatefunctionobject */
instantiate_function_object :: fonc (realm: *Realm, noeud: *NoeudSyntaxique, env: *Environment, private_env: *PrivateEnvironment) -> *Function
{
    si noeud.type == FunctionDeclaration {
        retourne instantiate_ordinary_function_object(realm, noeud comme *FunctionDeclaration, env, private_env)
    }

    panique("instantiate_function_object non-implémenté")
}

/* 8.6.5 Static Semantics: PropName
 * https://tc39.es/ecma262/multipage/syntax-directed-operations.html#sec-static-semantics-propname */
prop_name :: fonc (noeud: *NoeudSyntaxique) -> ECMAString
{
    si noeud.type == Identifier {
        identifier := noeud comme *Identifier
        retourne identifier.nom
    }
    // À FAIRE : complète
    retourne crée_chaine_utf16_unique_vide()
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NoeudScope
 * \{ */

NoeudScope :: struct {
    empl base: Statement
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_scope

    enfants: [..]*Statement
}

sur_exécution_scope :: fonc (noeud: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    /* Si nous appartenons à fonction notre point d'entrée doit être interpréteuse_arbre. */
    assert(!noeud.appartient_à_fonction)
    retourne interpréteuse.exécute(noeud comme *NoeudScope)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NoeudScript
 * \{ */

NoeudScript :: struct {
    empl noeud: NoeudSyntaxique
    type = #type_de_cette_structure

    script_body: *ScriptBody
    code_binaire: *FluxDInstructions
}

exécute :: fonc (script: *NoeudScript, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    si script.script_body {
        retourne interpréteuse.exécute(script.script_body)
    }

    retourne normal_completion(js_undefined)
}

crée_script :: fonc (parseuse: *Parseuse, script_body: *ScriptBody) -> *NoeudScript
{
    résultat := parseuse.crée_noeud(nul, NoeudScript)
    résultat.script_body = script_body
    résultat.sur_génération_code_binaire = noeud_script_sur_code_binaire
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ScriptBody
 * \{ */

ScriptBody :: struct {
    empl scope: NoeudScope
    type = #type_de_cette_structure

    code_binaire: *FluxDInstructions
}

crée_script_body :: fonc (parseuse: *Parseuse, expressions: [..]*Statement) -> *ScriptBody
{
    résultat := parseuse.crée_noeud(nul, ScriptBody)
    résultat.enfants = expressions
    résultat.sur_génération_code_binaire = noeud_script_body_sur_code_binaire
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Statement
 * Structure de base pour les statements.
 * \{ */

Statement :: struct {
    empl noeud: NoeudSyntaxique
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Expression
 * Structure de base pour les expressions.
 * \{ */

Expression :: struct {
    empl noeud: NoeudSyntaxique
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ParenthesizedExpression
 * \{ */

ParenthesizedExpression :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_parenthesized_expression

    expression: *Expression
}

crée_parenthesized_expression :: fonc (parseuse: *Parseuse, lexème: *Lexème, expression: *Expression) -> *ParenthesizedExpression
{
    résultat := parseuse.crée_noeud(lexème, ParenthesizedExpression)
    résultat.sur_génération_code_binaire = parenthesized_expression_sur_code_binaire
    résultat.expression = expression
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-grouping-operator-runtime-semantics-evaluation */
sur_exécution_parenthesized_expression :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    parenthèse := base comme *ParenthesizedExpression

    saufsi parenthèse.expression {
        retourne normal_completion(js_undefined)
    }

    // 1. Return ? Evaluation of Expression. This may be of type Reference.
    retourne exécute_noeud(parenthèse.expression, interpréteuse)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ExpressionStatement
 * Structure de base pour les expressions.
 * \{ */

ExpressionStatement :: struct {
    empl statement: Statement
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_expression_statement

    expression: *Expression
}

crée_expression_statement :: fonc (parseuse: *Parseuse, lexème: *Lexème, expression: *Expression) -> *ExpressionStatement
{
    résultat := parseuse.crée_noeud(lexème, ExpressionStatement)
    résultat.expression = expression
    résultat.sur_génération_code_binaire = expression_statement_sur_code_binaire
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-expression-statement */
sur_exécution_expression_statement :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    statement := base comme *ExpressionStatement

    // 1. Let exprRef be ? Evaluation of Expression.
    completion := exécute_noeud(statement.expression, interpréteuse)
    saufsi completion.est_normal() {
        retourne completion
    }
    expr_ref := completion.valeur

    // 2. Return ? GetValue(exprRef).
    valeur := get_value(interpréteuse, expr_ref)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }
    retourne normal_completion(valeur)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom EmptyStatement
 * \{ */

EmptyStatement :: struct {
    empl statement: Statement
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_empty_statement
    sur_génération_code_binaire = empty_statement_sur_code_binaire
}

crée_empty_statement :: fonc (parseuse: *Parseuse, lexème: *Lexème) -> *EmptyStatement
{
    retourne parseuse.crée_noeud(lexème, EmptyStatement)
}

sur_exécution_empty_statement :: fonc (base: *NoeudSyntaxique @inutilisée, interpréteuse: *InterprèteArbre @inutilisée) -> CompletionRecord
{
    // 1. Return empty.
    retourne normal_completion(js_undefined)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom FunctionDeclaration
 * \{ */

FunctionDeclaration :: struct {
    empl base: Statement
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_function_declaration

    id: *Identifier
    params: [..]*Expression
    corps: *FunctionBody
    code_binaire: *FluxDInstructions

    generator := faux
    async := faux
}

crée_function_déclaration :: fonc (parseuse: *Parseuse, lexème: *Lexème, id: *Identifier, params: [..]*Expression, corps: *FunctionBody, async: bool, generator: bool) -> *FunctionDeclaration
{
    résultat := parseuse.crée_noeud(lexème, FunctionDeclaration)
    résultat.sur_génération_code_binaire = function_declaration_sur_code_binaire
    résultat.id = id
    résultat.corps = corps
    résultat.params = params
    résultat.async = async
    résultat.generator = generator
    retourne résultat
}

sur_exécution_function_declaration :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre @inutilisée) -> CompletionRecord
{
    fonction := base comme *FunctionDeclaration
    assert(!fonction.async)
    // 1. Return empty.
    retourne normal_completion(js_undefined)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom FunctionExpression
 * \{ */

FunctionExpression :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_function_expression

    id: *Identifier
    params: [..]*Expression
    corps: *FunctionBody

    generator := faux
    async := faux
}

crée_function_expression :: fonc (parseuse: *Parseuse, lexème: *Lexème, id: *Identifier, params: [..]*Expression, corps: *FunctionBody, async: bool, generator: bool) -> *FunctionExpression
{
    résultat := parseuse.crée_noeud(lexème, FunctionExpression)
    résultat.sur_génération_code_binaire = function_expression_sur_code_binaire
    résultat.id = id
    résultat.corps = corps
    résultat.params = params
    résultat.async = async
    résultat.generator = generator
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-function-definitions-runtime-semantics-evaluation */
sur_exécution_function_expression :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    expression := base comme *FunctionExpression
    assert(!expression.async)
    /* 1. Return InstantiateOrdinaryFunctionExpression of FunctionExpression. */
    closure := instantiate_ordinary_function_expression(interpréteuse, expression)
    retourne normal_completion(Valeur(Function = closure))
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom FunctionBody
 * \{ */

FunctionBody :: struct {
    empl base_statement: Statement
    type = #type_de_cette_structure

    statement: *Statement
    async: bool
    generator: bool
}

crée_function_body :: fonc (parseuse: *Parseuse, statement: *Statement, async: bool, generator: bool) -> *FunctionBody
{
    résultat := parseuse.crée_noeud(nul, FunctionBody)
    résultat.statement = statement
    résultat.async = async
    résultat.generator = generator
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ArrowFunction
 * \{ */

ArrowFunction :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_arrow_function

    params: [..]*Expression
    corps: *ConciseBody
    async: bool
}

crée_arrow_function :: fonc (parseuse: *Parseuse, lexème: *Lexème, params: [..]*Expression, corps: *ConciseBody, async: bool) -> *ArrowFunction
{
    résultat := parseuse.crée_noeud(lexème, ArrowFunction)
    résultat.sur_génération_code_binaire = arrow_function_sur_code_binaire
    résultat.corps = corps
    résultat.params = params
    résultat.async = async
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-arrow-function-definitions-runtime-semantics-evaluation */
sur_exécution_arrow_function :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    expression := base comme *ArrowFunction
    assert(!expression.async)
    /* 1. Return InstantiateOrdinaryFunctionExpression of FunctionExpression. */
    closure := instantiate_arrow_function_expression(interpréteuse, expression)
    retourne normal_completion(Valeur(Function = closure))
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom FunctionBody
 * \{ */

ConciseBody :: struct {
    empl base_statement: Statement
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_concise_body

    statement: *Statement
    code_binaire: *FluxDInstructions
    async: bool
}

crée_concise_body :: fonc (parseuse: *Parseuse, statement: *Statement, async: bool) -> *ConciseBody
{
    résultat := parseuse.crée_noeud(nul, ConciseBody)
    résultat.sur_génération_code_binaire = concise_body_sur_code_binaire
    résultat.statement = statement
    résultat.async = async
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-arrow-function-definitions-runtime-semantics-evaluation */
sur_exécution_concise_body :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    concise_body := base comme *ConciseBody

    // ExpressionBody : FunctionBody
    si concise_body.statement.type == BlockStatement {
        retourne interpréteuse.exécute(concise_body.statement)
    }

    // ExpressionBody : AssignmentExpression
    // 1. Let exprRef be ? Evaluation of AssignmentExpression.
    completion := exécute_noeud(concise_body.statement, interpréteuse)
    saufsi completion.est_normal() {
        retourne completion
    }
    expr_ref := completion.valeur

    // 2. Let exprValue be ? GetValue(exprRef).
    expr_value := get_value(interpréteuse, expr_ref)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 3. Return ReturnCompletion(exprValue).
    retourne return_completion(expr_value)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom This
 * \{ */

ThisExpression :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_this_expression
}

crée_this_expression :: fonc (parseuse: *Parseuse, lexème: *Lexème) -> *ThisExpression
{
    résultat := parseuse.crée_noeud(lexème, ThisExpression)
    résultat.sur_génération_code_binaire = this_expression_sur_code_binaire
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-this-keyword-runtime-semantics-evaluation */
sur_exécution_this_expression :: fonc (base: *NoeudSyntaxique @inutilisée, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    résultat := resolve_this_binding(interpréteuse)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }
    retourne normal_completion(résultat)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Identifier
 * \{ */

Identifier :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_identifier

    nom: ECMAString
    indice_chaine_en_cache := -1
    coordonnée: Optionnel(CoordonnéeEnvironnement)
}

/* Utilisée pour créer des identifiants pour les paramètres des fonctions des EventHandlers. */
crée_identifier_pour_html :: fonc (nom: ECMAString) -> *Identifier
{
    résultat := loge(Identifier)
    résultat.sur_génération_code_binaire = identifier_sur_code_binaire
    résultat.nom = nom
    retourne résultat
}

crée_identifier :: fonc (parseuse: *Parseuse, lexème: *Lexème, nom: ECMAString) -> *Identifier
{
    résultat := parseuse.crée_noeud(lexème, Identifier)
    résultat.sur_génération_code_binaire = identifier_sur_code_binaire
    résultat.nom = nom
    retourne résultat
}

crée_identifier :: fonc (parseuse: *Parseuse, lexème: *Lexème, nom: chaine) -> *Identifier
{
    retourne crée_identifier(parseuse, lexème, crée_chaine_utf16_unique(nom))
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-identifiers-runtime-semantics-evaluation */
sur_exécution_identifier :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    noeud := base comme *Identifier

    si noeud.coordonnée.possède_valeur() {
        coordonnée := noeud.coordonnée.Quelque

        environment := interpréteuse.donne_lexical_environement()
        tantque coordonnée.sauts != 0 {
            environment = environment.outer_environment
            coordonnée.sauts -= 1
        }
        assert(environment != nul)
        assert(est_declarative_environment(environment))

        reference: ReferenceRecord
        reference.base = environment
        reference.referenced_name = Valeur(String = noeud.donne_chaine_primitive(interpréteuse.donne_realm()))
        reference.strict = is_strict(noeud)
        reference.coordonnée = noeud.coordonnée
        retourne normal_completion(reference)
    }

    référence := resolve_binding(interpréteuse, noeud.donne_chaine_primitive(interpréteuse.donne_realm()))
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }
    
    noeud.coordonnée = référence.coordonnée
    retourne normal_completion(référence)
}

donne_chaine_primitive :: fonc (identifier: *Identifier, realm: *Realm) -> *PrimitiveChaine
{
    si identifier.indice_chaine_en_cache == -1 {
        pour realm.chaines {
            si it.texte == identifier.nom {
                identifier.indice_chaine_en_cache = indice_it comme z32
                retourne it
            }
        }

        résultat := realm.crée_chaine(identifier.nom)
        identifier.indice_chaine_en_cache = realm.chaines.taille comme z32 - 1
        retourne résultat
    }

    retourne realm.chaines[identifier.indice_chaine_en_cache]
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom PrivateIdentifier
 * \{ */

PrivateIdentifier :: struct {
    empl base: Expression
    type = #type_de_cette_structure

    nom: ECMAString
}

crée_private_identifier :: fonc (parseuse: *Parseuse, lexème: *Lexème) -> *PrivateIdentifier
{
    résultat := parseuse.crée_noeud(lexème, PrivateIdentifier)
    résultat.nom = crée_chaine_utf16_unique(lexème.texte)
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ComputedPropertyName
 * \{ */

ComputedPropertyName :: struct {
    empl base: Expression
    type = #type_de_cette_structure

    expression: *Expression    
}

crée_computed_property_name :: fonc (parseuse: *Parseuse, lexème: *Lexème, expression: *Expression) -> *ComputedPropertyName
{
    résultat := parseuse.crée_noeud(lexème, ComputedPropertyName)
    résultat.expression = expression
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom BlockStatement
 * \{ */

BlockStatement :: struct {
    empl scope: NoeudScope
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_block_statement

    code_binaire: *FluxDInstructions
}

crée_block_statement :: fonc (parseuse: *Parseuse, lexème: *Lexème, expressions: [..]*Statement) -> *BlockStatement
{
    résultat := parseuse.crée_noeud(lexème, BlockStatement)
    résultat.sur_génération_code_binaire = block_statement_sur_code_binaire
    résultat.enfants = expressions
    retourne résultat
}

sur_exécution_block_statement :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    /* Si nous appartenons à fonction notre point d'entrée doit être interpréteuse_arbre. */
    assert(!base.appartient_à_fonction)

    block := base comme *BlockStatement
    si block.enfants.taille == 0 {
        retourne normal_completion(js_undefined)
    }

    mv := interpréteuse.mv
    running_execution_context := mv.donne_running_execution_context()

    // 1. Let oldEnv be the running execution context's LexicalEnvironment.
    old_env := running_execution_context.lexical_environment

    // 2. Let blockEnv be NewDeclarativeEnvironment(oldEnv).
    block_env := new_declarative_environment(old_env.donne_tas_de_mémoire(), old_env)

    // 3. Perform BlockDeclarationInstantiation(StatementList, blockEnv).
    block_declaration_instantiation(interpréteuse, block, block_env)

    // 4. Set the running execution context's LexicalEnvironment to blockEnv.
    running_execution_context.lexical_environment = block_env

    // 5. Let blockValue be Completion(Evaluation of StatementList).
    block_value: CompletionRecord = ---
    pour block.enfants {
        block_value = exécute_noeud(it, interpréteuse)
        saufsi block_value.est_normal() {
            arrête
        }
    }

    // 6. Set the running execution context's LexicalEnvironment to oldEnv.
    running_execution_context.lexical_environment = old_env

    // 7. Return ? blockValue.
    retourne block_value
}

/* 14.2.3 BlockDeclarationInstantiation ( code, env )
 * https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-blockdeclarationinstantiation */
block_declaration_instantiation :: fonc (interpréteuse: *Interpréteuse, code: *NoeudSyntaxique, env: *DeclarativeEnvironment)
{
    // 1. Let declarations be the LexicallyScopedDeclarations of code.
    lex_declarations := donne_lexically_scoped_declarations(code)
    saufsi lex_declarations {
        retourne
    }
    diffère déloge(lex_declarations)

    // 2. Let privateEnv be the running execution context's PrivateEnvironment.
    // mv := interpréteuse.mv
    // running_execution_context := mv.donne_running_execution_context()
    // private_env := running_execution_context.private_environment

    realm := interpréteuse.donne_realm()

    // 3. For each element d of declarations, do
    bound_names: [..]ECMAString
    diffère déloge(bound_names)

    pour d dans lex_declarations {
        // a. For each element dn of the BoundNames of d, do
        donne_bound_names(d, *bound_names)
        pour dn dans bound_names {
            // i. If IsConstantDeclaration of d is true, then
            si is_constant_declaration(d) {
                // 1. Perform ! env.CreateImmutableBinding(dn, true).
                _ := env.create_immutable_binding(realm, dn, vrai)
            }
            // ii. Else,
            sinon {
                // 1. Perform ! env.CreateMutableBinding(dn, false). NOTE: This step is replaced in section B.3.2.6.
                env.create_mutable_binding(realm, dn, faux)
            }
        }
        // À FAIRE b. If d is either a FunctionDeclaration, a GeneratorDeclaration, an AsyncFunctionDeclaration, or an AsyncGeneratorDeclaration, then
        // i. Let fn be the sole element of the BoundNames of d.
        // ii. Let fo be InstantiateFunctionObject of d with arguments env and privateEnv.
        // iii. Perform ! env.InitializeBinding(fn, fo). NOTE: This step is replaced in section B.3.2.6.
    }

    // 4. Return unused.
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ReturnStatement
 * \{ */

ReturnStatement :: struct {
    empl base: Statement
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_return

    argument: *NoeudSyntaxique
}

crée_return_statement :: fonc (parseuse: *Parseuse, lexème: *Lexème, argument: *NoeudSyntaxique) -> *ReturnStatement
{
    résultat := parseuse.crée_noeud(lexème, ReturnStatement)
    résultat.sur_génération_code_binaire = return_statement_sur_code_binaire
    résultat.argument = argument
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-return-statement-runtime-semantics-evaluation */
sur_exécution_return :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    noeud := base comme *ReturnStatement

    // ReturnStatement : return ;
    // 1. Return Completion Record { [[Type]]: RETURN, [[Value]]: undefined, [[Target]]: EMPTY }.
    résultat := return_completion(js_undefined)

    // ReturnStatement : return Expression ;
    si noeud.argument {
        // 1. Let exprRef be ? Evaluation of Expression.
        completion := exécute_noeud(noeud.argument, interpréteuse)
        saufsi completion.est_normal() {
            retourne completion
        }
        expr_ref := completion.valeur
        // 2. Let exprValue be ? GetValue(exprRef).
        expr_value := get_value(interpréteuse, expr_ref)
        si interpréteuse.possède_exception() {
            retourne throw_completion(interpréteuse.donne_exception())
        }

        // À FAIRE : 3. If GetGeneratorKind() is ASYNC, set exprValue to ? Await(exprValue).

        // 4. Return Completion Record { [[Type]]: RETURN, [[Value]]: exprValue, [[Target]]: EMPTY }.
        résultat = return_completion(expr_value)
    }

    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom UnaryPlusOperator
 * \{ */

UnaryPlusOperator :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_unary_plus_operator

    argument: *Expression
}

crée_unary_plus_operator :: fonc (parseuse: *Parseuse, lexème: *Lexème, argument: *Expression) -> *UnaryPlusOperator
{
    résultat := parseuse.crée_noeud(lexème, UnaryPlusOperator)
    résultat.sur_génération_code_binaire = unary_plus_operator_sur_code_binaire
    résultat.argument = argument
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-unary-plus-operator-runtime-semantics-evaluation */
sur_exécution_unary_plus_operator :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    noeud := base comme *UnaryPlusOperator
    unary_expression := noeud.argument

    // 1. Let expr be ? Evaluation of UnaryExpression.
    completion := exécute_noeud(unary_expression, interpréteuse)
    saufsi completion.est_normal() {
        retourne completion
    }
    expr := completion.valeur

    // 2. Return ? ToNumber(? GetValue(expr)).
    valeur := get_value(interpréteuse, expr)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    retourne normal_completion(to_number(interpréteuse, valeur))
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom UnaryMinusOperator
 * \{ */

UnaryMinusOperator :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_unary_minus_operator

    argument: *Expression
}

crée_unary_minus_operator :: fonc (parseuse: *Parseuse, lexème: *Lexème, argument: *Expression) -> *UnaryMinusOperator
{
    résultat := parseuse.crée_noeud(lexème, UnaryMinusOperator)
    résultat.sur_génération_code_binaire = unary_minus_operator_sur_code_binaire
    résultat.argument = argument
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-unary-minus-operator-runtime-semantics-evaluation */
sur_exécution_unary_minus_operator :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    noeud := base comme *UnaryMinusOperator
    unary_expression := noeud.argument

    // 1. Let expr be ? Evaluation of UnaryExpression.
    completion := exécute_noeud(unary_expression, interpréteuse)
    saufsi completion.est_normal() {
        retourne completion
    }
    expr := completion.valeur

    // 2. Let oldValue be ? ToNumeric(? GetValue(expr)).
    valeur := get_value(interpréteuse, expr)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }
    old_value := to_numeric(interpréteuse, valeur)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 3. If oldValue is a Number, then
    si old_value.est_nombre() {
        // a. Return Number::unaryMinus(oldValue).
        retourne normal_completion(number_unary_minus(old_value))
    }
    // 4. Else,
    // a. Assert: oldValue is a BigInt.
    assert(old_value.est_big_int())
    // b. Return BigInt::unaryMinus(oldValue).
    retourne normal_completion(bigint_unary_minus(old_value))
}

bigint_unary_minus :: fonc (x: Valeur @inutilisée) -> Valeur
{
    panique("big_int unary minus non-implémenté")
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom BinaryNot
 * \{ */

BinaryNot :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_binary_not

    argument: *Expression
}

crée_binary_not :: fonc (parseuse: *Parseuse, lexème: *Lexème, argument: *Expression) -> *BinaryNot
{
    résultat := parseuse.crée_noeud(lexème, BinaryNot)
    résultat.sur_génération_code_binaire = binary_not_sur_code_binaire
    résultat.argument = argument
    retourne résultat
}

sur_exécution_binary_not :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    noeud := base comme *BinaryNot

    // 1. Let expr be ? Evaluation of UnaryExpression.
    completion := exécute_noeud(noeud.argument, interpréteuse)
    saufsi completion.est_normal() {
        retourne completion
    }
    expr := completion.valeur

    // 2. Let oldValue be ? ToNumeric(? GetValue(expr)).
    valeur := get_value(interpréteuse, expr)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    old_value := to_numeric(interpréteuse, valeur)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 3. If oldValue is a Number, then
    si old_value.est_nombre() {
        // a. Return Number::bitwiseNOT(oldValue).
        retourne normal_completion(number_bitwise_not(old_value))
    }

    // 4. Else,
    //    a. Assert: oldValue is a BigInt.
    assert(old_value.est_big_int())

    //    b. Return BigInt::bitwiseNOT(oldValue).
    retourne normal_completion(big_int_bitwise_not(old_value))
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom LogicalNot
 * \{ */

LogicalNot :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_logical_not

    argument: *Expression
}

crée_logical_not :: fonc (parseuse: *Parseuse, lexème: *Lexème, argument: *Expression) -> *LogicalNot
{
    résultat := parseuse.crée_noeud(lexème, LogicalNot)
    résultat.sur_génération_code_binaire = logical_not_sur_code_binaire
    résultat.argument = argument
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-logical-not-operator */
sur_exécution_logical_not :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    noeud := base comme *LogicalNot
    unary_expression := noeud.argument

    // 1. Let expr be ? Evaluation of UnaryExpression.
    completion := exécute_noeud(unary_expression, interpréteuse)
    saufsi completion.est_normal() {
        retourne completion
    }
    expr := completion.valeur

    // 2. Let oldValue be ToBoolean(? GetValue(expr)).
    valeur := get_value(interpréteuse, expr)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }
    old_value := to_boolean(valeur)

    // 3. If oldValue is true, return false.
    si old_value {
        retourne normal_completion(Valeur(Boolean = faux))
    }

    // 4. Return true.
    retourne normal_completion(Valeur(Boolean = vrai))
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom LogicalAnd
 * \{ */

LogicalAnd :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_logical_and

    left: *Expression
    right: *Expression
}

crée_logical_and :: fonc (parseuse: *Parseuse, lexème: *Lexème, left: *Expression, right: *Expression) -> *LogicalAnd
{
    résultat := parseuse.crée_noeud(lexème, LogicalAnd)
    résultat.sur_génération_code_binaire = logical_and_sur_code_binaire
    résultat.left = left
    résultat.right = right
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#prod-LogicalANDExpression */
sur_exécution_logical_and :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    noeud := base comme *LogicalAnd

    // 1. Let lRef be ? Evaluation of LogicalANDExpression.
    completion := exécute_noeud(noeud.left, interpréteuse)
    saufsi completion.est_normal() {
        retourne completion
    }
    lref := completion.valeur

    // 2. Let lVal be ? GetValue(lRef).
    lval := get_value(interpréteuse, lref)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 3. If ToBoolean(lVal) is false, return lVal.
    saufsi to_boolean(lval) {
        retourne normal_completion(lval)
    }

    // 4. Let rRef be ? Evaluation of BitwiseORExpression.
    completion = exécute_noeud(noeud.right, interpréteuse)
    saufsi completion.est_normal() {
        retourne completion
    }
    rref := completion.valeur

    // 5. Return ? GetValue(rRef).
    résultat := get_value(interpréteuse, rref)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }
    retourne normal_completion(résultat)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom LogicalOr
 * \{ */

LogicalOr :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_logical_or

    left: *Expression
    right: *Expression
}

crée_logical_or :: fonc (parseuse: *Parseuse, lexème: *Lexème, left: *Expression, right: *Expression) -> *LogicalOr
{
    résultat := parseuse.crée_noeud(lexème, LogicalOr)
    résultat.sur_génération_code_binaire = logical_or_sur_code_binaire
    résultat.left = left
    résultat.right = right
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#prod-LogicalORExpression */
sur_exécution_logical_or :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    noeud := base comme *LogicalOr

    // 1. Let lRef be ? Evaluation of LogicalORExpression.
    completion := exécute_noeud(noeud.left, interpréteuse)
    saufsi completion.est_normal() {
        retourne completion
    }
    lref := completion.valeur

    // 2. Let lVal be ? GetValue(lRef).
    lval := get_value(interpréteuse, lref)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 3. If ToBoolean(lVal) is true, return lVal.
    si to_boolean(lval).est_true() {
        retourne normal_completion(lval)
    }

    // 4. Let rRef be ? Evaluation of LogicalANDExpression.
    completion = exécute_noeud(noeud.right, interpréteuse)
    saufsi completion.est_normal() {
        retourne completion
    }
    rref := completion.valeur

    // 5. Return ? GetValue(rRef).
    résultat := get_value(interpréteuse, rref)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }
    retourne normal_completion(résultat)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Coalesce
 * \{ */

Coalesce :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_coalesce

    left: *Expression
    right: *Expression
}

crée_coalesce :: fonc (parseuse: *Parseuse, lexème: *Lexème, left: *Expression, right: *Expression) -> *Coalesce
{
    résultat := parseuse.crée_noeud(lexème, Coalesce)
    résultat.sur_génération_code_binaire = coalesce_sur_code_binaire
    résultat.left = left
    résultat.right = right
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#prod-LogicalORExpression */
sur_exécution_coalesce :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    noeud := base comme *Coalesce

    // 1. Let lRef be ? Evaluation of CoalesceExpressionHead.
    completion := exécute_noeud(noeud.left, interpréteuse)
    saufsi completion.est_normal() {
        retourne completion
    }
    lref := completion.valeur
    // 2. Let lVal be ? GetValue(lRef).
    lval := get_value(interpréteuse, lref)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 3. If lVal is either undefined or null, then
    si lval.est_nulle() || lval.est_undefined() {
        // a. Let rRef be ? Evaluation of BitwiseORExpression.
        completion = exécute_noeud(noeud.right, interpréteuse)
        saufsi completion.est_normal() {
            retourne completion
        }
        rref := completion.valeur

        // b. Return ? GetValue(rRef).
        résultat := get_value(interpréteuse, rref)
        si interpréteuse.possède_exception() {
            retourne throw_completion(interpréteuse.donne_exception())
        }
        retourne normal_completion(résultat)
    }

    // 4. Else,
    //    a. Return lVal.
    retourne normal_completion(lval)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom BinaryExpression
 * \{ */

BinaryOperation :: énum {
    Plus
    Moins
    Multiplie
    Divise
    Modulo
    EtBinaire
    OuBinaire
    OuExclusif
    DécalageGauche
    DécalageDroite
    DécalageDroiteNaturel
    Exponentiation
}

BinaryExpression :: struct {
    empl  base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_binary_expression

    opération: BinaryOperation
    gauche: *Expression
    droite: *Expression
}

crée_binary_expression :: fonc (parseuse: *Parseuse, lexème: *Lexème, opération: BinaryOperation, gauche: *Expression, droite: *Expression) -> *BinaryExpression
{
    résultat := parseuse.crée_noeud(lexème, BinaryExpression)
    résultat.sur_génération_code_binaire = binary_expression_sur_code_binaire
    résultat.opération = opération
    résultat.gauche = gauche
    résultat.droite = droite
    retourne résultat
}


sur_exécution_binary_expression :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    noeud := base comme *BinaryExpression
    completion_gauche := exécute_noeud(noeud.gauche, interpréteuse)
    saufsi completion_gauche.est_normal() {
        retourne completion_gauche
    }
    completion_droite := exécute_noeud(noeud.droite, interpréteuse)
    saufsi completion_droite.est_normal() {
        retourne completion_droite
    }
    gauche := get_value(interpréteuse, completion_gauche.valeur)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }
    droite := get_value(interpréteuse, completion_droite.valeur)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }
    retourne apply_string_or_numeric_binary_operator(interpréteuse, noeud.opération, gauche, droite)
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-applystringornumericbinaryoperator */
apply_string_or_numeric_binary_operator :: fonc (interpréteuse: *Interpréteuse, opération: BinaryOperation, gauche: Valeur, droite: Valeur) -> CompletionRecord
{
    // 1. If opText is +, then
    si opération == BinaryOperation.Plus {
        // a. Let lprim be ? ToPrimitive(lval).
        lprim := to_primitive(interpréteuse, gauche)
        si interpréteuse.possède_exception() {
            retourne throw_completion(interpréteuse.donne_exception())
        }
        // b. Let rprim be ? ToPrimitive(rval).
        rprim := to_primitive(interpréteuse, droite)
        si interpréteuse.possède_exception() {
            retourne throw_completion(interpréteuse.donne_exception())
        }
        // c. If lprim is a String or rprim is a String, then
        si lprim.est_chaine() || rprim.est_chaine() {
            // i. Let lstr be ? ToString(lprim).
            lstr := to_string(interpréteuse, gauche)
            si interpréteuse.possède_exception() {
                retourne throw_completion(interpréteuse.donne_exception())
            }
            // ii. Let rstr be ? ToString(rprim).
            rstr := to_string(interpréteuse, droite)
            si interpréteuse.possède_exception() {
                retourne throw_completion(interpréteuse.donne_exception())
            }
            // iii. Return the string-concatenation of lstr and rstr.
            retourne normal_completion(Valeur(String = concatène(interpréteuse.donne_realm(), lstr, rstr)))
        }
    
        // d. Set lval to lprim.
        gauche = lprim
        // e. Set rval to rprim.
        droite = rprim
    }

    // 2. NOTE: At this point, it must be a numeric operation.

    // 3. Let lnum be ? ToNumeric(lval).
    gauche = to_numeric(interpréteuse, gauche)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 4. Let rnum be ? ToNumeric(rval).
    droite = to_numeric(interpréteuse, droite)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 5. If Type(lnum) is not Type(rnum), throw a TypeError exception.
    si donne_type(gauche) != donne_type(droite) {
        _ := lance_type_error(interpréteuse, "Incompatible types for binary expression")
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 6. If lnum is a BigInt, then
    si est_big_int(gauche) {
        // a. If opText is **, return ? BigInt::exponentiate(lnum, rnum).
        // b. If opText is /, return ? BigInt::divide(lnum, rnum).
        // c. If opText is %, return ? BigInt::remainder(lnum, rnum).
        // d. If opText is >>>, return ? BigInt::unsignedRightShift(lnum, rnum).
        panique("big_int non-géré")
    }

    // 7. Let operation be the abstract operation associated with opText and Type(lnum) in the following table:

    // 8. Return operation(lnum, rnum).
    valeur := js_undefined

    discr opération {
        Plus {
            valeur = number_add(gauche, droite)
        }
        Moins {
            valeur = number_subtract(gauche, droite)
        }
        Multiplie {
            valeur = number_multiply(gauche, droite)
        }
        Divise {
            valeur = number_divide(gauche, droite)
        }
        Modulo {
            valeur = number_remainder(gauche, droite)
        }
        OuExclusif {
            valeur = number_bitwise_xor(gauche, droite)
        }
        DécalageGauche {
            valeur = number_left_shift(gauche, droite)
        }
        DécalageDroite {
            valeur = number_signed_right_shift(gauche, droite)
        }
        DécalageDroiteNaturel {
            valeur = number_unsigned_right_shift(gauche, droite)
        }
        EtBinaire {
            valeur = number_bitwise_and(gauche, droite)
        }
        OuBinaire {
            valeur = number_bitwise_or(gauche, droite)
        }
        Exponentiation {
            valeur = number_exponentiate(gauche, droite)
        }
    }

    retourne normal_completion(valeur)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom EqualityExpression
 * \{ */

EqualityOperation :: énum {
    Égal
    Inégal
    ÉgalStrict
    InégalStrict
}

EqualityExpression :: struct {
    empl  base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_equality_expression

    opération: EqualityOperation
    gauche: *Expression
    droite: *Expression
}

crée_equality_expression :: fonc (parseuse: *Parseuse, lexème: *Lexème, opération: EqualityOperation, gauche: *Expression, droite: *Expression) -> *EqualityExpression
{
    résultat := parseuse.crée_noeud(lexème, EqualityExpression)
    résultat.sur_génération_code_binaire = equality_expression_sur_code_binaire
    résultat.opération = opération
    résultat.gauche = gauche
    résultat.droite = droite
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-equality-operators-runtime-semantics-evaluation */
sur_exécution_equality_expression :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    noeud := base comme *EqualityExpression
    completion_gauche := exécute_noeud(noeud.gauche, interpréteuse)
    saufsi completion_gauche.est_normal() {
        retourne completion_gauche
    }
    completion_droite := exécute_noeud(noeud.droite, interpréteuse)
    saufsi completion_droite.est_normal() {
        retourne completion_droite
    }
    gauche := get_value(interpréteuse, completion_gauche.valeur)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }
    droite := get_value(interpréteuse, completion_droite.valeur)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }
    
    discr noeud.opération {
        Égal {
            résultat := is_loosely_equal(interpréteuse, gauche, droite)
            si interpréteuse.possède_exception() {
                retourne throw_completion(interpréteuse.donne_exception())
            }
            retourne normal_completion(résultat)
        }
        Inégal {
            résultat := is_loosely_equal(interpréteuse, gauche, droite)
            si interpréteuse.possède_exception() {
                retourne throw_completion(interpréteuse.donne_exception())
            }
            si résultat {
                retourne normal_completion(Valeur(Boolean = faux))
            }
            retourne normal_completion(Valeur(Boolean = vrai))
        }
        ÉgalStrict {
            retourne normal_completion(is_strictly_equal(gauche, droite))
        }
        InégalStrict {
            résultat := is_strictly_equal(gauche, droite)
            si résultat.est_true() {
                retourne normal_completion(Valeur(Boolean = faux))
            }
            retourne normal_completion(Valeur(Boolean = vrai))
        }
        sinon {
            panique("noeud.opération non-initialisé")
        }
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom RelationalExpression
 * \{ */

RelationalOperation :: énum {
    Supérieur
    Inférieur
    SupérieurÉgal
    InférieurÉgal
    InstanceOf
    In
}

RelationalExpression :: struct {
    empl  base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_relational_expression

    opération: RelationalOperation
    gauche: *Expression
    droite: *Expression
}

crée_relational_expression :: fonc (parseuse: *Parseuse, lexème: *Lexème, opération: RelationalOperation, gauche: *Expression, droite: *Expression) -> *RelationalExpression
{
    résultat := parseuse.crée_noeud(lexème, RelationalExpression)
    résultat.sur_génération_code_binaire = relational_expression_sur_code_binaire
    résultat.opération = opération
    résultat.gauche = gauche
    résultat.droite = droite
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-relational-operators-runtime-semantics-evaluation */
sur_exécution_relational_expression :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    noeud := base comme *RelationalExpression

    // 1. Let lref be ? Evaluation of RelationalExpression.
    completion_lref := exécute_noeud(noeud.gauche, interpréteuse)
    saufsi completion_lref.est_normal() {
        retourne completion_lref
    }
    lref := completion_lref.valeur

    // 2. Let lval be ? GetValue(lref).
    lval := get_value(interpréteuse, lref)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 3. Let rref be ? Evaluation of ShiftExpression.
    completion_rref := exécute_noeud(noeud.droite, interpréteuse)
    saufsi completion_rref.est_normal() {
        retourne completion_rref
    }
    rref := completion_rref.valeur

    // 4. Let rval be ? GetValue(rref).
    rval := get_value(interpréteuse, rref)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    r: Valeur

    discr noeud.opération {
        Inférieur {
            // 5. Let r be ? IsLessThan(lval, rval, true).
            r = is_less_than(interpréteuse, lval, rval, vrai)
            si interpréteuse.possède_exception() {
                retourne throw_completion(interpréteuse.donne_exception())
            }

            // 6. If r is undefined, return false. Otherwise, return r.
            si r.est_undefined() {
                r = Valeur(Boolean = faux)
            }
        }
        Supérieur {
            // 5. Let r be ? IsLessThan(rval, lval, false).
            r = is_less_than(interpréteuse, rval, lval, faux)
            si interpréteuse.possède_exception() {
                retourne throw_completion(interpréteuse.donne_exception())
            }

            // 6. If r is undefined, return false. Otherwise, return r.
            si r.est_undefined() {
                r = Valeur(Boolean = faux)
            }
        }
        InférieurÉgal {
            // 5. Let r be ? IsLessThan(rval, lval, false).
            r = is_less_than(interpréteuse, rval, lval, faux)
            si interpréteuse.possède_exception() {
                retourne throw_completion(interpréteuse.donne_exception())
            }

            // 6. If r is either true or undefined, return false. Otherwise, return true.
            si r.est_true() || r.est_undefined() {
                r = Valeur(Boolean = faux)
            }
            sinon {
                r = Valeur(Boolean = vrai)
            }
        }
        SupérieurÉgal {
            // 5. Let r be ? IsLessThan(lval, rval, true).
            r = is_less_than(interpréteuse, lval, rval, vrai)
            si interpréteuse.possède_exception() {
                retourne throw_completion(interpréteuse.donne_exception())
            }

            // 6. If r is either true or undefined, return false. Otherwise, return true.
            si r.est_true() || r.est_undefined() {
                r = Valeur(Boolean = faux)
            }
            sinon {
                r = Valeur(Boolean = vrai)
            }
        }
        InstanceOf {
            retourne instanceof_operator(interpréteuse, lval, rval)
        }
        In {
            // 5. If rVal is not an Object, throw a TypeError exception.
            saufsi rval.est_object() {
                message := imprime_chaine("'%' is not an Object", rval)
            _ := lance_type_error(interpréteuse, message)
            retourne throw_completion(interpréteuse.donne_exception())
            }

            // 6. Return ? HasProperty(rVal, ? ToPropertyKey(lVal)).
            P := to_property_key(interpréteuse, lval)
            si interpréteuse.possède_exception() {
                retourne throw_completion(interpréteuse.donne_exception())
            }

            résultat := has_property(rval.donne_objet(), P.String)
            si interpréteuse.possède_exception() {
                retourne throw_completion(interpréteuse.donne_exception())
            }
            retourne normal_completion(résultat)
        }
    }

    retourne normal_completion(r)
}

/* 13.10.2 InstanceofOperator ( V, target )
 * https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-instanceofoperator */
instanceof_operator :: fonc (interpréteuse: *Interpréteuse, V: Valeur, target: Valeur) -> CompletionRecord
{
    // 1. If target is not an Object, throw a TypeError exception.
    saufsi target.est_object() {
        _ := lance_type_error(interpréteuse, "target is not an Object")
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // À FAIRE : 2. Let instOfHandler be ? GetMethod(target, %Symbol.hasInstance%).
    // 3. If instOfHandler is not undefined, then
    //    a. Return ToBoolean(? Call(instOfHandler, target, « V »)).

    // 4. If IsCallable(target) is false, throw a TypeError exception.
    si is_callable(target).est_false() {
        _ := lance_type_error(interpréteuse, "target is not callable")
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 5. Return ? OrdinaryHasInstance(target, V).
    résultat := ordinary_has_instance(interpréteuse, target, V)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }
    retourne normal_completion(Valeur(Boolean = résultat))
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NumericLiteral
 * \{ */

NumericLiteral :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_numeric_literal

    valeur: r64
    // raw: ECMAString
}

crée_literal :: fonc (parseuse: *Parseuse, lexème: *Lexème, valeur: r64) -> *NumericLiteral
{
    résultat := parseuse.crée_noeud(lexème, NumericLiteral)
    résultat.sur_génération_code_binaire = numeric_literal_sur_code_binaire
    résultat.valeur = valeur
    retourne résultat
}

sur_exécution_numeric_literal :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre @inutilisée) -> CompletionRecord
{
    noeud := base comme *NumericLiteral
    retourne normal_completion(Valeur(Number = noeud.valeur))
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom BooleanLiteral
 * \{ */

BooleanLiteral :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_boolean_literal

    valeur: bool
}

crée_boolean_literal :: fonc (parseuse: *Parseuse, lexème: *Lexème, valeur: bool) -> *BooleanLiteral
{
    résultat := parseuse.crée_noeud(lexème, BooleanLiteral)
    résultat.sur_génération_code_binaire = boolean_literal_sur_code_binaire
    résultat.valeur = valeur
    retourne résultat
}

sur_exécution_boolean_literal :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre @inutilisée) -> CompletionRecord
{
    noeud := base comme *BooleanLiteral
    retourne normal_completion(Valeur(Boolean = noeud.valeur))
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NullLiteral
 * \{ */

NullLiteral :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_null_literal
}

crée_null_literal :: fonc (parseuse: *Parseuse, lexème: *Lexème) -> *NullLiteral
{
    résultat := parseuse.crée_noeud(lexème, NullLiteral)
    résultat.sur_génération_code_binaire = null_literal_sur_code_binaire
    retourne résultat
}

sur_exécution_null_literal :: fonc (base: *NoeudSyntaxique @inutilisée, interpréteuse: *InterprèteArbre @inutilisée) -> CompletionRecord
{
    retourne normal_completion(js_null)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom StringLiteral
 * \{ */

StringLiteral :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_string_literal

    valeur: ECMAString
    indice_chaine : z64 = -1
}

crée_literal :: fonc (parseuse: *Parseuse, lexème: *Lexème, valeur: ECMAString) -> *StringLiteral
{
    résultat := parseuse.crée_noeud(lexème, StringLiteral)
    résultat.sur_génération_code_binaire = string_literal_sur_code_binaire
    résultat.valeur = valeur
    retourne résultat
}

crée_literal :: fonc (parseuse: *Parseuse, lexème: *Lexème, valeur: chaine) -> *StringLiteral
{
    retourne crée_literal(parseuse, lexème, crée_chaine_utf16_unique(valeur))
}

sur_exécution_string_literal :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    noeud := base comme *StringLiteral

    realm := interpréteuse.donne_realm()

    chn: *PrimitiveChaine
    si noeud.indice_chaine == -1 {
        chn = crée_chaine(realm, noeud.valeur)
        tableau_ajoute(*realm.chaines_littérales, chn)
        noeud.indice_chaine = realm.chaines_littérales.taille - 1
    }
    sinon {
        chn = realm.chaines_littérales[noeud.indice_chaine]
    }

    retourne normal_completion(chn)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom CallExpression
 * \{ */

CallExpression :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_call_expression

    appelé: *Expression
    arguments: [..]*Expression
}

crée_call_expression :: fonc (parseuse: *Parseuse, lexème: *Lexème, appelé: *Expression, arguments: [..]*Expression) -> *CallExpression
{
    résultat := parseuse.crée_noeud(lexème, CallExpression)
    résultat.sur_génération_code_binaire = call_expression_sur_code_binaire
    résultat.appelé = appelé
    résultat.arguments = arguments
    retourne résultat
}

/* 13.3.6 Function Calls
 * https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-function-calls-runtime-semantics-evaluation */
sur_exécution_call_expression :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    noeud := base comme *CallExpression

    // CallExpression : CoverCallExpressionAndAsyncArrowHead
    si noeud.appelé.type != CallExpression {
        // 1. Let expr be the CallMemberExpression that is covered by CoverCallExpressionAndAsyncArrowHead.
        expr := noeud

        // 2. Let memberExpr be the MemberExpression of expr.
        member_expr := noeud.appelé

        // 3. Let arguments be the Arguments of expr.
        arguments := expr.arguments

        // 4. Let ref be ? Evaluation of memberExpr.
        completion_ref := exécute_noeud(member_expr, interpréteuse)
        saufsi completion_ref.est_normal() {
            retourne completion_ref
        }
        ref := completion_ref.valeur

        // 5. Let func be ? GetValue(ref).
        func := get_value(interpréteuse, ref)
        si interpréteuse.possède_exception() {
            retourne throw_completion(interpréteuse.donne_exception())
        }
        
        // 6. If ref is a Reference Record, IsPropertyReference(ref) is false, and ref.[[ReferencedName]] is "eval", then
        si ref.est_reference_record() && is_property_reference(ref) == faux && ref.R.referenced_name.valeur.String.texte == STR_eval {
            realm := interpréteuse.donne_realm()

            // a. If SameValue(func, %eval%) is true, then
            saufsi same_value(func, Valeur(Object = realm.intrinsics.eval)).est_false() {
                //  i. Let argList be ? ArgumentListEvaluation of arguments.
                arg_list: [..]Valeur
                diffère déloge(arg_list)

                completion_arg_list := argument_list_evaluation(interpréteuse, arguments, *arg_list)
                saufsi completion_arg_list.est_normal() {
                    retourne completion_arg_list
                }

                //  ii. If argList has no elements, return undefined.
                si arg_list.taille == 0 {
                    retourne normal_completion(js_undefined)
                }

                //  iii. Let evalArg be the first element of argList.
                eval_arg := arg_list[0]

                //  iv. If IsStrict(this CallExpression) is true, let strictCaller be true. Otherwise let strictCaller be false.
                strict_caller := is_strict(noeud)

                //  v. Return ? PerformEval(evalArg, strictCaller, true).
                résultat := perform_eval(interpréteuse, eval_arg, strict_caller, vrai)
                si interpréteuse.possède_exception() {
                    retourne throw_completion(interpréteuse.donne_exception())
                }
                retourne normal_completion(résultat)
            }
        }

        // 7. Let thisCall be this CallExpression.
        this_call := noeud

        // 8. Let tailCall be IsInTailPosition(thisCall).
        tail_call := is_in_tail_position(this_call)

        // 9. Return ? EvaluateCall(func, ref, arguments, tailCall).
        retourne evaluate_call(interpréteuse, func, ref, arguments, tail_call)
    }

    // CallExpression : CallExpression Arguments

    // 1. Let ref be ? Evaluation of CallExpression.
    completion_ref := exécute_noeud(noeud.appelé, interpréteuse)
    saufsi completion_ref.est_normal() {
        retourne completion_ref
    }

    ref := completion_ref.valeur

    // 2. Let func be ? GetValue(ref).
    func := get_value(interpréteuse, ref)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 3. Let thisCall be this CallExpression.
    this_call := noeud

    // 4. Let tailCall be IsInTailPosition(thisCall).
    tail_call := is_in_tail_position(this_call)

    // 5. Return ? EvaluateCall(func, ref, Arguments, tailCall).
    retourne evaluate_call(interpréteuse, func, ref, noeud.arguments, tail_call)
}

/* 13.3.6.2 EvaluateCall ( func, ref, arguments, tailPosition )
 * https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-evaluatecall */
evaluate_call :: fonc (interpréteuse: *InterprèteArbre, func: Valeur, ref: ValeurCompletion, arguments: []*Expression, tail_position: bool) -> CompletionRecord
{
    this_value: Valeur = ---
    // 1. If ref is a Reference Record, then
    si est_reference_record(ref) {
        // a. If IsPropertyReference(ref) is true, then
        si is_property_reference(ref) {
            // i. Let thisValue be GetThisValue(ref).
            this_value = get_this_value(ref.R)
        }
        // b. Else,
        sinon {
            // i. Let refEnv be ref.[[Base]].
            ref_env := ref.R.base.E
            // ii. Assert: refEnv is an Environment Record.
            // iii. Let thisValue be refEnv.WithBaseObject().
            this_value = ref_env.with_base_object()
        }
    }
    // 2. Else,
    sinon {
        // a. Let thisValue be undefined.
        this_value = js_undefined
    }

    // 3. Let argList be ? ArgumentListEvaluation of arguments.
    arg_list: [..]Valeur
    diffère déloge(arg_list)

    completion_arg_list := argument_list_evaluation(interpréteuse, arguments, *arg_list)
    saufsi completion_arg_list.est_normal() {
        retourne completion_arg_list
    }

    // 4. If func is not an Object, throw a TypeError exception.
    saufsi func.est_object() {
        message := imprime_chaine("'%' is not an Object", func)
        _ := lance_type_error(interpréteuse, message)
        retourne throw_completion(interpréteuse.donne_exception())
    }
    
    // 5. If IsCallable(func) is false, throw a TypeError exception.
    saufsi func.is_callable() {
        message := imprime_chaine("'%' is not callable", func)
        _ := lance_type_error(interpréteuse, message)
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 6. If tailPosition is true, perform PrepareForTailCall().
    si tail_position {
        prepare_for_tail_call(interpréteuse)
    }

    // 7. Return ? Call(func, thisValue, argList).
    résultat := call(interpréteuse, func, this_value, arg_list)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }
    retourne normal_completion(résultat)
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-runtime-semantics-argumentlistevaluation */
argument_list_evaluation :: fonc (interpréteuse: *InterprèteArbre, arguments: []*Expression, résultat: *[..]Valeur) -> CompletionRecord
{
    // À FAIRE : standardise
    pour arguments {
        /* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#prod-ArgumentList */
        si it.type == SpreadElement {
            spread := it comme *SpreadElement
            // 1. Let list be a new empty List.
            // 2. Let spreadRef be ? Evaluation of AssignmentExpression.
            completion := exécute_noeud(spread.argument, interpréteuse)
            saufsi completion.est_normal() {
                retourne completion
            }
            spread_ref := completion.valeur

            // 3. Let spreadObj be ? GetValue(spreadRef).
            spread_obj := get_value(interpréteuse, spread_ref)
            si interpréteuse.possède_exception() {
                retourne throw_completion(interpréteuse.donne_exception())
            }

            // 4. Let iteratorRecord be ? GetIterator(spreadObj, sync).
            iterator_record := get_iterator(interpréteuse, spread_obj, IteratorKind.SYNC)
            si interpréteuse.possède_exception() {
                retourne throw_completion(interpréteuse.donne_exception())
            }

            // 5. Repeat,
            boucle {
                // a. Let next be ? IteratorStepValue(iteratorRecord).
                next, done := iterator_step_value(interpréteuse, *iterator_record)

                // b. If next is done, return list.
                si done {
                    arrête
                }

                // c. Append next to list.
                tableau_ajoute(résultat, next)
            }

            continue
        }

        complétion_arg := exécute_noeud(it, interpréteuse)
        saufsi complétion_arg.est_normal() {
            retourne complétion_arg
        }
        valeur_arg := get_value(interpréteuse, complétion_arg.valeur)
        si interpréteuse.possède_exception() {
            retourne throw_completion(interpréteuse.donne_exception())
        }
        tableau_ajoute(résultat, valeur_arg)
    }

    retourne normal_completion(js_undefined)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom AssignmentExpression
 * \{ */

AssignmentOperation :: énum {
    Assigne /* = */
    Ajoute /* += */
    Soustrait /* -= */
    Exponentiation /* **= */
    Multiplie /* *= */
    Divise /* /= */
    Modulo /* %= */
    DécalageGauche /* <<= */
    DécalageDroite /* >>= */
    DécalageDroiteNaturel /* >>>= */
    EtBinaire /* &= */
    OuBinaire /* |= */
    OuExBinaire /* ^= */
    Coalesce /* ??= */
    OuLogique /* ||= */
    EtLogique /* &&=*/
}

AssignmentExpression :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_assignment_expression

    opération: AssignmentOperation
    gauche: *Expression
    droite: *Expression
}

crée_assignment_expression :: fonc (parseuse: *Parseuse, lexème: *Lexème, opération: AssignmentOperation, gauche: *Expression, droite: *Expression) -> *AssignmentExpression
{
    résultat := parseuse.crée_noeud(lexème, AssignmentExpression)
    résultat.sur_génération_code_binaire = assignment_expression_sur_code_binaire
    résultat.opération = opération
    résultat.gauche = gauche
    résultat.droite = droite
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-assignment-operators-runtime-semantics-evaluation */
sur_exécution_assignment_expression :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    noeud := base comme *AssignmentExpression
    si noeud.opération == AssignmentOperation.Assigne {
        retourne évalue_assignement_simple(noeud, interpréteuse)
    }
    si noeud.opération == AssignmentOperation.Coalesce {
        retourne évalue_coalesce_assignemnt(noeud, interpréteuse)
    }
    si noeud.opération == AssignmentOperation.OuLogique {
        retourne évalue_logical_or_assignemnt(noeud, interpréteuse)
    }
    si noeud.opération == AssignmentOperation.EtLogique {
        retourne évalue_logical_and_assignemnt(noeud, interpréteuse)
    }
    retourne évalue_assignement_opéré(noeud, interpréteuse)
}

évalue_assignement_simple :: fonc (noeud: *AssignmentExpression, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    // 1. If LeftHandSideExpression is neither an ObjectLiteral nor an ArrayLiteral, then
    si noeud.gauche.type != ObjectLiteral && noeud.gauche.type != ArrayLiteral {
        // a. Let lref be ? Evaluation of LeftHandSideExpression.
        completion_lref := exécute_noeud(noeud.gauche, interpréteuse)
        saufsi completion_lref.est_normal() {
            retourne completion_lref
        }
        lref := completion_lref.valeur

        rval: Valeur
        // b. If IsAnonymousFunctionDefinition(AssignmentExpression) is true and IsIdentifierRef of LeftHandSideExpression is true, then
        si is_anonymous_function_definition(noeud.droite) && is_identifier_ref(noeud.gauche) {
            // i. Let lhs be the StringValue of LeftHandSideExpression.
            lhs := (noeud.gauche comme *Identifier).nom

            // ii. Let rval be ? NamedEvaluation of AssignmentExpression with argument lhs.
            completion_rval := named_evaluation(interpréteuse, noeud.droite, lhs)
            saufsi completion_rval.est_normal() {
                retourne completion_rval
            }

            rval = completion_rval.valeur.V
        }
        // c. Else,
        sinon {
            // i. Let rref be ? Evaluation of AssignmentExpression.
            completion_rref := exécute_noeud(noeud.droite, interpréteuse)
            saufsi completion_rref.est_normal() {
                retourne completion_rref
            }
            rref := completion_rref.valeur

            // ii. Let rval be ? GetValue(rref).
            rval = get_value(interpréteuse, rref)
            si interpréteuse.possède_exception() {
                retourne throw_completion(interpréteuse.donne_exception())
            }
        }

        // d. Perform ? PutValue(lref, rval).
        _ := put_value(interpréteuse, lref, rval)
        si interpréteuse.possède_exception() {
            retourne throw_completion(interpréteuse.donne_exception())
        }

        // e. Return rval.
        retourne normal_completion(rval)
    }

    panique("assignement expression non-implémenté")
    // 2. Let assignmentPattern be the AssignmentPattern that is covered by LeftHandSideExpression.
    // 3. Let rref be ? Evaluation of AssignmentExpression.
    // 4. Let rval be ? GetValue(rref).
    // 5. Perform ? DestructuringAssignmentEvaluation of assignmentPattern with argument rval.
    // 6. Return rval.
}

évalue_assignement_opéré :: fonc (noeud: *AssignmentExpression, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    // 1. Let lref be ? Evaluation of LeftHandSideExpression.
    completion_lref := exécute_noeud(noeud.gauche, interpréteuse)
    saufsi completion_lref.est_normal() {
        retourne completion_lref
    }
    lref := completion_lref.valeur

    // 2. Let lval be ? GetValue(lref).
    lval := get_value(interpréteuse, lref)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 3. Let rref be ? Evaluation of AssignmentExpression.
    completion_rref := exécute_noeud(noeud.droite, interpréteuse)
    saufsi completion_rref.est_normal() {
        retourne completion_rref
    }
    rref := completion_rref.valeur

    // 4. Let rval be ? GetValue(rref).
    rval := get_value(interpréteuse, rref)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 5. Let assignmentOpText be the source text matched by AssignmentOperator.
    // 6. Let opText be the sequence of Unicode code points associated with assignmentOpText in the following table:
    opérateur_binaire: BinaryOperation
    discr noeud.opération {
        Assigne {
            panique("Assignement opéré via '=' qui devrait être un chemin différent.")
        }
        Coalesce {
            panique("Assignement opéré via '??=' qui devrait être un chemin différent.")
        }
        OuLogique {
            panique("Assignement opéré via '||=' qui devrait être un chemin différent.")
        }
        EtLogique {
            panique("Assignement opéré via '&&=' qui devrait être un chemin différent.")
        }
        Ajoute {
            opérateur_binaire = BinaryOperation.Plus
        }
        Soustrait {
            opérateur_binaire = BinaryOperation.Moins
        }
        Multiplie {
            opérateur_binaire = BinaryOperation.Multiplie
        }
        Divise {
            opérateur_binaire = BinaryOperation.Divise
        }
        Modulo {
            opérateur_binaire = BinaryOperation.Modulo
        }
        DécalageGauche {
            opérateur_binaire = BinaryOperation.DécalageGauche
        }
        DécalageDroite {
            opérateur_binaire = BinaryOperation.DécalageDroite
        }
        DécalageDroiteNaturel {
            opérateur_binaire = BinaryOperation.DécalageDroiteNaturel
        }
        EtBinaire {
            opérateur_binaire = BinaryOperation.EtBinaire
        }
        OuBinaire {
            opérateur_binaire = BinaryOperation.OuBinaire
        }
        OuExBinaire {
            opérateur_binaire = BinaryOperation.OuExclusif
        }
        Exponentiation {
            opérateur_binaire = BinaryOperation.Exponentiation
        }
    }

    // 7. Let r be ? ApplyStringOrNumericBinaryOperator(lval, opText, rval).
    completion := apply_string_or_numeric_binary_operator(interpréteuse, opérateur_binaire, lval, rval)
    saufsi completion.est_normal() {
        retourne completion
    }
    r := completion.valeur.V

    // 8. Perform ? PutValue(lref, r).
    _ := put_value(interpréteuse, lref, r)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 9. Return r.
    retourne normal_completion(r)
}

évalue_coalesce_assignemnt :: fonc (noeud: *AssignmentExpression, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    // 1. Let lRef be ? Evaluation of LeftHandSideExpression.
    completion_lref := exécute_noeud(noeud.gauche, interpréteuse)
    saufsi completion_lref.est_normal() {
        retourne completion_lref
    }
    lref := completion_lref.valeur

    // 2. Let lVal be ? GetValue(lRef).
    lval := get_value(interpréteuse, lref)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 3. If lVal is neither undefined nor null, return lVal.
    saufsi lval.est_nulle() || lval.est_undefined() {
        retourne normal_completion(lval)
    }

    rval: Valeur
    // 4. If IsAnonymousFunctionDefinition(AssignmentExpression) is true and IsIdentifierRef of LeftHandSideExpression is true, then
    si is_anonymous_function_definition(noeud.droite) && is_identifier_ref(noeud.gauche) {
        // a. Let lhs be the StringValue of LeftHandSideExpression.
        lhs := (noeud.gauche comme *Identifier).nom

        // ii. Let rval be ? NamedEvaluation of AssignmentExpression with argument lhs.
        completion_rval := named_evaluation(interpréteuse, noeud.droite, lhs)
        saufsi completion_rval.est_normal() {
            retourne completion_rval
        }

        rval = completion_rval.valeur.V
    }
    // 5. Else,
    sinon {
        // a. Let rRef be ? Evaluation of AssignmentExpression.
        completion_rref := exécute_noeud(noeud.droite, interpréteuse)
        saufsi completion_rref.est_normal() {
            retourne completion_rref
        }
        rref := completion_rref.valeur

        // b. Let rVal be ? GetValue(rRef).
        rval = get_value(interpréteuse, rref)
        si interpréteuse.possède_exception() {
            retourne throw_completion(interpréteuse.donne_exception())
        }
    }

    // 6. Perform ? PutValue(lRef, rVal).
    _ := put_value(interpréteuse, lref, rval)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 7. Return rVal.
    retourne normal_completion(rval)
}

évalue_logical_or_assignemnt :: fonc (noeud: *AssignmentExpression, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    // 1. Let lRef be ? Evaluation of LeftHandSideExpression.
    completion_lref := exécute_noeud(noeud.gauche, interpréteuse)
    saufsi completion_lref.est_normal() {
        retourne completion_lref
    }
    lref := completion_lref.valeur

    // 2. Let lVal be ? GetValue(lRef).
    lval := get_value(interpréteuse, lref)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 3. If ToBoolean(lVal) is true, return lVal.
    si to_boolean(lval).est_true() {
        retourne normal_completion(lval)
    }

    rval: Valeur
    // 4. If IsAnonymousFunctionDefinition(AssignmentExpression) is true and IsIdentifierRef of LeftHandSideExpression is true, then
    si is_anonymous_function_definition(noeud.droite) && is_identifier_ref(noeud.gauche) {
        // a. Let lhs be the StringValue of LeftHandSideExpression.
        lhs := (noeud.gauche comme *Identifier).nom

        // b. Let rVal be ? NamedEvaluation of AssignmentExpression with argument lhs.
        completion_rval := named_evaluation(interpréteuse, noeud.droite, lhs)
        saufsi completion_rval.est_normal() {
            retourne completion_rval
        }

        rval = completion_rval.valeur.V
    }
    // 5. Else,
    sinon {
        // a. Let rRef be ? Evaluation of AssignmentExpression.
        completion_rref := exécute_noeud(noeud.droite, interpréteuse)
        saufsi completion_rref.est_normal() {
            retourne completion_rref
        }
        rref := completion_rref.valeur

        // b. Let rVal be ? GetValue(rRef).
        rval = get_value(interpréteuse, rref)
        si interpréteuse.possède_exception() {
            retourne throw_completion(interpréteuse.donne_exception())
        }
    }

    // 6. Perform ? PutValue(lRef, rVal).
    _ := put_value(interpréteuse, lref, rval)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 7. Return rVal.
    retourne normal_completion(rval)
}

évalue_logical_and_assignemnt :: fonc (noeud: *AssignmentExpression, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    // 1. Let lRef be ? Evaluation of LeftHandSideExpression.
    completion_lref := exécute_noeud(noeud.gauche, interpréteuse)
    saufsi completion_lref.est_normal() {
        retourne completion_lref
    }
    lref := completion_lref.valeur

    // 2. Let lVal be ? GetValue(lRef).
    lval := get_value(interpréteuse, lref)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 3. If ToBoolean(lVal) is false, return lVal.
    si to_boolean(lval).est_false() {
        retourne normal_completion(lval)
    }

    rval: Valeur
    // 4. If IsAnonymousFunctionDefinition(AssignmentExpression) is true and IsIdentifierRef of LeftHandSideExpression is true, then
    si is_anonymous_function_definition(noeud.droite) && is_identifier_ref(noeud.gauche) {
        // a. Let lhs be the StringValue of LeftHandSideExpression.
        lhs := (noeud.gauche comme *Identifier).nom

        // b. Let rVal be ? NamedEvaluation of AssignmentExpression with argument lhs.
        completion_rval := named_evaluation(interpréteuse, noeud.droite, lhs)
        saufsi completion_rval.est_normal() {
            retourne completion_rval
        }

        rval = completion_rval.valeur.V
    }
    // 5. Else,
    sinon {
        // a. Let rRef be ? Evaluation of AssignmentExpression.
        completion_rref := exécute_noeud(noeud.droite, interpréteuse)
        saufsi completion_rref.est_normal() {
            retourne completion_rref
        }
        rref := completion_rref.valeur

        // b. Let rVal be ? GetValue(rRef).
        rval = get_value(interpréteuse, rref)
        si interpréteuse.possède_exception() {
            retourne throw_completion(interpréteuse.donne_exception())
        }
    }

    // 6. Perform ? PutValue(lRef, rVal).
    _ := put_value(interpréteuse, lref, rval)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 7. Return rVal.
    retourne normal_completion(rval)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom VariableDeclaration
 * \{ */

VariableDeclarationKind :: énum {
    Const
    Let
    Var
}

VariableDeclaration :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_variable_declaration

    nature: VariableDeclarationKind
    expressions: [..]*VariableDeclarator
}

crée_variable_declaration :: fonc (parseuse: *Parseuse, lexème: *Lexème, nature: VariableDeclarationKind, declarators: [..]*VariableDeclarator) -> *VariableDeclaration
{
    résultat := parseuse.crée_noeud(lexème, VariableDeclaration)
    résultat.sur_génération_code_binaire = variable_declaration_sur_code_binaire
    résultat.nature = nature
    résultat.expressions = declarators
    retourne résultat
}

sur_exécution_variable_declaration :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    noeud := base comme *VariableDeclaration
    
    dernière_valeur := normal_completion(js_undefined)

    si noeud.nature == VariableDeclarationKind.Var {
        pour noeud.expressions {
            dernière_valeur = évalue_variable_declaration(interpréteuse, it)
        }
    }
    sinon {
        pour noeud.expressions {
            dernière_valeur = évalue_lexical_declaration(interpréteuse, it)
        }
    }

    retourne dernière_valeur
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom VariableDeclarator
 * \{ */

VariableDeclarator :: struct {
    empl base: Expression
    type = #type_de_cette_structure

    id: *Expression
    init: *Expression
}

crée_variable_declarator :: fonc (parseuse: *Parseuse, lexème: *Lexème, id: *Expression, init: *Expression) -> *VariableDeclarator
{
    résultat := parseuse.crée_noeud(lexème, VariableDeclarator)
    résultat.id = id
    résultat.init = init
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-variable-statement */
évalue_variable_declaration :: fonc (interpréteuse: *InterprèteArbre, noeud: *VariableDeclarator) -> CompletionRecord
{
    assert(noeud.id.type == Identifier)
    identifier := noeud.id comme *Identifier

    saufsi noeud.init {
        // 1. Return EMPTY
        retourne empty_completion()
    }

    // 1. Let bindingId be the StringValue of BindingIdentifier.
    binding_id := identifier.donne_chaine_primitive(interpréteuse.donne_realm())

    // 2. Let lhs be ? ResolveBinding(bindingId).
    lhs := interpréteuse.resolve_binding(binding_id)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    valeur := js_undefined
    // 3. If IsAnonymousFunctionDefinition(Initializer) is true, then
    si is_anonymous_function_definition(noeud.init) {
        // a. Let value be ? NamedEvaluation of Initializer with argument bindingId.
        completion_valeur := named_evaluation(interpréteuse, noeud.init, binding_id.texte)
        saufsi completion_valeur.est_normal() {
            retourne completion_valeur
        }

        valeur = completion_valeur.valeur.V
    }
    // 4. Else,
    sinon {
        // a. Let rhs be ? Evaluation of Initializer.
        completion_valeur := exécute_noeud(noeud.init, interpréteuse)
        saufsi completion_valeur.est_normal() {
            retourne completion_valeur
        }
        // b. Let value be ? GetValue(rhs).
        valeur = get_value(interpréteuse, completion_valeur.valeur)
        si interpréteuse.possède_exception() {
            retourne throw_completion(interpréteuse.donne_exception())
        }
    }

    // 5. Perform ? PutValue(lhs, value).
    _ := put_value(interpréteuse, lhs, valeur)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 6. Return EMPTY.
    retourne empty_completion()
}

évalue_lexical_declaration :: fonc (interpréteuse: *InterprèteArbre, noeud: *VariableDeclarator) -> CompletionRecord
{
    assert(noeud.id.type == Identifier)
    binding_identifier := noeud.id comme *Identifier

    saufsi noeud.init {
        // 1. Let lhs be ! ResolveBinding(StringValue of BindingIdentifier).
        lhs := resolve_binding(interpréteuse, binding_identifier.donne_chaine_primitive(interpréteuse.donne_realm()))

        // 2. Perform ! InitializeReferencedBinding(lhs, undefined).
        initialize_reference_binding(lhs, js_undefined)

        // 3. Return empty.
        retourne empty_completion()
    }

    // 1. Let bindingId be the StringValue of BindingIdentifier.
    binding_id := binding_identifier.donne_chaine_primitive(interpréteuse.donne_realm())

    // 2. Let lhs be ! ResolveBinding(bindingId).
    lhs := resolve_binding(interpréteuse, binding_identifier.donne_chaine_primitive(interpréteuse.donne_realm()))

    valeur := js_undefined
    // 3. If IsAnonymousFunctionDefinition(Initializer) is true, then
    si is_anonymous_function_definition(noeud.init) {
        // a. Let value be ? NamedEvaluation of Initializer with argument bindingId.
        completion_valeur := named_evaluation(interpréteuse, noeud.init, binding_id.texte)
        saufsi completion_valeur.est_normal() {
            retourne completion_valeur
        }

        valeur = completion_valeur.valeur.V
    }
    // 4. Else,
    sinon {
        // a. Let rhs be ? Evaluation of Initializer.
        completion_valeur := exécute_noeud(noeud.init, interpréteuse)
        saufsi completion_valeur.est_normal() {
            retourne completion_valeur
        }
        // b. Let value be ? GetValue(rhs).
        valeur = get_value(interpréteuse, completion_valeur.valeur)
        si interpréteuse.possède_exception() {
            retourne throw_completion(interpréteuse.donne_exception())
        }
    }

    // 5. Perform ! InitializeReferencedBinding(lhs, value).
    initialize_reference_binding(lhs, valeur)

    // 6. Return empty.
    retourne empty_completion()
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom PropertyDefinition
 * \{ */

PropertyDefinition :: struct {
    empl base: Expression
    type = #type_de_cette_structure

    property_name: *Expression
    expression: *Expression
}

crée_property_definition :: fonc (parseuse: *Parseuse, lexème: *Lexème, property_name: *Expression, expression: *Expression) -> *PropertyDefinition
{
    résultat := parseuse.crée_noeud(lexème, PropertyDefinition)
    résultat.property_name = property_name
    résultat.expression = expression
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ObjectLiteral
 * \{ */

ObjectLiteral :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_object_literal

    properties: [..]*Expression
}

crée_object_literal :: fonc (parseuse: *Parseuse, lexème: *Lexème, properties: [..]*Expression) -> *ObjectLiteral
{
    résultat := parseuse.crée_noeud(lexème, ObjectLiteral)
    résultat.sur_génération_code_binaire = object_expression_sur_code_binaire
    résultat.properties = properties
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-object-initializer-runtime-semantics-evaluation */
sur_exécution_object_literal :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    noeud := base comme *ObjectLiteral

    // 1. Let obj be OrdinaryObjectCreate(%Object.prototype%).
    realm := interpréteuse.donne_realm()
    objet := ordinary_object_create(realm, realm.intrinsics.object_prototype, object_instance_crée)

    // 2. Perform ? PropertyDefinitionEvaluation of PropertyDefinitionList with argument obj.
    completion := property_definition_evaluation(interpréteuse, noeud.properties, objet)
    saufsi completion.est_normal() {
        retourne completion
    }

    // 3. Return obj.
    retourne normal_completion(Valeur(Object = objet))
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-runtime-semantics-propertydefinitionevaluation */
property_definition_evaluation :: fonc (interpréteuse: *InterprèteArbre, properties: []*Expression, object: *Object) -> CompletionRecord
{
    pour properties {
        si it.type == SpreadElement {
            spread := it comme *SpreadElement

            // 1. Let exprValue be ? Evaluation of AssignmentExpression.
            completion := exécute_noeud(spread.argument, interpréteuse)
            saufsi completion.est_normal() {
                retourne completion
            }
            expr_value := completion.valeur

            // 2. Let fromValue be ? GetValue(exprValue).
            from_value := get_value(interpréteuse, expr_value)
            si interpréteuse.possède_exception() {
                retourne throw_completion(interpréteuse.donne_exception())
            }

            // 3. Let excludedNames be a new empty List.
            excluded_names: []PropertyKey

            // 4. Perform ? CopyDataProperties(object, fromValue, excludedNames).
            copy_data_properties(interpréteuse, object, from_value, excluded_names)
            si interpréteuse.possède_exception() {
                retourne throw_completion(interpréteuse.donne_exception())
            }

            // 5. Return unused.
            continue
        }

        si it.type == Identifier {
            identifier_reference := it comme *Identifier

            // 1. Let propName be the StringValue of IdentifierReference.
            prop_name := identifier_reference.nom

            // 2. Let exprValue be ? Evaluation of IdentifierReference.
            completion := exécute_noeud(identifier_reference, interpréteuse)
            saufsi completion.est_normal() {
                retourne completion
            }
            expr_value := completion.valeur

            // 3. Let propValue be ? GetValue(exprValue).
            prop_value := get_value(interpréteuse, expr_value)
            si interpréteuse.possède_exception() {
                retourne throw_completion(interpréteuse.donne_exception())
            }
            
            // 4. Assert: object is an ordinary, extensible object with no non-configurable properties.

            // 5. Perform ! CreateDataPropertyOrThrow(object, propName, propValue).
            create_data_property_or_throw(object, prop_name, prop_value)

            // 6. Return unused.
            continue
        }

        si it.type == ObjectMethod {
            // 1. Perform ? MethodDefinitionEvaluation of MethodDefinition with arguments object and true.
            _ := method_definition_evaluation(interpréteuse, it comme *ObjectMethod, object, vrai)
            si interpréteuse.possède_exception() {
                retourne throw_completion(interpréteuse.donne_exception())
            }

            // 2. Return unused.
            continue
        }

        assert(it.type == PropertyDefinition)
        property_definition := it comme *PropertyDefinition

        // 1. Let propKey be ? Evaluation of PropertyName.
        prop_key := évalue_property_name(interpréteuse, property_definition.property_name)
        si interpréteuse.possède_exception() {
            retourne throw_completion(interpréteuse.donne_exception())
        }

        // À FAIRE : complète
        is_proto_setter := faux
        // 2. If this PropertyDefinition is contained within a Script that is being evaluated for JSON.parse (see step 7 of JSON.parse), then
            // a. Let isProtoSetter be false.
        // 3. Else if propKey is "__proto__" and IsComputedPropertyKey of PropertyName is false, then
            // a. Let isProtoSetter be true.
        // 4. Else,
            // a. Let isProtoSetter be false.
        // 5. If IsAnonymousFunctionDefinition(AssignmentExpression) is true and isProtoSetter is false, then
        prop_value: Valeur
        si is_anonymous_function_definition(property_definition.expression) && is_proto_setter == faux {
            // a. Let propValue be ? NamedEvaluation of AssignmentExpression with argument propKey.
            completion := named_evaluation(interpréteuse, property_definition.expression, donne_field_name(prop_key))
            saufsi completion.est_normal() {
                retourne completion
            }

            prop_value = completion.valeur.V
        }
        // 6. Else,
        sinon {
            // a. Let exprValueRef be ? Evaluation of AssignmentExpression.
            completion := exécute_noeud(property_definition.expression, interpréteuse)
            saufsi completion.est_normal() {
                retourne completion
            }
            expr_value_ref := completion.valeur
            // b. Let propValue be ? GetValue(exprValueRef).
            prop_value = get_value(interpréteuse, expr_value_ref)
            si interpréteuse.possède_exception() {
                retourne throw_completion(interpréteuse.donne_exception())
            }
        }
        // 7. If isProtoSetter is true, then
            // a. If propValue is an Object or propValue is null, then
                // i. Perform ! object.[[SetPrototypeOf]](propValue).
            // b. Return UNUSED.
        // 8. Assert: object is an ordinary, extensible object with no non-configurable properties.
        // 9. Perform ! CreateDataPropertyOrThrow(object, propKey, propValue).
        create_data_property_or_throw(object, prop_key, prop_value)
        // 10. Return UNUSED.
    }

    retourne normal_completion(js_undefined)
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-object-initializer-runtime-semantics-evaluation */
évalue_property_name :: fonc (interpréteuse: *Interpréteuse, expression: *Expression) -> PropertyKey
{
    si expression.type == StringLiteral {
        string := expression comme *StringLiteral
        retourne string.valeur
    }

    si expression.type == NumericLiteral {
        number := expression comme *NumericLiteral
        valeur := Valeur(Number = number.valeur)
        realm := interpréteuse.donne_realm()
        retourne to_string(realm, valeur).texte
    }

    si expression.type == ComputedPropertyName {
        computed_property_name := expression comme *ComputedPropertyName

        // 1. Let exprValue be ? Evaluation of AssignmentExpression.
        assert(interpréteuse.type == InterprèteArbre)
        completion := exécute_noeud(computed_property_name.expression, interpréteuse comme *InterprèteArbre)
        saufsi completion.est_normal() {
            interpréteuse.définis_exception(completion)
            résultat: PropertyKey
            retourne résultat
        }
        expr_value := completion.valeur

        // 2. Let propName be ? GetValue(exprValue).
        prop_name := get_value(interpréteuse, expr_value)
        si interpréteuse.possède_exception() {
            résultat: PropertyKey
            retourne résultat
        }

        // 3. Return ? ToPropertyKey(propName).
        retourne to_property_key(interpréteuse, prop_name)
    }

    assert(expression.type == Identifier)
    ident := expression comme *Identifier
    retourne ident.nom
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ArrayLiteral
 * \{ */

ArrayLiteral :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_array_literal

    éléments: [..]*Expression
}

crée_array_literal :: fonc (parseuse: *Parseuse, lexème: *Lexème, éléments: [..]*Expression) -> *ArrayLiteral
{
    résultat := parseuse.crée_noeud(lexème, ArrayLiteral)
    résultat.sur_génération_code_binaire = array_literal_sur_code_binaire
    résultat.éléments = éléments
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-runtime-semantics-arrayaccumulation */
sur_exécution_array_literal :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    /* À FAIRE : standardise. */
    noeud := base comme *ArrayLiteral

    realm := interpréteuse.donne_realm()

    résultat := crée_array(realm.donne_tas_de_mémoire(), realm.intrinsics.array_prototype, 0)

    next_index: z64

    pour noeud.éléments {
        /* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#prod-Elision */
        saufsi it {
            /* Élision. */
            next_index += 1
            continue
        }

        /* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#prod-SpreadElement */
        si it.type == SpreadElement {
            spread := it comme *SpreadElement

            // 1. Let spreadRef be ? Evaluation of AssignmentExpression.
            completion := exécute_noeud(spread.argument, interpréteuse)
            saufsi completion.est_normal() {
                retourne completion
            }
            spread_ref := completion.valeur

            // 2. Let spreadObj be ? GetValue(spreadRef).
            spread_obj := get_value(interpréteuse, spread_ref)
            si interpréteuse.possède_exception() {
                retourne throw_completion(interpréteuse.donne_exception())
            }

            // 3. Let iteratorRecord be ? GetIterator(spreadObj, sync).
            iterator_record := get_iterator(interpréteuse, spread_obj, IteratorKind.SYNC)
            si interpréteuse.possède_exception() {
                retourne throw_completion(interpréteuse.donne_exception())
            }

            // 4. Repeat,
            boucle {
                // a. Let next be ? IteratorStepValue(iteratorRecord).
                next, done := iterator_step_value(interpréteuse, *iterator_record)

                // b. If next is done, return nextIndex.
                si done {
                    arrête
                }

                // c. Perform ! CreateDataPropertyOrThrow(array, ! ToString(𝔽(nextIndex)), next).
                nom_propriété := to_string(interpréteuse, Valeur(Number = next_index comme r64)).texte
                _ := create_data_property(résultat, nom_propriété, next)

                // d. Set nextIndex to nextIndex + 1.
                next_index = next_index + 1
            }

            continue
        }

        completion := exécute_noeud(it, interpréteuse)
        saufsi completion.est_normal() {
            retourne completion
        }
        valeur := get_value(interpréteuse, completion.valeur)
        si interpréteuse.possède_exception() {
            retourne throw_completion(interpréteuse.donne_exception())
        }

        nom_propriété := to_string(interpréteuse, Valeur(Number = next_index comme r64)).texte

        _ := create_data_property(résultat, nom_propriété, valeur)

        next_index += 1
    }

    set(résultat, STR_length, Valeur(Number = next_index comme r64), vrai)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    retourne normal_completion(Valeur(Object = résultat))
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom MemberExpression
 * \{ */

MemberExpression :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_member_expression

    objet: *Expression
    propriété: *Expression
    calculé := faux
}

crée_member_expression :: fonc (parseuse: *Parseuse, lexème: *Lexème, objet: *Expression, propriété: *Expression, calculé: bool) -> *MemberExpression
{
    résultat := parseuse.crée_noeud(lexème, MemberExpression)
    résultat.sur_génération_code_binaire = member_expression_sur_code_binaire
    résultat.objet = objet
    résultat.propriété = propriété
    résultat.calculé = calculé
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-property-accessors-runtime-semantics-evaluation */
sur_exécution_member_expression :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    member := base comme *MemberExpression

    si member.propriété.type == PrivateIdentifier {
        private_identifier := member.propriété comme *PrivateIdentifier

        // 1. Let baseReference be ? Evaluation of MemberExpression.
        completion_base_reference := exécute_noeud(member.objet, interpréteuse)
        saufsi completion_base_reference.est_normal() {
            retourne completion_base_reference
        }
        base_reference := completion_base_reference.valeur
    
        // 2. Let baseValue be ? GetValue(baseReference).
        base_value := get_value(interpréteuse, base_reference)
        si interpréteuse.possède_exception() {
            retourne throw_completion(interpréteuse.donne_exception())
        }

        // 3. Let fieldNameString be the StringValue of PrivateIdentifier.
        field_name_string := private_identifier.nom

        // 4. Return MakePrivateReference(baseValue, fieldNameString).
        référence := make_private_reference(interpréteuse, base_value, field_name_string)
        retourne normal_completion(référence)
    }

    // 1. Let baseReference be ? Evaluation of MemberExpression.
    completion_base_reference := exécute_noeud(member.objet, interpréteuse)
    saufsi completion_base_reference.est_normal() {
        retourne completion_base_reference
    }
    base_reference := completion_base_reference.valeur

    // 2. Let baseValue be ? GetValue(baseReference).
    base_value := get_value(interpréteuse, base_reference)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 3. Let strict be IsStrict(this MemberExpression).
    strict := is_strict(member)

    si member.calculé {
        // MemberExpression : MemberExpression [ Expression ]
        retourne evaluate_property_access_with_expression_key(interpréteuse, base_value, member.propriété, strict)
    }

    // MemberExpression : MemberExpression . IdentifierName
    assert(member.propriété.type == Identifier)
    identifier := member.propriété comme *Identifier

    retourne evaluate_property_access_with_identifier_key(interpréteuse, base_value, identifier, strict)
}

/* 13.3.3 EvaluatePropertyAccessWithExpressionKey ( baseValue, expression, strict )
 * https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-evaluate-property-access-with-expression-key */
evaluate_property_access_with_expression_key :: fonc (interpréteuse: *InterprèteArbre, base_value: Valeur, expression: *NoeudSyntaxique, strict: bool) -> CompletionRecord
{
    // 1. Let propertyNameReference be ? Evaluation of expression.
    completion_expression := exécute_noeud(expression, interpréteuse)
    saufsi completion_expression.est_normal() {
        retourne completion_expression
    }
    property_name_reference := completion_expression.valeur

    // 2. Let propertyNameValue be ? GetValue(propertyNameReference).
    property_name_value := get_value(interpréteuse, property_name_reference)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 3. NOTE: In most cases, ToPropertyKey will be performed on propertyNameValue
    //    immediately after this step. However, in the case of a[b] = c, it will
    //    not be performed until after evaluation of c.

    // 4. Return the Reference Record { [[Base]]: baseValue, [[ReferencedName]]: propertyNameValue, [[Strict]]: strict, [[ThisValue]]: EMPTY }.
    résultat: ReferenceRecord
    résultat.base = base_value
    résultat.referenced_name = property_name_value
    résultat.strict = strict
    retourne normal_completion(résultat)
}

/* 13.3.4 EvaluatePropertyAccessWithIdentifierKey ( baseValue, identifierName, strict )
 * https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-evaluate-property-access-with-identifier-key */
evaluate_property_access_with_identifier_key :: fonc (interpréteuse: *InterprèteArbre, base_value: Valeur, identifier_name: *Identifier, strict: bool) -> CompletionRecord
{
    // 1. Let propertyNameString be the StringValue of identifierName.
    property_name_string := crée_chaine(interpréteuse.donne_realm(), identifier_name.nom)

    // 2. Return the Reference Record { [[Base]]: baseValue, [[ReferencedName]]: propertyNameString, [[Strict]]: strict, [[ThisValue]]: EMPTY }.
    résultat: ReferenceRecord
    résultat.base = base_value
    résultat.referenced_name = Valeur(String = property_name_string)
    résultat.strict = strict
    retourne normal_completion(résultat)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom UpdateExpression
 * \{ */

UpdateOperation :: énum {
    PrefixIncrement
    PrefixDecrement
    PostfixIncrement
    PostfixDecrement
}

UpdateExpression :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_update_expression

    argument: *Expression
    operation: UpdateOperation
}

crée_update_expression :: fonc (parseuse: *Parseuse, lexème: *Lexème, argument: *Expression, operation: UpdateOperation) -> *UpdateExpression
{
    résultat := parseuse.crée_noeud(lexème, UpdateExpression)
    résultat.sur_génération_code_binaire = update_expression_sur_code_binaire
    résultat.argument = argument
    résultat.operation = operation
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-postfix-increment-operator */
sur_exécution_update_expression :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    update := base comme *UpdateExpression

    // 1. Let lhs be ? Evaluation of LeftHandSideExpression.
    complétion_lhs := exécute_noeud(update.argument, interpréteuse)
    saufsi complétion_lhs.est_normal() {
        retourne complétion_lhs
    }
    lhs := complétion_lhs.valeur

    // 2. Let oldValue be ? ToNumeric(? GetValue(lhs)).
    lhs_value := get_value(interpréteuse, lhs)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    old_value := to_numeric(interpréteuse, lhs_value)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    nouvelle_valeur: Valeur

    // 3. If oldValue is a Number, then
    si est_nombre(old_value) {
        // a. Let newValue be Number::add(oldValue, 1𝔽).
        // NOTE : nous faison ++ et -- directement.
        si update.operation == UpdateOperation.PostfixIncrement || update.operation == UpdateOperation.PrefixIncrement {
            nouvelle_valeur = number_add(old_value, Valeur(Number = 1))
        }
        sinon {
            nouvelle_valeur = number_subtract(old_value, Valeur(Number = 1))
        }
    }
    // 4. Else,
    sinon {
        // a. Assert: oldValue is a BigInt.
        // b. Let newValue be BigInt::add(oldValue, 1ℤ).
        panique("update expression sur BigInt non-implémentée")
    }

    // 5. Perform ? PutValue(lhs, newValue).
    _ := put_value(interpréteuse, lhs, nouvelle_valeur)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    si update.operation == UpdateOperation.PrefixIncrement || update.operation == UpdateOperation.PrefixDecrement {
        retourne normal_completion(nouvelle_valeur)
    }

    // 6. Return oldValue.
    retourne normal_completion(old_value)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ContinueStatement
 * \{ */

ContinueStatement :: struct {
    empl base: Statement
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_continue_statement

    target: *Expression
}

crée_continue_statement :: fonc (parseuse: *Parseuse, lexème: *Lexème, target: *Expression) -> *ContinueStatement
{
    résultat := parseuse.crée_noeud(lexème, ContinueStatement)
    résultat.sur_génération_code_binaire = continue_statement_sur_code_binaire
    résultat.target = target
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-continue-statement-runtime-semantics-evaluation */
sur_exécution_continue_statement :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre @inutilisée) -> CompletionRecord
{
    statement := base comme *ContinueStatement

    si statement.target {
        assert(statement.target.type == Identifier)
        cible := statement.target comme *Identifier

        // 1. Let label be the StringValue of LabelIdentifier.
        label := cible.nom

        // 2. Return Completion Record { [[Type]]: continue, [[Value]]: empty, [[Target]]: label }.
        retourne continue_completion(label)
    }

    // 1. Return Completion Record { [[Type]]: continue, [[Value]]: empty, [[Target]]: empty }.
    retourne continue_completion(crée_chaine_utf16_unique_vide())
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom BreakStatement
 * \{ */

BreakStatement :: struct {
    empl base: Statement
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_break_statement

    target: *Expression
}

crée_break_statement :: fonc (parseuse: *Parseuse, lexème: *Lexème, target: *Expression) -> *BreakStatement
{
    résultat := parseuse.crée_noeud(lexème, BreakStatement)
    résultat.sur_génération_code_binaire = break_statement_sur_code_binaire
    résultat.target = target
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-break-statement-runtime-semantics-evaluation */
sur_exécution_break_statement :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre @inutilisée) -> CompletionRecord
{
    statement := base comme *BreakStatement

    si statement.target {
        assert(statement.target.type == Identifier)
        cible := statement.target comme *Identifier

        // 1. Let label be the StringValue of LabelIdentifier.
        label := cible.nom

        // 2. Return Completion Record { [[Type]]: break, [[Value]]: empty, [[Target]]: label }.
        retourne break_completion(label)
    }

    // 1. Return Completion Record { [[Type]]: break, [[Value]]: empty, [[Target]]: empty }.
    retourne break_completion(crée_chaine_utf16_unique_vide())
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ForStatement
 * \{ */

ForStatement :: struct {
    empl base: Statement
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_for_statement

    init: *Expression
    test: *Expression
    update: *Expression
    body: *Statement
}

crée_for_statement :: fonc (parseuse: *Parseuse, lexème: *Lexème, init: *Expression, test: *Expression, update: *Expression, body: *Statement) -> *ForStatement
{
    résultat := parseuse.crée_noeud(lexème, ForStatement)
    résultat.sur_génération_code_binaire = for_statement_sur_code_binaire
    résultat.init = init
    résultat.test = test
    résultat.update = update
    résultat.body = body
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-for-statement */
sur_exécution_for_statement :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    for := base comme *ForStatement

    si for_statement_possède_lexical_declaration(for) {
        mv := interpréteuse.mv
        running_execution_context := mv.donne_running_execution_context()

        // 1. Let oldEnv be the running execution context's LexicalEnvironment.
        old_env := running_execution_context.lexical_environment

        // 2. Let loopEnv be NewDeclarativeEnvironment(oldEnv).
        loop_env := new_declarative_environment(old_env.donne_tas_de_mémoire(), old_env)

        // 3. Let isConst be IsConstantDeclaration of LexicalDeclaration.
        lexical_declaration := for.init comme *VariableDeclaration
        is_const := lexical_declaration.nature == VariableDeclarationKind.Const

        // 4. Let boundNames be the BoundNames of LexicalDeclaration.
        bound_names: [..]ECMAString
        diffère déloge(bound_names)
        donne_bound_names(lexical_declaration, *bound_names)

        // 5. For each element dn of boundNames, do
        pour bound_names {
            // a. If isConst is true, then
            si is_const {
                // i. Perform ! loopEnv.CreateImmutableBinding(dn, true).
                _ := loop_env.create_immutable_binding(interpréteuse.donne_realm(), it, vrai)
            }
            // b. Else,
            sinon {
                // i. Perform ! loopEnv.CreateMutableBinding(dn, false).
                loop_env.create_mutable_binding(interpréteuse.donne_realm(), it, faux)
            }
        }

        // 6. Set the running execution context's LexicalEnvironment to loopEnv.
        running_execution_context.lexical_environment = loop_env

        // 7. Let forDcl be Completion(Evaluation of LexicalDeclaration).
        completion := exécute_noeud(lexical_declaration, interpréteuse)

        // 8. If forDcl is an abrupt completion, then
        saufsi completion.est_normal() {
            // a. Set the running execution context's LexicalEnvironment to oldEnv.
            running_execution_context.lexical_environment = old_env

            // b. Return ? forDcl.
            retourne completion
        }

        // 9. If isConst is false, let perIterationLets be boundNames; otherwise let perIterationLets be a new empty List.
        per_iteration_lets := bound_names
        si is_const {
            per_iteration_lets.taille = 0
        }

        // 10. If the first Expression is present, let test be the first Expression; otherwise, let test be empty.
        test := for.test

        // 11. If the second Expression is present, let increment be the second Expression; otherwise, let increment be empty.
        increment := for.update

        // 12. Let bodyResult be Completion(ForBodyEvaluation(test, increment, Statement, perIterationLets, labelSet)).
        body_result := for_body_evaluation(interpréteuse, test, increment, for.body, per_iteration_lets)

        // 13. Set the running execution context's LexicalEnvironment to oldEnv.
        running_execution_context.lexical_environment = old_env

        // 14. Return ? bodyResult.
        retourne body_result
    }

    // 1. Perform ? Evaluation of VariableDeclarationList.
    si for.init {
        doit_continuer := exécute_noeud(for.init, interpréteuse)
        saufsi doit_continuer.est_normal() {
            retourne doit_continuer
        }
    }

    // 2. If the first Expression is present, let test be the first Expression; otherwise, let test be empty.
    test := for.test

    // 3. If the second Expression is present, let increment be the second Expression; otherwise, let increment be empty.
    increment := for.update

    // 4. Return ? ForBodyEvaluation(test, increment, Statement, « », labelSet).
    per_iteration_lets: []ECMAString
    retourne for_body_evaluation(interpréteuse, test, increment, for.body, per_iteration_lets)
}

for_statement_possède_lexical_declaration :: fonc (for: *ForStatement) -> bool
{
    saufsi for.init {
        retourne faux
    }

    saufsi for.init.type == VariableDeclaration {
        retourne faux
    }

    declaration := for.init comme *VariableDeclaration
    retourne declaration.nature != VariableDeclarationKind.Var
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-forbodyevaluation */
for_body_evaluation :: fonc (interpréteuse: *InterprèteArbre, test: *Expression, increment: *Expression, stmt: *Statement , per_iteration_bindings: []ECMAString) -> CompletionRecord
{
    // 1. Let V be undefined.
    V := js_undefined

    // 2. Perform ? CreatePerIterationEnvironment(perIterationBindings).
    completion := create_per_iteration_environment(interpréteuse, per_iteration_bindings)
    saufsi completion.est_normal() {
        retourne completion
    }

    // 3. Repeat,
    boucle {
        // a. If test is not empty, then
        si test {
            // i. Let testRef be ? Evaluation of test.
            doit_continuer := exécute_noeud(test, interpréteuse)
            saufsi doit_continuer.est_normal() {
                retourne doit_continuer
            }

            // ii. Let testValue be ? GetValue(testRef).
            test_value := get_value(interpréteuse, doit_continuer.valeur)
            si interpréteuse.possède_exception() {
                retourne throw_completion(interpréteuse.donne_exception())
            }

            // iii. If ToBoolean(testValue) is false, return V.
            valeur := to_boolean(test_value)
            saufsi valeur {
                arrête
            }
        }

        // b. Let result be Completion(Evaluation of stmt).
        // À FAIRE c. If LoopContinues(result, labelSet) is false, return ? UpdateEmpty(result, V).
        // À FAIRE d. If result.[[Value]] is not empty, set V to result.[[Value]].
        doit_continuer := exécute_noeud(stmt, interpréteuse)
        si doit_continuer.est_continue() {
            // OK.
        }
        sinon si doit_continuer.est_break() {
            arrête
        }
        sinon saufsi doit_continuer.est_normal() {
            retourne doit_continuer
        }

        // e. Perform ? CreatePerIterationEnvironment(perIterationBindings).
        completion = create_per_iteration_environment(interpréteuse, per_iteration_bindings)
        saufsi completion.est_normal() {
            retourne completion
        }

        // f. If increment is not empty, then
        si increment {
            // i. Let incRef be ? Evaluation of increment.
            doit_continuer = exécute_noeud(increment, interpréteuse)
            saufsi doit_continuer.est_normal() {
                retourne doit_continuer
            }
            // ii. Perform ? GetValue(incRef).
            _ := get_value(interpréteuse, doit_continuer.valeur)
            si interpréteuse.possède_exception() {
                retourne throw_completion(interpréteuse.donne_exception())
            }
        }
    }

    retourne normal_completion(V)
}

/* 14.7.4.4 CreatePerIterationEnvironment ( perIterationBindings )
 * https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-createperiterationenvironment */
create_per_iteration_environment :: fonc (interpréteuse: *Interpréteuse, per_iteration_bindings: []ECMAString) -> CompletionRecord
{
    // 1. If perIterationBindings has any elements, then
    si per_iteration_bindings.taille != 0 {
        mv := interpréteuse.mv
        running_execution_context := mv.donne_running_execution_context()

        // a. Let lastIterationEnv be the running execution context's LexicalEnvironment.
        last_iteration_env := running_execution_context.lexical_environment

        // b. Let outer be lastIterationEnv.[[OuterEnv]].
        outer := last_iteration_env.outer_environment

        // c. Assert: outer is not null.
        assert(outer != nul)

        // d. Let thisIterationEnv be NewDeclarativeEnvironment(outer).
        this_iteration_env := new_declarative_environment(outer.donne_tas_de_mémoire(), outer)

        // e. For each element bn of perIterationBindings, do
        pour per_iteration_bindings {
            // i. Perform ! thisIterationEnv.CreateMutableBinding(bn, false).
            this_iteration_env.create_mutable_binding(interpréteuse.donne_realm(), it, faux)

            // ii. Let lastValue be ? lastIterationEnv.GetBindingValue(bn, true).
            last_value := last_iteration_env.get_binding_value(interpréteuse.donne_realm(), it, vrai)
            si interpréteuse.possède_exception() {
                retourne throw_completion(interpréteuse.donne_exception())
            }

            // iii. Perform ! thisIterationEnv.InitializeBinding(bn, lastValue).
            this_iteration_env.initialize_binding(it, last_value)
        }

        // f. Set the running execution context's LexicalEnvironment to thisIterationEnv.
        running_execution_context.lexical_environment = this_iteration_env
    }

    // 2. Return unused.
    retourne normal_completion(js_undefined)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ForOfStatement
 * \{ */

ForOfStatement :: struct {
    empl base: Statement
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_for_of_statement

    left: *Expression
    right: *Expression
    body: *Statement
}

crée_for_of_statement :: fonc (parseuse: *Parseuse, lexème: *Lexème, left: *Expression, right: *Expression, body: *Statement) -> *ForOfStatement
{
    résultat := parseuse.crée_noeud(lexème, ForOfStatement)
    résultat.left = left
    résultat.right = right
    résultat.body = body
    retourne résultat
}

sur_exécution_for_of_statement :: fonc (base: *NoeudSyntaxique @inutilisée, interpréteuse: *InterprèteArbre @inutilisée) -> CompletionRecord
{
    retourne normal_completion(js_undefined)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ForInStatement
 * \{ */

ForInStatement :: struct {
    empl base: Statement
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_for_in_statement

    left: *Expression
    right: *Expression
    body: *Statement
}

crée_for_in_statement :: fonc (parseuse: *Parseuse, lexème: *Lexème, left: *Expression, right: *Expression, body: *Statement) -> *ForInStatement
{
    résultat := parseuse.crée_noeud(lexème, ForInStatement)
    résultat.left = left
    résultat.right = right
    résultat.body = body
    retourne résultat
}

sur_exécution_for_in_statement :: fonc (base: *NoeudSyntaxique @inutilisée, interpréteuse: *InterprèteArbre @inutilisée) -> CompletionRecord
{
    retourne normal_completion(js_undefined)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom WhileStatement
 * \{ */

WhileStatement :: struct {
    empl base: Statement
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_while_statement

    test: *Expression
    body: *Statement
}

crée_while_statement :: fonc (parseuse: *Parseuse, lexème: *Lexème, test: *Expression, body: *Statement) -> *WhileStatement
{
    résultat := parseuse.crée_noeud(lexème, WhileStatement)
    résultat.sur_génération_code_binaire = while_statement_sur_code_binaire
    résultat.test = test
    résultat.body = body
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-runtime-semantics-whileloopevaluation */
sur_exécution_while_statement :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    // À FAIRE : standardise
    while := base comme *WhileStatement

    boucle {
        doit_continuer := exécute_noeud(while.test, interpréteuse)
        saufsi doit_continuer.est_normal() {
            retourne doit_continuer
        }
        valeur := get_value(interpréteuse, doit_continuer.valeur)
        si interpréteuse.possède_exception() {
            retourne throw_completion(interpréteuse.donne_exception())
        }

        saufsi to_boolean(valeur) {
            arrête
        }

        doit_continuer = exécute_noeud(while.body, interpréteuse)
        si doit_continuer.est_continue() {
            // OK.
        }
        sinon si doit_continuer.est_break() {
            arrête
        }
        sinon saufsi doit_continuer.est_normal() {
            retourne doit_continuer
        }
    }
    
    retourne normal_completion(js_undefined)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom DoWhileStatement
 * \{ */

DoWhileStatement :: struct {
    empl base: Statement
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_do_while_statement

    body: *Statement
    test: *Expression
}

crée_do_while_statement :: fonc (parseuse: *Parseuse, lexème: *Lexème, body: *Statement, test: *Expression) -> *DoWhileStatement
{
    résultat := parseuse.crée_noeud(lexème, DoWhileStatement)
    résultat.sur_génération_code_binaire = do_while_statement_sur_code_binaire
    résultat.body = body
    résultat.test = test
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-runtime-semantics-do_whileloopevaluation */
sur_exécution_do_while_statement :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    // À FAIRE : standardise
    do_while := base comme *DoWhileStatement

    boucle {
        doit_continuer := exécute_noeud(do_while.body, interpréteuse)
        si doit_continuer.est_continue() {
            // OK.
        }
        sinon si doit_continuer.est_break() {
            arrête
        }
        sinon saufsi doit_continuer.est_normal() {
            retourne doit_continuer
        }

        doit_continuer = exécute_noeud(do_while.test, interpréteuse)
        saufsi doit_continuer.est_normal() {
            retourne doit_continuer
        }
        valeur := get_value(interpréteuse, doit_continuer.valeur)
        si interpréteuse.possède_exception() {
            retourne throw_completion(interpréteuse.donne_exception())
        }

        saufsi to_boolean(valeur) {
            arrête
        }
    }
    
    retourne normal_completion(js_undefined)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ConditionalExpression
 * \{ */

ConditionalExpression :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_conditional_expression

    test: *Expression
    consequent: *Expression
    alternate: *Expression
}

crée_conditional_expression :: fonc (parseuse: *Parseuse, lexème: *Lexème, test: *Expression, consequent: *Expression, alternate: *Expression) -> *ConditionalExpression
{
    résultat := parseuse.crée_noeud(lexème, ConditionalExpression)
    résultat.sur_génération_code_binaire = conditional_expression_sur_code_binaire
    résultat.test = test
    résultat.consequent = consequent
    résultat.alternate = alternate
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-conditional-operator-runtime-semantics-evaluation */
sur_exécution_conditional_expression :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    conditional := base comme *ConditionalExpression

    // 1. Let lRef be ? Evaluation of ShortCircuitExpression.
    completion := exécute_noeud(conditional.test, interpréteuse)
    saufsi completion.est_normal() {
        retourne completion
    }
    lref := completion.valeur

    // 2. Let lVal be ToBoolean(? GetValue(lRef)).
    valeur_lval := get_value(interpréteuse, lref)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }
    lval := to_boolean(valeur_lval)

    expr: *NoeudSyntaxique
    // 3. If lVal is true, then
    si lval.est_true() {
        // a. Let trueRef be ? Evaluation of the first AssignmentExpression.
        // b. Return ? GetValue(trueRef).
        expr = conditional.consequent
    }
    // 4. Else,
    sinon {
        // a. Let falseRef be ? Evaluation of the second AssignmentExpression.
        // b. Return ? GetValue(falseRef).
        expr = conditional.alternate
    }

    completion = exécute_noeud(expr, interpréteuse)
    saufsi completion.est_normal() {
        retourne completion
    }
    ref := completion.valeur
    résultat := get_value(interpréteuse, ref)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }
    retourne normal_completion(résultat)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom IfStatement
 * \{ */

IfStatement :: struct {
    empl base: Statement
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_if_statement

    test: *Expression
    consequent: *Statement
    alternate: *Statement
}

crée_if_statement :: fonc (parseuse: *Parseuse, lexème: *Lexème, test: *Expression, consequent: *Statement, alternate: *Statement) -> *IfStatement
{
    résultat := parseuse.crée_noeud(lexème, IfStatement)
    résultat.sur_génération_code_binaire = if_statement_sur_code_binaire
    résultat.test = test
    résultat.consequent = consequent
    résultat.alternate = alternate
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-if-statement */
sur_exécution_if_statement :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    if := base comme *IfStatement

    // 1. Let exprRef be ? Evaluation of Expression.
    complétion_expr_ref := exécute_noeud(if.test, interpréteuse)
    saufsi complétion_expr_ref.est_normal() {
        retourne complétion_expr_ref
    }
    expr_ref := complétion_expr_ref.valeur

    // 2. Let exprValue be ToBoolean(? GetValue(exprRef)).
    value_expr_ref := get_value(interpréteuse, expr_ref)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }
    expr_value := to_boolean(value_expr_ref)

    stmt_completion: CompletionRecord

    // 3. If exprValue is true, then
    si expr_value.est_true() {
        // a. Let stmtCompletion be Completion(Evaluation of the first Statement).
        stmt_completion = exécute_noeud(if.consequent, interpréteuse)
    }
    // 4. Else,
    sinon {
        si if.alternate == nul {
            /* NOTE : ceci provient du deuxième cas. */
            retourne normal_completion(js_undefined)
        }

        // a. Let stmtCompletion be Completion(Evaluation of the second Statement).
        stmt_completion = exécute_noeud(if.alternate, interpréteuse)
    }

    // 5. Return ? UpdateEmpty(stmtCompletion, undefined).
    retourne update_empty(stmt_completion, js_undefined)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom TypeofOperator
 * \{ */

TypeofOperator :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_typeof_operator

    argument: *Expression
}

crée_typeof_operator :: fonc (parseuse: *Parseuse, lexème: *Lexème, argument: *Expression) -> *TypeofOperator
{
    résultat := parseuse.crée_noeud(lexème, TypeofOperator)
    résultat.sur_génération_code_binaire = typeof_operator_sur_code_binaire
    résultat.argument = argument
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-typeof-operator-runtime-semantics-evaluation */
sur_exécution_typeof_operator :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    typeof := base comme *TypeofOperator

    // 1. Let val be ? Evaluation of UnaryExpression.
    completion_val := exécute_noeud(typeof.argument, interpréteuse)
    saufsi completion_val.est_normal() {
        retourne completion_val
    }
    val := completion_val.valeur

    // 2. If val is a Reference Record, then
    si est_reference_record(val) {
        // a. If IsUnresolvableReference(val) is true, return "undefined".
        si is_unresolvable_reference(val) {
            retourne crée_string_value_completion(interpréteuse, STR_undefined)
        }
    }

    // 3. Set val to ? GetValue(val).
    valeur := get_value(interpréteuse, val)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    chn := donne_chaine_pour_typeof(valeur)
    retourne crée_string_value_completion(interpréteuse, chn)
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-typeof-operator-runtime-semantics-evaluation */
donne_chaine_pour_typeof :: fonc (valeur: Valeur) -> ECMAString
{
    // 4. If val is undefined, return "undefined".
    si valeur.est_undefined() {
        retourne STR_undefined
    }

    // 5. If val is null, return "object".
    si valeur.est_nulle() {
        retourne STR_object
    }

    // 6. If val is a String, return "string".
    si valeur.est_chaine() {
        retourne STR_string
    }

    // 7. If val is a Symbol, return "symbol".
    si valeur.est_symbol() {
        retourne STR_symbol
    }

    // 8. If val is a Boolean, return "boolean".
    si valeur.est_boolean() {
        retourne STR_boolean
    }

    // 9. If val is a Number, return "number".
    si valeur.est_nombre() {
        retourne STR_number
    }

    // 10. If val is a BigInt, return "bigint".
    si valeur.est_big_int() {
        retourne STR_bigint
    }

    // 11. Assert: val is an Object.
    objet := valeur.donne_objet()

    // À FAIRE : 12. NOTE: This step is replaced in section B.3.6.3.
    // 13. If val has a [[Call]] internal slot, return "function".
    si objet.donne_table().sur_call {
        retourne STR_function
    }

    // 14. Return "object".
    retourne STR_object
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom VoidOperator
 * \{ */

VoidOperator :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_void_operator

    argument: *Expression
}

crée_void_operator :: fonc (parseuse: *Parseuse, lexème: *Lexème, argument: *Expression) -> *VoidOperator
{
    résultat := parseuse.crée_noeud(lexème, VoidOperator)
    résultat.sur_génération_code_binaire = void_operator_sur_code_binaire
    résultat.argument = argument
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-void-operator-runtime-semantics-evaluation */
sur_exécution_void_operator :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    void := base comme *VoidOperator

    // 1. Let expr be ? Evaluation of UnaryExpression.
    completion := exécute_noeud(void.argument, interpréteuse)
    saufsi completion.est_normal() {
        retourne completion
    }
    expr := completion.valeur

    // 2. Perform ? GetValue(expr).
    _ := get_value(interpréteuse, expr)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 3. Return undefined.
    retourne normal_completion(js_undefined)
}

/** \} */
/* ------------------------------------------------------------------------- */
/** \nom DeleteOperator
 * \{ */

DeleteOperator :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_delete_operator

    argument: *Expression
}

crée_delete_operator :: fonc (parseuse: *Parseuse, lexème: *Lexème, argument: *Expression) -> *DeleteOperator
{
    résultat := parseuse.crée_noeud(lexème, DeleteOperator)
    résultat.argument = argument
    retourne résultat
}

sur_exécution_delete_operator :: fonc (base: *NoeudSyntaxique @inutilisée, interpréteuse: *InterprèteArbre @inutilisée) -> CompletionRecord
{
    panique("non-implémenté")
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ThrowStatement
 * https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-throw-statement
 * \{ */

ThrowStatement :: struct {
    empl base: Statement
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_throw_statement

    argument: *Expression
}

crée_throw_statement :: fonc (parseuse: *Parseuse, lexème: *Lexème, argument: *Expression) -> *ThrowStatement
{
    résultat := parseuse.crée_noeud(lexème, ThrowStatement)
    résultat.sur_génération_code_binaire = throw_statement_sur_code_binaire
    résultat.argument = argument
    retourne résultat
}

sur_exécution_throw_statement :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    throw := base comme *ThrowStatement

    // 1. Let exprRef be ? Evaluation of Expression.
    completion_expr_ref := exécute_noeud(throw.argument, interpréteuse)
    saufsi completion_expr_ref.est_normal() {
        retourne completion_expr_ref
    }
    expr_ref := completion_expr_ref.valeur

    // 2. Let exprValue be ? GetValue(exprRef).
    expr_value := get_value(interpréteuse, expr_ref)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 3. Return ThrowCompletion(exprValue).
    retourne throw_completion(expr_value)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom TryStatement
 * https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-try-statement
 * \{ */

TryStatement :: struct {
    empl base: Statement
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_try_statement

    block: *Statement
    handler: *CatchClause
    finalizer: *Statement
}

crée_try_statement :: fonc (parseuse: *Parseuse, lexème: *Lexème, block: *Statement, handler: *CatchClause, finalizer: *Statement) -> *TryStatement
{
    résultat := parseuse.crée_noeud(lexème, TryStatement)
    résultat.sur_génération_code_binaire = try_statement_sur_code_binaire
    résultat.block = block
    résultat.handler = handler
    résultat.finalizer = finalizer
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-try-statement-runtime-semantics-evaluation */
sur_exécution_try_statement :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    try := base comme *TryStatement

    si try.handler != nul && try.finalizer == nul {
        // 1. Let B be Completion(Evaluation of Block).
        B := exécute_noeud(try.block, interpréteuse)

        // 2. If B is a throw completion, let C be Completion(CatchClauseEvaluation of Catch with argument B.[[Value]]).
        C: CompletionRecord
        si B.est_throw() {
            C = catch_clause_evaluation(try.handler, interpréteuse, B.valeur)
        }
        // 3. Else, let C be B.
        sinon {
            C = B
        }

        // 4. Return ? UpdateEmpty(C, undefined).
        retourne update_empty(C, js_undefined)
    }

    si try.handler == nul && try.finalizer != nul {
        // 1. Let B be Completion(Evaluation of Block).
        B := exécute_noeud(try.block, interpréteuse)

        // 2. Let F be Completion(Evaluation of Finally).
        F := exécute_noeud(try.finalizer, interpréteuse)

        // 3. If F is a normal completion, set F to B.
        si F.est_normal() {
            F = B
        }

        // 4. Return ? UpdateEmpty(F, undefined).
        retourne update_empty(F, js_undefined)
    }

    // 1. Let B be Completion(Evaluation of Block).
    B := exécute_noeud(try.block, interpréteuse)

    // 2. If B is a throw completion, let C be Completion(CatchClauseEvaluation of Catch with argument B.[[Value]]).
    C: CompletionRecord
    si B.est_throw() {
        C = catch_clause_evaluation(try.handler, interpréteuse, B.valeur)
    }
    // 3. Else, let C be B.
    sinon {
        C = B
    }

    // 4. Let F be Completion(Evaluation of Finally).
    F := exécute_noeud(try.finalizer, interpréteuse)

    // 5. If F is a normal completion, set F to C.
    si F.est_normal() {
        F = C
    }

    // 6. Return ? UpdateEmpty(F, undefined).
    retourne update_empty(F, js_undefined)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom CatchClause
 * https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-try-statement
 * \{ */

CatchClause :: struct {
    empl base: Statement
    type = #type_de_cette_structure

    param: *Expression
    body: *Statement
}

crée_catch_clause :: fonc (parseuse: *Parseuse, lexème: *Lexème, param: *Expression, body: *Statement) -> *CatchClause
{
    résultat := parseuse.crée_noeud(lexème, CatchClause)
    résultat.param = param
    résultat.body = body
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-runtime-semantics-catchclauseevaluation */
catch_clause_evaluation :: fonc (catch: *CatchClause, interpréteuse: *InterprèteArbre, thrown_value: Valeur) -> CompletionRecord
{
    saufsi catch.param {
        // 1. Return ? Evaluation of Block.
        retourne exécute_noeud(catch.body, interpréteuse)
    }

    assert(catch.param.type == Identifier)
    identifier := catch.param comme *Identifier
    arg_name := identifier.nom

    status, old_env := crée_environnement_lexical_pour_catch(interpréteuse, arg_name, thrown_value)
    si status.est_abrupt() {
        retourne status
    }
    assert(old_env != nul)

    // 7. Let B be Completion(Evaluation of Block).
    B := exécute_noeud(catch.body, interpréteuse)

    // 8. Set the running execution context's LexicalEnvironment to oldEnv.
    mv := interpréteuse.mv
    running_execution_context := mv.donne_running_execution_context()
    running_execution_context.lexical_environment = old_env

    // 9. Return ? B.
    retourne B
}

crée_environnement_lexical_pour_catch :: fonc (interpréteuse: *Interpréteuse, arg_name: ECMAString, thrown_value: Valeur) -> CompletionRecord, *Environment
{
    mv := interpréteuse.mv
    running_execution_context := mv.donne_running_execution_context()

    // 1. Let oldEnv be the running execution context's LexicalEnvironment.
    old_env := running_execution_context.lexical_environment

    // 2. Let catchEnv be NewDeclarativeEnvironment(oldEnv).
    catch_env := new_declarative_environment(old_env.donne_tas_de_mémoire(), old_env)

    // À FAIRE : 3. For each element argName of the BoundNames of CatchParameter, do
    //    a. Perform ! catchEnv.CreateMutableBinding(argName, false).
    catch_env.create_mutable_binding(interpréteuse.donne_realm(), arg_name, faux)

    // 4. Set the running execution context's LexicalEnvironment to catchEnv.
    running_execution_context.lexical_environment = catch_env

    // À FAIRE : 5. Let status be Completion(BindingInitialization of CatchParameter with arguments thrownValue and catchEnv).
    catch_env.initialize_binding(arg_name, thrown_value)

    // 6. If status is an abrupt completion, then
    si interpréteuse.possède_exception() {
        // a. Set the running execution context's LexicalEnvironment to oldEnv.
        running_execution_context.lexical_environment = old_env

        // b. Return ? status.
        retourne throw_completion(interpréteuse.donne_exception()), nul
    }

    retourne normal_completion(js_undefined), old_env
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NewExpression
 * \{ */

NewExpression :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_new_expression

    argument: *Expression
}

crée_new_expression :: fonc (parseuse: *Parseuse, lexème: *Lexème, argument: *Expression) -> *NewExpression
{
    résultat := parseuse.crée_noeud(lexème, NewExpression)
    résultat.sur_génération_code_binaire = new_expression_sur_code_binaire
    résultat.argument = argument
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-new-operator-runtime-semantics-evaluation */
sur_exécution_new_expression :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    new := base comme *NewExpression

    construct_expr: *NoeudSyntaxique
    arguments: []*Expression

    si new.argument.type == CallExpression {
        call := new.argument comme *CallExpression
        construct_expr = call.appelé
        arguments = call.arguments
    }
    sinon {
        construct_expr = new.argument
    }

    retourne evaluate_new(interpréteuse, construct_expr, arguments)
}

/* 13.3.5.1.1 EvaluateNew ( constructExpr, arguments )
 * https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-new-operator-runtime-semantics-evaluation */
evaluate_new :: fonc (interpréteuse: *InterprèteArbre, construct_expr: *NoeudSyntaxique, arguments: []*Expression) -> CompletionRecord
{
    // 1. Let ref be ? Evaluation of constructExpr.
    completion_ref := exécute_noeud(construct_expr, interpréteuse)
    saufsi completion_ref.est_normal() {
        retourne completion_ref
    }
    ref := completion_ref.valeur

    // 2. Let constructor be ? GetValue(ref).
    constructor := get_value(interpréteuse, ref)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    arg_list: [..]Valeur
    diffère déloge(arg_list)
    // 3. If arguments is empty, then
        // a. Let argList be a new empty List.
    // 4. Else,
    si arguments.taille != 0 {
        // a. Let argList be ? ArgumentListEvaluation of arguments.
        completion_arg_list := argument_list_evaluation(interpréteuse, arguments, *arg_list)
        saufsi completion_arg_list.est_normal() {
            retourne completion_arg_list
        }
    }

    // 5. If IsConstructor(constructor) is false, throw a TypeError exception.
    saufsi is_constructor(constructor) {
        _ := lance_type_error(interpréteuse, "expression is not a constructor")
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 6. Return ? Construct(constructor, argList).
    résultat := construct(interpréteuse, constructor, arg_list)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }
    retourne normal_completion(résultat)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom SwitchStatement
 * \{ */

SwitchStatement :: struct {
    empl base: Statement
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_switch_statement

    discriminant: *Expression
    cases: [..]*CaseClause
    index_default_clause: z64
}

crée_switch_statement :: fonc (parseuse: *Parseuse, lexème: *Lexème, discriminant: *Expression, cases: [..]*CaseClause, index_default_clause: z64) -> *SwitchStatement
{
    résultat := parseuse.crée_noeud(lexème, SwitchStatement)
    résultat.sur_génération_code_binaire = switch_statement_sur_code_binaire
    résultat.discriminant = discriminant
    résultat.cases = cases
    résultat.index_default_clause = index_default_clause
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-switch-statement-runtime-semantics-evaluation */
sur_exécution_switch_statement :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    switch := base comme *SwitchStatement

    // 1. Let exprRef be ? Evaluation of Expression.
    completion := exécute_noeud(switch.discriminant, interpréteuse)
    saufsi completion.est_normal() {
        retourne completion
    }
    expr_ref := completion.valeur

    // 2. Let switchValue be ? GetValue(exprRef).
    switch_value := get_value(interpréteuse, expr_ref)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 3. Let oldEnv be the running execution context's LexicalEnvironment.
    mv := interpréteuse.mv
    running_execution_context := mv.donne_running_execution_context()
    old_env := running_execution_context.lexical_environment

    // 4. Let blockEnv be NewDeclarativeEnvironment(oldEnv).
    block_env := new_declarative_environment(old_env.donne_tas_de_mémoire(), old_env)

    // 5. Perform BlockDeclarationInstantiation(CaseBlock, blockEnv).
    block_declaration_instantiation(interpréteuse, switch, block_env)

    // 6. Set the running execution context's LexicalEnvironment to blockEnv.
    running_execution_context.lexical_environment = block_env

    // 7. Let R be Completion(CaseBlockEvaluation of CaseBlock with argument switchValue).
    R := case_block_evaluation(switch, interpréteuse, switch_value)

    // 8. Set the running execution context's LexicalEnvironment to oldEnv.
    running_execution_context.lexical_environment = old_env

    // À FAIRE : ceci n'est pas spécifié, mais une complétion de BREAK est
    // propagée car abrupte et fait échouer les programmes.
    si R.est_break() {
        R.type = CompletionRecord.Type.NORMAL
    }

    // 9. Return R.
    retourne R
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-runtime-semantics-caseblockevaluation */
case_block_evaluation :: fonc (switch: *SwitchStatement, interpréteuse: *InterprèteArbre, input: Valeur) -> CompletionRecord
{
    si switch.cases.taille == 0 {
        // 1. Return undefined.
        retourne normal_completion(js_undefined)
    }

    si switch.index_default_clause == -1 {
        // 1. Let V be undefined.
        V := js_undefined

        // 2. Let A be the List of CaseClause items in CaseClauses, in source text order.
        A := switch.cases

        // 3. Let found be false.
        found := faux

        // 4. For each CaseClause C of A, do
        pour A {
            // a. If found is false, then
            saufsi found {
                // i. Set found to ? CaseClauseIsSelected(C, input).
                completion := case_clause_is_selected(interpréteuse, it, input)
                saufsi completion.est_normal() {
                    retourne completion
                }

                found = completion.valeur.V.est_true()
            }
            // b. If found is true, then
            si found {
                // i. Let R be Completion(Evaluation of C).
                R := exécute_noeud(it, interpréteuse)

                // ii. If R.[[Value]] is not empty, set V to R.[[Value]].
                saufsi R.valeur.est_empty() {
                    V = R.valeur.V
                }

                // iii. If R is an abrupt completion, return ? UpdateEmpty(R, V).
                si R.est_abrupt() {
                    retourne update_empty(R, V)
                }
            }
        }

        // 5. Return V.
        retourne normal_completion(V)
    }

    // 1. Let V be undefined.
    V := js_undefined

    // 2. If the first CaseClauses is present, then
        // a. Let A be the List of CaseClause items in the first CaseClauses, in source text order.
    // 3. Else,
        // a. Let A be a new empty List.
    A := tableau_donne_tranche(switch.cases, 0, switch.index_default_clause - 1)

    // 4. Let found be false.
    found := faux

    // 5. For each CaseClause C of A, do
    pour A {
        // a. If found is false, then
        saufsi found {
            // i. Set found to ? CaseClauseIsSelected(C, input).
            completion := case_clause_is_selected(interpréteuse, it, input)
            saufsi completion.est_normal() {
                retourne completion
            }

            found = completion.valeur.V.est_true()
        }
        // b. If found is true, then
        si found {
            // i. Let R be Completion(Evaluation of C).
            R := exécute_noeud(it, interpréteuse)

            // ii. If R.[[Value]] is not empty, set V to R.[[Value]].
            saufsi R.valeur.est_empty() {
                V = R.valeur.V
            }

            // iii. If R is an abrupt completion, return ? UpdateEmpty(R, V).
            si R.est_abrupt() {
                retourne update_empty(R, V)
            }
        }
    }

    // 6. Let foundInB be false.
    found_in_b := faux

    // 7. If the second CaseClauses is present, then
        // a. Let B be the List of CaseClause items in the second CaseClauses, in source text order.
    // 8. Else,
        // a. Let B be a new empty List.
    B := tableau_donne_tranche(switch.cases, switch.index_default_clause + 1, switch.cases.taille - 1)

    // 9. If found is false, then
    saufsi found {
        // a. For each CaseClause C of B, do
        pour B {
            // i. If foundInB is false, then
            saufsi found_in_b {
                // 1. Set foundInB to ? CaseClauseIsSelected(C, input).
                completion := case_clause_is_selected(interpréteuse, it, input)
                saufsi completion.est_normal() {
                    retourne completion
                }

                found_in_b = completion.valeur.V.est_true()
            }
            // ii. If foundInB is true, then
            si found_in_b {
                // 1. Let R be Completion(Evaluation of CaseClause C).
                R := exécute_noeud(it, interpréteuse)

                // 2. If R.[[Value]] is not empty, set V to R.[[Value]].
                saufsi R.valeur.est_empty() {
                    V = R.valeur.V
                }

                // 3. If R is an abrupt completion, return ? UpdateEmpty(R, V).
                si R.est_abrupt() {
                    retourne update_empty(R, V)
                }
            }
        }
    }

    // 10. If foundInB is true, return V.
    si found_in_b {
        retourne normal_completion(V)
    }

    // 11. Let defaultR be Completion(Evaluation of DefaultClause).
    default_r := exécute_noeud(switch.cases[switch.index_default_clause], interpréteuse)
    saufsi default_r.est_normal() {
        retourne default_r
    }

    // 12. If defaultR.[[Value]] is not empty, set V to defaultR.[[Value]].
    saufsi default_r.valeur.est_empty() {
        V = default_r.valeur.V
    }

    // 13. If defaultR is an abrupt completion, return ? UpdateEmpty(defaultR, V).
    si default_r.est_abrupt() {
        retourne update_empty(default_r, V)
    }

    // 14. NOTE: The following is another complete iteration of the second CaseClauses.
    // 15. For each CaseClause C of B, do
    pour B {
        // a. Let R be Completion(Evaluation of CaseClause C).
        R := exécute_noeud(it, interpréteuse)

        // b. If R.[[Value]] is not empty, set V to R.[[Value]].
        saufsi R.valeur.est_empty() {
            V = R.valeur.V
        }

        // c. If R is an abrupt completion, return ? UpdateEmpty(R, V).
        si R.est_abrupt() {
            retourne update_empty(R, V)
        }
    }

    // 16. Return V.
    retourne normal_completion(V)
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-runtime-semantics-caseclauseisselected */
case_clause_is_selected :: fonc (interpréteuse: *InterprèteArbre, clause: *CaseClause, input: Valeur) -> CompletionRecord
{
    // 1. Assert: C is an instance of the production CaseClause : case Expression : StatementListopt .
    // NOTE : nous pouvons avoir default close
    assert(clause.type == CaseClause)

    // 2. Let exprRef be ? Evaluation of the Expression of C.
    completion := exécute_noeud(clause.test, interpréteuse)
    saufsi completion.est_normal() {
        retourne completion
    }
    expr_ref := completion.valeur

    // 3. Let clauseSelector be ? GetValue(exprRef).
    clause_selector := get_value(interpréteuse, expr_ref)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 4. Return IsStrictlyEqual(input, clauseSelector).
    retourne normal_completion(is_strictly_equal(input, clause_selector))
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom CaseClause
 * \{ */

CaseClause :: struct {
    empl base: Statement
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_case_clause

    test: *Expression
    consequent: *Statement // StatementList
}

crée_case_clause :: fonc (parseuse: *Parseuse, lexème: *Lexème, test: *Expression, consequent: *Statement) -> *CaseClause
{
    résultat := parseuse.crée_noeud(lexème, CaseClause)
    résultat.test = test
    résultat.consequent = consequent
    retourne résultat
}

sur_exécution_case_clause :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    case := base comme *CaseClause

    si case.consequent == nul {
        // 1. Return empty.
        retourne normal_completion(js_undefined)
    }

    retourne exécute_noeud(case.consequent, interpréteuse)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom DefaultClause
 * \{ */

DefaultClause :: struct {
    empl case_clause: CaseClause
    type = #type_de_cette_structure
}

crée_default_clause :: fonc (parseuse: *Parseuse, lexème: *Lexème, consequent: *Statement) -> *DefaultClause
{
    résultat := parseuse.crée_noeud(lexème, DefaultClause)
    résultat.consequent = consequent
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom CommaExpression
 * \{ */

CommaExpression :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_comma_expression

    left: *Expression
    right: *Expression
}

crée_comma_expression :: fonc (parseuse: *Parseuse, lexème: *Lexème, left: *Expression, right: *Expression) -> *CommaExpression
{
    résultat := parseuse.crée_noeud(lexème, CommaExpression)
    résultat.sur_génération_code_binaire = comma_statement_sur_code_binaire
    résultat.left = left
    résultat.right = right
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-comma-operator-runtime-semantics-evaluation */
sur_exécution_comma_expression :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    comma := base comme *CommaExpression

    // 1. Let lRef be ? Evaluation of Expression.
    completion := exécute_noeud(comma.left, interpréteuse)
    saufsi completion.est_normal() {
        retourne completion
    }

    // 2. Perform ? GetValue(lRef).
    _ := get_value(interpréteuse, completion.valeur)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 3. Let rRef be ? Evaluation of AssignmentExpression.
    completion = exécute_noeud(comma.right, interpréteuse)
    saufsi completion.est_normal() {
        retourne completion
    }

    // 4. Return ? GetValue(rRef).
    résultat := get_value(interpréteuse, completion.valeur)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }
    retourne normal_completion(résultat)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom LabelledStatement
 * \{ */

LabelledStatement :: struct {
    empl base: Statement
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_labelled_statement

    identifier: ECMAString
    statement: *Statement
}

crée_labelled_statement :: fonc (parseuse: *Parseuse, lexème: *Lexème, identifier: ECMAString, statement: *Statement) -> *LabelledStatement
{
    résultat := parseuse.crée_noeud(lexème, LabelledStatement)
    résultat.identifier = identifier
    résultat.statement = statement
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-labelled-statements-runtime-semantics-evaluation */
sur_exécution_labelled_statement :: fonc (base: *NoeudSyntaxique @inutilisée, interpréteuse: *InterprèteArbre @inutilisée) -> CompletionRecord
{
    panique("non-implémené")
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom DebuggerStatement
 * \{ */

DebuggerStatement :: struct {
    empl base: Statement
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_debugger_statement
}

crée_debugger_statement :: fonc (parseuse: *Parseuse, lexème: *Lexème) -> *DebuggerStatement
{
    résultat := parseuse.crée_noeud(lexème, DebuggerStatement)
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-debugger-statements-runtime-semantics-evaluation */
sur_exécution_debugger_statement :: fonc (base: *NoeudSyntaxique @inutilisée, interpréteuse: *InterprèteArbre @inutilisée) -> CompletionRecord
{
    // À FAIRE : supporte debugger
    retourne normal_completion(js_undefined)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom TemplateLiteral
 * \{ */

TemplateLiteral :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_template_literal

    quasis: [..]*TemplateElement
    expressions: [..]*Expression
}

crée_template_literal :: fonc (parseuse: *Parseuse, lexème: *Lexème, quasis: [..]*TemplateElement) -> *TemplateLiteral
{
    résultat := parseuse.crée_noeud(lexème, TemplateLiteral)
    résultat.quasis = quasis
    retourne résultat
}

crée_template_literal :: fonc (parseuse: *Parseuse, lexème: *Lexème, quasis: [..]*TemplateElement, expressions: [..]*Expression) -> *TemplateLiteral
{
    résultat := crée_template_literal(parseuse, lexème, quasis)
    résultat.expressions = expressions
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-template-literals-runtime-semantics-evaluation */
sur_exécution_template_literal :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    template := base comme *TemplateLiteral

    quasi := template.quasis[0]
    si template.quasis.taille == 1 {
        retourne crée_string_value_completion(interpréteuse, quasi.value)
    }

    chaines: [..]*PrimitiveChaine
    diffère déloge(chaines)

    realm := interpréteuse.donne_realm()
    tableau_ajoute(*chaines, crée_chaine(realm, quasi.value))

    indice_expression := 0

    tantque indice_expression < template.expressions.taille {
        expression := template.expressions[indice_expression]
        indice_expression += 1

        completion := exécute_noeud(expression, interpréteuse)
        saufsi completion.est_normal() {
            retourne completion
        }
        valeur := get_value(interpréteuse, completion.valeur)
        si interpréteuse.possède_exception() {
            retourne throw_completion(interpréteuse.donne_exception())
        }
        str := to_string(interpréteuse, valeur)
        si interpréteuse.possède_exception() {
            retourne throw_completion(interpréteuse.donne_exception())
        }
        tableau_ajoute(*chaines, str)

        quasi = template.quasis[indice_expression]
        tableau_ajoute(*chaines, crée_chaine(realm, quasi.value))
    }

    résultat := chaines[0]

    pour 1 ... chaines.taille - 1 {
        résultat = concatène(realm, résultat, chaines[it])
    }

    value := Valeur(String = résultat)
    retourne normal_completion(value)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom TemplateElement
 * \{ */

TemplateElement :: struct {
    empl base: Expression
    type = #type_de_cette_structure

    value: ECMAString
    tail: bool
}

crée_template_element :: fonc (parseuse: *Parseuse, lexème: *Lexème, value: ECMAString, tail: bool) -> *TemplateElement
{
    résultat := parseuse.crée_noeud(lexème, TemplateElement)
    résultat.value = value
    résultat.tail = tail
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom SpreadElement
 * \{ */

SpreadElement :: struct {
    empl base: Expression
    type = #type_de_cette_structure

    argument: *Expression
}

crée_spread_element :: fonc (parseuse: *Parseuse, lexème: *Lexème, argument: *Expression) -> *SpreadElement
{
    résultat := parseuse.crée_noeud(lexème, SpreadElement)
    résultat.argument = argument
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ObjectMethod
 * \{ */

MethodKind :: énum {
    Method
    Get
    Set
    Constructor
}

ObjectMethod :: struct {
    empl base: Expression
    type = #type_de_cette_structure

    class_element_name: *Expression
    paramètres: [..]*Expression
    body: *FunctionBody

    est_méthode: bool
    async: bool
    generator: bool
    kind: MethodKind
}

crée_object_method :: fonc (parseuse: *Parseuse, lexème: *Lexème, class_element_name: *Expression, paramètres: [..]*Expression, body: *FunctionBody, kind: MethodKind, async: bool, generator: bool) -> *ObjectMethod
{
    résultat := parseuse.crée_noeud(lexème, ObjectMethod)
    résultat.class_element_name = class_element_name
    résultat.paramètres = paramètres
    résultat.body = body
    résultat.est_méthode = kind == MethodKind.Method
    résultat.kind = kind
    résultat.async = async
    résultat.generator = generator
    retourne résultat
}

MethodDefinitionInfo :: struct {
    closure: *ECMAScriptFunction
    key: FieldName
}

/* 15.4.4 Runtime Semantics: DefineMethod
 * https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-runtime-semantics-definemethod */
define_method :: fonc (interpréteuse: *InterprèteArbre, method_definition: *ObjectMethod, object: *Object, function_prototype : *Object = nul) -> MethodDefinitionInfo
{
    realm := interpréteuse.donne_realm()

    // 1. Let propKey be ? Evaluation of ClassElementName.
    prop_key := évalue_classe_element_name(interpréteuse, method_definition.class_element_name)

    // 2. Let env be the running execution context's LexicalEnvironment.
    mv := interpréteuse.mv
    running_execution_context := mv.donne_running_execution_context()
    env := running_execution_context.lexical_environment

    // 3. Let privateEnv be the running execution context's PrivateEnvironment.
    private_env := running_execution_context.private_environment

    // 4. If functionPrototype is present, then
    prototype := si function_prototype {
        // a. Let prototype be functionPrototype.
        function_prototype
    }
    // 5. Else,
    sinon {
        // a. Let prototype be %Function.prototype%.
        realm.intrinsics.function_prototype
    }

    // 6. Let sourceText be the source text matched by MethodDefinition.
    source_text := donne_texte_source(method_definition)

    // 7. Let closure be OrdinaryFunctionCreate(prototype, sourceText, UniqueFormalParameters, FunctionBody, non-lexical-this, env, privateEnv).
    closure := ordinary_function_create(realm, prototype, source_text, method_definition.paramètres, method_definition.body, NON_LEXICAL_THIS, env, private_env)
    
    // 8. Perform MakeMethod(closure, object).
    make_method(closure, object)

    // 9. Return the Record { [[Key]]: propKey, [[Closure]]: closure }.
    retourne MethodDefinitionInfo(closure, prop_key)
}

/* 15.4.5 Runtime Semantics: MethodDefinitionEvaluation
 * https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-runtime-semantics-methoddefinitionevaluation */
method_definition_evaluation :: fonc (interpréteuse: *InterprèteArbre, method_definition: *ObjectMethod, object: *Object, enumerable: bool) -> Optionnel(PrivateElement)
{
    si method_definition.kind == MethodKind.Method {
        // 1. Let methodDef be ? DefineMethod of MethodDefinition with argument object.
        method_def := define_method(interpréteuse, method_definition, object)
        si interpréteuse.possède_exception() {
            retourne
        }

        // 2. Perform SetFunctionName(methodDef.[[Closure]], methodDef.[[Key]]).
        set_function_name(interpréteuse.donne_realm(), method_def.closure, method_def.key)

        // 3. Return ? DefineMethodProperty(object, methodDef.[[Key]], methodDef.[[Closure]], enumerable).
        retourne define_method_property(object, method_def.key, method_def.closure, enumerable)
    }
    sinon si method_definition.kind == MethodKind.Get {
        // 1. Let propKey be ? Evaluation of ClassElementName.
        prop_key := évalue_classe_element_name(interpréteuse, method_definition.class_element_name)

        // 2. Let env be the running execution context's LexicalEnvironment.
        mv := interpréteuse.mv
        running_execution_context := mv.donne_running_execution_context()
        env := running_execution_context.lexical_environment

        // 3. Let privateEnv be the running execution context's PrivateEnvironment.
        private_env := running_execution_context.private_environment

        // 4. Let sourceText be the source text matched by MethodDefinition.
        source_text := donne_texte_source(method_definition)

        // 5. Let formalParameterList be an instance of the production FormalParameters : [empty] .
        formal_parameter_list: [..]*Expression

        // 6. Let closure be OrdinaryFunctionCreate(%Function.prototype%, sourceText, formalParameterList, FunctionBody, non-lexical-this, env, privateEnv).
        realm := interpréteuse.donne_realm()
        closure := ordinary_function_create(realm, realm.intrinsics.function_prototype, source_text, formal_parameter_list, method_definition.body, NON_LEXICAL_THIS, env, private_env)

        // 7. Perform MakeMethod(closure, object).
        make_method(closure, object)

        // 8. Perform SetFunctionName(closure, propKey, "get").
        set_function_name(interpréteuse.donne_realm(), closure, prop_key, STR_get)

        // 9. If propKey is a Private Name, then
        si prop_key.est_private_name() {
            // a. Return PrivateElement { [[Key]]: propKey, [[Kind]]: accessor, [[Get]]: closure, [[Set]]: undefined }.
            retourne PrivateElement(prop_key.PrivateName, PrivateElement.Kind.ACCESSOR, get = closure)
        }
        // 10. Else,
        sinon {
            // a. Let desc be the PropertyDescriptor { [[Get]]: closure, [[Enumerable]]: enumerable, [[Configurable]]: true }.
            desc: PropertyDescriptor
            desc.get = closure
            desc.enumerable = enumerable
            desc.configurable = vrai

            // b. Perform ? DefinePropertyOrThrow(object, propKey, desc).
            define_property_or_throw(object, donne_property_key(prop_key), desc)

            // c. Return unused.
        }
    }
    sinon si method_definition.kind == MethodKind.Set {
        // 1. Let propKey be ? Evaluation of ClassElementName.
        prop_key := évalue_classe_element_name(interpréteuse, method_definition.class_element_name)

        // 2. Let env be the running execution context's LexicalEnvironment.
        mv := interpréteuse.mv
        running_execution_context := mv.donne_running_execution_context()
        env := running_execution_context.lexical_environment

        // 3. Let privateEnv be the running execution context's PrivateEnvironment.
        private_env := running_execution_context.private_environment

        // 4. Let sourceText be the source text matched by MethodDefinition.
        source_text := donne_texte_source(method_definition)

        // 5. Let closure be OrdinaryFunctionCreate(%Function.prototype%, sourceText, PropertySetParameterList, FunctionBody, non-lexical-this, env, privateEnv).
        realm := interpréteuse.donne_realm()
        closure := ordinary_function_create(realm, realm.intrinsics.function_prototype, source_text, method_definition.paramètres, method_definition.body, NON_LEXICAL_THIS, env, private_env)

        // 6. Perform MakeMethod(closure, object).
        make_method(closure, object)

        // 7. Perform SetFunctionName(closure, propKey, "set").
        set_function_name(interpréteuse.donne_realm(), closure, prop_key, STR_get)

        // À FAIRE 8. If propKey is a Private Name, then
        si prop_key.est_private_name() {
        // a. Return PrivateElement { [[Key]]: propKey, [[Kind]]: accessor, [[Get]]: undefined, [[Set]]: closure }.
            retourne PrivateElement(prop_key.PrivateName, PrivateElement.Kind.ACCESSOR, set = closure)
        }
        // 9. Else,
        sinon {
            // a. Let desc be the PropertyDescriptor { [[Set]]: closure, [[Enumerable]]: enumerable, [[Configurable]]: true }.
            desc: PropertyDescriptor
            desc.set = closure
            desc.enumerable = enumerable
            desc.configurable = vrai

            // b. Perform ? DefinePropertyOrThrow(object, propKey, desc).
            define_property_or_throw(object, donne_property_key(prop_key), desc)

            // c. Return unused.
        }
    }
    sinon {
        panique("Non-implémenté")
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom OptionalMemberExpression.
 * \{ */

OptionalMemberExpression :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_optional_member_expression

    gauche: *Expression
    droite: *Expression
    calculé: bool
}

crée_optional_member_expression :: fonc (parseuse: *Parseuse, lexème: *Lexème, gauche: *Expression, droite: *Expression, calculé: bool) -> *OptionalMemberExpression
{
    résultat := parseuse.crée_noeud(lexème, OptionalMemberExpression)
    résultat.gauche = gauche
    résultat.droite = droite
    résultat.calculé = calculé
    retourne résultat
}

sur_exécution_optional_member_expression :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    optional_chain := base comme *OptionalMemberExpression

    // 1. Let baseReference be ? Evaluation of MemberExpression.
    completion := exécute_noeud(optional_chain.gauche, interpréteuse)
    saufsi completion.est_normal() {
        retourne completion
    }
    base_reference := completion.valeur

    // 2. Let baseValue be ? GetValue(baseReference).
    base_value := get_value(interpréteuse, base_reference)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 3. If baseValue is either undefined or null, then
    si base_value.est_undefined() || base_value.est_nulle() {
        // a. Return undefined.
        retourne normal_completion(js_undefined)
    }

    // 4. Return ? ChainEvaluation of OptionalChain with arguments baseValue and baseReference.
    retourne chain_evaluation(interpréteuse, optional_chain, base_value, base_reference)
}

/* 13.3.9.2 Runtime Semantics: ChainEvaluation
 * https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-optional-chaining-chain-evaluation */
chain_evaluation :: fonc (interpréteuse: *InterprèteArbre, optional_chain: *Expression, base_value: Valeur, base_reference: ValeurCompletion) -> CompletionRecord
{
    assert(optional_chain.type == OptionalMemberExpression || optional_chain.type == OptionalCallExpression)

    si optional_chain.type == OptionalMemberExpression {
        optional_member := optional_chain comme *OptionalMemberExpression

        // OptionalChain : ?. [ Expression ]
        si optional_member.calculé {
            // 1. Let strict be IsStrict(this OptionalChain).
            strict := is_strict(optional_chain)
            // 2. Return ? EvaluatePropertyAccessWithExpressionKey(baseValue, Expression, strict).
            retourne evaluate_property_access_with_expression_key(interpréteuse, base_value, optional_member.droite, strict)
        }

        // OptionalChain : ?. IdentifierName
        si optional_member.droite.type == Identifier {
            // 1. Let strict be IsStrict(this OptionalChain).
            strict := is_strict(optional_chain)
            // 2. Return EvaluatePropertyAccessWithIdentifierKey(baseValue, IdentifierName, strict).
            retourne evaluate_property_access_with_identifier_key(interpréteuse, base_value, optional_member.droite comme *Identifier, strict)
        }

        panique("non-implémenté")
    }

    // 1. Let thisChain be this OptionalChain.
    this_chain := optional_chain comme *OptionalCallExpression

    // 2. Let tailCall be IsInTailPosition(thisChain).
    tail_call := is_in_tail_position(this_chain)

    // 3. Return ? EvaluateCall(baseValue, baseReference, Arguments, tailCall).
    retourne evaluate_call(interpréteuse, base_value, base_reference, this_chain.arguments, tail_call)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom OptionalCallExpression.
 * \{ */

OptionalCallExpression :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_optional_call_expression

    gauche: *Expression
    arguments: [..]*Expression
}

crée_optional_call_expression :: fonc (parseuse: *Parseuse, lexème: *Lexème, gauche: *Expression, arguments: [..]*Expression) -> *OptionalCallExpression
{
    résultat := parseuse.crée_noeud(lexème, OptionalCallExpression)
    résultat.gauche = gauche
    résultat.arguments = arguments
    retourne résultat
}

sur_exécution_optional_call_expression :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    optional_chain := base comme *OptionalCallExpression

    // 1. Let baseReference be ? Evaluation of MemberExpression.
    completion := exécute_noeud(optional_chain.gauche, interpréteuse)
    saufsi completion.est_normal() {
        retourne completion
    }
    base_reference := completion.valeur

    // 2. Let baseValue be ? GetValue(baseReference).
    base_value := get_value(interpréteuse, base_reference)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 3. If baseValue is either undefined or null, then
    si base_value.est_undefined() || base_value.est_nulle() {
        // a. Return undefined.
        retourne normal_completion(js_undefined)
    }

    // 4. Return ? ChainEvaluation of OptionalChain with arguments baseValue and baseReference.
    retourne chain_evaluation(interpréteuse, optional_chain, base_value, base_reference)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ClassDeclaration
 * \{ */

ClassDeclaration :: struct {
    empl statement: Statement
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_class_declaration

    identifier: *Identifier
    héritage: *Expression
    body: *ClassBody
}

crée_class_declaration :: fonc (parseuse: *Parseuse, lexème: *Lexème, héritage: *Expression, identifier: *Identifier, body: *ClassBody) -> *ClassDeclaration
{
    résultat := parseuse.crée_noeud(lexème, ClassDeclaration)
    résultat.héritage = héritage
    résultat.identifier = identifier
    résultat.body = body
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-class-definitions-runtime-semantics-evaluation */
sur_exécution_class_declaration :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    class_declaration := base comme *ClassDeclaration

    // 1. Perform ? BindingClassDeclarationEvaluation of this ClassDeclaration.
    _ := binding_class_declaration_evaluation(interpréteuse, class_declaration)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 2. Return empty.
    retourne normal_completion(js_undefined)
}

/* 15.7.4 Static Semantics: IsStatic
 * https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-static-semantics-isstatic */
is_static :: fonc (syntax: *NoeudSyntaxique) -> bool
{
    si syntax.type == ClassMethod {
        method_definition := syntax comme *ClassMethod
        retourne method_definition.static
    }

    si syntax.type == ClassStaticBlock {
        retourne vrai
    }

    si syntax.type == ClassField {
        field := syntax comme *ClassField
        retourne field.static
    }

    retourne faux
}

évalue_classe_element_name :: fonc (interpréteuse: *Interpréteuse, class_element_name: *Expression) -> FieldName
{
    si class_element_name.type == PrivateIdentifier {
        /* https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-class-definitions-runtime-semantics-evaluation */
        private_identifier := class_element_name comme *PrivateIdentifier

        // 1. Let privateIdentifier be the StringValue of PrivateIdentifier.
        private_identifier_str := private_identifier.nom

        // 2. Let privateEnvRec be the running execution context's PrivateEnvironment.
        mv := interpréteuse.mv
        running_execution_context := donne_running_execution_context(mv)
        private_env_rec := running_execution_context.private_environment

        // 3. Let names be privateEnvRec.[[Names]].
        names := private_env_rec.names

        // 4. Assert: Exactly one element of names is a Private Name whose [[Description]] is privateIdentifier.
        // 5. Let privateName be the Private Name in names whose [[Description]] is privateIdentifier.

        occurences := 0
        private_name: PrivateName
        pour names {
            si it.description == private_identifier_str {
                occurences += 1
                private_name = it
            }
        }

        assert(occurences == 1)

        // 6. Return privateName.
        retourne private_name
    }

    property_key := évalue_property_name(interpréteuse, class_element_name)
    si interpréteuse.possède_exception() {
        résultat: FieldName
        retourne résultat
    }

    retourne donne_field_name(property_key)
}

/* 15.7.10 Runtime Semantics: ClassFieldDefinitionEvaluation
 * https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-runtime-semantics-classfielddefinitionevaluation */
class_field_definition_evaluation :: fonc (interpréteuse: *Interpréteuse, class_field: *ClassField, home_object: *Object) -> ClassFieldDefinition
{
    // 1. Let name be ? Evaluation of ClassElementName.
    name := évalue_classe_element_name(interpréteuse, class_field.class_element_name)
    si interpréteuse.possède_exception() {
        retourne ClassFieldDefinition()
    }

    // 2. If Initializer is present, then
    initializer: *ECMAScriptFunction
    si class_field.initializer {
        // a. Let formalParameterList be an instance of the production FormalParameters : [empty] .
        formal_parameter_list: [..]*Expression

        // b. Let env be the LexicalEnvironment of the running execution context.
        mv := interpréteuse.mv
        running_execution_context := donne_running_execution_context(mv)
        env := running_execution_context.lexical_environment

        // c. Let privateEnv be the running execution context's PrivateEnvironment.
        private_env := running_execution_context.private_environment

        // d. Let sourceText be the empty sequence of Unicode code points.
        source_text: chaine

        // e. Let initializer be OrdinaryFunctionCreate(%Function.prototype%, sourceText, formalParameterList, Initializer, non-lexical-this, env, privateEnv).
        realm := interpréteuse.donne_realm()
        initializer = ordinary_function_create(realm, realm.intrinsics.function_prototype, source_text, formal_parameter_list, class_field.initializer, NON_LEXICAL_THIS, env, private_env)

        // f. Perform MakeMethod(initializer, homeObject).
        make_method(initializer, home_object)

        // g. Set initializer.[[ClassFieldInitializerName]] to name.
        initializer.class_field_initializer_name = name
    }
    // 3. Else,
    sinon {
        // a. Let initializer be empty.
    }

    // 4. Return the ClassFieldDefinition Record { [[Name]]: name, [[Initializer]]: initializer }.
    retourne ClassFieldDefinition(name, initializer)
}

/* 15.7.11 Runtime Semantics: ClassStaticBlockDefinitionEvaluation
 * https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-runtime-semantics-classstaticblockdefinitionevaluation */
class_static_block_definition_evaluation :: fonc (interpréteuse: *Interpréteuse, class_static_block: *ClassStaticBlock, home_object: *Object) -> ClassStaticBlockDefinition
{
    // 1. Let lex be the running execution context's LexicalEnvironment
    mv := interpréteuse.mv
    running_execution_context := donne_running_execution_context(mv)
    lex := running_execution_context.lexical_environment

    // 2. Let privateEnv be the running execution context's PrivateEnvironment
    private_env := running_execution_context.private_environment

    // 3. Let sourceText be the empty sequence of Unicode code points
    source_text: chaine

    // 4. Let formalParameters be an instance of the production FormalParameters : [empty] 
    formal_parameters: [..]*Expression

    // 5. Let bodyFunction be OrdinaryFunctionCreate(%Function.prototype%, sourceText, formalParameters, ClassStaticBlockBody, non-lexical-this, lex, privateEnv)
    realm := interpréteuse.donne_realm()
    body_function := ordinary_function_create(realm, realm.intrinsics.function_prototype, source_text, formal_parameters, class_static_block.body, NON_LEXICAL_THIS, lex, private_env)

    // 6. Perform MakeMethod(bodyFunction, homeObject)
    make_method(body_function, home_object)

    // 7. Return the ClassStaticBlockDefinition Record { [[BodyFunction]]: bodyFunction }
    retourne ClassStaticBlockDefinition(body_function)
}

/* 15.7.13 Runtime Semantics: ClassElementEvaluation
 * https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-static-semantics-classelementevaluation */
ClassElementEvaluationResult :: union {
    Field: ClassFieldDefinition
    StaticBlock: ClassStaticBlockDefinition
    Private: PrivateElement
}

est_private_element :: fonc (result: ClassElementEvaluationResult) -> bool
{
    discr result {
        Private {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_class_field_definition :: fonc (result: ClassElementEvaluationResult) -> bool
{
    discr result {
        Field {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

est_class_static_block_definition :: fonc (result: ClassElementEvaluationResult) -> bool
{
    discr result {
        StaticBlock {
            retourne vrai
        }
        sinon {
            retourne faux
        }
    }
}

class_element_evaluation :: fonc (interpréteuse: *InterprèteArbre, syntax: *NoeudSyntaxique, object: *Object) -> ClassElementEvaluationResult
{
    si syntax.type == ClassMethod {
        class_method := syntax comme *ClassMethod

        // 1. Return ? MethodDefinitionEvaluation of MethodDefinition with arguments object and false.
        résultat: ClassElementEvaluationResult
        
        opt_private_element := method_definition_evaluation(interpréteuse, class_method, object, faux)
        si opt_private_element.possède_valeur() {
            résultat.Private = opt_private_element.Quelque
        }

        retourne résultat
    }

    si syntax.type == ClassField {
        class_field := syntax comme *ClassField
        // 1. Return ? ClassFieldDefinitionEvaluation of FieldDefinition with argument object.
        retourne class_field_definition_evaluation(interpréteuse, class_field, object)
    }

    si syntax.type == ClassStaticBlock {
        static_block := syntax comme *ClassStaticBlock
        // 1. Return the ClassStaticBlockDefinitionEvaluation of ClassStaticBlock with argument object.
        retourne class_static_block_definition_evaluation(interpréteuse, static_block, object)
    }

    si syntax.type == EmptyStatement {
        // 1. Return unused.
        résultat: ClassElementEvaluationResult
        retourne résultat
    }

    panique("noeud non-géré dans %", #nom_de_cette_fonction)
}

/* 15.7.14 Runtime Semantics: ClassDefinitionEvaluation
 * https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-runtime-semantics-classdefinitionevaluation */
class_definition_evaluation :: fonc (interpréteuse: *InterprèteArbre, class_heritage: *Expression, class_body: *ClassBody, class_binding: Optionnel(ECMAString), class_name: FieldName) -> *Function
{
    realm := interpréteuse.donne_realm()

    // 1. Let env be the LexicalEnvironment of the running execution context.
    mv := interpréteuse.mv
    running_execution_context := donne_running_execution_context(mv)
    env := running_execution_context.lexical_environment

    // 2. Let classEnv be NewDeclarativeEnvironment(env).
    class_env := new_declarative_environment(env.donne_tas_de_mémoire(), env)

    // 3. If classBinding is not undefined, then
    si class_binding.possède_valeur() {
        // a. Perform ! classEnv.CreateImmutableBinding(classBinding, true).
        _ := create_immutable_binding(class_env, realm, class_binding.Quelque, vrai)
    }

    // 4. Let outerPrivateEnvironment be the running execution context's PrivateEnvironment.
    outer_private_environment := running_execution_context.private_environment

    // 5. Let classPrivateEnvironment be NewPrivateEnvironment(outerPrivateEnvironment).
    class_private_environment := new_private_environment(realm.donne_tas_de_mémoire(), outer_private_environment)

    // 6. If ClassBody is present, then
    si class_body {
        private_bound_identifiers := donne_private_bound_identifiers(class_body)
        diffère déloge(private_bound_identifiers)

        // a. For each String dn of the PrivateBoundIdentifiers of ClassBody, do
        pour dn dans private_bound_identifiers {
            // i. If classPrivateEnvironment.[[Names]] contains a Private Name pn such that pn.[[Description]] is dn, then
            si possède_nom(class_private_environment, dn) {
                // 1. Assert: This is only possible for getter/setter pairs.
            }
            // ii. Else,
            sinon {
                // 1. Let name be a new Private Name whose [[Description]] is dn.
                name := PrivateName(dn)
                // 2. Append name to classPrivateEnvironment.[[Names]].
                tableau_ajoute(*class_private_environment.names, name)
            }
        }
    }

    // 7. If ClassHeritage is not present, then
    proto_parent: *Object
    constructor_parent: *Object
    saufsi class_heritage {
        // a. Let protoParent be %Object.prototype%.
        proto_parent = realm.intrinsics.object_prototype

        // b. Let constructorParent be %Function.prototype%.
        constructor_parent = realm.intrinsics.function_prototype
    }
    // 8. Else,
    sinon {
        // a. Set the running execution context's LexicalEnvironment to classEnv.
        running_execution_context.lexical_environment = class_env
    
        // b. NOTE: The running execution context's PrivateEnvironment is outerPrivateEnvironment when evaluating ClassHeritage.
    
        // c. Let superclassRef be Completion(Evaluation of ClassHeritage).
        completion := exécute_noeud(class_heritage, interpréteuse)
        saufsi completion.est_normal() {
            interpréteuse.définis_exception(completion)
            retourne nul
        }
        superclass_ref := completion.valeur
    
        // d. Set the running execution context's LexicalEnvironment to env.
        running_execution_context.lexical_environment = env

        // e. Let superclass be ? GetValue(? superclassRef).
        superclass := get_value(interpréteuse, superclass_ref)
        si interpréteuse.possède_exception() {
            retourne nul
        }

        // f. If superclass is null, then
        si superclass.est_nulle() {
            // i. Let protoParent be null.
            proto_parent = nul

            // ii. Let constructorParent be %Function.prototype%.
            constructor_parent = realm.intrinsics.function_prototype
        }
        // g. Else if IsConstructor(superclass) is false, then
        sinon si is_constructor(superclass) == faux {
            // i. Throw a TypeError exception.
            _ := lance_type_error(interpréteuse, "superclass is not a constructor")
            retourne nul
        }
        // h. Else,
        sinon {
            // i. Let protoParent be ? Get(superclass, "prototype").
            proto_parent_value := get(superclass.donne_objet(), STR_prototype)
            si interpréteuse.possède_exception() {
                retourne nul
            }

            // ii. If protoParent is not an Object and protoParent is not null, throw a TypeError exception.
            si proto_parent_value.est_object() {
                proto_parent = proto_parent_value.donne_objet()
            }
            sinon si proto_parent.est_nulle() {
                proto_parent = nul
            }
            sinon {
                _ := lance_type_error(interpréteuse, "parent prototype is not an Object nor null")
                retourne nul
            }

            // iii. Let constructorParent be superclass.
            constructor_parent = superclass.donne_objet()
        }
    }

    // 9. Let proto be OrdinaryObjectCreate(protoParent).
    proto := ordinary_object_create(realm, proto_parent, object_instance_crée)

    // 10. If ClassBody is not present, let constructor be empty.
    constructor: *ClassMethod = ---
    saufsi class_body {
        constructor = nul
    }
    // 11. Else, let constructor be the ConstructorMethod of ClassBody.
    sinon {
        constructor = nul
        pour class_body.éléments {
            si it.type == ClassMethod {
                class_method := it comme *ClassMethod
                si class_method.kind == MethodKind.Constructor {
                    constructor = class_method
                }
            }
        }
    }

    // 12. Set the running execution context's LexicalEnvironment to classEnv.
    running_execution_context.lexical_environment = class_env

    // 13. Set the running execution context's PrivateEnvironment to classPrivateEnvironment.
    running_execution_context.private_environment = class_private_environment

    // 14. If constructor is empty, then
    F: *Function

    saufsi constructor {
        // a. Let defaultConstructor be a new Abstract Closure with no parameters that captures nothing and performs the following steps when called:
        default_constructor := constructor_pour_classe_sans_constructor

        // b. Let F be CreateBuiltinFunction(defaultConstructor, 0, className, « [[ConstructorKind]], [[SourceText]] », the current Realm Record, constructorParent).
        tas_de_mémoire := realm.donne_tas_de_mémoire()
        builtin := tas_de_mémoire.alloue(BuiltInFunction)
        builtin.sur_call_or_construct = default_constructor
        create_builtin_function(builtin, 0, class_name, realm, constructor_parent)

        F = builtin
    }
    // 15. Else,
    sinon {
        // a. Let constructorInfo be ! DefineMethod of constructor with arguments proto and constructorParent.
        constructor_info := define_method(interpréteuse, constructor, proto, constructor_parent)

        // b. Let F be constructorInfo.[[Closure]].
        closure := constructor_info.closure
        F = closure

        // c. Perform MakeClassConstructor(F).
        make_class_constructor(closure)

        // d. Perform SetFunctionName(F, className).
        set_function_name(realm, closure, class_name)
    }

    // 16. Perform MakeConstructor(F, false, proto).
    writable_prototype := faux
    make_constructor(realm, F, *writable_prototype, proto)

    // 17. If ClassHeritage is present, set F.[[ConstructorKind]] to derived.
    si class_heritage {
        F.définis_constructor_kind(ConstructorKind.Derived)
    }
    
    // 18. Perform ! DefineMethodProperty(proto, "constructor", F, false).
    _ := define_method_property(proto, STR_constructor, F, faux)

    // 19. If ClassBody is not present, let elements be a new empty List.
    // 20. Else, let elements be the NonConstructorElements of ClassBody.
    éléments: [..]*NoeudSyntaxique
    diffère déloge(éléments)

    si class_body {
        pour class_body.éléments {
            si it.type == ClassMethod {
                class_method := it comme *ClassMethod
                si class_method.kind == MethodKind.Constructor {
                    continue
                }
            }

            tableau_ajoute(*éléments, it)
        }
    }

    // 21. Let instancePrivateMethods be a new empty List.
    instance_private_methods: [..]PrivateElement

    // 22. Let staticPrivateMethods be a new empty List.
    static_private_methods: [..]PrivateElement
    diffère déloge(static_private_methods)

    // 23. Let instanceFields be a new empty List.
    instance_fields: [..]ClassFieldDefinition

    // 24. Let staticElements be a new empty List.
    static_elements: [..]ClassElementEvaluationResult
    diffère déloge(static_elements)

    // 25. For each ClassElement e of elements, do
    pour e dans éléments {
        element: ClassElementEvaluationResult
        // a. If IsStatic of e is false, then
        e_est_static := is_static(e)
        saufsi e_est_static {
            // i. Let element be Completion(ClassElementEvaluation of e with argument proto).
            element = class_element_evaluation(interpréteuse, e, proto)
        }
        // b. Else,
        sinon {
            // i. Let element be Completion(ClassElementEvaluation of e with argument F).
            element = class_element_evaluation(interpréteuse, e, F)
        }

        // c. If element is an abrupt completion, then
        si interpréteuse.possède_exception() {
            // i. Set the running execution context's LexicalEnvironment to env.
            running_execution_context.lexical_environment = env

            // ii. Set the running execution context's PrivateEnvironment to outerPrivateEnvironment.
            running_execution_context.private_environment = outer_private_environment

            // iii. Return ? element.
            retourne nul
        }

        // d. Set element to ! element.

        // e. If element is a PrivateElement, then
        si element.est_private_element() {
            private_element := element.Private

            // i. Assert: element.[[Kind]] is either method or accessor.
            assert(private_element.kind == PrivateElement.Kind.METHOD || private_element.kind == PrivateElement.Kind.ACCESSOR)

            // ii. If IsStatic of e is false, let container be instancePrivateMethods.
            container: *[..]PrivateElement
            saufsi e_est_static {
                container = *instance_private_methods
            }
            // iii. Else, let container be staticPrivateMethods.
            sinon {
                container = *static_private_methods
            }

            // iv. If container contains a PrivateElement pe such that pe.[[Key]] is element.[[Key]], then
            pour mémoire(container) {
                si it.key != private_element.key {

                }

                // 1. Assert: element.[[Kind]] and pe.[[Kind]] are both accessor.
                assert(private_element.kind == PrivateElement.Kind.ACCESSOR && it.kind == PrivateElement.Kind.ACCESSOR)

                // 2. If element.[[Get]] is undefined, then
                combined: PrivateElement
                combined.key = private_element.key
                combined.kind = PrivateElement.Kind.ACCESSOR

                si private_element.get == nul {
                    // a. Let combined be PrivateElement { [[Key]]: element.[[Key]], [[Kind]]: accessor, [[Get]]: pe.[[Get]], [[Set]]: element.[[Set]] }.
                    combined.get = it.get
                    combined.set = private_element.set
                }
                // 3. Else,
                sinon {
                    // a. Let combined be PrivateElement { [[Key]]: element.[[Key]], [[Kind]]: accessor, [[Get]]: element.[[Get]], [[Set]]: pe.[[Set]] }.
                    combined.get = private_element.get
                    combined.set = it.set
                }

                // 4. Replace pe in container with combined.
                container.pointeur[indice_it] = combined

                arrête
            }
            // v. Else,
            sansarrêt {
                // 1. Append element to container.
                tableau_ajoute(container, private_element)
            }
        }
        // f. Else if element is a ClassFieldDefinition Record, then
        sinon si element.est_class_field_definition() {
            // i. If IsStatic of e is false, append element to instanceFields.
            saufsi e_est_static {
                tableau_ajoute(*instance_fields, element.Field)
            }
            // ii. Else, append element to staticElements.
            sinon {
                tableau_ajoute(*static_elements, element)
            }
        }
        // g. Else if element is a ClassStaticBlockDefinition Record, then
        sinon si element.est_class_static_block_definition() {
            // i. Append element to staticElements.
            tableau_ajoute(*static_elements, element)
        }
    }

    // 26. Set the running execution context's LexicalEnvironment to env.
    running_execution_context.lexical_environment = env

    // 27. If classBinding is not undefined, then
    si class_binding.possède_valeur() {
        // a. Perform ! classEnv.InitializeBinding(classBinding, F).
        initialize_binding(class_env, class_binding.Quelque, Valeur(Function = F))
    }

    // 28. Set F.[[PrivateMethods]] to instancePrivateMethods.
    F.définis_private_methods(instance_private_methods)

    // 29. Set F.[[Fields]] to instanceFields.
    F.définis_fields(instance_fields)

    // 30. For each PrivateElement method of staticPrivateMethods, do
    pour method dans static_private_methods {
        // a. Perform ! PrivateMethodOrAccessorAdd(F, method).
        private_method_or_accessor_add(interpréteuse, F, method)
    }

    // 31. For each element elementRecord of staticElements, do
    pour element_record dans static_elements {
        // a. If elementRecord is a ClassFieldDefinition Record, then
        si element_record.est_class_field_definition() {
            // i. Let result be Completion(DefineField(F, elementRecord)).
            define_field(interpréteuse, F, element_record.Field)
        }
        // b. Else,
        sinon {
            // i. Assert: elementRecord is a ClassStaticBlockDefinition Record.
            class_static_block := element_record.StaticBlock

            // ii. Let result be Completion(Call(elementRecord.[[BodyFunction]], F)).
            _ := call(interpréteuse, Valeur(Function = class_static_block.body_function), Valeur(Function = F))
        }

        // c. If result is an abrupt completion, then
        si interpréteuse.possède_exception() {
            // i. Set the running execution context's PrivateEnvironment to outerPrivateEnvironment.
            running_execution_context.private_environment = outer_private_environment

            // ii. Return ? result.
            retourne nul
        }
    }

    // 32. Set the running execution context's PrivateEnvironment to outerPrivateEnvironment.
    running_execution_context.private_environment = outer_private_environment

    // 33. Return F.
    retourne F
}

constructor_pour_classe_sans_constructor :: fonc (empl params: *ParamètresCallOrConstruct) -> Valeur
{
    // i. Let args be the List of arguments that was passed to this function by [[Call]] or [[Construct]].
    args := arguments

    // ii. If NewTarget is undefined, throw a TypeError exception.
    si new_target.est_undefined() {
        _ := lance_type_error(interpréteuse, "new target is undefined")
        retourne js_undefined
    }

    // iii. Let F be the active function object.
    F := donne_active_function_object(interpréteuse).vérifie_comme(BuiltInFunction)

    // iv. If F.[[ConstructorKind]] is derived, then
    result: Valeur
    si F.constructor_kind == ConstructorKind.Derived {
        // 1. NOTE: This branch behaves similarly to constructor(...args) { super(...args); }. The most notable distinction is that while the aforementioned ECMAScript source text observably calls the %Symbol.iterator% method on %Array.prototype%, this function does not.

        // 2. Let func be ! F.[[GetPrototypeOf]]().
        func := internal_get_prototype_of(F)

        // 3. If IsConstructor(func) is false, throw a TypeError exception.
        saufsi is_constructor(func) {
            _ := lance_type_error(interpréteuse, "function is not a constructor")
        }

        // 4. Let result be ? Construct(func, args, NewTarget).
        result = construct(interpréteuse, func, args, new_target)
        si interpréteuse.possède_exception() {
            retourne js_undefined
        }
    }
    // v. Else,
    sinon {
        // 1. NOTE: This branch behaves similarly to constructor() {}.
        // 2. Let result be ? OrdinaryCreateFromConstructor(NewTarget, "%Object.prototype%").
        realm := interpréteuse.donne_realm()
        result = ordinary_create_from_constructor(realm, new_target.Function, realm.intrinsics.object_prototype, object_instance_crée)
    }

    // vi. Perform ? InitializeInstanceElements(result, F).
    initialize_instance_elements(interpréteuse, result, F)

    // vii. Return NormalCompletion(result).
    retourne result
}

/* 15.7.15 Runtime Semantics: BindingClassDeclarationEvaluation
 * https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-runtime-semantics-bindingclassdeclarationevaluation */
binding_class_declaration_evaluation :: fonc (interpréteuse: *InterprèteArbre, class_declaration: *ClassDeclaration) -> *Function
{
    // 1. Let className be the StringValue of BindingIdentifier.
    class_name := class_declaration.identifier.nom

    // 2. Let value be ? ClassDefinitionEvaluation of ClassTail with arguments className and className.
    value := class_definition_evaluation(interpréteuse, class_declaration.héritage, class_declaration.body, class_name, class_name)
    si interpréteuse.possède_exception() {
        retourne nul
    }

    // 3. Set value.[[SourceText]] to the source text matched by ClassDeclaration.
    value.définis_source_text(donne_texte_source(class_declaration))

    // 4. Let env be the running execution context's LexicalEnvironment.
    mv := interpréteuse.mv
    running_execution_context := donne_running_execution_context(mv)
    env := running_execution_context.lexical_environment

    // 5. Perform ? InitializeBoundName(className, value, env).
    initialize_bound_name(interpréteuse, class_name, Valeur(Function = value), env)

    // 6. Return value.
    retourne value
}

/* 8.6.2.1 InitializeBoundName ( name, value, environment )
 * https://tc39.es/ecma262/multipage/syntax-directed-operations.html#sec-initializeboundname */
initialize_bound_name :: fonc (interpréteuse: *Interpréteuse, name: ECMAString, value: Valeur, environment: *Environment)
{
    // 1. If environment is not undefined, then
    si environment {
        // a. Perform ! environment.InitializeBinding(name, value).
        initialize_binding(environment, name, value)
        // b. Return unused.
    }
    // 2. Else,
    sinon {
        // a. Let lhs be ? ResolveBinding(name).
        realm := interpréteuse.donne_realm()
        chaine_pour_name := realm.crée_chaine(name)
        lhs := resolve_binding(interpréteuse, chaine_pour_name)
        si interpréteuse.possède_exception() {
            retourne
        }

        // b. Return ? PutValue(lhs, value).
        _ := put_value(interpréteuse, lhs, value)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ClassExpression
 * \{ */

ClassExpression :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_class_expression

    identifier: *Identifier
    héritage: *Expression
    body: *ClassBody
}

crée_class_expression :: fonc (parseuse: *Parseuse, lexème: *Lexème, héritage: *Expression, identifier: *Identifier, body: *ClassBody) -> *ClassExpression
{
    résultat := parseuse.crée_noeud(lexème, ClassExpression)
    résultat.héritage = héritage
    résultat.identifier = identifier
    résultat.body = body
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-class-definitions-runtime-semantics-evaluation */
sur_exécution_class_expression :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    class_expression := base comme *ClassExpression

    // ClassExpression : class ClassTail
    saufsi class_expression.identifier {
        // 1. Let value be ? ClassDefinitionEvaluation of ClassTail with arguments undefined and "".
        class_binding: Optionnel(ECMAString)
        class_name : FieldName = crée_chaine_utf16_unique_vide()
        value := class_definition_evaluation(interpréteuse, class_expression.héritage, class_expression.body, class_binding, class_name)
        si interpréteuse.possède_exception() {
            retourne throw_completion(interpréteuse.donne_exception())
        }

        // 2. Set value.[[SourceText]] to the source text matched by ClassExpression.
        définis_source_text(value, donne_texte_source(class_expression))

        // 3. Return value.
        retourne normal_completion(Valeur(Function = value))
    }

    // ClassExpression : class BindingIdentifier ClassTail

    // 1. Let className be the StringValue of BindingIdentifier.
    class_name := class_expression.identifier.nom

    // 2. Let value be ? ClassDefinitionEvaluation of ClassTail with arguments className and className.
    value := class_definition_evaluation(interpréteuse, class_expression.héritage, class_expression.body, class_name, class_name)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 3. Set value.[[SourceText]] to the source text matched by ClassExpression.
    définis_source_text(value, donne_texte_source(class_expression))

    // 4. Return value.
    retourne normal_completion(Valeur(Function = value))
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ClassBody
 * \{ */

ClassBody :: struct {
    empl base: Expression
    type = #type_de_cette_structure

    éléments: [..]*NoeudSyntaxique
}

crée_class_body :: fonc (parseuse: *Parseuse, lexème: *Lexème, éléments: [..]*NoeudSyntaxique) -> *ClassBody
{
    résultat := parseuse.crée_noeud(lexème, ClassBody)
    résultat.éléments = éléments
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ClassMethod
 * \{ */

ClassMethod :: struct {
    empl object_method: ObjectMethod
    type = #type_de_cette_structure

    static: bool
}

crée_class_method :: fonc (parseuse: *Parseuse, lexème: *Lexème, key: *Expression, arguments: [..]*Expression, body: *FunctionBody, method_kind: MethodKind, async: bool, generator: bool) -> *ClassMethod
{
    résultat := parseuse.crée_noeud(lexème, ClassMethod)
    résultat.class_element_name = key
    résultat.paramètres = arguments
    résultat.body = body
    résultat.kind = method_kind
    résultat.est_méthode = method_kind == MethodKind.Method
    résultat.async = async
    résultat.generator = generator
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ClassField
 * \{ */

ClassField :: struct {
    empl base: Expression
    type = #type_de_cette_structure

    class_element_name: *Expression
    initializer: *Expression
    static: bool
}

crée_class_field :: fonc (parseuse: *Parseuse, lexème: *Lexème, class_element_name: *Expression, initializer: *Expression, static: bool) -> *ClassField
{
    résultat := parseuse.crée_noeud(lexème, ClassField)
    résultat.class_element_name = class_element_name
    résultat.initializer = initializer
    résultat.static = static
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ClassStaticBlock
 * \{ */

ClassStaticBlock :: struct {
    empl base: Expression
    type = #type_de_cette_structure

    body: *FunctionBody
}

crée_class_static_block :: fonc (parseuse: *Parseuse, lexème: *Lexème, body: *FunctionBody) -> *ClassStaticBlock
{
    résultat := parseuse.crée_noeud(lexème, ClassStaticBlock)
    résultat.body = body
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom SuperCall
 * \{ */

SuperCall :: struct {
    empl object_method: ObjectMethod
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_super_call

    arguments: [..]*Expression
}

crée_super_call :: fonc (parseuse: *Parseuse, lexème: *Lexème, arguments: [..]*Expression) -> *SuperCall
{
    résultat := parseuse.crée_noeud(lexème, SuperCall)
    résultat.arguments = arguments
    retourne résultat
}

sur_exécution_super_call :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    super_call := base comme *SuperCall

    // 1. Let newTarget be GetNewTarget()
    new_target := get_new_target(interpréteuse)

    // 2. Assert: newTarget is a constructor
    
    // 3. Let func be GetSuperConstructor()
    func := get_super_constructor(interpréteuse)

    // 4. Let argList be ? ArgumentListEvaluation of Arguments
    arg_list: [..]Valeur
    diffère déloge(arg_list)
    completion := argument_list_evaluation(interpréteuse, super_call.arguments, *arg_list)
    saufsi completion.est_normal() {
        retourne completion
    }
    
    // 5. If IsConstructor(func) is false, throw a TypeError exception
    si is_constructor(func) == faux {
        _ := lance_type_error(interpréteuse, "super constructor is not a function")
    }
    
    // 6. Let result be ? Construct(func, argList, newTarget)
    result := construct(interpréteuse, func, arg_list, new_target)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }
    
    // 7. Let thisER be GetThisEnvironment()
    this_er := get_this_environment(interpréteuse) comme *FunctionEnvironment

    // 8. Assert: thisER is a Function Environment Record
    assert(this_er.table.classe == FunctionEnvironment)
    
    // 9. Perform ? BindThisValue(thisER, result)
    _ := bind_this_value(this_er, result)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 10. Let F be thisER.[[FunctionObject]]
    F := this_er.function_object

    // 11. Assert: F is an ECMAScript function object
    
    // 12. Perform ? InitializeInstanceElements(result, F)
    initialize_instance_elements(interpréteuse, result, F)
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 13. Return result
    retourne normal_completion(result)
}

/* 13.3.7.2 GetSuperConstructor ( )
 * https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-getsuperconstructor */
get_super_constructor :: fonc (interpréteuse: *Interpréteuse) -> Valeur
{
    // 1. Let envRec be GetThisEnvironment().
    env_rec := get_this_environment(interpréteuse) comme *FunctionEnvironment

    // 2. Assert: envRec is a Function Environment Record.
    assert(env_rec.table.classe == FunctionEnvironment)

    // 3. Let activeFunction be envRec.[[FunctionObject]].
    active_function := env_rec.function_object

    // 4. Assert: activeFunction is an ECMAScript function object.
    assert(active_function.table.classe == ECMAScriptFunction)

    // 5. Let superConstructor be ! activeFunction.[[GetPrototypeOf]]().
    super_constructor := internal_get_prototype_of(active_function)

    // 6. Return superConstructor.
    retourne super_constructor
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom SuperProperty
 * \{ */

SuperProperty :: struct {
    empl object_method: ObjectMethod
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_super_property

    property: *Expression
    calculé: bool
}

crée_super_property :: fonc (parseuse: *Parseuse, lexème: *Lexème, property: *Expression, calculé: bool) -> *SuperProperty
{
    résultat := parseuse.crée_noeud(lexème, SuperProperty)
    résultat.property = property
    résultat.calculé = calculé
    retourne résultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-super-keyword-runtime-semantics-evaluation */
sur_exécution_super_property :: fonc (base: *NoeudSyntaxique, interpréteuse: *InterprèteArbre) -> CompletionRecord
{
    super_property := base comme *SuperProperty

    si super_property.calculé {
        // 1. Let env be GetThisEnvironment().
        env := get_this_environment(interpréteuse) comme *FunctionEnvironment

        // 2. Let actualThis be ? env.GetThisBinding().
        actual_this := env.get_this_binding(interpréteuse.donne_realm())
        si interpréteuse.possède_exception() {
            retourne throw_completion(interpréteuse.donne_exception())
        }

        // 3. Let propertyNameReference be ? Evaluation of Expression.
        completion := exécute_noeud(super_property.property, interpréteuse)
        saufsi completion.est_normal() {
            retourne completion
        }
        property_name_reference := completion.valeur

        // 4. Let propertyNameValue be ? GetValue(propertyNameReference).
        property_name_value := get_value(interpréteuse, property_name_reference)
        si interpréteuse.possède_exception() {
            retourne throw_completion(interpréteuse.donne_exception())
        }

        // 5. Let strict be IsStrict(this SuperProperty).
        strict := is_strict(super_property)

        // 6. NOTE: In most cases, ToPropertyKey will be performed on propertyNameValue immediately after this step. However, in the case of super[b] = c, it will not be performed until after evaluation of c.

        // 7. Return MakeSuperPropertyReference(actualThis, propertyNameValue, strict).
        résultat := make_super_property_reference(interpréteuse, actual_this, property_name_value, strict)
        retourne normal_completion(résultat)
    }

    // 1. Let env be GetThisEnvironment().
    env := get_this_environment(interpréteuse) comme *FunctionEnvironment

    // 2. Let actualThis be ? env.GetThisBinding().
    actual_this := env.get_this_binding(interpréteuse.donne_realm())
    si interpréteuse.possède_exception() {
        retourne throw_completion(interpréteuse.donne_exception())
    }

    // 3. Let propertyKey be the StringValue of IdentifierName.
    assert(super_property.property.type == Identifier)
    property_key := donne_chaine_primitive(super_property.property comme *Identifier, interpréteuse.donne_realm())

    // 4. Let strict be IsStrict(this SuperProperty).
    strict := is_strict(super_property)

    // 5. Return MakeSuperPropertyReference(actualThis, propertyKey, strict).
    résultat := make_super_property_reference(interpréteuse, actual_this, property_key, strict)
    retourne normal_completion(résultat)
}

/* 13.3.7.3 MakeSuperPropertyReference ( actualThis, propertyKey, strict )
 * https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-makesuperpropertyreference */
make_super_property_reference :: fonc (interpréteuse: *Interpréteuse, actual_this: Valeur, property_key: Valeur, strict: bool) -> ReferenceRecord
{
    // 1. Let env be GetThisEnvironment().
    env := get_this_environment(interpréteuse) comme *FunctionEnvironment

    // 2. Assert: env.HasSuperBinding() is true.
    assert(env.has_super_binding())

    // 3. Assert: env is a Function Environment Record.
    assert(env.table.classe == FunctionEnvironment)

    // 4. Let baseValue be GetSuperBase(env).
    base_value := get_super_base(env)

    // 5. Return the Reference Record { [[Base]]: baseValue, [[ReferencedName]]: propertyKey, [[Strict]]: strict, [[ThisValue]]: actualThis }.
    retourne ReferenceRecord(Valeur(Object = base_value), property_key, strict, actual_this)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ObjectBindingPattern
 * \{ */

ObjectBindingPattern :: struct {
    empl base: Expression
    type = #type_de_cette_structure

    properties: [..]*Expression
}

crée_object_binding_pattern :: fonc (parseuse: *Parseuse, lexème: *Lexème, properties: [..]*Expression) -> *ObjectBindingPattern
{
    résultat := parseuse.crée_noeud(lexème, ObjectBindingPattern)
    résultat.properties = properties
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom BindingProperty
 * \{ */

BindingProperty :: struct {
    empl base: Expression
    type = #type_de_cette_structure

    property_name: *Expression
    binding_element: *Expression
}

crée_binding_property :: fonc (parseuse: *Parseuse, lexème: *Lexème, property_name: *Expression, binding_element: *Expression) -> *BindingProperty
{
    résultat := parseuse.crée_noeud(lexème, BindingProperty)
    résultat.property_name = property_name
    résultat.binding_element = binding_element
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom BindingElement
 * \{ */

BindingElement :: struct {
    empl base: Expression
    type = #type_de_cette_structure

    expression: *Expression
    initializer: *Expression
}

crée_binding_element :: fonc (parseuse: *Parseuse, lexème: *Lexème, expression: *Expression, initializer: *Expression) -> *BindingElement
{
    résultat := parseuse.crée_noeud(lexème, BindingElement)
    résultat.expression = expression
    résultat.initializer = initializer
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ArrayBindingPattern
 * \{ */

ArrayBindingPattern :: struct {
    empl base: Expression
    type = #type_de_cette_structure

    elements: [..]*Expression
}

crée_array_binding_pattern :: fonc (parseuse: *Parseuse, lexème: *Lexème, elements: [..]*Expression) -> *ArrayBindingPattern
{
    résultat := parseuse.crée_noeud(lexème, ArrayBindingPattern)
    résultat.elements = elements
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom AwaitExpression
 * \{ */

AwaitExpression :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_await_expression

    expression: *Expression
}

crée_await_expression :: fonc (parseuse: *Parseuse, lexème: *Lexème, expression: *Expression) -> *AwaitExpression
{
    résultat := parseuse.crée_noeud(lexème, AwaitExpression)
    résultat.expression = expression
    retourne résultat
}

sur_exécution_await_expression :: fonc (base: *NoeudSyntaxique @inutilisée, interpréteuse: *InterprèteArbre @inutilisée) -> CompletionRecord
{
    panique("exécution await non-implémenté")
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NewTarget
 * \{ */

NewTarget :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_new_target
}

crée_new_target :: fonc (parseuse: *Parseuse, lexème: *Lexème) -> *NewTarget
{
    résultat := parseuse.crée_noeud(lexème, NewTarget)
    retourne résultat
}

sur_exécution_new_target :: fonc (base: *NoeudSyntaxique @inutilisée, interpréteuse: *InterprèteArbre @inutilisée) -> CompletionRecord
{
    panique("exécution new.target non-implémenté")
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom YieldExpression
 * \{ */

YieldExpression :: struct {
    empl base: Expression
    type = #type_de_cette_structure
    sur_exécution = sur_exécution_yield_expression

    expression: *Expression
    est_star: bool
}

crée_yield_expression :: fonc (parseuse: *Parseuse, lexème: *Lexème, expression: *Expression, est_star: bool) -> *YieldExpression
{
    résultat := parseuse.crée_noeud(lexème, YieldExpression)
    résultat.expression = expression
    résultat.est_star = est_star
    retourne résultat
}

sur_exécution_yield_expression :: fonc (base: *NoeudSyntaxique @inutilisée, interpréteuse: *InterprèteArbre @inutilisée) -> CompletionRecord
{
    panique("exécution yield non-implémenté")
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Visiteuse arbre.
 * \{ */

DirectionVisiteNoeud :: énum {
    PRÉ_ORDRE
    POST_ORDRE
}

VisiteEnfants :: énum {
    Oui
    Non
}

VisiteuseNoeud :: struct {
    arbre: *NoeudSyntaxique
    rappel_pour_noeud: fonc(*VisiteuseNoeud, *NoeudSyntaxique, *InfoTypeStructure)(VisiteEnfants)
    rappel_pour_tableau: fonc(*VisiteuseNoeud, [..]*NoeudSyntaxique)(rien)
    profondeur: z32
    direction_visite: DirectionVisiteNoeud
}

donne_info_pour_type_noeud :: fonc (racine: *NoeudSyntaxique) -> *InfoTypeStructure
{
    résultat := racine.type comme *InfoTypeStructure
    assert(est_struct_ou_employeuse_de(résultat, info_de(NoeudSyntaxique)))
    retourne résultat
}

visite_noeud :: fonc (visiteuse: *VisiteuseNoeud, racine: *NoeudSyntaxique, $Rappel: fonc(*VisiteuseNoeud, *NoeudSyntaxique, *InfoTypeStructure)(rien))
{
    /* Les noeuds peuvent être nuls, même dans les tableaux lorsqu'il y a une erreur de compilation. */
    saufsi racine {
        retourne
    }
    infos := donne_info_pour_type_noeud(racine)
    Rappel(visiteuse, racine, infos)
}

visite_noeud_générique :: fonc (visiteuse: *VisiteuseNoeud, racine: *NoeudSyntaxique, info: *InfoTypeStructure)
{
    si visiteuse.direction_visite == DirectionVisiteNoeud.PRÉ_ORDRE && visiteuse.rappel_pour_noeud {
        si visiteuse.rappel_pour_noeud(visiteuse, racine, info) == VisiteEnfants.Non {
            retourne
        }
    }

    valeur_eini : eini = ---
    valeur_eini.pointeur = racine
    valeur_eini.info = info

    visite_structure(visiteuse, valeur_eini)

    si visiteuse.direction_visite == DirectionVisiteNoeud.POST_ORDRE && visiteuse.rappel_pour_noeud {
        _ := visiteuse.rappel_pour_noeud(visiteuse, racine, info)
    }
}

visite_structure :: fonc (visiteuse: *VisiteuseNoeud, valeur_eini: eini)
{
    info := valeur_eini.info comme *InfoTypeStructure

    pour info.rubriques {
        si est_type_adresse_noeud_syntaxique(it.id) {
            rubrique := eini_depuis_info_rubrique(valeur_eini, it)
            expression := mémoire(rubrique.pointeur comme **NoeudSyntaxique)
            si expression == nul {
                continue
            }

            si possède_annotation(it, "NeVisitePas") {
                continue
            }

            visiteuse.profondeur += 1
            visite_noeud(visiteuse, expression, visite_noeud_générique)
            visiteuse.profondeur -= 1
            continue
        }

        si est_type_adresse_tableau_noeud_syntaxique(it.id) {
            rubrique := eini_depuis_info_rubrique(valeur_eini, it)

            tableau := mémoire(rubrique.pointeur comme *[..]*NoeudSyntaxique)

            pour noeud dans tableau {
                visiteuse.profondeur += 1
                visite_noeud(visiteuse, noeud, visite_noeud_générique)
                visiteuse.profondeur -= 1
            }

            si visiteuse.rappel_pour_tableau {
                visiteuse.profondeur += 1
                visiteuse.rappel_pour_tableau(visiteuse, tableau)
                visiteuse.profondeur -= 1
            }

            continue
        }

        si it.id.id == GenreInfoType.STRUCTURE && est_struct_ou_employeuse_de(it.id comme *InfoTypeStructure, info_de(NoeudSyntaxique)) {
            rubrique := eini_depuis_info_rubrique(valeur_eini, it)
            visite_structure(visiteuse, rubrique)
            continue
        }
    }
}

est_type_adresse_noeud_syntaxique :: fonc (infos: *InfoType) -> bool
{
    si infos == info_de(*NoeudSyntaxique) {
        retourne vrai
    }

    saufsi infos.id == GenreInfoType.POINTEUR {
        retourne faux
    }

    type_pointeur := infos comme *InfoTypePointeur
    saufsi type_pointeur.type_pointé {
        retourne faux
    }
    saufsi type_pointeur.type_pointé.id == GenreInfoType.STRUCTURE {
        retourne faux
    }

    type_structure := type_pointeur.type_pointé comme *InfoTypeStructure
    retourne est_struct_ou_employeuse_de(type_structure, info_de(NoeudSyntaxique))
}

est_type_adresse_tableau_noeud_syntaxique :: fonc (infos: *InfoType) -> bool
{
    si infos == info_de([..]*NoeudSyntaxique) {
        retourne vrai
    }

    saufsi infos.id == GenreInfoType.TABLEAU {
        retourne faux
    }

    type_tableau := infos comme *InfoTypeTableau
    retourne est_type_adresse_noeud_syntaxique(type_tableau.type_pointé)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Impression arbre.
 * \{ */

crée_visiteuse_pour_impression :: fonc (noeud: *NoeudSyntaxique) -> VisiteuseNoeud
{
    rappel_pour_noeud :: fonc (visiteuse: *VisiteuseNoeud, noeud: *NoeudSyntaxique, info: *InfoTypeStructure) -> VisiteEnfants
    {
        imprime_tabulation(visiteuse.profondeur)
        texte := ""
        si noeud.lexème {
            texte = noeud.lexème.texte
        }
        imprime("% : %\n", info.nom, texte)
        retourne VisiteEnfants.Oui
    }

    résultat: VisiteuseNoeud
    résultat.arbre = noeud
    résultat.rappel_pour_noeud = rappel_pour_noeud
    résultat.direction_visite = DirectionVisiteNoeud.PRÉ_ORDRE
    retourne résultat
}

imprime_arbre :: fonc (noeud: *NoeudSyntaxique)
{
    visiteuse := crée_visiteuse_pour_impression(noeud)
    visite_noeud(*visiteuse, noeud, visite_noeud_générique)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Destruction arbre.
 * \{ */

crée_visiteuse_pour_destruction :: fonc (noeud: *NoeudSyntaxique) -> VisiteuseNoeud
{
    rappel_pour_noeud :: fonc (visiteuse: *VisiteuseNoeud @inutilisée, noeud: *NoeudSyntaxique, info: *InfoTypeStructure) -> VisiteEnfants
    {
        déloge_mémoire(info.taille_en_octet comme z64, noeud, info, #position_code_source)
        retourne VisiteEnfants.Oui
    }

    rappel_pour_tableau :: fonc (visiteuse: *VisiteuseNoeud @inutilisée, tableau: [..]*NoeudSyntaxique)
    {
        déloge(tableau)
    }

    résultat: VisiteuseNoeud
    résultat.arbre = noeud
    résultat.rappel_pour_noeud = rappel_pour_noeud
    résultat.rappel_pour_tableau = rappel_pour_tableau
    résultat.direction_visite = DirectionVisiteNoeud.POST_ORDRE
    retourne résultat
}

détruit_arbre :: fonc (noeud: *NoeudSyntaxique)
{
    visiteuse := crée_visiteuse_pour_destruction(noeud)
    visite_noeud(*visiteuse, noeud, visite_noeud_générique)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Destruction arbre.
 * \{ */

VisteuseMémoire :: struct {
    empl base: VisiteuseNoeud
    total: z64
    total_compressé: z64
}

crée_visiteuse_pour_mémoire :: fonc (résultat: *VisteuseMémoire, noeud: *NoeudSyntaxique)
{
    rappel_pour_noeud :: fonc (base: *VisiteuseNoeud, noeud: *NoeudSyntaxique @inutilisée, info: *InfoTypeStructure) -> VisiteEnfants
    {
        visiteuse := base comme *VisteuseMémoire
        visiteuse.total += info.taille_en_octet comme z64

        pour info.rubriques {
            si est_type_adresse_noeud_syntaxique(it.id) {
                visiteuse.total_compressé += 4
            }
            sinon saufsi est_type_adresse_tableau_noeud_syntaxique(it.id) {
                visiteuse.total_compressé += it.id.taille_en_octet comme z64
            }
        }

        retourne VisiteEnfants.Oui
    }

    rappel_pour_tableau :: fonc (base: *VisiteuseNoeud, tableau: [..]*NoeudSyntaxique)
    {
        visiteuse := base comme *VisteuseMémoire
        visiteuse.total += tableau.capacité * 8
        visiteuse.total_compressé += (tableau.taille + 1) * 4
    }

    résultat.arbre = noeud
    résultat.rappel_pour_noeud = rappel_pour_noeud
    résultat.rappel_pour_tableau = rappel_pour_tableau
    résultat.direction_visite = DirectionVisiteNoeud.POST_ORDRE
}

imprime_mémoire_arbre :: fonc (noeud: *NoeudSyntaxique)
{
    visiteuse: VisteuseMémoire
    crée_visiteuse_pour_mémoire(*visiteuse, noeud)
    visite_noeud(*visiteuse, noeud, visite_noeud_générique)
    imprime("Mémoire arbre : % (compressé ~= %, %)\n", visiteuse.total, visiteuse.total_compressé, 1.0 - (visiteuse.total_compressé comme r64) / (visiteuse.total comme r64))
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Rassemblement des noms des déclarations de variables.
 * \{ */

VisteuseDéclarationVar :: struct {
    empl base: VisiteuseNoeud
    déclarations: [..]*NoeudSyntaxique
}

crée_visiteuse_pour_déclarations_var :: fonc (résultat: *VisteuseDéclarationVar, noeud: *NoeudSyntaxique)
{
    rappel_pour_noeud :: fonc (base: *VisiteuseNoeud, noeud: *NoeudSyntaxique, info: *InfoTypeStructure @inutilisée) -> VisiteEnfants
    {
        visiteuse := base comme *VisteuseDéclarationVar

        si noeud.type == FunctionDeclaration {
            tableau_ajoute(*visiteuse.déclarations, noeud)
            retourne VisiteEnfants.Non
        }

        si noeud.type == FunctionExpression || noeud.type == ArrowFunction {
            retourne VisiteEnfants.Non
        }

        si noeud.type == VariableDeclaration {
            var_decl := noeud comme *VariableDeclaration
            si var_decl.nature != VariableDeclarationKind.Var {
                retourne VisiteEnfants.Non
            }

            tableau_ajoute(*visiteuse.déclarations, noeud)
        }

        retourne VisiteEnfants.Oui
    }

    résultat.arbre = noeud
    résultat.rappel_pour_noeud = rappel_pour_noeud
    résultat.direction_visite = DirectionVisiteNoeud.PRÉ_ORDRE
}

/* https://tc39.es/ecma262/multipage/syntax-directed-operations.html#sec-static-semantics-varscopeddeclarations */
donne_var_scoped_declarations :: fonc (noeud: *NoeudSyntaxique) -> [..]*NoeudSyntaxique
{
    visiteuse: VisteuseDéclarationVar
    crée_visiteuse_pour_déclarations_var(*visiteuse, noeud)
    visite_noeud(*visiteuse, noeud, visite_noeud_générique)
    retourne visiteuse.déclarations
}

/* https://tc39.es/ecma262/multipage/syntax-directed-operations.html#sec-static-semantics-vardeclarednames */
donne_var_declared_names :: fonc (noeud: *NoeudSyntaxique) -> [..]ECMAString
{
    visiteuse: VisteuseDéclarationVar
    diffère déloge(visiteuse.déclarations)

    crée_visiteuse_pour_déclarations_var(*visiteuse, noeud)
    visite_noeud(*visiteuse, noeud, visite_noeud_générique)

    résultat: [..]ECMAString
    pour visiteuse.déclarations {
        saufsi it.type == VariableDeclaration {
            continue
        }

        var_decl := it comme *VariableDeclaration
        si var_decl.nature != VariableDeclarationKind.Var {
            continue
        }

        pour decl dans var_decl.expressions {
            tableau_ajoute(*résultat, (decl.id comme *Identifier).nom)
        }
    }

    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Rassemblement les déclarations lexicales.
 * \{ */

VisteuseDéclarationsLexicales :: struct {
    empl base: VisiteuseNoeud
    déclarations: [..]*NoeudSyntaxique
}

crée_visiteuse_pour_déclarations_lexicales :: fonc (résultat: *VisteuseDéclarationsLexicales, noeud: *NoeudSyntaxique)
{
    rappel_pour_noeud :: fonc (base: *VisiteuseNoeud, noeud: *NoeudSyntaxique, info: *InfoTypeStructure @inutilisée) -> VisiteEnfants
    {
        visiteuse := base comme *VisteuseDéclarationsLexicales

        si noeud.type == FunctionDeclaration || noeud.type == FunctionExpression || noeud.type == ArrowFunction {
            retourne VisiteEnfants.Non
        }

        si noeud.type == VariableDeclaration {
            var_decl := noeud comme *VariableDeclaration
            si var_decl.nature != VariableDeclarationKind.Var {
                tableau_ajoute(*visiteuse.déclarations, var_decl)
            }
            retourne VisiteEnfants.Non
        }

        si noeud.type == ClassDeclaration {
            tableau_ajoute(*visiteuse.déclarations, noeud)
            retourne VisiteEnfants.Non
        }

        si noeud.type == ExpressionStatement || noeud.type == LabelledStatement || noeud.type == BlockStatement || noeud.type == ScriptBody || noeud.type == NoeudScript || noeud.type == ConciseBody || noeud.type == FunctionBody {
            retourne VisiteEnfants.Oui
        }

        retourne VisiteEnfants.Non
    }

    résultat.arbre = noeud
    résultat.rappel_pour_noeud = rappel_pour_noeud
    résultat.direction_visite = DirectionVisiteNoeud.PRÉ_ORDRE
}

/* https://tc39.es/ecma262/multipage/syntax-directed-operations.html#sec-static-semantics-lexicallydeclarednames */
donne_lexically_scoped_declarations :: fonc (noeud: *NoeudSyntaxique) -> [..]*NoeudSyntaxique
{
    visiteuse: VisteuseDéclarationsLexicales
    crée_visiteuse_pour_déclarations_lexicales(*visiteuse, noeud)
    visite_noeud(*visiteuse, noeud, visite_noeud_générique)
    retourne visiteuse.déclarations
}

/** \} */

/* 8.2.1 Static Semantics: BoundNames
 * https://tc39.es/ecma262/multipage/syntax-directed-operations.html#sec-static-semantics-boundnames */
donne_bound_names :: fonc (syntax: *NoeudSyntaxique, résultat: *[..]ECMAString)
{
    résultat.taille = 0

    si syntax.type == VariableDeclaration {
        variable_declaration := syntax comme *VariableDeclaration
        pour variable_declaration.expressions {
            assert(it.id.type == Identifier)
            tableau_ajoute(résultat, (it.id comme *Identifier).nom)
        }
        retourne
    }

    si syntax.type == ClassDeclaration {
        class_declaration := syntax comme *ClassDeclaration
        tableau_ajoute(résultat, class_declaration.identifier.nom)
        retourne
    }
}

/* 8.2.3 Static Semantics: IsConstantDeclaration
 * https://tc39.es/ecma262/multipage/notational-conventions.html#sec-algorithm-conventions-syntax-directed-operations */
is_constant_declaration :: fonc (syntax: *NoeudSyntaxique) -> bool
{
    si syntax.type == VariableDeclaration {
        variable_declaration := syntax comme *VariableDeclaration
        retourne variable_declaration.nature == VariableDeclarationKind.Const
    }
    retourne faux
}

/* 15.7.8 Static Semantics: PrivateBoundIdentifiers
 * https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-static-semantics-privateboundidentifiers */
donne_private_bound_identifiers :: fonc (body: *ClassBody) -> [..]ECMAString
{
    résultat: [..]ECMAString

    pour body.éléments {
        si it.type == ClassField {
            field := it comme *ClassField
            si field.class_element_name.type == PrivateIdentifier {
                private_identifier := field.class_element_name comme *PrivateIdentifier
                tableau_ajoute(*résultat, private_identifier.nom)
            }
            continue
        }

        si it.type == ClassMethod {
            method := it comme *ClassMethod
            si method.class_element_name.type == PrivateIdentifier {
                private_identifier := method.class_element_name comme *PrivateIdentifier
                tableau_ajoute(*résultat, private_identifier.nom)
            }
            continue
        }
    }

    retourne résultat
}
