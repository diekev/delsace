importe Chaine
importe Fondation
importe Introspection

/* ------------------------------------------------------------------------- */
/** \nom NoeudSyntaxique
 * \{ */

NoeudSyntaxique :: struct {
    type := #type_de_cette_structure

    sur_ex√©cution: fonc(*NoeudSyntaxique, *Interpr√©teuse)(CompletionRecord)
}

ex√©cute_noeud :: fonc (noeud: *NoeudSyntaxique, interpr√©teuse: *Interpr√©teuse) -> CompletionRecord
{
    // imprime("Ex√©cution de %\n", noeud.type)
    retourne noeud.sur_ex√©cution(noeud, interpr√©teuse)
}

/* 11.2.2.1 Static Semantics: IsStrict ( node )
 * https://tc39.es/ecma262/multipage/ecmascript-language-source-code.html#sec-isstrict */
is_strict :: fonc (noeud: *NoeudSyntaxique @inutilis√©e) -> bool
{
    // √Ä FAIRE 1. If the source text matched by node is strict mode code, return true; else return false.
    retourne faux
}

/* 8.4.1 Static Semantics: HasName
 * https://tc39.es/ecma262/multipage/syntax-directed-operations.html#sec-static-semantics-hasname */
has_name :: fonc (noeud: *NoeudSyntaxique) -> bool
{
    // √Ä FAIRE : impl√©mente tous les cas
    si noeud.type == FunctionExpression {
        retourne (noeud comme *FunctionExpression).id != nul
    }
    retourne faux
}

/* 8.4.2 Static Semantics: IsFunctionDefinition
 * https://tc39.es/ecma262/multipage/syntax-directed-operations.html#sec-static-semantics-isfunctiondefinition */
is_function_definition :: fonc (noeud: *NoeudSyntaxique) -> bool
{
    // √Ä FAIRE : impl√©mente tous les cas
    retourne noeud.type == FunctionExpression
}

/* 8.4.3 Static Semantics: IsAnonymousFunctionDefinition
 * https://tc39.es/ecma262/multipage/syntax-directed-operations.html#sec-isanonymousfunctiondefinition */
is_anonymous_function_definition :: fonc (noeud: *NoeudSyntaxique) -> bool
{
    // 1. If IsFunctionDefinition of expr is false, return false.
    saufsi is_function_definition(noeud) {
        retourne faux
    }

    // 2. Let hasName be HasName of expr.
    // 3. If hasName is true, return false.
    si has_name(noeud) {
        retourne faux
    }

    // 4. Return true.
    retourne vrai
}

/* 8.4.4 Static Semantics: IsIdentifierRef
 * https://tc39.es/ecma262/multipage/syntax-directed-operations.html#sec-static-semantics-isidentifierref */
is_identifier_ref :: fonc (noeud: *NoeudSyntaxique) -> bool
{
    retourne noeud.type == Identifier
}

/* 8.4.5 Runtime Semantics: NamedEvaluation
 * https://tc39.es/ecma262/multipage/syntax-directed-operations.html#sec-runtime-semantics-namedevaluation */
named_evaluation :: fonc (interpr√©teuse: *Interpr√©teuse, noeud: *NoeudSyntaxique, name: ECMAString) -> CompletionRecord
{
    si noeud.type == FunctionExpression {
        // 1. Return InstantiateOrdinaryFunctionExpression of FunctionExpression with argument name.
        r√©sultat := instantiate_ordinary_function_expression(interpr√©teuse, noeud comme *FunctionExpression, *name)
        retourne normal_completion(Valeur(Function = r√©sultat))
    }

    panique("name_evaluation non-impl√©ment√©")
}

/* 8.6.5 Static Semantics: PropName
 * https://tc39.es/ecma262/multipage/syntax-directed-operations.html#sec-static-semantics-propname */
prop_name :: fonc (noeud: *NoeudSyntaxique) -> ECMAString
{
    si noeud.type == Identifier {
        identifier := noeud comme *Identifier
        retourne identifier.nom
    }
    // √Ä FAIRE : compl√®te
    retourne cr√©e_chaine_utf16_unique_vide()
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NoeudScope
 * Type Utilis√© pour Interpr√©teuse.ex√©cute
 * \{ */

NoeudScope :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_scope

    enfants: [..]*NoeudSyntaxique
}

sur_ex√©cution_scope :: fonc (noeud: *NoeudSyntaxique, interpr√©teuse: *Interpr√©teuse) -> CompletionRecord
{
    retourne interpr√©teuse.ex√©cute(noeud comme *NoeudScope, TypeScope.BLOC)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Programme
 * \{ */

Programme :: struct {
    empl scope: NoeudScope
    type = #type_de_cette_structure

    type_source := "script"
}

cr√©e_programme :: fonc (expressions: ...*NoeudSyntaxique) -> *Programme
{
    r√©sultat := loge(Programme)
    pour expressions {
        tableau_ajoute(*r√©sultat.enfants, it)
    }
    retourne r√©sultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom FunctionDeclaration
 * \{ */

FunctionDeclaration :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_function_declaration

    id: *Identifier
    params: [..]*NoeudSyntaxique
    corps: *NoeudSyntaxique

    generator := faux
    expression := faux
    async := faux
}

cr√©e_function_d√©claration :: fonc (id: *Identifier, params: []*NoeudSyntaxique, corps: *NoeudSyntaxique) -> *FunctionDeclaration
{
    r√©sultat := loge(FunctionDeclaration)
    r√©sultat.id = id
    r√©sultat.corps = corps
    pour params {
        tableau_ajoute(*r√©sultat.params, it)
    }
    retourne r√©sultat
}

sur_ex√©cution_function_declaration :: fonc (base: *NoeudSyntaxique, interpr√©teuse: *Interpr√©teuse) -> CompletionRecord
{
    noeud := base comme *FunctionDeclaration

    mv := interpr√©teuse.mv
    running_execution_context := mv.donne_running_execution_context()
    realm := running_execution_context.realm

    fonction := cr√©e_fonction(realm, realm.intrinsics.function_prototype, noeud.id.nom, noeud.corps)
    fonction.environment = running_execution_context.lexical_environment

    objet_global := interpr√©teuse.get_global_object()
    completion := set(objet_global, noeud.id.nom, Valeur(Function = fonction), vrai)
    saufsi completion.est_normal() {
        retourne completion
    }

    retourne normal_completion(Valeur(Function = fonction))
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom FunctionExpression
 * \{ */

FunctionExpression :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_function_expression

    id: *Identifier
    params: [..]*NoeudSyntaxique
    corps: *NoeudSyntaxique

    generator := faux
    expression := faux
    async := faux
}

cr√©e_function_expression :: fonc (id: *Identifier, params: []*NoeudSyntaxique, corps: *NoeudSyntaxique) -> *FunctionExpression
{
    r√©sultat := loge(FunctionExpression)
    r√©sultat.id = id
    r√©sultat.corps = corps
    pour params {
        tableau_ajoute(*r√©sultat.params, it)
    }
    retourne r√©sultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-function-definitions-runtime-semantics-evaluation */
sur_ex√©cution_function_expression :: fonc (base: *NoeudSyntaxique, interpr√©teuse: *Interpr√©teuse) -> CompletionRecord
{
    expression := base comme *FunctionExpression
    /* 1. Return InstantiateOrdinaryFunctionExpression of FunctionExpression. */
    closure := instantiate_ordinary_function_expression(interpr√©teuse, expression)
    retourne normal_completion(Valeur(Function = closure))
}

/* 15.2.5 Runtime Semantics: InstantiateOrdinaryFunctionExpression
 * https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-runtime-semantics-instantiateordinaryfunctionexpression */
instantiate_ordinary_function_expression :: fonc (interpr√©teuse: *Interpr√©teuse, expression: *FunctionExpression, opt_name : *ECMAString = nul) -> *Function
{
    si expression.id == nul {
        mv := interpr√©teuse.mv
        running_execution_context := mv.donne_running_execution_context()

        // 1. If name is not present, set name to "".
        name: ECMAString
        si opt_name {
            name = m√©moire(opt_name)
        }

        // 2. Let env be the LexicalEnvironment of the running execution context.
        env := running_execution_context.lexical_environment

        // 3. Let privateEnv be the running execution context's PrivateEnvironment.
        private_env := running_execution_context.private_environment

        // √Ä FAIRE 4. Let sourceText be the source text matched by FunctionExpression.

        // 5. Let closure be OrdinaryFunctionCreate(%Function.prototype%, sourceText, FormalParameters, FunctionBody, NON-LEXICAL-THIS, env, privateEnv).
        realm := running_execution_context.realm
        closure := ordinary_function_create(realm, realm.intrinsics.function_prototype, expression.params, expression.corps, NON_LEXICAL_THIS, env, private_env)

        // √Ä FAIRE 6. Perform SetFunctionName(closure, name).

        // √Ä FAIRE 7. Perform MakeConstructor(closure).

        // 8. Return closure.
        retourne closure
    }

    panique("instantiate_ordinary_function_expression non-impl√©ment√©")
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Identifier
 * \{ */

Identifier :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_identifier

    nom: ECMAString
}

cr√©e_identifier :: fonc (nom: ECMAString) -> *Identifier
{
    r√©sultat := loge(Identifier)
    r√©sultat.nom = nom
    retourne r√©sultat
}

cr√©e_identifier :: fonc (nom: chaine) -> *Identifier
{
    retourne cr√©e_identifier(cr√©e_chaine_utf16_unique(nom))
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-identifiers-runtime-semantics-evaluation */
sur_ex√©cution_identifier :: fonc (base: *NoeudSyntaxique, interpr√©teuse: *Interpr√©teuse) -> CompletionRecord
{
    noeud := base comme *Identifier
    retourne resolve_binding(interpr√©teuse, noeud.nom)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom BlockStatement
 * \{ */

BlockStatement :: struct {
    empl scope: NoeudScope
    type = #type_de_cette_structure
}

cr√©e_block_statement :: fonc (expressions: ...*NoeudSyntaxique) -> *BlockStatement
{
    r√©sultat := loge(BlockStatement)
    pour expressions {
        tableau_ajoute(*r√©sultat.enfants, it)
    }
    retourne r√©sultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ReturnStatement
 * \{ */

ReturnStatement :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_return

    argument: *NoeudSyntaxique
}

cr√©e_return_statement :: fonc (argument: *NoeudSyntaxique) -> *ReturnStatement
{
    r√©sultat := loge(ReturnStatement)
    r√©sultat.argument = argument
    retourne r√©sultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-return-statement-runtime-semantics-evaluation */
sur_ex√©cution_return :: fonc (base: *NoeudSyntaxique, interpr√©teuse: *Interpr√©teuse) -> CompletionRecord
{
    noeud := base comme *ReturnStatement

    // ReturnStatement : return ;
    // 1. Return Completion Record { [[Type]]: RETURN, [[Value]]: undefined, [[Target]]: EMPTY }.
    r√©sultat := return_completion(js_undefined)

    // ReturnStatement : return Expression ;
    si noeud.argument {
        // 1. Let exprRef be ? Evaluation of Expression.
        completion := ex√©cute_noeud(noeud.argument, interpr√©teuse)
        saufsi completion.est_normal() {
            retourne completion
        }
        expr_ref := completion.valeur
        // 2. Let exprValue be ? GetValue(exprRef).
        completion = get_value(interpr√©teuse, expr_ref)
        saufsi completion.est_normal() {
            retourne completion
        }
        expr_value := completion.valeur.V

        // √Ä FAIRE : 3. If GetGeneratorKind() is ASYNC, set exprValue to ? Await(exprValue).

        // 4. Return Completion Record { [[Type]]: RETURN, [[Value]]: exprValue, [[Target]]: EMPTY }.
        r√©sultat = return_completion(expr_value)
    }

    retourne r√©sultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom UnaryPlusOperator
 * \{ */

UnaryPlusOperator :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_unary_plus_operator

    argument: *NoeudSyntaxique
}

cr√©e_unary_plus_operator :: fonc (argument: *NoeudSyntaxique) -> *UnaryPlusOperator
{
    r√©sultat := loge(UnaryPlusOperator)
    r√©sultat.argument = argument
    retourne r√©sultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-unary-plus-operator-runtime-semantics-evaluation */
sur_ex√©cution_unary_plus_operator :: fonc (base: *NoeudSyntaxique, interpr√©teuse: *Interpr√©teuse) -> CompletionRecord
{
    noeud := base comme *UnaryPlusOperator
    unary_expression := noeud.argument

    // 1. Let expr be ? Evaluation of UnaryExpression.
    completion := ex√©cute_noeud(unary_expression, interpr√©teuse)
    saufsi completion.est_normal() {
        retourne completion
    }
    expr := completion.valeur

    // 2. Return ? ToNumber(? GetValue(expr)).
    completion = get_value(interpr√©teuse, expr)
    saufsi completion.est_normal() {
        retourne completion
    }

    retourne vers_nombre(interpr√©teuse, completion.valeur.V)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom UnaryMinusOperator
 * \{ */

UnaryMinusOperator :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_unary_minus_operator

    argument: *NoeudSyntaxique
}

cr√©e_unary_minus_operator :: fonc (argument: *NoeudSyntaxique) -> *UnaryMinusOperator
{
    r√©sultat := loge(UnaryMinusOperator)
    r√©sultat.argument = argument
    retourne r√©sultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-unary-minus-operator-runtime-semantics-evaluation */
sur_ex√©cution_unary_minus_operator :: fonc (base: *NoeudSyntaxique, interpr√©teuse: *Interpr√©teuse) -> CompletionRecord
{
    noeud := base comme *UnaryMinusOperator
    unary_expression := noeud.argument

    // 1. Let expr be ? Evaluation of UnaryExpression.
    completion := ex√©cute_noeud(unary_expression, interpr√©teuse)
    saufsi completion.est_normal() {
        retourne completion
    }
    expr := completion.valeur

    // 2. Let oldValue be ? ToNumeric(? GetValue(expr)).
    completion = get_value(interpr√©teuse, expr)
    saufsi completion.est_normal() {
        retourne completion
    }
    completion = to_numeric(interpr√©teuse, completion.valeur.V)
    saufsi completion.est_normal() {
        retourne completion
    }
    old_value := completion.valeur.V

    // 3. If oldValue is a Number, then
    si old_value.est_nombre() {
        // a. Return Number::unaryMinus(oldValue).
        retourne normal_completion(number_unary_minus(old_value))
    }
    // 4. Else,
    // a. Assert: oldValue is a BigInt.
    assert(old_value.est_big_int())
    // b. Return BigInt::unaryMinus(oldValue).
    retourne normal_completion(bigint_unary_minus(old_value))
}

/* https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-numeric-types-number-unaryMinus */
number_unary_minus :: fonc (x: Valeur) -> Valeur
{
    // 1. If x is NaN, return NaN.
    // √Ä FAIRE : est_nan

    // 2. Return the negation of x; that is, compute a Number with the same magnitude but opposite sign.
    retourne Valeur(Number = -x.Number)
}

bigint_unary_minus :: fonc (x: Valeur @inutilis√©e) -> Valeur
{
    panique("big_int unary minus non-impl√©ment√©")
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom LogicalNot
 * \{ */

LogicalNot :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_logical_not

    argument: *NoeudSyntaxique
}

cr√©e_logical_not :: fonc (argument: *NoeudSyntaxique) -> *LogicalNot
{
    r√©sultat := loge(LogicalNot)
    r√©sultat.argument = argument
    retourne r√©sultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-logical-not-operator */
sur_ex√©cution_logical_not :: fonc (base: *NoeudSyntaxique, interpr√©teuse: *Interpr√©teuse) -> CompletionRecord
{
    noeud := base comme *LogicalNot
    unary_expression := noeud.argument

    // 1. Let expr be ? Evaluation of UnaryExpression.
    completion := ex√©cute_noeud(unary_expression, interpr√©teuse)
    saufsi completion.est_normal() {
        retourne completion
    }
    expr := completion.valeur

    // 2. Let oldValue be ToBoolean(? GetValue(expr)).
    completion = get_value(interpr√©teuse, expr)
    saufsi completion.est_normal() {
        retourne completion
    }
    old_value := to_boolean(completion.valeur.V)

    // 3. If oldValue is true, return false.
    si old_value.est_true() {
        retourne normal_completion(Valeur(Boolean = faux))
    }

    // 4. Return true.
    retourne normal_completion(Valeur(Boolean = vrai))
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom BinaryExpression
 * \{ */

BinaryOperation :: √©num {
    Plus
    Moins
    Multiplie
    Divise
}

BinaryExpression :: struct {
    empl  base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_binary_expression

    op√©ration: BinaryOperation
    gauche: *NoeudSyntaxique
    droite: *NoeudSyntaxique
}

cr√©e_binary_expression :: fonc (op√©ration: BinaryOperation, gauche: *NoeudSyntaxique, droite: *NoeudSyntaxique) -> *BinaryExpression
{
    r√©sultat := loge(BinaryExpression)
    r√©sultat.op√©ration = op√©ration
    r√©sultat.gauche = gauche
    r√©sultat.droite = droite
    retourne r√©sultat
}


sur_ex√©cution_binary_expression :: fonc (base: *NoeudSyntaxique, interpr√©teuse: *Interpr√©teuse) -> CompletionRecord
{
    noeud := base comme *BinaryExpression
    completion_gauche := ex√©cute_noeud(noeud.gauche, interpr√©teuse)
    saufsi completion_gauche.est_normal() {
        retourne completion_gauche
    }
    completion_droite := ex√©cute_noeud(noeud.droite, interpr√©teuse)
    saufsi completion_droite.est_normal() {
        retourne completion_droite
    }
    valeur_compl√©tion_gauche := get_value(interpr√©teuse, completion_gauche.valeur)
    saufsi valeur_compl√©tion_gauche.est_normal() {
        retourne valeur_compl√©tion_gauche
    }
    valeur_compl√©tion_droite := get_value(interpr√©teuse, completion_droite.valeur)
    saufsi valeur_compl√©tion_droite.est_normal() {
        retourne valeur_compl√©tion_droite
    }
    gauche := valeur_compl√©tion_gauche.valeur.V
    droite := valeur_compl√©tion_droite.valeur.V
    retourne apply_string_or_numeric_binary_operator(interpr√©teuse, noeud.op√©ration, gauche, droite)
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-applystringornumericbinaryoperator */
apply_string_or_numeric_binary_operator :: fonc (interpr√©teuse: *Interpr√©teuse, op√©ration: BinaryOperation, gauche: Valeur, droite: Valeur) -> CompletionRecord
{
    // 1. If opText is +, then
    si op√©ration == BinaryOperation.Plus {
        // a. Let lprim be ? ToPrimitive(lval).
        compl√©tion_lprim := vers_primitive(interpr√©teuse, gauche)
        saufsi compl√©tion_lprim.est_normal() {
            retourne compl√©tion_lprim
        }
        lprim := compl√©tion_lprim.valeur.V
        // b. Let rprim be ? ToPrimitive(rval).
        compl√©tion_rprim := vers_primitive(interpr√©teuse, droite)
        saufsi compl√©tion_rprim.est_normal() {
            retourne compl√©tion_rprim
        }
        rprim := compl√©tion_rprim.valeur.V
        // c. If lprim is a String or rprim is a String, then
        si lprim.est_chaine() || rprim.est_chaine() {
            // i. Let lstr be ? ToString(lprim).
            completion_lstr := vers_chaine(interpr√©teuse, gauche)
            saufsi completion_lstr.est_normal() {
                retourne completion_lstr
            }
            lstr := completion_lstr.valeur.V
            // ii. Let rstr be ? ToString(rprim).
            completion_rstr := vers_chaine(interpr√©teuse, droite)
            saufsi completion_rstr.est_normal() {
                retourne completion_rstr
            }
            rstr := completion_rstr.valeur.V
            // iii. Return the string-concatenation of lstr and rstr.
            retourne normal_completion(Valeur(String = concat√®ne(lstr.String, rstr.String)))
        }
    
        // d. Set lval to lprim.
        gauche = lprim
        // e. Set rval to rprim.
        droite = rprim
    }

    // 2. NOTE: At this point, it must be a numeric operation.

    // 3. Let lnum be ? ToNumeric(lval).
    compl√©tion_lnum := to_numeric(interpr√©teuse, gauche)
    saufsi compl√©tion_lnum.est_normal() {
        retourne compl√©tion_lnum
    }
    gauche = compl√©tion_lnum.valeur.V

    // 4. Let rnum be ? ToNumeric(rval).
    compl√©tion_rnum := to_numeric(interpr√©teuse, droite)
    saufsi compl√©tion_rnum.est_normal() {
        retourne compl√©tion_rnum
    }
    droite = compl√©tion_rnum.valeur.V

    // 5. If Type(lnum) is not Type(rnum), throw a TypeError exception.
    si donne_type(gauche) != donne_type(droite) {
        retourne lance_type_error(interpr√©teuse, "Incompatible types for binary expression")
    }

    // 6. If lnum is a BigInt, then
    si est_big_int(gauche) {
        // a. If opText is **, return ? BigInt::exponentiate(lnum, rnum).
        // b. If opText is /, return ? BigInt::divide(lnum, rnum).
        // c. If opText is %, return ? BigInt::remainder(lnum, rnum).
        // d. If opText is >>>, return ? BigInt::unsignedRightShift(lnum, rnum).
        panique("big_int non-g√©r√©")
    }

    // 7. Let operation be the abstract operation associated with opText and Type(lnum) in the following table:

    // 8. Return operation(lnum, rnum).
    valeur := js_undefined

    discr op√©ration {
        Plus {
            valeur = ajoute_valeurs(gauche, droite)
        }
        Moins {
            valeur = soustrait_valeurs(gauche, droite)
        }
        Multiplie {
            valeur = multiplie_valeurs(gauche, droite)
        }
        Divise {
            valeur = divise_valeurs(gauche, droite)
        }
    }

    retourne normal_completion(valeur)
}

ajoute_valeurs :: fonc (gauche: Valeur, droite: Valeur) -> Valeur
{
    assert(gauche.est_nombre())
    assert(droite.est_nombre())
    retourne Valeur(Number = gauche.Number + droite.Number)
}

soustrait_valeurs :: fonc (gauche: Valeur, droite: Valeur) -> Valeur
{
    assert(gauche.est_nombre())
    assert(droite.est_nombre())
    retourne Valeur(Number = gauche.Number - droite.Number)
}

multiplie_valeurs :: fonc (gauche: Valeur, droite: Valeur) -> Valeur
{
    assert(gauche.est_nombre())
    assert(droite.est_nombre())
    retourne Valeur(Number = gauche.Number * droite.Number)
}

divise_valeurs :: fonc (gauche: Valeur, droite: Valeur) -> Valeur
{
    assert(gauche.est_nombre())
    assert(droite.est_nombre())
    retourne Valeur(Number = gauche.Number / droite.Number)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom EqualityExpression
 * \{ */

EqualityOperation :: √©num {
    √âgal
    In√©gal
    √âgalStrict
    In√©galStrict
}

EqualityExpression :: struct {
    empl  base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_equality_expression

    op√©ration: EqualityOperation
    gauche: *NoeudSyntaxique
    droite: *NoeudSyntaxique
}

cr√©e_equality_expression :: fonc (op√©ration: EqualityOperation, gauche: *NoeudSyntaxique, droite: *NoeudSyntaxique) -> *EqualityExpression
{
    r√©sultat := loge(EqualityExpression)
    r√©sultat.op√©ration = op√©ration
    r√©sultat.gauche = gauche
    r√©sultat.droite = droite
    retourne r√©sultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-equality-operators-runtime-semantics-evaluation */
sur_ex√©cution_equality_expression :: fonc (base: *NoeudSyntaxique, interpr√©teuse: *Interpr√©teuse) -> CompletionRecord
{
    noeud := base comme *EqualityExpression
    completion_gauche := ex√©cute_noeud(noeud.gauche, interpr√©teuse)
    saufsi completion_gauche.est_normal() {
        retourne completion_gauche
    }
    completion_droite := ex√©cute_noeud(noeud.droite, interpr√©teuse)
    saufsi completion_droite.est_normal() {
        retourne completion_droite
    }
    valeur_compl√©tion_gauche := get_value(interpr√©teuse, completion_gauche.valeur)
    saufsi valeur_compl√©tion_gauche.est_normal() {
        retourne valeur_compl√©tion_gauche
    }
    valeur_compl√©tion_droite := get_value(interpr√©teuse, completion_droite.valeur)
    saufsi valeur_compl√©tion_droite.est_normal() {
        retourne valeur_compl√©tion_droite
    }
    gauche := valeur_compl√©tion_gauche.valeur.V
    droite := valeur_compl√©tion_droite.valeur.V
    
    discr noeud.op√©ration {
        √âgal {
            retourne is_loosely_equal(interpr√©teuse, gauche, droite)
        }
        In√©gal {
            compl√©tion := is_loosely_equal(interpr√©teuse, gauche, droite)
            saufsi compl√©tion.est_normal() {
                retourne compl√©tion
            }
            r√©sultat := compl√©tion.valeur.V
            si r√©sultat.est_true() {
                retourne normal_completion(Valeur(Boolean = faux))
            }
            retourne normal_completion(Valeur(Boolean = vrai))
        }
        √âgalStrict {
            retourne normal_completion(is_strictly_equal(gauche, droite))
        }
        In√©galStrict {
            r√©sultat := is_strictly_equal(gauche, droite)
            si r√©sultat.est_true() {
                retourne normal_completion(Valeur(Boolean = faux))
            }
            retourne normal_completion(Valeur(Boolean = vrai))
        }
        sinon {
            panique("noeud.op√©ration non-initialis√©")
        }
    }
}

donne_type :: fonc (valeur: Valeur) -> z32
{
    info := info_de(Valeur)
    index := m√©moire(((*valeur comme *octet) + info.d√©calage_index) comme *z32)
    retourne index
}

/* 7.2.12 IsLooselyEqual ( x, y )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-islooselyequal */
is_loosely_equal :: fonc (interpr√©teuse: *Interpr√©teuse @inutilis√©e, x: Valeur, y: Valeur) -> CompletionRecord
{
    // 1. If Type(x) is Type(y), then
    si x.donne_type() == y.donne_type() {
        // a. Return IsStrictlyEqual(x, y).
        retourne normal_completion(is_strictly_equal(x, y))
    }

    // 2. If x is null and y is undefined, return true.
    si x.est_nulle() && y.est_undefined() {
        retourne normal_completion(Valeur(Boolean = vrai))
    }

    // 3. If x is undefined and y is null, return true.
    si x.est_undefined() && y.est_nulle() {
        retourne normal_completion(Valeur(Boolean = vrai))
    }

    panique("is_loosely_equal non-impl√©ment√©")
    // 4. NOTE: This step is replaced in section B.3.6.2.
    // 5. If x is a Number and y is a String, return ! IsLooselyEqual(x, ! ToNumber(y)).
    // 6. If x is a String and y is a Number, return ! IsLooselyEqual(! ToNumber(x), y).
    // 7. If x is a BigInt and y is a String, then
    //     a. Let n be StringToBigInt(y).
    //     b. If n is undefined, return false.
    //     c. Return ! IsLooselyEqual(x, n).
    // 8. If x is a String and y is a BigInt, return ! IsLooselyEqual(y, x).
    // 9. If x is a Boolean, return ! IsLooselyEqual(! ToNumber(x), y).
    // 10. If y is a Boolean, return ! IsLooselyEqual(x, ! ToNumber(y)).
    // 11. If x is either a String, a Number, a BigInt, or a Symbol and y is an Object, return ! IsLooselyEqual(x, ? ToPrimitive(y)).
    // 12. If x is an Object and y is either a String, a Number, a BigInt, or a Symbol, return ! IsLooselyEqual(? ToPrimitive(x), y).
    // 13. If x is a BigInt and y is a Number, or if x is a Number and y is a BigInt, then
    //     a. If x is not finite or y is not finite, return false.
    //     b. If ‚Ñù(x) = ‚Ñù(y), return true; otherwise return false.
    // 14. Return false.
}

/* 7.2.10 SameValueNonNumber ( x, y )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-samevaluenonnumber */
same_value_non_number :: fonc (x: Valeur, y: Valeur) -> Valeur
{
    // 1. Assert: Type(x) is Type(y).

    // 2. If x is either null or undefined, return true.
    si x.est_nulle() || x.est_undefined() {
        retourne Valeur(Boolean = vrai)
    }

    // 3. If x is a BigInt, then
    si est_big_int(x) {
        // a. Return BigInt::equal(x, y).
        retourne big_int_equal(x, y)
    }

    // 4. If x is a String, then
    si x.est_chaine() {
        // a. If x and y have the same length and the same code units in the same positions, return true; otherwise, return false.
        chnx := x.String
        chny := y.String
        retourne chnx.texte == chny.texte
    }

    // 5. If x is a Boolean, then
    si x.est_boolean() {
        // a. If x and y are both true or both false, return true; otherwise, return false.
        boolx := x.Boolean
        booly := y.Boolean
        retourne boolx == booly
    }

    // 6. NOTE: All other ECMAScript language values are compared by identity.
    // 7. If x is y, return true; otherwise, return false.
    retourne x.donne_objet() == y.donne_objet()
}

/* 7.2.13 IsStrictlyEqual ( x, y )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-isstrictlyequal */
is_strictly_equal :: fonc (x: Valeur, y: Valeur) -> Valeur
{
    // 1. If Type(x) is not Type(y), return false.
    si x.donne_type() != y.donne_type() {
        retourne Valeur(Boolean = faux)
    }

    // 2. If x is a Number, then
    si x.est_nombre() {
        // a. Return Number::equal(x, y).
        // √Ä FAIRE : Numer::equal
        valx := x.Number
        valy := y.Number
        retourne valx == valy
    }

    // 3. Return SameValueNonNumber(x, y).
    retourne same_value_non_number(x, y)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom RelationalExpression
 * \{ */

RelationalOperation :: √©num {
    Sup√©rieur
    Inf√©rieur
    Sup√©rieur√âgal
    Inf√©rieur√âgal
}

RelationalExpression :: struct {
    empl  base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_relational_expression

    op√©ration: RelationalOperation
    gauche: *NoeudSyntaxique
    droite: *NoeudSyntaxique
}

cr√©e_relational_expression :: fonc (op√©ration: RelationalOperation, gauche: *NoeudSyntaxique, droite: *NoeudSyntaxique) -> *RelationalExpression
{
    r√©sultat := loge(RelationalExpression)
    r√©sultat.op√©ration = op√©ration
    r√©sultat.gauche = gauche
    r√©sultat.droite = droite
    retourne r√©sultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-relational-operators-runtime-semantics-evaluation */
sur_ex√©cution_relational_expression :: fonc (base: *NoeudSyntaxique, interpr√©teuse: *Interpr√©teuse) -> CompletionRecord
{
    noeud := base comme *RelationalExpression

    // 1. Let lref be ? Evaluation of RelationalExpression.
    completion_lref := ex√©cute_noeud(noeud.gauche, interpr√©teuse)
    saufsi completion_lref.est_normal() {
        retourne completion_lref
    }
    lref := completion_lref.valeur

    // 2. Let lval be ? GetValue(lref).
    completion_lval := get_value(interpr√©teuse, lref)
    saufsi completion_lval.est_normal() {
        retourne completion_lval
    }
    lval := completion_lval.valeur.V

    // 3. Let rref be ? Evaluation of ShiftExpression.
    completion_rref := ex√©cute_noeud(noeud.droite, interpr√©teuse)
    saufsi completion_rref.est_normal() {
        retourne completion_rref
    }
    rref := completion_rref.valeur

    // 4. Let rval be ? GetValue(rref).
    completion_rval := get_value(interpr√©teuse, rref)
    saufsi completion_rval.est_normal() {
        retourne completion_rval
    }
    rval := completion_rval.valeur.V

    r: Valeur

    discr noeud.op√©ration {
        Inf√©rieur {
            // 5. Let r be ? IsLessThan(lval, rval, true).
            completion := is_less_than(interpr√©teuse, lval, rval, vrai)
            saufsi completion.est_normal() {
                retourne completion
            }
            r = completion.valeur.V

            // 6. If r is undefined, return false. Otherwise, return r.
            si r.est_undefined() {
                r = Valeur(Boolean = faux)
            }
        }
        Sup√©rieur {
            // 5. Let r be ? IsLessThan(rval, lval, false).
            completion := is_less_than(interpr√©teuse, rval, lval, faux)
            saufsi completion.est_normal() {
                retourne completion
            }
            r = completion.valeur.V

            // 6. If r is undefined, return false. Otherwise, return r.
            si r.est_undefined() {
                r = Valeur(Boolean = faux)
            }
        }
        Inf√©rieur√âgal {
            // 5. Let r be ? IsLessThan(rval, lval, false).
            completion := is_less_than(interpr√©teuse, rval, lval, faux)
            saufsi completion.est_normal() {
                retourne completion
            }
            r = completion.valeur.V

            // 6. If r is either true or undefined, return false. Otherwise, return true.
            si r.est_true() || r.est_undefined() {
                r = Valeur(Boolean = faux)
            }
            sinon {
                r = Valeur(Boolean = vrai)
            }
        }
        Sup√©rieur√âgal {
            // 5. Let r be ? IsLessThan(lval, rval, true).
            completion := is_less_than(interpr√©teuse, lval, rval, vrai)
            saufsi completion.est_normal() {
                retourne completion
            }
            r = completion.valeur.V

            // 6. If r is either true or undefined, return false. Otherwise, return true.
            si r.est_true() || r.est_undefined() {
                r = Valeur(Boolean = faux)
            }
            sinon {
                r = Valeur(Boolean = vrai)
            }
        }
    }

    retourne normal_completion(r)
}

/* 7.2.11 IsLessThan ( x, y, LeftFirst )
 * https://tc39.es/ecma262/multipage/abstract-operations.html#sec-islessthan */
is_less_than :: fonc (interpr√©teuse: *Interpr√©teuse, x: Valeur, y: Valeur, left_first: bool) -> CompletionRecord
{
    px: Valeur
    py: Valeur

    // 1. If LeftFirst is true, then
    si left_first {
        // a. Let px be ? ToPrimitive(x, NUMBER).
        completion := vers_primitive(interpr√©teuse, x, TypePr√©f√©r√©.Number)
        saufsi completion.est_normal() {
            retourne completion
        }
        px = completion.valeur.V

        // b. Let py be ? ToPrimitive(y, NUMBER).
        completion = vers_primitive(interpr√©teuse, y, TypePr√©f√©r√©.Number)
        saufsi completion.est_normal() {
            retourne completion
        }
        py = completion.valeur.V
    }
    // 2. Else,
    sinon {
        // a. NOTE: The order of evaluation needs to be reversed to preserve left to right evaluation.
        // b. Let py be ? ToPrimitive(y, NUMBER).
        completion := vers_primitive(interpr√©teuse, y, TypePr√©f√©r√©.Number)
        saufsi completion.est_normal() {
            retourne completion
        }
        py = completion.valeur.V

        // c. Let px be ? ToPrimitive(x, NUMBER).
        completion = vers_primitive(interpr√©teuse, x, TypePr√©f√©r√©.Number)
        saufsi completion.est_normal() {
            retourne completion
        }
        px = completion.valeur.V
    }

    // 3. If px is a String and py is a String, then
    si px.est_chaine() && py.est_chaine() {
        panique("is_less_than non-impl√©ment√© pour chaine < chaine")
        // a. Let lx be the length of px.
        // b. Let ly be the length of py.
        // c. For each integer i such that 0 ‚â§ i < min(lx, ly), in ascending order, do
            // i. Let cx be the numeric value of the code unit at index i within px.
            // ii. Let cy be the numeric value of the code unit at index i within py.
            // iii. If cx < cy, return true.
            // iv. If cx > cy, return false.
        // d. If lx < ly, return true. Otherwise, return false.   
    }
    // 4. Else,
    sinon {
        // a. If px is a BigInt and py is a String, then
        si px.est_big_int() && py.est_chaine() {
            // i. Let ny be StringToBigInt(py).
            // ii. If ny is undefined, return undefined.
            // iii. Return BigInt::lessThan(px, ny).
            panique("is_less_than non-impl√©ment√© pour bigint < chaine")
        }
        // b. If px is a String and py is a BigInt, then
        si px.est_chaine() && py.est_big_int() {
            // i. Let nx be StringToBigInt(px).
            // ii. If nx is undefined, return undefined.
            // iii. Return BigInt::lessThan(nx, py).
            panique("is_less_than non-impl√©ment√© pour bigint < chaine")
        }
        // c. NOTE: Because px and py are primitive values, evaluation order is not important.
        // d. Let nx be ? ToNumeric(px).
        completion := to_numeric(interpr√©teuse, px)
        saufsi completion.est_normal() {
            retourne completion
        }
        nx := completion.valeur.V

        // e. Let ny be ? ToNumeric(py).
        completion = to_numeric(interpr√©teuse, py)
        saufsi completion.est_normal() {
            retourne completion
        }
        ny := completion.valeur.V

        // f. If Type(nx) is Type(ny), then
        si donne_type(nx) == donne_type(ny) {
            // i. If nx is a Number, then
            si nx.est_nombre() {
                // 1. Return Number::lessThan(nx, ny).
                retourne normal_completion(Valeur(Boolean = nx.Number < ny.Number))
            }
            // ii. Else,
                // 1. Assert: nx is a BigInt.
                // 2. Return BigInt::lessThan(nx, ny).
            panique("is_less_than non-impl√©ment√© pour bigint < bigint")
        }

        // g. Assert: nx is a BigInt and ny is a Number, or nx is a Number and ny is a BigInt.
        // h. If nx or ny is NaN, return undefined.
        // i. If nx is -‚àûùîΩ or ny is +‚àûùîΩ, return true.
        // j. If nx is +‚àûùîΩ or ny is -‚àûùîΩ, return false.
        // k. If ‚Ñù(nx) < ‚Ñù(ny), return true; otherwise return false.
        panique("is_less_than non-impl√©ment√© pour bigint|number < bigint|number")
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NumericLiteral
 * \{ */

NumericLiteral :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_numeric_literal

    valeur: r64
    // raw: ECMAString
}

cr√©e_literal :: fonc (valeur: r64) -> *NumericLiteral
{
    r√©sultat := loge(NumericLiteral)
    r√©sultat.valeur = valeur
    retourne r√©sultat
}

sur_ex√©cution_numeric_literal :: fonc (base: *NoeudSyntaxique, interpr√©teuse: *Interpr√©teuse @inutilis√©e) -> CompletionRecord
{
    noeud := base comme *NumericLiteral
    retourne normal_completion(Valeur(Number = noeud.valeur))
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom BooleanLiteral
 * \{ */

BooleanLiteral :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_boolean_literal

    valeur: bool
}

cr√©e_boolean_literal :: fonc (valeur: bool) -> *BooleanLiteral
{
    r√©sultat := loge(BooleanLiteral)
    r√©sultat.valeur = valeur
    retourne r√©sultat
}

sur_ex√©cution_boolean_literal :: fonc (base: *NoeudSyntaxique, interpr√©teuse: *Interpr√©teuse @inutilis√©e) -> CompletionRecord
{
    noeud := base comme *BooleanLiteral
    retourne normal_completion(Valeur(Boolean = noeud.valeur))
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom NullLiteral
 * \{ */

NullLiteral :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_null_literal
}

cr√©e_null_literal :: fonc () -> *NullLiteral
{
    r√©sultat := loge(NullLiteral)
    retourne r√©sultat
}

sur_ex√©cution_null_literal :: fonc (base: *NoeudSyntaxique @inutilis√©e, interpr√©teuse: *Interpr√©teuse @inutilis√©e) -> CompletionRecord
{
    retourne normal_completion(js_null)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom StringLiteral
 * \{ */

StringLiteral :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_string_literal

    valeur: ECMAString
    index_chaine : z64 = -1
}

cr√©e_literal :: fonc (valeur: ECMAString) -> *StringLiteral
{
    r√©sultat := loge(StringLiteral)
    r√©sultat.valeur = valeur
    retourne r√©sultat
}

cr√©e_literal :: fonc (valeur: chaine) -> *StringLiteral
{
    retourne cr√©e_literal(cr√©e_chaine_utf16_unique(valeur))
}

sur_ex√©cution_string_literal :: fonc (base: *NoeudSyntaxique, interpr√©teuse: *Interpr√©teuse) -> CompletionRecord
{
    noeud := base comme *StringLiteral

    realm := interpr√©teuse.donne_realm()

    chn: *PrimitiveChaine
    si noeud.index_chaine == -1 {
        chn = cr√©e_chaine(interpr√©teuse.donne_tas_de_m√©moire(), noeud.valeur)
        tableau_ajoute(*realm.chaines_litt√©rales, chn)
        noeud.index_chaine = realm.chaines_litt√©rales.taille - 1
    }
    sinon {
        chn = realm.chaines_litt√©rales[noeud.index_chaine]
    }

    retourne normal_completion(chn)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ExpressionStatement
 * \{ */

ExpressionStatement :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_expression_statement

    expression: *NoeudSyntaxique
}

cr√©e_expression_statement :: fonc (expression: *NoeudSyntaxique) -> *NoeudSyntaxique
{
    r√©sultat := loge(ExpressionStatement)
    r√©sultat.expression = expression
    retourne r√©sultat
}

sur_ex√©cution_expression_statement :: fonc (base: *NoeudSyntaxique, interpr√©teuse: *Interpr√©teuse) -> CompletionRecord
{
    noeud := base comme *ExpressionStatement
    si noeud.expression {
        retourne ex√©cute_noeud(noeud.expression, interpr√©teuse)
    }
    retourne normal_completion(js_undefined)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom CallExpression
 * \{ */

CallExpression :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_call_expression

    appel√©: *NoeudSyntaxique
    arguments: [..]*NoeudSyntaxique
}

cr√©e_call_expression :: fonc (appel√©: *NoeudSyntaxique, arguments: ...*NoeudSyntaxique) -> *CallExpression
{
    r√©sultat := loge(CallExpression)
    r√©sultat.appel√© = appel√©
    pour arguments {
        tableau_ajoute(*r√©sultat.arguments, it)
    }
    retourne r√©sultat
}

/* 13.3.6 Function Calls
 * https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-function-calls-runtime-semantics-evaluation */
sur_ex√©cution_call_expression :: fonc (base: *NoeudSyntaxique, interpr√©teuse: *Interpr√©teuse) -> CompletionRecord
{
    // √Ä FAIRE : CoverCallExpressionAndAsyncArrowHead

    // CallExpression : CallExpression Arguments

    noeud := base comme *CallExpression

    // 1. Let ref be ? Evaluation of CallExpression.
    completion_ref := ex√©cute_noeud(noeud.appel√©, interpr√©teuse)
    saufsi completion_ref.est_normal() {
        retourne completion_ref
    }

    ref := completion_ref.valeur

    // 2. Let func be ? GetValue(ref).
    compl√©tion_func := get_value(interpr√©teuse, ref)
    saufsi compl√©tion_func.est_normal() {
        retourne compl√©tion_func
    }

    func := compl√©tion_func.valeur.V

    // 3. Let thisCall be this CallExpression.
    // this_call := noeud

    // √Ä FAIRE 4. Let tailCall be IsInTailPosition(thisCall).
    tail_call := faux

    // 5. Return ? EvaluateCall(func, ref, Arguments, tailCall).
    retourne evaluate_call(interpr√©teuse, func, ref, noeud.arguments, tail_call)
}

/* 13.3.6.2 EvaluateCall ( func, ref, arguments, tailPosition )
 * https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-evaluatecall */
evaluate_call :: fonc (interpr√©teuse: *Interpr√©teuse, func: Valeur, ref: ValeurCompletion, arguments: [..]*NoeudSyntaxique, tail_position: bool) -> CompletionRecord
{
    this_value: Valeur = ---
    // 1. If ref is a Reference Record, then
    si est_reference_record(ref) {
        // a. If IsPropertyReference(ref) is true, then
        si est_r√©f√©rence_propri√©t√©(ref) {
            // i. Let thisValue be GetThisValue(ref).
            this_value = get_this_value(ref.R)
        }
        // b. Else,
        sinon {
            // i. Let refEnv be ref.[[Base]].
            ref_env := ref.R.base.E
            // ii. Assert: refEnv is an Environment Record.
            // iii. Let thisValue be refEnv.WithBaseObject().
            this_value = ref_env.with_base_object()
        }
    }
    // 2. Else,
    sinon {
        // a. Let thisValue be undefined.
        this_value = js_undefined
    }

    // 3. Let argList be ? ArgumentListEvaluation of arguments.
    // √Ä FAIRE : fuite de m√©moire
    arg_list: [..]Valeur

    pour arguments {
        compl√©tion_arg := ex√©cute_noeud(it, interpr√©teuse)
        saufsi compl√©tion_arg.est_normal() {
            d√©loge(arg_list)
            retourne compl√©tion_arg
        }
        compl√©tion_valeur := get_value(interpr√©teuse, compl√©tion_arg.valeur)
        saufsi compl√©tion_valeur.est_normal() {
            d√©loge(arg_list)
            retourne compl√©tion_valeur
        }
        valeur_arg := compl√©tion_valeur.valeur.V
        tableau_ajoute(*arg_list, valeur_arg)
    }

    // 4. If func is not an Object, throw a TypeError exception.
    saufsi func.est_object() {
        message := imprime_chaine("'%' is not an Object", func)
        retourne lance_type_error(interpr√©teuse, message)
    }
    
    // 5. If IsCallable(func) is false, throw a TypeError exception.
    saufsi func.is_callable() {
        message := imprime_chaine("'%' is not callable", func)
        retourne lance_type_error(interpr√©teuse, message)
    }

    // 6. If tailPosition is true, perform PrepareForTailCall().
    si tail_position {
        panique("tail position non-impl√©met√©")
    }

    // 7. Return ? Call(func, thisValue, argList).
    retourne call(interpr√©teuse, func, this_value, arg_list)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom AssignmentExpression
 * \{ */

AssignmentOperation :: √©num {
    Assigne /* = */
    Ajoute /* += */
    Soustrait /* -= */
    // √Ä FAIRE : Exponentiation /* **= */
    Multiplie /* *= */
    Divise /* /= */
    Modulo /* %= */
    D√©calageGauche /* <<= */
    D√©calageDroite /* >>= */
    // √Ä FAIRE : D√©calageDroiteNaturel /* >>>= */
    EtBinaire /* &= */
    OuBinaire /* |= */
    OuExBinaire /* ^= */
}

AssignmentExpression :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_assignment_expression

    op√©ration: AssignmentOperation
    gauche: *NoeudSyntaxique
    droite: *NoeudSyntaxique
}

cr√©e_assignment_expression :: fonc (op√©ration: AssignmentOperation, gauche: *NoeudSyntaxique, droite: *NoeudSyntaxique) -> *AssignmentExpression
{
    r√©sultat := loge(AssignmentExpression)
    r√©sultat.op√©ration = op√©ration
    r√©sultat.gauche = gauche
    r√©sultat.droite = droite
    retourne r√©sultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-assignment-operators-runtime-semantics-evaluation */
sur_ex√©cution_assignment_expression :: fonc (base: *NoeudSyntaxique, interpr√©teuse: *Interpr√©teuse) -> CompletionRecord
{
    noeud := base comme *AssignmentExpression
    si noeud.op√©ration == AssignmentOperation.Assigne {
        retourne √©value_assignement_simple(noeud, interpr√©teuse)
    }
    retourne √©value_assignement_op√©r√©(noeud, interpr√©teuse)
}

√©value_assignement_simple :: fonc (noeud: *AssignmentExpression, interpr√©teuse: *Interpr√©teuse) -> CompletionRecord
{
    // 1. If LeftHandSideExpression is neither an ObjectLiteral nor an ArrayLiteral, then
    si noeud.gauche.type != ObjectExpression && noeud.gauche.type != ArrayLiteral {
        // a. Let lref be ? Evaluation of LeftHandSideExpression.
        completion_lref := ex√©cute_noeud(noeud.gauche, interpr√©teuse)
        saufsi completion_lref.est_normal() {
            retourne completion_lref
        }
        lref := completion_lref.valeur

        rval: Valeur
        // b. If IsAnonymousFunctionDefinition(AssignmentExpression) is true and IsIdentifierRef of LeftHandSideExpression is true, then
        si is_anonymous_function_definition(noeud.droite) && is_identifier_ref(noeud.gauche) {
            // i. Let lhs be the StringValue of LeftHandSideExpression.
            lhs := (noeud.gauche comme *Identifier).nom

            // ii. Let rval be ? NamedEvaluation of AssignmentExpression with argument lhs.
            completion_rval := named_evaluation(interpr√©teuse, noeud.droite, lhs)
            saufsi completion_rval.est_normal() {
                retourne completion_rval
            }

            rval = completion_rval.valeur.V
        }
        // c. Else,
        sinon {
            // i. Let rref be ? Evaluation of AssignmentExpression.
            completion_rref := ex√©cute_noeud(noeud.droite, interpr√©teuse)
            saufsi completion_rref.est_normal() {
                retourne completion_rref
            }
            rref := completion_rref.valeur

            // ii. Let rval be ? GetValue(rref).
            completion_rval := get_value(interpr√©teuse, rref)
            saufsi completion_rval.est_normal() {
                retourne completion_rval
            }
            rval = completion_rval.valeur.V
        }

        // d. Perform ? PutValue(lref, rval).
        completion_assignment := put_value(interpr√©teuse, lref, rval)
        saufsi completion_assignment.est_normal() {
            retourne completion_assignment
        }

        // e. Return rval.
        retourne normal_completion(rval)
    }

    panique("assignement expression non-impl√©ment√©")
    // 2. Let assignmentPattern be the AssignmentPattern that is covered by LeftHandSideExpression.
    // 3. Let rref be ? Evaluation of AssignmentExpression.
    // 4. Let rval be ? GetValue(rref).
    // 5. Perform ? DestructuringAssignmentEvaluation of assignmentPattern with argument rval.
    // 6. Return rval.
}

√©value_assignement_op√©r√© :: fonc (noeud: *AssignmentExpression, interpr√©teuse: *Interpr√©teuse) -> CompletionRecord
{
    // 1. Let lref be ? Evaluation of LeftHandSideExpression.
    completion_lref := ex√©cute_noeud(noeud.gauche, interpr√©teuse)
    saufsi completion_lref.est_normal() {
        retourne completion_lref
    }
    lref := completion_lref.valeur

    // 2. Let lval be ? GetValue(lref).
    completion_lval := get_value(interpr√©teuse, lref)
    saufsi completion_lval.est_normal() {
        retourne completion_lval
    }
    lval := completion_lval.valeur.V

    // 3. Let rref be ? Evaluation of AssignmentExpression.
    completion_rref := ex√©cute_noeud(noeud.droite, interpr√©teuse)
    saufsi completion_rref.est_normal() {
        retourne completion_rref
    }
    rref := completion_rref.valeur

    // 4. Let rval be ? GetValue(rref).
    completion_rval := get_value(interpr√©teuse, rref)
    saufsi completion_rval.est_normal() {
        retourne completion_rval
    }
    rval := completion_rval.valeur.V

    // 5. Let assignmentOpText be the source text matched by AssignmentOperator.
    // 6. Let opText be the sequence of Unicode code points associated with assignmentOpText in the following table:
    op√©rateur_binaire: BinaryOperation
    discr noeud.op√©ration {
        Assigne {
            panique("Assignement op√©r√© via '=' qui devrait √™tre un chemin diff√©rent.")
        }
        Ajoute {
            op√©rateur_binaire = BinaryOperation.Plus
        }
        Soustrait {
            op√©rateur_binaire = BinaryOperation.Moins
        }
        Multiplie {
            op√©rateur_binaire = BinaryOperation.Multiplie
        }
        Divise {
            op√©rateur_binaire = BinaryOperation.Divise
        }
        Modulo {
            panique("%= non-impl√©ment√©")
        }
        D√©calageGauche {
            panique("<<= non-impl√©ment√©")
        }
        D√©calageDroite {
            panique(">>= non-impl√©ment√©")
        }
        EtBinaire {
            panique("&= non-impl√©ment√©")
        }
        OuBinaire {
            panique("|= non-impl√©ment√©")
        }
        OuExBinaire {
            panique("^= non-impl√©ment√©")
        }
    }

    // 7. Let r be ? ApplyStringOrNumericBinaryOperator(lval, opText, rval).
    completion := apply_string_or_numeric_binary_operator(interpr√©teuse, op√©rateur_binaire, lval, rval)
    saufsi completion.est_normal() {
        retourne completion
    }
    r := completion.valeur.V

    // 8. Perform ? PutValue(lref, r).
    completion_assignment := put_value(interpr√©teuse, lref, r)
    saufsi completion_assignment.est_normal() {
        retourne completion_assignment
    }

    // 9. Return r.
    retourne normal_completion(r)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom VariableDeclaration
 * \{ */

VariableDeclarationKind :: √©num {
    Const
    Let
    Var
}

VariableDeclaration :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_variable_declaration

    nature: VariableDeclarationKind
    expressions: [..]*NoeudSyntaxique
}

cr√©e_variable_declaration :: fonc (nature: VariableDeclarationKind, expressions: ...*NoeudSyntaxique) -> *VariableDeclaration
{
    r√©sultat := loge(VariableDeclaration)
    r√©sultat.nature = nature
    pour expressions {
        tableau_ajoute(*r√©sultat.expressions, it)
    }
    retourne r√©sultat
}

sur_ex√©cution_variable_declaration :: fonc (base: *NoeudSyntaxique, interpr√©teuse: *Interpr√©teuse) -> CompletionRecord
{
    noeud := base comme *VariableDeclaration
    
    derni√®re_valeur := normal_completion(js_undefined)

    /* √Ä FAIRE : diff√©rence entre let et var. */
    pour noeud.expressions {
        derni√®re_valeur = ex√©cute_noeud(it, interpr√©teuse)
    }

    retourne derni√®re_valeur
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom VariableDeclarator
 * \{ */

VariableDeclarator :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_variable_declarator

    id: *NoeudSyntaxique
    init: *NoeudSyntaxique
}

cr√©e_variable_declarator :: fonc (id: *NoeudSyntaxique, init: *NoeudSyntaxique) -> *VariableDeclarator
{
    r√©sultat := loge(VariableDeclarator)
    r√©sultat.id = id
    r√©sultat.init = init
    retourne r√©sultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-variable-statement */
sur_ex√©cution_variable_declarator :: fonc (base: *NoeudSyntaxique, interpr√©teuse: *Interpr√©teuse) -> CompletionRecord
{
    noeud := base comme *VariableDeclarator
    assert(noeud.id.type == Identifier)
    identifier := noeud.id comme *Identifier

    // √Ä FAIRE : cas sans init
    assert(noeud.init != nul)

    // 1. Let bindingId be the StringValue of BindingIdentifier.
    binding_id := identifier.nom

    // 2. Let lhs be ? ResolveBinding(bindingId).
    completion_lhs := interpr√©teuse.resolve_binding(binding_id)
    saufsi completion_lhs.est_normal() {
        retourne completion_lhs
    }
    lhs := completion_lhs.valeur

    valeur := js_undefined
    // 3. If IsAnonymousFunctionDefinition(Initializer) is true, then
    si is_anonymous_function_definition(noeud.init) {
        // a. Let value be ? NamedEvaluation of Initializer with argument bindingId.
        panique("init avec is_anonymous_function non-impl√©ment√©")
    }
    // 4. Else,
    sinon {
        // a. Let rhs be ? Evaluation of Initializer.
        completion_valeur := ex√©cute_noeud(noeud.init, interpr√©teuse)
        saufsi completion_valeur.est_normal() {
            retourne completion_valeur
        }
        // b. Let value be ? GetValue(rhs).
        valeur_compl√©tion := get_value(interpr√©teuse, completion_valeur.valeur)
        saufsi valeur_compl√©tion.est_normal() {
            retourne valeur_compl√©tion
        }
        valeur = valeur_compl√©tion.valeur.V
    }

    // 5. Perform ? PutValue(lhs, value).
    completion_put_value := put_value(interpr√©teuse, lhs, valeur)
    saufsi completion_put_value.est_normal() {
        retourne completion_put_value
    }

    // 6. Return EMPTY.
    retourne normal_completion(js_undefined)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom PropertyDefinition
 * \{ */

PropertyDefinition :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure

    property_name: *NoeudSyntaxique
    expression: *NoeudSyntaxique
}

cr√©e_property_definition :: fonc (property_name: *NoeudSyntaxique, expression: *NoeudSyntaxique) -> *PropertyDefinition
{
    r√©sultat := loge(PropertyDefinition)
    r√©sultat.property_name = property_name
    r√©sultat.expression = expression
    retourne r√©sultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ObjectExpression
 * \{ */

ObjectExpression :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_object_expression

    properties: [..]*PropertyDefinition
}

cr√©e_object_expression :: fonc (properties: [..]*PropertyDefinition) -> *ObjectExpression
{
    r√©sultat := loge(ObjectExpression)
    r√©sultat.properties = properties
    retourne r√©sultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-object-initializer-runtime-semantics-evaluation */
sur_ex√©cution_object_expression :: fonc (base: *NoeudSyntaxique, interpr√©teuse: *Interpr√©teuse) -> CompletionRecord
{
    noeud := base comme *ObjectExpression

    // √Ä FAIRE : 1. Let obj be OrdinaryObjectCreate(%Object.prototype%).
    objet := cr√©e_objet(interpr√©teuse.donne_tas_de_m√©moire(), interpr√©teuse.donne_realm().intrinsics.object_prototype)

    // 2. Perform ? PropertyDefinitionEvaluation of PropertyDefinitionList with argument obj.
    completion := property_definition_evaluation(interpr√©teuse, noeud.properties, objet)
    saufsi completion.est_normal() {
        retourne completion
    }

    // 3. Return obj.
    retourne normal_completion(Valeur(Object = objet))
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-runtime-semantics-propertydefinitionevaluation */
property_definition_evaluation :: fonc (interpr√©teuse: *Interpr√©teuse, properties: []*PropertyDefinition, object: *Object) -> CompletionRecord
{
    pour properties {
        // 1. Let propKey be ? Evaluation of PropertyName.
        assert(it.property_name.type == Identifier)
        prop_key := (it.property_name comme *Identifier).nom

        // √Ä FAIRE : compl√®te
        is_proto_setter := faux
        // 2. If this PropertyDefinition is contained within a Script that is being evaluated for JSON.parse (see step 7 of JSON.parse), then
            // a. Let isProtoSetter be false.
        // 3. Else if propKey is "__proto__" and IsComputedPropertyKey of PropertyName is false, then
            // a. Let isProtoSetter be true.
        // 4. Else,
            // a. Let isProtoSetter be false.
        // 5. If IsAnonymousFunctionDefinition(AssignmentExpression) is true and isProtoSetter is false, then
        prop_value: Valeur
        si is_anonymous_function_definition(it.expression) && is_proto_setter == faux {
            // a. Let propValue be ? NamedEvaluation of AssignmentExpression with argument propKey.
            completion := named_evaluation(interpr√©teuse, it.expression, prop_key)
            saufsi completion.est_normal() {
                retourne completion
            }

            prop_value = completion.valeur.V
        }
        // 6. Else,
        sinon {
            // a. Let exprValueRef be ? Evaluation of AssignmentExpression.
            completion := ex√©cute_noeud(it.expression, interpr√©teuse)
            saufsi completion.est_normal() {
                retourne completion
            }
            expr_value_ref := completion.valeur
            // b. Let propValue be ? GetValue(exprValueRef).
            completion = get_value(interpr√©teuse, expr_value_ref)
            saufsi completion.est_normal() {
                retourne completion
            }
            prop_value = completion.valeur.V
        }
        // 7. If isProtoSetter is true, then
            // a. If propValue is an Object or propValue is null, then
                // i. Perform ! object.[[SetPrototypeOf]](propValue).
            // b. Return UNUSED.
        // 8. Assert: object is an ordinary, extensible object with no non-configurable properties.
        // 9. Perform ! CreateDataPropertyOrThrow(object, propKey, propValue).
        _ := create_data_property_or_throw(object, prop_key, prop_value)
        // 10. Return UNUSED.
    }

    retourne normal_completion(js_undefined)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ArrayLiteral
 * \{ */

ArrayLiteral :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_array_literal

    √©l√©ments: [..]*NoeudSyntaxique
}

cr√©e_array_literal :: fonc (√©l√©ments: [..]*NoeudSyntaxique) -> *ArrayLiteral
{
    r√©sultat := loge(ArrayLiteral)
    r√©sultat.√©l√©ments = √©l√©ments
    retourne r√©sultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-runtime-semantics-arrayaccumulation */
sur_ex√©cution_array_literal :: fonc (base: *NoeudSyntaxique, interpr√©teuse: *Interpr√©teuse) -> CompletionRecord
{
    /* √Ä FAIRE : standardise. */
    noeud := base comme *ArrayLiteral

    realm := interpr√©teuse.donne_realm()

    r√©sultat := cr√©e_array(realm.donne_tas_de_m√©moire(), realm.intrinsics.array_prototype, 0)

    pour noeud.√©l√©ments {
        completion := ex√©cute_noeud(it, interpr√©teuse)
        saufsi completion.est_normal() {
            retourne completion
        }
        completion = get_value(interpr√©teuse, completion.valeur)
        saufsi completion.est_normal() {
            retourne completion
        }
        valeur := completion.valeur.V

        nom_propri√©t√© := vers_chaine(interpr√©teuse, Valeur(Number = index_it comme r64)).valeur.V.String.texte

        _ := create_data_property(r√©sultat, nom_propri√©t√©, valeur)
    }

    completion := set(r√©sultat, STR_length, Valeur(Number = noeud.√©l√©ments.taille comme r64), vrai)
    saufsi completion.est_normal() {
        retourne completion
    }

    retourne normal_completion(Valeur(Object = r√©sultat))
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ObjectExpression
 * \{ */

MemberExpression :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_member_expression

    objet: *NoeudSyntaxique
    propri√©t√©: *NoeudSyntaxique
    calcul√© := faux
}

cr√©e_member_expression :: fonc (objet: *NoeudSyntaxique, propri√©t√©: *NoeudSyntaxique, calcul√©: bool) -> *MemberExpression
{
    r√©sultat := loge(MemberExpression)
    r√©sultat.objet = objet
    r√©sultat.propri√©t√© = propri√©t√©
    r√©sultat.calcul√© = calcul√©
    retourne r√©sultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-property-accessors-runtime-semantics-evaluation */
sur_ex√©cution_member_expression :: fonc (base: *NoeudSyntaxique, interpr√©teuse: *Interpr√©teuse) -> CompletionRecord
{
    membre := base comme *MemberExpression

    // 1. Let baseReference be ? Evaluation of MemberExpression.
    completion_base_reference := ex√©cute_noeud(membre.objet, interpr√©teuse)
    saufsi completion_base_reference.est_normal() {
        retourne completion_base_reference
    }
    base_reference := completion_base_reference.valeur

    // 2. Let baseValue be ? GetValue(baseReference).
    valeur_base_reference := get_value(interpr√©teuse, base_reference)
    saufsi valeur_base_reference.est_normal() {
        retourne valeur_base_reference
    }
    base_value := valeur_base_reference.valeur.V

    // 3. Let strict be IsStrict(this MemberExpression).
    strict := is_strict(membre)

    si membre.calcul√© {
        // MemberExpression : MemberExpression [ Expression ]
        retourne evaluate_property_access_with_expression_key(interpr√©teuse, base_value, membre.propri√©t√©, strict)
    }

    // MemberExpression : MemberExpression . IdentifierName
    assert(membre.propri√©t√©.type == Identifier)
    identifier := membre.propri√©t√© comme *Identifier

    retourne evaluate_property_access_with_identifier_key(interpr√©teuse, base_value, identifier, strict)
}

/* 13.3.3 EvaluatePropertyAccessWithExpressionKey ( baseValue, expression, strict )
 * https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-evaluate-property-access-with-expression-key */
evaluate_property_access_with_expression_key :: fonc (interpr√©teuse: *Interpr√©teuse, base_value: Valeur, expression: *NoeudSyntaxique, strict: bool) -> CompletionRecord
{
    // 1. Let propertyNameReference be ? Evaluation of expression.
    completion_expression := ex√©cute_noeud(expression, interpr√©teuse)
    saufsi completion_expression.est_normal() {
        retourne completion_expression
    }
    property_name_reference := completion_expression.valeur

    // 2. Let propertyNameValue be ? GetValue(propertyNameReference).
    completion_value := get_value(interpr√©teuse, property_name_reference)
    saufsi completion_value.est_normal() {
        retourne completion_value
    }
    property_name_value := completion_value.valeur.V

    // 3. NOTE: In most cases, ToPropertyKey will be performed on propertyNameValue
    //    immediately after this step. However, in the case of a[b] = c, it will
    //    not be performed until after evaluation of c.

    // 4. Return the Reference Record { [[Base]]: baseValue, [[ReferencedName]]: propertyNameValue, [[Strict]]: strict, [[ThisValue]]: EMPTY }.
    r√©sultat: ReferenceRecord
    r√©sultat.base = base_value
    r√©sultat.referenced_name = property_name_value
    r√©sultat.strict = strict
    retourne normal_completion(r√©sultat)
}

/* 13.3.4 EvaluatePropertyAccessWithIdentifierKey ( baseValue, identifierName, strict )
 * https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-evaluate-property-access-with-identifier-key */
evaluate_property_access_with_identifier_key :: fonc (interpr√©teuse: *Interpr√©teuse, base_value: Valeur, identifier_name: *Identifier, strict: bool) -> CompletionRecord
{
    // 1. Let propertyNameString be the StringValue of identifierName.
    property_name_string := cr√©e_chaine(interpr√©teuse.donne_tas_de_m√©moire(), identifier_name.nom)

    // 2. Return the Reference Record { [[Base]]: baseValue, [[ReferencedName]]: propertyNameString, [[Strict]]: strict, [[ThisValue]]: EMPTY }.
    r√©sultat: ReferenceRecord
    r√©sultat.base = base_value
    r√©sultat.referenced_name = Valeur(String = property_name_string)
    r√©sultat.strict = strict
    retourne normal_completion(r√©sultat)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom UpdateExpression
 * \{ */

UpdateOperation :: √©num {
    Increment
    Decrement
}

UpdateExpression :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_update_expression

    argument: *NoeudSyntaxique
    operation: UpdateOperation
}

cr√©e_update_expression :: fonc (argument: *NoeudSyntaxique, operation: UpdateOperation) -> *UpdateExpression
{
    r√©sultat := loge(UpdateExpression)
    r√©sultat.argument = argument
    r√©sultat.operation = operation
    retourne r√©sultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-postfix-increment-operator */
sur_ex√©cution_update_expression :: fonc (base: *NoeudSyntaxique, interpr√©teuse: *Interpr√©teuse) -> CompletionRecord
{
    update := base comme *UpdateExpression
    assert(update.argument.type == Identifier)

    // 1. Let lhs be ? Evaluation of LeftHandSideExpression.
    compl√©tion_lhs := ex√©cute_noeud(update.argument, interpr√©teuse)
    saufsi compl√©tion_lhs.est_normal() {
        retourne compl√©tion_lhs
    }
    lhs := compl√©tion_lhs.valeur

    // 2. Let oldValue be ? ToNumeric(? GetValue(lhs)).
    lhs_value := get_value(interpr√©teuse, lhs)
    saufsi lhs_value.est_normal() {
        retourne lhs_value
    }

    compl√©tion_old_value := to_numeric(interpr√©teuse, lhs_value.valeur.V)
    saufsi compl√©tion_old_value.est_normal() {
        retourne compl√©tion_old_value
    }
    old_value := compl√©tion_old_value.valeur.V

    nouvelle_valeur: Valeur

    // 3. If oldValue is a Number, then
    si est_nombre(old_value) {
        // a. Let newValue be Number::add(oldValue, 1ùîΩ).
        // NOTE : nous faison ++ et -- directement.
        si update.operation == UpdateOperation.Increment {
            nouvelle_valeur = ajoute_valeurs(old_value, Valeur(Number = 1))
        }
        sinon {
            nouvelle_valeur = soustrait_valeurs(old_value, Valeur(Number = 1))
        }
    }
    // 4. Else,
    sinon {
        // a. Assert: oldValue is a BigInt.
        // b. Let newValue be BigInt::add(oldValue, 1‚Ñ§).
        panique("update expression sur BigInt non-impl√©ment√©e")
    }

    // 5. Perform ? PutValue(lhs, newValue).
    compl√©tion_update := put_value(interpr√©teuse, lhs, nouvelle_valeur)
    saufsi compl√©tion_update.est_normal() {
        retourne compl√©tion_update
    }

    // 6. Return oldValue.
    retourne normal_completion(old_value)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ForStatement
 * \{ */

ForStatement :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_for_statement

    init: *NoeudSyntaxique
    test: *NoeudSyntaxique
    update: *NoeudSyntaxique
    body: *NoeudSyntaxique
}

cr√©e_for_statement :: fonc (init: *NoeudSyntaxique, test: *NoeudSyntaxique, update: *NoeudSyntaxique, body: *NoeudSyntaxique) -> *ForStatement
{
    r√©sultat := loge(ForStatement)
    r√©sultat.init = init
    r√©sultat.test = test
    r√©sultat.update = update
    r√©sultat.body = body
    retourne r√©sultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-for-statement */
sur_ex√©cution_for_statement :: fonc (base: *NoeudSyntaxique, interpr√©teuse: *Interpr√©teuse) -> CompletionRecord
{
    for := base comme *ForStatement

    si for.init {
        doit_continuer := ex√©cute_noeud(for.init, interpr√©teuse)
        saufsi doit_continuer.est_normal() {
            retourne doit_continuer
        }
    }

    boucle {
        si for.test {
            doit_continuer := ex√©cute_noeud(for.test, interpr√©teuse)
            saufsi doit_continuer.est_normal() {
                retourne doit_continuer
            }
            valeur_compl√©tion := get_value(interpr√©teuse, doit_continuer.valeur)
            saufsi valeur_compl√©tion.est_normal() {
                retourne valeur_compl√©tion
            }

            valeur := to_boolean(valeur_compl√©tion.valeur.V)
            si valeur.est_false() {
                arr√™te
            }
        }

        doit_continuer := ex√©cute_noeud(for.body, interpr√©teuse)
        saufsi doit_continuer.est_normal() {
            retourne doit_continuer
        }

        si for.update {
            doit_continuer = ex√©cute_noeud(for.update, interpr√©teuse)
            saufsi doit_continuer.est_normal() {
                retourne doit_continuer
            }
        }
    }

    retourne normal_completion(js_undefined)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ForOfStatement
 * \{ */

ForOfStatement :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_for_of_statement

    left: *NoeudSyntaxique
    right: *NoeudSyntaxique
    body: *NoeudSyntaxique
}

cr√©e_for_of_statement :: fonc (left: *NoeudSyntaxique, right: *NoeudSyntaxique, body: *NoeudSyntaxique) -> *ForOfStatement
{
    r√©sultat := loge(ForOfStatement)
    r√©sultat.left = left
    r√©sultat.right = right
    r√©sultat.body = body
    retourne r√©sultat
}

sur_ex√©cution_for_of_statement :: fonc (base: *NoeudSyntaxique @inutilis√©e, interpr√©teuse: *Interpr√©teuse @inutilis√©e) -> CompletionRecord
{
    retourne normal_completion(js_undefined)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ForInStatement
 * \{ */

ForInStatement :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_for_in_statement

    left: *NoeudSyntaxique
    right: *NoeudSyntaxique
    body: *NoeudSyntaxique
}

cr√©e_for_in_statement :: fonc (left: *NoeudSyntaxique, right: *NoeudSyntaxique, body: *NoeudSyntaxique) -> *ForInStatement
{
    r√©sultat := loge(ForInStatement)
    r√©sultat.left = left
    r√©sultat.right = right
    r√©sultat.body = body
    retourne r√©sultat
}

sur_ex√©cution_for_in_statement :: fonc (base: *NoeudSyntaxique @inutilis√©e, interpr√©teuse: *Interpr√©teuse @inutilis√©e) -> CompletionRecord
{
    retourne normal_completion(js_undefined)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom IfStatement
 * \{ */

IfStatement :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_if_statement

    test: *NoeudSyntaxique
    consequent: *NoeudSyntaxique
    alternate: *NoeudSyntaxique
}

cr√©e_if_statement :: fonc (test: *NoeudSyntaxique, consequent: *NoeudSyntaxique, alternate: *NoeudSyntaxique) -> *IfStatement
{
    r√©sultat := loge(IfStatement)
    r√©sultat.test = test
    r√©sultat.consequent = consequent
    r√©sultat.alternate = alternate
    retourne r√©sultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-if-statement */
sur_ex√©cution_if_statement :: fonc (base: *NoeudSyntaxique, interpr√©teuse: *Interpr√©teuse) -> CompletionRecord
{
    if := base comme *IfStatement

    // 1. Let exprRef be ? Evaluation of Expression.
    compl√©tion_expr_ref := ex√©cute_noeud(if.test, interpr√©teuse)
    saufsi compl√©tion_expr_ref.est_normal() {
        retourne compl√©tion_expr_ref
    }
    expr_ref := compl√©tion_expr_ref.valeur

    // 2. Let exprValue be ToBoolean(? GetValue(exprRef)).
    compl√©tion_valeur_expr_ref := get_value(interpr√©teuse, expr_ref)
    saufsi compl√©tion_valeur_expr_ref.est_normal() {
        retourne compl√©tion_valeur_expr_ref
    }
    expr_value := to_boolean(compl√©tion_valeur_expr_ref.valeur.V)

    stmt_completion: CompletionRecord

    // 3. If exprValue is true, then
    si expr_value.est_true() {
        // a. Let stmtCompletion be Completion(Evaluation of the first Statement).
        stmt_completion = ex√©cute_noeud(if.consequent, interpr√©teuse)
    }
    // 4. Else,
    sinon {
        si if.alternate == nul {
            /* NOTE : ceci provient du deuxi√®me cas. */
            retourne normal_completion(js_undefined)
        }

        // a. Let stmtCompletion be Completion(Evaluation of the second Statement).
        stmt_completion = ex√©cute_noeud(if.alternate, interpr√©teuse)
    }

    // 5. Return ? UpdateEmpty(stmtCompletion, undefined).
    retourne update_empty(stmt_completion, js_undefined)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom TypeofOperator
 * \{ */

TypeofOperator :: struct {
    empl base: NoeudSyntaxique
    type = #type_de_cette_structure
    sur_ex√©cution = sur_ex√©cution_typeof_operator

    argument: *NoeudSyntaxique
}

cr√©e_typeof_operator :: fonc (argument: *NoeudSyntaxique) -> *TypeofOperator
{
    r√©sultat := loge(TypeofOperator)
    r√©sultat.argument = argument
    retourne r√©sultat
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-typeof-operator-runtime-semantics-evaluation */
sur_ex√©cution_typeof_operator :: fonc (base: *NoeudSyntaxique, interpr√©teuse: *Interpr√©teuse) -> CompletionRecord
{
    typeof := base comme *TypeofOperator

    // 1. Let val be ? Evaluation of UnaryExpression.
    completion_val := ex√©cute_noeud(typeof.argument, interpr√©teuse)
    saufsi completion_val.est_normal() {
        retourne completion_val
    }
    val := completion_val.valeur

    // 2. If val is a Reference Record, then
    si est_reference_record(val) {
        // a. If IsUnresolvableReference(val) is true, return "undefined".
        si est_r√©f√©rence_non_r√©solvable(val) {
            retourne cr√©e_string_value_completion(interpr√©teuse, STR_undefined)
        }
    }

    // 3. Set val to ? GetValue(val).
    completion_valeur := get_value(interpr√©teuse, val)
    saufsi completion_valeur.est_normal() {
        retourne completion_valeur
    }
    valeur := completion_valeur.valeur.V

    // 4. If val is undefined, return "undefined".
    si valeur.est_undefined() {
        retourne cr√©e_string_value_completion(interpr√©teuse, STR_undefined)
    }

    // 5. If val is null, return "object".
    si valeur.est_nulle() {
        retourne cr√©e_string_value_completion(interpr√©teuse, STR_object)
    }

    // 6. If val is a String, return "string".
    si valeur.est_chaine() {
        retourne cr√©e_string_value_completion(interpr√©teuse, STR_string)
    }

    // 7. If val is a Symbol, return "symbol".
    si valeur.est_symbol() {
        retourne cr√©e_string_value_completion(interpr√©teuse, STR_symbol)
    }

    // 8. If val is a Boolean, return "boolean".
    si valeur.est_boolean() {
        retourne cr√©e_string_value_completion(interpr√©teuse, STR_boolean)
    }

    // 9. If val is a Number, return "number".
    si valeur.est_nombre() {
        retourne cr√©e_string_value_completion(interpr√©teuse, STR_number)
    }

    // 10. If val is a BigInt, return "bigint".
    si valeur.est_big_int() {
        retourne cr√©e_string_value_completion(interpr√©teuse, STR_bigint)
    }

    // 11. Assert: val is an Object.
    objet := valeur.donne_objet()

    // √Ä FAIRE : 12. NOTE: This step is replaced in section B.3.6.3.
    // 13. If val has a [[Call]] internal slot, return "function".
    si objet.donne_table().sur_call {
        retourne cr√©e_string_value_completion(interpr√©teuse, STR_function)
    }

    // 14. Return "object".
    retourne cr√©e_string_value_completion(interpr√©teuse, STR_object)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Visiteuse arbre.
 * \{ */

DirectionVisiteNoeud :: √©num {
    PR√â_ORDRE
    POST_ORDRE
}

VisiteuseNoeud :: struct {
    arbre: *NoeudSyntaxique
    rappel_pour_noeud: fonc(*VisiteuseNoeud, *NoeudSyntaxique, *InfoTypeStructure)(rien)
    rappel_pour_tableau: fonc(*VisiteuseNoeud, [..]*NoeudSyntaxique)(rien)
    profondeur: z32
    direction_visite: DirectionVisiteNoeud
}

donne_info_pour_type_noeud :: fonc (racine: *NoeudSyntaxique) -> *InfoTypeStructure
{
    r√©sultat := __table_des_types[racine.type] comme *InfoTypeStructure
    assert(est_struct_ou_employeuse_de(r√©sultat, info_de(NoeudSyntaxique)))
    retourne r√©sultat
}

visite_noeud :: fonc (visiteuse: *VisiteuseNoeud, racine: *NoeudSyntaxique, $Rappel: fonc(*VisiteuseNoeud, *NoeudSyntaxique, *InfoTypeStructure)(rien))
{
    infos := donne_info_pour_type_noeud(racine)
    Rappel(visiteuse, racine, infos)
}

visite_noeud_g√©n√©rique :: fonc (visiteuse: *VisiteuseNoeud, racine: *NoeudSyntaxique, info: *InfoTypeStructure)
{
    si visiteuse.direction_visite == DirectionVisiteNoeud.PR√â_ORDRE && visiteuse.rappel_pour_noeud {
        visiteuse.rappel_pour_noeud(visiteuse, racine, info)
    }

    valeur_eini : eini = ---
    valeur_eini.pointeur = racine
    valeur_eini.info = info

    pour info.membres {
        si it.id == info_de(*NoeudSyntaxique) {
            membre := eini_depuis_info_membre(valeur_eini, it)
            expression := m√©moire(membre.pointeur comme **NoeudSyntaxique)
            si expression == nul {
                continue
            }

            si poss√®de_annotation(it, "NeVisitePas") {
                continue
            }

            visiteuse.profondeur += 1
            visite_noeud(visiteuse, expression, visite_noeud_g√©n√©rique)
            visiteuse.profondeur -= 1
            continue
        }

        si it.id == info_de([..]*NoeudSyntaxique) {
            membre := eini_depuis_info_membre(valeur_eini, it)

            tableau := m√©moire(membre.pointeur comme *[..]*NoeudSyntaxique)

            pour noeud dans tableau {
                visiteuse.profondeur += 1
                visite_noeud(visiteuse, noeud, visite_noeud_g√©n√©rique)
                visiteuse.profondeur -= 1
            }

            si visiteuse.rappel_pour_tableau {
                visiteuse.profondeur += 1
                visiteuse.rappel_pour_tableau(visiteuse, tableau)
                visiteuse.profondeur -= 1
            }

            continue
        }

        si it.id == info_de(NoeudScope) {
            // √Ä FAIRE : assert(est_base)
            scope := racine comme *NoeudScope
            tableau := scope.enfants

            pour noeud dans tableau {
                visiteuse.profondeur += 1
                visite_noeud(visiteuse, noeud, visite_noeud_g√©n√©rique)
                visiteuse.profondeur -= 1
            }

            si visiteuse.rappel_pour_tableau {
                visiteuse.profondeur += 1
                visiteuse.rappel_pour_tableau(visiteuse, tableau)
                visiteuse.profondeur -= 1
            }

            continue
        }
    }

    si visiteuse.direction_visite == DirectionVisiteNoeud.POST_ORDRE && visiteuse.rappel_pour_noeud {
        visiteuse.rappel_pour_noeud(visiteuse, racine, info)
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Impression arbre.
 * \{ */

cr√©e_visiteuse_pour_impression :: fonc (noeud: *NoeudSyntaxique) -> VisiteuseNoeud
{
    rappel_pour_noeud :: fonc (visiteuse: *VisiteuseNoeud, noeud: *NoeudSyntaxique @inutilis√©e, info: *InfoTypeStructure)
    {
        imprime_tabulation(visiteuse.profondeur)
        imprime("%\n", info.nom)
    }

    r√©sultat: VisiteuseNoeud
    r√©sultat.arbre = noeud
    r√©sultat.rappel_pour_noeud = rappel_pour_noeud
    r√©sultat.direction_visite = DirectionVisiteNoeud.PR√â_ORDRE
    retourne r√©sultat
}

imprime_arbre :: fonc (noeud: *NoeudSyntaxique)
{
    visiteuse := cr√©e_visiteuse_pour_impression(noeud)
    visite_noeud(*visiteuse, noeud, visite_noeud_g√©n√©rique)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Destruction arbre.
 * \{ */

cr√©e_visiteuse_pour_destruction :: fonc (noeud: *NoeudSyntaxique) -> VisiteuseNoeud
{
    rappel_pour_noeud :: fonc (visiteuse: *VisiteuseNoeud @inutilis√©e, noeud: *NoeudSyntaxique, info: *InfoTypeStructure)
    {
        d√©loge_m√©moire(info.taille_en_octet comme z64, noeud, info, PositionCodeSource())
    }

    rappel_pour_tableau :: fonc (visiteuse: *VisiteuseNoeud @inutilis√©e, tableau: [..]*NoeudSyntaxique)
    {
        d√©loge(tableau)
    }

    r√©sultat: VisiteuseNoeud
    r√©sultat.arbre = noeud
    r√©sultat.rappel_pour_noeud = rappel_pour_noeud
    r√©sultat.rappel_pour_tableau = rappel_pour_tableau
    r√©sultat.direction_visite = DirectionVisiteNoeud.POST_ORDRE
    retourne r√©sultat
}

d√©truit_arbre :: fonc (noeud: *NoeudSyntaxique)
{
    visiteuse := cr√©e_visiteuse_pour_destruction(noeud)
    visite_noeud(*visiteuse, noeud, visite_noeud_g√©n√©rique)
}

/** \} */
