importe Structures

parse :: fonc (realm: *Realm, source_text: *TexteSource, goal_symbol: GoalSymbol) -> R√©sultat(*NoeudSyntaxique, *SyntaxError)
{
    parseuse: Parseuse
    diff√®re d√©truit_donn√©es_parseuse(*parseuse)

    parseuse.realm = realm
    parseuse.source_text = source_text
    parseuse.lex√®mes = source_text.lex√®mes

    r√©sultat: *NoeudSyntaxique

    discr goal_symbol {
        Script {
            r√©sultat = parse_script(*parseuse)
        }
        StringNumericLiteral {
            /* A StringNumericLiteral that is empty or contains only white space is converted to +0ùîΩ. */
            si source_text.lex√®mes.taille == 0 {
                r√©sultat = cr√©e_literal(*parseuse, nul, 0.0)
            }
            sinon {
                r√©sultat = parse_expression(*parseuse, Param√®tresParsageExpression())
                si r√©sultat.type != NumericLiteral {
                    rapporte_erreur(*parseuse, "expected a numeric literal")
                }
            }
        }
        FunctionBody {
            r√©sultat = parse_function_body(*parseuse, faux)
        }
    }

    si parseuse.erreur_de_compilation {
        d√©truit_arbre(r√©sultat)
        retourne parseuse.erreur_de_compilation
    }

    retourne r√©sultat
}

Parseuse :: struct {
    realm: *Realm
    source_text: *TexteSource
    lex√®mes: [..]Lex√®me
    position := 0
    erreur_de_compilation: *SyntaxError
    erreur_de_compilation_n_est_pas_ignorable: bool
    parent: *Parseuse

    noeuds: [..]*NoeudSyntaxique

    await_est_mot_cl√©: bool
}

cr√©e_noeud :: fonc (parseuse: *Parseuse, lex√®me: *Lex√®me, $T: type_de_donn√©es) -> *T
{
    r√©sultat := loge(T)
    r√©sultat.lex√®me = lex√®me
    tableau_ajoute(*parseuse.noeuds, r√©sultat)
    retourne r√©sultat
}

donne_parseuse_locale :: fonc (parseuse: *Parseuse) -> Parseuse
{
    r√©sultat: Parseuse
    r√©sultat.lex√®mes = parseuse.lex√®mes
    r√©sultat.position = parseuse.position
    r√©sultat.realm = parseuse.realm
    r√©sultat.source_text = parseuse.source_text
    r√©sultat.parent = parseuse
    retourne r√©sultat
}

ajourne_parent :: fonc (parseuse: *Parseuse)
{
    assert(parseuse.parent != nul)
    parseuse.parent.position = parseuse.position
    si parseuse.erreur_de_compilation_n_est_pas_ignorable {
        parseuse.parent.erreur_de_compilation = parseuse.erreur_de_compilation
        parseuse.parent.erreur_de_compilation_n_est_pas_ignorable = vrai
    }
    pour parseuse.noeuds {
        tableau_ajoute(*parseuse.parent.noeuds, it)
    }
    parseuse.noeuds.taille = 0
}

d√©truit_donn√©es_parseuse :: fonc (parseuse: *Parseuse)
{
    // √Ä FAIRE : destruction des noeuds pour les parseuses locales
    d√©loge(parseuse.noeuds)
}

lex√®me_courant :: fonc (parseuse: *Parseuse) -> *Lex√®me
{
    retourne *parseuse.lex√®mes[parseuse.position]
}

fini :: fonc (parseuse: *Parseuse) -> bool
{
    retourne parseuse.erreur_de_compilation != nul || parseuse.position >= parseuse.lex√®mes.taille
}

est_en_fin_de_ligne :: fonc (parseuse: *Parseuse, r√©f√©rence: *Lex√®me) -> bool
{
    lex√®me := parseuse.lex√®me_courant()
    assert(lex√®me != r√©f√©rence)
    assert(lex√®me == r√©f√©rence + 1)

    fin_r√©f√©rence := r√©f√©rence.texte.pointeur + r√©f√©rence.texte.taille
    texte := chaine(fin_r√©f√©rence, lex√®me.texte.pointeur - fin_r√©f√©rence)

    pour texte {
        si it == '\n' {
            retourne vrai
        }
    }
    retourne faux
}

consomme :: fonc (parseuse: *Parseuse)
{
    parseuse.position += 1
}

consomme :: fonc (parseuse: *Parseuse, genre_lex√®me: GenreLex√®me)
{
    saufsi apparie(parseuse, genre_lex√®me) {
        si genre_lex√®me == GenreLex√®me.Parenth√®seOuvrante {
            parseuse.rapporte_erreur("expected a '('")
        }
        sinon si genre_lex√®me == GenreLex√®me.Parenth√®seFermante {
            parseuse.rapporte_erreur("expected a ')'")
        }
        sinon si genre_lex√®me == GenreLex√®me.AccoladeOuvrante {
            parseuse.rapporte_erreur("expected a '{'")
        }
        sinon si genre_lex√®me == GenreLex√®me.AccoladeFermante {
            parseuse.rapporte_erreur("expected a '}'")
        }
        sinon si genre_lex√®me == GenreLex√®me.CrochetOuvrant {
            parseuse.rapporte_erreur("expected a '['")
        }
        sinon si genre_lex√®me == GenreLex√®me.CrochetFermant {
            parseuse.rapporte_erreur("expected a ']'")
        }
        sinon si genre_lex√®me == GenreLex√®me.PointVirgule {
            parseuse.rapporte_erreur("expected a ';'")
        }
        sinon si genre_lex√®me == GenreLex√®me.DoublePoint {
            parseuse.rapporte_erreur("expected a ':'")
        }
        sinon  {
            parseuse.rapporte_erreur("unexpected token")
        }
    }
    parseuse.consomme()
}

consomme_point_virgule_potentiel :: fonc (parseuse: *Parseuse)
{
    si parseuse.apparie(GenreLex√®me.PointVirgule) {
        parseuse.consomme()
    }
}

apparie :: fonc (parseuse: *Parseuse, genre_lex√®me: GenreLex√®me) -> bool
{
    si parseuse.fini() {
        retourne faux
    }
    retourne parseuse.lex√®me_courant().genre == genre_lex√®me
}

parse_script :: fonc (parseuse: *Parseuse) -> *NoeudScript
{
    script_body: *ScriptBody
    statements := parse_statement_list(parseuse)

    si statements.taille != 0 {
        script_body = cr√©e_script_body(parseuse, statements)
    }

    retourne cr√©e_script(parseuse, script_body)
}

parse_statement :: fonc (parseuse: *Parseuse) -> *Statement
{
    si parseuse.fini() {
        rapporte_erreur(parseuse, "unexpected end of input")
        retourne nul
    }

    lex√®me := parseuse.lex√®me_courant()

    discr lex√®me.genre {
        Class {
            retourne parse_class_declaration(parseuse, faux) comme *ClassDeclaration
        }
        Function {
            retourne parse_function_declaration(parseuse, faux)
        }
        Return {
            retourne parse_return_statement(parseuse)
        }
        For {
            retourne parse_for_statement(parseuse)
        }
        While {
            retourne parse_while_statement(parseuse)
        }
        Do {
            retourne parse_do_while_statement(parseuse)
        }
        If {
            retourne parse_if_statement(parseuse)
        }
        Try {
            retourne parse_try_statement(parseuse)
        }
        Throw {
            retourne parse_throw_statement(parseuse)
        }
        Continue {
            retourne parse_continue_statement(parseuse)
        }
        Break {
            retourne parse_break_statement(parseuse)
        }
        Switch {
            retourne parse_switch_statement(parseuse)
        }
        Debugger {
            parseuse.consomme()
            parseuse.consomme_point_virgule_potentiel()
            retourne cr√©e_debugger_statement(parseuse, lex√®me)
        }
        AccoladeOuvrante {
            parseuse.consomme(GenreLex√®me.AccoladeOuvrante)
            statements := parse_statement_list(parseuse)
            parseuse.consomme(GenreLex√®me.AccoladeFermante)
            retourne cr√©e_block_statement(parseuse, lex√®me, statements)
        }
        PointVirgule {
            parseuse.consomme()
            retourne cr√©e_empty_statement(parseuse, lex√®me)
        }
        sinon {
            sauvegarde := parseuse.position
            label_identifier := parse_label_identifier(parseuse, faux)
            si label_identifier {
                si parseuse.apparie(GenreLex√®me.DoublePoint) {
                    parseuse.consomme()

                    statement := parse_statement(parseuse)

                    retourne cr√©e_labelled_statement(parseuse, lex√®me, label_identifier.nom, statement)
                }

                parseuse.position = sauvegarde
            }

            si apparie(parseuse, GenreLex√®me.Async) {
                parseuse.consomme()

                si !est_en_fin_de_ligne(parseuse, lex√®me) && parseuse.apparie(GenreLex√®me.Function) {
                    retourne parse_function_declaration(parseuse, vrai)
                }

                parseuse.position = sauvegarde
            }

            expression := parseuse.parse_expression(Param√®tresParsageExpression())
            parseuse.consomme_point_virgule_potentiel()
            retourne cr√©e_expression_statement(parseuse, lex√®me, expression)
        }
    }

    retourne nul
}

parse_class_declaration :: fonc (parseuse: *Parseuse, pour_expression: bool) -> *NoeudSyntaxique
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()

    id := parse_binding_identifier(parseuse, !pour_expression)

    h√©ritage: *Expression
    si parseuse.apparie(GenreLex√®me.Extends) {
        parseuse.consomme()
        h√©ritage = parse_expression(parseuse, Param√®tresParsageExpression())
    }

    lex√®me_body := parseuse.lex√®me_courant()
    parseuse.consomme(GenreLex√®me.AccoladeOuvrante)

    √©l√©ments: [..]*NoeudSyntaxique

    tantque !fini(parseuse) && !apparie(parseuse, GenreLex√®me.AccoladeFermante) {
        si apparie(parseuse, GenreLex√®me.PointVirgule) {
            lex√®me_expr := parseuse.lex√®me_courant()
            expr := cr√©e_empty_statement(parseuse, lex√®me_expr)
            tableau_ajoute(*√©l√©ments, expr)
            continue
        }

        est_static := faux
        si apparie(parseuse, GenreLex√®me.Static) {
            lex√®me_static := parseuse.lex√®me_courant()
            parseuse.consomme()

            si apparie(parseuse, GenreLex√®me.AccoladeOuvrante) {
                body := parse_function_body(parseuse, faux)
                static_block := cr√©e_class_static_block(parseuse, lex√®me_static, body)
                tableau_ajoute(*√©l√©ments, static_block)
                continue
            }

            est_static = vrai
        }

        parseuse_locale := parseuse.donne_parseuse_locale()

        method := parse_method_definition(*parseuse_locale)

        si parseuse_locale.erreur_de_compilation && parseuse_locale.erreur_de_compilation_n_est_pas_ignorable {
            ajourne_parent(*parseuse_locale)
            d√©truit_donn√©es_parseuse(*parseuse_locale)
            arr√™te
        }

        si method && parseuse_locale.erreur_de_compilation == nul {
            method_typ√©e := method comme *ClassMethod
            method_typ√©e.static = est_static
            ajourne_parent(*parseuse_locale)
            d√©truit_donn√©es_parseuse(*parseuse_locale)
            tableau_ajoute(*√©l√©ments, method)
            continue
        }

        field_name := apparie_class_element_name(parseuse)
        saufsi field_name {
            rapporte_erreur(parseuse, "expected a class field")
            continue
        }

        initializer: *Expression
        si apparie(parseuse, GenreLex√®me.√âgal) {
            parseuse.consomme()
            initializer = parse_expression(parseuse, Param√®tresParsageExpression())
        }

        si apparie(parseuse, GenreLex√®me.PointVirgule) {
            parseuse.consomme()
        }
        
        field := cr√©e_class_field(parseuse, field_name.lex√®me, field_name, initializer, est_static)
        tableau_ajoute(*√©l√©ments, field)
    }

    parseuse.consomme(GenreLex√®me.AccoladeFermante)

    body := cr√©e_class_body(parseuse, lex√®me_body, √©l√©ments)

    si pour_expression {
        retourne cr√©e_class_expression(parseuse, lex√®me, h√©ritage, id, body)
    }

    retourne cr√©e_class_declaration(parseuse, lex√®me, h√©ritage, id, body)
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#prod-MethodDefinition */
parse_method_definition :: fonc (parseuse: *Parseuse) -> *Expression
{
    method_kind := MethodKind.Method

    class_element_name: *Expression
    
    async := faux

    si apparie(parseuse, GenreLex√®me.Get) {
        sauvegarde := parseuse.position
        parseuse.consomme()

        class_element_name = apparie_class_element_name(parseuse)
        si class_element_name {
            method_kind = MethodKind.Get
        }
        sinon {
            parseuse.position = sauvegarde
        }
    }
    sinon si apparie(parseuse, GenreLex√®me.Set) {
        sauvegarde := parseuse.position
        parseuse.consomme()

        class_element_name = apparie_class_element_name(parseuse)
        si class_element_name {
            method_kind = MethodKind.Set
        }
        sinon {
            parseuse.position = sauvegarde
        }
    }
    sinon si apparie(parseuse, GenreLex√®me.Async) {
        sauvegarde := parseuse.position
        parseuse.consomme()

        class_element_name = apparie_class_element_name(parseuse)
        si class_element_name {
            async = vrai
        }
        sinon {
            parseuse.position = sauvegarde
        }
    }

    // √Ä FAIRE : ClassElementName, pour les m√©thodes
    // https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#prod-ClassElementName
    saufsi class_element_name {
        class_element_name = apparie_class_element_name(parseuse)
        saufsi class_element_name {
            retourne nul
        }
    }

    saufsi apparie(parseuse, GenreLex√®me.Parenth√®seOuvrante) {
        retourne nul
    }

    // √Ä FAIRE : est-ce utile ?
    parseuse.erreur_de_compilation_n_est_pas_ignorable = vrai

    lex√®me_d√©f := parseuse.lex√®me_courant()
    parseuse.consomme()
    param√®tres := parse_expressions_s√©par√©es_par_des_virgules(parseuse, GenreLex√®me.Parenth√®seFermante)
    parseuse.consomme(GenreLex√®me.Parenth√®seFermante)

    si method_kind == MethodKind.Get && param√®tres.taille != 0 {
        rapporte_erreur(parseuse, lex√®me_d√©f, "get method cannot have arguments")
    }
    sinon si method_kind == MethodKind.Set && param√®tres.taille != 1 {
        rapporte_erreur(parseuse, lex√®me_d√©f, "set method has to have exactly 1 argument")
    }
    sinon si class_element_name.type == Identifier {
        identifier := class_element_name comme *Identifier
        si identifier.nom == STR_constructor {
            method_kind = MethodKind.Constructor
        }
    }

    body := parse_function_body(parseuse, async)

    retourne cr√©e_class_method(parseuse, lex√®me_d√©f, class_element_name, param√®tres, body, method_kind, async)
}

parse_function_declaration :: fonc (parseuse: *Parseuse, async: bool) -> *FunctionDeclaration
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()

    id := parse_binding_identifier(parseuse, vrai)

    parseuse.consomme(GenreLex√®me.Parenth√®seOuvrante)
    param√®tres := parse_expressions_s√©par√©es_par_des_virgules(parseuse, GenreLex√®me.Parenth√®seFermante)
    parseuse.consomme(GenreLex√®me.Parenth√®seFermante)

    body := parse_function_body(parseuse, async)

    retourne cr√©e_function_d√©claration(parseuse, lex√®me, id, param√®tres, body, async)
}

parse_function_expression :: fonc (parseuse: *Parseuse, async: bool) -> *FunctionExpression
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()

    id := parse_binding_identifier(parseuse, faux)

    parseuse.consomme(GenreLex√®me.Parenth√®seOuvrante)
    param√®tres := parse_expressions_s√©par√©es_par_des_virgules(parseuse, GenreLex√®me.Parenth√®seFermante)
    parseuse.consomme(GenreLex√®me.Parenth√®seFermante)

    body := parse_function_body(parseuse, async)

    retourne cr√©e_function_expression(parseuse, lex√®me, id, param√®tres, body, async)
}

parse_function_body :: fonc (parseuse: *Parseuse, async: bool) -> *FunctionBody
{
    ancien_await_est_mot_cl√© := parseuse.await_est_mot_cl√©
    parseuse.await_est_mot_cl√© = async
    diff√®re parseuse.await_est_mot_cl√© = ancien_await_est_mot_cl√©

    statement := parse_statement(parseuse)
    si statement {
        statement.appartient_√†_fonction = vrai
    }
    retourne cr√©e_function_body(parseuse, statement, async)
}

parse_variable_declaration :: fonc (parseuse: *Parseuse, nature: VariableDeclarationKind) -> *VariableDeclaration
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()

    declarators: [..]*VariableDeclarator

    tantque !fini(parseuse) {
        declarator := parse_variable_declarator(parseuse)
        saufsi declarator {
            d√©loge(declarators)
            retourne nul
        }

        tableau_ajoute(*declarators, declarator)

        si apparie(parseuse, GenreLex√®me.Virgule) {
            parseuse.consomme()
            continue
        }

        arr√™te
    }

    retourne cr√©e_variable_declaration(parseuse, lex√®me, nature, declarators)
}

parse_variable_declarator :: fonc (parseuse: *Parseuse) -> *VariableDeclarator
{
    lex√®me := parseuse.lex√®me_courant()

    id: *Expression

    si parseuse.apparie(GenreLex√®me.AccoladeOuvrante) {
        id = parse_object_binding_pattern(parseuse)
    }
    sinon si parseuse.apparie(GenreLex√®me.CrochetOuvrant) {
        id = parse_array_binding_pattern(parseuse)
    }
    sinon {
        id = parse_binding_identifier(parseuse, vrai)
    }

    init: *Expression
    si apparie(parseuse, GenreLex√®me.√âgal) {
        parseuse.consomme()
        init = parseuse.parse_expression(Param√®tresParsageExpression(lex√®me_final = GenreLex√®me.Virgule))
    }

    retourne cr√©e_variable_declarator(parseuse, lex√®me, id, init)
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#prod-ObjectBindingPattern */
parse_object_binding_pattern :: fonc (parseuse: *Parseuse) -> *ObjectBindingPattern
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()

    properties: [..]*Expression

    tantque !fini(parseuse) && !apparie(parseuse, GenreLex√®me.AccoladeFermante) {
        si parseuse.apparie(GenreLex√®me.Spread) {
            lex√®me_spread := parseuse.lex√®me_courant()
            parseuse.consomme()
            id := parse_binding_identifier(parseuse, vrai)
            binding_rest_property := cr√©e_spread_element(parseuse, lex√®me_spread, id)
            tableau_ajoute(*properties, binding_rest_property)
            continue
        }

        property := parse_binding_property(parseuse)
        tableau_ajoute(*properties, property)

        saufsi apparie(parseuse, GenreLex√®me.Virgule) {
            arr√™te
        }
        parseuse.consomme()
    }

    parseuse.consomme(GenreLex√®me.AccoladeFermante)

    retourne cr√©e_object_binding_pattern(parseuse, lex√®me, properties)
}

parse_binding_property :: fonc (parseuse: *Parseuse) -> *Expression
{
    lex√®me := parseuse.lex√®me_courant()
    id := parse_binding_identifier(parseuse, faux)

    saufsi id {
        property_name := apparie_property_name(parseuse)
        si property_name {
            si parseuse.apparie(GenreLex√®me.DoublePoint) {
                lex√®me_double_point := parseuse.lex√®me_courant()
                parseuse.consomme()
                expression := parse_binding_element(parseuse)
                retourne cr√©e_binding_property(parseuse, lex√®me_double_point, id, expression)
            }
            sinon {
                rapporte_erreur(parseuse, "expected a ':'")
                retourne nul
            }
        }

        rapporte_erreur(parseuse, "expected a property name")
        retourne nul
    }

    si parseuse.apparie(GenreLex√®me.DoublePoint) {
        lex√®me_double_point := parseuse.lex√®me_courant()
        parseuse.consomme()
        expression := parse_binding_element(parseuse)
        retourne cr√©e_binding_property(parseuse, lex√®me_double_point, id, expression)
    }

    initializer: *Expression
    si apparie(parseuse, GenreLex√®me.√âgal) {
        parseuse.consomme()
        initializer = parse_expression(parseuse, Param√®tresParsageExpression(lex√®me_final = GenreLex√®me.Virgule))
    }

    retourne cr√©e_binding_element(parseuse, lex√®me, id, initializer)
}

parse_binding_element :: fonc (parseuse: *Parseuse) -> *Expression
{
    si parseuse.fini() {
        rapporte_erreur(parseuse, "unexpected end of input")
    }

    lex√®me := parseuse.lex√®me_courant()

    expression: *Expression
    si parseuse.apparie(GenreLex√®me.AccoladeOuvrante) {
        expression = parse_object_binding_pattern(parseuse)
    }
    sinon si parseuse.apparie(GenreLex√®me.CrochetOuvrant) {
        expression = parse_array_binding_pattern(parseuse)
    }
    sinon {
        expression = parse_binding_identifier(parseuse, vrai)
    }
    
    initializer: *Expression
    si apparie(parseuse, GenreLex√®me.√âgal) {
        parseuse.consomme()
        initializer = parse_expression(parseuse, Param√®tresParsageExpression(lex√®me_final = GenreLex√®me.Virgule))
    }

    retourne cr√©e_binding_element(parseuse, lex√®me, expression, initializer)
}

parse_array_binding_pattern :: fonc (parseuse: *Parseuse) -> *ArrayBindingPattern
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()

    elements: [..]*Expression

    tantque !fini(parseuse) && !apparie(parseuse, GenreLex√®me.CrochetFermant) {
        si parseuse.apparie(GenreLex√®me.Virgule) {
            parseuse.consomme()
            tableau_ajoute(*elements, nul)
            continue
        }

        si parseuse.apparie(GenreLex√®me.Spread) {
            lex√®me_spread := parseuse.lex√®me_courant()
            parseuse.consomme()
            id := parse_binding_identifier(parseuse, faux)
            si id {
                binding_rest_property := cr√©e_spread_element(parseuse, lex√®me_spread, id)
                tableau_ajoute(*elements, binding_rest_property)
                continue
            }

            si parseuse.apparie(GenreLex√®me.AccoladeOuvrante) {
                expression := parse_object_binding_pattern(parseuse)
                binding_rest_property := cr√©e_spread_element(parseuse, lex√®me_spread, expression)
                tableau_ajoute(*elements, binding_rest_property)
                continue
            }

            si parseuse.apparie(GenreLex√®me.CrochetOuvrant) {
                expression := parse_array_binding_pattern(parseuse)
                binding_rest_property := cr√©e_spread_element(parseuse, lex√®me_spread, expression)
                tableau_ajoute(*elements, binding_rest_property)
                continue
            }
            
            rapporte_erreur(parseuse, "expected a binding identifier or a binding pattern")
            continue
        }

        binding_element := parse_binding_element(parseuse)
        tableau_ajoute(*elements, binding_element)

        saufsi apparie(parseuse, GenreLex√®me.Virgule) {
            arr√™te
        }
        parseuse.consomme()
    }

    parseuse.consomme(GenreLex√®me.CrochetFermant)

    retourne cr√©e_array_binding_pattern(parseuse, lex√®me, elements)
}

parse_return_statement :: fonc (parseuse: *Parseuse) -> *ReturnStatement
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()

    argument: *Expression

    saufsi apparie(parseuse, GenreLex√®me.PointVirgule) || apparie(parseuse, GenreLex√®me.AccoladeFermante) || est_en_fin_de_ligne(parseuse, lex√®me) {
        argument = parse_expression(parseuse, Param√®tresParsageExpression())
    }

    si apparie(parseuse, GenreLex√®me.PointVirgule) {
        parseuse.consomme()
    }

    retourne cr√©e_return_statement(parseuse, lex√®me, argument)
}

TypeFor :: √©num {
    Normal
    ForOf
    ForIn
}

d√©termine_type_for :: fonc (parseuse: *Parseuse) -> TypeFor
{
    parseuse_locale := parseuse.donne_parseuse_locale()

    tantque !fini(*parseuse_locale) {
        si apparie(*parseuse_locale, GenreLex√®me.Of) {
            retourne TypeFor.ForOf
        }
        si apparie(*parseuse_locale, GenreLex√®me.In) {
            retourne TypeFor.ForIn
        }
        si apparie(*parseuse_locale, GenreLex√®me.Parenth√®seFermante) {
            arr√™te
        }

        consomme(*parseuse_locale)
    }

    retourne TypeFor.Normal
}

parse_for_statement :: fonc (parseuse: *Parseuse) -> *Statement
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()

    parseuse.consomme(GenreLex√®me.Parenth√®seOuvrante)

    type_for := d√©termine_type_for(parseuse)

    si type_for != TypeFor.Normal {
        retourne parseuse.parse_for_of_in_statement(type_for)
    }

    init: *Expression
    saufsi parseuse.apparie(GenreLex√®me.PointVirgule) {
        init = parseuse.parse_expression(Param√®tresParsageExpression())
    }
    parseuse.consomme(GenreLex√®me.PointVirgule)

    test: *Expression
    saufsi parseuse.apparie(GenreLex√®me.PointVirgule) {
        test = parseuse.parse_expression(Param√®tresParsageExpression())
    }
    parseuse.consomme(GenreLex√®me.PointVirgule)

    update: *Expression
    saufsi parseuse.apparie(GenreLex√®me.Parenth√®seFermante) {
        update = parseuse.parse_expression(Param√®tresParsageExpression())
    }
    parseuse.consomme(GenreLex√®me.Parenth√®seFermante)

    body := parse_statement(parseuse)

    retourne cr√©e_for_statement(parseuse, lex√®me, init, test, update, body)
}

parse_for_of_in_statement :: fonc (parseuse: *Parseuse, type_for: TypeFor) -> *Statement
{
    lex√®me := parseuse.lex√®me_courant()

    lex√®me_final := si type_for == TypeFor.ForOf {
        GenreLex√®me.Of
    }
    sinon {
        GenreLex√®me.In
    }

    left := parseuse.parse_expression(Param√®tresParsageExpression(lex√®me_final = lex√®me_final))

    si type_for == TypeFor.ForOf && !apparie(parseuse, GenreLex√®me.Of) {
        parseuse.rapporte_erreur("expected 'of'")
        retourne nul
    }
    si type_for == TypeFor.ForIn && !apparie(parseuse, GenreLex√®me.In) {
        parseuse.rapporte_erreur("expected 'in'")
        retourne nul
    }

    /* Consomme in/of */
    parseuse.consomme()

    right := parseuse.parse_expression(Param√®tresParsageExpression())

    parseuse.consomme(GenreLex√®me.Parenth√®seFermante)

    body := parseuse.parse_statement()

    si type_for == TypeFor.ForIn {
        retourne cr√©e_for_in_statement(parseuse, lex√®me, left, right, body)
    }

    retourne cr√©e_for_of_statement(parseuse, lex√®me, left, right, body)
}

parse_while_statement :: fonc (parseuse: *Parseuse) -> *WhileStatement
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()

    parseuse.consomme(GenreLex√®me.Parenth√®seOuvrante)
    test := parseuse.parse_expression(Param√®tresParsageExpression())
    parseuse.consomme(GenreLex√®me.Parenth√®seFermante)

    body := parse_statement(parseuse)

    retourne cr√©e_while_statement(parseuse, lex√®me, test, body)
}

parse_do_while_statement :: fonc (parseuse: *Parseuse) -> *DoWhileStatement
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()
    
    body := parse_statement(parseuse)

    parseuse.consomme(GenreLex√®me.While)
    parseuse.consomme(GenreLex√®me.Parenth√®seOuvrante)
    test := parseuse.parse_expression(Param√®tresParsageExpression())
    parseuse.consomme(GenreLex√®me.Parenth√®seFermante)

    retourne cr√©e_do_while_statement(parseuse, lex√®me, body, test)
}

parse_if_statement :: fonc (parseuse: *Parseuse) -> *IfStatement
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()

    parseuse.consomme(GenreLex√®me.Parenth√®seOuvrante)

    test := parseuse.parse_expression(Param√®tresParsageExpression())

    parseuse.consomme(GenreLex√®me.Parenth√®seFermante)

    consequent := parseuse.parse_statement()

    consomme_point_virgule_potentiel(parseuse)

    alternate: *Statement
    si parseuse.apparie(GenreLex√®me.Else) {
        parseuse.consomme()
        alternate = parseuse.parse_statement()
    }

    retourne cr√©e_if_statement(parseuse, lex√®me, test, consequent, alternate)
}

parse_try_statement :: fonc (parseuse: *Parseuse) -> *TryStatement
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()

    block := parse_statement(parseuse)

    handler: *CatchClause
    si parseuse.apparie(GenreLex√®me.Catch) {
        lex√®me_catch := parseuse.lex√®me_courant()
        parseuse.consomme()

        param: *Expression
        si parseuse.apparie(GenreLex√®me.Parenth√®seOuvrante) {
            parseuse.consomme()

            param = parseuse.parse_expression(Param√®tresParsageExpression())

            parseuse.consomme(GenreLex√®me.Parenth√®seFermante)
        }

        body := parse_statement(parseuse)

        handler = cr√©e_catch_clause(parseuse, lex√®me_catch, param, body)
    }

    finalizer: *Statement
    si parseuse.apparie(GenreLex√®me.Finally) {
        parseuse.consomme()
        finalizer = parse_statement(parseuse)
    }

    retourne cr√©e_try_statement(parseuse, lex√®me, block, handler, finalizer)
}

parse_throw_statement :: fonc (parseuse: *Parseuse) -> *ThrowStatement
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()
    argument := parse_expression(parseuse, Param√®tresParsageExpression())
    retourne cr√©e_throw_statement(parseuse, lex√®me, argument)
}

parse_continue_statement :: fonc (parseuse: *Parseuse) -> *ContinueStatement
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()
    target := parse_label_identifier(parseuse, faux)
    retourne cr√©e_continue_statement(parseuse, lex√®me, target)
}

parse_break_statement :: fonc (parseuse: *Parseuse) -> *BreakStatement
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()
    target := parse_label_identifier(parseuse, faux)
    retourne cr√©e_break_statement(parseuse, lex√®me, target)
}

parse_switch_statement :: fonc (parseuse: *Parseuse) -> *SwitchStatement
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()

    parseuse.consomme(GenreLex√®me.Parenth√®seOuvrante)
    discriminant := parseuse.parse_expression(Param√®tresParsageExpression())
    parseuse.consomme(GenreLex√®me.Parenth√®seFermante)

    parseuse.consomme(GenreLex√®me.AccoladeOuvrante)
    cases: [..]*CaseClause
    index_default_clause : z64 = -1

    tantque !parseuse.fini() {
        si apparie(parseuse, GenreLex√®me.Case) {
            case := parseuse.parse_case_clause()
            tableau_ajoute(*cases, case)
            continue
        }

        si apparie(parseuse, GenreLex√®me.Default) {
            si index_default_clause != -1 {
                parseuse.rapporte_erreur("duplicate default case")
                arr√™te
            }

            case := parseuse.parse_default_clause()
            index_default_clause = cases.taille
            tableau_ajoute(*cases, case)
            continue
        }

        arr√™te
    }

    parseuse.consomme(GenreLex√®me.AccoladeFermante)

    retourne cr√©e_switch_statement(parseuse, lex√®me, discriminant, cases, index_default_clause)
}

parse_case_clause :: fonc (parseuse: *Parseuse) -> *CaseClause
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()

    test := parseuse.parse_expression(Param√®tresParsageExpression())
    parseuse.consomme(GenreLex√®me.DoublePoint)

    consequent := parse_statement_list_case(parseuse)

    retourne cr√©e_case_clause(parseuse, lex√®me, test, consequent)
}

parse_default_clause :: fonc (parseuse: *Parseuse) -> *DefaultClause
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()
    parseuse.consomme(GenreLex√®me.DoublePoint)

    consequent := parse_statement_list_case(parseuse)

    retourne cr√©e_default_clause(parseuse, lex√®me, consequent)
}

parse_statement_list_case :: fonc (parseuse: *Parseuse) -> *Statement
{
    si parseuse.apparie(GenreLex√®me.AccoladeOuvrante) {
        retourne parseuse.parse_statement()
    }

    statements: [..]*Statement

    tantque !fini(parseuse) && !apparie(parseuse, GenreLex√®me.AccoladeFermante) && !apparie(parseuse, GenreLex√®me.Case) && !apparie(parseuse, GenreLex√®me.Default) {
        statement := parse_statement(parseuse)
        saufsi statement {
            arr√™te
        }
        tableau_ajoute(*statements, statement)
    }

    retourne cr√©e_block_statement(parseuse, nul, statements)
}

Param√®tresParsageExpression :: struct {
    pr√©c√©dence : z32 = 0
    associativit√© : Associativit√© = Associativit√©.Gauche
    lex√®me_final := GenreLex√®me.PointVirgule
}

parse_expression :: fonc (parseuse: *Parseuse, params: Param√®tresParsageExpression) -> *Expression
{
    expression := parseuse.parse_expression_primaire()

    tantque !parseuse.fini() && !apparie(parseuse, params.lex√®me_final) {
        infos := infos_lex√®mes_pour_parsage[parseuse.lex√®me_courant().genre]
        saufsi infos.drapeaux.EstExpressionSecondaire {
            arr√™te
        }

        nouvelle_pr√©c√©dence := infos.pr√©c√©dence

        si nouvelle_pr√©c√©dence < params.pr√©c√©dence {
            arr√™te
        }

        si nouvelle_pr√©c√©dence == params.pr√©c√©dence && params.associativit√© == Associativit√©.Gauche {
            arr√™te
        }

        nouveau_params := params
        nouveau_params.pr√©c√©dence = nouvelle_pr√©c√©dence
        nouveau_params.associativit√© = infos.associativit√©

        expression_secondaire := parseuse.parse_expression_secondaire(expression, nouveau_params)
        saufsi expression_secondaire {
            arr√™te
        }
        expression = expression_secondaire
    }

    retourne expression
}

cr√©e_chaine_√©chappement_r√©solu :: fonc (chn: chaine) -> ECMAString
{
    saufsi poss√®de_√©chappement(chn) {
        retourne cr√©e_chaine_utf16_unique(chn)
    }

    enchaineuse: Enchaineuse
    initialise_enchaineuse(*enchaineuse)
    diff√®re d√©truit_tampons(*enchaineuse)

    d√©but := chn.pointeur
    fin := chn.pointeur + chn.taille

    tantque d√©but < fin {
        caract√®re := m√©moire(d√©but)

        si caract√®re == '\\' && (d√©but + 1) < fin {
            d√©but += 1
            caract√®re = m√©moire(d√©but)
            si caract√®re == 'n' {
                ajoute_au_tampon(*enchaineuse, "\n")
            }
            sinon si caract√®re == 't' {
                ajoute_au_tampon(*enchaineuse, "\t")
            }
            sinon si caract√®re != '\n' {
                ajoute_au_tampon(*enchaineuse, chaine(d√©but, 1))
            }
        }
        sinon {
            ajoute_au_tampon(*enchaineuse, chaine(d√©but, 1))
        }

        d√©but += 1
    }

    r√©sultat := chaine_depuis_enchaineuse(*enchaineuse)
    retourne cr√©e_chaine_utf16_unique(r√©sultat)
}

poss√®de_√©chappement :: fonc (chn: chaine) -> bool
{
    pour chn {
        si it == '\\' {
            retourne vrai
        }
    }

    retourne faux
}

parse_expression_primaire :: fonc (parseuse: *Parseuse) -> *Expression
{
    si parseuse.fini() {
        rapporte_erreur(parseuse, "expected a primary expression")
        retourne nul
    }

    lex√®me := parseuse.lex√®me_courant()

    discr lex√®me.genre {
        ChaineLitt√©rale {
            parseuse.consomme()
            retourne cr√©e_literal(parseuse, lex√®me, cr√©e_chaine_√©chappement_r√©solu(lex√®me.texte))
        }
        TemplateLiteral {
            parseuse.consomme()
            quasi := cr√©e_template_element(parseuse, lex√®me, cr√©e_chaine_√©chappement_r√©solu(lex√®me.texte), vrai)
            quasis: [..]*TemplateElement
            tableau_ajoute(*quasis, quasi)
            retourne cr√©e_template_literal(parseuse, lex√®me, quasis)
        }
        TemplateLiteralStart {
            retourne parse_template_literal(parseuse, lex√®me)
        }
        NombreLitt√©ral {
            parseuse.consomme()
            valeur := parse_nombre_depuis_lex√®me(lex√®me)
            retourne cr√©e_literal(parseuse, lex√®me, valeur)
        }
        True {
            parseuse.consomme()
            retourne cr√©e_boolean_literal(parseuse, lex√®me, vrai)
        }
        False {
            parseuse.consomme()
            retourne cr√©e_boolean_literal(parseuse, lex√®me, faux)
        }
        Null {
            parseuse.consomme()
            retourne cr√©e_null_literal(parseuse, lex√®me)
        }
        This {
            parseuse.consomme()
            retourne cr√©e_this_expression(parseuse, lex√®me)
        }
        As,
        From,
        Get,
        Meta,
        Of,
        Set,
        Target,
        Identifiant {
            parseuse.consomme()
            retourne cr√©e_identifier(parseuse, lex√®me, lex√®me.texte)
        }
        Async {
            parseuse.consomme()

            si !est_en_fin_de_ligne(parseuse, lex√®me) && parseuse.apparie(GenreLex√®me.Function) {
                retourne parse_function_expression(parseuse, vrai)
            }

            retourne cr√©e_identifier(parseuse, lex√®me, lex√®me.texte)
        }
        PrivateIdentifier {
            parseuse.consomme()
            retourne cr√©e_private_identifier(parseuse, lex√®me)
        }
        Parenth√®seOuvrante {
            parseuse.consomme()

            expression: *Expression
            saufsi parseuse.apparie(GenreLex√®me.Parenth√®seFermante) {
                expression = parseuse.parse_expression(Param√®tresParsageExpression())
            }

            parseuse.consomme(GenreLex√®me.Parenth√®seFermante)

            si expression {
                retourne expression
            }

            /* NOTE : pour l'instant ces expressions ne servent que pour les fonctions-arrow */
            retourne parseuse.cr√©e_parenthesized_expression(lex√®me, expression)
        }
        AccoladeOuvrante {
            parseuse.consomme()

            properties: [..]*Expression

            tantque !fini(parseuse) {
                si apparie(parseuse, GenreLex√®me.AccoladeFermante) {
                    arr√™te
                }

                si apparie(parseuse, GenreLex√®me.Spread) {
                    spread := parse_spread(parseuse, parseuse.lex√®me_courant())
                    tableau_ajoute(*properties, spread)
                }
                sinon {
                    nom_membre: *Expression
                    method_kind := MethodKind.Method

                    si apparie(parseuse, GenreLex√®me.Get) {
                        sauvegarde := parseuse.position
                        parseuse.consomme()

                        class_element_name := apparie_class_element_name(parseuse)
                        si class_element_name {
                            nom_membre = class_element_name
                            method_kind = MethodKind.Get
                        }
                        sinon {
                            parseuse.position = sauvegarde
                        }
                    }
                    sinon si apparie(parseuse, GenreLex√®me.Set) {
                        sauvegarde := parseuse.position
                        parseuse.consomme()

                        class_element_name := apparie_class_element_name(parseuse)
                        si class_element_name {
                            nom_membre = class_element_name
                            method_kind = MethodKind.Set
                        }
                        sinon {
                            parseuse.position = sauvegarde
                        }
                    }

                    // √Ä FAIRE : ClassElementName, pour les m√©thodes
                    // https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#prod-ClassElementName
                    saufsi nom_membre {
                        nom_membre = parse_property_name(parseuse)
                    }

                    si apparie(parseuse, GenreLex√®me.Parenth√®seOuvrante) {
                        lex√®me_d√©f := parseuse.lex√®me_courant()
                        parseuse.consomme()
                        param√®tres := parse_expressions_s√©par√©es_par_des_virgules(parseuse, GenreLex√®me.Parenth√®seFermante)
                        parseuse.consomme(GenreLex√®me.Parenth√®seFermante)

                        si method_kind == MethodKind.Get && param√®tres.taille != 0 {
                            rapporte_erreur(parseuse, lex√®me_d√©f, "get method cannot have arguments")
                        }
                        sinon si method_kind == MethodKind.Set && param√®tres.taille != 1 {
                            rapporte_erreur(parseuse, lex√®me_d√©f, "set method has to have exactly 1 argument")
                        }

                        body := parse_function_body(parseuse, faux)

                        m√©thode := cr√©e_object_method(parseuse, lex√®me_d√©f, nom_membre, param√®tres, body, method_kind)
                        tableau_ajoute(*properties, m√©thode)
                    }
                    sinon si parseuse.apparie(GenreLex√®me.DoublePoint) {
                        lex√®me_d√©f := parseuse.lex√®me_courant()
                        parseuse.consomme(GenreLex√®me.DoublePoint)

                        expression := parseuse.parse_expression(Param√®tresParsageExpression(lex√®me_final = GenreLex√®me.Virgule))

                        property := cr√©e_property_definition(parseuse, lex√®me_d√©f, nom_membre, expression)
                        tableau_ajoute(*properties, property)
                    }
                    sinon si nom_membre != nul && nom_membre.type == Identifier {
                        tableau_ajoute(*properties, nom_membre)
                    }
                    sinon {
                        rapporte_erreur(parseuse, "expected a property definition")
                    }
                }

                saufsi apparie(parseuse, GenreLex√®me.Virgule) {
                    arr√™te
                }

                parseuse.consomme()
            }

            parseuse.consomme(GenreLex√®me.AccoladeFermante)

            retourne cr√©e_object_literal(parseuse, lex√®me, properties)
        }
        CrochetOuvrant {
            retourne parse_array_literal(parseuse, lex√®me)
        }
        Let {
            retourne parse_variable_declaration(parseuse, VariableDeclarationKind.Let)
        }
        Var {
            retourne parse_variable_declaration(parseuse, VariableDeclarationKind.Var)
        }
        Const {
            retourne parse_variable_declaration(parseuse, VariableDeclarationKind.Const)
        }
        Function {
            retourne parse_function_expression(parseuse, faux)
        }
        Plus {
            parseuse.consomme()
            params := donne_param√®tres_parsage_expression_pour_lex√®me_unaire(GenreLex√®me.PlusUnaire)
            argument := parseuse.parse_expression(params)
            retourne cr√©e_unary_plus_operator(parseuse, lex√®me, argument)
        }
        Moins {
            parseuse.consomme()
            params := donne_param√®tres_parsage_expression_pour_lex√®me_unaire(GenreLex√®me.MoinsUnaire)
            argument := parseuse.parse_expression(params)
            retourne cr√©e_unary_minus_operator(parseuse, lex√®me, argument)
        }
        NonBinaire {
            parseuse.consomme()
            params := donne_param√®tres_parsage_expression_pour_lex√®me_unaire(lex√®me.genre)
            argument := parseuse.parse_expression(params)
            retourne cr√©e_binary_not(parseuse, lex√®me, argument)
        }
        NonLogique {
            parseuse.consomme()
            params := donne_param√®tres_parsage_expression_pour_lex√®me_unaire(lex√®me.genre)
            argument := parseuse.parse_expression(params)
            retourne cr√©e_logical_not(parseuse, lex√®me, argument)
        }
        PlusPlus {
            parseuse.consomme()
            params := donne_param√®tres_parsage_expression_pour_lex√®me_unaire(GenreLex√®me.PreIncrement)
            argument := parseuse.parse_expression(params)
            retourne cr√©e_update_expression(parseuse, lex√®me, argument, UpdateOperation.PrefixIncrement)
        }
        MoinsMoins {
            parseuse.consomme()
            params := donne_param√®tres_parsage_expression_pour_lex√®me_unaire(GenreLex√®me.PreDecrement)
            argument := parseuse.parse_expression(params)
            retourne cr√©e_update_expression(parseuse, lex√®me, argument, UpdateOperation.PrefixDecrement)
        }
        Typeof {
            parseuse.consomme()
            params := donne_param√®tres_parsage_expression_pour_lex√®me_unaire(lex√®me.genre)
            argument := parseuse.parse_expression(params)
            retourne cr√©e_typeof_operator(parseuse, lex√®me, argument)
        }
        Void {
            parseuse.consomme()
            params := donne_param√®tres_parsage_expression_pour_lex√®me_unaire(lex√®me.genre)
            argument := parseuse.parse_expression(params)
            retourne cr√©e_void_operator(parseuse, lex√®me, argument)
        }
        Delete {
            parseuse.consomme()
            params := donne_param√®tres_parsage_expression_pour_lex√®me_unaire(lex√®me.genre)
            argument := parseuse.parse_expression(params)
            retourne cr√©e_delete_operator(parseuse, lex√®me, argument)
        }
        New {
            parseuse.consomme()
            params := donne_param√®tres_parsage_expression_pour_lex√®me_unaire(lex√®me.genre)
            params.lex√®me_final = GenreLex√®me.Point
            argument := parseuse.parse_expression(params)
            retourne cr√©e_new_expression(parseuse, lex√®me, argument);
        }
        Spread {
            retourne parse_spread(parseuse, lex√®me)
        }
        Super {
            parseuse.consomme()

            si parseuse.apparie(GenreLex√®me.Point) {
                lex√®me_point := parseuse.lex√®me_courant()
                parseuse.consomme()
                propri√©t√© := parse_identifier_name(parseuse)
                retourne cr√©e_super_property(parseuse, lex√®me_point, propri√©t√©, faux)
            }

            si parseuse.apparie(GenreLex√®me.CrochetOuvrant) {
                lex√®me_crochet := parseuse.lex√®me_courant()
                parseuse.consomme()
                propri√©t√© := parse_expression(parseuse, Param√®tresParsageExpression())
                parseuse.consomme(GenreLex√®me.CrochetFermant)
                retourne cr√©e_super_property(parseuse, lex√®me_crochet, propri√©t√©, vrai)
            }

            parseuse.consomme(GenreLex√®me.Parenth√®seOuvrante)
            arguments := parse_expressions_s√©par√©es_par_des_virgules(parseuse, GenreLex√®me.Parenth√®seFermante)
            parseuse.consomme(GenreLex√®me.Parenth√®seFermante)
            retourne cr√©e_super_call(parseuse, lex√®me, arguments)
        }
        Class {
            retourne parse_class_declaration(parseuse, vrai) comme *ClassExpression
        }
        Slash {
            /* Nous manquons de contexte lors du lexage initial, et ainsi certaines expression r√©guli√®re
             * peuvent ne pas √™tre correctement d√©tect√©es.
             * Nous faisons un relexage √† partir du lex√®me courant pour obtenir ladite expression r√©guli√®re. */
            lexeuse: Lexeuse
            lexeuse.realm = parseuse.realm
            initialise_lexeuse_depuis_source(lexeuse, parseuse.source_text)
            lexeuse.d√©but_source = lex√®me.texte.pointeur

            lex√®me_regex_literal := l√®xe_regex_litt√©rale(lexeuse)

            tantque !fini(parseuse) {
                lex√®me_√†_ignorer := parseuse.lex√®me_courant()
                saufsi est_sous_chaine(lex√®me_regex_literal.texte, lex√®me_√†_ignorer.texte) {
                    arr√™te
                }

                parseuse.consomme()
            }

            m√©moire(lex√®me) = lex√®me_regex_literal

            retourne cr√©e_literal(parseuse, lex√®me, cr√©e_chaine_√©chappement_r√©solu(lex√®me.texte))
        }
        Await {
            parseuse.consomme()
            saufsi parseuse.await_est_mot_cl√© {
                retourne cr√©e_identifier(parseuse, lex√®me, lex√®me.texte)
            }

            expression := parse_expression(parseuse, Param√®tresParsageExpression())
            retourne cr√©e_await_expression(parseuse, lex√®me, expression)
        }
        sinon {
            parseuse.rapporte_erreur("expected a primary expression")
        }
    }

    retourne nul
}

parse_template_literal :: fonc (parseuse: *Parseuse, lex√®me: *Lex√®me) -> *TemplateLiteral
{
    assert(lex√®me.genre == GenreLex√®me.TemplateLiteralStart)
    parseuse.consomme()

    lex√®me_orig := lex√®me

    quasis: [..]*TemplateElement
    expressions: [..]*Expression

    quasi := cr√©e_template_element(parseuse, lex√®me, cr√©e_chaine_√©chappement_r√©solu(lex√®me.texte), faux)
    tableau_ajoute(*quasis, quasi)

    tantque !fini(parseuse) {
        expression := parse_expression(parseuse, Param√®tresParsageExpression())
        tableau_ajoute(*expressions, expression)

        si parseuse.fini() {
            parseuse.rapporte_erreur("fin de fichier inattendu dans le template literal")
            arr√™te
        }

        lex√®me = parseuse.lex√®me_courant()
        si lex√®me.genre == GenreLex√®me.TemplateLiteralMiddle {
            quasi = cr√©e_template_element(parseuse, lex√®me, cr√©e_chaine_√©chappement_r√©solu(lex√®me.texte), faux)
            tableau_ajoute(*quasis, quasi)
            parseuse.consomme()
            continue
        }

        si lex√®me.genre != GenreLex√®me.TemplateLiteralEnd {
            parseuse.rapporte_erreur("[erreur interne] attendu un template-literal-end")
        }

        quasi = cr√©e_template_element(parseuse, lex√®me, cr√©e_chaine_√©chappement_r√©solu(lex√®me.texte), vrai)
        tableau_ajoute(*quasis, quasi)
        parseuse.consomme()
        arr√™te
    }

    retourne cr√©e_template_literal(parseuse, lex√®me_orig, quasis, expressions)
}

parse_property_name :: fonc (parseuse: *Parseuse) -> *Expression
{
    lex√®me := parseuse.lex√®me_courant()

    si parseuse.apparie(GenreLex√®me.ChaineLitt√©rale) {
        parseuse.consomme()
        retourne cr√©e_literal(parseuse, lex√®me, lex√®me.texte)
    }

    si parseuse.apparie(GenreLex√®me.NombreLitt√©ral) {
        parseuse.consomme()
        valeur := parse_nombre_depuis_lex√®me(lex√®me)
        retourne cr√©e_literal(parseuse, lex√®me, valeur)
    }

    si parseuse.apparie(GenreLex√®me.CrochetOuvrant) {
        lex√®me = parseuse.lex√®me_courant()
        parseuse.consomme()
        expression := parse_expression(parseuse, Param√®tresParsageExpression())
        parseuse.consomme(GenreLex√®me.CrochetFermant)
        retourne cr√©e_computed_property_name(parseuse, lex√®me, expression)
    }

    retourne parse_identifier_name(parseuse)
}

parse_identifier_name :: fonc (parseuse: *Parseuse) -> *Identifier
{
    si parseuse.fini() {
        rapporte_erreur(parseuse, "unexpected end of input")
        retourne nul
    }

    lex√®me := parseuse.lex√®me_courant()
    si lex√®me.texte.taille == 0 {
        rapporte_erreur(parseuse, "empty token")
        retourne nul
    }

    c := lex√®me.texte[0]
    fanion := fanions_caract√®res[c comme n8]

    saufsi fanion.D√©buteIdentifiant {
        rapporte_erreur(parseuse, "expected an identifier name")
    }

    parseuse.consomme()
    retourne cr√©e_identifier(parseuse, lex√®me, lex√®me.texte)
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#prod-IdentifierReference */
parse_identifier_reference :: fonc (parseuse: *Parseuse) -> *Identifier
{
    retourne parse_identifiant_yield_ou_await(parseuse, vrai)
}

parse_binding_identifier :: fonc (parseuse: *Parseuse, √©mets_erreur_si_manquant: bool) -> *Identifier
{
    retourne parse_identifiant_yield_ou_await(parseuse, √©mets_erreur_si_manquant)
}

parse_label_identifier :: fonc (parseuse: *Parseuse, √©mets_erreur_si_manquant: bool) -> *Identifier
{
    retourne parse_identifiant_yield_ou_await(parseuse, √©mets_erreur_si_manquant)
}

parse_identifier :: fonc (parseuse: *Parseuse, √©mets_erreur_si_manquant: bool) -> *Identifier
{
    lex√®me := parseuse.lex√®me_courant()

    si apparie_lex√®me_identifier(parseuse) {
        parseuse.consomme()
        retourne cr√©e_identifier(parseuse, lex√®me, lex√®me.texte)
    }

    si √©mets_erreur_si_manquant {
        parseuse.rapporte_erreur("expected an identifier")
    }
    retourne nul
}

parse_spread :: fonc (parseuse: *Parseuse, lex√®me: *Lex√®me) -> *SpreadElement
{
    parseuse.consomme()
    params := donne_param√®tres_parsage_expression_pour_lex√®me_unaire(lex√®me.genre)
    params.lex√®me_final = GenreLex√®me.Virgule
    argument := parseuse.parse_expression(params)
    retourne cr√©e_spread_element(parseuse, lex√®me, argument);
}

apparie_lex√®me_identifier :: fonc (parseuse: *Parseuse) -> bool
{
    lex√®me := parseuse.lex√®me_courant()

    // as, async, from, get, meta, of, set, and target
    lex√®mes_autoris√©s := [GenreLex√®me.Identifiant, GenreLex√®me.As, GenreLex√®me.Async, GenreLex√®me.From, GenreLex√®me.Get, GenreLex√®me.Meta, GenreLex√®me.Of, GenreLex√®me.Set, GenreLex√®me.Target]
    pour lex√®mes_autoris√©s {
        si lex√®me.genre == it {
            retourne vrai
        }
    }
    retourne faux
}

apparie_lex√®me_identifier_property :: fonc (parseuse: *Parseuse) -> bool
{
    si apparie_lex√®me_identifier(parseuse) {
        retourne vrai
    }
    si apparie(parseuse, GenreLex√®me.Delete) {
        retourne vrai
    }
    retourne faux
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#prod-ClassElementName */
apparie_class_element_name :: fonc (parseuse: *Parseuse) -> *Expression
{
    r√©sultat := apparie_property_name(parseuse)
    si r√©sultat {
        retourne r√©sultat
    }

    si apparie(parseuse, GenreLex√®me.PrivateIdentifier) {
        lex√®me := parseuse.lex√®me_courant()
        parseuse.consomme()
        retourne cr√©e_private_identifier(parseuse, lex√®me)
    }

    retourne nul
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#prod-PropertyName */
apparie_property_name :: fonc (parseuse: *Parseuse) -> *Expression
{
    r√©sultat := apparie_literal_property_name(parseuse)
    si r√©sultat {
        retourne r√©sultat
    }

    si parseuse.apparie(GenreLex√®me.CrochetOuvrant) {
        lex√®me := parseuse.lex√®me_courant()
        parseuse.consomme()
        expression := parse_expression(parseuse, Param√®tresParsageExpression())
        parseuse.consomme(GenreLex√®me.CrochetFermant)
        retourne cr√©e_computed_property_name(parseuse, lex√®me, expression)
    }

    retourne nul
}

// √Ä FAIRE : redondant avec parse_property_name
apparie_literal_property_name :: fonc (parseuse: *Parseuse) -> *Expression
{
    si parseuse.fini() {
        retourne nul
    }

    lex√®me := parseuse.lex√®me_courant()
    si lex√®me.genre == GenreLex√®me.ChaineLitt√©rale {
        parseuse.consomme()
        retourne cr√©e_literal(parseuse, lex√®me, cr√©e_chaine_√©chappement_r√©solu(lex√®me.texte))
    }

    si lex√®me.genre == GenreLex√®me.NombreLitt√©ral {
        parseuse.consomme()
        valeur := parse_nombre_depuis_lex√®me(lex√®me)
        retourne cr√©e_literal(parseuse, lex√®me, valeur)
    }

    si lex√®me.texte.taille == 0 {
        retourne nul
    }

    c := lex√®me.texte[0]
    fanion := fanions_caract√®res[c comme n8]

    saufsi fanion.D√©buteIdentifiant {
        retourne nul
    }

    parseuse.consomme()
    retourne cr√©e_identifier(parseuse, lex√®me, lex√®me.texte)
}

parse_identifiant_yield_ou_await :: fonc (parseuse: *Parseuse, √©mets_erreur_si_manquant: bool) -> *Identifier
{
    lex√®me := parseuse.lex√®me_courant()

    si lex√®me.genre == GenreLex√®me.Yield {
        parseuse.consomme()
        retourne cr√©e_identifier(parseuse, lex√®me, lex√®me.texte)
    }

    si lex√®me.genre == GenreLex√®me.Await && !parseuse.await_est_mot_cl√© {
        parseuse.consomme()
        retourne cr√©e_identifier(parseuse, lex√®me, lex√®me.texte)
    }

    retourne parse_identifier(parseuse, √©mets_erreur_si_manquant)
}

donne_op√©ration_binaire_pour_genre_lex√®me :: fonc (genre: GenreLex√®me) -> BinaryOperation
{
    discr genre {
        Plus {
            retourne BinaryOperation.Plus
        }
        Moins {
            retourne BinaryOperation.Moins
        }
        √âtoile {
            retourne BinaryOperation.Multiplie
        }
        Slash {
            retourne BinaryOperation.Divise
        }
        Pourcent {
            retourne BinaryOperation.Modulo
        }
        EtBinaire {
            retourne BinaryOperation.EtBinaire
        }
        OuBinaire {
            retourne BinaryOperation.OuBinaire
        }
        OuExclusif {
            retourne BinaryOperation.OuExclusif
        }
        D√©calageGauche {
            retourne BinaryOperation.D√©calageGauche
        }
        D√©calageDroite {
            retourne BinaryOperation.D√©calageDroite
        }
        D√©calageDroiteNaturel {
            retourne BinaryOperation.D√©calageDroiteNaturel
        }
        Exponentiation {
            retourne BinaryOperation.Exponentiation
        }
        sinon {
            panique("genre op√©rateur non-g√©r√©")
        }
    }

    retourne BinaryOperation.Plus
}

donne_op√©ration_√©galitaire_pour_genre_lex√®me :: fonc (genre: GenreLex√®me) -> EqualityOperation
{
    discr genre {
        Est√âgal {
            retourne EqualityOperation.√âgal
        }
        NEspaPas√âgal {
            retourne EqualityOperation.In√©gal
        }
        Est√âgalStrict {
            retourne EqualityOperation.√âgalStrict
        }
        NEspaPas√âgalStrict {
            retourne EqualityOperation.In√©galStrict
        }
        sinon {
            panique("genre op√©rateur non-g√©r√©")
        }
    }
    retourne EqualityOperation.√âgal
}

donne_op√©ration_relationnelle_pour_genre_lex√®me :: fonc (genre: GenreLex√®me) -> RelationalOperation
{
    discr genre {
        Inf√©rieur {
            retourne RelationalOperation.Inf√©rieur
        }
        Sup√©rieur {
            retourne RelationalOperation.Sup√©rieur
        }
        Inf√©rieur√âgal {
            retourne RelationalOperation.Inf√©rieur√âgal
        }
        Sup√©rieur√âgal {
            retourne RelationalOperation.Sup√©rieur√âgal
        }
        InstanceOf {
            retourne RelationalOperation.InstanceOf
        }
        In {
            retourne RelationalOperation.In
        }
        sinon {
            panique("genre op√©rateur non-g√©r√©")
        }
    }

    retourne RelationalOperation.Inf√©rieur
}

parse_expression_secondaire :: fonc (parseuse: *Parseuse, gauche: *Expression, params: Param√®tresParsageExpression) -> *Expression
{
    lex√®me := parseuse.lex√®me_courant()

    discr lex√®me.genre {
        Plus,
        Moins,
        √âtoile,
        Slash,
        Pourcent,
        EtBinaire,
        OuBinaire,
        OuExclusif,
        D√©calageGauche,
        D√©calageDroite,
        D√©calageDroiteNaturel,
        Exponentiation {
            op√©ration := donne_op√©ration_binaire_pour_genre_lex√®me(lex√®me.genre)
            parseuse.consomme()
            op√©rande_droite := parseuse.parse_expression(params)
            retourne cr√©e_binary_expression(parseuse, lex√®me, op√©ration, gauche, op√©rande_droite)
        }
        Inf√©rieur,
        Sup√©rieur,
        Inf√©rieur√âgal,
        Sup√©rieur√âgal,
        InstanceOf,
        In {
            op√©ration := donne_op√©ration_relationnelle_pour_genre_lex√®me(lex√®me.genre)
            parseuse.consomme()
            op√©rande_droite := parseuse.parse_expression(params)
            retourne cr√©e_relational_expression(parseuse, lex√®me, op√©ration, gauche, op√©rande_droite)
        }
        Est√âgal,
        NEspaPas√âgal,
        Est√âgalStrict,
        NEspaPas√âgalStrict {
            op√©ration := donne_op√©ration_√©galitaire_pour_genre_lex√®me(lex√®me.genre)
            parseuse.consomme()
            op√©rande_droite := parseuse.parse_expression(params)
            retourne cr√©e_equality_expression(parseuse, lex√®me, op√©ration, gauche, op√©rande_droite)
        }
        PlusPlus,
        MoinsMoins {
            parseuse.consomme()

            operation := si lex√®me.genre == GenreLex√®me.PlusPlus { UpdateOperation.PostfixIncrement } sinon { UpdateOperation.PostfixDecrement }
            update := cr√©e_update_expression(parseuse, lex√®me, gauche, operation)

            /* Les expressions de style var o = {x:i++,y:2} doivent s'arr√™ter √† la virgule (qui est une expression secondaire). */
            si !parseuse.apparie(params.lex√®me_final) {
                expression := parseuse.parse_expression_secondaire(update, params)
                si expression {
                    retourne expression
                }
            }

            retourne update
        }
        √âgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.Assigne, params)
        }
        Plus√âgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.Ajoute, params)
        }
        Moins√âgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.Soustrait, params)
        }
        √âtoile√âgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.Multiplie, params)
        }
        Slash√âgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.Divise, params)
        }
        Pourcent√âgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.Modulo, params)
        }
        D√©calageGauche√âgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.D√©calageGauche, params)
        }
        D√©calageDroite√âgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.D√©calageDroite, params)
        }
        D√©calageDroiteNaturel√âgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.D√©calageDroiteNaturel, params)
        }
        EtBinaire√âgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.EtBinaire, params)
        }
        OuBinaire√âgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.OuBinaire, params)
        }
        OuExclusif√âgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.OuExBinaire, params)
        }
        EtLogique√âgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.EtLogique, params)
        }
        OuLogique√âgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.OuLogique, params)
        }
        Coalesce√âgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.Coalesce, params)
        }
        Exponentiation√âgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.Exponentiation, params)
        }
        Point {
            parseuse.consomme()
            propri√©t√©: *Expression
            si parseuse.apparie(GenreLex√®me.PrivateIdentifier) {
                lex√®me_identifier := parseuse.lex√®me_courant()
                parseuse.consomme()
                propri√©t√© = cr√©e_private_identifier(parseuse, lex√®me_identifier)
            }
            sinon {
                propri√©t√© = parse_identifier_name(parseuse)
            }
            
            si gauche.type == OptionalMemberExpression {
                retourne cr√©e_optional_member_expression(parseuse, lex√®me, gauche, propri√©t√©, faux)
            }
            retourne cr√©e_member_expression(parseuse, lex√®me, gauche, propri√©t√©, faux)
        }
        Parenth√®seOuvrante {
            parseuse.consomme()

            arguments := parse_expressions_s√©par√©es_par_des_virgules(parseuse, GenreLex√®me.Parenth√®seFermante)

            parseuse.consomme(GenreLex√®me.Parenth√®seFermante)
            
            si gauche.type == OptionalMemberExpression {
                retourne cr√©e_optional_call_expression(parseuse, lex√®me, gauche, arguments)
            }

            retourne cr√©e_call_expression(parseuse, lex√®me, gauche, arguments)
        }
        CrochetOuvrant {
            parseuse.consomme()

            propri√©t√© := parseuse.parse_expression(Param√®tresParsageExpression())

            parseuse.consomme(GenreLex√®me.CrochetFermant)

            si gauche.type == OptionalMemberExpression {
                retourne cr√©e_optional_member_expression(parseuse, lex√®me, gauche, propri√©t√©, vrai)
            }

            retourne cr√©e_member_expression(parseuse, lex√®me, gauche, propri√©t√©, vrai)
        }
        EtLogique {
            parseuse.consomme()
            droite := parseuse.parse_expression(params)
            retourne cr√©e_logical_and(parseuse, lex√®me, gauche, droite)
        }
        OuLogique {
            parseuse.consomme()
            droite := parseuse.parse_expression(params)
            retourne cr√©e_logical_or(parseuse, lex√®me, gauche, droite)
        }
        Coalesce {
            parseuse.consomme()
            droite := parseuse.parse_expression(params)
            retourne cr√©e_coalesce(parseuse, lex√®me, gauche, droite)
        }
        Interrogation {
            parseuse.consomme()

            consequent := parseuse.parse_expression(params)
            parseuse.consomme(GenreLex√®me.DoublePoint)

            alternate := parseuse.parse_expression(params)
            retourne cr√©e_conditional_expression(parseuse, lex√®me, gauche, consequent, alternate)
        }
        Virgule {
            parseuse.consomme()
            droite := parseuse.parse_expression(params)
            retourne cr√©e_comma_expression(parseuse, lex√®me, gauche, droite)
        }
        Arrow {
            parseuse.consomme()

            droite: *Statement
            si parseuse.apparie(GenreLex√®me.AccoladeOuvrante) {
                droite = parseuse.parse_statement()
            }
            sinon {
                /* Virgule car nous pouvons √™tre dans une expression d'objet ou d'array. */
                params = Param√®tresParsageExpression()
                params.lex√®me_final = GenreLex√®me.Virgule
                expression := parse_expression(parseuse, params)
                droite = cr√©e_expression_statement(parseuse, lex√®me, expression)
            }

            si droite {
                droite.appartient_√†_fonction = vrai
            }

            // √Ä FAIRE : nous pouvons avoir une expression virgule alors que les fonctions doivent avoir un tableau
            // pour les param√®tres.
            arrow_params := aplatis_expression_et_d√©truit_virgules(gauche)

            concise_body := parseuse.cr√©e_concise_body(droite)
            retourne cr√©e_arrow_function(parseuse, lex√®me, arrow_params, concise_body)
        }
        OptionalChaining {
            parseuse.consomme()

            droite: *Expression

            si parseuse.apparie(GenreLex√®me.TemplateLiteral) {
                rapporte_erreur(parseuse, "template literals cannot be used on the right-hand side of an optional chain operator")
            }

            si parseuse.apparie(GenreLex√®me.Parenth√®seOuvrante) {
                parseuse.consomme()
                arguments := parse_expressions_s√©par√©es_par_des_virgules(parseuse, GenreLex√®me.Parenth√®seFermante)
                parseuse.consomme(GenreLex√®me.Parenth√®seFermante)
                retourne cr√©e_optional_call_expression(parseuse, lex√®me, gauche, arguments)
            }

            calcul√© := faux
            si parseuse.apparie(GenreLex√®me.CrochetOuvrant) {
                calcul√© = vrai
                parseuse.consomme()
                droite = parseuse.parse_expression(Param√®tresParsageExpression())
                parseuse.consomme(GenreLex√®me.CrochetFermant)
            }
            sinon si parseuse.apparie(GenreLex√®me.PrivateIdentifier) {
                lex√®me_identifier := parseuse.lex√®me_courant()
                parseuse.consomme()
                droite = cr√©e_private_identifier(parseuse, lex√®me_identifier)
            }
            sinon {
                droite = parseuse.parse_identifier_name()
            }

            retourne cr√©e_optional_member_expression(parseuse, lex√®me, gauche, droite, calcul√©)
        }
        sinon {}
    }

    retourne nul
}

aplatis_expression_et_d√©truit_virgules :: fonc (expression: *Expression) -> [..]*Expression
{
    r√©sultat: [..]*Expression

    si expression.type == ParenthesizedExpression {
        assert((expression comme *ParenthesizedExpression).expression == nul)
        d√©truit_arbre(expression)
        retourne r√©sultat
    }

    si expression.type == CommaExpression {
        aplatis_virgule(expression comme *CommaExpression, *r√©sultat)
        d√©truit_arbre(expression)
    }
    sinon {
        tableau_ajoute(*r√©sultat, expression)
    }

    retourne r√©sultat
}

aplatis_virgule :: fonc (virgule: *CommaExpression, r√©sultat: *[..]*Expression)
{
    si virgule.left.type == CommaExpression {
        aplatis_virgule(virgule.left comme *CommaExpression, r√©sultat)
    }
    sinon {
        tableau_ajoute(r√©sultat, virgule.left)
        virgule.left = nul
    }

    tableau_ajoute(r√©sultat, virgule.right)
    virgule.right = nul
}

parse_assignement_expression :: fonc (parseuse: *Parseuse, gauche: *Expression, op√©ration: AssignmentOperation, params: Param√®tresParsageExpression) -> *AssignmentExpression
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()
    expression := parseuse.parse_expression(params)
    retourne cr√©e_assignment_expression(parseuse, lex√®me, op√©ration, gauche, expression)
}

parse_expressions_s√©par√©es_par_des_virgules :: fonc (parseuse: *Parseuse, lex√®me_final: GenreLex√®me) -> [..]*Expression
{
    r√©sultat: [..]*Expression

    tantque !fini(parseuse) && !apparie(parseuse, lex√®me_final) {
        expr := parseuse.parse_expression(Param√®tresParsageExpression(lex√®me_final = GenreLex√®me.Virgule))

        tableau_ajoute(*r√©sultat, expr)

        saufsi parseuse.apparie(GenreLex√®me.Virgule) {
            arr√™te
        }

        parseuse.consomme()
    }
    retourne r√©sultat
}

donne_param√®tres_parsage_expression_pour_lex√®me_unaire :: fonc (genre: GenreLex√®me) -> Param√®tresParsageExpression
{
    infos := infos_lex√®mes_pour_parsage[genre]
    r√©sultat: Param√®tresParsageExpression
    r√©sultat.pr√©c√©dence = infos.pr√©c√©dence
    r√©sultat.associativit√© = infos.associativit√©
    retourne r√©sultat
}

parse_statement_list :: fonc (parseuse: *Parseuse) -> [..]*Statement
{
    statements: [..]*Statement

    tantque !fini(parseuse) && !apparie(parseuse, GenreLex√®me.AccoladeFermante) {
        statement := parseuse.parse_statement()
        saufsi statement {
            arr√™te
        }
        tableau_ajoute(*statements, statement)
    }

    retourne statements
}

parse_array_literal :: fonc (parseuse: *Parseuse, lex√®me: *Lex√®me) -> *ArrayLiteral
{
    parseuse.consomme()

    √©l√©ments: [..]*Expression

    tantque !fini(parseuse) && !apparie(parseuse, GenreLex√®me.CrochetFermant) {
        si parseuse.apparie(GenreLex√®me.Virgule) {
            parseuse.consomme()
            tableau_ajoute(*√©l√©ments, nul)
            continue
        }

        expr := parseuse.parse_expression(Param√®tresParsageExpression(lex√®me_final = GenreLex√®me.Virgule))

        tableau_ajoute(*√©l√©ments, expr)

        saufsi parseuse.apparie(GenreLex√®me.Virgule) {
            arr√™te
        }

        parseuse.consomme()
    }

    parseuse.consomme(GenreLex√®me.CrochetFermant)

    retourne cr√©e_array_literal(parseuse, lex√®me, √©l√©ments)
}

rapporte_erreur :: fonc (parseuse: *Parseuse, message: chaine)
{
    lex√®me := si parseuse.fini() {
        *parseuse.lex√®mes[parseuse.lex√®mes.taille - 1]
    }
    sinon {
        parseuse.lex√®me_courant()
    }

    rapporte_erreur(parseuse, lex√®me, message)
}

rapporte_erreur :: fonc (parseuse: *Parseuse, lex√®me: *Lex√®me, message: chaine)
{
    si parseuse.erreur_de_compilation {
        parseuse.consomme()
        retourne
    }

    position := donne_position_source(parseuse.source_text, m√©moire(lex√®me))

    erreur_de_compilation := cr√©e_erreur_de_compilation(parseuse.realm, message, position)
    parseuse.erreur_de_compilation = erreur_de_compilation
}
