importe Fondation
importe Structures

parse :: fonc (script: *Script) -> Résultat(*Programme, ErreurCompilation)
{
    saufsi script.lexèmes {
        retourne ErreurCompilation(message = copie_chaine("Le texte est vide"))
    }

    parseuse: Parseuse
    diffère détruit_données_parseuse(*parseuse)

    parseuse.script = script
    parseuse.lexèmes = script.lexèmes

    statements := parse_statement_list(*parseuse)

    si parseuse.possède_erreur {
        retourne parseuse.erreur_de_compilation
    }

    résultat := crée_programme(*parseuse, nul, statements)
    retourne résultat
}

Parseuse :: struct {
    script: *Script
    lexèmes: [..]Lexème
    position := 0
    erreur_de_compilation: ErreurCompilation
    possède_erreur: bool

    noeuds: [..]*NoeudSyntaxique
}

crée_noeud :: fonc (parseuse: *Parseuse, lexème: *Lexème, $T: type_de_données) -> *T
{
    résultat := loge(T)
    résultat.lexème = lexème
    tableau_ajoute(*parseuse.noeuds, résultat)
    retourne résultat
}

donne_parseuse_locale :: fonc (parseuse: *Parseuse) -> Parseuse
{
    résultat: Parseuse
    résultat.lexèmes = parseuse.lexèmes
    résultat.position = parseuse.position
    retourne résultat
}

détruit_données_parseuse :: fonc (parseuse: *Parseuse)
{
    déloge(parseuse.noeuds)
}

lexème_courant :: fonc (parseuse: *Parseuse) -> *Lexème
{
    retourne *parseuse.lexèmes[parseuse.position]
}

fini :: fonc (parseuse: *Parseuse) -> bool
{
    retourne parseuse.possède_erreur || parseuse.position >= parseuse.lexèmes.taille
}

consomme :: fonc (parseuse: *Parseuse)
{
    parseuse.position += 1
}

consomme :: fonc (parseuse: *Parseuse, genre_lexème: GenreLexème)
{
    saufsi apparie(parseuse, genre_lexème) {
        si genre_lexème == GenreLexème.ParenthèseOuvrante {
            parseuse.rapporte_erreur("expected a '('")
        }
        sinon si genre_lexème == GenreLexème.ParenthèseFermante {
            parseuse.rapporte_erreur("expected a ')'")
        }
        sinon si genre_lexème == GenreLexème.AccoladeOuvrante {
            parseuse.rapporte_erreur("expected a '{'")
        }
        sinon si genre_lexème == GenreLexème.AccoladeFermante {
            parseuse.rapporte_erreur("expected a '}'")
        }
        sinon si genre_lexème == GenreLexème.CrochetOuvrant {
            parseuse.rapporte_erreur("expected a '['")
        }
        sinon si genre_lexème == GenreLexème.CrochetFermant {
            parseuse.rapporte_erreur("expected a ']'")
        }
        sinon si genre_lexème == GenreLexème.PointVirgule {
            parseuse.rapporte_erreur("expected a ';'")
        }
        sinon si genre_lexème == GenreLexème.DoublePoint {
            parseuse.rapporte_erreur("expected a ':'")
        }
        sinon  {
            parseuse.rapporte_erreur("unexpected token")
        }
    }
    parseuse.consomme()
}

consomme_point_virgule_potentiel :: fonc (parseuse: *Parseuse)
{
    si parseuse.apparie(GenreLexème.PointVirgule) {
        parseuse.consomme()
    }
}

apparie :: fonc (parseuse: *Parseuse, genre_lexème: GenreLexème) -> bool
{
    si parseuse.fini() {
        retourne faux
    }
    retourne parseuse.lexème_courant().genre == genre_lexème
}

apparie_expression :: fonc (parseuse: *Parseuse) -> bool
{
    si parseuse.fini() {
        retourne faux
    }
    genre := parseuse.lexème_courant().genre
    drapeaux := données_lexèmes_pour_parsage[genre].drapeaux
    retourne drapeaux.EstExpression == vrai || drapeaux.EstExpressionUnaire == vrai
}

apparie_expression_unaire :: fonc (parseuse: *Parseuse) -> bool #enligne
{
    genre := parseuse.lexème_courant().genre
    si données_lexèmes_pour_parsage[genre].drapeaux.EstExpressionUnaire == vrai {
        retourne vrai
    }
    retourne faux
}

apparie_expression_secondaire :: fonc (parseuse: *Parseuse) -> bool #enligne
{
    si parseuse.fini() {
        retourne faux
    }
    genre := parseuse.lexème_courant().genre
    si données_lexèmes_pour_parsage[genre].drapeaux.EstExpressionSecondaire == vrai {
        retourne vrai
    }
    retourne faux
}

apparie_instruction :: fonc (parseuse: *Parseuse) -> bool #enligne
{
    si parseuse.fini() {
        retourne faux
    }
    genre := parseuse.lexème_courant().genre
    si données_lexèmes_pour_parsage[genre].drapeaux.EstInstruction == vrai {
        retourne vrai
    }
    retourne faux
}

parse_statement :: fonc (parseuse: *Parseuse) -> *Statement
{
    lexème := parseuse.lexème_courant()

    discr lexème.genre {
        Function {
            retourne parse_function_declaration(parseuse)
        }
        Return {
            retourne parse_return_statement(parseuse)
        }
        For {
            retourne parse_for_statement(parseuse)
        }
        While {
            retourne parse_while_statement(parseuse)
        }
        Do {
            retourne parse_do_while_statement(parseuse)
        }
        If {
            retourne parse_if_statement(parseuse)
        }
        Try {
            retourne parse_try_statement(parseuse)
        }
        Throw {
            retourne parse_throw_statement(parseuse)
        }
        Continue {
            retourne parse_continue_statement(parseuse)
        }
        Break {
            retourne parse_break_statement(parseuse)
        }
        Switch {
            retourne parse_switch_statement(parseuse)
        }
        AccoladeOuvrante {
            parseuse.consomme(GenreLexème.AccoladeOuvrante)
            statements := parse_statement_list(parseuse)
            parseuse.consomme(GenreLexème.AccoladeFermante)
            retourne crée_block_statement(parseuse, lexème, statements)
        }
        PointVirgule {
            parseuse.consomme()
            retourne crée_empty_statement(parseuse, lexème)
        }
        sinon {
            si parseuse.apparie_expression() {
                expression := parseuse.parse_expression(ParamètresParsageExpression())
                parseuse.consomme_point_virgule_potentiel()
                retourne crée_expression_statement(parseuse, lexème, expression)
            }

            rapporte_erreur(parseuse, "expected a statement")
        }
    }

    retourne nul
}

parse_function_declaration :: fonc (parseuse: *Parseuse) -> *FunctionDeclaration
{
    lexème := parseuse.lexème_courant()
    parseuse.consomme()

    id := parse_binding_identifier(parseuse, vrai)

    parseuse.consomme(GenreLexème.ParenthèseOuvrante)
    paramètres := parse_expressions_séparées_par_des_virgules(parseuse)
    parseuse.consomme(GenreLexème.ParenthèseFermante)

    body := parse_statement(parseuse)

    retourne crée_function_déclaration(parseuse, lexème, id, paramètres, body)
}

parse_function_expression :: fonc (parseuse: *Parseuse) -> *FunctionExpression
{
    lexème := parseuse.lexème_courant()
    parseuse.consomme()

    id := parse_binding_identifier(parseuse, faux)

    parseuse.consomme(GenreLexème.ParenthèseOuvrante)
    paramètres := parse_expressions_séparées_par_des_virgules(parseuse)
    parseuse.consomme(GenreLexème.ParenthèseFermante)

    body := parse_statement(parseuse)

    retourne crée_function_expression(parseuse, lexème, id, paramètres, body)
}

parse_variable_declaration :: fonc (parseuse: *Parseuse, nature: VariableDeclarationKind) -> *VariableDeclaration
{
    lexème := parseuse.lexème_courant()
    parseuse.consomme()

    declarators: [..]*VariableDeclarator

    tantque !fini(parseuse) {
        declarator := parse_variable_declarator(parseuse)
        saufsi declarator {
            déloge(declarators)
            retourne nul
        }

        tableau_ajoute(*declarators, declarator)

        si apparie(parseuse, GenreLexème.Virgule) {
            parseuse.consomme()
            continue
        }

        arrête
    }

    retourne crée_variable_declaration(parseuse, lexème, nature, declarators)
}

parse_variable_declarator :: fonc (parseuse: *Parseuse) -> *VariableDeclarator
{
    lexème := parseuse.lexème_courant()
    id := parse_binding_identifier(parseuse, vrai)

    init: *Expression
    si apparie(parseuse, GenreLexème.Égal) {
        parseuse.consomme()
        init = parseuse.parse_expression(ParamètresParsageExpression(lexème_final = GenreLexème.Virgule))
    }

    retourne crée_variable_declarator(parseuse, lexème, id, init)
}

parse_return_statement :: fonc (parseuse: *Parseuse) -> *ReturnStatement
{
    lexème := parseuse.lexème_courant()
    parseuse.consomme()

    argument: *Expression

    si parseuse.apparie_expression() {
        argument = parse_expression(parseuse, ParamètresParsageExpression())
    }

    retourne crée_return_statement(parseuse, lexème, argument)
}

TypeFor :: énum {
    Normal
    ForOf
    ForIn
}

détermine_type_for :: fonc (parseuse: *Parseuse) -> TypeFor
{
    parseuse_locale := parseuse.donne_parseuse_locale()

    tantque !fini(*parseuse_locale) {
        si apparie(*parseuse_locale, GenreLexème.Of) {
            retourne TypeFor.ForOf
        }
        si apparie(*parseuse_locale, GenreLexème.In) {
            retourne TypeFor.ForIn
        }
        si apparie(*parseuse_locale, GenreLexème.ParenthèseFermante) {
            arrête
        }

        consomme(*parseuse_locale)
    }

    retourne TypeFor.Normal
}

parse_for_statement :: fonc (parseuse: *Parseuse) -> *Statement
{
    lexème := parseuse.lexème_courant()
    parseuse.consomme()

    parseuse.consomme(GenreLexème.ParenthèseOuvrante)

    type_for := détermine_type_for(parseuse)

    si type_for != TypeFor.Normal {
        retourne parseuse.parse_for_of_in_statement(type_for)
    }

    init: *Expression
    si parseuse.apparie_expression() {
        init = parseuse.parse_expression(ParamètresParsageExpression())
    }
    parseuse.consomme(GenreLexème.PointVirgule)

    test: *Expression
    si parseuse.apparie_expression() {
        test = parseuse.parse_expression(ParamètresParsageExpression())
    }
    parseuse.consomme(GenreLexème.PointVirgule)

    update: *Expression
    si parseuse.apparie_expression() {
        update = parseuse.parse_expression(ParamètresParsageExpression())
    }
    parseuse.consomme(GenreLexème.ParenthèseFermante)

    body := parse_statement(parseuse)

    retourne crée_for_statement(parseuse, lexème, init, test, update, body)
}

parse_for_of_in_statement :: fonc (parseuse: *Parseuse, type_for: TypeFor) -> *Statement
{
    lexème := parseuse.lexème_courant()
    left := parseuse.parse_expression(ParamètresParsageExpression())

    si type_for == TypeFor.ForOf && !apparie(parseuse, GenreLexème.Of) {
        parseuse.rapporte_erreur("Attendu 'of'")
        retourne nul
    }
    si type_for == TypeFor.ForIn && !apparie(parseuse, GenreLexème.In) {
        parseuse.rapporte_erreur("Attendu 'in'")
        retourne nul
    }

    /* Consomme in/of */
    parseuse.consomme()

    right := parseuse.parse_expression(ParamètresParsageExpression())

    parseuse.consomme(GenreLexème.ParenthèseFermante)

    body := parseuse.parse_statement()

    si type_for == TypeFor.ForIn {
        retourne crée_for_in_statement(parseuse, lexème, left, right, body)
    }

    retourne crée_for_of_statement(parseuse, lexème, left, right, body)
}

parse_while_statement :: fonc (parseuse: *Parseuse) -> *WhileStatement
{
    lexème := parseuse.lexème_courant()
    parseuse.consomme()

    parseuse.consomme(GenreLexème.ParenthèseOuvrante)
    test := parseuse.parse_expression(ParamètresParsageExpression())
    parseuse.consomme(GenreLexème.ParenthèseFermante)

    body := parse_statement(parseuse)

    retourne crée_while_statement(parseuse, lexème, test, body)
}

parse_do_while_statement :: fonc (parseuse: *Parseuse) -> *DoWhileStatement
{
    lexème := parseuse.lexème_courant()
    parseuse.consomme()
    
    body := parse_statement(parseuse)

    parseuse.consomme(GenreLexème.While)
    parseuse.consomme(GenreLexème.ParenthèseOuvrante)
    test := parseuse.parse_expression(ParamètresParsageExpression())
    parseuse.consomme(GenreLexème.ParenthèseFermante)

    retourne crée_do_while_statement(parseuse, lexème, body, test)
}

parse_if_statement :: fonc (parseuse: *Parseuse) -> *IfStatement
{
    lexème := parseuse.lexème_courant()
    parseuse.consomme()

    parseuse.consomme(GenreLexème.ParenthèseOuvrante)

    test := parseuse.parse_expression(ParamètresParsageExpression())

    parseuse.consomme(GenreLexème.ParenthèseFermante)

    consequent := parseuse.parse_statement()

    consomme_point_virgule_potentiel(parseuse)

    alternate: *Statement
    si parseuse.apparie(GenreLexème.Else) {
        parseuse.consomme()
        alternate = parseuse.parse_statement()
    }

    retourne crée_if_statement(parseuse, lexème, test, consequent, alternate)
}

parse_try_statement :: fonc (parseuse: *Parseuse) -> *TryStatement
{
    lexème := parseuse.lexème_courant()
    parseuse.consomme()

    block := parse_statement(parseuse)

    handler: *CatchClause
    si parseuse.apparie(GenreLexème.Catch) {
        lexème_catch := parseuse.lexème_courant()
        parseuse.consomme()

        param: *Expression
        si parseuse.apparie(GenreLexème.ParenthèseOuvrante) {
            parseuse.consomme()

            param = parseuse.parse_expression(ParamètresParsageExpression())

            parseuse.consomme(GenreLexème.ParenthèseFermante)
        }

        body := parse_statement(parseuse)

        handler = crée_catch_clause(parseuse, lexème_catch, param, body)
    }

    finalizer: *Statement
    si parseuse.apparie(GenreLexème.Finally) {
        parseuse.consomme()
        finalizer = parse_statement(parseuse)
    }

    retourne crée_try_statement(parseuse, lexème, block, handler, finalizer)
}

parse_throw_statement :: fonc (parseuse: *Parseuse) -> *ThrowStatement
{
    lexème := parseuse.lexème_courant()
    parseuse.consomme()
    argument := parse_expression(parseuse, ParamètresParsageExpression())
    retourne crée_throw_statement(parseuse, lexème, argument)
}

parse_continue_statement :: fonc (parseuse: *Parseuse) -> *ContinueStatement
{
    lexème := parseuse.lexème_courant()
    parseuse.consomme()
    target := parse_label_identifier(parseuse, faux)
    retourne crée_continue_statement(parseuse, lexème, target)
}

parse_break_statement :: fonc (parseuse: *Parseuse) -> *BreakStatement
{
    lexème := parseuse.lexème_courant()
    parseuse.consomme()
    target := parse_label_identifier(parseuse, faux)
    retourne crée_break_statement(parseuse, lexème, target)
}

parse_switch_statement :: fonc (parseuse: *Parseuse) -> *SwitchStatement
{
    lexème := parseuse.lexème_courant()
    parseuse.consomme()

    parseuse.consomme(GenreLexème.ParenthèseOuvrante)
    discriminant := parseuse.parse_expression(ParamètresParsageExpression())
    parseuse.consomme(GenreLexème.ParenthèseFermante)

    parseuse.consomme(GenreLexème.AccoladeOuvrante)
    cases: [..]*CaseClause
    index_default_clause : z64 = -1

    tantque !parseuse.fini() {
        si apparie(parseuse, GenreLexème.Case) {
            case := parseuse.parse_case_clause()
            tableau_ajoute(*cases, case)
            continue
        }

        si apparie(parseuse, GenreLexème.Default) {
            si index_default_clause != -1 {
                parseuse.rapporte_erreur("duplicate default case")
                arrête
            }

            case := parseuse.parse_default_clause()
            index_default_clause = cases.taille
            tableau_ajoute(*cases, case)
            continue
        }

        arrête
    }

    parseuse.consomme(GenreLexème.AccoladeFermante)

    retourne crée_switch_statement(parseuse, lexème, discriminant, cases, index_default_clause)
}

parse_case_clause :: fonc (parseuse: *Parseuse) -> *CaseClause
{
    lexème := parseuse.lexème_courant()
    parseuse.consomme()

    test := parseuse.parse_expression(ParamètresParsageExpression())
    parseuse.consomme(GenreLexème.DoublePoint)

    consequent := parse_statement_list_case(parseuse)

    retourne crée_case_clause(parseuse, lexème, test, consequent)
}

parse_default_clause :: fonc (parseuse: *Parseuse) -> *DefaultClause
{
    lexème := parseuse.lexème_courant()
    parseuse.consomme()
    parseuse.consomme(GenreLexème.DoublePoint)

    consequent := parse_statement_list_case(parseuse)

    retourne crée_default_clause(parseuse, lexème, consequent)
}

parse_statement_list_case :: fonc (parseuse: *Parseuse) -> *Statement
{
    si parseuse.apparie(GenreLexème.AccoladeOuvrante) {
        retourne parseuse.parse_statement()
    }

    statements: [..]*Statement

    tantque !fini(parseuse) && !apparie(parseuse, GenreLexème.AccoladeFermante) && !apparie(parseuse, GenreLexème.Case) && !apparie(parseuse, GenreLexème.Default) {
        statement := parse_statement(parseuse)
        saufsi statement {
            arrête
        }
        tableau_ajoute(*statements, statement)
    }

    retourne crée_block_statement(parseuse, nul, statements)
}

ParamètresParsageExpression :: struct {
    précédence : z32 = 0
    associativité : Associativité = Associativité.Gauche
    lexème_final := GenreLexème.PointVirgule
}

parse_expression :: fonc (parseuse: *Parseuse, params: ParamètresParsageExpression) -> *Expression
{
    saufsi parseuse.apparie_expression() {
        parseuse.rapporte_erreur("Attendu une expression primaire")
        retourne nul
    }

    expression := parseuse.parse_expression_primaire()

    tantque !parseuse.fini() && parseuse.apparie_expression_secondaire() && !apparie(parseuse, params.lexème_final) {
        données := données_lexèmes_pour_parsage[parseuse.lexème_courant().genre]

        nouvelle_précédence := données.précédence

        si nouvelle_précédence < params.précédence {
            arrête
        }

        si nouvelle_précédence == params.précédence && params.associativité == Associativité.Gauche {
            arrête
        }

        nouveau_params := params
        nouveau_params.précédence = nouvelle_précédence
        nouveau_params.associativité = données.associativité

        expression = parseuse.parse_expression_secondaire(expression, nouveau_params)
    }

    retourne expression
}

parse_expression_primaire :: fonc (parseuse: *Parseuse) -> *Expression
{
    lexème := parseuse.lexème_courant()

    si parseuse.apparie_expression_unaire() {
        retourne parseuse.parse_expression_unaire()
    }

    discr lexème.genre {
        ChaineLittérale {
            parseuse.consomme()
            retourne crée_literal(parseuse, lexème, lexème.texte)
        }
        NombreLittéral {
            parseuse.consomme()
            valeur := parse_nombre_depuis_lexème(lexème)
            retourne crée_literal(parseuse, lexème, valeur)
        }
        True {
            parseuse.consomme()
            retourne crée_boolean_literal(parseuse, lexème, vrai)
        }
        False {
            parseuse.consomme()
            retourne crée_boolean_literal(parseuse, lexème, faux)
        }
        Null {
            parseuse.consomme()
            retourne crée_null_literal(parseuse, lexème)
        }
        This {
            parseuse.consomme()
            retourne crée_this_expression(parseuse, lexème)
        }
        Identifiant {
            parseuse.consomme()
            retourne crée_identifier(parseuse, lexème, lexème.texte)
        }
        ParenthèseOuvrante {
            parseuse.consomme()

            expression := parseuse.parse_expression(ParamètresParsageExpression())

            parseuse.consomme(GenreLexème.ParenthèseFermante)
            retourne expression
        }
        AccoladeOuvrante {
            parseuse.consomme()

            properties: [..]*PropertyDefinition

            tantque !fini(parseuse) {
                si apparie(parseuse, GenreLexème.AccoladeFermante) {
                    arrête
                }

                nom_membre := parse_identifier_reference(parseuse)

                lexème_déf := parseuse.lexème_courant()
                parseuse.consomme(GenreLexème.DoublePoint)

                expression := parseuse.parse_expression(ParamètresParsageExpression(lexème_final = GenreLexème.Virgule))

                property := crée_property_definition(parseuse, lexème_déf, nom_membre, expression)
                tableau_ajoute(*properties, property)

                saufsi apparie(parseuse, GenreLexème.Virgule) {
                    arrête
                }

                parseuse.consomme()
            }

            parseuse.consomme(GenreLexème.AccoladeFermante)

            retourne crée_object_expression(parseuse, lexème, properties)
        }
        CrochetOuvrant {
            parseuse.consomme()

            éléments := parse_expressions_séparées_par_des_virgules(parseuse)

            parseuse.consomme(GenreLexème.CrochetFermant)

            retourne crée_array_literal(parseuse, lexème, éléments)
        }
        Let {
            retourne parse_variable_declaration(parseuse, VariableDeclarationKind.Let)
        }
        Var {
            retourne parse_variable_declaration(parseuse, VariableDeclarationKind.Var)
        }
        Const {
            retourne parse_variable_declaration(parseuse, VariableDeclarationKind.Const)
        }
        Function {
            retourne parse_function_expression(parseuse)
        }
        sinon {
            parseuse.rapporte_erreur("lexème non géré dans parse_expression_primaire")
        }
    }

    retourne nul
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#prod-IdentifierReference */
parse_identifier_reference :: fonc (parseuse: *Parseuse) -> *Identifier
{
    retourne parse_identifiant_yield_ou_await(parseuse, vrai)
}

parse_binding_identifier :: fonc (parseuse: *Parseuse, émets_erreur_si_manquant: bool) -> *Identifier
{
    retourne parse_identifiant_yield_ou_await(parseuse, émets_erreur_si_manquant)
}

parse_label_identifier :: fonc (parseuse: *Parseuse, émets_erreur_si_manquant: bool) -> *Identifier
{
    retourne parse_identifiant_yield_ou_await(parseuse, émets_erreur_si_manquant)
}

parse_identifier :: fonc (parseuse: *Parseuse, émets_erreur_si_manquant: bool) -> *Identifier
{
    lexème := parseuse.lexème_courant()

    si apparie_lexème_identifier(parseuse) {
        parseuse.consomme()
        retourne crée_identifier(parseuse, lexème, lexème.texte)
    }

    si émets_erreur_si_manquant {
        parseuse.rapporte_erreur("expected an identifier")
    }
    retourne nul
}

apparie_lexème_identifier :: fonc (parseuse: *Parseuse) -> bool
{
    lexème := parseuse.lexème_courant()

    // as, async, from, get, meta, of, set, and target
    lexèmes_autorisés := [GenreLexème.Identifiant, GenreLexème.As, GenreLexème.Async, GenreLexème.From, GenreLexème.Get, GenreLexème.Meta, GenreLexème.Of, GenreLexème.Set, GenreLexème.Target]
    pour lexèmes_autorisés {
        si lexème.genre == it {
            retourne vrai
        }
    }
    retourne faux
}

apparie_lexème_identifier_property :: fonc (parseuse: *Parseuse) -> bool
{
    si apparie_lexème_identifier(parseuse) {
        retourne vrai
    }
    si apparie(parseuse, GenreLexème.Delete) {
        retourne vrai
    }
    retourne faux
}

parse_identifiant_yield_ou_await :: fonc (parseuse: *Parseuse, émets_erreur_si_manquant: bool) -> *Identifier
{
    lexème := parseuse.lexème_courant()

    si lexème.genre == GenreLexème.Yield {
        parseuse.consomme()
        retourne crée_identifier(parseuse, lexème, lexème.texte)
    }

    si lexème.genre == GenreLexème.Await {
        parseuse.consomme()
        retourne crée_identifier(parseuse, lexème, lexème.texte)
    }

    retourne parse_identifier(parseuse, émets_erreur_si_manquant)
}

donne_opération_binaire_pour_genre_lexème :: fonc (genre: GenreLexème) -> BinaryOperation
{
    discr genre {
        Plus {
            retourne BinaryOperation.Plus
        }
        Moins {
            retourne BinaryOperation.Moins
        }
        Étoile {
            retourne BinaryOperation.Multiplie
        }
        Slash {
            retourne BinaryOperation.Divise
        }
        Pourcent {
            retourne BinaryOperation.Modulo
        }
        OuExclusif {
            retourne BinaryOperation.OuExclusif
        }
        sinon {
            panique("genre opérateur non-géré")
        }
    }

    retourne BinaryOperation.Plus
}

donne_opération_égalitaire_pour_genre_lexème :: fonc (genre: GenreLexème) -> EqualityOperation
{
    discr genre {
        EstÉgal {
            retourne EqualityOperation.Égal
        }
        NEspaPasÉgal {
            retourne EqualityOperation.Inégal
        }
        EstÉgalStrict {
            retourne EqualityOperation.ÉgalStrict
        }
        NEspaPasÉgalStrict {
            retourne EqualityOperation.InégalStrict
        }
        sinon {
            panique("genre opérateur non-géré")
        }
    }
    retourne EqualityOperation.Égal
}

donne_opération_relationnelle_pour_genre_lexème :: fonc (genre: GenreLexème) -> RelationalOperation
{
    discr genre {
        Inférieur {
            retourne RelationalOperation.Inférieur
        }
        Supérieur {
            retourne RelationalOperation.Supérieur
        }
        InférieurÉgal {
            retourne RelationalOperation.InférieurÉgal
        }
        SupérieurÉgal {
            retourne RelationalOperation.SupérieurÉgal
        }
        sinon {
            panique("genre opérateur non-géré")
        }
    }

    retourne RelationalOperation.Inférieur
}

parse_expression_secondaire :: fonc (parseuse: *Parseuse, gauche: *Expression, params: ParamètresParsageExpression) -> *Expression
{
    lexème := parseuse.lexème_courant()

    discr lexème.genre {
        Plus,
        Moins,
        Étoile,
        Slash,
        Pourcent,
        OuExclusif {
            opération := donne_opération_binaire_pour_genre_lexème(lexème.genre)
            parseuse.consomme()
            opérande_droite := parseuse.parse_expression(params)
            retourne crée_binary_expression(parseuse, lexème, opération, gauche, opérande_droite)
        }
        Inférieur,
        Supérieur,
        InférieurÉgal,
        SupérieurÉgal {
            opération := donne_opération_relationnelle_pour_genre_lexème(lexème.genre)
            parseuse.consomme()
            opérande_droite := parseuse.parse_expression(params)
            retourne crée_relational_expression(parseuse, lexème, opération, gauche, opérande_droite)
        }
        EstÉgal,
        NEspaPasÉgal,
        EstÉgalStrict,
        NEspaPasÉgalStrict {
            opération := donne_opération_égalitaire_pour_genre_lexème(lexème.genre)
            parseuse.consomme()
            opérande_droite := parseuse.parse_expression(params)
            retourne crée_equality_expression(parseuse, lexème, opération, gauche, opérande_droite)
        }
        PlusPlus,
        MoinsMoins {
            parseuse.consomme()

            operation := si lexème.genre == GenreLexème.PlusPlus { UpdateOperation.PostfixIncrement } sinon { UpdateOperation.PostfixDecrement }
            update := crée_update_expression(parseuse, lexème, gauche, operation)

            si parseuse.apparie_expression_secondaire() {
                retourne parseuse.parse_expression_secondaire(update, params)
            }

            retourne update
        }
        Égal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.Assigne, params)
        }
        PlusÉgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.Ajoute, params)
        }
        MoinsÉgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.Soustrait, params)
        }
        ÉtoileÉgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.Multiplie, params)
        }
        SlashÉgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.Divise, params)
        }
        PourcentÉgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.Modulo, params)
        }
        DécalageGaucheÉgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.DécalageGauche, params)
        }
        DécalageDroiteÉgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.DécalageDroite, params)
        }
        EtBinaireÉgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.EtBinaire, params)
        }
        OuBinaireÉgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.OuBinaire, params)
        }
        OuExclusifÉgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.OuExBinaire, params)
        }
        Point {
            parseuse.consomme()

            saufsi apparie_lexème_identifier_property(parseuse) {
                parseuse.rapporte_erreur("Attendu un identifiant après '.'")
                retourne nul
            }

            lexème_ident := parseuse.lexème_courant()
            parseuse.consomme()

            propriété := crée_identifier(parseuse, lexème_ident, lexème_ident.texte)
            retourne crée_member_expression(parseuse, lexème, gauche, propriété, faux)
        }
        ParenthèseOuvrante {
            parseuse.consomme()

            arguments := parse_expressions_séparées_par_des_virgules(parseuse)

            parseuse.consomme(GenreLexème.ParenthèseFermante)

            retourne crée_call_expression(parseuse, lexème, gauche, arguments)
        }
        CrochetOuvrant {
            parseuse.consomme()

            propriété := parseuse.parse_expression(ParamètresParsageExpression())

            parseuse.consomme(GenreLexème.CrochetFermant)

            retourne crée_member_expression(parseuse, lexème, gauche, propriété, vrai)
        }
        EtLogique {
            parseuse.consomme()
            droite := parseuse.parse_expression(params)
            retourne crée_logical_and(parseuse, lexème, gauche, droite)
        }
        OuLogique {
            parseuse.consomme()
            droite := parseuse.parse_expression(params)
            retourne crée_logical_or(parseuse, lexème, gauche, droite)
        }
        Interrogation {
            parseuse.consomme()

            consequent := parseuse.parse_expression(params)
            parseuse.consomme(GenreLexème.DoublePoint)

            alternate := parseuse.parse_expression(params)
            retourne crée_conditionnal_expression(parseuse, lexème, gauche, consequent, alternate)
        }
        Virgule {
            parseuse.consomme()
            droite := parseuse.parse_expression(params)
            retourne crée_comma_expression(parseuse, lexème, gauche, droite)
        }
        sinon {
            rapporte_erreur(parseuse, lexème, "Genre de lexème non géré dans parse_expression_secondaire\n")
        }
    }

    retourne nul
}

parse_assignement_expression :: fonc (parseuse: *Parseuse, gauche: *Expression, opération: AssignmentOperation, params: ParamètresParsageExpression) -> *AssignmentExpression
{
    lexème := parseuse.lexème_courant()
    parseuse.consomme()
    expression := parseuse.parse_expression(params)
    retourne crée_assignment_expression(parseuse, lexème, opération, gauche, expression)
}

parse_expressions_séparées_par_des_virgules :: fonc (parseuse: *Parseuse) -> [..]*Expression
{
    résultat: [..]*Expression
    /* Permet de ne pas avoir d'expression pour que, par exemple, le parsage des parenthèses
     * d'expressions d'appels vides n'est pas à le vérifier. */
    saufsi apparie_expression(parseuse) {
        retourne résultat
    }

    tantque !fini(parseuse) {
        expr := parseuse.parse_expression(ParamètresParsageExpression(lexème_final = GenreLexème.Virgule))

        tableau_ajoute(*résultat, expr)

        saufsi parseuse.apparie(GenreLexème.Virgule) {
            arrête
        }

        parseuse.consomme()
    }
    retourne résultat
}

parse_expression_unaire :: fonc (parseuse: *Parseuse) -> *Expression
{
    lexème := parseuse.lexème_courant()

    discr lexème.genre {
        Plus {
            parseuse.consomme()
            argument := parseuse.parse_expression_primaire()
            retourne crée_unary_plus_operator(parseuse, lexème, argument)
        }
        Moins {
            parseuse.consomme()
            argument := parseuse.parse_expression_primaire()
            retourne crée_unary_minus_operator(parseuse, lexème, argument)
        }
        NonBinaire {
            parseuse.rapporte_erreur("opérateur unaire non-géré")
        }
        NonLogique {
            parseuse.consomme()
            argument := parseuse.parse_expression_primaire()
            retourne crée_logical_not(parseuse, lexème, argument)
        }
        PlusPlus,
        MoinsMoins {
            parseuse.consomme()
            argument := parseuse.parse_expression_primaire()
            operation := si lexème.genre == GenreLexème.PlusPlus { UpdateOperation.PrefixIncrement } sinon { UpdateOperation.PrefixDecrement }
            retourne crée_update_expression(parseuse, lexème, argument, operation)
        }
        Typeof {
            parseuse.consomme()
            argument := parseuse.parse_expression_primaire()
            retourne crée_typeof_operator(parseuse, lexème, argument)
        }
        New {
            parseuse.consomme()
            données := données_lexèmes_pour_parsage[GenreLexème.New]
            params: ParamètresParsageExpression
            params.précédence = données.précédence
            params.associativité = données.associativité
            params.lexème_final = GenreLexème.Point
            argument := parseuse.parse_expression(params)
            retourne crée_new_expression(parseuse, lexème, argument);
        }
        sinon {
            parseuse.rapporte_erreur("genre de lexème non géré dans parse_expression_unaire")
        }
    }

    retourne nul
}

parse_statement_list :: fonc (parseuse: *Parseuse) -> [..]*Statement
{
    statements: [..]*Statement

    tantque !fini(parseuse) && !apparie(parseuse, GenreLexème.AccoladeFermante) {
        statement := parseuse.parse_statement()
        saufsi statement {
            arrête
        }
        tableau_ajoute(*statements, statement)
    }

    retourne statements
}

rapporte_erreur :: fonc (parseuse: *Parseuse, message: chaine)
{
    lexème := si parseuse.fini() {
        *parseuse.lexèmes[parseuse.lexèmes.taille - 1]
    }
    sinon {
        parseuse.lexème_courant()
    }

    rapporte_erreur(parseuse, lexème, message)
}

rapporte_erreur :: fonc (parseuse: *Parseuse, lexème: *Lexème, message: chaine)
{
    si parseuse.possède_erreur {
        parseuse.consomme()
        retourne
    }

    position := donne_position_source(parseuse.script.source, mémoire(lexème))

    erreur_de_compilation := crée_erreur_de_compilation("Erreur de parsage", message, position)
    parseuse.erreur_de_compilation = erreur_de_compilation
    parseuse.possède_erreur = vrai
}
