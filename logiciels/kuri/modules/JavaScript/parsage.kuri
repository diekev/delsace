importe Chaine
importe Fondation
importe Structures

parse :: fonc (realm: *Realm, source_text: *TexteSource, goal_symbol: GoalSymbol) -> R√©sultat(*NoeudSyntaxique, *SyntaxError)
{
    parseuse: Parseuse
    diff√®re d√©truit_donn√©es_parseuse(*parseuse)

    parseuse.realm = realm
    parseuse.source_text = source_text
    parseuse.lex√®mes = source_text.lex√®mes

    r√©sultat: *NoeudSyntaxique

    discr goal_symbol {
        Script {
            r√©sultat = parse_script(*parseuse)
        }
        StringNumericLiteral {
            /* A StringNumericLiteral that is empty or contains only white space is converted to +0ùîΩ. */
            si source_text.lex√®mes.taille == 0 {
                r√©sultat = cr√©e_literal(*parseuse, nul, 0.0)
            }
            sinon {
                r√©sultat = parse_expression(*parseuse, Param√®tresParsageExpression())
                si r√©sultat.type != NumericLiteral {
                    rapporte_erreur(*parseuse, "expected a numeric literal")
                }
            }
        }
        FunctionBody {
            r√©sultat = parse_function_body(*parseuse)
        }
    }

    si parseuse.erreur_de_compilation {
        d√©truit_arbre(r√©sultat)
        retourne parseuse.erreur_de_compilation
    }

    retourne r√©sultat
}

Parseuse :: struct {
    realm: *Realm
    source_text: *TexteSource
    lex√®mes: [..]Lex√®me
    position := 0
    erreur_de_compilation: *SyntaxError

    noeuds: [..]*NoeudSyntaxique
}

cr√©e_noeud :: fonc (parseuse: *Parseuse, lex√®me: *Lex√®me, $T: type_de_donn√©es) -> *T
{
    r√©sultat := loge(T)
    r√©sultat.lex√®me = lex√®me
    tableau_ajoute(*parseuse.noeuds, r√©sultat)
    retourne r√©sultat
}

donne_parseuse_locale :: fonc (parseuse: *Parseuse) -> Parseuse
{
    r√©sultat: Parseuse
    r√©sultat.lex√®mes = parseuse.lex√®mes
    r√©sultat.position = parseuse.position
    retourne r√©sultat
}

d√©truit_donn√©es_parseuse :: fonc (parseuse: *Parseuse)
{
    d√©loge(parseuse.noeuds)
}

lex√®me_courant :: fonc (parseuse: *Parseuse) -> *Lex√®me
{
    retourne *parseuse.lex√®mes[parseuse.position]
}

fini :: fonc (parseuse: *Parseuse) -> bool
{
    retourne parseuse.erreur_de_compilation != nul || parseuse.position >= parseuse.lex√®mes.taille
}

consomme :: fonc (parseuse: *Parseuse)
{
    parseuse.position += 1
}

consomme :: fonc (parseuse: *Parseuse, genre_lex√®me: GenreLex√®me)
{
    saufsi apparie(parseuse, genre_lex√®me) {
        si genre_lex√®me == GenreLex√®me.Parenth√®seOuvrante {
            parseuse.rapporte_erreur("expected a '('")
        }
        sinon si genre_lex√®me == GenreLex√®me.Parenth√®seFermante {
            parseuse.rapporte_erreur("expected a ')'")
        }
        sinon si genre_lex√®me == GenreLex√®me.AccoladeOuvrante {
            parseuse.rapporte_erreur("expected a '{'")
        }
        sinon si genre_lex√®me == GenreLex√®me.AccoladeFermante {
            parseuse.rapporte_erreur("expected a '}'")
        }
        sinon si genre_lex√®me == GenreLex√®me.CrochetOuvrant {
            parseuse.rapporte_erreur("expected a '['")
        }
        sinon si genre_lex√®me == GenreLex√®me.CrochetFermant {
            parseuse.rapporte_erreur("expected a ']'")
        }
        sinon si genre_lex√®me == GenreLex√®me.PointVirgule {
            parseuse.rapporte_erreur("expected a ';'")
        }
        sinon si genre_lex√®me == GenreLex√®me.DoublePoint {
            parseuse.rapporte_erreur("expected a ':'")
        }
        sinon  {
            parseuse.rapporte_erreur("unexpected token")
        }
    }
    parseuse.consomme()
}

consomme_point_virgule_potentiel :: fonc (parseuse: *Parseuse)
{
    si parseuse.apparie(GenreLex√®me.PointVirgule) {
        parseuse.consomme()
    }
}

apparie :: fonc (parseuse: *Parseuse, genre_lex√®me: GenreLex√®me) -> bool
{
    si parseuse.fini() {
        retourne faux
    }
    retourne parseuse.lex√®me_courant().genre == genre_lex√®me
}

apparie_expression :: fonc (parseuse: *Parseuse) -> bool
{
    si parseuse.fini() {
        retourne faux
    }
    genre := parseuse.lex√®me_courant().genre
    drapeaux := donn√©es_lex√®mes_pour_parsage[genre].drapeaux
    retourne drapeaux.EstExpression == vrai || drapeaux.EstExpressionUnaire == vrai
}

apparie_expression_secondaire :: fonc (parseuse: *Parseuse) -> bool #enligne
{
    si parseuse.fini() {
        retourne faux
    }
    genre := parseuse.lex√®me_courant().genre
    si donn√©es_lex√®mes_pour_parsage[genre].drapeaux.EstExpressionSecondaire == vrai {
        retourne vrai
    }
    retourne faux
}

parse_script :: fonc (parseuse: *Parseuse) -> *NoeudScript
{
    script_body: *ScriptBody
    statements := parse_statement_list(parseuse)

    si statements.taille != 0 {
        script_body = cr√©e_script_body(parseuse, statements)
    }

    retourne cr√©e_script(parseuse, script_body)
}

parse_statement :: fonc (parseuse: *Parseuse) -> *Statement
{
    lex√®me := parseuse.lex√®me_courant()

    discr lex√®me.genre {
        Function {
            retourne parse_function_declaration(parseuse)
        }
        Return {
            retourne parse_return_statement(parseuse)
        }
        For {
            retourne parse_for_statement(parseuse)
        }
        While {
            retourne parse_while_statement(parseuse)
        }
        Do {
            retourne parse_do_while_statement(parseuse)
        }
        If {
            retourne parse_if_statement(parseuse)
        }
        Try {
            retourne parse_try_statement(parseuse)
        }
        Throw {
            retourne parse_throw_statement(parseuse)
        }
        Continue {
            retourne parse_continue_statement(parseuse)
        }
        Break {
            retourne parse_break_statement(parseuse)
        }
        Switch {
            retourne parse_switch_statement(parseuse)
        }
        Debugger {
            parseuse.consomme()
            parseuse.consomme_point_virgule_potentiel()
            retourne cr√©e_debugger_statement(parseuse, lex√®me)
        }
        AccoladeOuvrante {
            parseuse.consomme(GenreLex√®me.AccoladeOuvrante)
            statements := parse_statement_list(parseuse)
            parseuse.consomme(GenreLex√®me.AccoladeFermante)
            retourne cr√©e_block_statement(parseuse, lex√®me, statements)
        }
        PointVirgule {
            parseuse.consomme()
            retourne cr√©e_empty_statement(parseuse, lex√®me)
        }
        sinon {
            sauvegarde := parseuse.position
            label_identifier := parse_label_identifier(parseuse, faux)
            si label_identifier {
                si parseuse.apparie(GenreLex√®me.DoublePoint) {
                    parseuse.consomme()

                    statement := parse_statement(parseuse)

                    retourne cr√©e_labelled_statement(parseuse, lex√®me, label_identifier.nom, statement)
                }

                parseuse.position = sauvegarde
            }

            si parseuse.apparie_expression() {
                expression := parseuse.parse_expression(Param√®tresParsageExpression())
                parseuse.consomme_point_virgule_potentiel()
                retourne cr√©e_expression_statement(parseuse, lex√®me, expression)
            }

            rapporte_erreur(parseuse, "expected a statement")
        }
    }

    retourne nul
}

parse_function_declaration :: fonc (parseuse: *Parseuse) -> *FunctionDeclaration
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()

    id := parse_binding_identifier(parseuse, vrai)

    parseuse.consomme(GenreLex√®me.Parenth√®seOuvrante)
    param√®tres := parse_expressions_s√©par√©es_par_des_virgules(parseuse)
    parseuse.consomme(GenreLex√®me.Parenth√®seFermante)

    body := parse_function_body(parseuse)

    retourne cr√©e_function_d√©claration(parseuse, lex√®me, id, param√®tres, body)
}

parse_function_expression :: fonc (parseuse: *Parseuse) -> *FunctionExpression
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()

    id := parse_binding_identifier(parseuse, faux)

    parseuse.consomme(GenreLex√®me.Parenth√®seOuvrante)
    param√®tres := parse_expressions_s√©par√©es_par_des_virgules(parseuse)
    parseuse.consomme(GenreLex√®me.Parenth√®seFermante)

    body := parse_function_body(parseuse)

    retourne cr√©e_function_expression(parseuse, lex√®me, id, param√®tres, body)
}

parse_function_body :: fonc (parseuse: *Parseuse) -> *FunctionBody
{
    statement := parse_statement(parseuse)
    si statement {
        statement.appartient_√†_fonction = vrai
    }
    retourne cr√©e_function_body(parseuse, statement)
}

parse_variable_declaration :: fonc (parseuse: *Parseuse, nature: VariableDeclarationKind) -> *VariableDeclaration
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()

    declarators: [..]*VariableDeclarator

    tantque !fini(parseuse) {
        declarator := parse_variable_declarator(parseuse)
        saufsi declarator {
            d√©loge(declarators)
            retourne nul
        }

        tableau_ajoute(*declarators, declarator)

        si apparie(parseuse, GenreLex√®me.Virgule) {
            parseuse.consomme()
            continue
        }

        arr√™te
    }

    retourne cr√©e_variable_declaration(parseuse, lex√®me, nature, declarators)
}

parse_variable_declarator :: fonc (parseuse: *Parseuse) -> *VariableDeclarator
{
    lex√®me := parseuse.lex√®me_courant()
    id := parse_binding_identifier(parseuse, vrai)

    init: *Expression
    si apparie(parseuse, GenreLex√®me.√âgal) {
        parseuse.consomme()
        init = parseuse.parse_expression(Param√®tresParsageExpression(lex√®me_final = GenreLex√®me.Virgule))
    }

    retourne cr√©e_variable_declarator(parseuse, lex√®me, id, init)
}

parse_return_statement :: fonc (parseuse: *Parseuse) -> *ReturnStatement
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()

    argument: *Expression

    si parseuse.apparie_expression() {
        argument = parse_expression(parseuse, Param√®tresParsageExpression())
    }

    retourne cr√©e_return_statement(parseuse, lex√®me, argument)
}

TypeFor :: √©num {
    Normal
    ForOf
    ForIn
}

d√©termine_type_for :: fonc (parseuse: *Parseuse) -> TypeFor
{
    parseuse_locale := parseuse.donne_parseuse_locale()

    tantque !fini(*parseuse_locale) {
        si apparie(*parseuse_locale, GenreLex√®me.Of) {
            retourne TypeFor.ForOf
        }
        si apparie(*parseuse_locale, GenreLex√®me.In) {
            retourne TypeFor.ForIn
        }
        si apparie(*parseuse_locale, GenreLex√®me.Parenth√®seFermante) {
            arr√™te
        }

        consomme(*parseuse_locale)
    }

    retourne TypeFor.Normal
}

parse_for_statement :: fonc (parseuse: *Parseuse) -> *Statement
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()

    parseuse.consomme(GenreLex√®me.Parenth√®seOuvrante)

    type_for := d√©termine_type_for(parseuse)

    si type_for != TypeFor.Normal {
        retourne parseuse.parse_for_of_in_statement(type_for)
    }

    init: *Expression
    saufsi parseuse.apparie(GenreLex√®me.PointVirgule) {
        init = parseuse.parse_expression(Param√®tresParsageExpression())
    }
    parseuse.consomme(GenreLex√®me.PointVirgule)

    test: *Expression
    saufsi parseuse.apparie(GenreLex√®me.PointVirgule) {
        test = parseuse.parse_expression(Param√®tresParsageExpression())
    }
    parseuse.consomme(GenreLex√®me.PointVirgule)

    update: *Expression
    saufsi parseuse.apparie(GenreLex√®me.Parenth√®seFermante) {
        update = parseuse.parse_expression(Param√®tresParsageExpression())
    }
    parseuse.consomme(GenreLex√®me.Parenth√®seFermante)

    body := parse_statement(parseuse)

    retourne cr√©e_for_statement(parseuse, lex√®me, init, test, update, body)
}

parse_for_of_in_statement :: fonc (parseuse: *Parseuse, type_for: TypeFor) -> *Statement
{
    lex√®me := parseuse.lex√®me_courant()

    lex√®me_final := si type_for == TypeFor.ForOf {
        GenreLex√®me.Of
    }
    sinon {
        GenreLex√®me.In
    }

    left := parseuse.parse_expression(Param√®tresParsageExpression(lex√®me_final = lex√®me_final))

    si type_for == TypeFor.ForOf && !apparie(parseuse, GenreLex√®me.Of) {
        parseuse.rapporte_erreur("Attendu 'of'")
        retourne nul
    }
    si type_for == TypeFor.ForIn && !apparie(parseuse, GenreLex√®me.In) {
        parseuse.rapporte_erreur("Attendu 'in'")
        retourne nul
    }

    /* Consomme in/of */
    parseuse.consomme()

    right := parseuse.parse_expression(Param√®tresParsageExpression())

    parseuse.consomme(GenreLex√®me.Parenth√®seFermante)

    body := parseuse.parse_statement()

    si type_for == TypeFor.ForIn {
        retourne cr√©e_for_in_statement(parseuse, lex√®me, left, right, body)
    }

    retourne cr√©e_for_of_statement(parseuse, lex√®me, left, right, body)
}

parse_while_statement :: fonc (parseuse: *Parseuse) -> *WhileStatement
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()

    parseuse.consomme(GenreLex√®me.Parenth√®seOuvrante)
    test := parseuse.parse_expression(Param√®tresParsageExpression())
    parseuse.consomme(GenreLex√®me.Parenth√®seFermante)

    body := parse_statement(parseuse)

    retourne cr√©e_while_statement(parseuse, lex√®me, test, body)
}

parse_do_while_statement :: fonc (parseuse: *Parseuse) -> *DoWhileStatement
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()
    
    body := parse_statement(parseuse)

    parseuse.consomme(GenreLex√®me.While)
    parseuse.consomme(GenreLex√®me.Parenth√®seOuvrante)
    test := parseuse.parse_expression(Param√®tresParsageExpression())
    parseuse.consomme(GenreLex√®me.Parenth√®seFermante)

    retourne cr√©e_do_while_statement(parseuse, lex√®me, body, test)
}

parse_if_statement :: fonc (parseuse: *Parseuse) -> *IfStatement
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()

    parseuse.consomme(GenreLex√®me.Parenth√®seOuvrante)

    test := parseuse.parse_expression(Param√®tresParsageExpression())

    parseuse.consomme(GenreLex√®me.Parenth√®seFermante)

    consequent := parseuse.parse_statement()

    consomme_point_virgule_potentiel(parseuse)

    alternate: *Statement
    si parseuse.apparie(GenreLex√®me.Else) {
        parseuse.consomme()
        alternate = parseuse.parse_statement()
    }

    retourne cr√©e_if_statement(parseuse, lex√®me, test, consequent, alternate)
}

parse_try_statement :: fonc (parseuse: *Parseuse) -> *TryStatement
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()

    block := parse_statement(parseuse)

    handler: *CatchClause
    si parseuse.apparie(GenreLex√®me.Catch) {
        lex√®me_catch := parseuse.lex√®me_courant()
        parseuse.consomme()

        param: *Expression
        si parseuse.apparie(GenreLex√®me.Parenth√®seOuvrante) {
            parseuse.consomme()

            param = parseuse.parse_expression(Param√®tresParsageExpression())

            parseuse.consomme(GenreLex√®me.Parenth√®seFermante)
        }

        body := parse_statement(parseuse)

        handler = cr√©e_catch_clause(parseuse, lex√®me_catch, param, body)
    }

    finalizer: *Statement
    si parseuse.apparie(GenreLex√®me.Finally) {
        parseuse.consomme()
        finalizer = parse_statement(parseuse)
    }

    retourne cr√©e_try_statement(parseuse, lex√®me, block, handler, finalizer)
}

parse_throw_statement :: fonc (parseuse: *Parseuse) -> *ThrowStatement
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()
    argument := parse_expression(parseuse, Param√®tresParsageExpression())
    retourne cr√©e_throw_statement(parseuse, lex√®me, argument)
}

parse_continue_statement :: fonc (parseuse: *Parseuse) -> *ContinueStatement
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()
    target := parse_label_identifier(parseuse, faux)
    retourne cr√©e_continue_statement(parseuse, lex√®me, target)
}

parse_break_statement :: fonc (parseuse: *Parseuse) -> *BreakStatement
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()
    target := parse_label_identifier(parseuse, faux)
    retourne cr√©e_break_statement(parseuse, lex√®me, target)
}

parse_switch_statement :: fonc (parseuse: *Parseuse) -> *SwitchStatement
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()

    parseuse.consomme(GenreLex√®me.Parenth√®seOuvrante)
    discriminant := parseuse.parse_expression(Param√®tresParsageExpression())
    parseuse.consomme(GenreLex√®me.Parenth√®seFermante)

    parseuse.consomme(GenreLex√®me.AccoladeOuvrante)
    cases: [..]*CaseClause
    index_default_clause : z64 = -1

    tantque !parseuse.fini() {
        si apparie(parseuse, GenreLex√®me.Case) {
            case := parseuse.parse_case_clause()
            tableau_ajoute(*cases, case)
            continue
        }

        si apparie(parseuse, GenreLex√®me.Default) {
            si index_default_clause != -1 {
                parseuse.rapporte_erreur("duplicate default case")
                arr√™te
            }

            case := parseuse.parse_default_clause()
            index_default_clause = cases.taille
            tableau_ajoute(*cases, case)
            continue
        }

        arr√™te
    }

    parseuse.consomme(GenreLex√®me.AccoladeFermante)

    retourne cr√©e_switch_statement(parseuse, lex√®me, discriminant, cases, index_default_clause)
}

parse_case_clause :: fonc (parseuse: *Parseuse) -> *CaseClause
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()

    test := parseuse.parse_expression(Param√®tresParsageExpression())
    parseuse.consomme(GenreLex√®me.DoublePoint)

    consequent := parse_statement_list_case(parseuse)

    retourne cr√©e_case_clause(parseuse, lex√®me, test, consequent)
}

parse_default_clause :: fonc (parseuse: *Parseuse) -> *DefaultClause
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()
    parseuse.consomme(GenreLex√®me.DoublePoint)

    consequent := parse_statement_list_case(parseuse)

    retourne cr√©e_default_clause(parseuse, lex√®me, consequent)
}

parse_statement_list_case :: fonc (parseuse: *Parseuse) -> *Statement
{
    si parseuse.apparie(GenreLex√®me.AccoladeOuvrante) {
        retourne parseuse.parse_statement()
    }

    statements: [..]*Statement

    tantque !fini(parseuse) && !apparie(parseuse, GenreLex√®me.AccoladeFermante) && !apparie(parseuse, GenreLex√®me.Case) && !apparie(parseuse, GenreLex√®me.Default) {
        statement := parse_statement(parseuse)
        saufsi statement {
            arr√™te
        }
        tableau_ajoute(*statements, statement)
    }

    retourne cr√©e_block_statement(parseuse, nul, statements)
}

Param√®tresParsageExpression :: struct {
    pr√©c√©dence : z32 = 0
    associativit√© : Associativit√© = Associativit√©.Gauche
    lex√®me_final := GenreLex√®me.PointVirgule
}

parse_expression :: fonc (parseuse: *Parseuse, params: Param√®tresParsageExpression) -> *Expression
{
    expression := parseuse.parse_expression_primaire()

    tantque !parseuse.fini() && parseuse.apparie_expression_secondaire() && !apparie(parseuse, params.lex√®me_final) {
        donn√©es := donn√©es_lex√®mes_pour_parsage[parseuse.lex√®me_courant().genre]

        nouvelle_pr√©c√©dence := donn√©es.pr√©c√©dence

        si nouvelle_pr√©c√©dence < params.pr√©c√©dence {
            arr√™te
        }

        si nouvelle_pr√©c√©dence == params.pr√©c√©dence && params.associativit√© == Associativit√©.Gauche {
            arr√™te
        }

        nouveau_params := params
        nouveau_params.pr√©c√©dence = nouvelle_pr√©c√©dence
        nouveau_params.associativit√© = donn√©es.associativit√©

        expression = parseuse.parse_expression_secondaire(expression, nouveau_params)
    }

    retourne expression
}

cr√©e_chaine_√©chappement_r√©solu :: fonc (chn: chaine) -> ECMAString
{
    saufsi poss√®de_√©chappement(chn) {
        retourne cr√©e_chaine_utf16_unique(chn)
    }

    enchaineuse: Enchaineuse
    initialise_enchaineuse(*enchaineuse)
    diff√®re d√©truit_tampons(*enchaineuse)

    morceaux := divise(chn, '\\')
    diff√®re d√©loge(morceaux)

    pour morceaux {
        si index_it == 0 {
            ajoute_au_tampon(*enchaineuse, it)
            continue
        }

        si it.taille == 0 {
            continue
        }

        c := it[0]
        si c == 'n' {
            ajoute_au_tampon(*enchaineuse, "\n")
            it = avance(it, 1)
        }
        sinon si c == 't' {
            ajoute_au_tampon(*enchaineuse, "\t")
            it = avance(it, 1)
        }
        sinon si c == '\n' {
            it = avance(it, 1)
        }

        ajoute_au_tampon(*enchaineuse, it)
    }

    r√©sultat := chaine_depuis_enchaineuse(*enchaineuse)
    retourne cr√©e_chaine_utf16_unique(r√©sultat)
}

poss√®de_√©chappement :: fonc (chn: chaine) -> bool
{
    pour chn {
        si it == '\\' {
            retourne vrai
        }
    }

    retourne faux
}

parse_expression_primaire :: fonc (parseuse: *Parseuse) -> *Expression
{
    lex√®me := parseuse.lex√®me_courant()

    discr lex√®me.genre {
        ChaineLitt√©rale {
            parseuse.consomme()
            retourne cr√©e_literal(parseuse, lex√®me, cr√©e_chaine_√©chappement_r√©solu(lex√®me.texte))
        }
        TemplateLiteral {
            parseuse.consomme()
            quasi := cr√©e_template_element(parseuse, lex√®me, cr√©e_chaine_√©chappement_r√©solu(lex√®me.texte), vrai)
            quasis: [..]*TemplateElement
            tableau_ajoute(*quasis, quasi)
            retourne cr√©e_template_literal(parseuse, lex√®me, quasis)
        }
        TemplateLiteralStart {
            retourne parse_template_literal(parseuse, lex√®me)
        }
        NombreLitt√©ral {
            parseuse.consomme()
            valeur := parse_nombre_depuis_lex√®me(lex√®me)
            retourne cr√©e_literal(parseuse, lex√®me, valeur)
        }
        True {
            parseuse.consomme()
            retourne cr√©e_boolean_literal(parseuse, lex√®me, vrai)
        }
        False {
            parseuse.consomme()
            retourne cr√©e_boolean_literal(parseuse, lex√®me, faux)
        }
        Null {
            parseuse.consomme()
            retourne cr√©e_null_literal(parseuse, lex√®me)
        }
        This {
            parseuse.consomme()
            retourne cr√©e_this_expression(parseuse, lex√®me)
        }
        As,
        Async,
        From,
        Get,
        Meta,
        Of,
        Set,
        Target,
        Identifiant {
            parseuse.consomme()
            retourne cr√©e_identifier(parseuse, lex√®me, lex√®me.texte)
        }
        Parenth√®seOuvrante {
            parseuse.consomme()

            expression: *Expression
            saufsi parseuse.apparie(GenreLex√®me.Parenth√®seFermante) {
                expression = parseuse.parse_expression(Param√®tresParsageExpression())
            }

            parseuse.consomme(GenreLex√®me.Parenth√®seFermante)

            si expression {
                retourne expression
            }

            /* NOTE : pour l'instant ces expressions ne servent que pour les fonctions-arrow */
            retourne parseuse.cr√©e_parenthesized_expression(lex√®me, expression)
        }
        AccoladeOuvrante {
            parseuse.consomme()

            properties: [..]*PropertyDefinition

            tantque !fini(parseuse) {
                si apparie(parseuse, GenreLex√®me.AccoladeFermante) {
                    arr√™te
                }

                nom_membre := parse_property_name(parseuse)

                lex√®me_d√©f := parseuse.lex√®me_courant()
                parseuse.consomme(GenreLex√®me.DoublePoint)

                expression := parseuse.parse_expression(Param√®tresParsageExpression(lex√®me_final = GenreLex√®me.Virgule))

                property := cr√©e_property_definition(parseuse, lex√®me_d√©f, nom_membre, expression)
                tableau_ajoute(*properties, property)

                saufsi apparie(parseuse, GenreLex√®me.Virgule) {
                    arr√™te
                }

                parseuse.consomme()
            }

            parseuse.consomme(GenreLex√®me.AccoladeFermante)

            retourne cr√©e_object_expression(parseuse, lex√®me, properties)
        }
        CrochetOuvrant {
            parseuse.consomme()

            √©l√©ments := parse_expressions_s√©par√©es_par_des_virgules(parseuse)

            parseuse.consomme(GenreLex√®me.CrochetFermant)

            retourne cr√©e_array_literal(parseuse, lex√®me, √©l√©ments)
        }
        Let {
            retourne parse_variable_declaration(parseuse, VariableDeclarationKind.Let)
        }
        Var {
            retourne parse_variable_declaration(parseuse, VariableDeclarationKind.Var)
        }
        Const {
            retourne parse_variable_declaration(parseuse, VariableDeclarationKind.Const)
        }
        Function {
            retourne parse_function_expression(parseuse)
        }
        Plus {
            parseuse.consomme()
            params := donne_param√®tres_parsage_expression_pour_lex√®me_unaire(GenreLex√®me.PlusUnaire)
            argument := parseuse.parse_expression(params)
            retourne cr√©e_unary_plus_operator(parseuse, lex√®me, argument)
        }
        Moins {
            parseuse.consomme()
            params := donne_param√®tres_parsage_expression_pour_lex√®me_unaire(GenreLex√®me.MoinsUnaire)
            argument := parseuse.parse_expression(params)
            retourne cr√©e_unary_minus_operator(parseuse, lex√®me, argument)
        }
        NonBinaire {
            parseuse.consomme()
            params := donne_param√®tres_parsage_expression_pour_lex√®me_unaire(lex√®me.genre)
            argument := parseuse.parse_expression(params)
            retourne cr√©e_binary_not(parseuse, lex√®me, argument)
        }
        NonLogique {
            parseuse.consomme()
            params := donne_param√®tres_parsage_expression_pour_lex√®me_unaire(lex√®me.genre)
            argument := parseuse.parse_expression(params)
            retourne cr√©e_logical_not(parseuse, lex√®me, argument)
        }
        PlusPlus {
            parseuse.consomme()
            params := donne_param√®tres_parsage_expression_pour_lex√®me_unaire(GenreLex√®me.PreIncrement)
            argument := parseuse.parse_expression(params)
            retourne cr√©e_update_expression(parseuse, lex√®me, argument, UpdateOperation.PrefixIncrement)
        }
        MoinsMoins {
            parseuse.consomme()
            params := donne_param√®tres_parsage_expression_pour_lex√®me_unaire(GenreLex√®me.PreDecrement)
            argument := parseuse.parse_expression(params)
            retourne cr√©e_update_expression(parseuse, lex√®me, argument, UpdateOperation.PrefixDecrement)
        }
        Typeof {
            parseuse.consomme()
            params := donne_param√®tres_parsage_expression_pour_lex√®me_unaire(lex√®me.genre)
            argument := parseuse.parse_expression(params)
            retourne cr√©e_typeof_operator(parseuse, lex√®me, argument)
        }
        Void {
            parseuse.consomme()
            params := donne_param√®tres_parsage_expression_pour_lex√®me_unaire(lex√®me.genre)
            argument := parseuse.parse_expression(params)
            retourne cr√©e_void_operator(parseuse, lex√®me, argument)
        }
        Delete {
            parseuse.consomme()
            params := donne_param√®tres_parsage_expression_pour_lex√®me_unaire(lex√®me.genre)
            argument := parseuse.parse_expression(params)
            retourne cr√©e_delete_operator(parseuse, lex√®me, argument)
        }
        New {
            parseuse.consomme()
            params := donne_param√®tres_parsage_expression_pour_lex√®me_unaire(lex√®me.genre)
            params.lex√®me_final = GenreLex√®me.Point
            argument := parseuse.parse_expression(params)
            retourne cr√©e_new_expression(parseuse, lex√®me, argument);
        }
        sinon {
            parseuse.rapporte_erreur("Attendu une expression primaire")
        }
    }

    retourne nul
}

parse_template_literal :: fonc (parseuse: *Parseuse, lex√®me: *Lex√®me) -> *TemplateLiteral
{
    assert(lex√®me.genre == GenreLex√®me.TemplateLiteralStart)
    parseuse.consomme()

    lex√®me_orig := lex√®me

    quasis: [..]*TemplateElement
    expressions: [..]*Expression

    quasi := cr√©e_template_element(parseuse, lex√®me, cr√©e_chaine_√©chappement_r√©solu(lex√®me.texte), faux)
    tableau_ajoute(*quasis, quasi)

    tantque !fini(parseuse) {
        expression := parse_expression(parseuse, Param√®tresParsageExpression())
        tableau_ajoute(*expressions, expression)

        si parseuse.fini() {
            parseuse.rapporte_erreur("fin de fichier inattendu dans le template literal")
            arr√™te
        }

        lex√®me = parseuse.lex√®me_courant()
        si lex√®me.genre == GenreLex√®me.TemplateLiteralMiddle {
            quasi = cr√©e_template_element(parseuse, lex√®me, cr√©e_chaine_√©chappement_r√©solu(lex√®me.texte), faux)
            tableau_ajoute(*quasis, quasi)
            parseuse.consomme()
            continue
        }

        si lex√®me.genre != GenreLex√®me.TemplateLiteralEnd {
            parseuse.rapporte_erreur("[erreur interne] attendu un template-literal-end")
        }

        quasi = cr√©e_template_element(parseuse, lex√®me, cr√©e_chaine_√©chappement_r√©solu(lex√®me.texte), vrai)
        tableau_ajoute(*quasis, quasi)
        parseuse.consomme()
        arr√™te
    }

    retourne cr√©e_template_literal(parseuse, lex√®me_orig, quasis, expressions)
}

parse_property_name :: fonc (parseuse: *Parseuse) -> *Expression
{
    lex√®me := parseuse.lex√®me_courant()

    si parseuse.apparie(GenreLex√®me.ChaineLitt√©rale) {
        parseuse.consomme()
        retourne cr√©e_literal(parseuse, lex√®me, lex√®me.texte)
    }

    si parseuse.apparie(GenreLex√®me.NombreLitt√©ral) {
        parseuse.consomme()
        valeur := parse_nombre_depuis_lex√®me(lex√®me)
        retourne cr√©e_literal(parseuse, lex√®me, valeur)
    }

    retourne parse_identifier_name(parseuse)
}

parse_identifier_name :: fonc (parseuse: *Parseuse) -> *Identifier
{
    si parseuse.fini() {
        rapporte_erreur(parseuse, "unexpected end of input")
        retourne nul
    }

    lex√®me := parseuse.lex√®me_courant()
    si lex√®me.texte.taille == 0 {
        rapporte_erreur(parseuse, "empty token")
        retourne nul
    }

    c := lex√®me.texte[0]
    fanion := fanions_caract√®res[c comme n8]

    saufsi fanion.D√©buteIdentifiant {
        rapporte_erreur(parseuse, "expected an identifier name")
    }

    parseuse.consomme()
    retourne cr√©e_identifier(parseuse, lex√®me, lex√®me.texte)
}

/* https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#prod-IdentifierReference */
parse_identifier_reference :: fonc (parseuse: *Parseuse) -> *Identifier
{
    retourne parse_identifiant_yield_ou_await(parseuse, vrai)
}

parse_binding_identifier :: fonc (parseuse: *Parseuse, √©mets_erreur_si_manquant: bool) -> *Identifier
{
    retourne parse_identifiant_yield_ou_await(parseuse, √©mets_erreur_si_manquant)
}

parse_label_identifier :: fonc (parseuse: *Parseuse, √©mets_erreur_si_manquant: bool) -> *Identifier
{
    retourne parse_identifiant_yield_ou_await(parseuse, √©mets_erreur_si_manquant)
}

parse_identifier :: fonc (parseuse: *Parseuse, √©mets_erreur_si_manquant: bool) -> *Identifier
{
    lex√®me := parseuse.lex√®me_courant()

    si apparie_lex√®me_identifier(parseuse) {
        parseuse.consomme()
        retourne cr√©e_identifier(parseuse, lex√®me, lex√®me.texte)
    }

    si √©mets_erreur_si_manquant {
        parseuse.rapporte_erreur("expected an identifier")
    }
    retourne nul
}

apparie_lex√®me_identifier :: fonc (parseuse: *Parseuse) -> bool
{
    lex√®me := parseuse.lex√®me_courant()

    // as, async, from, get, meta, of, set, and target
    lex√®mes_autoris√©s := [GenreLex√®me.Identifiant, GenreLex√®me.As, GenreLex√®me.Async, GenreLex√®me.From, GenreLex√®me.Get, GenreLex√®me.Meta, GenreLex√®me.Of, GenreLex√®me.Set, GenreLex√®me.Target]
    pour lex√®mes_autoris√©s {
        si lex√®me.genre == it {
            retourne vrai
        }
    }
    retourne faux
}

apparie_lex√®me_identifier_property :: fonc (parseuse: *Parseuse) -> bool
{
    si apparie_lex√®me_identifier(parseuse) {
        retourne vrai
    }
    si apparie(parseuse, GenreLex√®me.Delete) {
        retourne vrai
    }
    retourne faux
}

parse_identifiant_yield_ou_await :: fonc (parseuse: *Parseuse, √©mets_erreur_si_manquant: bool) -> *Identifier
{
    lex√®me := parseuse.lex√®me_courant()

    si lex√®me.genre == GenreLex√®me.Yield {
        parseuse.consomme()
        retourne cr√©e_identifier(parseuse, lex√®me, lex√®me.texte)
    }

    si lex√®me.genre == GenreLex√®me.Await {
        parseuse.consomme()
        retourne cr√©e_identifier(parseuse, lex√®me, lex√®me.texte)
    }

    retourne parse_identifier(parseuse, √©mets_erreur_si_manquant)
}

donne_op√©ration_binaire_pour_genre_lex√®me :: fonc (genre: GenreLex√®me) -> BinaryOperation
{
    discr genre {
        Plus {
            retourne BinaryOperation.Plus
        }
        Moins {
            retourne BinaryOperation.Moins
        }
        √âtoile {
            retourne BinaryOperation.Multiplie
        }
        Slash {
            retourne BinaryOperation.Divise
        }
        Pourcent {
            retourne BinaryOperation.Modulo
        }
        EtBinaire {
            retourne BinaryOperation.EtBinaire
        }
        OuBinaire {
            retourne BinaryOperation.OuBinaire
        }
        OuExclusif {
            retourne BinaryOperation.OuExclusif
        }
        D√©calageGauche {
            retourne BinaryOperation.D√©calageGauche
        }
        D√©calageDroite {
            retourne BinaryOperation.D√©calageDroite
        }
        D√©calageDroiteNaturel {
            retourne BinaryOperation.D√©calageDroiteNaturel
        }
        Exponentiation {
            retourne BinaryOperation.Exponentiation
        }
        sinon {
            panique("genre op√©rateur non-g√©r√©")
        }
    }

    retourne BinaryOperation.Plus
}

donne_op√©ration_√©galitaire_pour_genre_lex√®me :: fonc (genre: GenreLex√®me) -> EqualityOperation
{
    discr genre {
        Est√âgal {
            retourne EqualityOperation.√âgal
        }
        NEspaPas√âgal {
            retourne EqualityOperation.In√©gal
        }
        Est√âgalStrict {
            retourne EqualityOperation.√âgalStrict
        }
        NEspaPas√âgalStrict {
            retourne EqualityOperation.In√©galStrict
        }
        sinon {
            panique("genre op√©rateur non-g√©r√©")
        }
    }
    retourne EqualityOperation.√âgal
}

donne_op√©ration_relationnelle_pour_genre_lex√®me :: fonc (genre: GenreLex√®me) -> RelationalOperation
{
    discr genre {
        Inf√©rieur {
            retourne RelationalOperation.Inf√©rieur
        }
        Sup√©rieur {
            retourne RelationalOperation.Sup√©rieur
        }
        Inf√©rieur√âgal {
            retourne RelationalOperation.Inf√©rieur√âgal
        }
        Sup√©rieur√âgal {
            retourne RelationalOperation.Sup√©rieur√âgal
        }
        InstanceOf {
            retourne RelationalOperation.InstanceOf
        }
        In {
            retourne RelationalOperation.In
        }
        sinon {
            panique("genre op√©rateur non-g√©r√©")
        }
    }

    retourne RelationalOperation.Inf√©rieur
}

parse_expression_secondaire :: fonc (parseuse: *Parseuse, gauche: *Expression, params: Param√®tresParsageExpression) -> *Expression
{
    lex√®me := parseuse.lex√®me_courant()

    discr lex√®me.genre {
        Plus,
        Moins,
        √âtoile,
        Slash,
        Pourcent,
        EtBinaire,
        OuBinaire,
        OuExclusif,
        D√©calageGauche,
        D√©calageDroite,
        D√©calageDroiteNaturel,
        Exponentiation {
            op√©ration := donne_op√©ration_binaire_pour_genre_lex√®me(lex√®me.genre)
            parseuse.consomme()
            op√©rande_droite := parseuse.parse_expression(params)
            retourne cr√©e_binary_expression(parseuse, lex√®me, op√©ration, gauche, op√©rande_droite)
        }
        Inf√©rieur,
        Sup√©rieur,
        Inf√©rieur√âgal,
        Sup√©rieur√âgal,
        InstanceOf,
        In {
            op√©ration := donne_op√©ration_relationnelle_pour_genre_lex√®me(lex√®me.genre)
            parseuse.consomme()
            op√©rande_droite := parseuse.parse_expression(params)
            retourne cr√©e_relational_expression(parseuse, lex√®me, op√©ration, gauche, op√©rande_droite)
        }
        Est√âgal,
        NEspaPas√âgal,
        Est√âgalStrict,
        NEspaPas√âgalStrict {
            op√©ration := donne_op√©ration_√©galitaire_pour_genre_lex√®me(lex√®me.genre)
            parseuse.consomme()
            op√©rande_droite := parseuse.parse_expression(params)
            retourne cr√©e_equality_expression(parseuse, lex√®me, op√©ration, gauche, op√©rande_droite)
        }
        PlusPlus,
        MoinsMoins {
            parseuse.consomme()

            operation := si lex√®me.genre == GenreLex√®me.PlusPlus { UpdateOperation.PostfixIncrement } sinon { UpdateOperation.PostfixDecrement }
            update := cr√©e_update_expression(parseuse, lex√®me, gauche, operation)

            /* Les expressions de style var o = {x:i++,y:2} doivent s'arr√™ter √† la virgule (qui est une expression secondaire). */
            si parseuse.apparie_expression_secondaire() && !parseuse.apparie(params.lex√®me_final) {
                retourne parseuse.parse_expression_secondaire(update, params)
            }

            retourne update
        }
        √âgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.Assigne, params)
        }
        Plus√âgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.Ajoute, params)
        }
        Moins√âgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.Soustrait, params)
        }
        √âtoile√âgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.Multiplie, params)
        }
        Slash√âgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.Divise, params)
        }
        Pourcent√âgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.Modulo, params)
        }
        D√©calageGauche√âgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.D√©calageGauche, params)
        }
        D√©calageDroite√âgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.D√©calageDroite, params)
        }
        D√©calageDroiteNaturel√âgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.D√©calageDroiteNaturel, params)
        }
        EtBinaire√âgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.EtBinaire, params)
        }
        OuBinaire√âgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.OuBinaire, params)
        }
        OuExclusif√âgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.OuExBinaire, params)
        }
        EtLogique√âgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.EtLogique, params)
        }
        OuLogique√âgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.OuLogique, params)
        }
        Coalesce√âgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.Coalesce, params)
        }
        Exponentiation√âgal {
            retourne parse_assignement_expression(parseuse, gauche, AssignmentOperation.Exponentiation, params)
        }
        Point {
            parseuse.consomme()
            propri√©t√© := parse_identifier_name(parseuse)
            retourne cr√©e_member_expression(parseuse, lex√®me, gauche, propri√©t√©, faux)
        }
        Parenth√®seOuvrante {
            parseuse.consomme()

            arguments := parse_expressions_s√©par√©es_par_des_virgules(parseuse)

            parseuse.consomme(GenreLex√®me.Parenth√®seFermante)

            retourne cr√©e_call_expression(parseuse, lex√®me, gauche, arguments)
        }
        CrochetOuvrant {
            parseuse.consomme()

            propri√©t√© := parseuse.parse_expression(Param√®tresParsageExpression())

            parseuse.consomme(GenreLex√®me.CrochetFermant)

            retourne cr√©e_member_expression(parseuse, lex√®me, gauche, propri√©t√©, vrai)
        }
        EtLogique {
            parseuse.consomme()
            droite := parseuse.parse_expression(params)
            retourne cr√©e_logical_and(parseuse, lex√®me, gauche, droite)
        }
        OuLogique {
            parseuse.consomme()
            droite := parseuse.parse_expression(params)
            retourne cr√©e_logical_or(parseuse, lex√®me, gauche, droite)
        }
        Coalesce {
            parseuse.consomme()
            droite := parseuse.parse_expression(params)
            retourne cr√©e_coalesce(parseuse, lex√®me, gauche, droite)
        }
        Interrogation {
            parseuse.consomme()

            consequent := parseuse.parse_expression(params)
            parseuse.consomme(GenreLex√®me.DoublePoint)

            alternate := parseuse.parse_expression(params)
            retourne cr√©e_conditional_expression(parseuse, lex√®me, gauche, consequent, alternate)
        }
        Virgule {
            parseuse.consomme()
            droite := parseuse.parse_expression(params)
            retourne cr√©e_comma_expression(parseuse, lex√®me, gauche, droite)
        }
        Arrow {
            parseuse.consomme()
            droite := parseuse.parse_statement()
            si droite {
                droite.appartient_√†_fonction = vrai
            }

            // √Ä FAIRE : nous pouvons avoir une expression virgule alors que les fonctions doivent avoir un tableau
            // pour les param√®tres.
            arrow_params := aplatis_expression_et_d√©truit_virgules(gauche)

            concise_body := parseuse.cr√©e_concise_body(droite)
            retourne cr√©e_arrow_function(parseuse, lex√®me, arrow_params, concise_body)
        }
        sinon {
            rapporte_erreur(parseuse, lex√®me, "Genre de lex√®me non g√©r√© dans parse_expression_secondaire\n")
        }
    }

    retourne nul
}

aplatis_expression_et_d√©truit_virgules :: fonc (expression: *Expression) -> [..]*Expression
{
    r√©sultat: [..]*Expression

    si expression.type == ParenthesizedExpression {
        assert((expression comme *ParenthesizedExpression).expression == nul)
        d√©truit_arbre(expression)
        retourne r√©sultat
    }

    si expression.type == CommaExpression {
        aplatis_virgule(expression comme *CommaExpression, *r√©sultat)
        d√©truit_arbre(expression)
    }
    sinon {
        tableau_ajoute(*r√©sultat, expression)
    }

    retourne r√©sultat
}

aplatis_virgule :: fonc (virgule: *CommaExpression, r√©sultat: *[..]*Expression)
{
    si virgule.left.type == CommaExpression {
        aplatis_virgule(virgule.left comme *CommaExpression, r√©sultat)
    }
    sinon {
        tableau_ajoute(r√©sultat, virgule.left)
        virgule.left = nul
    }

    tableau_ajoute(r√©sultat, virgule.right)
    virgule.right = nul
}

parse_assignement_expression :: fonc (parseuse: *Parseuse, gauche: *Expression, op√©ration: AssignmentOperation, params: Param√®tresParsageExpression) -> *AssignmentExpression
{
    lex√®me := parseuse.lex√®me_courant()
    parseuse.consomme()
    expression := parseuse.parse_expression(params)
    retourne cr√©e_assignment_expression(parseuse, lex√®me, op√©ration, gauche, expression)
}

parse_expressions_s√©par√©es_par_des_virgules :: fonc (parseuse: *Parseuse) -> [..]*Expression
{
    r√©sultat: [..]*Expression
    /* Permet de ne pas avoir d'expression pour que, par exemple, le parsage des parenth√®ses
     * d'expressions d'appels vides n'est pas √† le v√©rifier. */
    saufsi apparie_expression(parseuse) {
        retourne r√©sultat
    }

    tantque !fini(parseuse) {
        expr := parseuse.parse_expression(Param√®tresParsageExpression(lex√®me_final = GenreLex√®me.Virgule))

        tableau_ajoute(*r√©sultat, expr)

        saufsi parseuse.apparie(GenreLex√®me.Virgule) {
            arr√™te
        }

        parseuse.consomme()
        /* Permet d'avoir des virgules en fin de liste sans expression suivante :
         * [a, b, c,] */
        saufsi apparie_expression(parseuse) {
            arr√™te
        }
    }
    retourne r√©sultat
}

donne_param√®tres_parsage_expression_pour_lex√®me_unaire :: fonc (genre: GenreLex√®me) -> Param√®tresParsageExpression
{
    donn√©es := donn√©es_lex√®mes_pour_parsage[genre]
    r√©sultat: Param√®tresParsageExpression
    r√©sultat.pr√©c√©dence = donn√©es.pr√©c√©dence
    r√©sultat.associativit√© = donn√©es.associativit√©
    retourne r√©sultat
}

parse_statement_list :: fonc (parseuse: *Parseuse) -> [..]*Statement
{
    statements: [..]*Statement

    tantque !fini(parseuse) && !apparie(parseuse, GenreLex√®me.AccoladeFermante) {
        statement := parseuse.parse_statement()
        saufsi statement {
            arr√™te
        }
        tableau_ajoute(*statements, statement)
    }

    retourne statements
}

rapporte_erreur :: fonc (parseuse: *Parseuse, message: chaine)
{
    lex√®me := si parseuse.fini() {
        *parseuse.lex√®mes[parseuse.lex√®mes.taille - 1]
    }
    sinon {
        parseuse.lex√®me_courant()
    }

    rapporte_erreur(parseuse, lex√®me, message)
}

rapporte_erreur :: fonc (parseuse: *Parseuse, lex√®me: *Lex√®me, message: chaine)
{
    si parseuse.erreur_de_compilation {
        parseuse.consomme()
        retourne
    }

    position := donne_position_source(parseuse.source_text, m√©moire(lex√®me))

    erreur_de_compilation := cr√©e_erreur_de_compilation(parseuse.realm, message, position)
    parseuse.erreur_de_compilation = erreur_de_compilation
}
