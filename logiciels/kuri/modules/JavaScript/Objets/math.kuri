importe AlÃ©a
importe Math

/* ------------------------------------------------------------------------- */
/** \nom Math
 * https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-math-object
 * \{ */

MathObject :: struct {
    empl object: Object
    table = *table_virtuelle_math

    entropie: SÃ©rieAlÃ©atoire
}

#portÃ©e_fichier

table_virtuelle_math := TableVirtuelleObject(classe = MathObject)

#portÃ©e_module

crÃ©e_math_object :: fonc (object_prototype: *ObjectPrototype) -> *MathObject
{
    rÃ©sultat := object_prototype.donne_tas_de_mÃ©moire().alloue(MathObject)
    rÃ©sultat.prototype = object_prototype
    rÃ©sultat.ajoute_fonction_native(STR_abs, math_abs)
    rÃ©sultat.ajoute_fonction_native(STR_ceil, math_ceil)
    rÃ©sultat.ajoute_fonction_native(STR_floor, math_floor)
    rÃ©sultat.ajoute_fonction_native(STR_max, math_max)
    rÃ©sultat.ajoute_fonction_native(STR_min, math_min)
    rÃ©sultat.ajoute_fonction_native(STR_random, math_random)
    rÃ©sultat.ajoute_fonction_native(STR_round, math_round)
    rÃ©sultat.ajoute_fonction_native(STR_sqrt, math_sqrt)

    /* Chaque realm doit avoir sa propre sÃ©rie. */
    graine := object_prototype comme n64 comme n32
    rÃ©sultat.entropie = graine_alÃ©atoire(graine)

    retourne rÃ©sultat
}

/* Ã€ FAIRE(langage) : erreur de compilation */
// R64_INFINITÃ‰ : r64 : 0r7ff0000000000000
// R64_INFINITÃ‰_NÃ‰GATIVE : r64 : 0rfff0000000000000
R64_INFINITÃ‰ : r64 : 1000000000.0
R64_INFINITÃ‰_NÃ‰GATIVE : r64 : -1000000000.0

#portÃ©e_fichier
/* 21.3.2.1 Math.abs ( x )
 * https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-math.abs */
math_abs :: fonc (empl params: *ParamÃ¨tresObjectCall) -> CompletionRecord
{
    x := params.donne_argument(0)
    // 1. Let n be ? ToNumber(x).
    completion := to_number(interprÃ©teuse, x)
    saufsi completion.est_normal() {
        retourne completion
    }
    n := completion.valeur.V.Number

    // 2. If n is NaN, return NaN.
    si est_nan(n) {
        retourne normal_completion(Valeur(Number = NaN))
    }

    // 3. If n is -0ğ”½, return +0ğ”½.
    si n == 0.0 {
        retourne normal_completion(Valeur(Number = 0.0))
    }

    // 4. If n is -âˆğ”½, return +âˆğ”½.
    si n == R64_INFINITÃ‰_NÃ‰GATIVE {
        retourne normal_completion(Valeur(Number = R64_INFINITÃ‰))
    }

    // 5. If n < -0ğ”½, return -n.
    si n < 0.0 {
        retourne normal_completion(Valeur(Number = -n))
    }

    // 6. Return n.
    retourne normal_completion(Valeur(Number = n))
}

/* https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-math.ceil */
math_ceil :: fonc (empl params: *ParamÃ¨tresObjectCall) -> CompletionRecord
{
    x := params.donne_argument(0)

    // 1. Let n be ? ToNumber(x).
    completion := to_number(interprÃ©teuse, x)
    saufsi completion.est_normal() {
        retourne completion
    }
    n := completion.valeur.V.Number

    // 2. If n is not finite or n is either +0ğ”½ or -0ğ”½, return n.
    si !est_fini(n) || (n == 0.0 || n == -0.0) {
        retourne completion
    }

    // 3. If n < -0ğ”½ and n > -1ğ”½, return -0ğ”½.
    si n < -0.0 && n > -1.0 {
        retourne normal_completion(Valeur(Number = -0.0))
    }

    // Ã€ FAIRE : 4. If n is an integral Number, return n.
    
    // 5. Return the smallest (closest to -âˆ) integral Number value that is not less than n.
    retourne normal_completion(plafond(n))
}

/* https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-math.floor */
math_floor :: fonc (empl params: *ParamÃ¨tresObjectCall) -> CompletionRecord
{
    x := params.donne_argument(0)

    // 1. Let n be ? ToNumber(x).
    completion := to_number(interprÃ©teuse, x)
    saufsi completion.est_normal() {
        retourne completion
    }
    n := completion.valeur.V.Number

    // 2. If n is not finite or n is either +0ğ”½ or -0ğ”½, return n.
    si !est_fini(n) || (n == 0.0 || n == -0.0) {
        retourne completion
    }

    // 3. If n < 1ğ”½ and n > +0ğ”½, return +0ğ”½.
    si n < 1.0 && n > 0.0 {
        retourne normal_completion(Valeur(Number = 0))
    }

    // Ã€ FAIRE : 4. If n is an integral Number, return n.

    // 5. Return the greatest (closest to +âˆ) integral Number value that is not greater than n.
    retourne normal_completion(plancher(n))
}

/* https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-math.min */
math_max :: fonc (empl params: *ParamÃ¨tresObjectCall) -> CompletionRecord
{
    // 1. Let coerced be a new empty List.
    coerced: [..]r64
    diffÃ¨re dÃ©loge(coerced)

    // 2. For each element arg of args, do
    pour arguments {
        // a. Let n be ? ToNumber(arg).
        completion := to_number(interprÃ©teuse, it)
        saufsi completion.est_normal() {
            retourne completion
        }

        // b. Append n to coerced.
        tableau_ajoute(*coerced, completion.valeur.V.Number)
    }

    // 3. Let highest be -âˆğ”½.
    highest := R64_INFINITÃ‰_NÃ‰GATIVE

    // 4. For each element number of coerced, do
    pour coerced {
        // a. If number is NaN, return NaN.
        si est_nan(it) {
            retourne normal_completion(Valeur(Number = NaN))
        }

        // b. b. If number is +0ğ”½ and highest is -0ğ”½, set highest to +0ğ”½.
        si it == 0.0 && highest == -0.0 {
            highest = 0.0
            continue
        }
        
        // c. If number > highest, set highest to number.
        si it > highest {
            highest = it
        }
    }

    // 5. Return highest.
    retourne normal_completion(Valeur(Number = highest))
}

/* https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-math.min */
math_min :: fonc (empl params: *ParamÃ¨tresObjectCall) -> CompletionRecord
{
    // 1. Let coerced be a new empty List.
    coerced: [..]r64
    diffÃ¨re dÃ©loge(coerced)

    // 2. For each element arg of args, do
    pour arguments {
        // a. Let n be ? ToNumber(arg).
        completion := to_number(interprÃ©teuse, it)
        saufsi completion.est_normal() {
            retourne completion
        }

        // b. Append n to coerced.
        tableau_ajoute(*coerced, completion.valeur.V.Number)
    }

    // 3. Let lowest be +âˆğ”½.
    lowest := R64_INFINITÃ‰

    // 4. For each element number of coerced, do
    pour coerced {
        // a. If number is NaN, return NaN.
        si est_nan(it) {
            retourne normal_completion(Valeur(Number = NaN))
        }

        // b. If number is -0ğ”½ and lowest is +0ğ”½, set lowest to -0ğ”½.
        si it == -0.0 && lowest == 0.0 {
            lowest = -0.0
            continue
        }
        
        // c. If number < lowest, set lowest to number.
        si it < lowest {
            lowest = it
        }
    }

    // 5. Return lowest.
    retourne normal_completion(Valeur(Number = lowest))
}

/* https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-math.random */
math_random :: fonc (empl params: *ParamÃ¨tresObjectCall) -> CompletionRecord
{
    math := this_value.donne_objet() comme *MathObject
    rÃ©sultat := alÃ©atoire_unilatÃ©rale(math.entropie)
    retourne normal_completion(Valeur(Number = rÃ©sultat))
}

/* 21.3.2.28 Math.round ( x )
 * https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-math.round */
math_round :: fonc (empl params: *ParamÃ¨tresObjectCall) -> CompletionRecord
{
    // 1. Let n be ? ToNumber(x).
    completion := to_number(interprÃ©teuse, params.donne_argument(0))
    saufsi completion.est_normal() {
        retourne completion
    }
    n := completion.valeur.V.Number

    // 2. If n is not finite or n is an integral Number, return n.
    // Ã€ FAIRE : is an integral Number
    si est_infini(n) {
        retourne normal_completion(Valeur(Number = n))
    }

    // 3. If n < 0.5ğ”½ and n > +0ğ”½, return +0ğ”½.
    si n < 0.5 && n > 0.0 {
        retourne normal_completion(Valeur(Number = 0.0))
    }

    // 4. If n < -0ğ”½ and n â‰¥ -0.5ğ”½, return -0ğ”½.
    si n < -0.0 && n >= -0.5 {
        retourne normal_completion(Valeur(Number = -0.0))
    }

    // 5. Return the integral Number closest to n, preferring the Number closer to +âˆ in the case of a tie.
    rÃ©sultat := arrondis(n)
    retourne normal_completion(Valeur(Number = rÃ©sultat))
}

/* https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-math.random */
math_sqrt :: fonc (empl params: *ParamÃ¨tresObjectCall) -> CompletionRecord
{
    // 1. Let n be ? ToNumber(x).
    completion := to_number(interprÃ©teuse, params.donne_argument(0))
    saufsi completion.est_normal() {
        retourne completion
    }
    n := completion.valeur.V.Number

    // 2. If n is one of NaN, +0ğ”½, -0ğ”½, or +âˆğ”½, return n.
    si est_nan(n) || n == 0.0 || n == -0.0 || n == R64_INFINITÃ‰ {
        retourne normal_completion(Valeur(Number = n))
    }

    // 3. If n < -0ğ”½, return NaN.
    si n < -0.0 {
        retourne normal_completion(Valeur(Number = NaN))
    }

    // 4. Return ğ”½(the square root of â„(n)).
    retourne normal_completion(Valeur(Number = racine_carrÃ©e(n)))
}

/** \} */
