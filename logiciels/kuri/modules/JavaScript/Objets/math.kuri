importe AlÃ©a

/* ------------------------------------------------------------------------- */
/** \nom Math
 * https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-math-object
 * \{ */

MathObject :: struct {
    empl object: Object
    table = *table_virtuelle_math

    entropie: SÃ©rieAlÃ©atoire
}

#portÃ©e_fichier

table_virtuelle_math := TableVirtuelleObject(classe = MathObject)

#portÃ©e_module

crÃ©e_math_object :: fonc (object_prototype: *ObjectPrototype) -> *MathObject
{
    rÃ©sultat := object_prototype.donne_tas_de_mÃ©moire().alloue(MathObject)
    rÃ©sultat.prototype = object_prototype

    constantes: Constantes(r64)

    rÃ©sultat.ajoute_propriÃ©tÃ©(STR_LN2, Valeur(Number = 0.6931471805599453), DrapeauxPropriÃ©tÃ©.zÃ©ro)
    rÃ©sultat.ajoute_propriÃ©tÃ©(STR_PI, Valeur(Number = constantes.PI), DrapeauxPropriÃ©tÃ©.zÃ©ro)

    rÃ©sultat.ajoute_fonction_native(STR_abs, math_abs)
    rÃ©sultat.ajoute_fonction_native(STR_ceil, math_ceil)
    rÃ©sultat.ajoute_fonction_native(STR_cos, math_cos)
    rÃ©sultat.ajoute_fonction_native(STR_exp, math_exp)
    rÃ©sultat.ajoute_fonction_native(STR_floor, math_floor)
    rÃ©sultat.ajoute_fonction_native(STR_log, math_log)
    rÃ©sultat.ajoute_fonction_native(STR_max, math_max)
    rÃ©sultat.ajoute_fonction_native(STR_min, math_min)
    rÃ©sultat.ajoute_fonction_native(STR_pow, math_pow)
    rÃ©sultat.ajoute_fonction_native(STR_random, math_random)
    rÃ©sultat.ajoute_fonction_native(STR_round, math_round)
    rÃ©sultat.ajoute_fonction_native(STR_sin, math_sin)
    rÃ©sultat.ajoute_fonction_native(STR_sqrt, math_sqrt)

    /* Chaque realm doit avoir sa propre sÃ©rie. */
    graine := object_prototype comme n64 comme n32
    rÃ©sultat.entropie = graine_alÃ©atoire(graine)

    retourne rÃ©sultat
}

R64_INFINITÃ‰ : r64 : 0r7ff0000000000000
R64_INFINITÃ‰_NÃ‰GATIVE : r64 : 0rfff0000000000000

#portÃ©e_fichier

/* 21.3.2.1 Math.abs ( x )
 * https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-math.abs */
math_abs :: fonc (empl params: *ParamÃ¨tresObjectCall) -> Valeur
{
    x := params.donne_argument(0)
    // 1. Let n be ? ToNumber(x).
    n := to_number(interprÃ©teuse, x)
    si interprÃ©teuse.possÃ¨de_exception() {
        retourne js_undefined
    }

    // 2. If n is NaN, return NaN.
    si est_nan(n) {
        retourne NaN
    }

    // 3. If n is -0ğ”½, return +0ğ”½.
    si n == 0.0 {
        retourne 0.0 comme r64
    }

    // 4. If n is -âˆğ”½, return +âˆğ”½.
    si n == R64_INFINITÃ‰_NÃ‰GATIVE {
        retourne R64_INFINITÃ‰
    }

    // 5. If n < -0ğ”½, return -n.
    si n < 0.0 {
        retourne -n
    }

    // 6. Return n.
    retourne n
}

/* 21.3.2.10 Math.ceil ( x )
 * https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-math.ceil */
math_ceil :: fonc (empl params: *ParamÃ¨tresObjectCall) -> Valeur
{
    x := params.donne_argument(0)

    // 1. Let n be ? ToNumber(x).
    n := to_number(interprÃ©teuse, x)
    si interprÃ©teuse.possÃ¨de_exception() {
        retourne js_undefined
    }

    // 2. If n is not finite or n is either +0ğ”½ or -0ğ”½, return n.
    si !est_fini(n) || (n == 0.0 || n == -0.0) {
        retourne n
    }

    // 3. If n < -0ğ”½ and n > -1ğ”½, return -0ğ”½.
    si n < -0.0 && n > -1.0 {
        retourne -0.0 comme r64
    }

    // 4. If n is an integral Number, return n.
    si est_intÃ©gral(n) {
        retourne n
    }
    
    // 5. Return the smallest (closest to -âˆ) integral Number value that is not less than n.
    retourne plafond(n)
}

/* 21.3.2.12 Math.cos ( x )
 * https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-math.cos */
math_cos :: fonc (empl params: *ParamÃ¨tresObjectCall) -> Valeur
{
    // 1. Let n be ? ToNumber(x).
    n := to_number(interprÃ©teuse, params.donne_argument(0))
    si interprÃ©teuse.possÃ¨de_exception() {
        retourne js_undefined
    }

    // 2. If n is not finite, return NaN.
    si est_infini(n) {
        retourne NaN
    }

    // 3. If n is either +0ğ”½ or -0ğ”½, return 1ğ”½.
    si n == 0.0 || n == -0.0 {
        retourne 1.0 comme r64
    }

    // 4. Return an implementation-approximated Number value representing the cosine of â„(n).
    retourne cosinus(n)
}

/* 21.3.2.14 Math.exp ( x )
 * https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-math.exp */
math_exp :: fonc (empl params: *ParamÃ¨tresObjectCall) -> Valeur
{
    // 1. Let n be ? ToNumber(x).
    n := to_number(interprÃ©teuse, params.donne_argument(0))
    si interprÃ©teuse.possÃ¨de_exception() {
        retourne js_undefined
    }

    // 2. If n is either NaN or +âˆğ”½, return n.
    si est_nan(n) || n == R64_INFINITÃ‰ {
        retourne n
    }

    // 3. If n is either +0ğ”½ or -0ğ”½, return 1ğ”½.
    si n == 0.0 || n == -0.0 {
        retourne 1.0 comme r64
    }

    // 4. If n is -âˆğ”½, return +0ğ”½.
    si n == R64_INFINITÃ‰_NÃ‰GATIVE {
        retourne 0.0 comme r64
    }

    // 5. Return an implementation-approximated Number value representing the exponential function of â„(n).
    retourne exp(n)
}

/* 21.3.2.16 Math.floor ( x )
 * https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-math.floor */
math_floor :: fonc (empl params: *ParamÃ¨tresObjectCall) -> Valeur
{
    x := params.donne_argument(0)

    // 1. Let n be ? ToNumber(x).
    n := to_number(interprÃ©teuse, x)
    si interprÃ©teuse.possÃ¨de_exception() {
        retourne js_undefined
    }

    // 2. If n is not finite or n is either +0ğ”½ or -0ğ”½, return n.
    si !est_fini(n) || (n == 0.0 || n == -0.0) {
        retourne n
    }

    // 3. If n < 1ğ”½ and n > +0ğ”½, return +0ğ”½.
    si n < 1.0 && n > 0.0 {
        retourne 0.0 comme r64
    }

    // 4. If n is an integral Number, return n.
    si est_intÃ©gral(n) {
        retourne n
    }

    // 5. Return the greatest (closest to +âˆ) integral Number value that is not greater than n.
    retourne plancher(n)
}

/* 21.3.2.20 Math.log ( x )
 * https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-math.log */
math_log :: fonc (empl params: *ParamÃ¨tresObjectCall) -> Valeur
{
    x := params.donne_argument(0)

    // 1. Let n be ? ToNumber(x).
    n := to_number(interprÃ©teuse, x)
    si interprÃ©teuse.possÃ¨de_exception() {
        retourne js_undefined
    }

    // 2. If n is either NaN or +âˆğ”½, return n.
    si est_nan(n) || n == -R64_INFINITÃ‰ {
        retourne n
    }

    // 3. If n is 1ğ”½, return +0ğ”½.
    si n == 1.0 {
        retourne 0.0 comme r64
    }

    // 4. If n is either +0ğ”½ or -0ğ”½, return -âˆğ”½.
    si n == 0.0 || n == -0.0 {
        retourne R64_INFINITÃ‰_NÃ‰GATIVE
    }

    // 5. If n < -0ğ”½, return NaN.
    si n < -0.0 {
        retourne NaN
    }

    // 6. Return an implementation-approximated Number value representing the natural logarithm of â„(n).
    retourne log(n)
}

/* 21.3.2.24 Math.max ( ...args )
 * https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-math.min */
math_max :: fonc (empl params: *ParamÃ¨tresObjectCall) -> Valeur
{
    // 1. Let coerced be a new empty List.
    coerced: [..]r64
    diffÃ¨re dÃ©loge(coerced)

    // 2. For each element arg of args, do
    pour arguments {
        // a. Let n be ? ToNumber(arg).
        n := to_number(interprÃ©teuse, it)
        si interprÃ©teuse.possÃ¨de_exception() {
            retourne js_undefined
        }

        // b. Append n to coerced.
        tableau_ajoute(*coerced, n)
    }

    // 3. Let highest be -âˆğ”½.
    highest := R64_INFINITÃ‰_NÃ‰GATIVE

    // 4. For each element number of coerced, do
    pour coerced {
        // a. If number is NaN, return NaN.
        si est_nan(it) {
            retourne NaN
        }

        // b. b. If number is +0ğ”½ and highest is -0ğ”½, set highest to +0ğ”½.
        si it == 0.0 && highest == -0.0 {
            highest = 0.0
            continue
        }
        
        // c. If number > highest, set highest to number.
        si it > highest {
            highest = it
        }
    }

    // 5. Return highest.
    retourne highest
}

/* 21.3.2.25 Math.min ( ...args )
 * https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-math.min */
math_min :: fonc (empl params: *ParamÃ¨tresObjectCall) -> Valeur
{
    // 1. Let coerced be a new empty List.
    coerced: [..]r64
    diffÃ¨re dÃ©loge(coerced)

    // 2. For each element arg of args, do
    pour arguments {
        // a. Let n be ? ToNumber(arg).
        n := to_number(interprÃ©teuse, it)
        si interprÃ©teuse.possÃ¨de_exception() {
            retourne js_undefined
        }

        // b. Append n to coerced.
        tableau_ajoute(*coerced, n)
    }

    // 3. Let lowest be +âˆğ”½.
    lowest := R64_INFINITÃ‰

    // 4. For each element number of coerced, do
    pour coerced {
        // a. If number is NaN, return NaN.
        si est_nan(it) {
            retourne NaN
        }

        // b. If number is -0ğ”½ and lowest is +0ğ”½, set lowest to -0ğ”½.
        si it == -0.0 && lowest == 0.0 {
            lowest = -0.0
            continue
        }
        
        // c. If number < lowest, set lowest to number.
        si it < lowest {
            lowest = it
        }
    }

    // 5. Return lowest.
    retourne lowest
}

/* 21.3.2.26 Math.pow ( base, exponent )
 * https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-math.pow */
math_pow :: fonc (empl params: *ParamÃ¨tresObjectCall) -> Valeur
{
    // 1. Set base to ? ToNumber(base).
    base := to_number(interprÃ©teuse, params.donne_argument(0))
    si interprÃ©teuse.possÃ¨de_exception() {
        retourne js_undefined
    }

    // 2. Set exponent to ? ToNumber(exponent).
    exponent := to_number(interprÃ©teuse, params.donne_argument(1))
    si interprÃ©teuse.possÃ¨de_exception() {
        retourne js_undefined
    }

    // 3. Return Number::exponentiate(base, exponent).
    retourne number_exponentiate(base, exponent)
}

/* 21.3.2.27 Math.random ( )
 * https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-math.random */
math_random :: fonc (empl params: *ParamÃ¨tresObjectCall) -> Valeur
{
    math := this_value.donne_objet().vÃ©rifie_comme(MathObject)
    rÃ©sultat := alÃ©atoire_unilatÃ©rale(math.entropie)
    retourne rÃ©sultat comme r64
}

/* 21.3.2.28 Math.round ( x )
 * https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-math.round */
math_round :: fonc (empl params: *ParamÃ¨tresObjectCall) -> Valeur
{
    // 1. Let n be ? ToNumber(x).
    n := to_number(interprÃ©teuse, params.donne_argument(0))
    si interprÃ©teuse.possÃ¨de_exception() {
        retourne js_undefined
    }

    // 2. If n is not finite or n is an integral Number, return n.
    si est_infini(n) || est_intÃ©gral(n) {
        retourne n
    }

    // 3. If n < 0.5ğ”½ and n > +0ğ”½, return +0ğ”½.
    si n < 0.5 && n > 0.0 {
        retourne 0.0 comme r64
    }

    // 4. If n < -0ğ”½ and n â‰¥ -0.5ğ”½, return -0ğ”½.
    si n < -0.0 && n >= -0.5 {
        retourne -0.0 comme r64
    }

    // 5. Return the integral Number closest to n, preferring the Number closer to +âˆ in the case of a tie.
    retourne arrondis(n)
}

/* 21.3.2.30 Math.sin ( x )
 * https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-math.sin */
math_sin :: fonc (empl params: *ParamÃ¨tresObjectCall) -> Valeur
{
    // 1. Let n be ? ToNumber(x).
    n := to_number(interprÃ©teuse, params.donne_argument(0))
    si interprÃ©teuse.possÃ¨de_exception() {
        retourne js_undefined
    }

    // 2. If n is one of NaN, +0ğ”½, or -0ğ”½, return n.
    si est_nan(n) || n == 0.0 || n == -0.0 {
        retourne n
    }

    // 3. If n is either +âˆğ”½ or -âˆğ”½, return NaN.
    si est_infini(n) {
        retourne NaN
    }

    // 4. Return an implementation-approximated Number value representing the sine of â„(n).
    retourne sinus(n)
}

/* 21.3.2.32 Math.sqrt ( x )
 * https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-math.random */
math_sqrt :: fonc (empl params: *ParamÃ¨tresObjectCall) -> Valeur
{
    // 1. Let n be ? ToNumber(x).
    n := to_number(interprÃ©teuse, params.donne_argument(0))
    si interprÃ©teuse.possÃ¨de_exception() {
        retourne js_undefined
    }

    // 2. If n is one of NaN, +0ğ”½, -0ğ”½, or +âˆğ”½, return n.
    si est_nan(n) || n == 0.0 || n == -0.0 || n == R64_INFINITÃ‰ {
        retourne n
    }

    // 3. If n < -0ğ”½, return NaN.
    si n < -0.0 {
        retourne NaN
    }

    // 4. Return ğ”½(the square root of â„(n)).
    retourne racine_carrÃ©e(n)
}

/** \} */
