importe AlÃ©a
importe Math

/* ------------------------------------------------------------------------- */
/** \nom Math
 * https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-math-object
 * \{ */

MathObject :: struct {
    empl object: Object
    table = *table_virtuelle_math

    entropie: SÃ©rieAlÃ©atoire
}

#portÃ©e_fichier

table_virtuelle_math := TableVirtuelleObject(classe = MathObject, sur_destruction = sur_destruction_objet)

#portÃ©e_module

crÃ©e_math_object :: fonc (object_prototype: *ObjectPrototype) -> *MathObject
{
    rÃ©sultat := object_prototype.donne_tas_de_mÃ©moire().alloue(MathObject)
    rÃ©sultat.prototype = object_prototype
    rÃ©sultat.ajoute_fonction_native(STR_max, math_max)
    rÃ©sultat.ajoute_fonction_native(STR_min, math_min)
    rÃ©sultat.ajoute_fonction_native(STR_random, math_random)
    rÃ©sultat.ajoute_fonction_native(STR_sqrt, math_sqrt)

    /* Chaque realm doit avoir sa propre sÃ©rie. */
    graine := object_prototype comme n64 comme n32
    rÃ©sultat.entropie = graine_alÃ©atoire(graine)

    retourne rÃ©sultat
}

/* Ã€ FAIRE(langage) : erreur de compilation */
// R64_INFINITÃ‰ : r64 : 0r7ff0000000000000
// R64_INFINITÃ‰_NÃ‰GATIVE : r64 : 0rfff0000000000000
R64_INFINITÃ‰ : r64 : 1000000000.0
R64_INFINITÃ‰_NÃ‰GATIVE : r64 : -1000000000.0

#portÃ©e_fichier

/* https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-math.min */
math_max :: fonc (empl params: *ParamÃ¨tresObjectCall) -> CompletionRecord
{
    // 1. Let coerced be a new empty List.
    coerced: [..]r64
    diffÃ¨re dÃ©loge(coerced)

    // 2. For each element arg of args, do
    pour arguments {
        // a. Let n be ? ToNumber(arg).
        completion := vers_nombre(interprÃ©teuse, it)
        saufsi completion.est_normal() {
            retourne completion
        }

        // b. Append n to coerced.
        tableau_ajoute(*coerced, completion.valeur.V.Number)
    }

    // 3. Let highest be -âˆğ”½.
    highest := R64_INFINITÃ‰_NÃ‰GATIVE

    // 4. For each element number of coerced, do
    pour coerced {
        // a. If number is NaN, return NaN.
        si est_nan(it) {
            retourne normal_completion(Valeur(Number = NaN))
        }

        // b. b. If number is +0ğ”½ and highest is -0ğ”½, set highest to +0ğ”½.
        si it == 0.0 && highest == -0.0 {
            highest = 0.0
            continue
        }
        
        // c. If number > highest, set highest to number.
        si it > highest {
            highest = it
        }
    }

    // 5. Return highest.
    retourne normal_completion(Valeur(Number = highest))
}

/* https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-math.min */
math_min :: fonc (empl params: *ParamÃ¨tresObjectCall) -> CompletionRecord
{
    // 1. Let coerced be a new empty List.
    coerced: [..]r64
    diffÃ¨re dÃ©loge(coerced)

    // 2. For each element arg of args, do
    pour arguments {
        // a. Let n be ? ToNumber(arg).
        completion := vers_nombre(interprÃ©teuse, it)
        saufsi completion.est_normal() {
            retourne completion
        }

        // b. Append n to coerced.
        tableau_ajoute(*coerced, completion.valeur.V.Number)
    }

    // 3. Let lowest be +âˆğ”½.
    lowest := R64_INFINITÃ‰

    // 4. For each element number of coerced, do
    pour coerced {
        // a. If number is NaN, return NaN.
        si est_nan(it) {
            retourne normal_completion(Valeur(Number = NaN))
        }

        // b. If number is -0ğ”½ and lowest is +0ğ”½, set lowest to -0ğ”½.
        si it == -0.0 && lowest == 0.0 {
            lowest = -0.0
            continue
        }
        
        // c. If number < lowest, set lowest to number.
        si it < lowest {
            lowest = it
        }
    }

    // 5. Return lowest.
    retourne normal_completion(Valeur(Number = lowest))
}

/* https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-math.random */
math_random :: fonc (empl params: *ParamÃ¨tresObjectCall) -> CompletionRecord
{
    math := this_value.donne_objet() comme *MathObject
    rÃ©sultat := alÃ©atoire_unilatÃ©rale(math.entropie)
    retourne normal_completion(Valeur(Number = rÃ©sultat))
}

/* https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-math.random */
math_sqrt :: fonc (empl params: *ParamÃ¨tresObjectCall) -> CompletionRecord
{
    // 1. Let n be ? ToNumber(x).
    completion := vers_nombre(interprÃ©teuse, params.donne_argument(0))
    saufsi completion.est_normal() {
        retourne completion
    }
    n := completion.valeur.V.Number

    // 2. If n is one of NaN, +0ğ”½, -0ğ”½, or +âˆğ”½, return n.
    si est_nan(n) || n == 0.0 || n == -0.0 || n == R64_INFINITÃ‰ {
        retourne normal_completion(Valeur(Number = n))
    }

    // 3. If n < -0ğ”½, return NaN.
    si n < -0.0 {
        retourne normal_completion(Valeur(Number = NaN))
    }

    // 4. Return ğ”½(the square root of â„(n)).
    retourne normal_completion(Valeur(Number = racine_carrÃ©e(n)))
}

/** \} */
