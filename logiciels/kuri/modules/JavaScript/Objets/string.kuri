/* ------------------------------------------------------------------------- */
/** \nom StringPrototype
 * https://tc39.es/ecma262/multipage/text-processing.html#sec-properties-of-the-string-prototype-object
 * \{ */

#port√©e_fichier

table_virtuelle_string_prototype := TableVirtuelleObject(classe = StringPrototype)

#port√©e_export

StringPrototype :: struct {
    empl objet: Object
    table = *table_virtuelle_string_prototype

    string_data: *PrimitiveChaine
}

cr√©e_string_prototype :: fonc (realm: *Realm, prototype: *ObjectPrototype) -> *StringPrototype
{
    tas_de_m√©moire := realm.donne_tas_de_m√©moire()
    r√©sultat := tas_de_m√©moire.alloue(StringPrototype)
    r√©sultat.prototype = prototype
    r√©sultat.string_data = cr√©e_chaine(realm, cr√©e_chaine_utf16_unique(""))
    r√©sultat.ajoute_propri√©t√©(STR_length, Valeur(Number = 0.0), DrapeauxPropri√©t√©.z√©ro)

    r√©sultat.ajoute_fonction_native(STR_indexOf, string_prototype_index_of, 1)
    r√©sultat.ajoute_fonction_native(STR_replace, string_prototype_replace, 3)
    r√©sultat.ajoute_fonction_native(STR_substring, string_prototype_substring, 2)

    retourne r√©sultat
}

#port√©e_fichier

/* 22.1.3.9 String.prototype.indexOf ( searchString [ , position ] )
 * https://tc39.es/ecma262/multipage/text-processing.html#sec-string.prototype.indexof */
string_prototype_index_of :: fonc (empl params: *Param√®tresObjectCall) -> Valeur
{
    // 1. Let O be ? RequireObjectCoercible(this value).
    O := require_object_coercible(interpr√©teuse.donne_realm(), this_value)
    si interpr√©teuse.poss√®de_exception() {
        retourne js_undefined
    }

    // 2. Let S be ? ToString(O).
    S := to_string(interpr√©teuse, O)
    si interpr√©teuse.poss√®de_exception() {
        retourne js_undefined
    }

    // 3. Let searchStr be ? ToString(searchString).
    search_str := to_string(interpr√©teuse, params.donne_argument(0))
    si interpr√©teuse.poss√®de_exception() {
        retourne js_undefined
    }

    // 4. Let pos be ? ToIntegerOrInfinity(position).
    position := params.donne_argument(1)
    pos := to_integer_or_infinity(interpr√©teuse, position)
    si interpr√©teuse.poss√®de_exception() {
        retourne js_undefined
    }

    // 5. Assert: If position is undefined, then pos is 0.
    assert(!position.est_undefined() || pos == 0.0)

    // 6. Let len be the length of S.
    len := S.texte.taille()

    // 7. Let start be the result of clamping pos between 0 and len.
    start := pos
    si start < 0.0 {
        start = 0.0
    }
    sinon si start > len comme r64 {
        start = len comme r64
    }

    // 8. Let result be StringIndexOf(S, searchStr, start).
    result := string_index_of(S.texte, search_str.texte, start comme z64)

    // 9. If result is not-found, return -1ùîΩ.
    // 10. Return ùîΩ(result).
    retourne result comme r64
}

/* 22.1.3.19 String.prototype.replace ( searchValue, replaceValue )
 * https://tc39.es/ecma262/multipage/text-processing.html#sec-string.prototype.replace */
string_prototype_replace :: fonc (empl params: *Param√®tresObjectCall) -> Valeur
{
    // √Ä FAIRE : impl√©mente
    O := require_object_coercible(interpr√©teuse.donne_realm(), this_value)
    si interpr√©teuse.poss√®de_exception() {
        retourne js_undefined
    }

    // 2. Let S be ? ToString(O).
    retourne to_string(interpr√©teuse, O)
}

/* 22.1.3.25 String.prototype.substring ( start, end )
 * https://tc39.es/ecma262/multipage/text-processing.html#sec-string.prototype.substring */
string_prototype_substring :: fonc (empl params: *Param√®tresObjectCall) -> Valeur
{
    // 1. Let O be ? RequireObjectCoercible(this value).
    O := require_object_coercible(interpr√©teuse.donne_realm(), this_value)
    si interpr√©teuse.poss√®de_exception() {
        retourne js_undefined
    }

    // 2. Let S be ? ToString(O).
    S := to_string(interpr√©teuse, O)
    si interpr√©teuse.poss√®de_exception() {
        retourne js_undefined
    }

    // 3. Let len be the length of S.
    len := S.texte.taille()

    // 4. Let intStart be ? ToIntegerOrInfinity(start).
    int_start := to_integer_or_infinity(interpr√©teuse, params.donne_argument(0))
    si interpr√©teuse.poss√®de_exception() {
        retourne js_undefined
    }

    // 5. If end is undefined, let intEnd be len; else let intEnd be ? ToIntegerOrInfinity(end).
    end := params.donne_argument(1)
    int_end: z64
    si end.est_undefined() {
        int_end = len
    }
    sinon {
        int_end = to_integer_or_infinity(interpr√©teuse, end) comme z64
        si interpr√©teuse.poss√®de_exception() {
            retourne js_undefined
        }
    }

    // 6. Let finalStart be the result of clamping intStart between 0 and len.
    final_start := int_start
    si final_start < 0 {
        final_start = 0
    }
    sinon si final_start > len comme r64 {
        final_start = len comme r64
    }

    // 7. Let finalEnd be the result of clamping intEnd between 0 and len.
    final_end := int_end
    si final_end < 0 {
        final_end = 0
    }
    sinon si final_end > len {
        final_end = len
    }

    // 8. Let from be min(finalStart, finalEnd).
    from := min(final_start, final_end comme r64) comme z64

    // 9. Let to be max(finalStart, finalEnd).
    to := max(final_start, final_end comme r64) comme z64

    // 10. Return the substring of S from from to to.
    S16 := S.texte.donne_chaine_utf16()

    substring: ChaineUTF16
    substring.unit√©s.pointeur = S16.unit√©s.pointeur + from
    substring.unit√©s.taille = to - from

    r√©sultat := cr√©e_chaine_utf16_unique(substring)
    retourne cr√©e_chaine(interpr√©teuse.donne_realm(), r√©sultat)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom StringObject
 * https://tc39.es/ecma262/multipage/text-processing.html#sec-string-objects
 * \{ */

#port√©e_fichier

table_virtuelle_objet_chaine := TableVirtuelleObject(classe = StringObject)

#port√©e_export

StringObject :: struct {
    empl objet: Object
    table = *table_virtuelle_objet_chaine

    chn: *PrimitiveChaine
}

cr√©e_chaine :: fonc (tas_de_m√©moire: *TasDeM√©moire, string_prototype: *StringPrototype, chn: *PrimitiveChaine) -> *StringObject
{
    r√©sultat := tas_de_m√©moire.alloue(StringObject)
    r√©sultat.prototype = string_prototype
    r√©sultat.chn = chn

    r√©sultat.ajoute_propri√©t√©(STR_length, Valeur(Number = chn.texte.donne_chaine_utf16().taille() comme r64), DrapeauxPropri√©t√©.z√©ro)
    r√©sultat.ajoute_propri√©t√©(STR_prototype, Valeur(Object = string_prototype), DrapeauxPropri√©t√©.z√©ro)

    retourne r√©sultat
}

/* 6.1.4.1 StringIndexOf ( string, searchValue, fromIndex )
 * https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-stringindexof */
string_index_of :: fonc (string: ECMAString, search_value: ECMAString, from_index: z64) -> z64
{
    // 1. Let len be the length of string.
    len := string.taille()

    // 2. If searchValue is the empty String and fromIndex ‚â§ len, return fromIndex.
    si search_value.est_vide() && from_index <= len {
        retourne from_index
    }

    // 3. Let searchLen be the length of searchValue.
    search_len := search_value.taille()

    // 4. For each integer i such that fromIndex ‚â§ i ‚â§ len - searchLen, in ascending order, do
    string_utf16 := string.donne_chaine_utf16()
    search_value_utf16 := search_value.donne_chaine_utf16()

    index := from_index
    indice_final := len - search_len

    candidate: ChaineUTF16
    candidate.unit√©s.pointeur = string_utf16.unit√©s.pointeur + from_index
    candidate.unit√©s.taille = search_len

    tantque index <= indice_final {
        // a. Let candidate be the substring of string from i to i + searchLen.
        // b. If candidate is searchValue, return i.
        si candidate == search_value_utf16 {
            retourne index
        }

        candidate.unit√©s.pointeur += 1
        index += 1
    }

    // 5. Return not-found.
    retourne -1
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom StringConstructor
 * https://tc39.es/ecma262/multipage/text-processing.html#sec-properties-of-the-string-constructor
 * \{ */

#port√©e_fichier

table_virtuelle_string_constructor := TableVirtuelleObject(
    classe = StringConstructor
)

#port√©e_export

StringConstructor :: struct {
    empl builtin_function: BuiltInFunction
    table = *table_virtuelle_string_constructor
}

cr√©e_string_constructor :: fonc (realm: *Realm, function_prototype: *FunctionPrototype, string_prototype: *StringPrototype) -> *StringConstructor
{
    tas_de_m√©moire := realm.donne_tas_de_m√©moire()
    r√©sultat := tas_de_m√©moire.alloue(StringConstructor)
    create_builtin_function(r√©sultat, 1, STR_String, realm, function_prototype)

    r√©sultat.ajoute_propri√©t√©(STR_prototype, Valeur(Object = string_prototype), DrapeauxPropri√©t√©.z√©ro)

    string_prototype.ajoute_propri√©t√©(STR_constructor, Valeur(Object = r√©sultat), DrapeauxPropri√©t√©.z√©ro)

    retourne r√©sultat
}

/** \} */
