importe Chaine

/* ------------------------------------------------------------------------- */
/** \nom Error
 * https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-error-objects
 * \{ */

#portée_fichier

table_virtuelle_error := TableVirtuelleObject(classe = Error, sur_destruction = sur_destruction_objet)

#portée_export

Error :: struct {
    empl objet: Object
    table = *table_virtuelle_error
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ErrorPrototype
 * https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-properties-of-the-error-prototype-object
 * \{ */

#portée_fichier

table_virtuelle_error_prototype := TableVirtuelleObject(classe = ErrorPrototype, sur_destruction = sur_destruction_objet)

#portée_export

ErrorPrototype :: struct {
    empl objet: Object
    table = *table_virtuelle_error_prototype
}

crée_error_prototype :: fonc (tas_de_mémoire: *TasDeMémoire, prototype: *ObjectPrototype) -> *ErrorPrototype
{
    résultat := tas_de_mémoire.alloue(ErrorPrototype)
    résultat.prototype = prototype
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ReferenceError
 * https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-native-error-types-used-in-this-standard-referenceerror
 * \{ */

#portée_fichier

table_virtuelle_reference_error := TableVirtuelleObject(classe = ReferenceError, sur_destruction = sur_destruction_objet)

#portée_export

ReferenceError :: struct {
    empl error: Error
    table = *table_virtuelle_reference_error

    message: *PrimitiveChaine
}

crée_reference_error :: fonc (tas_de_mémoire: *TasDeMémoire, prototype: *ReferenceErrorPrototype, message: chaine) -> *ReferenceError
{
    résultat := tas_de_mémoire.alloue(ReferenceError)
    résultat.prototype = prototype
    résultat.message = crée_chaine(tas_de_mémoire, crée_chaine_utf16_unique(message))
    retourne résultat
}

lance_reference_error :: fonc (realm: *Realm, message: chaine) -> CompletionRecord
{
    exception := crée_reference_error(realm.donne_tas_de_mémoire(), realm.intrinsics.reference_error_prototype, message)
    retourne throw_completion(exception)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ReferenceErrorPrototype
 * https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-properties-of-the-nativeerror-prototype-objects
 * \{ */

#portée_fichier

table_virtuelle_reference_error_prototype := TableVirtuelleObject(classe = ReferenceErrorPrototype, sur_destruction = sur_destruction_objet)

#portée_export

ReferenceErrorPrototype :: struct {
    empl objet: Object
    table = *table_virtuelle_reference_error_prototype
}

crée_reference_error_prototype :: fonc (tas_de_mémoire: *TasDeMémoire, prototype: *ErrorPrototype) -> *ReferenceErrorPrototype
{
    résultat := tas_de_mémoire.alloue(ReferenceErrorPrototype)
    résultat.prototype = prototype
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom SyntaxError
 * https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-native-error-types-used-in-this-standard-syntaxerror
 * \{ */

#portée_fichier

table_virtuelle_syntax_error := TableVirtuelleObject(classe = SyntaxError, sur_destruction = sur_destruction_objet)

#portée_export

SyntaxError :: struct {
    empl error: Error
    table = *table_virtuelle_syntax_error

    message: *PrimitiveChaine
}

crée_syntax_error :: fonc (tas_de_mémoire: *TasDeMémoire, prototype: *SyntaxErrorPrototype, message: chaine) -> *SyntaxError
{
    résultat := tas_de_mémoire.alloue(SyntaxError)
    résultat.prototype = prototype
    résultat.message = crée_chaine(tas_de_mémoire, crée_chaine_utf16_unique(message))
    retourne résultat
}

lance_syntax_error :: fonc (interpréteuse: *Interpréteuse, message: chaine) -> CompletionRecord
{
    retourne lance_syntax_error(interpréteuse.donne_realm(), message)
}

lance_syntax_error :: fonc (realm: *Realm, message: chaine) -> CompletionRecord
{
    exception := crée_syntax_error(realm.donne_tas_de_mémoire(), realm.intrinsics.syntax_error_prototype, message)
    retourne throw_completion(exception)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom SyntaxErrorPrototype
 * https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-properties-of-the-nativeerror-prototype-objects
 * \{ */

#portée_fichier

table_virtuelle_syntax_error_prototype := TableVirtuelleObject(classe = SyntaxErrorPrototype, sur_destruction = sur_destruction_objet)

#portée_export

SyntaxErrorPrototype :: struct {
    empl objet: Object
    table = *table_virtuelle_syntax_error_prototype
}

crée_syntax_error_prototype :: fonc (tas_de_mémoire: *TasDeMémoire, prototype: *ErrorPrototype) -> *SyntaxErrorPrototype
{
    résultat := tas_de_mémoire.alloue(SyntaxErrorPrototype)
    résultat.prototype = prototype
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom TypeError
 * https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-native-error-types-used-in-this-standard-typeerror
 * \{ */

#portée_fichier

table_virtuelle_type_error := TableVirtuelleObject(classe = TypeError, sur_destruction = sur_destruction_objet)

#portée_export

TypeError :: struct {
    empl error: Error
    table = *table_virtuelle_type_error

    message: *PrimitiveChaine
}

crée_type_error :: fonc (tas_de_mémoire: *TasDeMémoire, prototype: *TypeErrorPrototype, message: chaine) -> *TypeError
{
    résultat := tas_de_mémoire.alloue(TypeError)
    résultat.prototype = prototype
    résultat.message = crée_chaine(tas_de_mémoire, crée_chaine_utf16_unique(message))
    retourne résultat
}

lance_type_error :: fonc (interpréteuse: *Interpréteuse, message: chaine) -> CompletionRecord
{
    retourne lance_type_error(interpréteuse.donne_realm(), message)
}

lance_type_error :: fonc (realm: *Realm, message: chaine) -> CompletionRecord
{
    exception := crée_type_error(realm.donne_tas_de_mémoire(), realm.intrinsics.type_error_prototype, message)
    retourne throw_completion(exception)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom TypeErrorPrototype
 * https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-properties-of-the-nativeerror-prototype-objects
 * \{ */

#portée_fichier

table_virtuelle_type_error_prototype := TableVirtuelleObject(classe = TypeErrorPrototype, sur_destruction = sur_destruction_objet)

#portée_export

TypeErrorPrototype :: struct {
    empl objet: Object
    table = *table_virtuelle_type_error_prototype
}

crée_type_error_prototype :: fonc (tas_de_mémoire: *TasDeMémoire, prototype: *ErrorPrototype) -> *TypeErrorPrototype
{
    résultat := tas_de_mémoire.alloue(TypeErrorPrototype)
    résultat.prototype = prototype
    retourne résultat
}

/** \} */
