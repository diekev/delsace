importe Chaine
importe Fondation
importe Num√©rique

/* ------------------------------------------------------------------------- */
/** \nom ObjetArray
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-array-exotic-objects
 * \{ */

#port√©e_fichier

table_virtuelle_objet_array := TableVirtuelleObject(classe = ObjetArray, sur_destruction = sur_destruction_objet, sur_define_own_property = array_instance_define_own_property)

#port√©e_export

ObjetArray :: struct {
    empl objet: Object
    table = *table_virtuelle_objet_array
}

cr√©e_array :: fonc (tas_de_m√©moire: *TasDeM√©moire, array_prototype: *ArrayPrototype, nombre_√©l√©ments: z64) -> *ObjetArray
{
    r√©sultat := tas_de_m√©moire.alloue(ObjetArray)
    r√©sultat.prototype = array_prototype

    r√©sultat.ajoute_propri√©t√©(STR_length, Valeur(Number = nombre_√©l√©ments comme r64), Writable)

    retourne r√©sultat
}

#port√©e_fichier

is_non_negative_integral_number :: fonc (valeur: Valeur) -> bool
{
    saufsi valeur.est_nombre() {
        retourne faux
    }
    n := valeur.Number
    si n < 0.0 {
        retourne faux
    }
    in := n comme n64
    retourne n == in comme r64
}

/* https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#array-index */
is_array_index :: fonc (property_key: PropertyKey) -> bool
{
    saufsi property_key.est_chaine() {
        retourne faux
    }

    /* √Ä FAIRE */
    texte := property_key.String.donne_chaine_utf16()

    texte_utf8 := converti_vers_chaine(texte)
    diff√®re d√©loge(texte_utf8)

    r√©sultat := tente extrait_r64(texte_utf8) pi√®ge _ {
        retourne faux
    }

    retourne is_non_negative_integral_number(r√©sultat)
}

to_uint32 :: fonc (property_key: PropertyKey) -> n32
{
    texte := property_key.String.donne_chaine_utf16()

    /* √Ä FAIRE */
    texte_utf8 := converti_vers_chaine(texte)
    diff√®re d√©loge(texte_utf8)

    r√©sultat := tente extrait_r64(texte_utf8) pi√®ge nonatteignable
    retourne r√©sultat comme n32
}

/* 10.4.2.1 [[DefineOwnProperty]] ( P, Desc )
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-array-exotic-objects-defineownproperty-p-desc */
array_instance_define_own_property :: fonc (object: *Object, property_key: PropertyKey, desc: &PropertyDescriptor) -> CompletionRecord
{
    A := object comme *ObjetArray

    // 1. If P is "length", then
    si property_key == STR_length {
        // a. Return ? ArraySetLength(A, Desc).
        retourne array_set_length(A, desc)
    }

    // 2. Else if P is an array index, then
    si is_array_index(property_key) {
        // a. Let lengthDesc be OrdinaryGetOwnProperty(A, "length").
        length_desc := ordinary_get_own_property(A, STR_length).valeur.P

        // b. Assert: IsDataDescriptor(lengthDesc) is true.
        assert(is_data_descriptor(length_desc))

        // c. Assert: lengthDesc.[[Configurable]] is false.
        assert(length_desc.configurable == faux)

        // d. Let length be lengthDesc.[[Value]].
        length := length_desc.value.Quelque

        // e. Assert: length is a non-negative integral Number.
        assert(is_non_negative_integral_number(length))

        // f. Let index be ! ToUint32(P).
        index := to_uint32(property_key)

        // g. If index ‚â• length and lengthDesc.[[Writable]] is false, return false.
        si index >= length.Number comme n32 && length_desc.writable == faux {
            retourne normal_completion(Valeur(Boolean = faux))
        }

        // h. Let succeeded be ! OrdinaryDefineOwnProperty(A, P, Desc).
        succeeded := ordinary_define_own_property(A, property_key, desc).valeur.V   

        // i. If succeeded is false, return false.
        si succeeded.est_false() {
            retourne normal_completion(Valeur(Boolean = faux))
        }

        // j. If index ‚â• length, then
        si index >= length.Number comme n32 {
            // i. Set lengthDesc.[[Value]] to index + 1ùîΩ.
            length_desc.value = Valeur(Number = (index + 1) comme r64)
            // ii. Set succeeded to ! OrdinaryDefineOwnProperty(A, "length", lengthDesc).
            succeeded = ordinary_define_own_property(A, STR_length, length_desc).valeur.V
            // iii. Assert: succeeded is true.
            assert(succeeded.est_true())
        }

        // k. Return true.
        retourne normal_completion(Valeur(Boolean = vrai))
    }

    // 3. Return ? OrdinaryDefineOwnProperty(A, P, Desc).
    retourne ordinary_define_own_property(object, property_key, desc)
}

/* 10.4.2.4 ArraySetLength ( A, Desc ) 
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-arraysetlength */
array_set_length :: fonc (A: *ObjetArray, desc: &PropertyDescriptor) -> CompletionRecord
{
    /* √Ä FAIRE */
    retourne ordinary_define_own_property(A, STR_length, desc)
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ArrayConstructor
 * https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array-constructor
 * \{ */

#port√©e_fichier

table_virtuelle_array_constructor := TableVirtuelleBuiltinFunction(classe = ArrayConstructor, sur_destruction = sur_destruction_objet)

#port√©e_export

ArrayConstructor :: struct {
    empl builtin_function: BuiltInFunction
    table = *table_virtuelle_array_constructor

    sur_call_or_construct = array_constructor_call_or_construct
}

cr√©e_array_constructor :: fonc (realm: *Realm, function_prototype: *FunctionPrototype , array_prototype: *ArrayPrototype) -> *ArrayConstructor
{
    tas_de_m√©moire := realm.donne_tas_de_m√©moire()
    r√©sultat := tas_de_m√©moire.alloue(ArrayConstructor)
    create_builtin_function(r√©sultat, 1, STR_Array, realm, function_prototype)

    /* https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype */
    r√©sultat.ajoute_propri√©t√©(STR_prototype, Valeur(Object = array_prototype), DrapeauxPropri√©t√©.z√©ro)

    /* https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.constructor */
    array_prototype.ajoute_propri√©t√©(STR_constructor, Valeur(Object = r√©sultat), DrapeauxPropri√©t√©.z√©ro)

    retourne r√©sultat
}

/* √Ä FAIRE : standardise
 * https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array */
array_constructor_call_or_construct :: fonc (empl params: *Param√®tresCallOrConstruct) -> CompletionRecord
{
    realm := interpr√©teuse.donne_realm()

    r√©sultat := cr√©e_array(realm.donne_tas_de_m√©moire(), realm.intrinsics.array_prototype, 0)

    si arguments.taille != 0 {
        completion := vers_nombre(interpr√©teuse, arguments[0])
        saufsi completion.est_normal() {
            retourne completion
        }
        len := completion.valeur.V.Number

        completion = set(r√©sultat, STR_length, Valeur(Number = len), vrai)
        saufsi completion.est_normal() {
            retourne completion
        }
    }

    retourne normal_completion(Valeur(Object = r√©sultat))
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ArrayPrototype
 * https://tc39.es/ecma262/multipage/indexed-collections.html#sec-properties-of-the-array-prototype-object
 * \{ */

#port√©e_fichier

table_virtuelle_array_prototype := TableVirtuelleObject(classe = ArrayPrototype, sur_destruction = sur_destruction_objet)

#port√©e_export

ArrayPrototype :: struct {
    empl objet: Object
    table = *table_virtuelle_array_prototype
}

cr√©e_array_prototype :: fonc (tas_de_m√©moire: *TasDeM√©moire, prototype: *ObjectPrototype) -> *ArrayPrototype
{
    r√©sultat := tas_de_m√©moire.alloue(ArrayPrototype)
    r√©sultat.prototype = prototype

    r√©sultat.ajoute_propri√©t√©(STR_length, Valeur(Number = 0.0), Writable)
    r√©sultat.ajoute_fonction_native(STR_join, array_prototype_join)
    r√©sultat.ajoute_fonction_native(STR_push, array_prototype_push, 1)
    r√©sultat.ajoute_fonction_native(STR_toString, array_prototype_to_string)

    retourne r√©sultat
}

/* 23.1.3.18 Array.prototype.join ( separator )
 * https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.join */
array_prototype_join :: fonc (empl params: *Param√®tresObjectCall) -> CompletionRecord
{
    // 1. Let O be ? ToObject(this value).
    completion := vers_objet(interpr√©teuse.donne_realm(), this_value)
    saufsi completion.est_normal() {
        retourne completion
    }
    O := completion.donne_object()

    // 2. Let len be ? LengthOfArrayLike(O).
    completion = length_of_array_like(O)
    saufsi completion.est_normal() {
        retourne completion
    }
    len := completion.valeur.V.Number

    // 3. If separator is undefined, let sep be ",".
    sep: ECMAString
    si arguments.taille == 0 {
        sep = cr√©e_chaine_utf16_unique(",")
    }
    // 4. Else, let sep be ? ToString(separator).
    sinon {
        completion = vers_chaine(interpr√©teuse, arguments[0])
        saufsi completion.est_normal() {
            retourne completion
        }
        sep = completion.valeur.V.String.texte
    }

    // 5. Let R be the empty String.
    R: EnchaineuseUTF16
    initialise_enchaineuse(R)
    diff√®re d√©truit_tampons(R)

    // 6. Let k be 0.
    k := 0.0

    // 7. Repeat, while k < len,
    tantque k < len {
        // a. If k > 0, set R to the string-concatenation of R and sep.
        si k > 0.0 {
            ajoute(R, sep.donne_chaine_utf16())
        }

        // b. Let element be ? Get(O, ! ToString(ùîΩ(k))).
        nom_propri√©t√© := vers_chaine(interpr√©teuse, Valeur(Number = k)).valeur.V.String.texte
        completion = get(O, nom_propri√©t√©)
        saufsi completion.est_normal() {
            retourne completion
        }
        element := completion.valeur.V

        // c. If element is neither undefined nor null, then
        saufsi element.est_nulle() || element.est_undefined() {
            // i. Let S be ? ToString(element).
            completion = vers_chaine(interpr√©teuse, element)
            saufsi completion.est_normal() {
                retourne completion
            }
            S := completion.valeur.V.String.texte

            // ii. Set R to the string-concatenation of R and S.
            ajoute(R, S.donne_chaine_utf16())
        }

        // d. Set k to k + 1.
        k += 1.0
    }

    // 8. Return R.
    r√©sultat := chaine_depuis_enchaineuse(R)
    diff√®re d√©truit_chaine(r√©sultat)
    valeur_r√©sultat := cr√©e_chaine(interpr√©teuse.donne_realm(), cr√©e_chaine_utf16_unique(r√©sultat))
    retourne normal_completion(Valeur(String = valeur_r√©sultat))
}

/* 23.1.3.23 Array.prototype.push ( ...items )
 * https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.push */
array_prototype_push :: fonc (empl params: *Param√®tresObjectCall) -> CompletionRecord
{
    // 1. Let O be ? ToObject(this value).
    completion := vers_objet(interpr√©teuse.donne_realm(), this_value)
    saufsi completion.est_normal() {
        retourne completion
    }
    O := completion.donne_object()

    // 2. Let len be ? LengthOfArrayLike(O).
    completion = length_of_array_like(O)
    saufsi completion.est_normal() {
        retourne completion
    }
    len := completion.valeur.V.Number

    // 3. Let argCount be the number of elements in items.
    // arg_count := arguments.taille

    // √Ä FAIRE : 4. If len + argCount > 2**53 - 1, throw a TypeError exception.

    // 5. For each element E of items, do
    pour arguments {
        // a. Perform ? Set(O, ! ToString(ùîΩ(len)), E, true).
        nom_propri√©t√© := vers_chaine(interpr√©teuse, Valeur(Number = len)).valeur.V.String.texte
        completion = set(O, nom_propri√©t√©, it, vrai)
        saufsi completion.est_normal() {
            retourne completion
        }

        // b. Set len to len + 1.
        len += 1.0
    }

    // 6. Perform ? Set(O, "length", ùîΩ(len), true).
    completion = set(O, STR_length, Valeur(Number = len), vrai)
    saufsi completion.est_normal() {
        retourne completion
    }

    // 7. Return ùîΩ(len).
    retourne normal_completion(Valeur(Number = len))
}

/* 23.1.3.36 Array.prototype.toString ( )
 * https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.tostring */
array_prototype_to_string :: fonc (empl params: *Param√®tresObjectCall) -> CompletionRecord
{
    // 1. Let array be ? ToObject(this value).
    completion := vers_objet(interpr√©teuse.donne_realm(), this_value)
    saufsi completion.est_normal() {
        retourne completion
    }
    array := completion.donne_object()

    // 2. Let func be ? Get(array, "join").
    completion = get(array, STR_join)
    saufsi completion.est_normal() {
        retourne completion
    }
    func := completion.valeur.V

    // 3. If IsCallable(func) is false, set func to the intrinsic function %Object.prototype.toString%.
    saufsi is_callable(func) {
        panique("%Object.prototype.toString% non-impl√©ment√©")
    }

    // 4. Return ? Call(func, array).
    retourne call(interpr√©teuse, func, Valeur(Object = array))
}

/** \} */
