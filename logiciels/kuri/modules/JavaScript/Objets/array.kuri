importe Chaine

/* ------------------------------------------------------------------------- */
/** \nom ObjetArray
 * https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-array-exotic-objects
 * \{ */

#port√©e_fichier

table_virtuelle_objet_array := TableVirtuelleObject(classe = ObjetArray, sur_destruction = sur_destruction_objet)

#port√©e_export

ObjetArray :: struct {
    empl objet: Object
    table = *table_virtuelle_objet_array
}

cr√©e_array :: fonc (tas_de_m√©moire: *TasDeM√©moire, array_prototype: *ArrayPrototype, nombre_√©l√©ments: z64) -> *ObjetArray
{
    r√©sultat := tas_de_m√©moire.alloue(ObjetArray)
    r√©sultat.prototype = array_prototype

    r√©sultat.ajoute_propri√©t√©(STR_length, Valeur(Number = nombre_√©l√©ments comme r64), DrapeauxPropri√©t√©.z√©ro)

    retourne r√©sultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ArrayConstructor
 * https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array-constructor
 * \{ */

#port√©e_fichier

table_virtuelle_array_constructor := TableVirtuelleObject(classe = ArrayConstructor, sur_destruction = sur_destruction_objet, sur_call = array_constructor_call)

#port√©e_export

ArrayConstructor :: struct {
    empl objet: Object
    table = *table_virtuelle_array_constructor
}

/* √Ä FAIRE : standardise */
cr√©e_array_constructor :: fonc (tas_de_m√©moire: *TasDeM√©moire, array_prototype: *ArrayPrototype) -> *ArrayConstructor
{
    r√©sultat := tas_de_m√©moire.alloue(ArrayConstructor)
    /* https://tc39.es/ecma262/multipage/indexed-collections.html#sec-properties-of-the-array-constructor */
    r√©sultat.ajoute_propri√©t√©(STR_length, Valeur(Number = 1.0), DrapeauxPropri√©t√©.z√©ro)
    /* https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype */
    r√©sultat.ajoute_propri√©t√©(STR_prototype, Valeur(Object = array_prototype), DrapeauxPropri√©t√©.z√©ro)

    /* https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.constructor */
    array_prototype.ajoute_propri√©t√©(STR_constructor, Valeur(Object = r√©sultat), DrapeauxPropri√©t√©.z√©ro)

    retourne r√©sultat
}

/* √Ä FAIRE : standardise
 * https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array */
array_constructor_call :: fonc (empl params: *Param√®tresObjectCall) -> CompletionRecord
{
    realm := interpr√©teuse.donne_realm()

    r√©sultat := cr√©e_array(realm.donne_tas_de_m√©moire(), realm.intrinsics.array_prototype, 0)

    si arguments.taille != 0 {
        completion := vers_nombre(interpr√©teuse, arguments[0])
        saufsi completion.est_normal() {
            retourne completion
        }
        len := completion.valeur.V.Number

        completion = set(r√©sultat, STR_length, Valeur(Number = len), vrai)
        saufsi completion.est_normal() {
            retourne completion
        }
    }

    retourne normal_completion(Valeur(Object = r√©sultat))
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ArrayPrototype
 * https://tc39.es/ecma262/multipage/indexed-collections.html#sec-properties-of-the-array-prototype-object
 * \{ */

#port√©e_fichier

table_virtuelle_array_prototype := TableVirtuelleObject(classe = ArrayPrototype, sur_destruction = sur_destruction_objet)

#port√©e_export

ArrayPrototype :: struct {
    empl objet: Object
    table = *table_virtuelle_array_prototype
}

cr√©e_array_prototype :: fonc (tas_de_m√©moire: *TasDeM√©moire, prototype: *ObjectPrototype) -> *ArrayPrototype
{
    r√©sultat := tas_de_m√©moire.alloue(ArrayPrototype)
    r√©sultat.prototype = prototype

    r√©sultat.ajoute_propri√©t√©(STR_length, Valeur(Number = 0.0), Writable)
    r√©sultat.ajoute_fonction_native(STR_join, array_prototype_join)
    r√©sultat.ajoute_fonction_native(STR_push, array_prototype_push, 1)
    r√©sultat.ajoute_fonction_native(STR_toString, array_prototype_to_string)

    retourne r√©sultat
}

/* 23.1.3.18 Array.prototype.join ( separator )
 * https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.join */
array_prototype_join :: fonc (empl params: *Param√®tresObjectCall) -> CompletionRecord
{
    // 1. Let O be ? ToObject(this value).
    completion := vers_objet(interpr√©teuse.donne_realm(), this_value)
    saufsi completion.est_normal() {
        retourne completion
    }
    O := completion.valeur.V.donne_objet()

    // 2. Let len be ? LengthOfArrayLike(O).
    completion = length_of_array_like(O)
    saufsi completion.est_normal() {
        retourne completion
    }
    len := completion.valeur.V.Number

    // 3. If separator is undefined, let sep be ",".
    sep: ECMAString
    si arguments.taille == 0 {
        sep = cr√©e_chaine_utf16_unique(",")
    }
    // 4. Else, let sep be ? ToString(separator).
    sinon {
        completion = vers_chaine(interpr√©teuse, arguments[0])
        saufsi completion.est_normal() {
            retourne completion
        }
        sep = completion.valeur.V.String.texte
    }

    // 5. Let R be the empty String.
    R: EnchaineuseUTF16
    initialise_enchaineuse(R)
    diff√®re d√©truit_tampons(R)

    // 6. Let k be 0.
    k := 0.0

    // 7. Repeat, while k < len,
    tantque k < len {
        // a. If k > 0, set R to the string-concatenation of R and sep.
        si k > 0.0 {
            ajoute(R, sep.donne_chaine_utf16())
        }

        // b. Let element be ? Get(O, ! ToString(ùîΩ(k))).
        nom_propri√©t√© := vers_chaine(interpr√©teuse, Valeur(Number = k)).valeur.V.String.texte
        completion = get(O, nom_propri√©t√©)
        saufsi completion.est_normal() {
            retourne completion
        }
        element := completion.valeur.V

        // c. If element is neither undefined nor null, then
        saufsi element.est_nulle() || element.est_undefined() {
            // i. Let S be ? ToString(element).
            completion = vers_chaine(interpr√©teuse, element)
            saufsi completion.est_normal() {
                retourne completion
            }
            S := completion.valeur.V.String.texte

            // ii. Set R to the string-concatenation of R and S.
            ajoute(R, S.donne_chaine_utf16())
        }

        // d. Set k to k + 1.
        k += 1.0
    }

    // 8. Return R.
    r√©sultat := chaine_depuis_enchaineuse(R)
    valeur_r√©sultat := cr√©e_chaine(interpr√©teuse.donne_tas_de_m√©moire(), cr√©e_chaine_utf16_unique(r√©sultat))
    retourne normal_completion(Valeur(String = valeur_r√©sultat))
}

/* 23.1.3.23 Array.prototype.push ( ...items )
 * https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.push */
array_prototype_push :: fonc (empl params: *Param√®tresObjectCall) -> CompletionRecord
{
    // 1. Let O be ? ToObject(this value).
    completion := vers_objet(interpr√©teuse.donne_realm(), this_value)
    saufsi completion.est_normal() {
        retourne completion
    }
    O := completion.valeur.V.donne_objet()

    // 2. Let len be ? LengthOfArrayLike(O).
    completion = length_of_array_like(O)
    saufsi completion.est_normal() {
        retourne completion
    }
    len := completion.valeur.V.Number

    // 3. Let argCount be the number of elements in items.
    // arg_count := arguments.taille

    // √Ä FAIRE : 4. If len + argCount > 2**53 - 1, throw a TypeError exception.

    // 5. For each element E of items, do
    pour arguments {
        // a. Perform ? Set(O, ! ToString(ùîΩ(len)), E, true).
        nom_propri√©t√© := vers_chaine(interpr√©teuse, Valeur(Number = len)).valeur.V.String.texte
        completion = set(O, nom_propri√©t√©, it, vrai)
        saufsi completion.est_normal() {
            retourne completion
        }

        // b. Set len to len + 1.
        len += 1.0
    }

    // 6. Perform ? Set(O, "length", ùîΩ(len), true).
    completion = set(O, STR_length, Valeur(Number = len), vrai)
    saufsi completion.est_normal() {
        retourne completion
    }

    // 7. Return ùîΩ(len).
    retourne normal_completion(Valeur(Number = len))
}

/* 23.1.3.36 Array.prototype.toString ( )
 * https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.tostring */
array_prototype_to_string :: fonc (empl params: *Param√®tresObjectCall) -> CompletionRecord
{
    // 1. Let array be ? ToObject(this value).
    completion := vers_objet(interpr√©teuse.donne_realm(), this_value)
    saufsi completion.est_normal() {
        retourne completion
    }
    array := completion.valeur.V.donne_objet()

    // 2. Let func be ? Get(array, "join").
    completion = get(array, STR_join)
    saufsi completion.est_normal() {
        retourne completion
    }
    func := completion.valeur.V

    // 3. If IsCallable(func) is false, set func to the intrinsic function %Object.prototype.toString%.
    saufsi is_callable(func) {
        panique("%Object.prototype.toString% non-impl√©ment√©")
    }

    // 4. Return ? Call(func, array).
    retourne call(interpr√©teuse, func, Valeur(Object = array))
}

/** \} */
