importe Chaine
importe Fondation

/* ------------------------------------------------------------------------- */
/** \nom Object
 * \{ */

ParamètresObjectCall :: struct {
    object: *Object
    interpréteuse: *Interpréteuse
    this_value: Valeur
    arguments: []Valeur
}

donne_argument :: fonc (params: *ParamètresObjectCall, index: z64) -> Valeur
{
    si index < 0 || index >= params.arguments.taille {
        retourne js_undefined
    }
    retourne params.arguments[index]
}

TypeFonctionObjectCall :: fonc(*ParamètresObjectCall)(CompletionRecord)

ParamètresObjectConstruct :: struct {
    object: *Object
    interpréteuse: *Interpréteuse
    new_target: Valeur
    arguments: []Valeur
}

TypeFonctionObjectConstruct :: fonc(*ParamètresObjectConstruct)(CompletionRecord)

TableVirtuelleObject :: struct {
    empl base_virtuelle_cellule: TableVirtuelleCellule

    sur_destruction = sur_destruction_objet

    sur_get_prototype_of := ordinary_get_prototype_of
    sur_get_own_property := ordinary_get_own_property
    sur_define_own_property := ordinary_define_own_property
    sur_has_property := ordinary_has_property
    sur_get := ordinary_get
    sur_set := ordinary_set
    sur_call: TypeFonctionObjectCall
    sur_construct: TypeFonctionObjectConstruct
}

#portée_fichier

table_virtuelle_objet := TableVirtuelleObject(classe = Object)

#portée_export

DrapeauxPropriété :: énum_drapeau n8 {
    WRITABLE
    ENUMERABLE
    CONFIGURABLE
}

Configurable :: DrapeauxPropriété.CONFIGURABLE
Enumerable :: DrapeauxPropriété.ENUMERABLE
Writable :: DrapeauxPropriété.WRITABLE

Object :: struct {
    empl base: Cellule
    table = *table_virtuelle_objet

    /* https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-property-attributes */
    Propriété :: struct {
        nom: PropertyKey
        valeur: Valeur
        get: *Object
        set: *Object
        drapeaux: DrapeauxPropriété
    }

    /* Ceci stocke les valeurs indexées par des chaines. */
    propriétés: [..]Propriété
    /* Ceci stocke les valeurs indexées par des nombres. */
    éléments_indexés: [..]Propriété

    prototype: *Object
    extensible := vrai
}

garantis_taille_tableau_élément_pour_index :: fonc (object: *Object, index: n32)
{
    si index comme z64 >= object.éléments_indexés.taille {
        ancienne_taille := object.éléments_indexés.taille
        tableau_redimensionne(object.éléments_indexés, index comme z64 + 1)

        pour ancienne_taille ... object.éléments_indexés.taille - 1 {
            init_de(Object.Propriété)(*object.éléments_indexés[it])
            object.éléments_indexés[it].valeur = js_undefined
        }

        si object.donne_classe() == ObjetArray {
            array := object comme *ObjetArray
            array_set_length(array, index + 1)
        }
    }
}

donne_table :: fonc (object: *Object) -> *TableVirtuelleObject
{
    retourne object.table comme *TableVirtuelleObject
}

is_data_propery :: fonc (propriété: &Object.Propriété) -> bool
{
    retourne propriété.get == nul && propriété.set == nul
}

is_accessor_propery :: fonc (propriété: &Object.Propriété) -> bool
{
    retourne !is_data_propery(propriété)
}

crée_objet :: fonc (tas_de_mémoire: *TasDeMémoire, prototype: *Object) -> *Object
{
    résultat := tas_de_mémoire.alloue(Object)
    résultat.prototype = prototype
    retourne résultat
}

sur_destruction_objet :: fonc (base: *Cellule)
{
    objet := base comme *Object
    déloge(objet.propriétés)
    déloge(objet.éléments_indexés)
}

ajoute_propriété :: fonc (objet: *Object, nom: PropertyKey, valeur: Valeur, drapeaux: DrapeauxPropriété)
{
    tableau_ajoute(*objet.propriétés, Object.Propriété(nom, valeur, drapeaux = drapeaux))
}

ajoute_propriété :: fonc (objet: *Object, nom: PropertyKey, get: TypeFonctionObjectCall, set: TypeFonctionObjectCall, drapeaux: DrapeauxPropriété)
{
    getter: *Object
    setter: *Object
    si get {
        getter = crée_fonction_native(objet.donne_tas_de_mémoire(), crée_chaine_utf16_unique_vide(), get, 0)
    }
    si set {
        setter = crée_fonction_native(objet.donne_tas_de_mémoire(), crée_chaine_utf16_unique_vide(), set, 0)
    }
    tableau_ajoute(*objet.propriétés, Object.Propriété(nom, get = getter, set = setter, drapeaux = drapeaux))
}

/* [[GetPrototypeOf]] */
internal_get_prototype_of :: fonc (object: *Object) -> *Object
{
    retourne object.donne_table().sur_get_prototype_of(object)
}

/* [[GetOwnProperty]] */
internal_get_own_property :: fonc (object: *Object, property_key: PropertyKey) -> CompletionRecord
{
    retourne object.donne_table().sur_get_own_property(object, property_key)
}

/* [[DefineOwnProperty]] */
internal_define_own_property :: fonc (object: *Object, property_key: PropertyKey, desc: &PropertyDescriptor) -> CompletionRecord
{
    retourne object.donne_table().sur_define_own_property(object, property_key, desc)
}

internal_define_own_property_by_index :: fonc (object: *Object, index: n32, desc: &PropertyDescriptor) -> CompletionRecord
{
    garantis_taille_tableau_élément_pour_index(object, index)
    object.éléments_indexés[index comme z64].valeur = desc.value
    retourne normal_completion(Valeur(Boolean = vrai))
}

/* [[HasProperty]] */
internal_has_property :: fonc (object: *Object, property_key: PropertyKey) -> CompletionRecord
{
    retourne object.donne_table().sur_has_property(object, property_key)
}

/* [[Get]] */
internal_get :: fonc (object: *Object, property_key: PropertyKey, receiver: Valeur) -> CompletionRecord
{
    retourne object.donne_table().sur_get(object, property_key, receiver)
}

internal_get_by_index :: fonc (object: *Object, index: n32, receiver: Valeur @inutilisée) -> CompletionRecord
{
    si index comme z64 >= object.éléments_indexés.taille {
        retourne normal_completion(js_undefined)
    }

    retourne normal_completion(object.éléments_indexés[index comme z64].valeur)
}

/* [[Set]] */
internal_set :: fonc (object: *Object, property_key: PropertyKey, valeur: Valeur, receiver: Valeur) -> CompletionRecord
{
    retourne object.donne_table().sur_set(object, property_key, valeur, receiver)
}

internal_set_by_index :: fonc (object: *Object, index: n32, valeur: Valeur, receiver: Valeur @inutilisée) -> CompletionRecord
{
    garantis_taille_tableau_élément_pour_index(object, index)
    object.éléments_indexés[index comme z64].valeur = valeur
    retourne normal_completion(Valeur(Boolean = vrai))
}

/* [[Call]] */
internal_call :: fonc (object: *Object, interpréteuse: *Interpréteuse, this_value: Valeur, arguments: []Valeur) -> CompletionRecord
{
    params: ParamètresObjectCall = ---
    params.object = object
    params.arguments = arguments
    params.this_value = this_value
    params.interpréteuse = interpréteuse
    retourne object.donne_table().sur_call(*params)
}

/* [[Construct]] */
internal_construct :: fonc (object: *Object, interpréteuse: *Interpréteuse, arguments: []Valeur, new_target: Valeur) -> CompletionRecord
{
    params: ParamètresObjectConstruct = ---
    params.object = object
    params.arguments = arguments
    params.new_target = new_target
    params.interpréteuse = interpréteuse
    retourne object.donne_table().sur_construct(*params)
}

trouve_propriété :: fonc (objet: *Object, nom: PropertyKey) -> *Object.Propriété
{
    pour * objet.propriétés {
        si it.nom == nom {
            retourne it
        }
    }
    retourne nul
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ObjectPrototype
 * https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-properties-of-the-object-prototype-object
 * \{ */

#portée_fichier

table_virtuelle_object_prototype := TableVirtuelleObject(classe = ObjectPrototype)

#portée_export

ObjectPrototype :: struct {
    empl objet: Object
    table = *table_virtuelle_object_prototype
}

crée_object_prototype :: fonc (tas_de_mémoire: *TasDeMémoire) -> *ObjectPrototype
{
    résultat := tas_de_mémoire.alloue(ObjectPrototype)
    résultat.ajoute_fonction_native(STR_hasOwnProperty, object_prototype_has_own_property)
    résultat.ajoute_fonction_native(STR_toString, object_prototype_to_string)
    résultat.ajoute_propriété(STR___proto__, object_prototype_proto_get, object_prototype_proto_set, Configurable)
    retourne résultat
}

/* 20.1.3.2 Object.prototype.hasOwnProperty ( V )
 * https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.prototype.hasownproperty */ 
object_prototype_has_own_property :: fonc (empl params: *ParamètresObjectCall) -> CompletionRecord
{
    si arguments.taille != 1 {
        retourne normal_completion(js_undefined)
    }

    // 1. Let P be ? ToPropertyKey(V).
    complétion_nom := to_property_key(interpréteuse, arguments[0])
    saufsi complétion_nom.est_normal() {
        retourne complétion_nom
    }
    nom := complétion_nom.valeur.V.String.texte

    // 2. Let O be ? ToObject(this value).
    complétion_obj := to_object(interpréteuse.donne_realm(), this_value)
    saufsi complétion_obj.est_normal() {
        retourne complétion_obj
    }
    obj := complétion_obj.valeur.V.donne_objet()

    // 3. Return ? HasOwnProperty(O, P).
    retourne has_own_property(obj, nom)
}

/* 20.1.3.6 Object.prototype.toString ( )
 * https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.prototype.tostring */
object_prototype_to_string :: fonc (empl params: *ParamètresObjectCall) -> CompletionRecord
{
    // 1. If the this value is undefined, return "[object Undefined]".
    si this_value.est_undefined() {
        retourne crée_string_value_completion(interpréteuse, "[object Undefined]")
    }

    // 2. If the this value is null, return "[object Null]".
    si this_value.est_nulle() {
        retourne crée_string_value_completion(interpréteuse, "[object Null]")
    }

    // 3. Let O be ! ToObject(this value).
    O := to_object(interpréteuse.donne_realm(), this_value).valeur.V.donne_objet()

    // À FAIRE : 4. Let isArray be ? IsArray(O).

    builtin_tag: chaine

    // 5. If isArray is true, let builtinTag be "Array".
    si O.donne_classe() == ObjetArray {
        builtin_tag = "Array"
    }
    // À FAIRE : 6. Else if O has a [[ParameterMap]] internal slot, let builtinTag be "Arguments".
    // 7. Else if O has a [[Call]] internal method, let builtinTag be "Function".
    sinon si O.donne_table().sur_call {
        builtin_tag = "Function"
    }
    // 8. Else if O has an [[ErrorData]] internal slot, let builtinTag be "Error".
    sinon si O.donne_classe() == Error || O.donne_classe() == ReferenceError || O.donne_classe() == TypeError {
        builtin_tag = "Error"
    }
    // À FAIRE : 9. Else if O has a [[BooleanData]] internal slot, let builtinTag be "Boolean".
    // À FAIRE : 10. Else if O has a [[NumberData]] internal slot, let builtinTag be "Number".
    // 11. Else if O has a [[StringData]] internal slot, let builtinTag be "String".
    sinon si O.donne_classe() == ObjetChaine {
        builtin_tag = "String"
    }
    // À FAIRE : 12. Else if O has a [[DateValue]] internal slot, let builtinTag be "Date".
    // À FAIRE : 13. Else if O has a [[RegExpMatcher]] internal slot, let builtinTag be "RegExp".
    // 14. Else, let builtinTag be "Object".
    sinon {
        builtin_tag = "Object"
    }

    // À FAIRE : 15. Let tag be ? Get(O, %Symbol.toStringTag%).
    // 16. If tag is not a String, set tag to builtinTag.
    tag := builtin_tag

    // 17. Return the string-concatenation of "[object ", tag, and "]".
    résultat := enchaine("[object ", tag, "]")
    diffère déloge(résultat)
    retourne crée_string_value_completion(interpréteuse, résultat)
}

/* 20.1.3.8 Object.prototype.__proto__
 * https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.prototype.__proto__ */
object_prototype_proto_get :: fonc (empl params: *ParamètresObjectCall) -> CompletionRecord
{
    // 1. Let O be ? ToObject(this value).
    completion := to_object(interpréteuse.donne_realm(), this_value)
    saufsi completion.est_normal() {
        retourne completion
    }
    O := completion.donne_object()

    // 2. Return ? O.[[GetPrototypeOf]]().
    retourne normal_completion(Valeur(Object = internal_get_prototype_of(O)))
}

object_prototype_proto_set :: fonc (empl params: *ParamètresObjectCall @inutilisée) -> CompletionRecord
{
    // 1. Let O be ? RequireObjectCoercible(this value).
    // 2. If proto is not an Object and proto is not null, return undefined.
    // 3. If O is not an Object, return undefined.
    // 4. Let status be ? O.[[SetPrototypeOf]](proto).
    // 5. If status is false, throw a TypeError exception.
    // 6. Return undefined.
    panique("set __proto__ non-implémenté")
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom ObjectConstructor
 * https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object-constructor
 * \{ */

#portée_fichier

table_virtuelle_object_constructor := TableVirtuelleObject(
    classe = ObjectConstructor
)

#portée_export

ObjectConstructor :: struct {
    empl builtin_function: BuiltInFunction
    table = *table_virtuelle_object_constructor
}

crée_object_constructor :: fonc (realm: *Realm, function_prototype: *FunctionPrototype, object_prototype: *ObjectPrototype) -> *ObjectConstructor
{
    tas_de_mémoire := realm.donne_tas_de_mémoire()
    résultat := tas_de_mémoire.alloue(ObjectConstructor)
    create_builtin_function(résultat, 1, STR_Object, realm, function_prototype)

    résultat.ajoute_propriété(STR_prototype, Valeur(Object = object_prototype), DrapeauxPropriété.zéro)

    résultat.ajoute_fonction_native(STR_getPrototypeOf, object_get_prototype_of, 1)

    object_prototype.ajoute_propriété(STR_constructor, Valeur(Object = résultat), DrapeauxPropriété.zéro)

    retourne résultat
}

#portée_fichier

/* 20.1.2.12 Object.getPrototypeOf ( O )
 * https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.getprototypeof */
object_get_prototype_of :: fonc (empl params: *ParamètresObjectCall) -> CompletionRecord
{
    // À FAIRE : remplis les paramètres manquants avec undefined
    O := Valeur(js_undefined)
    si arguments.taille > 0 {
        O = arguments[0]
    }

    // 1. Let obj be ? ToObject(O).
    completion := to_object(interpréteuse.donne_realm(), O)
    saufsi completion.est_normal() {
        retourne completion
    }
    obj := completion.donne_object()

    // 2. Return ? obj.[[GetPrototypeOf]]().
    retourne normal_completion(Valeur(Object = internal_get_prototype_of(obj)))
}

/** \} */
