importe Math

Couleur :: struct {
    r := 0.0
    v := 0.0
    b := 0.0
    a := 0.0
}

// Utiliser Couleur est difficile avec la génération de code
// dans les métaprogrammes à cause du nom du module (nous générons
// "Couleur" au lieu de "Couleur.Couleur").
CouleurRVBA :: struct {
    r := 0.0
    v := 0.0
    b := 0.0
    a := 0.0
}

// -------------------------------------------------------------------------

Spectre :: struct {
    x: r32
    y: r32
    z: r32
}

opérateur + :: fonc (s1: Spectre, s2: Spectre) -> Spectre
{
    retourne Spectre(s1.x + s2.x, s1.y + s2.y, s1.z + s2.z)
}

opérateur * :: fonc (s1: Spectre, s2: Spectre) -> Spectre
{
    retourne Spectre(s1.x * s2.x, s1.y * s2.y, s1.z * s2.z)
}

opérateur * :: fonc (s1: r32, s2: Spectre) -> Spectre
{
    retourne Spectre(s1 * s2.x, s1 * s2.y, s1 * s2.z)
}

/* Conversion d'espaces colorimétriques. */

linéaire_vers_srgb :: fonc (spectre: Spectre) -> Spectre
{
    résultat : Spectre = ---

    résultat.x = linéaire_vers_srgb(spectre.x) comme r32 / 255.0
    résultat.y = linéaire_vers_srgb(spectre.y) comme r32 / 255.0
    résultat.z = linéaire_vers_srgb(spectre.z) comme r32 / 255.0

    retourne résultat
}

linéaire_vers_srgb :: fonc (value: r32) -> z32
{
	v := max(0.0, min(1.0, value))

    si v <= 0.0031308 {
        retourne (v * 12.92 * 255.0 + 0.5) comme z32
    }

    retourne ((1.055 * puissance(v, 1.0 / 2.4) - 0.055) * 255.0 + 0.5) comme z32
}
