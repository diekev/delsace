/* Module de définitions de types pour représenter, et de travail sur, des courbes de Bézier. */

importe Couleur
importe CurveFit
importe Fondation
importe Math
importe PeintureInterface
importe POSIX

/* ------------------------------------------------------------------------- */
/** \nom Échantillonnage de courbe de Bézier.
 * \{ */

échantillonne_courbe_bézier :: fonc (p0: Point2D(r32), p1: Point2D(r32), p2: Point2D(r32), p3: Point2D(r32), échantillons: []Point2D(r32))
{
    si échantillons.taille == 0 {
        retourne
    }

    début := échantillons.pointeur comme *r32

    échantillonne_courbe_bézier(p0.x, p1.x, p2.x, p3.x, début, échantillons.taille comme z32, taille_de(Point2D(r32)) comme z32)
    échantillonne_courbe_bézier(p0.y, p1.y, p2.y, p3.y, début + 1, échantillons.taille comme z32, taille_de(Point2D(r32)) comme z32)
}

échantillonne_courbe_bézier :: fonc (point_a: r32, point_b: r32, point_c: r32, point_d: r32, décalage: r32) -> r32
{
    u := 1.0 - t
    u² := u * u
    u³ := u² * u

    t² := t * t
    t³ := d² * t

    a := u³ * point_a
    b := 3.0 * u² * t * point_b
    c := 3.0 * u * u² * point_c
    d := t³ * point_d
    retourne a + b + c + d
}

décale_pointeur :: fonc (ptr: *rien, stride: z32) -> *rien #enligne
{
    a := ptr comme *octet
    a += stride
    retourne a
}

/* Code adapté de Blender.
 * SPDX-License-Identifier: GPL-2.0-or-later */
échantillonne_courbe_bézier :: fonc (q0: r32, q1: r32, q2: r32, q3: r32, p: *r32, i: z32, stride: z32)
{
    f := i comme r32
    rt0 := q0
    rt1 := 3.0 * (q1 - q0) / f
    f *= f
    rt2 := 3.0 * (q0 - 2.0 * q1 + q2) / f
    f *= i comme r32
    rt3 := (q3 - q0 + 3.0 * (q1 - q2)) / f

    q0 = rt0
    q1 = rt1 + rt2 + rt3
    q2 = 2.0 * rt2 + 6.0 * rt3
    q3 = 6.0 * rt3

    pour i + 1 {
        mémoire(p) = q0
        p = décale_pointeur(p, stride) comme *r32
        q0 += q1
        q1 += q2
        q2 += q3
    }
}

calcule_point_sur_courbe :: fonc (point_a: Vec2, point_b: Vec2, décalage: r32, point_c: Vec2, point_d: Vec2) -> Vec2
{
    complément_décalage := 1.0 - décalage
    cd² := complément_décalage * complément_décalage
    cd³ := cd² * complément_décalage

    d² := décalage * décalage
    d³ := d² * décalage

    a := cd³ * point_a
    b := 3.0 * cd² * décalage * point_b
    c := 3.0 * complément_décalage * d² * point_c
    d := d³ * point_d
    retourne a + b + c + d
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Un Chemin sers à représenter un ensemble de courbes de Bézier, par
 * exemple, des courbes provenant d'un fichier SVG.
 * Un chemin est composé de sous-chemins : ceci permet de représenter des formes
 * complexes.
 * Les sous-chemins peuvent être fermés ou non;
 * \{ */

Chemin :: struct {
    sous_chemins: [..]SousChemin
}

détruit_données :: fonc (chemin: *Chemin)
{
    pour chemin.sous_chemins {
        déloge(it.noeuds)
    }
    déloge(chemin.sous_chemins)
}

SousChemin :: struct {
    Noeud :: struct {
        Drapeaux :: énum_drapeau {
            ANCRE_VISIBLE
            ANCRE_SÉCELCTIONNÉE
            CONTROLE_AVANT_VISIBLE
            CONTROLE_ARRIÈRE_VISIBLE
            CONTROLES_LIÉS
            AUTOMATIQUE

            DRAPEAUX_DÉFAUT :: ANCRE_VISIBLE
            SÉLECTION_CONTOLES :: CONTROLE_AVANT_VISIBLE | CONTROLE_ARRIÈRE_VISIBLE
            SÉLECTION :: ANCRE_SÉCELCTIONNÉE | SÉLECTION_CONTOLES
        }

        controle_arrière: Point2D(r32)
        ancre: Point2D(r32)
        controle_avant: Point2D(r32)

        drapeaux := Drapeaux.DRAPEAUX_DÉFAUT
    }

    noeuds: [..]Noeud
    est_fermé: bool
}

échantillonne_courbe_bézier :: fonc (noeud1: SousChemin.Noeud, noeud2: SousChemin.Noeud, échantillons: []Point2D(r32))
{
    échantillonne_courbe_bézier(noeud1.ancre, noeud1.controle_avant, noeud2.controle_arrière, noeud2.ancre, échantillons)
}

/* Traite les ancres des noeuds du sous-chemin comme un polygone et interpole les positions des controles
 * de telle sorte que nous obtenions une courbe lisse passant par tout les points.
 * La méthode est tirée de : https://agg.sourceforge.net/antigrain.com/research/bezier_interpolation/index.html#PAGE_BEZIER_INTERPOLATION */
interpole_courbe_depuis_polygone :: fonc (sous_chemin: SousChemin)
{
    si sous_chemin.noeuds.taille < 3 {
        retourne
    }

    nombre_de_noeuds := sous_chemin.noeuds.taille - 2
    si sous_chemin.est_fermé {
        nombre_de_noeuds = sous_chemin.noeuds.taille
    }

    pour indice_noeud dans nombre_de_noeuds {
        noeud0 := *sous_chemin.noeuds[(indice_noeud + 0) % sous_chemin.noeuds.taille]
        noeud1 := *sous_chemin.noeuds[(indice_noeud + 1) % sous_chemin.noeuds.taille]
        noeud2 := *sous_chemin.noeuds[(indice_noeud + 2) % sous_chemin.noeuds.taille]

        avant, arrière := interpole_position_controles_polygone(noeud0.ancre, noeud1.ancre, noeud2.ancre)

        noeud1.controle_avant = avant
        noeud1.controle_arrière = arrière
    }
}

interpole_position_controles_polygone :: fonc (p0: Point2D(r32), p1: Point2D(r32), p2: Point2D(r32)) -> (avant: Point2D(r32), arrière: Point2D(r32))
{
    x0 := p0.x comme r64
    y0 := p0.y comme r64
    x1 := p1.x comme r64
    y1 := p1.y comme r64
    x2 := p2.x comme r64
    y2 := p2.y comme r64

    centre0_x := (x0 + x1) * 0.5
    centre0_y := (y0 + y1) * 0.5

    centre1_x := (x1 + x2) * 0.5
    centre1_y := (y1 + y2) * 0.5

    len01 := racine_carrée(donne_distance_carrée(p0, p1))
    len12 := racine_carrée(donne_distance_carrée(p1, p2))

    len := len01 / (len01 + len12)

    centre2_x := centre0_x + (centre1_x - centre0_x) * len
    centre2_y := centre0_y + (centre1_y - centre0_y) * len

    dx := x1 - centre2_x
    dy := y1 - centre2_y

    arrière.x = (centre0_x + dx) comme r32
    arrière.y = (centre0_y + dy) comme r32

    avant.x = (centre1_x + dx) comme r32
    avant.y = (centre1_y + dy) comme r32

    retourne avant, arrière
}

/* Ceci recrée le sous-chemin à partir des points données.
 * Nous considérons que le chemin est en pixels, donc la valeur défaut de seuil_erreur_max est en pixels. */
adpate_sous_chemin_aux_points :: fonc (sous_chemin: *SousChemin, points: []Point2D(r32), seuil_erreur_max := 5.0) -> bool
{
    si points.taille == 0 {
        sous_chemin.noeuds.taille = 0
        retourne vrai
    }

    points_résultants: *r32
    nombre_points_résultants: n32

    points_entrée: *r32 = points.pointeur comme *r32
    résultat := curve_fit_cubic_to_points_fl(points_entrée, points.taille comme n32, 2,
                                             seuil_erreur_max,
                                             Curve_Fit_Calc.HIGH_QUALIY,
                                             nul, 0,
                                             *points_résultants, *nombre_points_résultants, 
                                             nul, nul, nul)

    si résultat != 0 {
        retourne faux
    }

    points_calculés := points_résultants comme *Point2D(r32)

    sous_chemin.noeuds.taille = 0

    pour nombre_points_résultants {
        noeud := tableau_ajoute_élément(*sous_chemin.noeuds)
        noeud.controle_arrière = mémoire(points_calculés)
        points_calculés += 1
        noeud.ancre = mémoire(points_calculés)
        points_calculés += 1
        noeud.controle_avant = mémoire(points_calculés)
        points_calculés += 1
    }

    free(points_résultants)

    retourne vrai
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom CréatriceChemin
 * \{ */

CréatriceChemin :: struct {
    noeuds: [..]SousChemin.Noeud
    chemin: Chemin
    dernier_point: Point2D(r32)
    sous_chemin_est_fermé: bool
}

détruit_données :: fonc (créatrice: *CréatriceChemin)
{
    déloge(créatrice.noeuds)
    détruit_données(*créatrice.chemin)
    init_de(CréatriceChemin)(créatrice)
}

/* Termine le sous-chemin courant et retourne-le. La créatrice est réinitialisée et ne possède alors plus le chemin. */
donne_chemin :: fonc (créatrice: *CréatriceChemin) -> Chemin
{
    termine_sous_chemin_courant(créatrice)
    déloge(créatrice.noeuds)
    résultat := créatrice.chemin
    init_de(Chemin)(*créatrice.chemin)
    retourne résultat
}

va_vers :: fonc (créatrice: *CréatriceChemin, point: Point2D(r32))
{
    termine_sous_chemin_courant(créatrice)

    noeud := tableau_ajoute_élément(*créatrice.noeuds)
    noeud.ancre = point
    noeud.controle_arrière = point
    noeud.controle_avant = point

    créatrice.dernier_point = point
}

ligne_vers :: fonc (créatrice: *CréatriceChemin, point: Point2D(r32))
{
    cubique_vers(créatrice, créatrice.dernier_point, point, point, faux)
}

conique_vers :: fonc (créatrice: *CréatriceChemin, controle: Point2D(r32), point: Point2D(r32), controles_liés: bool)
{
    cubique_vers(créatrice, controle, controle, point, controles_liés)
}

cubique_vers :: fonc (créatrice: *CréatriceChemin, controle1: Point2D(r32), controle2: Point2D(r32), point: Point2D(r32), controles_liés: bool)
{
    assert(créatrice.noeuds.taille != 0)

    dernier_noeud := dernier_élément(créatrice.noeuds)
    dernier_noeud.controle_avant = controle1
    
    noeud := tableau_ajoute_élément(*créatrice.noeuds)
    noeud.controle_arrière = controle2
    noeud.ancre = point
    noeud.controle_avant.x = noeud.ancre.x + (noeud.ancre.x - noeud.controle_arrière.x)
    noeud.controle_avant.y = noeud.ancre.y + (noeud.ancre.y - noeud.controle_arrière.y)

    noeud.drapeaux.CONTROLES_LIÉS = controles_liés

    créatrice.dernier_point = point
}

ferme_chemin_si_chemin_en_cours :: fonc (créatrice: *CréatriceChemin)
{
    si créatrice.noeuds {
        ferme_chemin(créatrice)
    }
}

ferme_chemin :: fonc (créatrice: *CréatriceChemin)
{
    assert(créatrice.noeuds.taille != 0)

    créatrice.sous_chemin_est_fermé = vrai

    si créatrice.noeuds.taille > 1 {
        premier_noeud := *créatrice.noeuds[0]
        dernier_noeud := dernier_élément(créatrice.noeuds)

        si premier_noeud.ancre == dernier_noeud.ancre {
            // Combinons les deux derniers neouds si le dernier mouvement ferma le chemin.
            créatrice.noeuds.taille -= 1

            premier_noeud.controle_arrière = dernier_noeud.controle_arrière
            premier_noeud.drapeaux.CONTROLES_LIÉS = dernier_noeud.drapeaux.CONTROLES_LIÉS == vrai
        }
        sinon {
            // Crée une ligne_vers du dernier_noeud vers le premier si le dernier
            // mouvement ne ferma pas le chemin.
            // Ceci implique que le premier controle du dernier noeud doit être le
            // même que son ancre.
            dernier_noeud.controle_avant = dernier_noeud.ancre
        }
    }
}

termine_sous_chemin_courant :: fonc (créatrice: *CréatriceChemin)
{
    si créatrice.noeuds {
        sous_chemin := tableau_ajoute_élément(*créatrice.chemin.sous_chemins)
        sous_chemin.noeuds = tableau_copie(créatrice.noeuds)
        sous_chemin.est_fermé = créatrice.sous_chemin_est_fermé
        créatrice.sous_chemin_est_fermé = faux
        créatrice.noeuds.taille = 0
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom InfoToucheTracé
 * Structure représentant ce qui se trouve à proximité d'un point.
 * \{ */

NatureToucheTracé :: énum {
    CONTROLE_ARRIÈRE :: 0
    ANCRE :: 1
    CONTROLE_AVANT :: 2

    RIEN :: -1
    SEGMENT :: -2
    INTÉRIEUR :: -3
}

IndiceSousChemin :: struct {
    sous_chemin: z64
    noeud: z64
}

InfoToucheTracé :: struct {
    tracé: *Chemin
    indice_sous_chemin: IndiceSousChemin
    quoi: NatureToucheTracé
    où: Point2D(r32)
}

donne_touche_tracé :: fonc (tracé: *Chemin, x: r32, y: r32) -> InfoToucheTracé
{
    résultat: InfoToucheTracé
    résultat.tracé = tracé
    résultat.quoi = NatureToucheTracé.RIEN

    distance_min := infinité_positive(r32)

    point := Point2D(r32)(x, y)

    // À FAIRE : touche sur un segment
    pour tracé.sous_chemins {
        pour noeud, indice_noeud dans it.noeuds {
            distance_test := donne_distance_carrée(point, noeud.ancre)
            si distance_test < distance_min && distance_test < (RAYON_NOEUD * RAYON_NOEUD) {
                distance_min = distance_test

                résultat.indice_sous_chemin.sous_chemin = indice_it
                résultat.indice_sous_chemin.noeud = indice_noeud
                résultat.où = point
                résultat.quoi = NatureToucheTracé.ANCRE
            }

            distance_test = donne_distance_carrée(point, noeud.controle_avant)
            si distance_test < distance_min && distance_test < (RAYON_NOEUD * RAYON_NOEUD) {
                distance_min = distance_test

                résultat.indice_sous_chemin.sous_chemin = indice_it
                résultat.indice_sous_chemin.noeud = indice_noeud
                résultat.où = point
                résultat.quoi = NatureToucheTracé.CONTROLE_AVANT
            }

            distance_test = donne_distance_carrée(point, noeud.controle_arrière)
            si distance_test < distance_min && distance_test < (RAYON_NOEUD * RAYON_NOEUD) {
                distance_min = distance_test

                résultat.indice_sous_chemin.sous_chemin = indice_it
                résultat.indice_sous_chemin.noeud = indice_noeud
                résultat.où = point
                résultat.quoi = NatureToucheTracé.CONTROLE_ARRIÈRE
            }
        }
    }

    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Dessin d'un chemin avec le Peintre de PeintureInterface
 * \{ */

RAYON_NOEUD :: 5.0

dessine_chemin :: fonc (peintre: *Peintre, chemin: Chemin, couleur := CouleurRVBA(1.0, 1.0, 1.0, 1.0))
{
    échantillons: [32]Point2D(r32)

    pour chemin.sous_chemins {
        pour noeud, indice_noeud dans it.noeuds {
            ligne: Ligne(r32)
            {
                ligne = Ligne(r32)(noeud.controle_arrière, noeud.ancre)
                peintre.dessine_segment(ligne, couleur)

                ligne = Ligne(r32)(noeud.ancre, noeud.controle_avant)
                peintre.dessine_segment(ligne, couleur)

                rect: RectanglePosDim(r32)
                rect.x = noeud.ancre.x - RAYON_NOEUD
                rect.y = noeud.ancre.y - RAYON_NOEUD
                rect.largeur = 2.0 * RAYON_NOEUD
                rect.hauteur = 2.0 * RAYON_NOEUD
                peintre.remplis_rectangle(rect, couleur)

                cercle: Cercle(r32)
                cercle.centre_x = noeud.controle_arrière.x
                cercle.centre_y = noeud.controle_arrière.y
                cercle.rayon = RAYON_NOEUD
                peintre.dessine_cercle(cercle, couleur)

                cercle.centre_x = noeud.controle_avant.x
                cercle.centre_y = noeud.controle_avant.y
                cercle.rayon = RAYON_NOEUD
                peintre.dessine_cercle(cercle, couleur)
            }

            noeud_suivant: SousChemin.Noeud

            si indice_noeud < it.noeuds.taille - 1 {
                noeud_suivant = it.noeuds[indice_noeud + 1]
            }
            sinon si it.est_fermé {
                noeud_suivant = it.noeuds[0]
            }
            sinon {
                continue
            }

            p0 := noeud.ancre
            p1 := noeud_suivant.ancre
            
            échantillonne_courbe_bézier(noeud, noeud_suivant, échantillons)

            ligne = Ligne(r32)(p0, échantillons[0])
            peintre.dessine_segment(ligne, couleur)

            pour i dans échantillons.taille - 1 {
                ligne = Ligne(r32)(échantillons[i], échantillons[i + 1])
                peintre.dessine_segment(ligne, couleur)
            }

            ligne = Ligne(r32)(échantillons[échantillons.taille - 1], p1)
            peintre.dessine_segment(ligne, couleur)
        }
    }
}

/** \} */
