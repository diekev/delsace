/* Module pour dessiner et gérer des interfaces graphiques.
 *
 * Comportement pour les évènements.
 *
 * Panneau.sur_clique_souris doit retourner vrai si le panneau a gérer le
 * clique. Les évènements de mouvement et de clique souris suivant seront
 * envoyés à ce panneau jusqu'au prochain évènement de clique ayant comme
 * action ActionSouris.RELACHÉE
 *
 * Panneau.sur_début_survol est émis quand la souris entre dans le rect du
 * panneau.
 *
 * Panneau.sur_fin_survol est émis quand la souris sors du rect du panneau.
 * Additionnellement, précédemment à l'émission de cet évènement,
 * Panneau.sur_déplacement_souris est émis.
 */

importe Couleur
importe Fondation
importe Géométrie
importe Périphériques
importe PeintureInterface
importe Typographie

charge "menu"

/* ------------------------------------------------------------------------- */
/** \nom Contexte pour le dessin.
 * \{ */

ContexteAffichage :: struct {
    peintre: *Peintre
    fonte: *Fonte
    thème: *Thème
}

/** } */

/* ------------------------------------------------------------------------- */
/** \nom ContexteInterface.
 * \{ */

/* Le ContexteInterface doit être instancié par fenêtre.
 * Il permet de créer les panneaux pour chaque fenêtre.
 * Il stocke l'état de l'interface : les éléments actifs/focalisés.
 * Chaque panneau possède une référence à ce contexte.
 *
 * rappel_définis_curseur_souris peut être mise en place par les applications
 * cliente afin que les panneaux puissent définir un curseur (par exemple
 * lorsque survolé). Il est suggéré d'utiliser son propre type de contexte par
 * composition avec celui-ci afin de pouvoir savoir pour quel contexte le
 * curseur doit être définis.
 */
ContexteInterface :: struct {
    /* Le menu étant affiché. */
    menus_affichés: [..]*PanneauMenu
    fonte: *Fonte

    diviseurs: [..]*PanneauDiviseur

    panneau_racine: *Panneau

    panneau_cliqué: *Panneau
    panneau_survolé: *Panneau

    rappel_définis_curseur_souris: fonc(*ContexteInterface, TypeCurseurSystème)(rien)
}

initialise_le_contexte_interface :: fonc (contexte: *ContexteInterface, fonte: *Fonte)
{
    contexte.fonte = fonte
}

crée_panneau :: fonc (contexte: *ContexteInterface, $TypePanneau: type_de_données) -> *TypePanneau
{
    résultat := loge(TypePanneau)
    résultat.contexte = contexte
    résultat.sur_redimension = sur_redimension_impl_défaut
    résultat.sur_destruction = sur_destruction_générique(TypePanneau)
    résultat.identifiant = info_de(TypePanneau).nom
    retourne résultat
}

affiche_panneau_menu :: fonc (contexte: *ContexteInterface, panneau: *PanneauMenu)
{
    tableau_ajoute(*contexte.menus_affichés, panneau)
}

dépile_panneau_menu :: fonc (empl contexte: *ContexteInterface)
{
    panneau_menu := contexte.menus_affichés[contexte.menus_affichés.taille - 1]
    détruit_panneau_menu(contexte, panneau_menu)
    contexte.menus_affichés.taille -= 1
}

détruit_panneau_menu :: fonc (empl contexte: *ContexteInterface)
{
    saufsi menus_affichés {
        retourne
    }

    pour menus_affichés {
        détruit_panneau_menu(contexte, it)
    }

    déloge(menus_affichés)
}

détruit_panneau_menu :: fonc (empl contexte: *ContexteInterface, panneau_menu: *PanneauMenu)
{
    si panneau_menu == panneau_survolé {
        panneau_survolé = nul
    }

    si panneau_menu == panneau_cliqué {
        panneau_cliqué = nul
    }

    détruit_panneau_menu(panneau_menu)
}

gère_clique_souris :: fonc (empl contexte: *ContexteInterface, clique: CliqueSouris)
{
    diffère {
        si clique.action == ActionSouris.RELACHÉE {
            panneau_cliqué = nul
        }
    }

    si gère_clique_souris(panneau_cliqué, clique) {
        // imprime("Clique géré par %\n", panneau_cliqué.identifiant)
        retourne
    }

    saufsi panneau_survolé {
        nouveau_panneau_survolé := trouve_panneau_survolé(contexte, clique.état)
        si nouveau_panneau_survolé != panneau_survolé {
            fini_survol_panneau(panneau_survolé, clique.état)
            débute_survol_panneau(nouveau_panneau_survolé)
        }
        nouveau_panneau_survolé = panneau_survolé
    }

    si panneau_survolé && gère_clique_souris(panneau_survolé, clique) {
        panneau_cliqué = panneau_survolé
    }

    /* À FAIRE : bouge ça d'ici. */
    pour menus_affichés {
        si it == panneau_cliqué {
            arrête
        }
    }
    sansarrêt {
        si clique.action != ActionSouris.PRESSÉE && menus_affichés.taille != 0 {
            si menus_affichés[0].panneau_barre_de_menu {
                menus_affichés[0].panneau_barre_de_menu.définis_élément_pressé(-1, vrai)
            }
            sinon {
                contexte.détruit_panneau_menu()
            }
        }
    }
    // si menu_affiché && panneau_cliqué != menu_affiché {
    //     si clique.action != ActionSouris.PRESSÉE {
    //         menu_affiché.panneau_barre_de_menu.définis_élément_pressé(-1, vrai)
    //     }
    // }

    // si panneau_cliqué {
    //     imprime("Clique sur panneau '%'\n", panneau_cliqué.identifiant)
    // }
    // sinon {
    //     imprime("Cliqué sur aucun panneau\n")
    // }
}

sur_déplacement_souris :: fonc (empl contexte: *ContexteInterface, état: ÉtatSouris)
{
    si panneau_cliqué {
        si panneau_cliqué.sur_déplacement_souris {
            panneau_cliqué.sur_déplacement_souris(panneau_cliqué, état)
        }

        retourne
    }

    nouveau_panneau_survolé := trouve_panneau_survolé(contexte, état)
    si nouveau_panneau_survolé != panneau_survolé {
        fini_survol_panneau(panneau_survolé, état)
        débute_survol_panneau(nouveau_panneau_survolé)
    }

    panneau_survolé = nouveau_panneau_survolé

    saufsi panneau_survolé {
        // imprime("Aucun panneau survolé\n")
        retourne
    }

    // imprime("Survole panneau : %\n", panneau_survolé.identifiant)
    si panneau_survolé.sur_déplacement_souris {
        panneau_survolé.sur_déplacement_souris(panneau_survolé, état)
    }
}

trouve_panneau_survolé :: fonc (empl contexte: *ContexteInterface, état: ÉtatSouris) -> *Panneau
{
    pour menus_affichés {
        si it.rect.contient(état.où) {
            retourne it
        }
    }

    pour diviseurs {
        si it.rect.contient(état.où) {
            retourne it
        }
    }

    retourne trouve_panneau_survolé_récursif(panneau_racine, état)
}

trouve_panneau_survolé_récursif :: fonc (panneau_racine: *Panneau, état: ÉtatSouris) -> *Panneau
{
    saufsi panneau_racine {
        retourne nul
    }

    pour panneau_racine.enfants {
        panneau_candidat := trouve_panneau_survolé_récursif(it, état)
        si panneau_candidat {
            retourne panneau_candidat
        }
    }

    si panneau_racine.rect.contient(état.où) {
        retourne panneau_racine
    }

    retourne nul
}

dessine_panneaux :: fonc (empl contexte: *ContexteInterface, contexte_affichage: *ContexteAffichage)
{
    saufsi panneau_racine {
        retourne
    }

    sur_dessin_récursif(panneau_racine, contexte_affichage)

    /* Dessine le menu au dessus du reste. */
    pour menus_affichés {
        sur_dessin_récursif(it, contexte_affichage)
    }
}

définis_curseur_souris :: fonc (empl contexte: *ContexteInterface, type_curseur: TypeCurseurSystème)
{
    saufsi rappel_définis_curseur_souris {
        retourne
    }

    rappel_définis_curseur_souris(contexte, type_curseur)
}

/** } */

/* ------------------------------------------------------------------------- */
/** \nom Panneau
 * Structure pour représenter un élément de l'interface graphique.
 * \{ */

Panneau :: struct {
    contexte: *ContexteInterface
    parent: *Panneau
    enfants: [..]*Panneau

    identifiant: chaine

    /* Dimension du panneau. */
    rect: RectanglePosDim(z32)

    besoin_ajournement_disposition := vrai

    /* Fonctions de rappels à implémenter pour chaque type dérivé. */
    sur_destruction: fonc(*Panneau)(rien)
    sur_déplacement_souris: fonc(*Panneau, ÉtatSouris)(rien)
    sur_clique_souris: fonc(*Panneau, CliqueSouris)(bool)
    sur_dessin: fonc(*Panneau, *ContexteAffichage)(rien)
    sur_redimension: fonc(*Panneau, RectanglePosDim(z32))(rien)
    sur_début_survol: fonc(*Panneau)(rien)
    sur_fin_survol: fonc(*Panneau)(rien)
}

ajoute_enfant :: fonc (panneau: *Panneau, enfant: *Panneau)
{
    assert(enfant.parent == nul)
    enfant.parent = panneau
    tableau_ajoute(*panneau.enfants, enfant)
}

/* Implémentation par défaut du rappel sur_redimension */
sur_redimension_impl_défaut :: fonc (panneau: *Panneau, rect_disponible: RectanglePosDim(z32))
{
    panneau.rect = rect_disponible
    panneau.besoin_ajournement_disposition = vrai
}

détruit_panneau :: fonc (panneau: *Panneau)
{
    déloge_tableau_et_ses_éléments(panneau.enfants, détruit_panneau)

    si panneau.sur_destruction {
        panneau.sur_destruction(panneau)
    }
}

/** } */

/* ------------------------------------------------------------------------- */
/** \nom Enveloppes pour les rappels de Panneau.
 * \{ */

sur_dessin_récursif :: fonc (panneau: *Panneau, ctx: *ContexteAffichage)
{
    si panneau.sur_dessin {
        peintre := ctx.peintre
        peintre.définis_ciseau(panneau.rect)
        panneau.sur_dessin(panneau, ctx)
        peintre.restaure_ciseau()
    }

    pour panneau.enfants {
        sur_dessin_récursif(it, ctx)
    }
}

gère_clique_souris :: fonc (panneau: *Panneau, clique: CliqueSouris) -> bool
{
    /* Permet de passer nul. */
    saufsi panneau {
        retourne faux
    }

    saufsi panneau.sur_clique_souris {
        retourne faux
    }

    retourne panneau.sur_clique_souris(panneau, clique)
}

redimensionne_panneau :: fonc (panneau: *Panneau, rect: RectanglePosDim(z32))
{
    panneau.sur_redimension(panneau, rect)
}

sur_déplacement_souris_récursif :: fonc (panneau: *Panneau, état: ÉtatSouris)
{
    saufsi panneau {
        retourne
    }

    si panneau.sur_déplacement_souris {
        panneau.sur_déplacement_souris(panneau, état)
    }

    pour panneau.enfants {
        sur_déplacement_souris_récursif(it, état)
    }
}

débute_survol_panneau :: fonc (panneau: *Panneau)
{
    /* Permet de passer nul. */
    saufsi panneau && panneau.sur_début_survol {
        retourne
    }

    panneau.sur_début_survol(panneau)
}

fini_survol_panneau :: fonc (panneau: *Panneau, état: ÉtatSouris)
{
    /* Permet de passer nul. */
    saufsi panneau {
        retourne
    }

    /* Émets un évènement de déplacement de souris pour permettre au panneau de
     * réinitialiser son état. */
    si panneau.sur_déplacement_souris {
        panneau.sur_déplacement_souris(panneau, état)
    }

    si panneau.sur_fin_survol {
        panneau.sur_fin_survol(panneau)
    }
}

/** } */

/* ------------------------------------------------------------------------- */
/** \nom Panneau Interface
 * Structure pour le panneau principal de l'interface.
 * \{ */

PanneauInterface :: struct {
    empl base: Panneau

    barre_de_menu: *PanneauBarreDeMenu
    élément_central: *Panneau
}

crée_panneau_interface :: fonc (ctx: *ContexteInterface, rect: RectanglePosDim(z32), élément_central: *Panneau) -> *PanneauInterface
{
    sur_déplacement_souris :: fonc (panneau_interface: *PanneauInterface, souris: ÉtatSouris)
    {
        observe_souris(panneau_interface, souris)
    }

    sur_clique_souris :: fonc (panneau_interface: *PanneauInterface, clique: CliqueSouris) -> bool
    {
        retourne reçoie_clique_souris(panneau_interface, clique)
    }

    sur_dessin :: fonc (panneau_interface: *PanneauInterface, contexte_affichage: *ContexteAffichage)
    {
        dessine_panneau_interface(panneau_interface, contexte_affichage)
    }

    sur_redimension :: fonc (panneau: *Panneau, rect: RectanglePosDim(z32))
    {
        panneau_interface := panneau comme *PanneauInterface
        panneau_interface.rect = rect
        calcule_rect_interne(panneau_interface)
    }

    résultat := ctx.crée_panneau(PanneauInterface)
    résultat.élément_central = élément_central
    ajoute_enfant(résultat, élément_central)

    /* Rappels. */
    résultat.sur_clique_souris = enveloppe_rappel(sur_clique_souris)
    résultat.sur_déplacement_souris = enveloppe_rappel(sur_déplacement_souris)
    résultat.sur_dessin = enveloppe_rappel(sur_dessin)
    résultat.sur_redimension = sur_redimension

    résultat.redimensionne_panneau(rect)

    retourne résultat
}

installe_barre_de_menu :: fonc (panneau: *PanneauInterface, barre_de_menu: *BarreDeMenu)
{
    assert(panneau.barre_de_menu == nul)
    panneau.barre_de_menu = crée_panneau_barre_de_menu(panneau.contexte, barre_de_menu)
    // ajoute_enfant(panneau, panneau.barre_de_menu)
    panneau.barre_de_menu.parent = panneau
    calcule_rect_interne(panneau)
}

calcule_rect_interne :: fonc (panneau: *PanneauInterface)
{
    rect_interne := panneau.rect

    si panneau.barre_de_menu {
        panneau.barre_de_menu.besoin_ajournement_disposition = vrai
        ajourne_disposition(panneau.barre_de_menu)
        rect_interne.hauteur -= panneau.barre_de_menu.rect.hauteur
    }

    si panneau.élément_central {
        panneau.élément_central.besoin_ajournement_disposition = vrai
        redimensionne_panneau(panneau.élément_central, rect_interne)
    }
}

installe_élément_central :: fonc (panneau: *PanneauInterface)
{
    panneau.élément_central = élément_central
    panneau.calcule_rect_interne()
}

dessine_panneau_interface :: fonc (empl panneau: *PanneauInterface, ctx: *ContexteAffichage)
{
    si barre_de_menu {
        barre_de_menu.sur_dessin(barre_de_menu, ctx)
    }
}

reçoie_clique_souris :: fonc (empl panneau: *PanneauInterface, clique: CliqueSouris) -> bool
{
    si gère_clique_souris(barre_de_menu, clique) {
        retourne vrai
    }

    /* Ni le menu actif, ni la barre de menu n'ont géré le clique, n'affiche plus le menu. */
    contexte.détruit_panneau_menu()
    si barre_de_menu {
        barre_de_menu.sur_menu_fermé()
    }

    retourne faux
}

observe_souris :: fonc (empl panneau: *PanneauInterface, souris: ÉtatSouris)
{
    si barre_de_menu {
        barre_de_menu.sur_déplacement_souris(barre_de_menu, souris)
    }
}

/** } */
