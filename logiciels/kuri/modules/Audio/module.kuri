importe Flux
importe Fondation
importe Math
importe SysFichier

charge "wave"

/* ------------------------------------------------------------------------- */
/** \nom FormatAudio
 * \{ */

FormatÉchantillon :: énum {
    ENTIER_NATUREL_16_BIT
    ENTIER_RELATIF_16_BIT
}

FormatAudio :: struct {
    nombre_de_canaux: z32
    échantillons_par_seconde: z32
    format_échantillon: FormatÉchantillon
}

donne_taille_données_pour_une_seconde :: fonc (format: FormatAudio) -> z64
{
    résultat: z64
    
    résultat = format.nombre_de_canaux comme z64 * format.échantillons_par_seconde

    discr format.format_échantillon {
        ENTIER_NATUREL_16_BIT,
        ENTIER_RELATIF_16_BIT {
            résultat *= 2
        }
    }

    retourne résultat
}

donne_nombre_échantillons_pour_durée :: fonc (format: FormatAudio, durée: r64) -> n32
{
    résultat := format.échantillons_par_seconde * format.nombre_cannaux
    retourne ((résultat comme r64 * durée + 0.5) comme n64) comme n32
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom TamponAudio
 * \{ */

TamponAudio :: struct {
    format: FormatAudio
    données: [..]octet
}

crée_tampon_audio :: fonc (format: FormatAudio, nombre_de_secondes: z32) -> TamponAudio
{
    résultat: TamponAudio
    résultat.format = format
    taille_tampon := donne_taille_données_pour_une_seconde(format) * nombre_de_secondes
    tableau_redimensionne(résultat.données, taille_tampon)
    retourne résultat
}

détruit_données :: fonc (tampon: *TamponAudio)
{
    déloge(tampon.données)
    init_de(FormatAudio)(*tampon.format)
}

donne_sous_tampon :: fonc (tampon: TamponAudio, début_seconde: z32, fin_seconde: z32) -> TamponAudioStatique
{
    assert(début_seconde < fin_seconde)

    résultat := donne_tampon_statique(tampon)

    début := donne_taille_données_pour_une_seconde(résultat.format) * début_seconde
    fin   := donne_taille_données_pour_une_seconde(résultat.format) * fin_seconde

    résultat.données.pointeur += début
    résultat.données.taille = fin - début
    retourne résultat
}

donne_tampon_statique :: fonc (tampon: TamponAudio) -> TamponAudioStatique
{
    résultat: TamponAudioStatique
    résultat.format = tampon.format
    résultat.données = tampon.données
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom TamponAudioStatique
 * \{ */

TamponAudioStatique :: struct {
    format: FormatAudio
    données: []octet
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Génération de sons.
 * \{ */

remplis_avec_onde_sinusoïdal :: fonc (tampon: TamponAudio, fréquence: r64, facteur_amplitude: r32) -> rien
{
    temps_sinus: r64
    remplis_avec_onde_sinusoïdal(donne_tampon_statique(tampon), *temps_sinus, fréquence, facteur_amplitude)
}

remplis_avec_onde_sinusoïdal :: fonc (tampon: TamponAudioStatique, temps_sinus: *r64, fréquence: r64, facteur_amplitude: r32) -> rien
{
    format := tampon.format

    nombre_échantillons := tampon.données.taille
    si nombre_échantillons == 0 {
        retourne
    }

    assert((nombre_échantillons % format.nombre_de_canaux) == 0)

    assert(tampon.format.format_échantillon == FormatÉchantillon.ENTIER_RELATIF_16_BIT)

    données: []z16
    données.pointeur = tampon.données.pointeur comme *z16
    données.taille = tampon.données.taille / 2

    remplis_avec_onde_sinusoïdal(données, format.nombre_de_canaux, format.échantillons_par_seconde comme n64, temps_sinus, fréquence, facteur_amplitude)
}

remplis_avec_onde_carrée :: fonc (tampon: TamponAudioStatique, décalage_échantillon: n64, fréquence: r64, facteur_amplitude: r32)
{
    format := tampon.format

    nombre_échantillons := tampon.données.taille
    si nombre_échantillons == 0 {
        retourne
    }

    assert((nombre_échantillons % format.nombre_de_canaux) == 0)
    assert(tampon.format.format_échantillon == FormatÉchantillon.ENTIER_RELATIF_16_BIT)

    données: []z16
    données.pointeur = tampon.données.pointeur comme *z16
    données.taille = tampon.données.taille / 2

    remplis_avec_onde_carrée(données, format.nombre_de_canaux, format.échantillons_par_seconde comme n64, décalage_échantillon, fréquence, facteur_amplitude)
}

#portée_fichier

remplis_avec_onde_sinusoïdal :: fonc (données: []z16, nombre_de_canaux: z32, taux_échantillon: n64, temps_sinus: *r64, fréquence: r64, facteur_amplitude: r32)
{
    nombre_échantillons := données.taille
    nombre_échantillons_par_canal := nombre_échantillons / nombre_de_canaux

    période := ((taux_échantillon comme r64) / fréquence) comme r32
    dt_sinus := Constantes(r32).TAU / période

    facteur_amplitude = restreint(facteur_amplitude, 0.0, 1.0)
    amplitude := (facteur_amplitude * 32768)

    échantillon := données.pointeur

    t_sinus := mémoire(temps_sinus)

    pour nombre_échantillons_par_canal {
        valeur := (amplitude * sinus(t_sinus)) comme z16

        pour _ dans nombre_de_canaux {
            mémoire(échantillon) = valeur
            échantillon += 1
        }

        t_sinus += dt_sinus
    }

    mémoire(temps_sinus) = t_sinus
}

remplis_avec_onde_carrée :: fonc (données: []z16, nombre_de_canaux: z32, taux_échantillon: n64, décalage_échantillon: n64, fréquence: r64, facteur_amplitude: r32)
{
    nombre_échantillons := données.taille
    nombre_échantillons_par_canal := nombre_échantillons / nombre_de_canaux

    période := ((taux_échantillon comme r64) / fréquence) comme n64

    facteur_amplitude = restreint(facteur_amplitude, 0.0, 1.0)
    tonalité := (facteur_amplitude * 32768) comme z16

    échantillon := données.pointeur

    pour nombre_échantillons_par_canal {
        valeur := si (décalage_échantillon / période) % 2 == 0 {
            tonalité
        }
        sinon {
            -tonalité
        }

        décalage_échantillon += 1

        pour _ dans nombre_de_canaux {
            mémoire(échantillon) = valeur
            échantillon += 1
        }
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Export.
 * \{ */

#portée_export

écris_fichier_wave :: fonc (tampon: TamponAudio, chemin: chaine)
{
    assert(tampon.format.format_échantillon == FormatÉchantillon.ENTIER_RELATIF_16_BIT)

    format: ChunkFormatWave
    format.taille = 16
    format.tag_format = 1
    format.nombre_cannaux = tampon.format.nombre_de_canaux comme n16
    format.échantillons_secondes = tampon.format.échantillons_par_seconde comme n32
    format.bits_par_échantillon = 16
    format.alignement_bloc = calcule_alignement_bloc(format)
    format.bits_moyens_par_secondes = calcule_bits_moyens_par_secondes(format)

    données: []z16
    données.pointeur = tampon.données.pointeur comme *z16
    données.taille = tampon.données.taille / 2

    chunk_données: ChunkDonnéesWave
    chunk_données.taille = tampon.données.taille comme n32
    chunk_données.données = données

    écris_données(format, chunk_données, CheminFichier(chemin))
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom FluxLectureAudio
 * \{ */

FluxLectureAudio :: struct {
    flux: *FluxOctets
}

crée_flux_lecture_audio :: fonc (chemin: chaine) -> *FluxLectureAudio
{
    résultat := loge(FluxLectureAudio)
    initialise_flux_lecture_audio(résultat, chemin)
    retourne résultat
}

crée_flux_lecture_audio :: fonc (chemin: CheminFichier) -> *FluxLectureAudio
{
    retourne crée_flux_lecture_audio(chemin.chn)
}

crée_flux_lecture_audio :: fonc (octets: []octet) -> *FluxLectureAudio
{
    résultat := loge(FluxLectureAudio)
    initialise_flux_lecture_audio(résultat, chemin)
    retourne résultat
}

initialise_flux_lecture_audio :: fonc (flux: *FluxLectureAudio, chemin: CheminFichier)
{
    initialise_flux_lecture_audio(flux, chemin.chn)
}

initialise_flux_lecture_audio :: fonc (flux: *FluxLectureAudio, chemin: chaine)
{
    flux.flux = crée_flux_octets(chemin)
}

initialise_flux_lecture_audio :: fonc (flux: *FluxLectureAudio, octets: []octet)
{
    flux.flux = crée_flux_octets(octets)
}

détruit_données_flux :: fonc (flux: *FluxLectureAudio)
{
    détruit(flux.flux)
}

/* Détruit un flux qui fut créé par crée_flux_lecture_audio */
détruit_flux :: fonc (flux: *FluxLectureAudio)
{
    détruit_données_flux(flux)
    déloge(flux)
}

est_valide :: fonc (flux: *FluxLectureAudio) -> bool
{
    retourne flux.flux != nul
}

positionne_sur_données :: fonc (empl flux_lecture: *FluxLectureAudio)
{
    positionne(flux, PositionDébut(0))

    succès_chunk, chunk := lis_structure(flux, EntêteChunk)
    saufsi succès_chunk {
        imprimeln("Impossible de lire le chunk de l'entête WAVE")
        retourne
    }

    entête: EntêteWave
    entête.chunk = chunk
    taille_lue: z64
    entête.type_riff, taille_lue = lis_petit_boutisme(flux, n32)
    si taille_lue != 4 {
        imprimeln("Données trop petites pour lire l'entête WAVE")
        retourne
    }

    saufsi valide_entête_wave(entête) {
        imprimeln("Entête WAVE invalide")
        retourne
    }

    succès_format, format := lis_structure(flux, ChunkFormatWave)
    saufsi succès_format {
        imprimeln("Données trop petites pour lire le chunk de format")
        retourne
    }
    saufsi valide_chunk_format_wave(format) {
        imprimeln("Format wave invalide ou non reconnue.")
        retourne
    }

    tantque est_valide(flux) {
        succès_chunk, chunk = lis_structure(flux, EntêteChunk)
        saufsi succès_chunk {
            imprimeln("Impossible de lire un chunk du fichier WAVE")
            retourne
        }

        si chunk.id == ID_CHUNK_DATA_PB {
            arrête
        }

        positionne(flux, PositionRelative(chunk.taille comme z64))
    }
}

lis_échantillons_audio :: fonc (flux: *FluxLectureAudio, sortie: []octet)
{
    _ := lis(flux.flux, sortie)
}

/** \} */
