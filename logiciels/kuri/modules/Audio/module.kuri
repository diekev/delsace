importe Fondation
importe Math
importe SysFichier

charge "wave"

/* ------------------------------------------------------------------------- */
/** \nom FormatAudio
 * \{ */

FormatÉchantillon :: énum {
    ENTIER_NATUREL_16_BIT
    ENTIER_RELATIF_16_BIT
}

FormatAudio :: struct {
    nombre_de_canaux: z32
    échantillons_par_seconde: z32
    format_échantillon: FormatÉchantillon
}

donne_taille_données_pour_une_seconde :: fonc (format: FormatAudio) -> z64
{
    résultat: z64
    
    résultat = format.nombre_de_canaux comme z64 * format.échantillons_par_seconde

    discr format.format_échantillon {
        ENTIER_NATUREL_16_BIT,
        ENTIER_RELATIF_16_BIT {
            résultat *= 2
        }
    }

    retourne résultat
}

donne_nombre_échantillons_pour_durée :: fonc (format: FormatAudio, durée: r64) -> n32
{
    résultat := format.échantillons_par_seconde * format.nombre_cannaux
    retourne ((résultat comme r64 * durée + 0.5) comme n64) comme n32
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom TamponAudio
 * \{ */

TamponAudio :: struct {
    format: FormatAudio
    données: [..]octet
}

crée_tampon_audio :: fonc (format: FormatAudio, nombre_de_secondes: z32) -> TamponAudio
{
    résultat: TamponAudio
    résultat.format = format
    taille_tampon := donne_taille_données_pour_une_seconde(format) * nombre_de_secondes
    tableau_redimensionne(résultat.données, taille_tampon)
    retourne résultat
}

détruit_données :: fonc (tampon: *TamponAudio)
{
    déloge(tampon.données)
    init_de(FormatAudio)(*tampon.format)
}

donne_sous_tampon :: fonc (tampon: TamponAudio, début_seconde: z32, fin_seconde: z32) -> TamponAudioStatique
{
    assert(début_seconde < fin_seconde)

    résultat := donne_tampon_statique(tampon)

    début := donne_taille_données_pour_une_seconde(résultat.format) * début_seconde
    fin   := donne_taille_données_pour_une_seconde(résultat.format) * fin_seconde

    résultat.données.pointeur += début
    résultat.données.taille = fin - début
    retourne résultat
}

donne_tampon_statique :: fonc (tampon: TamponAudio) -> TamponAudioStatique
{
    résultat: TamponAudioStatique
    résultat.format = tampon.format
    résultat.données = tampon.données
    retourne résultat
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom TamponAudioStatique
 * \{ */

TamponAudioStatique :: struct {
    format: FormatAudio
    données: []octet
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Génération de sons.
 * \{ */

remplis_avec_son_sinusoïdal :: fonc (tampon: TamponAudio, fréquence: r64, facteur_amplitude: r32) -> rien
{
    remplis_avec_son_sinusoïdal(donne_tampon_statique(tampon), fréquence, facteur_amplitude)
}

remplis_avec_son_sinusoïdal :: fonc (tampon: TamponAudioStatique, fréquence: r64, facteur_amplitude: r32) -> rien
{
    format := tampon.format

    nombre_échantillons := tampon.données.taille
    si nombre_échantillons == 0 {
        retourne
    }

    assert((nombre_échantillons % format.nombre_de_canaux) == 0)

    assert(tampon.format.format_échantillon == FormatÉchantillon.ENTIER_RELATIF_16_BIT)

    données: []z16
    données.pointeur = tampon.données.pointeur comme *z16
    données.taille = tampon.données.taille / 2

    remplis_avec_son_sinusoïdal(données, format.nombre_de_canaux, fréquence, facteur_amplitude)
}

remplis_avec_onde_carrée :: fonc (tampon: TamponAudioStatique, décalage_échantillon: n64, fréquence: r64, facteur_amplitude: r32)
{
    format := tampon.format

    nombre_échantillons := tampon.données.taille
    si nombre_échantillons == 0 {
        retourne
    }

    assert((nombre_échantillons % format.nombre_de_canaux) == 0)
    assert(tampon.format.format_échantillon == FormatÉchantillon.ENTIER_RELATIF_16_BIT)

    données: []z16
    données.pointeur = tampon.données.pointeur comme *z16
    données.taille = tampon.données.taille / 2

    remplis_avec_onde_carrée(données, format.nombre_de_canaux, format.échantillons_par_seconde comme n64, décalage_échantillon, fréquence, facteur_amplitude)
}

#portée_fichier

remplis_avec_son_sinusoïdal :: fonc (données: []z16, nombre_de_canaux: z32, fréquence: r64, facteur_amplitude: r32)
{
    nombre_échantillons := données.taille
    nombre_échantillons_par_canal := nombre_échantillons / nombre_de_canaux

    t := (Constantes(r32).TAU * fréquence comme r32) / (nombre_échantillons_par_canal comme r32)

    facteur_amplitude = restreint(facteur_amplitude, 0.0, 1.0)
    amplitude := (facteur_amplitude * 32768)

    échantillon := données.pointeur

    pour nombre_échantillons_par_canal {
        valeur := (amplitude * sinus(t * (it comme r32))) comme z16

        pour _ dans nombre_de_canaux {
            mémoire(échantillon) = valeur
            échantillon += 1
        }
    }
}

remplis_avec_onde_carrée :: fonc (données: []z16, nombre_de_canaux: z32, taux_échantillon: n64, décalage_échantillon: n64, fréquence: r64, facteur_amplitude: r32)
{
    nombre_échantillons := données.taille
    nombre_échantillons_par_canal := nombre_échantillons / nombre_de_canaux

    période := ((taux_échantillon comme r64) / fréquence) comme n64

    facteur_amplitude = restreint(facteur_amplitude, 0.0, 1.0)
    tonalité_haute := (facteur_amplitude * 32768) comme z16
    tonalité_basse := (facteur_amplitude * 32768) comme z16

    échantillon := données.pointeur

    pour nombre_échantillons_par_canal {
        valeur := si (décalage_échantillon / période) % 2 == 0 {
            tonalité_haute
        }
        sinon {
            -tonalité_basse
        }

        décalage_échantillon += 1

        pour _ dans nombre_de_canaux {
            mémoire(échantillon) = valeur
            échantillon += 1
        }
    }
}

/** \} */

/* ------------------------------------------------------------------------- */
/** \nom Export.
 * \{ */

#portée_export

écris_fichier_wave :: fonc (tampon: TamponAudio, chemin: chaine)
{
    assert(tampon.format.format_échantillon == FormatÉchantillon.ENTIER_RELATIF_16_BIT)

    format: ChunkFormatWave
    format.taille = 16
    format.tag_format = 1
    format.nombre_cannaux = tampon.format.nombre_de_canaux comme n16
    format.échantillons_secondes = tampon.format.échantillons_par_seconde comme n32
    format.bits_par_échantillon = 16
    format.alignement_bloc = calcule_alignement_bloc(format)
    format.bits_moyens_par_secondes = calcule_bits_moyens_par_secondes(format)

    données: []z16
    données.pointeur = tampon.données.pointeur comme *z16
    données.taille = tampon.données.taille / 2

    chunk_données: ChunkDonnéesWave
    chunk_données.taille = tampon.données.taille comme n32
    chunk_données.données = données

    écris_données(format, chunk_données, CheminFichier(chemin))
}

/** \} */
