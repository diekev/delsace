importe Couleur
importe FTGL
importe Fondation
importe Math
importe OpenGL

RendeuseTexte :: struct {
	// délégué au système
    hauteur := 0
    largeur := 0
    décalage := 0.0

	// Fonte
    taille_police := 0.0

	// Nuanceur
    programme : n32
}

dessine_texte :: fonc (rendeuse: *RendeuseTexte, texte: chaine) -> rien
{
    chemin_fonte := "/usr/share/fonts/truetype/dejavu/DejaVuSansMono.ttf\0"

	pos := Vec2( x = 8.0, y = 8.0 + rendeuse.décalage )
	taille := Vec2( x = rendeuse.largeur comme r32, y = rendeuse.hauteur comme r32 )
}

dessine_lettres :: fonc (rendeuse: *RendeuseTexte, tampon: *rien, texte: chaine, atlas: *texture_atlas_t, markup: *markup_t, pos: Vec2, taille: Vec2) -> rien
{
    pen := vec2( x = pos.x, y = taille.y - pos.y - rendeuse.taille_police )

	sommets : []Vec2
	uvs : []Vec2
	couleurs : []Couleur
	indices : []z32

    diffère {
        déloge(sommets)
        déloge(uvs)
        déloge(couleurs)
        déloge(indices)
    }

    couleur := Couleur(
        r = markup.foreground_color.x,
        v = markup.foreground_color.y,
        b = markup.foreground_color.z,
        a = markup.foreground_color.w)

	inv_taille := Vec2( x = 1.0 / taille.x, y = 1.0 / taille.y )

    dernier_caractère : *z8 = nul

    pour c dans texte {
		glyph := texture_font_get_glyph(markup.font, *c)

		si glyph == nul {
			continue
		}

		kerning := 0.0

		si dernier_caractère != nul {
			kerning = texture_glyph_get_kerning(glyph, dernier_caractère)
		}

		pen.x += kerning
		x0 := (pen.x + glyph.offset_x comme r32) * inv_taille.x
		y0 := (pen.y + glyph.offset_y comme r32) * inv_taille.y
		x1 := x0 + glyph.width comme r32 * inv_taille.x
		y1 := y0 - glyph.height comme r32 * inv_taille.y
		s0 := glyph.s0;
		t0 := glyph.t0;
		s1 := glyph.s1;
		t1 := glyph.t1;

		decalage_index := sommets.taille comme z32
		tableau_ajoute(*indices, 0 + decalage_index)
		tableau_ajoute(*indices, 1 + decalage_index)
		tableau_ajoute(*indices, 2 + decalage_index)
		tableau_ajoute(*indices, 0 + decalage_index)
		tableau_ajoute(*indices, 2 + decalage_index)
		tableau_ajoute(*indices, 3 + decalage_index)

		tableau_ajoute(*sommets, Vec2( x = x0, y = y0 ))
		tableau_ajoute(*sommets, Vec2( x = x0, y = y1 ))
		tableau_ajoute(*sommets, Vec2( x = x1, y = y1 ))
		tableau_ajoute(*sommets, Vec2( x = x1, y = y0 ))

		tableau_ajoute(*uvs, Vec2( x = s0, y = t0 ))
		tableau_ajoute(*uvs, Vec2( x = s0, y = t1 ))
		tableau_ajoute(*uvs, Vec2( x = s1, y = t1 ))
		tableau_ajoute(*uvs, Vec2( x = s1, y = t0 ))

        tableau_ajoute(*couleurs, couleur)
        tableau_ajoute(*couleurs, couleur)
        tableau_ajoute(*couleurs, couleur)
        tableau_ajoute(*couleurs, couleur)

		pen.x += glyph.advance_x

        dernier_caractère = *c
	}

    // --------------------------------------

    glGenVertexArrays(1, *rendeuse.id_tableau_vertex)
    glGenBuffers(1, *rendeuse.id_tampon_index)
    glGenBuffers(1, *rendeuse.id_tampon_vertex)
    glGenBuffers(1, *rendeuse.id_tampon_couleur)
    glGenBuffers(1, *rendeuse.id_tampon_tex_coord)

    glBindVertexArray(rendeuse.id_tableau_vertex)

    // --------------------------------------

    glBindBuffer(GL_ARRAY_BUFFER, rendeuse.id_tampon_vertex);
	glBufferData(GL_ARRAY_BUFFER, sommets.taille comme n64 * taille_de(Vec2), *sommets[0], GL_STATIC_DRAW);

	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, rendeuse.id_tampon_index);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.taille comme n64 * taille_de(z32), *indices[0], GL_STATIC_DRAW);

	glEnableVertexAttribArray(0);
	glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, nul);

    // --------------------------------------

    glBindBuffer(GL_ARRAY_BUFFER, rendeuse.id_tampon_tex_coord);
	glBufferData(GL_ARRAY_BUFFER, uvs.taille comme n64 * taille_de(Vec2), *uvs[0], GL_STATIC_DRAW);

	glEnableVertexAttribArray(1);
	glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, nul);

    // --------------------------------------

    glBindBuffer(GL_ARRAY_BUFFER, rendeuse.id_tampon_couleur);
	glBufferData(GL_ARRAY_BUFFER, couleurs.taille comme n64 * taille_de(Vec4), *couleurs[0], GL_STATIC_DRAW);

	glEnableVertexAttribArray(2);
	glVertexAttribPointer(2, 4, GL_FLOAT, GL_FALSE, 0, nul);

    // --------------------------------------

    glBindVertexArray(0)

    // --------------------------------------

	si atlas == nul {
		imprime("L'atlas est nul !\n")
	}
	sinon si atlas.data == nul {
		imprime("Les données de l'atlas sont nuls !\n")
	}

	glGenTextures(1, *atlas.id )
	glBindTexture(_GL_TEXTURE_2D, atlas.id)
	glTexParameteri(_GL_TEXTURE_2D, _GL_TEXTURE_WRAP_S, _GL_CLAMP_TO_EDGE );
	glTexParameteri(_GL_TEXTURE_2D, _GL_TEXTURE_WRAP_T, _GL_CLAMP_TO_EDGE );
	glTexParameteri(_GL_TEXTURE_2D, _GL_TEXTURE_MAG_FILTER, _GL_LINEAR );
	glTexParameteri(_GL_TEXTURE_2D, _GL_TEXTURE_MIN_FILTER, _GL_LINEAR );

    glTexImage2D(_GL_TEXTURE_2D, 0, _GL_RED, atlas.width comme z32, atlas.height comme z32,
				  0, _GL_RED, _GL_UNSIGNED_BYTE, atlas.data )

	{
		glUseProgram(rendeuse.programme)
        glBindVertexArray(rendeuse.id_tableau_vertex)

        loc := glGetUniformLocation(rendeuse.programme, "atlas".pointeur)
	    glUniform1ui(loc, 0);

		glDrawElements(GL_TRIANGLES, indices.taille comme z32, _GL_UNSIGNED_INT, nul);

        glBindVertexArray(0)
        glUseProgram(0)
	}

	glDeleteTextures(1, *atlas.id)
}
