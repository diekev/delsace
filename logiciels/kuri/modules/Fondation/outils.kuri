échange :: fonc(a : *$T, b : *T) -> rien #enligne
{
	temp := mémoire(a);
	mémoire(a) = mémoire(b);
	mémoire(b) = temp;
}

permute :: fonc (a: &$T, b: &T) #enligne
{
    tmp : T = a
    a = b
    b = tmp
}

// Type pour représenter un résultat optionnel
Résultat :: union ($T: type_de_données) {
    Quelque: T
    Aucun
}

valeur_ou :: fonc (résultat: Résultat($T), valeur: T) -> T #enligne
{
	discr résultat {
		Quelque(v) {
			retourne v
		}
		sinon {
			retourne valeur
		}
	}
}

valeur_ou_défaut :: fonc (résultat: Résultat($T)) -> T #enligne
{
    discr résultat {
		Quelque(v) {
			retourne v
		}
        sinon {
			valeur_défaut: T
			retourne valeur_défaut
        }
    }
}

possède_valeur :: fonc (résultat: Résultat($T)) -> bool #enligne
{
	discr résultat {
		Quelque {
			retourne vrai
		}
		sinon {
			retourne faux
		}
	}
}
