// Bibliothèque de flux, d'impression dans stdout.

importe GlibC
importe Numérique

//###################################################################################

TamponEnchaineuse :: struct {
    données : [16384]z8
    occupé  : z32
    suivant : *TamponEnchaineuse
}

Enchaineuse :: struct {
    tampon : TamponEnchaineuse
    tampon_courant : *TamponEnchaineuse
}

initialise_enchaineuse :: fonc (dyn enchaineuse : *Enchaineuse) -> rien
{
    enchaineuse.tampon_courant = @enchaineuse.tampon
    enchaineuse.tampon_courant.occupé = 0
    enchaineuse.tampon_courant.suivant = nul
}

taille_chaine :: fonc (dyn enchaineuse: *Enchaineuse) -> z64
{
    dyn taille : z64 = 0
    dyn tampon_courant := @enchaineuse.tampon

    tantque tampon_courant != nul {
        taille += tampon_courant.occupé
        tampon_courant = tampon_courant.suivant
    }

    retourne taille
}

chaine_depuis_enchaineuse :: fonc (enchaineuse: *Enchaineuse) -> chaine
{
    taille := taille_chaine(enchaineuse)

	si taille == 0 {
		retourne copie_chaine("")
	}

    chn := loge chaine(taille)

    dyn tampon_courant := @enchaineuse.tampon

    dyn curseur : z64 = 0

    tantque tampon_courant != nul {
        taille_tampon := tampon_courant.occupé
        src := @tampon_courant.données[0]
        dst := @chn[curseur]

        copie_mem_nonsur(src = src, dst = dst, taille = taille_tampon)

        tampon_courant = tampon_courant.suivant
        curseur += taille_tampon
    }

    retourne chn
}

détruit_tampons :: fonc (enchaineuse: *Enchaineuse) -> rien
{
    // le premier tampon n'est pas alloué dynamiquement
    dyn tampon_courant := enchaineuse.tampon.suivant

    tantque tampon_courant != nul {
        suivant := tampon_courant.suivant
        déloge tampon_courant
        tampon_courant = suivant
    }
}

imprime_dans_enchaineuse :: fonc (dyn enchaineuse: *Enchaineuse, format: chaine, args: ...eini) -> rien
{
    dyn index := 0

	pour c dans format {
		si c == '%' && index < args.taille {
			arg := args[index]
			imprime_valeur(enchaineuse, arg.pointeur, arg.info, faux)
			index += 1
		}
		sinon {
			ajoute_au_tampon(enchaineuse, c)
		}
	}
}

ajoute_tampon :: fonc (dyn enchaineuse: *Enchaineuse) -> *TamponEnchaineuse
{
    dyn tampon := enchaineuse.tampon_courant

	dyn nouveau_tampon := loge TamponEnchaineuse
    nouveau_tampon.occupé = 0
	nouveau_tampon.suivant = nul

	tampon.suivant = nouveau_tampon
	enchaineuse.tampon_courant = nouveau_tampon

	retourne nouveau_tampon
}

ajoute_au_tampon :: fonc (dyn enchaineuse: *Enchaineuse, c: z8) -> rien
{
    dyn tampon := enchaineuse.tampon_courant

    si tampon.occupé == 16384 {
		tampon = ajoute_tampon(enchaineuse)
		tampon.données[0] = c
		tampon.occupé = 1
	}
	sinon {
		tampon.données[tampon.occupé] = c
		tampon.occupé += 1
	}
}

ajoute_au_tampon :: fonc (dyn enchaineuse: *Enchaineuse, chn: chaine) -> rien
{
	si chn.taille == 0 {
		retourne
	}

    dyn tampon := enchaineuse.tampon_courant

    si (tampon.occupé + chn.taille) > 16384 {
        dyn taille := 16384 - tampon.occupé
        dyn src := chn.pointeur
        dyn dst := @tampon.données[tampon.occupé]
        tampon.occupé += taille

        copie_mem_nonsur(src = src, dst = dst, taille = taille)

        tampon = ajoute_tampon(enchaineuse)

        delta := chn.taille - taille

        src = @chn[chn.taille - delta]
        dst = @tampon.données[0]
        taille = transtype(chn.taille - taille: z32)

        copie_mem_nonsur(src = src, dst = dst, taille = taille)

        tampon.occupé += delta
    }
    sinon {
        src := chn.pointeur
        dst := @tampon.données[tampon.occupé]
        taille := chn.taille

        copie_mem_nonsur(src = src, dst = dst, taille = taille)

        tampon.occupé += chn.taille
    }
}

ajoute_au_tampon :: fonc (dyn enchaineuse : *Enchaineuse, chns: ...chaine) -> rien
{
	pour chn dans chns {
		ajoute_au_tampon(enchaineuse, chn)
	}
}

ajoute_au_tampon :: fonc (dyn enchaineuse: *Enchaineuse, args: ...eini) -> rien
{
	pour arg dans args {
		imprime_valeur(enchaineuse, arg.pointeur, arg.info, faux)
	}
}

// Retourne une chaine correspondant à l'enchainement de toutes les chaines
// spécifiées. La chaine retournée a été logé et doit être délogée par
// l'appelante.
enchaine :: fonc(chns : ...chaine) -> chaine
{
	dyn enchaineuse : Enchaineuse
	initialise_enchaineuse(@enchaineuse)
	diffère { détruit_tampons(@enchaineuse) }
	ajoute_au_tampon(@enchaineuse, ...chns)
	retourne chaine_depuis_enchaineuse(@enchaineuse)
}

//###################################################################################

// Imprime le nombre décimal en utilisant un nombre entier de haute précision afin de
// mieux cerner la valeur exacte du décimal.
// https://randomascii.wordpress.com/2012/03/08/float-precisionfrom-zero-to-100-digits-2/
imprime_nombre_décimal_haute_précision :: fonc(dyn enchaineuse : *Enchaineuse, f : r32) -> rien
{
	// Mets le nombre dans notre union magique afin d'extraire les composants
	num := construit_entier_ou_décimal(f)

	// Défini le caractère pour le signe
	si num.est_négatif() {
		ajoute_au_tampon(enchaineuse, '-')
	}

	// Vérifie si NaN ou infinité
	si num.exposant_cru() == 255 {
		// Vérifie si infinité
		si num.mantisse_crue() == 0 {
			ajoute_au_tampon(enchaineuse, "inf")
			retourne
		}

		// Sinon nous avons un NaN. On pourrait imprimer la valeur crue de la mantisse.
		ajoute_au_tampon(enchaineuse, "nan")
		retourne
	}

	// Ajustement pour le biais de l'exposant.
	dyn valeur_exposant := num.exposant_cru() - 127

	// Ajoute celui implicit à la mantisse.
	dyn valeur_mantisse := (1 << 23) + num.mantisse_crue()

	// Cas spécial pour les dénormales - pas de valeur spéciale d'exposant et pas d'impliquée
	si num.exposant_cru() == 0 {
		valeur_exposant = -126
		valeur_mantisse = num.mantisse_crue()
	}

	// Le premier bit de la mantisse a une valeur implicite de 1 et ceci peut
	// être décalé de 127 positions vers la gauche, donc de 125 bits vers la gauche
	// du point binaire, ou 4 mots pour la part entière.
	dyn part_entière := construit_nombre_haute_précision() // haute_précision<4>

	// Quand notre valeur_exposant est 0 (un nombre entre 1.0 et 2.0),
	// nous avons une mantisse de 24 bits et la valeur implicite du bit le plus haut
	// est 1. Nous devons donc décaler 9 bits depuis le bas afin d'avoir le 24ème bit
	// dans la position du 1 dans portion entière, ajoutant le décalage de l'exposant.
	insère_bits_du_bas(
		@part_entière,
		transtype(valeur_mantisse : n32),
		9 + valeur_exposant)

	dyn chn_part_entière : chaine

	// Perfome toujours au moins une itération, afin d'avoir un zéro au début.
	répète {
		reste := reste_de_la_division(@part_entière, transtype(10 : n32))
		pousse(@chn_part_entière, '0' + transtype(reste : z8))
	} tantque !est_zéro(@part_entière)

	inverse(@chn_part_entière)
	ajoute_au_tampon(enchaineuse, chn_part_entière)
	déloge chn_part_entière

	// Ajout le point décimal.
	ajoute_au_tampon(enchaineuse, '.')

	// Nous avons une mantisse de 23-bits à droite du point binaire et ceci
	// peut être décalé de 126 positions vers la droite, donc 149 bits, ou
	// 5 mots de 32-bits.
	dyn frac := construit_nombre_haute_précision() // haute_précision<5>

	// Quand valeur_exposant est zéro nous voulons décaler 23 bits de mantisse dans
	// la part fractionnelle.
	insère_bits_du_haut(@frac, transtype(valeur_mantisse : n32), 23 - valeur_exposant);

	// Perfome toujours au moins une itération, afin d'avoir un zéro au début.
	répète {
		surplus := surplus_de_la_multiplication(@frac, transtype(10 : n32))
		ajoute_au_tampon(enchaineuse, '0' + transtype(surplus : z8))
	} tantque !est_zéro(@frac)
}

//###################################################################################

FormatEntier :: struct {
    valeur : eini
    ajoute_zéros_début := faux
    nombre_zéros := 0
    base := 10
	séparation := 0
}

formatte_entier :: fonc (valeur: eini, ajoute_zéros_début := faux, nombre_zéros := 0, base := 10, séparation := 0) -> FormatEntier
{
    retourne FormatEntier{
        valeur = valeur,
        ajoute_zéros_début = ajoute_zéros_début,
        nombre_zéros = nombre_zéros,
        base = base,
		séparation = séparation
    }
}

imprime_n64_base_n :: fonc (dyn enchaineuse: *Enchaineuse, dyn v: n64, format: FormatEntier) -> rien
{
	base := transtype(format.base: n64)
	assert(base >= transtype(2: n64))
	assert(base <= transtype(64: n64))

	chiffres_base_64 := "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_#"

	dyn résultat : [64]z8

	dyn fin := @résultat[0] + 64
	dyn début := fin

	tantque v != transtype(0: n64) {
		chiffre := v % base
		v /= base

		début -= 1
		mémoire(début) = chiffres_base_64[chiffre]
	}

	si début == fin {
		début -= 1
		mémoire(début) = '0'
	}

	taille := transtype(fin - début: z32)

	pour i dans 0 ... taille - 1 {
		si format.séparation != 0 {
			si i != 0 && ((taille - i) % format.séparation) == 0 {
				ajoute_au_tampon(enchaineuse, ' ')
			}
		}

		ajoute_au_tampon(enchaineuse, début[i])
	}
}

imprime_nombre_entier :: fonc (dyn enchaineuse: *Enchaineuse, format: FormatEntier) -> rien
{
	info := transtype(format.valeur.info: *InfoTypeEntier)
	pointeur := format.valeur.pointeur

	dyn valeur : n64

	si info.est_signé {
		dyn val := z64_depuis_pointeur(pointeur, info.taille_en_octet)

		si val < 0 {
			ajoute_au_tampon(enchaineuse, '-')
			val = -val
		}

		valeur = transtype(val: n64)
	}
	sinon {
		valeur = n64_depuis_pointeur(pointeur, info.taille_en_octet)
	}

	si format.ajoute_zéros_début {
		pour i dans 0 ... format.nombre_zéros - 1 {
			ajoute_au_tampon(enchaineuse, '0')
		}
	}

	imprime_n64_base_n(enchaineuse, valeur, format)
}

z64_depuis_pointeur :: fonc (pointeur: *z8, taille: n32) -> z64
{
	si taille == transtype(1: n32) { retourne mémoire(transtype(pointeur : *z8)) }
	si taille == transtype(2: n32) { retourne mémoire(transtype(pointeur : *z16)) }
	si taille == transtype(4: n32) { retourne mémoire(transtype(pointeur : *z32)) }
	si taille == transtype(8: n32) { retourne mémoire(transtype(pointeur : *z64)) }

	retourne 0
}

n64_depuis_pointeur :: fonc (pointeur: *z8, taille: n32) -> n64
{
	si taille == transtype(1: n32) { retourne mémoire(transtype(pointeur : *n8)) }
	si taille == transtype(2: n32) { retourne mémoire(transtype(pointeur : *n16)) }
	si taille == transtype(4: n32) { retourne mémoire(transtype(pointeur : *n32)) }
	si taille == transtype(8: n32) { retourne mémoire(transtype(pointeur : *n64)) }

	retourne transtype(0: n32)
}

FormatRéel :: struct {
	valeur: eini
	précision := 6
}

formatte_réel :: fonc (valeur: eini, précision: z32) -> FormatRéel
{
	retourne FormatRéel{
		valeur = valeur,
		précision = précision
	}
}

imprime_nombre_réel :: fonc(dyn enchaineuse: *Enchaineuse, format: FormatRéel) -> rien
{
	info := format.valeur.info
	pointeur := format.valeur.pointeur
	dyn f : r32

	si info.taille_en_octet == transtype(2: n32) {
		x := mémoire(transtype(pointeur : *r16))
		f = x
	}
	sinon si info.taille_en_octet == transtype(4: n32) {
		f = mémoire(transtype(pointeur : *r32))
	}
	sinon si info.taille_en_octet == transtype(8: n32) {
		x := mémoire(transtype(pointeur : *r64))
		f = transtype(x : r32)
	}

	// Mets le nombre dans notre union magique afin d'extraire les composants
	num := construit_entier_ou_décimal(f)

	// Défini le caractère pour le signe
	si num.est_négatif() {
		ajoute_au_tampon(enchaineuse, '-')
	}

	// Vérifie si NaN ou infinité
	si num.exposant_cru() == 255 {
		// Vérifie si infinité
		si num.mantisse_crue() == 0 {
			ajoute_au_tampon(enchaineuse, "inf")
			retourne
		}

		// Sinon nous avons un NaN. On pourrait imprimer la valeur crue de la mantisse.
		ajoute_au_tampon(enchaineuse, "nan")
		retourne
	}

	si f == 0.0 {
		ajoute_au_tampon(enchaineuse, "0.0")
		retourne
	}

	dyn x := f

	si f < 0.0 {
		x = -x
	}

	dyn part_entière := transtype(x : n64)

	imprime_nombre_entier(enchaineuse, formatte_entier(part_entière))

	ajoute_au_tampon(enchaineuse, '.')

	dyn frac := x - transtype(part_entière : r32)

	chiffres := "0123456789"

	dyn p := format.précision

	répète {
		frac *= 10.0
		chiffre := transtype(frac : z64)

		ajoute_au_tampon(enchaineuse, chiffres[chiffre])

		frac = frac - transtype(chiffre : r32)
		p -= 1
	} tantque frac < 1.0 && frac != 0.0 && p >= 0
}

imprime_valeur :: fonc(
	dyn enchaineuse : *Enchaineuse,
	pointeur : *z8,
	info : *InfoType,
	échappe_chn : bool) -> rien
{
    discr info.id {
		OCTET {
			dyn e : eini
			e.pointeur = pointeur
			e.info = info

			fmt := formatte_entier(e, base = 16)
			imprime_nombre_entier(enchaineuse, fmt)
		}
		ENTIER {
			dyn e : eini
			e.pointeur = pointeur
			e.info = info

			fmt := formatte_entier(e)
			imprime_nombre_entier(enchaineuse, fmt)
		}
		RÉEL {
			dyn e : eini
			e.pointeur = pointeur
			e.info = info

			imprime_nombre_réel(enchaineuse, formatte_réel(e, 6))
		}
		BOOLÉEN {
			x := mémoire(transtype(pointeur : *bool))

            si x {
				ajoute_au_tampon(enchaineuse, "vrai")
			}
			sinon {
				ajoute_au_tampon(enchaineuse, "faux")
			}
		}
		CHAINE {
			x := mémoire(transtype(pointeur : *chaine))

            si échappe_chn {
				ajoute_au_tampon(enchaineuse, '"')
			}

			ajoute_au_tampon(enchaineuse, x)

            si échappe_chn {
				ajoute_au_tampon(enchaineuse, '"')
			}
		}
		STRUCTURE {
			info_arg := transtype(info : *InfoTypeStructure)

			si info_arg == info_de(FormatEntier{}) {
				imprime_nombre_entier(enchaineuse, mémoire(transtype(pointeur: *FormatEntier)))
				retourne
			}

			si info_arg == info_de(FormatRéel{}) {
				imprime_nombre_réel(enchaineuse, mémoire(transtype(pointeur: *FormatRéel)))
				retourne
			}

            ajoute_au_tampon(enchaineuse, info_arg.nom)
            ajoute_au_tampon(enchaineuse, " {")

            pour membre, idx dans info_arg.membres {
				nom := membre.nom
                décalage := membre.décalage
				id := membre.id

                si idx != 0 {
                    ajoute_au_tampon(enchaineuse, ',')
                }

                ajoute_au_tampon(enchaineuse, nom)
                ajoute_au_tampon(enchaineuse, " = ")

				imprime_valeur(enchaineuse, pointeur + décalage, id, vrai)
			}

            ajoute_au_tampon(enchaineuse, " }")
		}
		POINTEUR {
			info_arg := transtype(info : *InfoTypePointeur)

		    // Ne pas oublier qu'il y a un niveau d'indirection.
			x := mémoire(transtype(pointeur : **z8))

			si info_arg.est_référence {
				imprime_valeur(enchaineuse, x, info_arg.type_pointé, vrai)
			}
			sinon {
				fmt := formatte_entier(transtype(x: n64), base = 16)
				imprime_nombre_entier(enchaineuse, fmt)
			}
		}
		FONCTION {
		    // Ne pas oublier qu'il y a un niveau d'indirection.
			x := mémoire(transtype(pointeur : **z8))
			fmt := formatte_entier(transtype(x: n64), base = 16)
			imprime_nombre_entier(enchaineuse, fmt)
		}
		EINI {
			x := mémoire(transtype(pointeur : *eini))

            ajoute_au_tampon(enchaineuse, "eini { ptr = ")
			dyn fmt := formatte_entier(transtype(x.pointeur: n64), base = 16)
			imprime_nombre_entier(enchaineuse, fmt)
            ajoute_au_tampon(enchaineuse, ", info = ")
			fmt = formatte_entier(transtype(x.info: n64), base = 16)
			imprime_nombre_entier(enchaineuse, fmt)
            ajoute_au_tampon(enchaineuse, " }")
		}
		RIEN {
            ajoute_au_tampon(enchaineuse, "rien")
		}
		TABLEAU {
			info_arg := transtype(info : *InfoTypeTableau)

            décalage := transtype(info_arg.type_pointé.taille_en_octet: z32)

			dyn max_élément := 5

            ajoute_au_tampon(enchaineuse, "[")

            si info_arg.est_tableau_fixe {
				si info_arg.taille_fixe < max_élément {
					max_élément = info_arg.taille_fixe
				}

                pour i dans 0 ... max_élément - 1 {
                    si i != 0 {
                        ajoute_au_tampon(enchaineuse, ',')
                    }

                    imprime_valeur(enchaineuse, pointeur + décalage * i, info_arg.type_pointé, vrai)
                }

				si info_arg.taille_fixe > max_élément {
            		ajoute_au_tampon(enchaineuse, ", ...")
				}
            }
            sinon {
                x := mémoire(transtype(pointeur: *[]z8))

				si x.taille < max_élément {
					max_élément = transtype(x.taille: z32)
				}

                pour i dans 0 ... max_élément - 1 {
                    si i != 0 {
                        ajoute_au_tampon(enchaineuse, ',')
                    }

                    imprime_valeur(enchaineuse, x.pointeur + décalage * i, info_arg.type_pointé, vrai)
                }

				si x.taille > max_élément {
            		ajoute_au_tampon(enchaineuse, ", ...")
				}
            }

            ajoute_au_tampon(enchaineuse, "]")
		}
		ÉNUM {
			info_arg := transtype(info : *InfoTypeÉnum)

			// À FAIRE : typage selon énum
			valeur := mémoire(transtype(pointeur : *z32))
			noms := info_arg.noms

			si info_arg.est_drapeau {
				dyn valeur_trouvée := faux

				pour v, i dans info_arg.valeurs {
					si (v & valeur) != 0 {
						si valeur_trouvée {
							ajoute_au_tampon(enchaineuse, " | ")
						}

						ajoute_au_tampon(enchaineuse, noms[i])
						valeur_trouvée = vrai
					}
				}

				si !valeur_trouvée {
					ajoute_au_tampon(enchaineuse, "0")
				}
			}
			sinon {
				pour v, i dans info_arg.valeurs {
					si v == valeur {
						ajoute_au_tampon(enchaineuse, noms[i])
						arrête
					}
				}
			}
		}
	}
}

imprime :: fonc(format: chaine, args: ...eini) -> rien
{
    chn := imprime_chaine(format, ...args)
	write(std_out, chn.pointeur, chn.taille)
	déloge chn
}

imprime_chaine :: fonc (format: chaine, args: ...eini) -> chaine
{
    enchaineuse : Enchaineuse
	initialise_enchaineuse(@enchaineuse)
	diffère { détruit_tampons(@enchaineuse) }

	imprime_dans_enchaineuse(@enchaineuse, format, ...args)
	retourne chaine_depuis_enchaineuse(@enchaineuse)
}

imprime_sans_format :: fonc(args : ...eini) -> rien
{
    enchaineuse : Enchaineuse
	initialise_enchaineuse(@enchaineuse)
    diffère { détruit_tampons(@enchaineuse); }

    pour arg dans args {
		imprime_valeur(@enchaineuse, arg.pointeur, arg.info, faux)
    }

	résultat := chaine_depuis_enchaineuse(@enchaineuse)
	write(std_out, résultat.pointeur, résultat.taille)
	déloge résultat
}

imprime_sans_format_err :: fonc(args : ...eini) -> rien
{
    enchaineuse : Enchaineuse
	initialise_enchaineuse(@enchaineuse)
	diffère { détruit_tampons(@enchaineuse); }

    pour arg dans args {
		imprime_valeur(@enchaineuse, arg.pointeur, arg.info, faux)
    }

	résultat := chaine_depuis_enchaineuse(@enchaineuse)
	write(std_err, résultat.pointeur, résultat.taille)
	déloge résultat
}

imprime_log :: fonc (mode: ModeLogage, ident: chaine, format: chaine, args: ...eini) -> rien
{
	message := imprime_chaine(format, ...args)

	log := contexte.logueur
    log(message, ident, mode, contexte.données_logueur)
	déloge message
}

// --------------------------

// À FAIRE : trouve une manière de trouver la chaine de l'expression
assert :: fonc (expr: bool, pos := PositionCodeSource{}) -> rien
{
    si expr {
        retourne
    }

    imprime("%:% : l'assertion a échoué !\n", pos.fichier, pos.ligne)
    abort()
}
