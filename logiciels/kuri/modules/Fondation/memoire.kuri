// Bibliothèque de manipulation de la mémoire contenue dans des tampon
// Ces fonctions sont leurs pendantes de celles de la bibliothèque standard de C
// (memcmp, memcpy, memmove, memchr), à la différence que nous utilisons des
// tableaux d'octets pour s'assurer que nous ne dépassons jamais les limites des
// blocs de mémoires à manipuler.

comp_mem_ordre :: fonc(a : []octet, b : []octet, taille : z64) -> z32 #nulctx
{
    si a.taille < taille {
		retourne -1
	}

    si b.taille < taille {
		retourne 1
	}

    pour i dans 0...taille - 1 {
		v := a[i] - b[i]

        si v != transtype(0: octet) {
			retourne transtype(v : z32)
		}
	}

	retourne 0
}

comp_mem :: fonc(a : []octet, b : []octet, taille : z64) -> bool #nulctx
{
    si a.taille < taille {
		retourne faux
	}

    si b.taille < taille {
		retourne faux
	}

    si a.taille != b.taille {
		retourne faux
	}

    pour i dans 0...taille - 1 {
	    si a[i] != b[i] {
			retourne faux
		}
	}

	retourne vrai
}

copie_mem_nonsur :: fonc(src : *octet, dst : *octet, taille : z64) -> rien #nulctx
{
    pour i dans 0...taille - 1 {
		dst[i] = src[i]
	}
}

// Copie 'taille' octets depuis la source vers la destination
// La copie se fait comme si un tampon intermédiaire a été utilisé,
// permettant à la source et à la destination de se surposer.
copie_mem :: fonc(src : []octet, dst : []octet, taille : z64) -> rien #nulctx
{
    si src.taille < taille {
		retourne
	}

    si dst.taille < taille {
		retourne
	}

    // vérifie si surposition

	ptr_deb_src := @src[0]
	ptr_fin_src := @src[src.taille - 1]
	ptr_deb_dst := @dst[0]

    // src |---------------|
	// dst       |---------------|
	// Copie à partir de la fin.
	si ptr_deb_src <= ptr_deb_dst <= ptr_fin_src {
	    pour i dans 0...taille - 1 {
			idx := taille - i - 1
			dst[idx] = src[idx]
		}
	}
	sinon {
	    pour i dans 0...taille - 1 {
			dst[i] = src[i]
		}
	}
}

// Similaire à copie_mem. La bibliothèque C possède memcpy et memmove, la
// différence étant que memcpy ne peut recevoir de blocs se surposant, alors que
// memmove peut  mais aucune vérification n'est faite dans memcpy, menant à des
// vulnérabilités ! Nous faisons une vérification dans notre version 'copie_mem'.
// Cette fonction est plus ici pour avoir une symétrie avec la bibliothèque C
// qu'autre chose.
bouge_mem :: fonc(source : []octet, destination : []octet, taille : z64) -> rien #nulctx
{
	copie_mem(source, destination, taille)
}

// À FAIRE : considération pour la surposition de blocs.
echange_mem :: fonc(a : []octet, b : []octet) -> rien #nulctx
{
	tmp : [128]octet

	taille := a.taille

    si a.taille > b.taille {
	   taille = b.taille
	}

	debut := 0

    tantque debut < taille {
		source := @a[debut]
		destination := @tmp[0]

		taille_tmp := taille - debut

        si taille_tmp > 128 {
		    taille_tmp = 128
		}

		copie_mem_nonsur(src=source, dst=destination, taille=taille_tmp)

		source = @b[debut]
		destination = @a[debut]

		copie_mem_nonsur(src=source, dst=destination, taille=taille_tmp)

		source = @tmp[0]
		destination = @b[debut]

		copie_mem_nonsur(src=source, dst=destination, taille=taille_tmp)

		debut += 128
	}
}

init_mem :: fonc(destination : []octet, valeur : z8, taille : z64) -> rien #nulctx
{
	t := taille
	si destination.taille < taille {
		t = destination.taille
	}

    pour o, idx dans destination {
		o = transtype(valeur : octet)
	}
}

cherche_mem :: fonc(source : []octet, valeur : z8, taille : z64) -> []octet #nulctx
{
	t := taille
	si source.taille < taille {
		t = source.taille
	}

	ret : []octet
	ret.pointeur = nul
	ret.taille = 0

    pour i dans 0...t - 1 {
	    si source[i] == transtype(valeur : octet) {
			ret.pointeur = @source[i]
			ret.taille = t - i
			arrête
		}
	}

	retourne ret
}
