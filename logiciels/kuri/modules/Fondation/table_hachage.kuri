//###############################################################################
// Implémentation d'une table de hachage chaine -> chaine
// Voir aussi, comme inspiration :
// https://en.wikipedia.org/wiki/Open_addressing

charge "chaine"
charge "impression"

NoeudTableHachage :: struct {
    clé : chaine
    valeur : chaine
    suivant : *NoeudTableHachage
}

TableHachage :: struct {
    alvéoles : []*NoeudTableHachage
}

crée_table_hachage :: fonc() -> *TableHachage
{
    dyn table := loge TableHachage
    table.alvéoles = loge [10000]*NoeudTableHachage

    pour i dans 0 ... 9999 {
        table.alvéoles[i] = nul
    }

    retourne table
}

décrée_table_hachage :: fonc(table : *TableHachage) -> rien
{
    pour noeud dans table.alvéoles {
        dyn n := noeud;

        tantque n != nul {
            dyn ns := n.suivant
            déloge n
            n = ns
        }
    }

    déloge table.alvéoles
    déloge table
}

crée_noeud :: fonc(clé : chaine, valeur : chaine) -> *NoeudTableHachage
{
    dyn n := loge NoeudTableHachage
    n.clé = clé
    n.valeur = valeur
    n.suivant = nul
    retourne n
}

calcule_empreinte :: fonc(chn : chaine) -> n64
{
    dyn empreinte : n64 = 5381

    pour c dans chn {
        empreinte = ((empreinte << 5) + empreinte) + transtype(c : n64)
    }

	retourne empreinte
}

insère :: fonc(dyn table : *TableHachage, clé : chaine, valeur : chaine) -> rien
{
    empreinte := calcule_empreinte(clé) % 10000

    dyn alvéole := table.alvéoles[empreinte]

    si alvéole == nul {
        table.alvéoles[empreinte] = crée_noeud(clé, valeur)
        retourne
    }

    boucle {
        si alvéole.suivant == nul {
            alvéole.suivant = crée_noeud(clé, valeur)
            arrête
        }

        alvéole = alvéole.suivant
    }
}

trouve :: fonc(table : *TableHachage, clé : chaine) -> *NoeudTableHachage
{
    empreinte := calcule_empreinte(clé) % 10000

    dyn alvéole := table.alvéoles[empreinte]

    si alvéole == nul {
        retourne nul
    }

    boucle {
        si alvéole.clé == clé {
            retourne alvéole
        }

        si alvéole.suivant == nul {
            arrête
        }

        alvéole = alvéole.suivant
    }

    retourne nul
}

cherche_noeud :: fonc(table : *TableHachage, clé : chaine) -> *NoeudTableHachage
{
    retourne trouve(table, clé)
}

chaque_noeud :: corout(table : *TableHachage) -> *NoeudTableHachage
{
    pour alvéole dans table.alvéoles {
        dyn n := alvéole

        tantque n != nul {
            retiens n
            n = n.suivant
        }
    }
}
