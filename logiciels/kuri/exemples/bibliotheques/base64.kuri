importe Fondation

est_base64_url :: fonc(c : z8) -> bool
{
    retourne ('A' <= c <= 'Z') || ('a' <= c <= 'z') || ('0' <= c <= '9') || (c == '-') || (c == '_')
}

est_base64 :: fonc(c : z8) -> bool
{
    retourne ('A' <= c <= 'Z') || ('a' <= c <= 'z') || ('0' <= c <= '9') || (c == '+') || (c == '/')
}

//#######################################

encode_impl :: fonc(chn : chaine, table : chaine) -> chaine
{
	i := 0
	char_array_3 : [3]n8
	char_array_4 : [4]n8

    enchaineuse : Enchaineuse
	intialise_enchaineuse(@enchaineuse)
    diffère { détruit_tampons(@enchaineuse) }

    longueur := chn.taille

    pour c dans chn {
		char_array_3[i] = c comme n8

        i += 1

		si i == 3 {
			char_array_4[0] = (char_array_3[0] & 0xfc) >> 2 comme n8
			char_array_4[1] = ((char_array_3[0] & 0x03) << 4) | ((char_array_3[1] & 0xf0) >> 4) comme n8
			char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) | ((char_array_3[2] & 0xc0) >> 6) comme n8
			char_array_4[3] = char_array_3[2] & 0x3f comme n8

            pour j dans 0 ... 3 {
                ajoute_au_tampon(@enchaineuse, table[char_array_4[j]])
            }

			i = 0
		}
	}

	si i != 0 {
        pour j dans i ... 2 {
			char_array_3[j] = '\0' comme n8
        }

		char_array_4[0] = (char_array_3[0] & 0xfc) >> 2
		char_array_4[1] = ((char_array_3[0] & 0x03) << 4) | ((char_array_3[1] & 0xf0) >> 4) comme n8
		char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) | ((char_array_3[2] & 0xc0) >> 6) comme n8
		char_array_4[3] = char_array_3[2] & 0x3f

        pour j dans 0 ... i {
            ajoute_au_tampon(@enchaineuse, table[char_array_4[j]])
        }

        tantque i < 3 {
            ajoute_au_tampon(@enchaineuse, '=')
            i += 1
        }
	}

	retourne chaine_depuis_enchaineuse(@enchaineuse)
}

encode :: fonc(chn: chaine) -> chaine
{
    table := "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
	retourne encode_impl(chn, table)
}

encode_pour_url :: fonc(chn: chaine) -> chaine
{
    table := "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
	retourne encode_impl(chn, table)
}

//#######################################

décode_impl :: fonc(chn : chaine, table : chaine, rappel_est_base64: fonc(z8)(bool)) -> chaine
{
	i := 0
	char_array_3 : [3]n8
	char_array_4 : [4]n8
    longueur := chn.taille
    enchaineuse : Enchaineuse
	intialise_enchaineuse(@enchaineuse)
    diffère { détruit_tampons(@enchaineuse) }

    pour c dans chn {
        si c == '=' || !rappel_est_base64(c) {
            arrête
        }

        char_array_4[i] = c comme n8
        i += 1

        si i == 4 {
            pour j dans 0 ... 3 {
				char_array_4[j] = table.trouve_caractère(transtype(char_array_4[j] comme z8, 0): n8)
            }

			char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4) comme n8
			char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2) comme n8
			char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3] comme n8

            pour j dans 0 ... 2 {
                ajoute_au_tampon(@enchaineuse, char_array_3[j] comme z8)
            }

            i = 0
        }
    }

	si i != 0 {
		pour j dans i ... 3 {
			char_array_4[j] = '\0' comme n8
		}

        pour j dans i ... 3 {
            char_array_4[j] = table[char_array_4[j]] comme n8
        }

		char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4) comme n8
		char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2) comme n8
		char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3] comme n8

        pour j dans 0 ... i {
			ajoute_au_tampon(@enchaineuse, table.trouve_caractère(transtype(char_array_3[j] comme z8, 0): z8))
        }
	}

	retourne chaine_depuis_enchaineuse(@enchaineuse)
}

décode :: fonc(chn: chaine) -> chaine
{
    table := "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
	retourne décode_impl(chn, table, est_base64)
}

décode_pour_url :: fonc(chn: chaine) -> chaine
{
    table := "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
	retourne décode_impl(chn, table, est_base64_url)
}

//#######################################

principale :: fonc () -> z32
{
    diffère { imprime("mémoire utilisée : %o\n", mémoire_utilisée()) }

    chn := "Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure."

    attendu := "TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4="

    rés := encode(chn)

    imprime("Chaine encodée : ", rés, "\n")

    si rés != attendu {
        imprime("Le résultat n'est pas le bon")
    }

    déc := décode(rés)

    imprime("Chaine décodée : ", déc, "\n")

    déloge rés
    déloge déc

    retourne 0
}
