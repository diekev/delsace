importe Fondation
importe Image
importe Math

// tentative de l'implémentation en Kuri de https://github.com/woltapp/blurhash/tree/master/C

PI :: 3.14159265358979323846

ErreurHachage :: erreur {
    NombreDeComposantXTropPetit
    NombreDeComposantXTropGrand
    NombreDeComposantYTropPetit
    NombreDeComposantYTropGrand
}

RésultatHachage :: union {
    e: ErreurHachage
    c: chaine
}

blurHashForPixels :: fonc (
    composants_x: z32,
    composants_y: z32,
    image: *Image) -> RésultatHachage
{
    si composants_x < 1 {
        retourne ErreurHachage.NombreDeComposantXTropPetit
    }

    si composants_x > 9 {
        retourne ErreurHachage.NombreDeComposantXTropGrand
    }

    si composants_y < 1 {
        retourne ErreurHachage.NombreDeComposantYTropPetit
    }

    si composants_y > 9 {
        retourne ErreurHachage.NombreDeComposantYTropGrand
    }

    buffer : [2 + 4 + (9 * 9 - 1) * 2 + 1]z8

    factors : [9][9][3]r32

    pour y dans 0 ... composants_y - 1 {
        pour x dans 0 ... composants_x - 1 {
            factor := multiplyBasisFunction(x, y, image)
			factors[y][x][0] = factor[0]
			factors[y][x][1] = factor[1]
			factors[y][x][2] = factor[2]
        }
    }

	dc := @factors[0][0][0]
    ac := dc + 3
	acCount := composants_x * composants_y - 1

	sizeFlag := (composants_x - 1) + (composants_y - 1) * 9
	ptr := encode_int(sizeFlag, 1, @buffer[0])

	maximumValue : r32

	si acCount > 0 {
		actualMaximumValue := 0.0

        pour i dans 0 ... acCount * 3 - 1 {
            actualMaximumValue = max(abs(ac[i]), actualMaximumValue)
        }

		quantisedMaximumValue := max(0, min(82, transtype(sol(actualMaximumValue * 166.0 - 0.5): z32)))
		maximumValue = transtype((quantisedMaximumValue + 1): r32) / 166.0
		ptr = encode_int(quantisedMaximumValue, 1, ptr)
	}
    sinon {
		maximumValue = 1.0
		ptr = encode_int(0, 1, ptr)
	}

	ptr = encode_int(encodeDC(dc[0], dc[1], dc[2]), 4, ptr)

    pour i dans 0 ... acCount - 1 {
		ptr = encode_int(encodeAC(ac[i * 3 + 0], ac[i * 3 + 1], ac[i * 3 + 2], maximumValue), 2, ptr)
    }

	mémoire(ptr) = 0

    taille_chaine := transtype(ptr - @buffer[0]: z64)

    chn := construit_chaine(@buffer[0], taille_chaine)

    imprime("Résultat : %\n", chn)

	retourne ""
}

résultat_fonction_base : [3]r32

multiplyBasisFunction :: fonc (
    composant_x: z32,
    composant_y: z32,
    image: *Image) -> *r32
{
    r := 0.0
    g := 0.0
    b := 0.0

    normalisation := 1.0

    si (composant_x != 0 || composant_y != 0) {
        normalisation = 2.0
    }

    pour y dans 0 ... image.hauteur - 1 {
        pour x dans 0 ... image.largeur - 1 {
            fraction_largeur := transtype(x: r32) / transtype(image.largeur: r32)
            fraction_hauteur := transtype(y: r32) / transtype(image.hauteur: r32)

            cos_composant_x := cosinus(PI * transtype(composant_x: r32) * fraction_largeur)
            cos_composant_y := cosinus(PI * transtype(composant_y: r32) * fraction_hauteur)

            base := cos_composant_x * cos_composant_y

            pixel := image.tampon[x + y * image.largeur]

            r += base * sRGBToLinear(pixel.r)
            g += base * sRGBToLinear(pixel.v)
            b += base * sRGBToLinear(pixel.b)
        }
    }

	scale := normalisation / transtype(image.largeur * image.hauteur: r32)

	résultat_fonction_base[0] = r * scale
	résultat_fonction_base[1] = g * scale
	résultat_fonction_base[2] = b * scale

	retourne @résultat_fonction_base[0]
}

linearTosRGB :: fonc (value: r32) -> z32
{
	v := max(0.0, min(1.0, value))

    si v <= 0.0031308 {
        retourne transtype(v * 12.92 * 255.0 + 0.5: z32)
    }

    retourne transtype((1.055 * puissance(v, 1.0 / 2.4) - 0.055) * 255.0 + 0.5: z32)
}

sRGBToLinear :: fonc (value: z32) -> r32
{
    v := transtype(value: r32) / 255.0
    retourne sRGBToLinear(v)
}

sRGBToLinear :: fonc (value: r32) -> r32
{
    si value <= 0.04045 {
        retourne value / 12.92
    }

    retourne puissance((value + 0.055) / 1.055, 2.4)
}

encodeDC :: fonc (r: r32, g: r32, b: r32) -> z32
{
	roundedR := linearTosRGB(r)
	roundedG := linearTosRGB(g)
	roundedB := linearTosRGB(b)
	retourne (roundedR << 16) + (roundedG << 8) + roundedB
}

encodeAC :: fonc (r: r32, g: r32, b: r32, maximumValue: r32) -> z32
{
	quantR := transtype(max(0.0, min(18.0, floor(signPow(r / maximumValue, 0.5) * 9.0 + 9.5))): z32)
	quantG := transtype(max(0.0, min(18.0, floor(signPow(g / maximumValue, 0.5) * 9.0 + 9.5))): z32)
	quantB := transtype(max(0.0, min(18.0, floor(signPow(b / maximumValue, 0.5) * 9.0 + 9.5))): z32)

	retourne quantR * 19 * 19 + quantG * 19 + quantB
}

signPow :: fonc (value: r32, exp: r32) -> r32
{
	retourne copie_signe(puissance(abs(value), exp), value)
}

encode_int :: fonc (value: z32, length: z32, destination: *z8) -> *z8
{
    characters := "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz#$%*+,-.:;=?@[]^_{|}~"

	divisor := 1

    pour i dans 0 ... length - 1 {
        divisor *= 83
    }

    pour i dans 0 ... length - 1 {
        digit := (value / divisor) % 83
        divisor /= 83

        mémoire(destination) = characters[digit]
        destination += 1
    }

	retourne destination
}

principale :: fonc () -> z32
{
    diffère { imprime("Fin du programme, mémoire utilisée : %o\n", mémoire_utilisée()) }

    image := charge_image_png("pic1.png")
    diffère { détruit_image(image); déloge image; }

    hachis := tente blurHashForPixels(4, 3, image) piège err {
        imprime("Erreur lors du calcul du hachis : %\n", err)
        retourne 1
    }

    retourne 0
}
