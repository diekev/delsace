importe Fondation

/*
    https://en.wikipedia.org/wiki/ISO_4217
    https://www.baeldung.com/java-money-and-currency
    https://www.drdobbs.com/jvm/java-monetary-data/184405653
    http://download.oracle.com/javase/6/docs/api/java/util/Currency.html
    http://www.joda.org/joda-money/
    https://www.codeflow.site/fr/article/java-money-and-currency
    https://www.hildeberto.com/2020/04/dealing-with-money.html

    https://stackoverflow.com/questions/1679292/proof-that-fowlers-money-allocation-algorithm-is-correct

    https://stackoverflow.com/questions/224462/storing-money-in-a-decimal-column-what-precision-and-scale

    banker's rounding

    eu directive accounting rules

    https://www.economie.gouv.fr/dgfip/arrondis

    Devise (EUR, USD)
    Montant (15.44)

    savoir si la devise possède des fractions (pas le won ou le yen)

    ajoute, multiplie, divise, fraction

    utilisation d'un type entier, savoir où mettre les fractions ($N : z32 => nombre de chiffres après la virgule)

    parse depuis une chaine, un nombre entier, un nombre réel
*/

ValeurMonnétaire :: struct {
    quantité : z64 = 0
}

valeur_monétaire_depuis_centimes :: fonc (centimes: z64) -> ValeurMonnétaire
{
    retourne ValeurMonnétaire( quantité = centimes * 100 )
}

valeur_monétaire_depuis_unités :: fonc (unités: z64) -> ValeurMonnétaire
{
    retourne ValeurMonnétaire( quantité = unités * 10000 )
}

valeur_monétaire_depuis_unités_centimes :: fonc (unités: z64, centimes: z64) -> ValeurMonnétaire
{
    retourne ValeurMonnétaire( quantité = unités * 10000 + centimes * 100 )
}

opérateur + :: fonc (v1 : ValeurMonnétaire, v2 : ValeurMonnétaire) -> ValeurMonnétaire
{
    résultat : ValeurMonnétaire
    résultat.quantité = v1.quantité + v2.quantité
    retourne résultat
}

opérateur - :: fonc (v1 : ValeurMonnétaire, v2 : ValeurMonnétaire) -> ValeurMonnétaire
{
    résultat : ValeurMonnétaire
    résultat.quantité = v1.quantité - v2.quantité
    retourne résultat
}

opérateur * :: fonc (v1 : ValeurMonnétaire, v2 : z64) -> ValeurMonnétaire
{
    résultat : ValeurMonnétaire
    résultat.quantité = v1.quantité * v2
    retourne résultat
}

opérateur / :: fonc (v1 : ValeurMonnétaire, v2 : z64) -> ValeurMonnétaire
{
    résultat : ValeurMonnétaire
    résultat.quantité = v1.quantité / v2
    retourne résultat
}

opérateur > :: fonc (v1 : ValeurMonnétaire, v2 : ValeurMonnétaire) -> bool
{
    retourne v1.quantité > v2.quantité
}

opérateur < :: fonc (v1 : ValeurMonnétaire, v2 : ValeurMonnétaire) -> bool
{
    retourne v1.quantité < v2.quantité
}

opérateur == :: fonc (v1 : ValeurMonnétaire, v2 : ValeurMonnétaire) -> bool
{
    retourne v1.quantité == v2.quantité
}

opérateur != :: fonc (v1 : ValeurMonnétaire, v2 : ValeurMonnétaire) -> bool
{
    retourne v1.quantité != v2.quantité
}

opérateur >= :: fonc (v1 : ValeurMonnétaire, v2 : ValeurMonnétaire) -> bool
{
    retourne v1.quantité >= v2.quantité
}

opérateur <= :: fonc (v1 : ValeurMonnétaire, v2 : ValeurMonnétaire) -> bool
{
    retourne v1.quantité <= v2.quantité
}

// Algorithme d'allocation d'une somme d'argent selon des ratios.
// Le but de l'allocation est de distribution équitablement l'argent, en
// prenant en compte les problèmes liés à l'indivisibilité d'une somme
// (p.e. 1 centime ne peut être divisé), ou de perte d'argent due à des arrondis.
// À FAIRE : l'algorithme ne prend pas en compte les sommes dont les unités
// (p.e. 1 €) sont indivisibles. Ceci distribuera l'argent jusqu'au dix
// millième d'unités.
alloue :: fonc (v: ValeurMonnétaire, ratios: []z32) -> []ValeurMonnétaire
{
    total := 0

    pour r dans ratios {
        total += r
    }

    reste := v.quantité
    résultat := loge_tableau(ValeurMonnétaire, ratios.taille)

    pour r, i dans résultat {
        r.quantité = v.quantité * ratios[i] / total
        reste -= r.quantité
    }

    pour i dans 0 ... reste - 1 {
        résultat[i].quantité += 1
    }

    retourne résultat
}

imprime_valeur_monétaire :: fonc (v: ValeurMonnétaire) -> rien
{
    unités := v.quantité / 10000
    centimes := (v.quantité % 10000) / 100

    imprime("valeur = %,%\n",
        FormatEntier(valeur = unités, séparation = 3),
        FormatEntier(valeur = centimes, ajoute_zéros_début = centimes < 10, nombre_zéros = 1))
}

rand :: fonc () -> z32 #externe

nombre_aléatoire :: fonc () -> z32
{
    retourne rand() % 10
}

principale :: fonc () -> z32
{
    {
        v := valeur_monétaire_depuis_unités(100)

        imprime_valeur_monétaire(v)

        ratios := [1, 1, 1]

        allocations := alloue(v, ratios)

        pour allocation dans allocations {
            imprime_valeur_monétaire(allocation)
        }

        déloge(allocations)
    }

    // calcul d'une TVA pour l'abonnement
    abonnement := valeur_monétaire_depuis_unités_centimes(4, 90)
    imprime_valeur_monétaire(abonnement)

    tva := abonnement * 20 / 100
    imprime_valeur_monétaire(tva)

    valeur_final := abonnement + tva
    imprime_valeur_monétaire(valeur_final)

    part := abonnement / 2

    abonnements_totaux := 10_000_000
    somme_total := abonnement * abonnements_totaux * 12
    somme_redistribuée := somme_total / 2

    imprime_valeur_monétaire(somme_total)
    imprime_valeur_monétaire(somme_redistribuée)

    nombre_associations := 1234
    ratios := loge_tableau(z32, nombre_associations)

    pour & r dans ratios {
        r = nombre_aléatoire()
    }

    allocations := alloue(somme_redistribuée, ratios)

    somme_allouée : z64

    pour allocation, idx dans allocations {
        si idx < 10 {
            imprime_valeur_monétaire(allocation)
        }

        somme_allouée += allocation.quantité / 100 * 100
    }

    déloge(ratios)
    déloge(allocations)

    imprime("reste après allocation, ")
    imprime_valeur_monétaire(ValeurMonnétaire( quantité = somme_redistribuée.quantité - somme_allouée ))

    retourne 0
}
