rout crée_manipulable(valeur : eini) : &Manipulable
{
	si id de info de valeur != id_type.STRUCTURE {
		retourne nul;
	}

	soit info = transtype(info de valeur : &InfoTypeStructure);

	dyn manipulable = loge Manipulable sinon {
		# À FAIRE : erreur
		retourne nul;
	}

	pour membre dans membres de info {
		dyn tprop : type_prop;

		discr id de info de membre {
			id_type.ENTIER    : { tprop = type_prop.ENTIER; }
			id_type.RÉEL      : { tprop = type_prop.RÉEL; }
			id_type.STRUCTURE : { tprop = type_prop.NUL; }
			id_type.CHAÎNE    : { tprop = type_prop.CHAÎNE; }
		}

		manipulable.ajoute_propriete(nom de membre, tprop);
	}

	retourne manipulable;
}

rout ajourne_valeur(
	objet : &dyn eini,
	nom_prop : &chaine,
	valeur : eini) : rien
{
	garde id de info de objet == TYPE_STRUCTURE sinon {
		# À FAIRE : erreur
		retourne;
	}

	soit info = transtype(info de objet : &TypeInfoStructure);

	iter membre dans membres de info {
		si nom de membre == nom_prop {
			arrête;
		}
	}
	sansarrêt {
		# À FAIRE : erreur
		retourne;
	}
	sinon {
		# Trouve le type de membre
		si id de info de membre != id de info de valeur {
			# À FAIRE : erreur
			retourne
		}

		# Trouve le décalage
		soit décalage = décalage de info de membre;

		# Écris la valeur
		nonsûr {
			soit ptr_début = pointeur de eini;
			soit ptr_valeur = ptr_début + décalage

			mémoire(ptr_valeur) = mémoire(pointeur de eini);
		}
	}
}

struct Vecteur3D {
	x : z32 = 5;
	y : z32 = 6;
	z : z32 = 7;
}

rout invoque(methode : eini, args : ...eini) : eini
{
	soit fonc_ptr = pointeur de eini;

	# il faudrait émuler la manière dont les fonctions sont appelées
	# sur chaque plateforme...

	fonct_ptr(args...);
}

rout test_introspection() : rien
{
	dyn vec : Vecteur3D;

	imprime_structure(vec);

	ajourne_valeur(vec, "x", 1);
	ajourne_valeur(vec, "y", 2);
	ajourne_valeur(vec, "z", 3);

	imprime_structure(vec);

	ajourne_valeur(vec, "x", 10);
	ajourne_valeur(vec, "y", 200);
	ajourne_valeur(vec, "z", 3000);

	imprime_structure(vec);

	retourne;
}

rout loge_concat(args... : []z32) : []z32
{
	dyn taille : n64 = 0;

	iter arg dans args {
		taille = taille + taille de tabl;
	}

	soit res = loge [taille]z32 sinon {
		erreur;
	}

	retourne res;
}
