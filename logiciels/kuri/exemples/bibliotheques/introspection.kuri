rout crée_manipulable(valeur : eini) -> &Manipulable
{
	si valeur.info.id != id_type.STRUCTURE {
		retourne nul;
	}

	info := valeur.info comme &InfoTypeStructure;

	manipulable := loge Manipulable sinon {
		// À FAIRE : erreur
		retourne nul;
	}

	pour membre dans info.membres {
		tprop : type_prop;

		discr membre.info.id {
			id_type.ENTIER    : { tprop = type_prop.ENTIER; }
			id_type.RÉEL      : { tprop = type_prop.RÉEL; }
			id_type.STRUCTURE : { tprop = type_prop.NUL; }
			id_type.CHAÎNE    : { tprop = type_prop.CHAÎNE; }
		}

		manipulable.ajoute_propriete(membre.nom, tprop);
	}

	retourne manipulable;
}

rout ajourne_valeur(
	objet : &eini,
	nom_prop : &chaine,
	valeur : eini) -> rien
{
	garde objet.info.id == TYPE_STRUCTURE sinon {
		// À FAIRE : erreur
		retourne;
	}

	info := objet.info comme &TypeInfoStructure;

	iter membre dans info.membres {
		si membre.nom == nom_prop {
			arrête;
		}
	}
	sansarrêt {
		// À FAIRE : erreur
		retourne;
	}
	sinon {
		// Trouve le type de membre
		si membre.info.id != valeur.info.id {
			// À FAIRE : erreur
			retourne
		}

		// Trouve le décalage
		décalage := membre.info.décalage;

		// Écris la valeur
		nonsûr {
			ptr_début := valeur.pointeur;
			ptr_valeur := ptr_début + décalage

			mémoire(ptr_valeur) = mémoire(ptr_début);
		}
	}
}

Vecteur3D :: struct {
	x : z32 = 5;
	y : z32 = 6;
	z : z32 = 7;
}

rout invoque(methode : eini, args : ...eini) -> eini
{
	fonc_ptr := methode.pointeur;

	// il faudrait émuler la manière dont les fonctions sont appelées
	// sur chaque plateforme...

	fonct_ptr(args...);
}

rout test_introspection() -> rien
{
	vec : Vecteur3D;

	imprime_structure(vec);

	ajourne_valeur(vec, "x", 1);
	ajourne_valeur(vec, "y", 2);
	ajourne_valeur(vec, "z", 3);

	imprime_structure(vec);

	ajourne_valeur(vec, "x", 10);
	ajourne_valeur(vec, "y", 200);
	ajourne_valeur(vec, "z", 3000);

	imprime_structure(vec);

	retourne;
}

rout loge_concat(args... : []z32) -> []z32
{
	taille : n64 = 0;

	iter arg dans args {
		taille = taille + tabl.taille;
	}

	res := loge [taille]z32 sinon {
		erreur_;
	}

	retourne res;
}
