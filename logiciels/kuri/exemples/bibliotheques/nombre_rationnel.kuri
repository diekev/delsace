// Nombre fractionnel nous permettant de faire des calculs sur des
// fractions, afin d'être plus précis que des nombres à point flottant.
// https://iquilezles.org/www/articles/floatingbar/floatingbar.htm

printf :: fonc externe (fmt: *z8, args: ...) -> z32

NombreRationnel :: struct {
    N: n32
    D: n32
    s: bool
}

construit_nombre_rationnel :: fonc(n: n32, d: n32, positif: bool) -> NombreRationnel
{
    dyn r : NombreRationnel
    r.N = n
    r.D = d
    r.s = !positif

    retourne r
}

ajoute :: fonc(a: NombreRationnel, b: NombreRationnel) -> NombreRationnel
{
    // augmente la taille des types pour éviter les problèmes de surflot
    a_n := transtype(a.N: n64)
    a_d := transtype(a.D: n64)
    b_n := transtype(b.N: n64)
    b_d := transtype(b.D: n64)

    dyn r_N : n64
    r_N0 := a_n * b_d
    r_N1 := a_d * b_n

    dyn r : NombreRationnel

    si transtype(a.s: z8) == transtype(b.s: z8) {
        r_N = r_N0 + r_N1
        r.s = a.s
    }
    sinon si r_N0 <= r_N1 {
        r_N = r_N1 - r_N0
        r.s = vrai
    }
    sinon {
        r_N = r_N0 - r_N1
        r.s = vrai
    }

    dyn r_D : n64 = a_d * b_d

    // réduit la fraction selon le plus grand dénominateur commun,
    // afin d'éviter des problèmes de surflot
    dc := pgdc(r_N, r_D)

    r_N = r_N / dc
    r_D = r_D / dc

    // normalise en décalant les valeurs selon le nombre de bits 0 en fin de mot
    nb_N = nombre_de_bits_zéro_en_fin(r_N)
    nb_D = nombre_de_bits_zéro_en_fin(r_D)

    si nb_N != 0 && nb_D != 0 {
        si nb_N < nb_D {
            r_N = r_N >> nb_N
            r_D = r_D >> nb_N
        }
        sinon {
            r_N = r_N >> nb_D
            r_D = r_D >> nb_D
        }
    }

    // restaure la précision
    r.N = transtype(r_N: n32)
    r.D = transtype(r_D: n32)

    retourne r
}

soustrait :: fonc(a: NombreRationnel, b: NombreRationnel) -> NombreRationnel
{
    dyn tmp := b
    tmp.s = vrai

    retourne ajoute(a, tmp)
}

multiplie :: fonc(a: NombreRationnel, b: NombreRationnel) -> NombreRationnel
{
    // augmente la taille des types pour éviter les problèmes de surflot
    a_n := transtype(a.N: n64)
    a_d := transtype(a.D: n64)
    b_n := transtype(b.N: n64)
    b_d := transtype(b.D: n64)

    dyn r_N := a_n * b_n
    dyn r_D := a_d * b_d

    // réduit la fraction selon le plus grand dénominateur commun,
    // afin d'éviter des problèmes de surflot
    dc := pgdc(r_N, r_D)

    r_N := r_N / dc
    r_D := r_D / dc

    // normalise en décalant les valeurs selon le nombre de bits 0 en fin de mot
    nb_N := nombre_de_bits_zéro_en_fin(r_N)
    nb_D := nombre_de_bits_zéro_en_fin(r_D)

    si nb_N != 0 && nb_D != 0 {
        si nb_N < nb_D {
            r_N = r_N >> nb_N
            r_D = r_D >> nb_N
        }
        sinon {
            r_N = r_N >> nb_D
            r_D = r_D >> nb_D
        }
    }

    dyn r : NombreRationnel
    // restaure la précision
    r.N = transtype(r_N: n32)
    r.D = transtype(r_D: n32)
    r.s = (a.s || b.s) && !(a.s && b.s)

    retourne r
}

divise :: fonc(a: NombreRationnel, b: NombreRationnel) -> NombreRationnel
{
    dyn tmp := b
    tmp.N = b.D
    tmp.D = b.N

    retourne multiplie(a, tmp)
}

imprime_nombre_rationnel :: fonc(a: NombreRationnel) -> rien
{
    si a.s {
        printf("- %u / %u\n".pointeur, a.N, a.D)
    }
    sinon {
        printf("%u / %u\n".pointeur, a.N, a.D)
    }
}

// https://en.wikipedia.org/wiki/Binary_GCD_algorithm
pgdc_récursif :: fonc(u: n64, v: n64) -> n64
{
    // cas simples (terminaison)
    si u == v {
        retourne u
    }

    si u == 0 {
        retourne v
    }

    si v == 0 {
        retourne u
    }

    // cherche des facteurs de 2
    si (~u & 1) != 0 { // u est pair
        si (v & 1) != 0 { // v est impair
            retourne pgdc_récursif(u >> 1, v)
        }

        retourne pgdc_récursif(u >> 1, v >> 1) << 1
    }

    si (~v & 1) != 0 { // u est impair, v est pair
        retourne pgdc_récursif(u, v >> 1)
    }

    // réduis l'argument le plus grand
    si (u > v) {
        retourne pgdc_récursif((u - v) >> 1, v)
    }

    retourne pgdc_récursif((v - u) >> 1, u)
}

pgdc :: fonc(dyn u: n64, dyn v: n64) -> n64
{
    si u == v {
        retourne u
    }

    // GCD(0,v) == v GCD(u,0) == u, GCD(0,0) == 0
    si u == 0 {
        retourne v
    }

    si v == 0 {
        retourne u
    }

    dyn shift : n64 = transtype(0: n64)

    //Let shift := lg K, where K is the greatest power of 2
    // dividing both u and v.
    tantque (((u | v) & 1) == 0) {
        shift = shift + 1
        u = u >> 1
        v = v >> 1
    }

    tantque ((u & 1) == 0) {
        u = u >> 1
    }

    // From here on, u is always odd. */
    répète {
        // remove all factors of 2 in v -- they are not common */
        //   note: v is not zero, so while will terminate */
        tantque ((v & 1) == 0) {
            v = v >> 1
        }

        // Now u and v are both odd. Swap if necessary so u <= v,
        //    then set v = v - u (which is even). For bignums, the
        //     swapping is just pointer movement, and the subtraction
        //      can be done in-place. */
        si u > v {
            t = v
            v = u
            u = t
        }

        v = v - u // Here v >= u.
    } tantque (v != 0)

    // restore common factors of 2 */
    retourne u << shift
}

nombre_de_bits_zéro_en_fin :: fonc(dyn i: n64) -> n32
{
    si i == 0 {
        retourne transtype(64: n32)
    }

    dyn n := 63
    dyn y : n64

    y = i << 32; si y != 0 { n = n - 32; i = y; }
    y = i << 16; si y != 0 { n = n - 16; i = y; }
    y = i <<  8; si y != 0 { n = n -  8; i = y; }
    y = i <<  4; si y != 0 { n = n -  4; i = y; }
    y = i <<  2; si y != 0 { n = n -  2; i = y; }

	retourne transtype(n - ((i << 1) >> 63): n32)
}

principale :: fonc(args : []*z8) -> z32
{
    a := construit_nombre_rationnel(transtype(765: n32), transtype(455: n32), faux)
    b := construit_nombre_rationnel(transtype(455: n32), transtype(35: n32), vrai)

    imprime_nombre_rationnel(a)
    imprime_nombre_rationnel(b)

    c := multiplie(a, b)

    imprime_nombre_rationnel(c)

    retourne 0
}
