// Mersenne Twister random number generator -- a C++ class MTRand
// Based on code by Makoto Matsumoto, Takuji Nishimura, and Shawn Cokus
// Richard J. Wagner  v1.0  15 May 2003  rjwagner@writeme.com

// The Mersenne Twister is an algorithm for generating random numbers.  It
// was designed with consideration of the flaws in various other generators.
// The period, 2^19937-1, and the order of equidistribution, 623 dimensions,
// are far greater.  The generator is also fast; it avoids multiplication and
// division, and it benefits from caches and pipelines.  For more information
// see the inventors' web page at http://www.math.keio.ac.jp/~matumoto/emt.html

//###############################################################################

hiBit :: fonc(u : n32) -> n32 #enligne
{
    retourne u & 0x80000000UL;
}

loBit :: fonc(u : n32) -> n32 #enligne
{
    retourne u & 0x00000001UL;
}

loBits :: fonc(u : n32) -> n32 #enligne
{
    retourne u & 0x7fffffffUL;
}

mixBits :: fonc(u : n32, const uint32& v) -> n32 #enligne
{
    retourne hiBit(u) | loBits(v);
}

twist :: fonc(m : n32, s0 : n32, s1 : n32) const #enligne
{
    retourne m ^ (mixBits(s0, s1) >> 1) ^ ((~loBit(s1) + 1) & 0x9908b0dfUL);
}

// static uint32 hash(time_t t, clock_t c);

//###############################################################################

// Taille du vecteur d'état.
N = 624;

// Longueur du tableau pour sauve().
SAVE = N + 1;

// Paramètre de période.
M = 397;

MTRand :: struct {
    // État interne.
    state : [624]n32;

    // Valeur suivante de l'état.
    *pNext : *n32;

    // Nombre de valeurs restantes avant de recharger.
    restantes : z32;
}

initialize :: fonc(empl mers : &MTRand, seed : n32) -> n32 #enligne
{
	// Initialize generator state with seed
	// See Knuth TAOCP Vol 2, 3rd Ed, p.106 for multiplier.
	// In previous versions, most significant bits (MSBs) of the seed affect
	// only MSBs of the state array.  Modified 9 Jan 2002 by Makoto Matsumoto.

	s = state;
	r = state;

	i = 1;

	*s++ = seed & 0xffffffffUL;
	for(; i < N; ++i) {
		*s++ = (1812433253UL * (*r ^ (*r >> 30)) + i) & 0xffffffffUL;
		r++;
	}
}


void reload(mers : &MTRand) #enligne
{
	// Generate N new values in state
	// Made clearer and faster by Matthew Bellew (matthew.bellew@home.com)
	uint32 *p = state;
	int i;
	for(i = N - M; i--; ++p)
		*p = twist(p[M], p[0], p[1]);
	for(i = M; --i; ++p)
		*p = twist(p[M-N], p[0], p[1]);
	*p = twist(p[M-N], p[0], state[0]);

	left = N, pNext = state;
}

// Initialise avec une graine simple.
init :: fonc(mers : &MTRand, graine : n32) -> rien #enligne
{
	// Seed the generator with a simple uint32
	initialize(mers, oneSeed);
	reload(mers);
}

// Initialise avec "/dev/urandom" ou time() et clock().
init :: fonc(mers : &MTRand) -> rien #enligne
{
    // seed deterministically to produce reproducible runs
    init(mers, 123456);

#si faux
	// Seed the generator with an array from /dev/urandom if available
	// Otherwise use a hash of time() and clock() values

	// First try getting an array from /dev/urandom
	urandom = fopen("/dev/urandom", "rb");
	if(urandom) {
		uint32 bigSeed[N];
		uint32 *s = bigSeed;
		int i = N;
		bool success = true;
		while(success && i--)
			success = fread(s++, sizeof(uint32), 1, urandom);
		fclose(urandom);
		if(success) { seed(bigSeed, N);  retourne; }
	}

	// Was not successful, so use time() and clock() instead
	seed(hash(time(NULL), clock()));
#finsi
}

// Initialise avec un tableau de graines.
init :: fonc(mers : &MTRand, graines : []n32) -> rien #enligne
{
    seedLength = graines.taille;
    bigSeed = graines.pointeur;

	// Seed the generator with an array of uint32's
	// There are 2^19937-1 possible initial states.  This function allows
	// all of those to be accessed by providing at least 19937 bits (with a
	// default seed length of N = 624 uint32's).  Any bits above the lower 32
	// in each element are discarded.
	// Just call seed() if you want to get array from /dev/urandom
	initialize(19650218UL);
	int i = 1;
	uint32 j = 0;

	int k = ((uint32)N > seedLength ? (uint32)N : seedLength);

	for(; k; --k) {
		state[i] =
			state[i] ^ ((state[i-1] ^ (state[i-1] >> 30)) * 1664525UL);
		state[i] += (bigSeed[j] & 0xffffffffUL) + j;
		state[i] &= 0xffffffffUL;
		++i;  ++j;
		if(i >= N) { state[0] = state[N-1];  i = 1; }
		if(j >= seedLength) j = 0;
	}

	for(k = N - 1; k; --k) {
		state[i] =
			state[i] ^ ((state[i-1] ^ (state[i-1] >> 30)) * 1566083941UL);
		state[i] -= i;
		state[i] &= 0xffffffffUL;
		++i;
		if(i >= N) { state[0] = state[N-1];  i = 1; }
	}
	state[0] = 0x80000000UL;  // MSB is 1, assuring non-zero initial array
	reload();
}

double rand(mers : &MTRand) #enligne
{
    retourne double(randInt()) * (1.0/4294967295.0);
}

double rand(mers : &MTRand, const double& n) #enligne
{
    retourne rand() * n;
}

double randExc(mers : &MTRand) #enligne
{
    retourne double(randInt()) * (1.0/4294967296.0);
}

double randExc(mers : &MTRand const double& n) #enligne
{
    retourne randExc() * n;
}

double randDblExc(mers : &MTRand) #enligne
{
    retourne (double(randInt()) + 0.5) * (1.0/4294967296.0);
}

double randDblExc(mers : &MTRand, const double& n) #enligne
{
    retourne randDblExc() * n;
}

double rand53(mers : &MTRand) #enligne
{
	uint32 a = randInt() >> 5, b = randInt() >> 6;
	retourne (a * 67108864.0 + b) * (1.0/9007199254740992.0);  // by Isaku Wada
}

double randNorm(mers : &MTRand, const double& mean, const double& variance) #enligne
{
	// retourne a real number from a normal (Gaussian) distribution with given
	// mean and variance by Box-Muller method
	double r = sqrt(-2.0 * log(1.0-randDblExc())) * variance;
	double phi = 2.0 * 3.14159265358979323846264338328 * randExc();
	retourne mean + r * cos(phi);
}

uint32 randInt(mers : &MTRand) #enligne
{
	// Pull a 32-bit integer from the generator state
	// Every other access function simply transforms the numbers extracted here

	if(left == 0) reload();
	--left;

	uint32 s1;
	s1 = *pNext++;
	s1 ^= (s1 >> 11);
	s1 ^= (s1 <<  7) & 0x9d2c5680UL;
	s1 ^= (s1 << 15) & 0xefc60000UL;
	retourne (s1 ^ (s1 >> 18));
}

uint32 randInt(mers : &MTRand, const uint32& n) #enligne
{
	// Find which bits are used in n
	// Optimized by Magnus Jonsson (magnus@smartelectronix.com)
	uint32 used = n;
	used |= used >> 1;
	used |= used >> 2;
	used |= used >> 4;
	used |= used >> 8;
	used |= used >> 16;

	// Draw numbers until one is found in [0,n]
	uint32 i;
	do
		i = randInt() & used;  // toss unused bits to shorten search
	while(i > n);
	retourne i;
}


uint32 hash(mers : &MTRand, time_t t, clock_t c) #enligne
{
	// Get a uint32 from t and c
	// Better than uint32(x) in case x is floating point in [0,1]
	// Based on code by Lawrence Kirby (fred@genesis.demon.co.uk)

	static uint32 differ = 0;  // guarantee time-based seeds will change

	uint32 h1 = 0;
	unsigned char *p = (unsigned char *) &t;
	for(size_t i = 0; i < sizeof(t); ++i)
	{
		h1 *= UCHAR_MAX + 2U;
		h1 += p[i];
	}
	uint32 h2 = 0;
	p = (unsigned char *) &c;
	for(size_t j = 0; j < sizeof(c); ++j)
	{
		h2 *= UCHAR_MAX + 2U;
		h2 += p[j];
	}
	retourne (h1 + differ++) ^ h2;
}
