// Un ensemble de chaine

importe Fondation

opérateur > :: fonc (chn1: chaine, chn2: chaine) -> bool
{
    taille := chn1.taille

    si taille > chn2.taille {
        taille = chn2.taille
    }

    pour i dans 0 ... taille - 1 {
        si chn1[i] <= chn2[i] {
            retourne faux
        }
    }

    retourne vrai
}

opérateur < :: fonc (chn1: chaine, chn2: chaine) -> bool
{
    taille := chn1.taille

    si taille > chn2.taille {
        taille = chn2.taille
    }

    pour i dans 0 ... taille - 1 {
        si chn1[i] >= chn2[i] {
            retourne faux
        }
    }

    retourne vrai
}

/*
NoeudEnsemble :: struct {
    gauche : *NoeudEnsemble
    droite : *NoeudEnsemble

    chn: chaine
}

détruit_noeud :: fonc (noeud: *NoeudEnsemble) -> rien
{
    si noeud == nul {
        retourne
    }

    détruit_noeud(noeud.gauche)
    détruit_noeud(noeud.droite)
}

imprime_noeud :: fonc (noeud: *NoeudEnsemble) -> rien
{
    si noeud == nul {
        retourne
    }

    imprime_noeud(noeud.gauche)
    imprime_noeud(noeud.droite)

    imprime("%\n", noeud.chn)
}

Ensemble :: struct {
    racine : *NoeudEnsemble
}

détruit_ensemble :: fonc (ensemble: *Ensemble) -> rien
{
    détruit_noeud(ensemble.racine)
}

ajoute :: fonc (ensemble: *Ensemble, chn: chaine) -> rien
{
    noeud := loge NoeudEnsemble
    noeud.gauche = nul
    noeud.droite = nul
    noeud.chn = chn

    insère(ensemble, noeud)
}

insère :: fonc (ensemble: *Ensemble, noeud: *NoeudEnsemble) -> rien
{
    si ensemble.racine == nul {
        ensemble.racine = noeud
        retourne
    }

    racine := ensemble.racine

    si racine.gauche == nul && racine.droite == nul {
        si noeud.chn < racine.chn {
            racine.gauche = noeud
        }
        sinon {
            racine.droite = noeud
        }

        retourne
    }

    si racine.gauche == nul && racine.droite != nul {
        racine.gauche = noeud
        retourne
    }
    sinon {
        si noeud.chn < racine.gauche.chn {
            racine.droite = racine.gauche
            racine.gauche = noeud
            retourne
        }
    }

    si racine.droite == nul {
        racine.droite = noeud
        retourne
    }

    //insère(ensemble.racine)
}

imprime_ensemble :: fonc (ensemble: *Ensemble) -> rien
{
    imprime_noeud(ensemble.racine)
}
*/

Ensemble :: struct {
    données: []z32
}

détruit_ensemble :: fonc (ensemble: *Ensemble) -> rien
{
    déloge ensemble.données
}

distance :: fonc (ptr1 : *$T, ptr2 : *$T) -> z64
{
	retourne transtype(ptr2 - ptr1: z64)
}

suivant :: fonc (ptr : *$T, n : z64) -> *$T
{
	retourne ptr + n
}

limite_basse :: fonc (f : *$T, l : *$T, v : $T) -> *$T
{
	fl := f
	ll := l

	boucle {
		si fl == ll {
			arrête
		}

		m := suivant(fl, distance(fl, ll) / 2)

		si (m[0] < v) {
			fl = suivant(m, 1)
		}
		sinon {
			ll = m
		}
	}

	retourne fl
}

limite_haute :: fonc (f : *$T, l : *$T, v : $T) -> *$T
{
	fl := f
	ll := l

	boucle {
		si fl == ll {
			arrête
		}

		m := suivant(fl, distance(fl, ll) / 2)

		si (m[0] > v) {
			fl = suivant(m, 1)
		}
		sinon {
			ll = m
		}
	}

	retourne fl
}

ajoute :: fonc (ensemble: *Ensemble, donnée: z32) -> rien
{
/*
    index_d_insertion : z64 = 0
    trouvé := faux

    pour d, idx dans ensemble.données {
        si d == donnée {
            retourne
        }

        index_d_insertion = idx

        si d > donnée {
            trouvé = vrai
            arrête
        }
    }

    si !trouvé {
        index_d_insertion = ensemble.données.taille
    }
*/

    si ensemble.données.taille == 0 {
        tableau_ajoute(@ensemble.données, donnée)
        retourne
    }

    début := @ensemble.données[0]
    fin   := début + ensemble.données.taille

    limite := limite_basse(début, fin, donnée)

    si limite < fin {
        si mémoire(limite) == donnée {
            retourne
        }
    }

    index_d_insertion := distance(début, limite)

    taille := ensemble.données.taille
    reloge ensemble.données : [taille + 1]z32

    i := taille

    tantque i > index_d_insertion {
        ensemble.données[i] = ensemble.données[i - 1]
        i -= 1
    }

    ensemble.données[index_d_insertion] = donnée
}

imprime_ensemble :: fonc (ensemble: *Ensemble) -> rien
{
    pour donnée dans ensemble.données {
        imprime("% ", donnée)
    }

    imprime("\n")
}

principale :: fonc () -> z32
{
    e : Ensemble

    ajoute(@e, 5)
    ajoute(@e, 5)
    ajoute(@e, 4)
    ajoute(@e, 3)
    ajoute(@e, 1)
    ajoute(@e, 9)
    ajoute(@e, 8)
    ajoute(@e, 7)
    ajoute(@e, 6)
    ajoute(@e, 5)
    ajoute(@e, 5)
    ajoute(@e, 2)
    ajoute(@e, 2)
    ajoute(@e, 2)
    ajoute(@e, 1)
    ajoute(@e, 10)

    imprime_ensemble(@e)

    détruit_ensemble(@e)

    retourne 0
}
