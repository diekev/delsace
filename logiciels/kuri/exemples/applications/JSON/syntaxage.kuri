importe Fondation
importe Tori

charge "assemblage_objet"
charge "lexage"

struct Syntaxeuse {
	lexèmes : []DonneesLexème
    assembleuse : AssembleuseObjet

	position := 0
}

fonc construit_syntaxeuse(lexèmes : &[]DonneesLexème) : Syntaxeuse
{
	dyn syntaxeuse : Syntaxeuse
	syntaxeuse.lexèmes = lexèmes

	retourne syntaxeuse
}

fonc détruit(syntaxeuse : &Syntaxeuse) : rien
{
    détruit(syntaxeuse.assembleuse)
}

fonc lexème_courant(syntaxeuse : &Syntaxeuse) : TypeLexème
{
	retourne syntaxeuse.lexèmes[syntaxeuse.position].lexème
}

fonc avance(dyn syntaxeuse : &Syntaxeuse) : rien
{
	syntaxeuse.position += 1
}

fonc requiers_lexème(syntaxeuse : &Syntaxeuse, type : TypeLexème) : bool
{
	t := syntaxeuse.lexème_courant()
	syntaxeuse.avance()
	retourne t == type
}

fonc est_lexème(syntaxeuse : &Syntaxeuse, type : TypeLexème) : bool
{
	retourne syntaxeuse.lexème_courant() == type
}

fonc données(syntaxeuse : &Syntaxeuse) : &DonneesLexème
{
	retourne syntaxeuse.lexèmes[syntaxeuse.position - 1]
}

fonc analyse_objet(dyn syntaxeuse : &Syntaxeuse) : rien
{
	si (!syntaxeuse.requiers_lexème(TypeLexème.CHAINE_CARACTERE)) {
		#lance_erreur("Attendu une chaine de caractère")
	}

	nom_objet := syntaxeuse.données().chn

	si (!syntaxeuse.requiers_lexème(TypeLexème.DOUBLE_POINTS)) {
		#lance_erreur("Attendu un double-point ':'")
	}

	syntaxeuse.analyse_valeur(nom_objet)

	si (syntaxeuse.est_lexème(TypeLexème.VIRGULE)) {
		syntaxeuse.avance()
		syntaxeuse.analyse_objet()
	}
}

fonc analyse_valeur(dyn syntaxeuse : &Syntaxeuse, nom_objet : chaine) : rien
{
	discr syntaxeuse.lexème_courant() {
		ACCOLADE_OUVRANTE {
			syntaxeuse.avance()

			obj := syntaxeuse.assembleuse.crée_objet(nom_objet, TypeObjet.DICTIONNAIRE)
			syntaxeuse.assembleuse.empile_objet(obj)

			syntaxeuse.analyse_objet()

			syntaxeuse.assembleuse.dépile_objet()

			si (!syntaxeuse.requiers_lexème(TypeLexème.ACCOLADE_FERMANTE)) {
				#lance_erreur("Attendu une accolade fermante '}' à la fin de l'objet")
			}
		}
		CROCHET_OUVRANT {
			syntaxeuse.avance()

			obj := syntaxeuse.assembleuse.crée_objet(nom_objet, TypeObjet.LISTE)
			syntaxeuse.assembleuse.empile_objet(obj)

			tantque !syntaxeuse.est_lexème(TypeLexème.CROCHET_FERMANT) {
				syntaxeuse.analyse_valeur("")

				si (syntaxeuse.est_lexème(TypeLexème.VIRGULE)) {
					syntaxeuse.avance()
				}
			}

			syntaxeuse.assembleuse.dépile_objet()

			syntaxeuse.avance()
		}
		NOMBRE_ENTIER {
			syntaxeuse.avance()

			obj := syntaxeuse.assembleuse.crée_objet(nom_objet, TypeObjet.ENTIER)
			dyn obj_entier := transtype(obj: *ObjetEntier)
            obj_entier.valeur = extrait_nombre_entier(syntaxeuse.données().chn)
		}
		NOMBRE_REEL {
			syntaxeuse.avance()

			obj := syntaxeuse.assembleuse.crée_objet(nom_objet, TypeObjet.RÉEL)
			dyn obj_réel = transtype(obj: *ObjetRéel)
            obj_réel.valeur = extrait_nombre_réel(syntaxeuse.données().chn)
		}
		CHAINE_CARACTERE {
			syntaxeuse.avance()

			obj := syntaxeuse.assembleuse.crée_objet(nom_objet, TypeObjet.CHAINE)
			dyn obj_chaine := transtype(obj: *ObjetChaine)
            obj_chaine.valeur = syntaxeuse.données().chn

			# À FAIRE: gestion des chaines allouées dynamiquement
			#res = dls::chaine()

			#for (i = 0 i < donnees().chaine.taille() ++i) {
			#	c = donnees().chaine[i]

			#	si (c == '\\') {
			#		continue
			#	}

			#	res += c
			#}
		}
		sinon {
			syntaxeuse.avance()
			# À FAIRE : lance_erreur("Élément inattendu")
		}
	}
}

fonc lance_analyse(dyn syntaxeuse : &Syntaxeuse) : rien
{
	syntaxeuse.position = 0

	si (syntaxeuse.lexèmes.taille == 0) {
		retourne
	}

	si (!syntaxeuse.requiers_lexème(TypeLexème.ACCOLADE_OUVRANTE)) {
		#lance_erreur("Attendu une accolade ouvrante '{' au début du script")
	}

    obj := syntaxeuse.assembleuse.crée_objet("", TypeObjet.DICTIONNAIRE)
	syntaxeuse.assembleuse.empile_objet(obj)

	syntaxeuse.analyse_objet()

    # Ne dépile pas le dictionnaire, car il est la racine

	si (!syntaxeuse.requiers_lexème(TypeLexème.ACCOLADE_FERMANTE)) {
		#lance_erreur("Attendu une accolade fermante '}' à la fin du script")
	}

	#imprime_arbre(syntaxeuse.assembleuse.racine.get(), 0, std::cerr)
}
