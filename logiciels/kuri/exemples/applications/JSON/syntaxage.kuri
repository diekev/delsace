importe Fondation

charge "lexage"

struct Syntaxeuse {
	lexèmes : []DonneesLexème

	position = 0
}

fonc construit_syntaxeuse(lexèmes : &[]DonneesLexème) : Syntaxeuse
{
	dyn syntaxeuse : Syntaxeuse
	syntaxeuse.lexèmes = lexèmes

	retourne syntaxeuse
}

fonc lexème_courant(syntaxeuse : &Syntaxeuse) : TypeLexème
{
	retourne syntaxeuse.lexèmes[syntaxeuse.position].lexème
}

fonc avance(dyn syntaxeuse : &Syntaxeuse) : rien
{
	syntaxeuse.position += 1
}

fonc requiers_lexème(syntaxeuse : &Syntaxeuse, type : TypeLexème) : bool
{
	t = syntaxeuse.lexème_courant()
	syntaxeuse.avance()
	retourne t == type
}

fonc est_lexème(syntaxeuse : &Syntaxeuse, type : TypeLexème) : bool
{
	retourne syntaxeuse.lexème_courant() == type
}

fonc données(syntaxeuse : &Syntaxeuse) : &DonneesLexème
{
	retourne syntaxeuse.lexèmes[syntaxeuse.position]
}

fonc analyse_objet(dyn syntaxeuse : &Syntaxeuse) : rien
{
	si (!syntaxeuse.requiers_lexème(TypeLexème.CHAINE_CARACTERE)) {
		#lance_erreur("Attendu une chaine de caractère")
	}

	nom_objet = syntaxeuse.données().chn

	si (!syntaxeuse.requiers_lexème(TypeLexème.DOUBLE_POINTS)) {
		#lance_erreur("Attendu un double-point ':'")
	}

	syntaxeuse.analyse_valeur(nom_objet)

	si (syntaxeuse.est_lexème(TypeLexème.VIRGULE)) {
		syntaxeuse.avance()
		syntaxeuse.analyse_objet()
	}
}

fonc analyse_valeur(dyn syntaxeuse : &Syntaxeuse, nom_objet : chaine) : rien
{
	discr syntaxeuse.lexème_courant() {
		ACCOLADE_OUVRANTE {
			syntaxeuse.avance()

			#obj = syntaxeuse.assembleuse.cree_objet(nom_objet, tori::type_objet::DICTIONNAIRE)
			#syntaxeuse.assembleuse.empile_objet(obj)

			syntaxeuse.analyse_objet()

			#syntaxeuse.assembleuse.depile_objet()

			si (!syntaxeuse.requiers_lexème(TypeLexème.ACCOLADE_FERMANTE)) {
				#lance_erreur("Attendu une accolade fermante '}' à la fin de l'objet")
			}
		}
		CROCHET_OUVRANT {
			syntaxeuse.avance()

			#obj = syntaxeuse.assembleuse.cree_objet(nom_objet, tori::type_objet::TABLEAU)
			#syntaxeuse.assembleuse.empile_objet(obj)

			boucle {
				si (syntaxeuse.est_lexème(TypeLexème.CROCHET_FERMANT)) {
					arrête
				}

				syntaxeuse.analyse_valeur("")

				si (syntaxeuse.est_lexème(TypeLexème.VIRGULE)) {
					syntaxeuse.avance()
				}
			}

			#syntaxeuse.assembleuse.depile_objet()

			syntaxeuse.avance()
		}
		NOMBRE_ENTIER {
			syntaxeuse.avance()

			# À FAIRE
		}
		NOMBRE_REEL {
			syntaxeuse.avance()

			# À FAIRE
		}
		CHAINE_CARACTERE {
			syntaxeuse.avance()

			# À FAIRE

			#obj = syntaxeuse.assembleuse.cree_objet(nom_objet, tori::type_objet::CHAINE)
			#obj_chaine = static_cast<tori::ObjetChaine *>(obj.get())

			#res = dls::chaine()

			#for (i = 0 i < donnees().chaine.taille() ++i) {
			#	c = donnees().chaine[i]

			#	si (c == '\\') {
			#		continue
			#	}

			#	res += c
			#}

			#obj_chaine->valeur = res
		}
		sinon {
			syntaxeuse.avance()
			# À FAIRE : lance_erreur("Élément inattendu")
		}
	}
}

fonc lance_analyse(dyn syntaxeuse : &Syntaxeuse) : rien
{
	syntaxeuse.position = 0

	si (syntaxeuse.lexèmes.taille == 0) {
		retourne
	}

	si (!syntaxeuse.requiers_lexème(TypeLexème.ACCOLADE_OUVRANTE)) {
		#lance_erreur("Attendu une accolade ouvrante '{' au début du script")
	}

	syntaxeuse.analyse_objet()

	si (!syntaxeuse.requiers_lexème(TypeLexème.ACCOLADE_FERMANTE)) {
		#lance_erreur("Attendu une accolade fermante '}' à la fin du script")
	}

	#imprime_arbre(syntaxeuse.assembleuse.racine.get(), 0, std::cerr)
}

###############################################################################

fonc principale(args : []*z8) : z32
{
    chn = "{ \"nom\" : \"dietrich\", \"prénom\" : \"kévin\" }"

    dyn lexeuse = construit_lexeuse(chn)
    diffère { détruit_lexeuse(lexeuse); }

    lexeuse.performe_lexage()

    imprime("Il y a ", lexeuse.lexèmes.taille, " lexèmes.\n")

    pour données dans lexeuse.lexèmes {
        imprime(données.lexème, "\n")
    }

	dyn syntaxeuse : Syntaxeuse
	syntaxeuse.lexèmes = lexeuse.lexèmes
	syntaxeuse.lance_analyse()

    retourne 0
}