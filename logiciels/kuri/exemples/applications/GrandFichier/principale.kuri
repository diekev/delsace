importe Fondation
importe SysFichier
importe Temps

imprime_prompt :: fonc ()
{
    imprime("> ")
}

GFichier :: struct {
    chemin: chaine
    date_création: Date
}

Système :: struct {
    fichiers: []GFichier
}

ErreurRequête :: erreur {
    RequêteMalformée
    FichierInexistant
    FichierExisteDéjà
}

détruit_système :: fonc (système: *Système)
{
    pour système.fichiers {
        déloge it.chemin
    }

    déloge système.fichiers
}

crée_fichier :: fonc (système: *Système, entrée: chaine) -> ErreurRequête
{
    morceaux := divise(entrée, ' ')
    diffère { déloge morceaux }

    si morceaux.taille != 2 {
        retourne ErreurRequête.RequêteMalformée
    }

    pour système.fichiers {
        si it.chemin == morceaux[1] {
            retourne ErreurRequête.FichierExisteDéjà
        }
    }

    fichier : GFichier
    fichier.chemin = copie_chaine(morceaux[1])
    fichier.date_création = hui_système()

    // À FAIRE : log l'opération dans un journal
    // on pourrait avoir un attribut de taille pour savoir combien de chunks créer/réserver
    // distribut un chunk par serveur
    // quand un client veut écrire un fichier, il doit pouvoir contacter le serveur maitre pour demander des chunks en plus

    tableau_ajoute(@système.fichiers, fichier)
    retourne 0 comme ErreurRequête
}

accède_fichier :: fonc (système: *Système, entrée: chaine) -> ErreurRequête
{
    morceaux := divise(entrée, ' ')
    diffère { déloge morceaux }

    si morceaux.taille != 2 {
        retourne ErreurRequête.RequêteMalformée
    }

    pour système.fichiers {
        si it.chemin == morceaux[1] {
            // vérifie si le fichier est déjà en accès
            retourne 0 comme ErreurRequête
        }
    }

    // marque le fichier comme étant en accès pour un certain temps

    retourne ErreurRequête.FichierInexistant
}

liste_fichiers :: fonc (système: *Système)
{
    pour système.fichiers {
        imprime("% - ajouté : %\n", it.chemin, it.date_création)
    }
}

principale :: fonc () -> z32
{
    diffère { imprime("Fin du programme, mémoire utilisée : %o\n", mémoire_utilisée()) }

    nouveau_contexte := contexte
    nouveau_contexte.allocatrice = __stockage_temporaire

    système: Système
    diffère { détruit_système(@système) }

    boucle {
        imprime_prompt()

        marque := obtiens_marque_stockage_temporaire()
        diffère { set_marque_stockage_temporaire(marque) }

        entrée : chaine
        pousse_contexte nouveau_contexte {
            entrée = entrée_standarde().lis_ligne()
        }

        si entrée.commence_par("CRÉE") {
            tente crée_fichier(@système, entrée) piège err {
                imprime("erreur lors de la gestion de la requête : %\n", err)
                continue
            }

            imprime("ok\n")
        }
        sinon si entrée.commence_par("ACCÈDE") {
            tente accède_fichier(@système, entrée) piège err {
                imprime("erreur lors de la gestion de la requête : %\n", err)
                continue
            }

            imprime("ok\n")
        }
        sinon si entrée.commence_par("LISTE") {
            liste_fichiers(@système)
            imprime("ok\n")
        }
        sinon {
            imprime("erreur, commande non reconnue\n")
        }
    }

    retourne 0
}
