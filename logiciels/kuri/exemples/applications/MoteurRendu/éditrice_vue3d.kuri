importe Couleur
importe Fondation
importe Image
importe Math

charge "ratissage_maillage"
charge "traçage_maillage"

// --------------------------------------------------------------

DonnéesPourNuançage :: struct {
    matcap: *Image.Image
    direction_vue: Vec3
    position: Vec3
    normal: Norm3
}

nuançage_lumière :: fonc (empl données: DonnéesPourNuançage) -> Couleur.Couleur
{
    dir_lumière := crée_vec3r(z = -1.0)
    // besoin de normalisation ?
    dp := produit_scalaire(vec_depuis_nor(normal), dir_lumière)
    retourne Couleur(r = dp, v = dp, b = dp, a = 1.0)
}

nuançage_matcap :: fonc (empl données: DonnéesPourNuançage) -> Couleur.Couleur
{
    vnor := vec_depuis_nor(normal)
    uv := calcul_uv_capmat(*direction_vue, *vnor, faux)
    retourne échantillonne_prochain(matcap, *uv)
}

// --------------------------------------------------------------

MoteurRendu :: struct {
    caméra : *Caméra3D
    maillage: *Maillage
    matcap: *Image.Image

    /* Fonctions de rappels. */
    rends: fonc(*MoteurRendu, *Image.Image)(rien)

    nuanceur: fonc(DonnéesPourNuançage)(Couleur.Couleur)
}

ajourne_rendu :: fonc (moteur: *MoteurRendu, image: *Image.Image)
{
    marque := obtiens_marque_stockage_temporaire()
    diffère { set_marque_stockage_temporaire(marque) }

    ticks := compte_ticks_ms()

    moteur.nuanceur = nuançage_matcap
    moteur.rends(moteur, image)

    temps_rendu := compte_ticks_ms() - ticks
    temps_rendu_us := temps_rendu * 1000
    temps_par_pixel := temps_rendu_us / (image.largeur * image.hauteur)
    temps_par_polygone := temps_rendu_us / (moteur.maillage.tris.taille)

    imprime(
        "Temps de rendu : %ms (par pixel %us, par polygone %us)\n",
        FormatEntier(valeur = temps_rendu, séparation = 3),
        FormatEntier(valeur = temps_par_pixel, séparation = 3),
        FormatEntier(valeur = temps_par_polygone, séparation = 3))
}

// --------------------------------------------------------------

ModeRendu :: énum {
    Ratissage
    TraçageDeRayon
}

ÉditriceVue3D :: struct {
    empl base: Éditrice

    caméra : *Caméra3D
    tampon_texture : *TamponTexture
    image : Image.Image

    // seulement utilisé pour l'échantillonnage
    matcap : Image.Image

    img_matcap : ImageIO

    mode_rendu: ModeRendu
}

détruit_éditrice_vue_3d :: fonc (éditrice: *ÉditriceVue3D) -> rien
{
    détruit_tampon_texture(éditrice.tampon_texture)
    détruit_image(*éditrice.image)
    IMG_detruit_image(*éditrice.img_matcap)
    déloge(éditrice.caméra)
    déloge(éditrice)
}

crée_éditrice_vue_3d :: fonc (app: *Application) -> *Éditrice
{
    éditrice := loge(ÉditriceVue3D)
    éditrice.x = 0
    éditrice.y = 0
    éditrice.largeur = app.largeur
    éditrice.hauteur = app.hauteur

    éditrice.x_r = 0.0
    éditrice.y_r = 0.0
    éditrice.largeur_r = 1.0
    éditrice.hauteur_r = 1.0

    éditrice.type = TypeÉditrice.VUE_3D

    éditrice.image = crée_image(éditrice.largeur, éditrice.hauteur)

    _ := IMG_ouvre_image("/home/kevin/Images/matcap.png\0".pointeur, *éditrice.img_matcap)
    // imprime("résultat ouverture : %\n", résultat_ouverture)
    éditrice.matcap.tampon.pointeur = éditrice.img_matcap.donnees comme *Couleur.Couleur
    éditrice.matcap.tampon.taille = éditrice.img_matcap.largeur * éditrice.img_matcap.hauteur
    éditrice.matcap.largeur = éditrice.img_matcap.largeur
    éditrice.matcap.hauteur = éditrice.img_matcap.hauteur

    éditrice.tampon_texture = crée_tampon_texture()

    caméra := loge(Caméra3D)
    caméra.champs_de_vue = calcul_champs_de_vue_degrés(70.0, 35.0)
    caméra.direction_vue = Vec3(z = 1.0)
    caméra.projection = matrice_projection(
        caméra.champs_de_vue,
        éditrice.largeur comme r32,
        éditrice.hauteur comme r32,
        caméra.plan_proche,
        caméra.plan_éloigné)

    éditrice.caméra = caméra

    retourne éditrice
}

dessine_vue_3d :: fonc (app: *Application, éditrice: *ÉditriceVue3D) -> rien
{
    remplis_image(*éditrice.image, Couleur.Couleur( r = 0.0, v = 0.0, b = 0.0, a = 1.0 ))

    moteur : MoteurRendu
    moteur.caméra = éditrice.caméra
    moteur.maillage = app.maillage
    moteur.matcap = *éditrice.matcap

    si éditrice.mode_rendu == ModeRendu.Ratissage {
        initialise_moteur_rendu_ratissage(*moteur)
    }
    sinon {
        initialise_moteur_rendu_traçage(*moteur)
    }

    ajourne_rendu(*moteur, *éditrice.image)

    génère_texture(éditrice.tampon_texture, éditrice.image.tampon, éditrice.largeur, éditrice.hauteur)

    dessine_tampon_texture(éditrice.tampon_texture)
}
