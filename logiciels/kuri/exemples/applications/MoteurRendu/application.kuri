charge "glew"
charge "sdl2"
charge "dessin_texture"

importe Fondation
importe Math

// https://www.youtube.com/watch?v=ih20l3pJoeU

// ----------------------------------------------------------------------------

Image :: struct {
    tampon : []Couleur
    largeur: z32
    hauteur: z32
}

crée_image :: fonc (largeur: z32, hauteur: z32) -> Image
{
    dyn image: Image
    image.tampon = loge [largeur * hauteur]Couleur
    image.largeur = largeur
    image.hauteur = hauteur

    retourne image
}

détruit_image :: fonc (image: *Image) -> rien
{
    déloge image.tampon
}

remplis_image :: fonc (dyn image : *Image, couleur: Couleur) -> rien
{
    pour pixel dans image.tampon {
        pixel = couleur
    }
}

// ----------------------------------------------------------------------------

crée_vec3z :: fonc (x := 0.0, y := 0.0, z := 0.0) -> Vec3r
{
    retourne Vec3r{ x = x, y = y, z = z }
}

// À FAIRE(langage) : les typedefs des tableaux fixes ne sont pas correctes car la structure est définie après ceux-ci
Triangle :: struct {
    p0 : Vec3r
    p1 : Vec3r
    p2 : Vec3r
}

crée_triangle :: fonc (p0 : Vec3r, p1 : Vec3r, p2 : Vec3r) -> Triangle
{
    dyn tri : Triangle
    tri.p0 = p0
    tri.p1 = p1
    tri.p2 = p2

    retourne tri
}

Maillage :: struct {
    tris : []Triangle
}

// ----------------------------------------------------------------------------

dessine_ligne :: fonc(
    dyn image: *Image,
    x1 : z32,
    y1 : z32,
    x2 : z32,
    y2 : z32) -> rien
{
    dyn dx := transtype(x2 - x1 : r32);
    dyn dy := transtype(y2 - y1 : r32);
    dyn pas : r32;

    si abs(dx) >= abs(dy) {
        pas = abs(dx);
    }
    sinon {
        pas = abs(dy);
    }

    dx /= pas;
    dy /= pas;
    dyn x := transtype(x1 : r32);
    dyn y := transtype(y1 : r32);
    dyn i : r32 = 1.0;

    tantque i <= pas {
        xi := transtype(x : z32);
        yi := transtype(y : z32);
        index := xi + yi * image.largeur;
        image.tampon[index] = Couleur{ r = 1.0, v = 0.0, b = 1.0, a = 1.0 };

        x += dx;
        y += dy;
        i += 1.0;
    }
}

dessine_triangle :: fonc(
    dyn image: *Image,
    x1 : r32,
    y1 : r32,
    x2 : r32,
    y2 : r32,
    x3 : r32,
    y3 : r32) -> rien
{
    ld := transtype(image.largeur - 1 : r32);
    hd := transtype(image.hauteur - 1 : r32);

    x1i := transtype(ld * x1 : z32);
    x2i := transtype(ld * x2 : z32);
    x3i := transtype(ld * x3 : z32);

    y1i := transtype(hd * y1 : z32);
    y2i := transtype(hd * y2 : z32);
    y3i := transtype(hd * y3 : z32);

    dessine_ligne(image, x1i, y1i, x2i, y2i);
    dessine_ligne(image, x2i, y2i, x3i, y3i);
    dessine_ligne(image, x3i, y3i, x1i, y1i);
}

// http://www.sunshine2k.de/coding/java/TriangleRasterization/TriangleRasterization.html

// Remplis un triangle qui pointe vers le haut avec une base horizontale :
//      /\
//     /  \
//     ----
remplis_triangle_bas_plat :: fonc(
    dyn image: *Image,
    v1 : Vec2r,
    v2 : Vec2r,
    v3 : Vec2r) -> rien
{
    ld := transtype(image.largeur - 1 : r32);
    hd := transtype(image.hauteur - 1 : r32);

    taille_pixel := 1.0 / min(ld, hd);

    cd1_inv := (v2.x - v1.x) / (v2.y - v1.y) * taille_pixel;
    cd2_inv := (v3.x - v1.x) / (v3.y - v1.y) * taille_pixel;

    dyn cur_x1 := v1.x;
    dyn cur_x2 := v1.x;

    y1 := transtype(v1.y * hd : z32);
    y2 := transtype(v2.y * hd : z32);

    restreint(@y1, 0, image.hauteur - 1);
    restreint(@y2, 0, image.hauteur - 1);

    dyn scanlineY := y1;

    tantque scanlineY <= y2 {
        x1i := transtype(cur_x1 * ld : z32);
        x2i := transtype(cur_x2 * ld : z32);

        restreint(@x1i, 0, image.largeur - 1);
        restreint(@x2i, 0, image.largeur - 1);

        dessine_ligne(image, x1i, scanlineY, x2i, scanlineY);

        cur_x1 += cd1_inv;
        cur_x2 += cd2_inv;

        scanlineY += 1;
    }
}

// Remplis un triangle qui pointe vers le bas avec une base horizontale :
//     ----
//     \  /
//      \/
remplis_triangle_haut_plat :: fonc(
    dyn image: *Image,
    v1 : Vec2r,
    v2 : Vec2r,
    v3 : Vec2r) -> rien
{
    ld := transtype(image.largeur - 1 : r32);
    hd := transtype(image.hauteur - 1 : r32);

    taille_pixel := 1.0 / min(ld, hd);

    cd1_inv := (v3.x - v1.x) / (v3.y - v1.y) * taille_pixel;
    cd2_inv := (v3.x - v2.x) / (v3.y - v2.y) * taille_pixel;

    dyn cur_x1 := v3.x;
    dyn cur_x2 := v3.x;

    y1 := transtype(v1.y * hd : z32);
    y3 := transtype(v3.y * hd : z32);

    restreint(@y1, 0, image.hauteur - 1);
    restreint(@y3, 0, image.hauteur - 1);

    dyn scanlineY := y3;

    tantque scanlineY > y1 {
        x1i := transtype(cur_x1 * ld : z32);
        x2i := transtype(cur_x2 * ld : z32);

        restreint(@x1i, 0, image.largeur - 1);
        restreint(@x2i, 0, image.largeur - 1);

        dessine_ligne(image, x1i, scanlineY, x2i, scanlineY);

        cur_x1 -= cd1_inv;
        cur_x2 -= cd2_inv;
        scanlineY -= 1;
    }
}

échange :: fonc(dyn v1 : &Vec2r, dyn v2 : &Vec2r) -> rien
{
    // À FAIRE : langage, erreur de compilation
    //échange(@v1.x, @v2.x);
    //échange(@v1.y, @v2.y);

    dyn tmp := v1.x
    v1.x = v2.x
    v2.x = tmp

    tmp = v1.y
    v1.y = v2.y
    v2.y = tmp
}

// Pour dessiner par ratissage un triangle quelconque, nous le divisons au besoin
// en deux triangles avec bases horizontales dont un pointe vers le haut et
// l'autre le bas :
//
//   /|
//  / |
// /__|
// \  |
//  \ |
//   \|
//
ratisse_triangle :: fonc(
    dyn image: *Image,
    x1 : r32,
    y1 : r32,
    x2 : r32,
    y2 : r32,
    x3 : r32,
    y3 : r32) -> rien
{
    v1 := Vec2r{ x = x1, y = y1 };
    v2 := Vec2r{ x = x2, y = y2 };
    v3 := Vec2r{ x = x3, y = y3 };

    boucle {
        si (v1.y) <= (v2.y) <= (v3.y) {
            arrête;
        }

        si v2.y < v1.y {
            échange(v1, v2);
        }

        si v3.y < v2.y {
            échange(v2, v3);
        }
    }

    si v2.y == v3.y {
        remplis_triangle_bas_plat(image, v1, v2, v3);
    }
    sinon si v1.y == v2.y {
        remplis_triangle_haut_plat(image, v1, v2, v3);
    }
    sinon {
        x4 := v1.x + ((v2.y - v1.y) / (v3.y - v1.y)) * (v3.x - v1.x);
        y4 := v2.y;

        v4 := Vec2r{ x = x4, y = y4 };

        remplis_triangle_bas_plat(image, v1, v2, v4);
        remplis_triangle_haut_plat(image, v2, v4, v3);
    }
}

// ----------------------------------------------------------------------------

Application :: struct {
    hauteur : z32 = 0
    largeur : z32 = 0

    maillage : *Maillage
    tampon_texture : *TamponTexture

    image : Image
}

crée_maillage :: fonc () -> *Maillage
{
    dyn maillage := loge Maillage
    maillage.tris.taille = 0
    maillage.tris.pointeur = nul

    // SUD
    dyn tri := crée_triangle(crée_vec3z(0.0, 0.0, 0.0), crée_vec3z(0.0, 1.0, 0.0), crée_vec3z(1.0, 1.0, 0.0))
    tableau_ajoute(@maillage.tris, tri)

    tri = crée_triangle(crée_vec3z(0.0, 0.0, 0.0), crée_vec3z(1.0, 1.0, 0.0), crée_vec3z(1.0, 0.0, 0.0))
    tableau_ajoute(@maillage.tris, tri)

    // EST
    tri = crée_triangle(crée_vec3z(1.0, 0.0, 0.0), crée_vec3z(1.0, 1.0, 0.0), crée_vec3z(1.0, 1.0, 1.0))
    tableau_ajoute(@maillage.tris, tri)

    tri = crée_triangle(crée_vec3z(1.0, 0.0, 0.0), crée_vec3z(1.0, 1.0, 1.0), crée_vec3z(1.0, 0.0, 1.0))
    tableau_ajoute(@maillage.tris, tri)

    // NORD
    tri = crée_triangle(crée_vec3z(1.0, 0.0, 1.0), crée_vec3z(1.0, 1.0, 1.0), crée_vec3z(0.0, 1.0, 1.0))
    tableau_ajoute(@maillage.tris, tri)

    tri = crée_triangle(crée_vec3z(1.0, 0.0, 1.0), crée_vec3z(0.0, 1.0, 1.0), crée_vec3z(0.0, 0.0, 1.0))
    tableau_ajoute(@maillage.tris, tri)

    // OUEST
    tri = crée_triangle(crée_vec3z(0.0, 0.0, 1.0), crée_vec3z(0.0, 1.0, 1.0), crée_vec3z(0.0, 1.0, 0.0))
    tableau_ajoute(@maillage.tris, tri)

    tri = crée_triangle(crée_vec3z(0.0, 0.0, 1.0), crée_vec3z(0.0, 1.0, 0.0), crée_vec3z(0.0, 0.0, 0.0))
    tableau_ajoute(@maillage.tris, tri)

    // HAUT
    tri = crée_triangle(crée_vec3z(0.0, 1.0, 0.0), crée_vec3z(0.0, 1.0, 1.0), crée_vec3z(1.0, 1.0, 1.0))
    tableau_ajoute(@maillage.tris, tri)

    tri = crée_triangle(crée_vec3z(0.0, 1.0, 0.0), crée_vec3z(1.0, 1.0, 1.0), crée_vec3z(1.0, 1.0, 0.0))
    tableau_ajoute(@maillage.tris, tri)

    // BAS
    tri = crée_triangle(crée_vec3z(1.0, 0.0, 1.0), crée_vec3z(0.0, 0.0, 1.0), crée_vec3z(0.0, 0.0, 0.0))
    tableau_ajoute(@maillage.tris, tri)

    tri = crée_triangle(crée_vec3z(1.0, 0.0, 1.0), crée_vec3z(0.0, 0.0, 0.0), crée_vec3z(1.0, 0.0, 0.0))
    tableau_ajoute(@maillage.tris, tri)

    assert(maillage.tris.taille == 12)

    retourne maillage
}

détruit_maillage :: fonc (maillage : *Maillage) -> rien
{
    déloge maillage.tris
    déloge maillage
}

// ----------------------------------------------------------------------------

Mat4r :: struct {
    m : [4][4]r32
}

construit_mat4r :: fonc () -> Mat4r
{
    dyn mat : Mat4r

    pour i dans 0 ... 3 {
        pour j dans 0 ... 3 {
            mat.m[i][j] = 0.0
        }
    }

    retourne mat
}

matrice_projection :: fonc (largeur: z32, hauteur: z32) -> Mat4r
{
    fNear := 0.1
    fFar := 1000.0
    fFov := 90.0
    fAspectRatio := transtype(hauteur: r32) / transtype(largeur: r32)
    fFovRad := 1.0 / transtype(tan(fFov * 0.5 / 180.0 * 3.14159): r32)

    dyn mat := construit_mat4r()

    mat.m[0][0] = fAspectRatio * fFovRad
    mat.m[1][1] = fFovRad
    mat.m[2][2] = fFar / (fFar - fNear)
    mat.m[3][2] = (-fFar * fNear) / (fFar - fNear)
    mat.m[2][3] = 1.0
    mat.m[3][3] = 0.0

    retourne mat
}

multiplie :: fonc (mat: Mat4r, vec: Vec3r) -> Vec3r
{
    dyn rés : Vec3r

    rés.x = vec.x * mat.m[0][0] + vec.y * mat.m[1][0] + vec.z * mat.m[2][0] + mat.m[3][0]
    rés.y = vec.x * mat.m[0][1] + vec.y * mat.m[1][1] + vec.z * mat.m[2][1] + mat.m[3][1]
    rés.z = vec.x * mat.m[0][2] + vec.y * mat.m[1][2] + vec.z * mat.m[2][2] + mat.m[3][2]

    w := vec.x * mat.m[0][3] + vec.y * mat.m[1][3] + vec.z * mat.m[2][3] + mat.m[3][3]

    si w != 0.0 {
        rés.x /= w
        rés.y /= w
        rés.z /= w
    }

    retourne rés
}

multiplie :: fonc (mat: Mat4r, tri: Triangle) -> Triangle
{
    dyn rés : Triangle

    rés.p0 = multiplie(mat, tri.p0)
    rés.p1 = multiplie(mat, tri.p1)
    rés.p2 = multiplie(mat, tri.p2)

    retourne rés
}

// ----------------------------------------------------------------------------

principale :: fonc () -> z32
{
	diffère {
	    imprime_sans_format("Fin du programme, mémoire utilisée : ", mémoire_utilisée(), "o\n")
	}

    SDL_Init(DrapeauxInit.SDL_INIT_VIDEO);
    diffère { SDL_Quit(); }

    SDL_GL_SetAttribute(SDL_GLattr.SDL_GL_CONTEXT_PROFILE_MASK, 1);
    SDL_GL_SetAttribute(SDL_GLattr.SDL_GL_CONTEXT_MAJOR_VERSION, 4);
    SDL_GL_SetAttribute(SDL_GLattr.SDL_GL_CONTEXT_MINOR_VERSION, 0);
    SDL_GL_SetAttribute(SDL_GLattr.SDL_GL_STENCIL_SIZE, 8);

    dyn largeur : z32 = 640
    dyn hauteur : z32 = 480

    titre := "Moteur Rendu"

    window := SDL_CreateWindow(titre.pointeur, 100, 100, largeur, hauteur, SDL_WindowFlags.SDL_WINDOW_OPENGL);

    context := SDL_GL_CreateContext(window);
    diffère { SDL_GL_DeleteContext(context); }

    nonsûr {
        glewExperimental = 1
    }

    erreur := glewInit()

    si erreur != 0 {
        imprime("Erreur lors de l'initilisation de GLEW !\n")
        retourne 1
    }

    // initialise l'application
    dyn app : Application
    app.hauteur = hauteur
    app.largeur = largeur

    app.image = crée_image(largeur, hauteur)
    diffère { détruit_image(@app.image); }

    app.tampon_texture = crée_tampon_texture()
    diffère { détruit_tampon_texture(app.tampon_texture); }

    maillage := crée_maillage()
    diffère { détruit_maillage(maillage); }

    app.maillage = maillage

    dyn windowEvent : SDL_Event;

    mat_proj := matrice_projection(largeur, hauteur)

    dyn theta := 0.0

    boucle {
        si SDL_PollEvent(@windowEvent) != 0 {
            si windowEvent.type == transtype(0x100: n32) {
                arrête
            }
        }

        //imprime("%\n\n", app)
        imprime("Mémoire utilisée : %o\n\n", formatte_entier(mémoire_utilisée(), séparation=3))

        // dessine fenêtre

        glClear(0x00004000)

        //glClearColor(0.5, 0.5, 1.0, 1.0)

        remplis_image(@app.image, Couleur{ r = 0.0, v = 0.0, b = 0.0, a = 1.0 })

        dyn mat_rot_x := construit_mat4r()
        dyn mat_rot_z := construit_mat4r()

        mat_rot_z.m[0][0] = transtype(cos(theta): r32)
        mat_rot_z.m[0][1] = transtype(sin(theta): r32)
        mat_rot_z.m[1][0] = transtype(-sin(theta): r32)
        mat_rot_z.m[1][1] = transtype(cos(theta): r32)
        mat_rot_z.m[2][2] = 1.0
        mat_rot_z.m[3][3] = 1.0

        mat_rot_x.m[0][0] = 1.0
        mat_rot_x.m[1][1] = transtype(cos(theta * 0.5): r32)
        mat_rot_x.m[1][2] = transtype(sin(theta * 0.5): r32)
        mat_rot_x.m[2][1] = transtype(-sin(theta * 0.5): r32)
        mat_rot_x.m[2][2] = transtype(cos(theta * 0.5): r32)
        mat_rot_x.m[3][3] = 1.0

        //dessine_ligne(@app.image, largeur / 4, 0, largeur / 4, hauteur)
        //ratisse_triangle(@app.image, 0.25, 0.5, 0.5, 0.25, 0.5, 0.75);
        //dessine_triangle(@app.image, 0.25, 0.5, 0.5, 0.25, 0.5, 0.75);

        pour tri dans maillage.tris {
            dyn tri_rot_z := multiplie(mat_rot_z, tri)
            dyn tri_rot_zx := multiplie(mat_rot_x, tri_rot_z)

            // déplace le triangle pour qu'il ne soit pas dans la caméra
            dyn tri_déplacé := tri_rot_zx
            tri_déplacé.p0.z += 3.0
            tri_déplacé.p1.z += 3.0
            tri_déplacé.p2.z += 3.0

            dyn tri_projeté := multiplie(mat_proj, tri_déplacé)

            // puisque le résultat est entre -1.0 et 1.0 nous devons le transformer pous qu'il soit dans les coordonnées de l'image
            tri_projeté.p0.x += 1.0
            tri_projeté.p0.y += 1.0

            tri_projeté.p1.x += 1.0
            tri_projeté.p1.y += 1.0

            tri_projeté.p2.x += 1.0
            tri_projeté.p2.y += 1.0

            tri_projeté.p0.x *= 0.5
            tri_projeté.p0.y *= 0.5

            tri_projeté.p1.x *= 0.5
            tri_projeté.p1.y *= 0.5

            tri_projeté.p2.x *= 0.5
            tri_projeté.p2.y *= 0.5

            ratisse_triangle(
                @app.image,
                tri_projeté.p0.x,
                tri_projeté.p0.y,
                tri_projeté.p1.x,
                tri_projeté.p1.y
                tri_projeté.p2.x,
                tri_projeté.p2.y);
        }

        génère_texture(app.tampon_texture, app.image.tampon, largeur, hauteur)

        dessine_tampon_texture(app.tampon_texture)

        SDL_GL_SwapWindow(window);

        theta += 0.016

        SDL_Delay(16)
    }

    retourne 0
}
