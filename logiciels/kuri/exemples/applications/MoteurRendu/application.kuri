charge "sdl2"
charge "dessin_texture"
charge "maillage"
charge "ratissage"

importe Couleur
importe Fondation
importe Image
importe OpenGL
importe Math

// https://www.youtube.com/watch?v=HXSuNxpCzdM : 43.33

// ----------------------------------------------------------------------------

Application :: struct {
    hauteur : z32 = 0
    largeur : z32 = 0

    maillage : *Maillage
    tampon_texture : *TamponTexture

    image : Image
}

// ----------------------------------------------------------------------------

principale :: fonc () -> z32
{
	diffère {
	    imprime_sans_format("Fin du programme, mémoire utilisée : ", mémoire_utilisée(), "o\n")
	}

    SDL_Init(DrapeauxInit.SDL_INIT_EVERYTHING);
    diffère { SDL_Quit(); }

    SDL_GL_SetAttribute(SDL_GLattr.SDL_GL_CONTEXT_PROFILE_MASK, 1);
    SDL_GL_SetAttribute(SDL_GLattr.SDL_GL_CONTEXT_MAJOR_VERSION, 4);
    SDL_GL_SetAttribute(SDL_GLattr.SDL_GL_CONTEXT_MINOR_VERSION, 0);
    SDL_GL_SetAttribute(SDL_GLattr.SDL_GL_STENCIL_SIZE, 8);

    dyn largeur : z32 = 640
    dyn hauteur : z32 = 480

    titre := "Moteur Rendu"

    window := SDL_CreateWindow(titre.pointeur, 100, 100, largeur, hauteur, SDL_WindowFlags.SDL_WINDOW_OPENGL);

    context := SDL_GL_CreateContext(window);
    diffère { SDL_GL_DeleteContext(context); }

    si !initialise_opengl() {
        imprime("Erreur lors de l'initilisation de GLEW !\n")
        retourne 1
    }

    // initialise l'application
    dyn app : Application
    app.hauteur = hauteur
    app.largeur = largeur

    app.image = crée_image(largeur, hauteur)
    diffère { détruit_image(@app.image); }

    matcap := charge_image_png("/home/kevin/Images/matcap.png")

    diffère {
        détruit_image(matcap)
        déloge matcap
    }

    app.tampon_texture = crée_tampon_texture()
    diffère { détruit_tampon_texture(app.tampon_texture); }

    maillage := charge_maillage_depuis_obj("/home/kevin/fichiers/objs/VideoShip.obj")
    diffère { détruit_maillage(maillage); }

    app.maillage = maillage

    dyn windowEvent : SDL_Event;

    mat_proj := matrice_projection(
        90.0,
        transtype(largeur: r32),
        transtype(hauteur: r32),
        0.1,
        1000.0)

    dyn theta := 0.0

    dyn caméra := crée_vec3r()
    dyn dir_visé := crée_vec3r(z = 1.0)
    dyn yaw := 0.0

    dyn contexte_temp := contexte
    contexte_temp.allocatrice = __stockage_temporaire

    mat_trans := matrice_translation(z = 8.0)

    temps_écoulé := 1.0

    boucle {
        dyn début := compte_ticks_ms()

        marque := obtiens_marque_stockage_temporaire()
        diffère { set_marque_stockage_temporaire(marque); }

        si SDL_PollEvent(@windowEvent) != 0 {
            si windowEvent.type == SDL_EventType.SDL_QUIT {
                arrête
            }

            si windowEvent.type == SDL_EventType.SDL_KEYDOWN {
                si windowEvent.key.keysym.scancode == SDL_Scancode.SDL_SCANCODE_UP {
                    caméra.y += 0.8 * temps_écoulé
                }

                si windowEvent.key.keysym.scancode == SDL_Scancode.SDL_SCANCODE_DOWN {
                    caméra.y -= 0.8 * temps_écoulé
                }

                si windowEvent.key.keysym.scancode == SDL_Scancode.SDL_SCANCODE_LEFT {
                    caméra.x += 0.8 * temps_écoulé
                }

                si windowEvent.key.keysym.scancode == SDL_Scancode.SDL_SCANCODE_RIGHT {
                    caméra.x -= 0.8 * temps_écoulé
                }

                si windowEvent.key.keysym.scancode == SDL_Scancode.SDL_SCANCODE_A {
                    yaw -= 2.0 * 0.016
                }

                si windowEvent.key.keysym.scancode == SDL_Scancode.SDL_SCANCODE_D {
                    yaw += 2.0 * 0.016
                }

                dyn temp_dir_avant := multiplie(dir_visé, 0.8 * temps_écoulé)

                si windowEvent.key.keysym.scancode == SDL_Scancode.SDL_SCANCODE_W {
                    caméra = ajoute(caméra, temp_dir_avant)
                }

                si windowEvent.key.keysym.scancode == SDL_Scancode.SDL_SCANCODE_S {
                    caméra = soustrait(caméra, temp_dir_avant)
                }
            }
        }

        //imprime("%\n\n", app)
        //imprime("Mémoire utilisée : %o\n\n", formatte_entier(mémoire_utilisée(), séparation=3))

        // dessine fenêtre

        glClear(0x00004000)

        //glClearColor(0.5, 0.5, 1.0, 1.0)

        remplis_image(@app.image, Couleur{ r = 0.0, v = 0.0, b = 0.0, a = 1.0 })

        mat_rot_x := matrice_rotation_x(theta * 0.5)
        mat_rot_z := matrice_rotation_z(theta)
        mat_rot := multiplie(mat_rot_x, mat_rot_z)
        mat_obj := multiplie(mat_rot, mat_trans)

        dir_haut := crée_vec3r(y = 1.0)
        dyn dir_cible := crée_vec3r(z = 1.0)
        mat_rot_cam := matrice_rotation_y(yaw)
        dir_visé = transforme(mat_rot_cam, dir_cible)
        dir_cible = ajoute(caméra, dir_visé)

        //imprime("cible : %\n", dir_cible)
        matrice_caméra := matrice_de_visé(@caméra, @dir_cible, @dir_haut)
        matrice_vue := inverse_matrice_sans_échelle(@matrice_caméra)

        // élimine les triangles invisibles
        dyn triangles_visible : []Triangle

        pour tri dans maillage.tris {
            dyn tri_transformé := transforme(mat_obj, tri)

            dyn line1 := soustrait(tri_transformé.p1, tri_transformé.p0)
            dyn line2 := soustrait(tri_transformé.p2, tri_transformé.p0)

            dyn nor := calcul_normal(line1, line2)

            // exclus le triangle s'il n'est pas visible
            si nor.z >= 0.0 {
                continue
            }

            dir_caméra := soustrait(tri_transformé.p0, caméra)

            cos_angle := produit_scalaire(vec_depuis_nor(nor), dir_caméra)

            si cos_angle >= 0.0 {
                continue
            }

            pousse_contexte contexte_temp {
                tableau_ajoute(@triangles_visible, tri_transformé)
            }
        }

        // tri des triangles pour les ordonner selon la distance à la caméra
        tri_sélection(triangles_visible)

        pour tri dans triangles_visible {
            dyn line1 := soustrait(tri.p1, tri.p0)
            dyn line2 := soustrait(tri.p2, tri.p0)

            dyn nor := calcul_normal_normalisé(line1, line2)

            dir_lumière := crée_vec3r(z = -1.0)
            // besoin de normalisation ?

            //dp := produit_scalaire(vec_depuis_nor(nor), dir_lumière)

            //couleur := Couleur{ r = dp, v = dp, b = dp, a = 1.0 }

            vnor := vec_depuis_nor(nor)

            uv := calcul_uv_capmat(@dir_visé, @vnor, faux)

            couleur := échantillonne_prochain(matcap, @uv)

            dyn tri_vue := transforme(matrice_vue, tri)

            dyn tri_projeté := transforme(mat_proj, tri_vue)

            // puisque le résultat est entre -1.0 et 1.0 nous devons le transformer pous qu'il soit dans les coordonnées de l'image
            tri_projeté.p0.x += 1.0
            tri_projeté.p0.y += 1.0

            tri_projeté.p1.x += 1.0
            tri_projeté.p1.y += 1.0

            tri_projeté.p2.x += 1.0
            tri_projeté.p2.y += 1.0

            tri_projeté.p0.x *= 0.5
            tri_projeté.p0.y *= 0.5

            tri_projeté.p1.x *= 0.5
            tri_projeté.p1.y *= 0.5

            tri_projeté.p2.x *= 0.5
            tri_projeté.p2.y *= 0.5

            ratisse_triangle(
                @app.image,
                tri_projeté.p0.x,
                tri_projeté.p0.y,
                tri_projeté.p1.x,
                tri_projeté.p1.y
                tri_projeté.p2.x,
                tri_projeté.p2.y,
                couleur);
        }

        génère_texture(app.tampon_texture, app.image.tampon, largeur, hauteur)

        dessine_tampon_texture(app.tampon_texture)

        SDL_GL_SwapWindow(window);

        theta += 1.0 * 0.016 //temps_écoulé

        delta := compte_ticks_ms() - début
        fps := 1000.0 / transtype(delta: r32)

        nouveau_titre := imprime_chaine("Moteur Rendu - % FPS", formatte_réel(fps, précision = 2))

        chn_c := chaine_c_temp(nouveau_titre)

        SDL_SetWindowTitle(window, chn_c)

        déloge nouveau_titre
    }

    retourne 0
}
