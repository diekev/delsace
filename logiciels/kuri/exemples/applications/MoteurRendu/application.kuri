charge "sdl2"
charge "dessin_texture"
charge "maillage"
charge "ratissage"

importe Couleur
importe Fondation
importe Image
importe OpenGL
importe Math

// ratissage basé sur le tutorial :
// https://www.youtube.com/watch?v=HXSuNxpCzdM : 43.33

// recherche sur ZBrush
// https://stackoverflow.com/questions/10414512/low-level-graphics-programming-and-zbrush

// ----------------------------------------------------------------------------

Application :: struct {
    hauteur : z32 = 0
    largeur : z32 = 0

    maillage : *Maillage
    tampon_texture : *TamponTexture

    image : Image
}

Caméra :: struct {
    position : Vec3r
    direction_vue : Vec3r
    yaw := 0.0
    mat_proj : Mat4r
    champs_de_vue := 90.0
    plan_proche := 0.1
    plan_éloigné := 1000.0
}

// ----------------------------------------------------------------------------

ratisse_maillage :: fonc (
    dyn caméra : *Caméra,
    maillage: *Maillage,
    image: *Image,
    matcap: *Image,
    theta: r32) -> rien
{
    dyn contexte_temp := contexte
    contexte_temp.allocatrice = __stockage_temporaire

    mat_trans := matrice_translation(z = 8.0)
    mat_rot_x := matrice_rotation_x(theta * 0.5)
    mat_rot_z := matrice_rotation_z(theta)
    mat_rot := multiplie(mat_rot_x, mat_rot_z)
    mat_obj := multiplie(mat_rot, mat_trans)

    dir_haut := crée_vec3r(y = 1.0)
    dyn dir_cible := crée_vec3r(z = 1.0)
    mat_rot_cam := matrice_rotation_y(caméra.yaw)
    caméra.direction_vue = transforme(mat_rot_cam, dir_cible)
    dir_cible = ajoute(caméra.position, caméra.direction_vue)

    //imprime("cible : %\n", dir_cible)
    matrice_caméra := matrice_de_visé(@caméra.position, @dir_cible, @dir_haut)
    matrice_vue := inverse_matrice_sans_échelle(@matrice_caméra)

    // élimine les triangles invisibles
    dyn triangles_visible : []Triangle

    pour tri dans maillage.tris {
        dyn tri_transformé := transforme(mat_obj, tri)

        dyn line1 := soustrait(tri_transformé.p1, tri_transformé.p0)
        dyn line2 := soustrait(tri_transformé.p2, tri_transformé.p0)

        dyn nor := calcul_normal(line1, line2)

        // exclus le triangle s'il n'est pas visible
        si nor.z >= 0.0 {
            continue
        }

        dir_caméra := soustrait(tri_transformé.p0, caméra.position)

        cos_angle := produit_scalaire(vec_depuis_nor(nor), dir_caméra)

        si cos_angle >= 0.0 {
            continue
        }

        pousse_contexte contexte_temp {
            tableau_ajoute(@triangles_visible, tri_transformé)
        }
    }

    // tri des triangles pour les ordonner selon la distance à la caméra
    tri_sélection(triangles_visible)

    pour tri dans triangles_visible {
        dyn line1 := soustrait(tri.p1, tri.p0)
        dyn line2 := soustrait(tri.p2, tri.p0)

        dyn nor := calcul_normal_normalisé(line1, line2)

        dir_lumière := crée_vec3r(z = -1.0)
        // besoin de normalisation ?

        //dp := produit_scalaire(vec_depuis_nor(nor), dir_lumière)

        //couleur := Couleur{ r = dp, v = dp, b = dp, a = 1.0 }

        vnor := vec_depuis_nor(nor)

        uv := calcul_uv_capmat(@caméra.direction_vue, @vnor, faux)

        couleur := échantillonne_prochain(matcap, @uv)

        dyn tri_vue := transforme(matrice_vue, tri)

        dyn tri_projeté := transforme(caméra.mat_proj, tri_vue)

        // puisque le résultat est entre -1.0 et 1.0 nous devons le transformer pous qu'il soit dans les coordonnées de l'image
        tri_projeté.p0.x += 1.0
        tri_projeté.p0.y += 1.0

        tri_projeté.p1.x += 1.0
        tri_projeté.p1.y += 1.0

        tri_projeté.p2.x += 1.0
        tri_projeté.p2.y += 1.0

        tri_projeté.p0.x *= 0.5
        tri_projeté.p0.y *= 0.5

        tri_projeté.p1.x *= 0.5
        tri_projeté.p1.y *= 0.5

        tri_projeté.p2.x *= 0.5
        tri_projeté.p2.y *= 0.5

        ratisse_triangle(
            image,
            tri_projeté.p0.x,
            tri_projeté.p0.y,
            tri_projeté.p1.x,
            tri_projeté.p1.y
            tri_projeté.p2.x,
            tri_projeté.p2.y,
            couleur);
    }
}

// ----------------------------------------------------------------------------

Rayon :: struct {
    origine : Vec3r
    direction : Vec3r
}

// http://docs.pixologic.com/getting-started/basic-concepts/the-pixol/
Pixol :: struct {
    // position sur le cannevas
    x : z32
    y : z32

    // couleur
    r : r32
    v : r32
    b : r32

    // profondeur
    p : r32

    // orientation ? quaternion ? normal ?
    o : Vec3r

    // matériau
    m : z32
}

entresecte_triangle :: fonc (
		vertex0: Vec3r,
		vertex1: Vec3r,
		vertex2: Vec3r,
		rayon: *Rayon,
		dyn distance: *r32,
		dyn r_u : *r32,
		dyn r_v : *r32) -> bool
{
	epsilon := 0.000001

	cote1 := soustrait(vertex1, vertex0)
	cote2 := soustrait(vertex2, vertex0)
	h := produit_vectoriel(@rayon.direction, @cote2)
	angle := produit_scalaire(cote1, h)

	si (angle > -epsilon && angle < epsilon) {
		retourne faux
	}

	f := 1.0 / angle
	s := soustrait(rayon.origine, vertex0)
	angle_u := f * produit_scalaire(s, h)

	si (angle_u < 0.0 || angle_u > 1.0) {
		retourne faux
	}

	q := produit_vectoriel(@s, @cote1);
	angle_v := f * produit_scalaire(rayon.direction, q)

	si (angle_v < 0.0 || angle_u + angle_v > 1.0) {
		retourne faux
	}

	// À cette étape on peut calculer t pour trouver le point d'entresection sur
	// la ligne.
	t := f * produit_scalaire(cote2, q)

	// Entresection avec le rayon.
	si (t > epsilon) {
		mémoire(distance) = t

		si r_u != nul {
			mémoire(r_u) = angle_u
		}

		si r_v != nul {
			mémoire(r_v) = angle_v
		}

		retourne vrai
	}

	// Cela veut dire qu'il y a une entresection avec une ligne, mais pas avec
	// le rayon.
	retourne faux
}

// pas de rebond, pas d'anti-aliasing, simplement un traçage direct, pour avoir
// un rendu plus rapide du résultat, le matériau est une capmat
trace_maillage :: fonc (caméra : *Caméra, maillage : *Maillage, image: *Image) -> rien
{
    pour i dans 0 ... image.hauteur - 1 {
        pour j dans 0 ... image.largeur - 1 {
            // génère rayon
            dyn rayon : Rayon

            dyn distance_min := 1000.0

            pour tri dans maillage.tris {
                distance := 0.0
                touché := entresecte_triangle(tri.p0, tri.p1, tri.p2, @rayon, @distance, nul, nul)

                si distance < distance_min {
                    distance_min = distance
                }
            }
        }
    }
}

// ----------------------------------------------------------------------------

principale :: fonc () -> z32
{
	diffère {
	    imprime_sans_format("Fin du programme, mémoire utilisée : ", mémoire_utilisée(), "o\n")
	}

    SDL_Init(DrapeauxInit.SDL_INIT_EVERYTHING);
    diffère { SDL_Quit(); }

    SDL_GL_SetAttribute(SDL_GLattr.SDL_GL_CONTEXT_PROFILE_MASK, 1);
    SDL_GL_SetAttribute(SDL_GLattr.SDL_GL_CONTEXT_MAJOR_VERSION, 4);
    SDL_GL_SetAttribute(SDL_GLattr.SDL_GL_CONTEXT_MINOR_VERSION, 0);
    SDL_GL_SetAttribute(SDL_GLattr.SDL_GL_STENCIL_SIZE, 8);

    dyn largeur : z32 = 640
    dyn hauteur : z32 = 480

    titre := "Moteur Rendu"

    window := SDL_CreateWindow(titre.pointeur, 100, 100, largeur, hauteur, SDL_WindowFlags.SDL_WINDOW_OPENGL);

    context := SDL_GL_CreateContext(window);
    diffère { SDL_GL_DeleteContext(context); }

    si !initialise_opengl() {
        imprime("Erreur lors de l'initilisation de GLEW !\n")
        retourne 1
    }

    // initialise l'application
    dyn app : Application
    app.hauteur = hauteur
    app.largeur = largeur

    app.image = crée_image(largeur, hauteur)
    diffère { détruit_image(@app.image); }

    matcap := charge_image_png("/home/kevin/Images/matcap.png")

    diffère {
        détruit_image(matcap)
        déloge matcap
    }

    app.tampon_texture = crée_tampon_texture()
    diffère { détruit_tampon_texture(app.tampon_texture); }

    maillage := charge_maillage_depuis_obj("/home/kevin/fichiers/objs/VideoShip.obj")
    diffère { détruit_maillage(maillage); }

    app.maillage = maillage

    dyn windowEvent : SDL_Event;

    dyn theta := 0.0

    dyn caméra : Caméra
    caméra.position = crée_vec3r()
    caméra.direction_vue = crée_vec3r(z = 1.0)
    caméra.yaw = 0.0
    caméra.mat_proj = matrice_projection(
        caméra.champs_de_vue,
        transtype(largeur: r32),
        transtype(hauteur: r32),
        caméra.plan_proche,
        caméra.plan_éloigné)

    temps_écoulé := 1.0

    boucle {
        dyn début := compte_ticks_ms()

        marque := obtiens_marque_stockage_temporaire()
        diffère { set_marque_stockage_temporaire(marque); }

        si SDL_PollEvent(@windowEvent) != 0 {
            si windowEvent.type == SDL_EventType.SDL_QUIT {
                arrête
            }

            si windowEvent.type == SDL_EventType.SDL_KEYDOWN {
                si windowEvent.key.keysym.scancode == SDL_Scancode.SDL_SCANCODE_UP {
                    caméra.position.y += 0.8 * temps_écoulé
                }

                si windowEvent.key.keysym.scancode == SDL_Scancode.SDL_SCANCODE_DOWN {
                    caméra.position.y -= 0.8 * temps_écoulé
                }

                si windowEvent.key.keysym.scancode == SDL_Scancode.SDL_SCANCODE_LEFT {
                    caméra.position.x += 0.8 * temps_écoulé
                }

                si windowEvent.key.keysym.scancode == SDL_Scancode.SDL_SCANCODE_RIGHT {
                    caméra.position.x -= 0.8 * temps_écoulé
                }

                si windowEvent.key.keysym.scancode == SDL_Scancode.SDL_SCANCODE_A {
                    caméra.yaw -= 2.0 * 0.016
                }

                si windowEvent.key.keysym.scancode == SDL_Scancode.SDL_SCANCODE_D {
                    caméra.yaw += 2.0 * 0.016
                }

                dyn temp_dir_avant := multiplie(caméra.direction_vue, 0.8 * temps_écoulé)

                si windowEvent.key.keysym.scancode == SDL_Scancode.SDL_SCANCODE_W {
                    caméra.position = ajoute(caméra.position, temp_dir_avant)
                }

                si windowEvent.key.keysym.scancode == SDL_Scancode.SDL_SCANCODE_S {
                    caméra.position = soustrait(caméra.position, temp_dir_avant)
                }
            }
        }

        //imprime("%\n\n", app)
        //imprime("Mémoire utilisée : %o\n\n", formatte_entier(mémoire_utilisée(), séparation=3))

        // dessine fenêtre

        glClear(0x00004000)

        //glClearColor(0.5, 0.5, 1.0, 1.0)

        remplis_image(@app.image, Couleur{ r = 0.0, v = 0.0, b = 0.0, a = 1.0 })

        ratisse_maillage(@caméra, maillage, @app.image, matcap, theta)

        génère_texture(app.tampon_texture, app.image.tampon, largeur, hauteur)

        dessine_tampon_texture(app.tampon_texture)

        SDL_GL_SwapWindow(window);

        theta += 1.0 * 0.016 //temps_écoulé

        delta := compte_ticks_ms() - début
        fps := 1000.0 / transtype(delta: r32)

        nouveau_titre := imprime_chaine("Moteur Rendu - % FPS", formatte_réel(fps, précision = 2))

        chn_c := chaine_c_temp(nouveau_titre)

        SDL_SetWindowTitle(window, chn_c)

        déloge nouveau_titre
    }

    retourne 0
}
