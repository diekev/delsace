importe Math

Triangle :: struct {
    p0 : Vec3
    p1 : Vec3
    p2 : Vec3
}

calcul_normal :: fonc (triangle: Triangle) -> Norm3
{
    ligne1 := triangle.p1 - triangle.p0
    ligne2 := triangle.p2 - triangle.p0
    retourne calcul_normal(ligne1, ligne2)
}

calcul_normal_normalisé :: fonc (triangle: Triangle) -> Norm3
{
    ligne1 := triangle.p1 - triangle.p0
    ligne2 := triangle.p2 - triangle.p0
    retourne calcul_normal_normalisé(ligne1, ligne2)
}

crée_triangle :: fonc (p0 : Vec3, p1 : Vec3, p2 : Vec3) -> Triangle
{
    tri : Triangle
    tri.p0 = p0
    tri.p1 = p1
    tri.p2 = p2

    retourne tri
}

calcul_boite_englobante :: fonc (triangles: []Triangle) -> (Vec3, Vec3)
{
    min_boite := crée_vec3r(x =  100000000.0, y =  100000000.0, z =  100000000.0)
    max_boite := crée_vec3r(x = -100000000.0, y = -100000000.0, z = -100000000.0)

    pour tri dans triangles {
        min_max(*tri.p0, *min_boite, *max_boite)
        min_max(*tri.p1, *min_boite, *max_boite)
        min_max(*tri.p2, *min_boite, *max_boite)
    }

    retourne min_boite, max_boite
}

transforme :: fonc (mat: Mat4r, tri: Triangle) -> Triangle #enligne
{
    rés : Triangle

    rés.p0 = transforme(mat, tri.p0)
    rés.p1 = transforme(mat, tri.p1)
    rés.p2 = transforme(mat, tri.p2)

    retourne rés
}

centre_triangle :: fonc (tri: *Triangle) -> Vec3
{
    retourne divise(ajoute(ajoute(tri.p0, tri.p1), tri.p2), 3.0)
}

compare_triangles_selon_axe_z :: fonc (tri1: Triangle, tri2: Triangle) -> bool
{
    z1 := (tri1.p0.z + tri1.p1.z + tri1.p2.z) / 3.0
    z2 := (tri2.p0.z + tri2.p1.z + tri2.p2.z) / 3.0

    retourne z2 < z1
}
