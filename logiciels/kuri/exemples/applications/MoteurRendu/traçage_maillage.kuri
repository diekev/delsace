importe Fondation
importe Math
importe Image

Rayon :: struct {
    origine : Vec3
    direction : Vec3
    direction_inverse : Vec3
}

// http://docs.pixologic.com/getting-started/basic-concepts/the-pixol/
Pixol :: struct {
    // position sur le cannevas
    x : z32
    y : z32

    // couleur
    r : r32
    v : r32
    b : r32

    // profondeur
    p : r32

    // orientation ? quaternion ? normal ?
    o : Vec3

    // matériau
    m : z32
}

entresecte_triangle :: fonc (
		vertex0: Vec3,
		vertex1: Vec3,
		vertex2: Vec3,
		rayon: *Rayon,
		distance: *r32,
		r_u : *r32,
		r_v : *r32) -> bool
{
	epsilon := 0.000001

	cote1 := vertex1 - vertex0
	cote2 := vertex2 - vertex0
	h := produit_vectoriel(*rayon.direction, *cote2)
	angle := produit_scalaire(cote1, h)

	si (angle > -epsilon && angle < epsilon) {
		retourne faux
	}

	f := 1.0 / angle
	s := rayon.origine - vertex0
	angle_u := f * produit_scalaire(s, h)

	si (angle_u < 0.0 || angle_u > 1.0) {
		retourne faux
	}

	q := produit_vectoriel(*s, *cote1);
	angle_v := f * produit_scalaire(rayon.direction, q)

	si (angle_v < 0.0 || angle_u + angle_v > 1.0) {
		retourne faux
	}

	// À cette étape on peut calculer t pour trouver le point d'entresection sur
	// la ligne.
	t := f * produit_scalaire(cote2, q)

	// Entresection avec le rayon.
	si (t > epsilon) {
		mémoire(distance) = t

		si r_u != nul {
			mémoire(r_u) = angle_u
		}

		si r_v != nul {
			mémoire(r_v) = angle_v
		}

		retourne vrai
	}

	// Cela veut dire qu'il y a une entresection avec une ligne, mais pas avec
	// le rayon.
	retourne faux
}

entresection_rapide_min_max :: fonc (
		r: *Rayon,
		min_boite: *Vec3,
		max_boite: *Vec3) -> r32
{
	//si est_supérieur_ou_égal(r.origine, mémoire(min_boite)) && est_inférieur_ou_égal(r.origine, mémoire(max_boite)) {
	//	retourne 0.0
	//}

	t1 := (min_boite.x - r.origine.x) * r.direction_inverse.x;
	t2 := (max_boite.x - r.origine.x) * r.direction_inverse.x;

	tmin := min(t1, t2);
	tmax := max(t1, t2);

    t1 = (min_boite.x - r.origine.x) * r.direction_inverse.x;
    t2 = (max_boite.x - r.origine.x) * r.direction_inverse.x;

    tmin = max(tmin, min(t1, t2));
    tmax = min(tmax, max(t1, t2));

    t1 = (min_boite.y - r.origine.y) * r.direction_inverse.y;
    t2 = (max_boite.y - r.origine.y) * r.direction_inverse.y;

    tmin = max(tmin, min(t1, t2));
    tmax = min(tmax, max(t1, t2));

    t1 = (min_boite.z - r.origine.z) * r.direction_inverse.z;
    t2 = (max_boite.z - r.origine.z) * r.direction_inverse.z;

    tmin = max(tmin, min(t1, t2));
    tmax = min(tmax, max(t1, t2));

	/* pour retourner une valeur booléenne : return tmax > max(tmin, 0.0); */

	si (tmax < 0.0 || tmin > tmax) {
		retourne -1.0;
	}

	retourne tmin;
}

min_max :: fonc (v: *Vec3, min_boite: *Vec3, max_boite: *Vec3) -> rien
{
    si v.x < min_boite.x {
        min_boite.x = v.x
    }
    sinon si v.x > max_boite.x {
        max_boite.x = v.x
    }

    si v.y < min_boite.y {
        min_boite.y = v.y
    }
    sinon si v.y > max_boite.y {
        max_boite.y = v.y
    }

    si v.z < min_boite.z {
        min_boite.z = v.z
    }
    sinon si v.z > max_boite.z {
        max_boite.z = v.z
    }
}

// --------------------------------------------------------------

entresecte_triangles :: fonc (triangles_visible: []Triangle, rayon: Rayon) -> z32
{
    distance_min := 1000.0
    idx_triangle := -1

    pour tri, idx dans triangles_visible {
        distance := 0.0
        touché := entresecte_triangle(tri.p0, tri.p1, tri.p2, *rayon, *distance, nul, nul)

        si distance < distance_min {
            distance_min = distance
        }

        si touché {
            idx_triangle = idx comme z32
        }
    }

    retourne idx_triangle
}

// --------------------------------------------------------------

initialise_moteur_rendu_traçage :: fonc (moteur: *MoteurRendu)
{
    moteur.rends = trace_maillage
}

// --------------------------------------------------------------

// pas de rebond, pas d'anti-aliasing, simplement un traçage direct, pour avoir
// un rendu plus rapide du résultat, le matériau est une capmat
trace_maillage :: fonc (moteur: *MoteurRendu, image: *Image.Image) -> rien
{
    caméra := moteur.caméra
    maillage := moteur.maillage
    mat_obj := maillage.matrice

    triangles_visible : []Triangle
    diffère déloge(triangles_visible)

    pour tri dans maillage.tris {
        tri_transformé := transforme(mat_obj, tri)
        tableau_ajoute(*triangles_visible, tri_transformé)
    }

    min_boite, max_boite := calcul_boite_englobante(triangles_visible)

    /* Mis en tampon de certaines valeurs. */
    largeur_inverse := 1.0 / caméra.largeur comme r32
    hauteur_inverse := 1.0 / caméra.hauteur comme r32
    aspect := caméra.aspect
    échelle := caméra.échelle
    caméra_vers_monde := caméra.caméra_vers_monde

    données_nuançage: DonnéesPourNuançage
    données_nuançage.matcap = moteur.matcap
    données_nuançage.direction_vue = caméra.direction_vue

    pour j dans 0 ... image.hauteur - 1 {
        pour i dans 0 ... image.largeur - 1 {
            /*
            x := (transtype(i: r32) * largeur_inverse)
            y := (transtype(image.hauteur - j: r32) * hauteur_inverse)

            pos_pixel := Vec2r{ x = x, y = y }

            direction := direction_via_pixel(caméra, @pos_pixel)
            */

            x := (2.0 * (i comme r32 + 0.5) * largeur_inverse - 1.0) * aspect * échelle
            y := (1.0 - 2.0 * (j comme r32 + 0.5) * hauteur_inverse) * échelle

            pos := crée_vec3r(x, y, -1.0)

            direction := transforme(caméra_vers_monde, pos)

            rayon : Rayon
            rayon.origine = caméra.position
            rayon.direction = direction // normalise(@direction)
            rayon.direction_inverse.x = 1.0 / direction.x
            rayon.direction_inverse.y = 1.0 / direction.y
            rayon.direction_inverse.z = 1.0 / direction.z

            d := entresection_rapide_min_max(*rayon, *min_boite, *max_boite)

            si d < -0.5 {
                continue
            }

            idx_triangle := entresecte_triangles(triangles_visible, rayon)

            si idx_triangle == -1 {
                continue
            }

            tri := triangles_visible[idx_triangle]

            données_nuançage.normal = calcul_normal_normalisé(tri)
            couleur := moteur.nuanceur(données_nuançage)

            image.tampon[j * image.largeur + i] = couleur
        }
    }
}
