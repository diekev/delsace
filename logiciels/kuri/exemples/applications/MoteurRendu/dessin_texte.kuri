importe Couleur
importe FTGL
importe Math
importe OpenGL

RendeuseTexte :: struct {
    hauteur := 0
    largeur := 0
    décalage := 0
    taille_police := 0

    tampon : *rien

    altas : *texture_atlas_t
    font : *texture_font_t
}

détruit_rendeuse_texte :: fonc (dyn rendeuse: *RendeuseTexte) -> rien
{
    texture_atlas_delete(rendeuse.atlas)
    texture_font_delete(rendeuse.font)
}

crée_tampon :: fonc (dyn rendeuse: *RendeuseTexte) -> rien
{

}

dessine_texte :: fonc (dyn rendeuse: *RendeuseTexte, texte: chaine) -> rien
{
    chemin_fonte := "/usr/share/fonts/truetype/dejavu/DejaVuSansMono.ttf"

    // À FAIRE : passe la couleur
    blanc := vec4{ x = 1.0, y = 1.0, z = 1.0, w = 1.0 }
    noir  := vec4{ x = 0.0, y = 0.0, z = 0.0, w = 1.0 }
    none := blanc

    dyn markup : markup_t
	markup.family  = chemin_fonte.pointeur
	markup.size    = transtype(rendeuse.taille_police: r32)
	markup.bold    = 0
	markup.italic  = 0
	markup.spacing = 0.0
	markup.gamma   = 1.5
	markup.foreground_color    = blanc
	markup.background_color    = none
	markup.underline           = 0
	markup.underline_color     = blanc
	markup.overline            = 0
	markup.overline_color      = blanc
	markup.strikethrough       = 0
	markup.strikethrough_color = blanc

    si rendeuse.tampon == nul {
		crée_tampon(rendeuse)
		rendeuse.atlas = texture_atlas_new(512, 512, 1)
		rendeuse.font = texture_font_new_from_file(rendeuse.atlas, markup.size, markup.family)
	}

	markup.font = rendeuse.font

	pos := Vec2r{ x = 8.0, y = 8.0 + transtype(rendeuse.decalage: r32) }
	taille := Vec2r{ x = transtype(rendeuse.largeur: r32), y = transtype(rendeuse.hauteur: r32) }

	markup.foreground_color = noir
	markup.font.rendermode = rendermode_t.RENDER_OUTLINE_EDGE
	markup.font.outline_thickness = 0.2

	dessine_lettres(rendeuse.tampon, texte, rendeuse.atlas, @markup, pos, taille)

	markup.foreground_color = blanc
	markup.font.rendermode = rendermode_t.RENDER_NORMAL

	dessine_lettres(rendeuse.tampon, texte, rendeuse.atlas, @markup, pos, taille)

	rendeuse.decalage += transtype(rendeuse.taille_police: r32)
}

dessine_lettres :: fonc (tampon: *rien, texte: chaine, altas: *texture_atlas_t, markup: *markup_t, pos: Vec2r, taille: Vec2r) -> rien
{
    dyn pen := vec2{ x = pos.x, y = taille.y - pos.y - 16.0 }

	dyn sommets : []Vec2r
	dyn uvs : []Vec2r
	dyn couleurs : []Couleur
	dyn indices : []z32

    diffère {
        déloge sommets
        déloge uvs
        déloge couleurs
        déloge indices
    }

    dyn couleur := Couleur { r = markup.foreground_color.r, v = markup.foreground_color.g, b = markup.foreground_color.b, a = markup.foreground_color.a }

	inv_taille := Vec2r{ x = 1.0 / taille.x, y = 1.0 / taille.y }

    dyn dernier_caractère : *z8 = nul

    pour c dans texte {
		glyph := texture_font_get_glyph(markup.font, @c)

		si glyph == nul {
			continue
		}

		dyn kerning := 0.0

		si dernier_caractère != nul {
			kerning = texture_glyph_get_kerning(glyph, dernier_caractère)
		}

		pen.x += kerning
		x0 := (pen.x + transtype(glyph.offset_x: r32)) * inv_taille.x
		y0 := (pen.y + transtype(glyph.offset_y: r32)) * inv_taille.y
		x1 := (x0 + transtype(glyph.width: r32)) * inv_taille.x
		y1 := (y0 - transtype(glyph.height: r32)) * inv_taille.y
		s0 := glyph.s0;
		t0 := glyph.t0;
		s1 := glyph.s1;
		t1 := glyph.t1;

		decalage_index := transtype(sommets.taille: z32)
		tableau_ajoute(@indices, 0 + decalage_index)
		tableau_ajoute(@indices, 1 + decalage_index)
		tableau_ajoute(@indices, 2 + decalage_index)
		tableau_ajoute(@indices, 0 + decalage_index)
		tableau_ajoute(@indices, 2 + decalage_index)
		tableau_ajoute(@indices, 3 + decalage_index)

		tableau_ajoute(@sommets, Vec2r{ x = x0, y = y0 })
		tableau_ajoute(@sommets, Vec2r{ x = x0, y = y1 })
		tableau_ajoute(@sommets, Vec2r{ x = x1, y = y1 })
		tableau_ajoute(@sommets, Vec2r{ x = x1, y = y0 })

		tableau_ajoute(@uvs, Vec2r{ x = s0, y = t0 })
		tableau_ajoute(@uvs, Vec2r{ x = s0, y = t1 })
		tableau_ajoute(@uvs, Vec2r{ x = s1, y = t1 })
		tableau_ajoute(@uvs, Vec2r{ x = s1, y = t0 })

        tableau_ajoute(@couleurs, couleur)
        tableau_ajoute(@couleurs, couleur)
        tableau_ajoute(@couleurs, couleur)
        tableau_ajoute(@couleurs, couleur)

		pen.x += glyph.advance_x

        dernier_caractère = @c
	}

    // --------------------------------------

	auto params_tampon = ParametresTampon{};
	params_tampon.attribut = "vertex";
	params_tampon.dimension_attribut = 2;
	params_tampon.pointeur_sommets = sommets.data();
	params_tampon.taille_octet_sommets = sizeof(dls::math::vec2f) * sommets.size();
	params_tampon.elements = indices.size();
	params_tampon.pointeur_index = indices.data();
	params_tampon.taille_octet_index = sizeof(unsigned int) * indices.size();

	tampon.remplie_tampon(params_tampon);

    // --------------------------------------

	params_tampon.attribut = "tex_coord";
	params_tampon.dimension_attribut = 2;
	params_tampon.pointeur_donnees_extra = uvs.data();
	params_tampon.taille_octet_donnees_extra = sizeof(dls::math::vec2f) * uvs.size();

	tampon.remplie_tampon_extra(params_tampon);

    // --------------------------------------

	params_tampon.attribut = "color";
	params_tampon.dimension_attribut = 4;
	params_tampon.pointeur_donnees_extra = colors.data();
	params_tampon.taille_octet_donnees_extra = sizeof(dls::math::vec4f) * colors.size();

	tampon.remplie_tampon_extra(params_tampon);

    // --------------------------------------

	si atlas = nul {
		imprime("L'atlas est nul !\n")
	}
	sinon si atlas.data == nul {
		imprime("Les données de l'atlas sont nuls !\n")
	}

	glGenTextures(1, @atlas.id )
	glBindTexture(_GL_TEXTURE_2D, atlas.id)
	glTexParameteri(_GL_TEXTURE_2D, _GL_TEXTURE_WRAP_S, _GL_CLAMP_TO_EDGE );
	glTexParameteri(_GL_TEXTURE_2D, _GL_TEXTURE_WRAP_T, _GL_CLAMP_TO_EDGE );
	glTexParameteri(_GL_TEXTURE_2D, _GL_TEXTURE_MAG_FILTER, _GL_LINEAR );
	glTexParameteri(_GL_TEXTURE_2D, _GL_TEXTURE_MIN_FILTER, _GL_LINEAR );

    glTexImage2D(_GL_TEXTURE_2D, 0, _GL_RED, transtype(atlas.width: z32), transtype(atlas.height: z32),
				  0, _GL_RED, _GL_UNSIGNED_BYTE, atlas.data )

	{
		auto programme = tampon.programme();

		if (!programme->est_valide()) {
			std::cerr << "Programme invalide !\n";
			return;
		}

		//dls::ego::util::GPU_check_errors("Erreur lors du rendu du tampon avant utilisation programme");

		programme->active();

		programme->uniforme("atlas", 0);

		tampon.donnees()->attache();
		//tampon.texture()->attache();

		//		numero7::ego::util::GPU_check_errors("Erreur lors du rendu du tampon après attache texture");

		mat4   model, view, projection;
		mat4_set_identity(&projection);
		mat4_set_identity(&model);
		mat4_set_identity(&view);
		glUniformMatrix4fv((*programme)("MVP"), 1, 0, model.data);
		glUniformMatrix4fv((*programme)("matrice"), 1, 0, view.data);
		//glUniformMatrix4fv((*programme)("projection"), 1, 0, projection.data);

		glDrawElements(_GL_TRIANGLES, transtype(indices.taille: z32), _GL_UNSIGNED_INT, nul);

		//		numero7::ego::util::GPU_check_errors("Erreur lors du rendu du tampon après dessin indexé");

		//tampon.texture()->detache();
		tampon.donnees()->detache();

        glUseProgramme(0)
	}

	glDeleteTextures(1, @atlas.id)
}
