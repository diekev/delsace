importe Fondation
importe Math
importe Image

ratisse_maillage :: fonc (
    caméra : *Caméra3D,
    maillage: *Maillage,
    image: *Image.Image,
    matcap: *Image.Image,
    theta: r32) -> rien
{
    marque := obtiens_marque_stockage_temporaire()
    diffère { set_marque_stockage_temporaire(marque) }

    ticks := compte_ticks_ms()

    diffère {
        temps_rendu := compte_ticks_ms() - ticks
        temps_rendu_us := temps_rendu * 1000
        temps_par_pixel := temps_rendu_us / (image.largeur * image.hauteur)
        temps_par_polygone := temps_rendu_us / (maillage.tris.taille)

        imprime(
            "Temps de rendu : %ms (par pixel %us, par polygone %us)\n",
            FormatEntier(valeur = temps_rendu, séparation = 3),
            FormatEntier(valeur = temps_par_pixel, séparation = 3),
            FormatEntier(valeur = temps_par_polygone, séparation = 3))
    }

    contexte_temp := contexte()
    contexte_temp.allocatrice = __stockage_temporaire

    mat_trans := matrice_translation(z = 8.0)
    mat_rot_x := matrice_rotation_x(theta * 0.5)
    mat_rot_z := matrice_rotation_z(theta)
    mat_rot := multiplie(mat_trans, mat_rot_z)
    mat_obj := mat_trans // multiplie(mat_rot, mat_rot_x)

    dir_haut := crée_vec3r(y = 1.0)
    dir_cible := crée_vec3r(z = 1.0)
    mat_rot_cam := matrice_rotation_y(caméra.yaw)
    caméra.direction_vue = transforme(mat_rot_cam, dir_cible)
    dir_cible = caméra.position + caméra.direction_vue

    //imprime("cible : %\n", dir_cible)
    matrice_caméra := matrice_de_visé(*caméra.position, *dir_cible, *dir_haut)
    matrice_vue := inverse(*matrice_caméra)

    // élimine les triangles invisibles
    triangles_visible : []Triangle

    pour tri dans maillage.tris {
        tri_transformé := transforme(mat_obj, tri)

        line1 := tri_transformé.p1 - tri_transformé.p0
        line2 := tri_transformé.p2 - tri_transformé.p0

        nor := calcul_normal(line1, line2)

        // exclus le triangle s'il n'est pas visible
        si nor.z >= 0.0 {
            continue
        }

        dir_caméra := tri_transformé.p0 - caméra.position

        cos_angle := produit_scalaire(vec_depuis_nor(nor), dir_caméra)

        si cos_angle >= 0.0 {
            continue
        }

        pousse_contexte contexte_temp {
            tableau_ajoute(*triangles_visible, tri_transformé)
        }
    }

    // tri des triangles pour les ordonner selon la distance à la caméra
    tri_sélection(triangles_visible)

    caméra_vers_rateau := construit_identité_mat4r()
    //caméra_vers_rateau = multiplie(caméra_vers_rateau, matrice_échelle(0.5, 0.5, 0.0))
    //caméra_vers_rateau = multiplie(caméra_vers_rateau, matrice_translation(1.0, 1.0, 0.0))

    caméra_vers_rateau.m[0][0] = 0.5
    caméra_vers_rateau.m[1][1] = 0.5
    caméra_vers_rateau.m[3][0] = 0.5
    caméra_vers_rateau.m[3][1] = 0.5

    pour tri dans triangles_visible {
        line1 := tri.p1 - tri.p0
        line2 := tri.p2 - tri.p0

        nor := calcul_normal_normalisé(line1, line2)

        dir_lumière := crée_vec3r(z = -1.0)
        // besoin de normalisation ?

        //dp := produit_scalaire(vec_depuis_nor(nor), dir_lumière)

        //couleur := Couleur{ r = dp, v = dp, b = dp, a = 1.0 }

        vnor := vec_depuis_nor(nor)

        uv := calcul_uv_capmat(*caméra.direction_vue, *vnor, faux)

        couleur := échantillonne_prochain(matcap, *uv)

        tri_vue := transforme(matrice_vue, tri)

        tri_projeté := transforme(caméra.projection, tri_vue)

        // puisque le résultat est entre -1.0 et 1.0 nous devons le transformer pous qu'il soit dans les coordonnées de l'image
        tri_projeté = transforme(caméra_vers_rateau, tri_projeté)

        ratisse_triangle(
            image,
            tri_projeté.p0.x,
            tri_projeté.p0.y,
            tri_projeté.p1.x,
            tri_projeté.p1.y
            tri_projeté.p2.x,
            tri_projeté.p2.y,
            couleur);
    }
}
