importe Couleur
importe Fondation
importe Math
importe Image

// --------------------------------------------------------------

initialise_moteur_rendu_ratissage :: fonc (moteur: *MoteurRendu)
{
    moteur.rends = rends_ratissage
}

// --------------------------------------------------------------

rends_ratissage :: fonc (moteur: *MoteurRendu, image: *Image.Image)
{
    caméra := moteur.caméra
    maillage := moteur.maillage
    theta := 1.0

    contexte_temp := contexte()
    contexte_temp.allocatrice = __stockage_temporaire

    mat_trans := matrice_translation(z = 8.0)
    mat_rot_x := matrice_rotation_x(theta * 0.5)
    mat_rot_z := matrice_rotation_z(theta)
    mat_rot := multiplie(mat_trans, mat_rot_z)
    mat_obj := mat_trans // multiplie(mat_rot, mat_rot_x)

    dir_haut := crée_vec3r(y = 1.0)
    dir_cible := crée_vec3r(z = 1.0)
    mat_rot_cam := matrice_rotation_y(caméra.yaw)
    caméra.direction_vue = transforme(mat_rot_cam, dir_cible)
    dir_cible = caméra.position + caméra.direction_vue

    //imprime("cible : %\n", dir_cible)
    matrice_caméra := matrice_de_visé(*caméra.position, *dir_cible, *dir_haut)
    matrice_vue := inverse(*matrice_caméra)

    données_nuançage: DonnéesPourNuançage
    données_nuançage.matcap = moteur.matcap
    données_nuançage.direction_vue = caméra.direction_vue

    // élimine les triangles invisibles
    triangles_visible : []Triangle

    pour tri dans maillage.tris {
        tri_transformé := transforme(mat_obj, tri)

        line1 := tri_transformé.p1 - tri_transformé.p0
        line2 := tri_transformé.p2 - tri_transformé.p0

        nor := calcul_normal(line1, line2)

        // exclus le triangle s'il n'est pas visible
        si nor.z >= 0.0 {
            continue
        }

        dir_caméra := tri_transformé.p0 - caméra.position

        cos_angle := produit_scalaire(vec_depuis_nor(nor), dir_caméra)

        si cos_angle >= 0.0 {
            continue
        }

        pousse_contexte contexte_temp {
            tableau_ajoute(*triangles_visible, tri_transformé)
        }
    }

    // tri des triangles pour les ordonner selon la distance à la caméra
    tri_sélection(triangles_visible)

    caméra_vers_rateau := construit_identité_mat4r()
    caméra_vers_rateau = multiplie(caméra_vers_rateau, matrice_échelle(0.5, 0.5, 0.0))
    caméra_vers_rateau = multiplie(caméra_vers_rateau, matrice_translation(1.0, 1.0, 0.0))

    pour tri dans triangles_visible {
        line1 := tri.p1 - tri.p0
        line2 := tri.p2 - tri.p0

        nor := calcul_normal_normalisé(line1, line2)

        données_nuançage.normal = nor
        couleur := moteur.nuanceur(données_nuançage)

        tri_vue := transforme(matrice_vue, tri)
        tri_projeté := transforme(caméra.projection, tri_vue)

        // puisque le résultat est entre -1.0 et 1.0 nous devons le transformer pous qu'il soit dans les coordonnées de l'image
        tri_projeté = transforme(caméra_vers_rateau, tri_projeté)

        ratisse_triangle(
            image,
            tri_projeté.p0.x,
            tri_projeté.p0.y,
            tri_projeté.p1.x,
            tri_projeté.p1.y
            tri_projeté.p2.x,
            tri_projeté.p2.y,
            couleur);
    }
}
