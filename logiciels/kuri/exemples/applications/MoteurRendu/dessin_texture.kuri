charge "glew"

importe Fondation

vérifie_erreur :: fonc() -> rien
{
    erreur := glGetError()

	si erreur == transtype(0: n32) {
        retourne
	}

	imprime("erreur OpenGL !\n")

    discr erreur {
        _GL_INVALID_ENUM {
            imprime("-- énumération invalide\n")
        }
        _GL_INVALID_VALUE {
            imprime("-- valeur invalide\n")
        }
        _GL_INVALID_OPERATION {
            imprime("-- opération invalide\n")
        }
        _GL_INVALID_FRAMEBUFFER_OPERATION {
            imprime("-- opération invalide sur framebuffer\n")
        }
        sinon {
            imprime("-- erreur inconnue, code %\n", erreur)
        }
    }
}

Couleur :: struct {
    r := 0.0
    v := 0.0
    b := 0.0
    a := 0.0
}

TamponTexture :: struct {
    programme : n32

    id_tampon_vertex : n32
    id_tampon_index : n32
    id_tableau_vertex : n32

    code_texture : n32
}

crée_tampon_texture :: fonc () -> *TamponTexture
{
    dyn tampon_texture := loge TamponTexture
    tampon_texture.programme = charge_programme()

    // ------------------

    glGenTextures(1, @tampon_texture.code_texture)

    glUseProgram(tampon_texture.programme)

    loc := glGetUniformLocation(tampon_texture.programme, "image".pointeur)

	glUniform1ui(loc, tampon_texture.code_texture);

    glUseProgram(transtype(0 : n32))

    // ------------------

    glGenVertexArrays(1, @tampon_texture.id_tableau_vertex)
    glGenBuffers(1, @tampon_texture.id_tampon_index)
    glGenBuffers(1, @tampon_texture.id_tampon_vertex)

    // création du tableau de sommets
    glBindVertexArray(tampon_texture.id_tableau_vertex)

    sommets := [ 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0 ]

	glBindBuffer(OGL.ARRAY_BUFFER, tampon_texture.id_tampon_vertex);
	glBufferData(OGL.ARRAY_BUFFER, transtype(sommets.taille: n64) * taille_de(r32), @sommets[0], OGL.STATIC_DRAW);

    index := [ 0, 1, 2, 0, 2, 3 ];

	glBindBuffer(OGL.ELEMENT_ARRAY_BUFFER, tampon_texture.id_tampon_index);
	glBufferData(OGL.ELEMENT_ARRAY_BUFFER, transtype(index.taille: n64) * taille_de(z32), @index[0], OGL.STATIC_DRAW);

	glEnableVertexAttribArray(transtype(0: n32));
	glVertexAttribPointer(transtype(0 : n32), 2, OGL.FLOAT, OGL.FALSE, 0, nul);

    glBindVertexArray(transtype(0 : n32))

    retourne tampon_texture
}

dessine_tampon_texture :: fonc (tampon_texture: *TamponTexture) -> rien
{
    glUseProgram(tampon_texture.programme)
    glBindVertexArray(tampon_texture.id_tableau_vertex)

	glActiveTexture(_GL_TEXTURE0);
	glBindTexture(_GL_TEXTURE_2D, tampon_texture.code_texture);

    glDrawElements(OGL.TRIANGLES, 6, 0x1405, nul)

	glActiveTexture(_GL_TEXTURE0);
	glBindTexture(_GL_TEXTURE_2D, transtype(0: n32));

    glBindVertexArray(transtype(0 : n32))
    glUseProgram(transtype(0 : n32))
}

détruit_tampon_texture :: fonc (tampon_texture: *TamponTexture) -> rien
{
    glDeleteVertexArrays(1, @tampon_texture.id_tableau_vertex)
    glDeleteBuffers(1, @tampon_texture.id_tampon_vertex)
    glDeleteBuffers(1, @tampon_texture.id_tampon_index)
    glDeleteProgram(tampon_texture.programme)

    déloge tampon_texture
}

génère_texture :: fonc (
    tampon_texture: *TamponTexture,
    données: []Couleur,
    largeur: z32,
    hauteur: z32) -> rien
{
    si glIsTexture(tampon_texture.code_texture) {
		glDeleteTextures(1, @tampon_texture.code_texture);
        glGenTextures(1, @tampon_texture.code_texture);
	}

	glActiveTexture(_GL_TEXTURE0);
	glBindTexture(_GL_TEXTURE_2D, tampon_texture.code_texture);

	glTexParameteri(_GL_TEXTURE_2D, _GL_TEXTURE_MIN_FILTER, _GL_LINEAR);
	glTexParameteri(_GL_TEXTURE_2D, _GL_TEXTURE_MAG_FILTER, _GL_LINEAR);
	glTexParameteri(_GL_TEXTURE_2D, _GL_TEXTURE_WRAP_S, _GL_CLAMP);
	glTexParameteri(_GL_TEXTURE_2D, _GL_TEXTURE_WRAP_T, _GL_CLAMP);

    glTexImage2D(_GL_TEXTURE_2D, 0, _GL_RGBA, largeur, hauteur, 0, _GL_RGBA, _GL_FLOAT, données.pointeur);

	glActiveTexture(_GL_TEXTURE0);
	glBindTexture(_GL_TEXTURE_2D, transtype(0: n32));
}

charge_programme :: fonc() -> n32
{
    source_vertex := "
    #version 330 core
    layout(location = 0) in vec2 sommets;
    smooth out vec2 UV;
    void main()
    {
        gl_Position = vec4(sommets * 2.0 - 1.0, 0.0, 1.0);
        UV = sommets;
    }
    "

    source_fragment := "
    #version 330 core
    layout (location = 0) out vec4 couleur_fragment;
    smooth in vec2 UV;
    uniform sampler2D image;
    void main()
    {
        vec2 flipped = vec2(UV.x, 1.0 - UV.y);
        couleur_fragment = texture(image, flipped);
    }
    "

    // crée les nuanceurs
	VertexShaderID := glCreateShader(OGL.VERTEX_SHADER)
	FragmentShaderID := glCreateShader(OGL.FRAGMENT_SHADER)

    taille_src_vertex := transtype(source_vertex.taille : z32)
	glShaderSource(VertexShaderID, 1, @source_vertex.pointeur , @taille_src_vertex)
	glCompileShader(VertexShaderID)

    // verifie la compilation
    dyn Result : z32 = 0
    dyn InfoLogLength : z32 = 0
    glGetShaderiv(VertexShaderID, OGL.COMPILE_STATUS, @Result)
    glGetShaderiv(VertexShaderID, OGL.INFO_LOG_LENGTH, @InfoLogLength)

    si InfoLogLength > 0 {
		ProgramErrorMessage := loge chaine(InfoLogLength+1)
		glGetShaderInfoLog(VertexShaderID, InfoLogLength, nul, ProgramErrorMessage.pointeur)
		imprime_sans_format("!!!!! Erreur compilation : VertexShaderID", ProgramErrorMessage, '\n')
        déloge ProgramErrorMessage
	}

    taille_src_fragment := transtype(source_fragment.taille : z32)
	glShaderSource(FragmentShaderID, 1, @source_fragment.pointeur , @taille_src_fragment)
	glCompileShader(FragmentShaderID)

    // verifie la compilation
    Result = 0
    InfoLogLength = 0
    glGetShaderiv(FragmentShaderID, OGL.COMPILE_STATUS, @Result)
	glGetShaderiv(FragmentShaderID, OGL.INFO_LOG_LENGTH, @InfoLogLength)

    si InfoLogLength > 0 {
		ProgramErrorMessage := loge chaine(InfoLogLength+1)
		glGetShaderInfoLog(FragmentShaderID, InfoLogLength, nul, ProgramErrorMessage.pointeur)
		imprime_sans_format("!!!!! Erreur compilation : FragmentShaderID", ProgramErrorMessage, '\n')
        déloge ProgramErrorMessage
	}

    ProgramID_ := glCreateProgram()
	glAttachShader(ProgramID_, VertexShaderID)
	glAttachShader(ProgramID_, FragmentShaderID)
	glLinkProgram(ProgramID_)

    // verifie la liaison
    Result = 0
    InfoLogLength = 0
    glGetProgramiv(ProgramID_, OGL.LINK_STATUS, @Result)
	glGetProgramiv(ProgramID_, OGL.INFO_LOG_LENGTH, @InfoLogLength)

    si InfoLogLength > 0 {
		ProgramErrorMessage := loge chaine(InfoLogLength+1)
		glGetProgramInfoLog(ProgramID_, InfoLogLength, nul, ProgramErrorMessage.pointeur)
		imprime_sans_format("!!!!! Erreur liaison : ProgramID", ProgramErrorMessage, '\n')
        déloge ProgramErrorMessage
	}

	glDetachShader(ProgramID_, VertexShaderID)
	glDetachShader(ProgramID_, FragmentShaderID)

	glDeleteShader(VertexShaderID)
	glDeleteShader(FragmentShaderID)

    retourne ProgramID_
}