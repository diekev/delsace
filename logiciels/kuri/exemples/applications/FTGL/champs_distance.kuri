//importe Fondation

charge "edtaa3func"

memset :: fonc externe (ptr: *rien, valeur: z32, taille: n64) -> rien

make_distance_mapd :: fonc (dyn data : []r64, width : z32, height : z32) -> []r64
{
	dyn xdist := loge [width * height]z16
	dyn ydist := loge [width * height]z16
	dyn gx := loge [width * height]r64
	dyn gy := loge [width * height]r64
	dyn outside := loge [width * height]r64
	dyn inside := loge [width * height]r64

	diffère {
		déloge xdist
		déloge ydist
		déloge gx
		déloge gy
		déloge outside
		déloge inside
	}

	computegradient(data, width, height, gx, gy)
	edtaa3(data, gx, gy, width, height, xdist, ydist, outside)

	pour valeur dans outside {
		si valeur < 0.0 {
			valeur = 0.0
		}
	}

	memset(gx.pointeur, 0, taille_de(r64) * transtype(width * height: n32))
	memset(gy.pointeur, 0, taille_de(r64) * transtype(width * height: n32))

	pour valeur dans data {
		valeur = 1.0 - valeur
	}

	computegradient(data, width, height, gx, gy)
	edtaa3(data, gx, gy, width, height, xdist, ydist, inside)

	pour valeur dans inside {
		si valeur < 0.0 {
			valeur = 0.0
		}
	}

	dyn vmin := 1000000000.0 // À FAIRE : DOUBLE_MAX

	pour i dans 0 ... width * height - 1 {
		outside[i] -= inside[i]

		si outside[i] < vmin {
			vmin = outside[i]
		}
	}

	vmin = abs(vmin)

	pour i dans 0 ... width * height - 1 {
		v := outside[i]

		si v < -vmin {
			outside[i] = -vmin
		}
		sinon si v > +vmin {
			outside[i] = +vmin
		}

		data[i] = (outside[i] + vmin) / (2.0 * vmin)
	}

	retourne data
}

make_distance_mapb :: fonc (img : []octet, width : z32, height : z32) -> []octet
{
	dyn data := loge [width * height]r64
	dyn out := loge [width * height]octet

	diffère { déloge data; }

	// find minimimum and maximum values
	dyn img_min :=  1000000000.0 // À FAIRE : DOUBLE_MAX
	dyn img_max := -1000000000.0 // À FAIRE : DOUBLE_MIN

	pour i dans 0 ... width * height - 1 {
		v := transtype(img[i]: r64)
		data[i] = v

		si v > img_max {
			img_max = v
		}

		si v < img_min {
			img_min = v
		}
	}

	pour i dans 0 ... width * height - 1 {
		data[i] = (transtype(img[i]: r64) - img_min) / img_max
	}

	data = make_distance_mapd(data, width, height)

	pour i dans 0 ... width * height - 1 {
		out[i] = transtype((255.0 * (1.0 - data[i])) : octet)
	}

	retourne out
}
