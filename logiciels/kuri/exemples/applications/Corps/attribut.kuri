importe Fondation

énum_drapeau TypeAttribut : n16 {
	Z8
	Z16
	Z32
	Z64
	N8
	N16
	N32
	N64
	R16
	R32
	R64
	CHAINE
    TABLEAU
}

énum PortéeAttribut : z8 {
	# l'attribut varie pour chaque point
	POINT
	# l'attribut varie pour chaque primitive
	PRIMITIVE
	# l'attribut varie pour chaque vertex de chaque primitive
	VERTEX
	# l'attribut est unique pour le corps
	CORPS
	# l'attribut varie pour chaque groupe
	GROUPE
}

struct TamponPartagé {
    données : []octet
    référence : *z32
}

struct Attribut {
    tampon : TamponPartagé
    nom : chaine
    type : TypeAttribut
    portée : PortéeAttribut
	# À FAIRE : utilisation de la dimension
    dimensions := 1
	nombre_éléments : z64 = 0
}

fonc est_type_attribut_valide(dyn type : TypeAttribut) -> bool
{
    # enlève le type tableau au cas où
    type &= ~TypeAttribut.TABLEAU

    si type == transtype(0 : TypeAttribut) {
        retourne faux
    }

    info := info_de(type)

    dyn nombre_bits := 0

    pour valeur dans info.valeurs {
		# À FAIRE : typage des valeurs des énums
		type_ := transtype(type : z32)
		nombre_bits += transtype((type_ & valeur) != 0 : z32)
    }

    retourne nombre_bits == 1
}

fonc principale(args : []*z8) -> z32
{
	diffère { imprime("\nMémoire utilisée : ", mémoire_utilisée(), " o\n") }

	imprime("Validation d'attributs...\n\n")

	dyn type := TypeAttribut.Z16
	imprime("est_type_valide : ", type, " ===> ", est_type_attribut_valide(type), "\n")

	type = TypeAttribut.TABLEAU | TypeAttribut.Z16
	imprime("est_type_valide : ", type, " ===> ", est_type_attribut_valide(type), "\n")

	type = TypeAttribut.TABLEAU | TypeAttribut.TABLEAU
	imprime("est_type_valide : ", type, " ===> ", est_type_attribut_valide(type), "\n")

	type = TypeAttribut.Z32 | TypeAttribut.Z16
	imprime("est_type_valide : ", type, " ===> ", est_type_attribut_valide(type), "\n")

	imprime("\n")

	imprime("Création d'attributs...\n\n")

	type = TypeAttribut.R32 | TypeAttribut.TABLEAU
	attr := crée_attribut(type)
	attr.réserve(10)

	imprime(attr, "\n")
	imprime("\nIntialise valeurs...\n")

	pour i dans transtype(0 : z64) ... attr.nombre_éléments - 1 {
		dyn ptr := attr.tableau_r32(i)
		ptr.taille = 0
		ptr.pointeur = nul
	}

	imprime("\nValeurs :\n")

	pour i dans transtype(0 : z64) ... attr.nombre_éléments - 1 {
		dyn ptr := attr.tableau_r32(i)

		imprime("Valeur ", i, " = ", mémoire(ptr), "\n")
	}

	détruit(attr)

	retourne 0
}

fonc crée_attribut(type : TypeAttribut) -> Attribut
{
	dyn attr : Attribut
	attr.type = type
	attr.nom = ""

	retourne attr
}

fonc réserve(dyn attr : &Attribut, nombre_éléments : z64) -> rien
{
	# À FAIRE : copie le tampon si référencé
	taille := nombre_éléments * taille_octet_type_attribut(attr.type)
	reloge attr.tampon.données : [taille]octet

	attr.nombre_éléments = nombre_éléments
}

fonc est_type_tableau(type : TypeAttribut) -> bool
{
	retourne (type & TypeAttribut.TABLEAU) != transtype(0 : TypeAttribut)
}

fonc détruit(dyn attr : &Attribut) -> rien
{
	# À FAIRE : déloge le tampon que si non référencé

	si est_type_tableau(attr.type) {
		pour i dans transtype(0 : z64) ... attr.nombre_éléments - 1 {
			# À FAIRE : types des données
			#ptr := attr.tableau_r32(i)
			#déloge mémoire(ptr)
		}
	}

	déloge attr.tampon.données
}

fonc valeur_z32(dyn attr : &Attribut, index : z64) -> *z32
{
	si attr.type != TypeAttribut.Z32 {
		retourne nul
	}

	décalage := index * taille_octet_type_attribut(attr.type)

	retourne transtype(@attr.tampon.données[décalage] : *z32)
}

fonc valeur_r32(dyn attr : &Attribut, index : z64) -> *r32
{
	si attr.type != TypeAttribut.R32 {
		retourne nul
	}

	décalage := index * taille_octet_type_attribut(attr.type)

	retourne transtype(@attr.tampon.données[décalage] : *r32)
}

fonc tableau_r32(dyn attr : &Attribut, index : z64) -> *[]r32
{
	si attr.type != (TypeAttribut.TABLEAU | TypeAttribut.R32) {
		retourne nul
	}

	décalage := index * taille_octet_type_attribut(attr.type)

	retourne transtype(@attr.tampon.données[décalage] : *[]r32)
}

fonc taille_octet_type_attribut(type : TypeAttribut) -> z64
{
	dyn taille : n32

	discr type {
		N8,
		Z8 {
			taille = taille_de(z8)
        }
		N16,
		Z16 {
			taille = taille_de(z16)
        }
		N32,
		Z32 {
			taille = taille_de(z32)
        }
		N64,
		Z64 {
			taille = taille_de(z64)
        }
		R16 {
			taille = taille_de(r16)
        }
		R32 {
			taille = taille_de(r32)
        }
		R64 {
			taille = taille_de(r64)
        }
		CHAINE {
			taille = taille_de(chaine)
        }
		sinon {
			# À FAIRE : est_type_tableau échoue ici...
            si (type & TypeAttribut.TABLEAU) != transtype(0 : TypeAttribut) {
                # Tous les types de tableaux ont la même taille.
                taille = taille_de([]octet)
            }
        }
	}

	retourne transtype(taille : z64)
}

#fonc crée_attribut_point(nom : chaine, type : TypeAttribut, dimensions : z32) : Attribut

#fonc crée_attribut_primitive(nom : chaine, type : TypeAttribut, dimensions : z32) : Attribut

#fonc crée_attribut_vertex(nom : chaine, type : TypeAttribut, dimensions : z32) : Attribut

#fonc crée_attribut_corps(nom : chaine, type : TypeAttribut, dimensions : z32) : Attribut

#fonc crée_attribut_groupe(nom : chaine, type : TypeAttribut, dimensions : z32) : Attribut

fonc copie_attribut(attr : &Attribut) -> Attribut
{
    dyn nattr : Attribut
    nattr.tampon = attr.tampon
    mémoire(nattr.tampon.référence) += 1
    nattr.nom = attr.nom
    nattr.type = attr.type
    nattr.portée = attr.portée
    nattr.dimensions = attr.dimensions

    retourne nattr
}

# À FAIRE : définir une bonne interface pour accéder aux valeurs sans gabarits
#
# Idée tirée de JAI :
#
# déclaration d'un type gabarit    => x : $T
# déclaration d'une valeur gabarit => $x : T
# La valeur gabarit est l'équivalent des valeurs littérales des templates en C++
# template <int N>, mais en plus flexible
#
# Une instruction #bake sers à instantier les fonctions selon les valeurs gabarits
# par exemple (avec notre syntaxe)
#
# fonc nouveau_tableau_fixe($N : Type_de_N, x : $Type_du_tableau) : [N]$Type_du_tableau
# crée_tableau_dix_éléments = #cuis nouveau_tableau_fixe($N = 10)
#
# On peut alors appeler : crée_tableau_dix_éléments(z32) pour créer un [10]z32
#
# Pour les attributs nous pourrions avoir un système similaire
#
# fonc valeur(attr : &Attribut, index : z64, $Type_de_valeur : Type, $T : TypeAttribut)
#
# valeur_z32 = #cuis valeur(Type_de_valeur = z32, T = TypeAttribut.Z32)
# valeur_r32 = #cuis valeur(Type_de_valeur = r32, T = TypeAttribut.R32)
# ....
#
# Ceci pourrait aisément remplacer le combo template + macro utilisé en C++
