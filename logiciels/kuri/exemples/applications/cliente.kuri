importe Fondation
importe GlibC
importe Réseau

################################################################################

#!inclus "openssl/err.h"
#!inclus "openssl/ssl.h"

#!bib "ssl"
#!bib "crypto"

struct externe ssl_method_st; # SSL_METHOD dans l'IPA C
struct externe ssl_st; # SSL dans l'IPA C

fonc externe SSL_library_init() : rien;
fonc externe OpenSSL_add_ssl_algorithms() : rien;
fonc externe SSL_load_error_strings() : rien;
fonc externe SSLv23_client_method() : *ssl_method_st;
fonc externe SSL_CTX_new(method : *ssl_method_st) : *rien;
fonc externe SSL_new(ctx_s : *rien) : *ssl_st;
fonc externe SSL_set_fd(ssl : *ssl_st, prise : z32) : rien;
fonc externe SSL_connect(ssl : *ssl_st) : z32;
fonc externe SSL_free(ssl : *ssl_st) : rien;
fonc externe SSL_get_error(ssl : *ssl_st, erreur : z32) : z32;
fonc externe SSL_write(ssl : *ssl_st, ptr : *z8, taille : z32) : z32
fonc externe SSL_read(ssl : *ssl_st, tampon : *z8, max : z32) : z32

soit _SSL_ERROR_NONE = 0
soit _SSL_ERROR_SSL = 1
soit _SSL_ERROR_WANT_READ = 2
soit _SSL_ERROR_WANT_WRITE = 3
soit _SSL_ERROR_WANT_X509_LOOKUP = 4
soit _SSL_ERROR_SYSCALL = 5
soit _SSL_ERROR_ZERO_RETURN = 6
soit _SSL_ERROR_WANT_CONNECT = 7
soit _SSL_ERROR_WANT_ACCEPT = 8

################################################################################

#!nulctx fonc rappel_erreur(pointeur : *z8, taille : n64, user_data : *rien) : z32
{
    write(std_err, pointeur, transtype(taille : z64))
    retourne 0
}

fonc externe ERR_print_errors_cb(cb : fonc(*z8,n64,*rien)z32, u : *rien) : rien

fonc port_pour_uri(uri_ : &URI) : n16
{
    si uri_.port.taille == 0 {
        si compare_chaines(uri_.schéma, "http") {
            retourne 80
        }

        si compare_chaines(uri_.schéma, "https") {
            retourne 443
        }
    }

    dyn résultat : n16 = 0

    pour c dans uri_.port {
        résultat = résultat * 10 + transtype(c - '0' : n16)
    }

    retourne résultat
}

fonc imprime_erreur_ssl(ssl : *ssl_st, dyn erreur : z32, message : chaine, pile : bool) : rien
{
	imprime(message)

	erreur = SSL_get_error(ssl, erreur);

	associe (erreur) {
		_SSL_ERROR_NONE {
			imprime("SSL_ERROR_NONE\n")
        }
	    _SSL_ERROR_ZERO_RETURN {
			imprime("SSL_ERROR_ZERO_RETURN\n")
        }
		_SSL_ERROR_WANT_READ {
			imprime("SSL_ERROR_WANT_READ\n")
        }
		_SSL_ERROR_WANT_WRITE {
			imprime("SSL_ERROR_WANT_WRITE\n")
        }
		_SSL_ERROR_WANT_CONNECT {
			imprime("SSL_ERROR_WANT_CONNECT\n")
        }
		_SSL_ERROR_WANT_ACCEPT {
			imprime("SSL_ERROR_WANT_ACCEPT\n")
        }
		_SSL_ERROR_WANT_X509_LOOKUP {
			imprime("SSL_ERROR_WANT_X509_LOOKUP\n")
        }
		_SSL_ERROR_SYSCALL {
			imprime("SSL_ERROR_SYSCALL\n")
        }
		_SSL_ERROR_SSL {
			imprime("SSL_ERROR_SSL\n")
        }
	}

	si (pile) {
		#ERR_print_errors_cb(rappel_erreur, nul)
	}
}

fonc lance_requête(uri : &URI, requête : chaine) : chaine, z32
{
    dyn réponse : chaine;

    si !est_valide(uri) {
        imprime("L'uri est invalide !", '\n');
        retourne réponse, 1;
    }

    dyn tampon : [1024]z8;
    ptr_tampon = copie_chaine_c_tampon(tampon, hôte de uri);

    he = gethostbyname(ptr_tampon);

    si he == nul {
        imprime("Ne peut pas trouver les informations de l'hôte !", '\n');
        retourne réponse, 1;
    }

    prise = socket(_AF_INET, _SOCK_STREAM, 0);

    si prise == -1 {
        imprime("Ne peut pas créer la prise !", '\n');
        retourne réponse, 1;
    }

    diffère { close(prise); }

    port : n16 = port_pour_uri(uri);

    dyn their_addr : sockaddr_in;
    sin_family de their_addr = transtype(_AF_INET : n16);
    sin_port de their_addr = htons(port);
    their_addr.sin_zero[0]= 0;
    their_addr.sin_zero[1]= 0;
    their_addr.sin_zero[2]= 0;
    their_addr.sin_zero[3]= 0;
    their_addr.sin_zero[4]= 0;
    their_addr.sin_zero[5]= 0;
    their_addr.sin_zero[6]= 0;
    their_addr.sin_zero[7]= 0;

    x = he.h_addr_list[0];
    sin_addr de their_addr = mémoire(transtype(x : *in_addr));

    #imprime(their_addr, '\n');

    si connect(prise, transtype(@their_addr : *sockaddr), transtype(taille_de(sockaddr) : z64)) == -1 {
        imprime("Impossible de se connecter à la prise !", '\n');
        retourne réponse, 1;
    }

    #imprime("Connexion active", '\n');

    dyn m_ssl : *ssl_st = nul
    diffère { si m_ssl != nul { SSL_free(m_ssl); } }

    # initialise connexion SSL
    si port == 443 {
        SSL_library_init()
        OpenSSL_add_ssl_algorithms()
        SSL_load_error_strings()

        method = SSLv23_client_method()

        si method == nul {
            imprime("Erreur lors de la création de la méthode SSL\n")
            retourne réponse, 1
        }

        ctx_ssl = SSL_CTX_new(method)

        si ctx_ssl == nul {
            imprime_erreur_ssl(nul, 0, "Erreur lors de la création du contexte SSL : ", vrai)
            retourne réponse, 1
        }

        m_ssl = SSL_new(ctx_ssl)

        si m_ssl == nul {
            imprime_erreur_ssl(m_ssl, 0, "Erreur lors de la création SSL : ", vrai)
            retourne réponse, 1
        }

        SSL_set_fd(m_ssl, prise);

        connexion = SSL_connect(m_ssl);

        si connexion <= 0 {
            imprime_erreur_ssl(m_ssl, connexion, "Erreur lors de la connexion SSL : ", vrai)
            retourne réponse, 1
        }
    }

    # envoie la requête
    si port == 443 {
        taille = SSL_write(m_ssl, requête.pointeur, transtype(requête.taille : z32))

		si taille <= 0 {
			imprime_erreur_ssl(m_ssl, taille, "Erreur lors de l'écriture SSL : ", faux)
            retourne réponse, 1;
		}
    }
    sinon {
        si send(prise, pointeur de requête, transtype(taille de requête : n64), 0) == -1 {
            imprime("Ne peut pas envoyer la reqûete !", '\n');
            retourne réponse, 1;
        }
    }

    # obtiens les données
    taille_max_données = 1024;

    si port == 443 {
        boucle {
            taille = SSL_read(m_ssl, @tampon[0], taille_max_données)

            si taille > 0 {
                ancienne_taille = taille de réponse;
                reloge réponse : chaine(taille de réponse + taille);
                copie_mem_nonsur(src=@tampon[0], dst=@réponse[ancienne_taille], taille=transtype(taille : z64));
            }
            sinon {
                erreur = SSL_get_error(m_ssl, taille)

                si erreur != _SSL_ERROR_NONE || erreur != _SSL_ERROR_ZERO_RETURN {
                    imprime("Erreur lors de la lecture SSL : ");

                    associe (erreur) {
                        _SSL_ERROR_NONE {
                            imprime("SSL_ERROR_NONE\n")
                        }
                        _SSL_ERROR_ZERO_RETURN {
                            imprime("SSL_ERROR_ZERO_RETURN\n")
                        }
                        _SSL_ERROR_WANT_READ {
                            imprime("SSL_ERROR_WANT_READ\n")
                        }
                        _SSL_ERROR_WANT_WRITE {
                            imprime("SSL_ERROR_WANT_WRITE\n")
                        }
                        _SSL_ERROR_WANT_CONNECT {
                            imprime("SSL_ERROR_WANT_CONNECT\n")
                        }
                        _SSL_ERROR_WANT_ACCEPT {
                            imprime("SSL_ERROR_WANT_ACCEPT\n")
                        }
                        _SSL_ERROR_WANT_X509_LOOKUP {
                            imprime("SSL_ERROR_WANT_X509_LOOKUP\n")
                        }
                        _SSL_ERROR_SYSCALL {
                            imprime("SSL_ERROR_SYSCALL\n")
                        }
                        _SSL_ERROR_SSL {
                            imprime("SSL_ERROR_SSL\n")
                        }
                    }
                }

                arrête
            }
        }
    }
    sinon {
        boucle {
            taille_reçue = recv(prise, @tampon[0], transtype(taille_max_données : n64), 0);
            #imprime("Reçu paquet de taille ", taille_reçue, '\n');

            si taille_reçue > 0 {
                ancienne_taille = taille de réponse;
                reloge réponse : chaine(taille de réponse + taille_reçue);
                copie_mem_nonsur(src=@tampon[0], dst=@réponse[ancienne_taille], taille=taille_reçue);
            }
            sinon si taille_reçue == 0 {
                arrête;
            }
            sinon si taille_reçue == -1 {
                arrête;
            }
        }
    }

    retourne réponse, 0
}

fonc principale(args : []*z8) : z32
{
    si args.taille != 2 {
        chn = converti_chaine_c(args[0])
        imprime_err("Utilisation : ", chn, " URL\n")
        retourne 1
    }

    # connecte vers la page
    chn = converti_chaine_c(args[1])
    uri = construit_uri(chn);

    si !est_valide(uri) {
        imprime("L'uri est invalide !", '\n');
        retourne 1;
    }

    #imprime(uri, '\n', '\n');

    constructrice = crée_constructrice_chaine()
    diffère { déloge constructrice.résultat; }

    pousse(constructrice, "GET ")
    pousse(constructrice, chemin de uri)
    pousse(constructrice, requête de uri)
    pousse(constructrice, " HTTP/1.1\r\n")
    pousse(constructrice, "Host:")
    pousse(constructrice, hôte de uri)
    pousse(constructrice, "\r\n")
    pousse(constructrice, "Accept-Encoding: identity\r\n")
    pousse(constructrice, "Accept-Charset: utf-8, iso-8859-1;q=0.5\r\n")
    pousse(constructrice, "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/ *;q=0.8\r\n")
    pousse(constructrice, "User-Agent: delsace\r\n")
    pousse(constructrice, "Connection: close\r\n")
    pousse(constructrice, "\r\n")

    requête = constructrice.résultat

    imprime("Reqûete envoyée :\n", requête, '\n');

    réponse, erreur = lance_requête(uri, requête)
    diffère { déloge réponse; }

    si erreur == 0 {
        imprime("Réponse :", '\n', réponse, '\n');
    }

    retourne 0;
}
