importe Fondation
importe GlibC
importe OpenSSL
importe Réseau

################################################################################

#!nulctx fonc rappel_erreur(pointeur : *z8, taille : n64, user_data : *rien) -> z32
{
    write(std_err, pointeur, transtype(taille : z64))
    retourne 0
}

fonc imprime_erreur_ssl(ssl : *ssl_st, dyn erreur : z32, message : chaine, pile : bool) -> rien
{
	imprime(message)

	erreur := SSL_get_error(ssl, erreur);

	discr (erreur) {
		_SSL_ERROR_NONE {
			imprime("SSL_ERROR_NONE\n")
        }
	    _SSL_ERROR_ZERO_RETURN {
			imprime("SSL_ERROR_ZERO_RETURN\n")
        }
		_SSL_ERROR_WANT_READ {
			imprime("SSL_ERROR_WANT_READ\n")
        }
		_SSL_ERROR_WANT_WRITE {
			imprime("SSL_ERROR_WANT_WRITE\n")
        }
		_SSL_ERROR_WANT_CONNECT {
			imprime("SSL_ERROR_WANT_CONNECT\n")
        }
		_SSL_ERROR_WANT_ACCEPT {
			imprime("SSL_ERROR_WANT_ACCEPT\n")
        }
		_SSL_ERROR_WANT_X509_LOOKUP {
			imprime("SSL_ERROR_WANT_X509_LOOKUP\n")
        }
		_SSL_ERROR_SYSCALL {
			imprime("SSL_ERROR_SYSCALL\n")
        }
		_SSL_ERROR_SSL {
			imprime("SSL_ERROR_SSL\n")
        }
	}

	si (pile) {
		#ERR_print_errors_cb(rappel_erreur, nul)
	}
}

fonc lance_requête(uri : &URI, requête : chaine) -> chaine, z32
{
    dyn réponse : chaine;

    si !est_valide(uri) {
        imprime("L'uri est invalide !", '\n');
        retourne réponse, 1;
    }

    dyn tampon : [1024]z8;
    ptr_tampon = copie_chaine_c_tampon(tampon, uri.hôte);

    he := gethostbyname(ptr_tampon);

    si he == nul {
        imprime("Ne peut pas trouver les informations de l'hôte !", '\n');
        retourne réponse, 1;
    }

    prise := socket(_AF_INET, _SOCK_STREAM, 0);

    si prise == -1 {
        imprime("Ne peut pas créer la prise !", '\n');
        retourne réponse, 1;
    }

    diffère { close(prise); }

    port : n16 = port_pour_uri(uri);

    dyn their_addr : sockaddr_in;
    their_addr.sin_family = transtype(_AF_INET : n16);
    their_addr.sin_port = htons(port);
    their_addr.sin_zero[0] = transtype(0 : n8);
    their_addr.sin_zero[1] = transtype(0 : n8);
    their_addr.sin_zero[2] = transtype(0 : n8);
    their_addr.sin_zero[3] = transtype(0 : n8);
    their_addr.sin_zero[4] = transtype(0 : n8);
    their_addr.sin_zero[5] = transtype(0 : n8);
    their_addr.sin_zero[6] = transtype(0 : n8);
    their_addr.sin_zero[7] = transtype(0 : n8);

    x := he.h_addr_list[0];
    their_addr.sin_addr = mémoire(transtype(x : *in_addr));

    #imprime(their_addr, '\n');

	si connect(prise, transtype(@their_addr : *sockaddr), transtype(taille_de(sockaddr) : z64)) == -1 {
        imprime("Impossible de se connecter à la prise !", '\n');
        retourne réponse, 1;
    }

    #imprime("Connexion active", '\n');

    dyn m_ssl : *ssl_st = nul
    diffère { si m_ssl != nul { SSL_free(m_ssl); } }

    # initialise connexion SSL
    si port == 443 {
        SSL_library_init()
        OpenSSL_add_ssl_algorithms()
        SSL_load_error_strings()

        method := SSLv23_client_method()

        si method == nul {
            imprime("Erreur lors de la création de la méthode SSL\n")
            retourne réponse, 1
        }

        ctx_ssl := SSL_CTX_new(method)

        si ctx_ssl == nul {
            imprime_erreur_ssl(nul, 0, "Erreur lors de la création du contexte SSL : ", vrai)
            retourne réponse, 1
        }

        m_ssl := SSL_new(ctx_ssl)

        si m_ssl == nul {
            imprime_erreur_ssl(m_ssl, 0, "Erreur lors de la création SSL : ", vrai)
            retourne réponse, 1
        }

        SSL_set_fd(m_ssl, prise);

        connexion := SSL_connect(m_ssl);

        si connexion <= 0 {
            imprime_erreur_ssl(m_ssl, connexion, "Erreur lors de la connexion SSL : ", vrai)
            retourne réponse, 1
        }
    }

    # envoie la requête
    si port == 443 {
        taille := SSL_write(m_ssl, requête.pointeur, transtype(requête.taille : z32))

		si taille <= 0 {
			imprime_erreur_ssl(m_ssl, taille, "Erreur lors de l'écriture SSL : ", faux)
            retourne réponse, 1;
		}
    }
    sinon {
        si send(prise, requête.pointeur, transtype(requête.taille : n64), 0) == -1 {
            imprime("Ne peut pas envoyer la reqûete !", '\n');
            retourne réponse, 1;
        }
    }

    # obtiens les données
    taille_max_données := 1024;

    si port == 443 {
        boucle {
            taille := SSL_read(m_ssl, @tampon[0], taille_max_données)

            si taille > 0 {
                ancienne_taille := réponse.taille;
                reloge réponse : chaine(réponse.taille + taille);
                copie_mem_nonsur(src=@tampon[0], dst=@réponse[ancienne_taille], taille=transtype(taille : z64));
            }
            sinon {
                erreur := SSL_get_error(m_ssl, taille)

                si erreur != _SSL_ERROR_NONE || erreur != _SSL_ERROR_ZERO_RETURN {
                    imprime("Erreur lors de la lecture SSL : ");

                    discr (erreur) {
                        _SSL_ERROR_NONE {
                            imprime("SSL_ERROR_NONE\n")
                        }
                        _SSL_ERROR_ZERO_RETURN {
                            imprime("SSL_ERROR_ZERO_RETURN\n")
                        }
                        _SSL_ERROR_WANT_READ {
                            imprime("SSL_ERROR_WANT_READ\n")
                        }
                        _SSL_ERROR_WANT_WRITE {
                            imprime("SSL_ERROR_WANT_WRITE\n")
                        }
                        _SSL_ERROR_WANT_CONNECT {
                            imprime("SSL_ERROR_WANT_CONNECT\n")
                        }
                        _SSL_ERROR_WANT_ACCEPT {
                            imprime("SSL_ERROR_WANT_ACCEPT\n")
                        }
                        _SSL_ERROR_WANT_X509_LOOKUP {
                            imprime("SSL_ERROR_WANT_X509_LOOKUP\n")
                        }
                        _SSL_ERROR_SYSCALL {
                            imprime("SSL_ERROR_SYSCALL\n")
                        }
                        _SSL_ERROR_SSL {
                            imprime("SSL_ERROR_SSL\n")
                        }
                    }
                }

                arrête
            }
        }
    }
    sinon {
        boucle {
            taille_reçue := recv(prise, @tampon[0], transtype(taille_max_données : n64), 0);
            #imprime("Reçu paquet de taille ", taille_reçue, '\n');

            si taille_reçue > 0 {
                ancienne_taille := réponse.taille;
                reloge réponse : chaine(réponse.taille + taille_reçue);
                copie_mem_nonsur(src=@tampon[0], dst=@réponse[ancienne_taille], taille=taille_reçue);
            }
            sinon si taille_reçue == 0 {
                arrête;
            }
            sinon si taille_reçue == -1 {
                arrête;
            }
        }
    }

    retourne réponse, 0
}

fonc principale(args : []*z8) -> z32
{
    si args.taille != 2 {
        chn := converti_chaine_c(args[0])
        imprime_err("Utilisation : ", chn, " URL\n")
        retourne 1
    }

    # connecte vers la page
    chn := converti_chaine_c(args[1])
    uri := construit_uri(chn);

    si !est_valide(uri) {
        imprime("L'uri est invalide !", '\n');
        retourne 1;
    }

    #imprime(uri, '\n', '\n');

    enchaineuse := crée_enchaineuse()
    diffère { enchaineuse.détruit(); }

    enchaineuse.pousse("GET ")
    enchaineuse.pousse(uri.chemin)
    enchaineuse.pousse(uri.requête)
    enchaineuse.pousse(" HTTP/1.1\r\n")
    enchaineuse.pousse("Host:")
    enchaineuse.pousse(uri.hôte)
    enchaineuse.pousse("\r\n")
    enchaineuse.pousse("Accept-Encoding: identity\r\n")
    enchaineuse.pousse("Accept-Charset: utf-8, iso-8859-1;q=0.5\r\n")
    enchaineuse.pousse("Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/ *;q=0.8\r\n")
    enchaineuse.pousse("User-Agent: delsace\r\n")
    enchaineuse.pousse("Connection: close\r\n")
    enchaineuse.pousse("\r\n")

    requête := enchaineuse.résultat

    imprime("Reqûete envoyée :\n", requête, '\n');

    réponse, erreur := lance_requête(uri, requête)
    diffère { déloge réponse; }

    si erreur == 0 {
        imprime("Réponse :", '\n', réponse, '\n');
    }

    retourne 0;
}
