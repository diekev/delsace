
int ajoute_conversion(
		cm_lng &cm,
		type_var type1,
		type_var type2,
		int decalage_pile)
{
	cm.ajoute_instruction(code_inst_conversion(type1, type2))
	cm.ajoute_instruction(decalage_pile)
	ptr := cm.donnees().loge_donnees(taille_type(type2))
	cm.ajoute_instruction(ptr)
	retourne ptr
}

//##############################################################################

// À FAIRE : suppression de la mémoire pour les feuilles
rassemble_feuilles :: fonc(
    noeud_base : *NoeudSyntaxique,
    dyn feuilles : *[]*NoeudSyntaxique) -> rien
{
	pour enfant dans noeud_base.enfants {
		si enfant.lexème() == TypeLexème.VIRGULE {
			rassemble_feuilles(enfant, feuilles)
		}
		sinon {
			tableau_ajoute(feuilles, enfant)
		}
	}
}

//##############################################################################

extrait_entier :: fonc(chn : chaine) -> z32
{
    dyn résultat : z32 = 0

    pour c dans chn {
        résultat *= 10
        résultat += transtype(c - '0' : z32)
    }

    retourne résultat
}

extrait_decimal :: fonc(chn : chaine) -> r32
{
    dyn résultat := 0.0
    dyn point_trouvé := faux
    dyn dividende := 0.0

    pour c dans chn {
        si c == '.' {
            point_trouvé = vrai
            continue
        }

        si point_trouvé {
            résultat += transtype(c - '0' : r64) / dividende
            dividende *= 10
        }
        sinon {
            résultat *= 10
            résultat += transtype(c - '0' : r64)
        }
    }

    retourne transtype(résultat : r32)
}

type_pour_lexème :: fonc(type_lexème : TypeLexème) -> TypeParamètre
{
	discr type_lexème {
		TypeLexème.CHAINE_LITTERALE { retourne TypeParamètre.CHAINE }
		TypeLexème.TABLEAU { retourne TypeParamètre.TABLEAU }
		TypeLexème.NOMBRE_ENTIER,
		TypeLexème.NOMBRE_OCTAL,
		TypeLexème.NOMBRE_HEXADECIMAL,
		TypeLexème.NOMBRE_BINAIRE { retourne TypeParamètre.ENT32 }
		TypeLexème.NOMBRE_REEL { retourne TypeParamètre.DEC }
		TypeLexème.VEC2 { retourne TypeParamètre.VEC2 }
		TypeLexème.VEC3 { retourne TypeParamètre.VEC3 }
		TypeLexème.VEC4 { retourne TypeParamètre.VEC4 }
		TypeLexème.MAT3 { retourne TypeParamètre.MAT3 }
		TypeLexème.MAT4 { retourne TypeParamètre.MAT4 }
		sinon { retourne TypeParamètre.INVALIDE }
	}

	retourne TypeParamètre.INVALIDE
}

ConversionOpération :: énum {
    AUCUNE
	CONVERTI_TYPE1
	CONVERTI_TYPE2
}

calcul_conversion :: fonc(
	type1 : TypeParamètre,
	type2 : TypeParamètre) -> ConversionOpération
{
	si type1 == type2 {
		retourne ConversionOpération.AUCUNE
	}

	si type1 == TypeParamètre.DEC && type2 == TypeParamètre.ENT32 {
		retourne ConversionOpération.CONVERTI_TYPE2
	}

	si type1 == TypeParamètre.ENT32 && type2 == TypeParamètre.DEC {
		retourne ConversionOpération.CONVERTI_TYPE1
	}

	si taille_type(type1) > taille_type(type2) {
		retourne ConversionOpération.CONVERTI_TYPE2
	}

	retourne ConversionOpération.CONVERTI_TYPE1
}

//##############################################################################

CodeMachine :: struct {
    pile : []octet
}

ajoute_instruction :: fonc(inst : CodeInst) -> rien
{
    ptr := agrandi(cm.pile, taille_de(CodeInst))
    copie_mem_nonsûr(ptr, @inst, taille_de(CodeInst))
}

agrandi :: fonc(dyn tabl : &[]octet, taille : n32) -> *octet
{
    taille_tabl := tabl.taille
    reloge tabl : [taille_tabl + taille]octet
    retourne @tabl[taille_tabl]
}

//##############################################################################

genere_code :: fonc(
		base *b,
		ContexteGenerationCode &contexte_generation,
		dyn cm : &CodeMachine,
		expr_gauche : bool) -> z32
{
	discr (b.type) {
		TypeNoeud.RACINE {
			pour enfant dans b.enfants {
				genere_code(enfant, contexte_generation, cm, expr_gauche)
			}

			cm.ajoute_instruction(CodeInst.TERMINE)
		}
		TypeNoeud.PROPRIETE,
		TypeNoeud.ATTRIBUT {
			&gest_attrs := contexte_generation.gest_attrs
			donnees := gest_attrs.donnees_pour_propriete(b.chaine())

			si donnees == nul {
				si expr_gauche {
					gest_attrs.requiers_attr(b.chn(), b.donnees_type, b.pointeur_donnees)
				}
				sinon {
					erreur::lance_erreur(
								"Attribut inconnu.",
								contexte_generation,
								b.donnees,
								erreur::type_erreur::NORMAL)
				}
			}
			sinon {
				si expr_gauche {
					si (donnees.est_non_modifiable) {
						erreur::lance_erreur(
									"La propriété n'est pas modifiable.",
									contexte_generation,
									b.donnees,
									erreur::type_erreur::NORMAL)
					}

					donnees.est_modifiee = true
				}

				b.donnees_type = donnees.type
				b.pointeur_donnees = donnees.ptr
			}
		}
		TypeNoeud.VARIABLE {
			si expr_gauche {
				// si la locale existe, ne fais rien
				si (contexte_generation.locale_existe(b.chaine())) {
					b.pointeur_donnees = contexte_generation.valeur_locale(b.chaine())
					b.donnees_type  = contexte_generation.donnees_type(b.chaine())
				}
				sinon {
					// sinon, loge de la place pour elle
					b.pointeur_donnees = cm.donnees().loge_donnees(taille_type(b.donnees_type))
					contexte_generation.pousse_locale(b.chaine(), b.pointeur_donnees, b.donnees_type)
				}
			}
			sinon {
				// retrouve le pointeur
				b.pointeur_donnees = contexte_generation.valeur_locale(b.chaine())
				b.donnees_type  = contexte_generation.donnees_type(b.chaine())
			}
		}
		TypeNoeud.VALEUR {
			b.donnees_type = type_pour_lexème(b.lexème())

			discr b.donnees_type {
				TypeParamètre.ENT32 {
					b.pointeur_donnees = cm.donnees().loge_donnees(1)
					// évite de modifier le pointeur
					decalage = b.pointeur_donnees
					cm.donnees().stocke(decalage, extrait_entier(b.chaine()))
				}
				TypeParamètre.DEC {
					b.pointeur_donnees = cm.donnees().loge_donnees(1)
					// évite de modifier le pointeur
					decalage = b.pointeur_donnees
					cm.donnees().stocke(decalage, extrait_decimal(b.chaine()))
				}
				TypeParamètre.VEC2,
				TypeParamètre.VEC3,
				TypeParamètre.VEC4,
				TypeParamètre.MAT3,
				TypeParamètre.MAT4 {
					taille := taille_type(b.donnees_type)

					si (b.enfants.est_vide()) {
						b.pointeur_donnees = cm.donnees().loge_donnees(taille)
					}
					sinon {
						feuilles := dls::tableau<base *>()
						rassemble_feuilles(b, @feuilles)

						// À FAIRE :
						// - vérifie que tous les noeuds sont bel et bien constants
						// - converti les valeurs au besoin


						b.pointeur_donnees = cm.donnees().loge_donnees(taille)

						decalage := b.pointeur_donnees

						for (const &feuille : feuilles) {
							cm.donnees().stocke(decalage, extrait_decimal(feuille.chaine()))
						}

						si ((decalage - b.pointeur_donnees) > taille) {
							// il y trop de paramètres
						}
					}
				}
				TypeParamètre.TABLEAU {
					feuilles := dls::tableau<base *>()
					rassemble_feuilles(b, @feuilles)

					// À FAIRE : erreur si tableau vide, INFÉRENCE TYPE
					type_feuille := type_var{}

					for (feuille : feuilles) {
						genere_code(feuille, contexte_generation, cm, expr_gauche)
						type_feuille = feuille.donnees_type
					}

					cm.ajoute_instruction(CodeInst.CONSTRUIT_TABLEAU)
					cm.ajoute_instruction(type_feuille)
					cm.ajoute_instruction(static_cast<int>(feuilles.taille()))

					for (feuille : feuilles) {
						cm.ajoute_instruction(feuille.pointeur_donnees)
					}

					// là où se trouve l'index du tableau
					b.pointeur_donnees = cm.donnees().loge_donnees(1)

					cm.ajoute_instruction(b.pointeur_donnees)
				}
				TypeParamètre.CHAINE {
					// là où se trouve l'index de la chaine
					b.pointeur_donnees = cm.donnees().loge_donnees(1)
					ptr := b.pointeur_donnees
					cm.donnees().stocke(ptr, static_cast<int>(contexte_generation.chaines.taille()))
					contexte_generation.chaines.pousse(b.chaine())
				}
				TypeParamètre.COULEUR,
				TypeParamètre.INVALIDE,
				TypeParamètre.POLYMORPHIQUE {
				}
			}
		}
		TypeNoeud.FONCTION {
			// génére le code des enfants pour avoir les données sur leurs types
			types_params := types_entrees{}

			for (enfant : b.enfants) {
				genere_code(enfant, contexte_generation, cm, expr_gauche)
				types_params.types.pousse(enfant.donnees_type)
			}

			donnees_fonc := contexte_generation.fonctions.meilleure_candidate(
						b.chn(),
						types_params)

			si (donnees_fonc.donnees == nul) {
				dls::flux_chaine ss
				ss << "Impossible de trouver la fonction '" << b.chaine() << "'"
				throw std::runtime_error(ss.chn().c_str())
			}

			type_instance := donnees_fonc.type

			contexte_generation.requetes.insere(donnees_fonc.donnees.requete)

			// rassemble les pointeurs et crée les conversions au besoin
			dls::tableau<int> pointeurs
			taille := donnees_fonc.entrees.types.taille()
			enfant := b.enfants.debut()

			for (i = 0 i < taille ++i) {
				type_entree := donnees_fonc.entrees.types[i]

				si ((*enfant).donnees_type == type_entree) {
					pointeurs.pousse((*enfant).pointeur_donnees)
				}
				sinon {
					// À FAIRE : erreur si conversion impossible.
					ptr := ajoute_conversion(
								cm,
								(*enfant).donnees_type,
								type_entree,
								(*enfant).pointeur_donnees)

					pointeurs.pousse(ptr)
				}

				++enfant
			}

			// ****************** crée les données pour les appels ******************

			// ajoute le code_inst de la fonction
			cm.ajoute_instruction(donnees_fonc.donnees.type)

			// ajoute le type de la fonction pour choisir la bonne surcharge
			si (type_instance != TypeParamètre.INVALIDE) {
				cm.ajoute_instruction(type_instance)
			}

			// ajoute le pointeur de chaque paramètre
			for (ptr : pointeurs) {
				cm.ajoute_instruction(ptr)
			}

			// pour chaque sortie, nous réservons de la place sur la pile de données
			for (const &type_seing : donnees_fonc.sorties.types) {
				pointeur := cm.donnees().loge_donnees(taille_type(type_seing))

				// le pointeur sur la pile est celui du premier paramètre
				si (b.pointeur_donnees == 0) {
					b.pointeur_donnees = pointeur
				}
			}

			// ajoute le pointeur aux instructions pour savoir où écrire
			cm.ajoute_instruction(b.pointeur_donnees)

			// par défaut, seule la première sortie est utilisée, sauf si on assigne
			// plusieurs variables à la fois, c-à-d : a, b = foo()
			b.donnees_type = donnees_fonc.sorties.types[0]
			// pour les données sur les sorties multiple
			b.valeur_calculee = donnees_fonc
		}
		TypeNoeud.OPERATION_UNAIRE {
			enfant := b.enfants.front()
			pointeur := genere_code(enfant, contexte_generation, cm, expr_gauche)

			b.donnees_type = enfant.donnees_type

			discr b.lexème() {
				TypeLexème.MOINS_UNAIRE {
					taille := taille_type(b.donnees_type)
					cm.ajoute_instruction(CodeInst.NIE)
					cm.ajoute_instruction(b.donnees_type)
					cm.ajoute_instruction(pointeur)
					b.pointeur_donnees = cm.donnees().loge_donnees(taille)
					cm.ajoute_instruction(b.pointeur_donnees)
				}
				TypeLexème.PLUS_UNAIRE {
					b.pointeur_donnees = pointeur
				}
				sinon {
					// À FAIRE : erreur
				}
			}
		}
		TypeNoeud.OPERATION_BINAIRE {
			// À FAIRE : type booléen pour le retour des opérateurs de comparaison.

			enfant1 := b.enfants.front()
			enfant2 := b.enfants.back()

			genere_code(enfant1, contexte_generation, cm, expr_gauche)
			genere_code(enfant2, contexte_generation, cm, expr_gauche)

			dyn decalage1 := enfant1.pointeur_donnees
			dyn decalage2 := enfant2.pointeur_donnees

			// À FAIRE : multiplication mat/vec, etc.

			si (b.lexème() == TypeLexème.CROCHET_OUVRANT) {
				si (enfant2.donnees_type != lcc::TypeParamètre.TABLEAU) {
					erreur::lance_erreur(
								"Un tableau est requis pour l'opérateur []",
								contexte_generation,
								enfant2.donnees_morceau())
				}

				si (enfant1.donnees_type != lcc::TypeParamètre.ENT32) {
					erreur::lance_erreur(
								"Un nombre entier est requis dans l'opérateur []",
								contexte_generation,
								enfant1.donnees_morceau())
				}

				b.donnees_type = lcc::TypeParamètre.ENT32
				decalage1 = enfant2.pointeur_donnees
				decalage2 = enfant1.pointeur_donnees
			}
			sinon {
				conversion := calcul_conversion(enfant1.donnees_type, enfant2.donnees_type)

				si (conversion == conv_op::aucune) {
					b.donnees_type = enfant1.donnees_type
				}
				sinon si (conversion == ConversionOpération.CONVERTI_TYPE1) {
					b.donnees_type = enfant2.donnees_type

					decalage1 = ajoute_conversion(
								cm,
								enfant1.donnees_type,
								enfant2.donnees_type,
								enfant1.pointeur_donnees)
				}
				sinon {
					b.donnees_type = enfant1.donnees_type

					decalage2 = ajoute_conversion(
								cm,
								enfant2.donnees_type,
								enfant1.donnees_type,
								enfant2.pointeur_donnees)
				}
			}

			ajoute_insts_op_assign = [&](code_inst inst)
			{
				cm.ajoute_instruction(inst)
				cm.ajoute_instruction(b.donnees_type)
				cm.ajoute_instruction(decalage1)
				cm.ajoute_instruction(decalage2)

				b.pointeur_donnees = cm.donnees().loge_donnees(taille_type(b.donnees_type))

				cm.ajoute_instruction(b.pointeur_donnees)

				// ajoute assignement
				cm.ajoute_instruction(CodeInst.ASSIGNATION)
				cm.ajoute_instruction(b.donnees_type)
				cm.ajoute_instruction(b.pointeur_donnees)
				cm.ajoute_instruction(enfant1.pointeur_donnees)

				retourne b.pointeur_donnees
			}

			dyn requiers_inst_type := true

			discr b.lexème() {
				TypeLexème.PLUS {
					cm.ajoute_instruction(CodeInst.FN_AJOUTE)
				}
				TypeLexème.MOINS {
					cm.ajoute_instruction(CodeInst.FN_SOUSTRAIT)
				}
				TypeLexème.FOIS {
					// cas spéciale en cas de matrices
					si (b.donnees_type == TypeParamètre.MAT3 || b.donnees_type == TypeParamètre.MAT4) {
						cm.ajoute_instruction(CodeInst.FN_MULTIPLIE_MAT)
					}
					sinon {
						cm.ajoute_instruction(CodeInst.FN_MULTIPLIE)
					}
				}
				TypeLexème.DIVISE {
					cm.ajoute_instruction(CodeInst.FN_DIVISE)
					break
				}
				TypeLexème.PLUS_EGAL {
					retourne ajoute_insts_op_assign(CodeInst.FN_AJOUTE)
				}
				TypeLexème.MOINS_EGAL {
					retourne ajoute_insts_op_assign(CodeInst.FN_SOUSTRAIT)
				}
				TypeLexème.DIVISE_EGAL {
					retourne ajoute_insts_op_assign(CodeInst.FN_DIVISE)
				}
				TypeLexème.FOIS_EGAL {
					// cas spéciale en cas de matrices
					si (b.donnees_type == TypeParamètre.MAT3 || b.donnees_type == TypeParamètre.MAT4) {
						retourne ajoute_insts_op_assign(CodeInst.FN_MULTIPLIE_MAT)
					}

					retourne ajoute_insts_op_assign(CodeInst.FN_MULTIPLIE)
				}
				TypeLexème.POURCENT {
					cm.ajoute_instruction(CodeInst.FN_MODULO)
				}
				TypeLexème.EGALITE {
					cm.ajoute_instruction(CodeInst.FN_EGALITE)
				}
				TypeLexème.DIFFERENCE {
					cm.ajoute_instruction(CodeInst.FN_INEGALITE)
				}
				TypeLexème.SUPERIEUR {
					cm.ajoute_instruction(CodeInst.FN_SUPERIEUR)
				}
				TypeLexème.SUPERIEUR_EGAL {
					cm.ajoute_instruction(CodeInst.FN_SUPERIEUR_EGAL)
				}
				TypeLexème.INFERIEUR {
					cm.ajoute_instruction(CodeInst.FN_INFERIEUR)
				}
				TypeLexème.INFERIEUR_EGAL {
					cm.ajoute_instruction(CodeInst.FN_INFERIEUR_EGAL)
				}
				TypeLexème.BARRE,
				TypeLexème.BARRE_BARRE {
					cm.ajoute_instruction(CodeInst.FN_COMP_OU)
				}
				TypeLexème.ESPERLUETTE,
				TypeLexème.ESP_ESP {
					cm.ajoute_instruction(CodeInst.FN_COMP_ET)
				}
				TypeLexème.CHAPEAU {
					cm.ajoute_instruction(CodeInst.FN_COMP_OUX)
				}
				TypeLexème.CROCHET_OUVRANT {
					cm.ajoute_instruction(CodeInst.IN_EXTRAIT_TABLEAU)
					requiers_inst_type = false
				}
				sinon {
					//erreur::lance_erreur(
					//			"Opération inconnue",
					//			contexte_generation,
					//			b.donnees_morceau())
				}
			}

			si (requiers_inst_type) {
				cm.ajoute_instruction(b.donnees_type)
			}

			cm.ajoute_instruction(decalage1)
			cm.ajoute_instruction(decalage2)

			b.pointeur_donnees = cm.donnees().loge_donnees(taille_type(b.donnees_type))

			cm.ajoute_instruction(b.pointeur_donnees)

			break
		}
		TypeNoeud.ASSIGNATION {
			enfant_gauche := b.enfants.front()
			enfant_droite := b.enfants.back()

			// l'idée est que les sorties des fonctions sont des pointeurs vers la où se trouve les valeurs
			pointeur := genere_code(enfant_droite, contexte_generation, cm, false)

			si (enfant_gauche.identifiant() == TypeLexème.VIRGULE) {
				feuilles := dls::tableau<base *>()

				rassemble_feuilles(enfant_gauche, @feuilles)

				donnees_fonc := donnees_fonction_generation{}

				si (enfant_droite.type == TypeNoeud.ACCES_MEMBRE_POINT) {
					noeud_fonc := enfant_droite.enfants.back()

					donnees_fonc = std::any_cast<donnees_fonction_generation>(
										noeud_fonc.valeur_calculee)
				}
				sinon si (enfant_droite.type == TypeNoeud.FONCTION) {
					donnees_fonc = std::any_cast<donnees_fonction_generation>(
										enfant_droite.valeur_calculee)
				}
				sinon {
					throw std::runtime_error("enfant_droite inattendu dans l'assignation")
				}

				for (i = 0 i < feuilles.taille() ++i) {
					feuille := feuilles[i]

					ptr := pointeur
					dt := donnees_fonc.sorties.types[i]

					si (i > 0) {
						type_sortie = donnees_fonc.sorties.types[i - 1]
						ptr += taille_type(type_sortie)
					}

					feuille.pointeur_donnees = ptr
					feuille.donnees_type = dt
					genere_code(feuille, contexte_generation, cm, true)

					cm.ajoute_instruction(CodeInst.ASSIGNATION)
					cm.ajoute_instruction(dt)
					cm.ajoute_instruction(ptr)
					cm.ajoute_instruction(feuille.pointeur_donnees)
				}
			}
			sinon {
				enfant_gauche.pointeur_donnees = pointeur
				enfant_gauche.donnees_type = enfant_droite.donnees_type
				genere_code(enfant_gauche, contexte_generation, cm, true)

				cm.ajoute_instruction(CodeInst.ASSIGNATION)
				cm.ajoute_instruction(enfant_droite.donnees_type)
				cm.ajoute_instruction(enfant_droite.pointeur_donnees)
				cm.ajoute_instruction(enfant_gauche.pointeur_donnees)
			}
		}
		TypeNoeud.ACCES_MEMBRE_POINT {
			enfant_gauche := b.enfants.front()
			enfant_droite := b.enfants.back()

			si (enfant_droite.type == TypeNoeud.FONCTION) {
				// le premier paramètre doit être la 'structure' que l'on accède
				enfant_droite.enfants.insere(enfant_droite.enfants.debut(), enfant_gauche)

				genere_code(enfant_droite, contexte_generation, cm, expr_gauche)

				b.donnees_type = enfant_droite.donnees_type
				b.pointeur_donnees = enfant_droite.pointeur_donnees
			}
			sinon si (enfant_droite.type == TypeNoeud.VARIABLE) {
				si (enfant_droite.identifiant() != TypeLexème.CHAINE_CARACTERE) {
                    retourne
					//throw std::runtime_error("accès à un membre qui n'est pas une chaîne")
				}

				genere_code(enfant_gauche, contexte_generation, cm, expr_gauche)

				discr enfant_gauche.donnees_type {
					TypeParamètre.ENT32,
					TypeParamètre.DEC,
					TypeParamètre.MAT3,
					TypeParamètre.MAT4,
					TypeParamètre.TABLEAU,
					TypeParamètre.CHAINE,
					TypeParamètre.INVALIDE,
					TypeParamètre.POLYMORPHIQUE {
                        retourne
						//dls::flux_chaine ss
						//ss << "La variable '"
						//   << enfant_droite.chaine()
						//   << "' n'est pas une structure !"
						//   << " Accès au membre '"
						//   << enfant_gauche.chaine()
						//   << "' impossible."

						//throw std::runtime_error(ss.chn().c_str())
					}
					TypeParamètre.VEC2 {
						b.donnees_type = TypeParamètre.DEC

						si (enfant_droite.chaine() == "x") {
							b.pointeur_donnees = enfant_gauche.pointeur_donnees
						}
						sinon si (enfant_droite.chaine() == "y") {
							b.pointeur_donnees = enfant_gauche.pointeur_donnees + 1
						}
						sinon {
                            retourne
							//throw std::runtime_error("membre inconnu")
						}
					}
					TypeParamètre.VEC3 {
						b.donnees_type = TypeParamètre.DEC

						si (enfant_droite.chaine() == "x") {
							b.pointeur_donnees = enfant_gauche.pointeur_donnees
						}
						sinon si (enfant_droite.chaine() == "y") {
							b.pointeur_donnees = enfant_gauche.pointeur_donnees + 1
						}
						sinon si (enfant_droite.chaine() == "z") {
							b.pointeur_donnees = enfant_gauche.pointeur_donnees + 2
						}
						sinon {
                            retourne
							//throw std::runtime_error("membre inconnu")
						}
					}
					TypeParamètre.VEC4 {
						b.donnees_type = TypeParamètre.DEC

						si (enfant_droite.chaine() == "x") {
							b.pointeur_donnees = enfant_gauche.pointeur_donnees
						}
						sinon si (enfant_droite.chaine() == "y") {
							b.pointeur_donnees = enfant_gauche.pointeur_donnees + 1
						}
						sinon si (enfant_droite.chaine() == "z") {
							b.pointeur_donnees = enfant_gauche.pointeur_donnees + 2
						}
						sinon si (enfant_droite.chaine() == "w") {
							b.pointeur_donnees = enfant_gauche.pointeur_donnees + 3
						}
						sinon {
                            retourne
							//throw std::runtime_error("membre inconnu")
						}
					}
					TypeParamètre.COULEUR {
						b.donnees_type = TypeParamètre.DEC

						si (enfant_droite.chaine() == "r") {
							b.pointeur_donnees = enfant_gauche.pointeur_donnees
						}
						sinon si (enfant_droite.chaine() == "v") {
							b.pointeur_donnees = enfant_gauche.pointeur_donnees + 1
						}
						sinon si (enfant_droite.chaine() == "b") {
							b.pointeur_donnees = enfant_gauche.pointeur_donnees + 2
						}
						sinon si (enfant_droite.chaine() == "a") {
							b.pointeur_donnees = enfant_gauche.pointeur_donnees + 3
						}
						sinon {
							throw std::runtime_error("membre inconnu")
						}
					}
				}
			}
			sinon {
                retourne
				//throw std::runtime_error("accès impossible")
			}
		}
		TypeNoeud.SI {
			iter_enfant := b.enfants.debut()
			enfant1 := *iter_enfant++
			enfant2 := *iter_enfant++
			enfant3 := (b.enfants.taille() == 3) ? *iter_enfant++ : nul

			// génère le code de l'expression
			genere_code(enfant1, contexte_generation, cm, expr_gauche)

			// instructions : inst_branche ptr_comp bloc_si_vrai bloc_si_faux
			&instructions := cm.instructions()

			cm.ajoute_instruction(CodeInst.IN_BRANCHE_CONDITION)
			cm.ajoute_instruction(enfant1.pointeur_donnees)
			decalage_branche_si_vrai := static_cast<int>(instructions.taille())
			cm.ajoute_instruction(0)
			decalage_branche_si_faux := static_cast<int>(instructions.taille())
			cm.ajoute_instruction(0)

			// si la condition est vraie, le bloc est normalement juste après, donc
			// cette instruction n'est pas nécessaire
			instructions.stocke(decalage_branche_si_vrai, static_cast<int>(instructions.taille()))

			// génère le code du bloc 'si'
			genere_code(enfant2, contexte_generation, cm, expr_gauche)

			// génère le code du bloc 'sinon'
			si (enfant3 != nul) {
				// ajout d'une branche pour sauter le code si la condition était vraie
				cm.ajoute_instruction(CodeInst.IN_BRANCHE)
				decalage_branche := static_cast<int>(instructions.taille())
				cm.ajoute_instruction(0)

				// prend en compte la branche ajoutée
				instructions.stocke(decalage_branche_si_faux, static_cast<int>(instructions.taille()))

				genere_code(enfant3, contexte_generation, cm, expr_gauche)

				instructions.stocke(decalage_branche, static_cast<int>(instructions.taille()))
			}
			sinon {
				instructions.stocke(decalage_branche_si_faux, static_cast<int>(instructions.taille()))
			}
		}
		TypeNoeud.BLOC {
			pour enfant dans b.enfants {
				genere_code(enfant, contexte_generation, cm, expr_gauche)
			}
		}
		TypeNoeud.POUR {
			// 3 enfants : var plage bloc
			iter_enfant := b.enfants.debut()
			enfant1 := *iter_enfant++
			enfant2 := *iter_enfant++
			enfant3 := *iter_enfant++

			// génère le code de l'expresion pour avoir le type de la variable
			genere_code(enfant2, contexte_generation, cm, expr_gauche)
			variable_debut := enfant2.enfants.front().pointeur_donnees
			variable_fin := enfant2.enfants.back().pointeur_donnees

			// alloue la variable, À FAIRE : portée variables
			enfant1.donnees_type = enfant2.enfants.front().donnees_type
			genere_code(enfant1, contexte_generation, cm, true)

			cm.ajoute_instruction(CodeInst.ASSIGNATION)
			cm.ajoute_instruction(enfant1.donnees_type)
			cm.ajoute_instruction(variable_debut)
			cm.ajoute_instruction(enfant1.pointeur_donnees)

			// entrée de la boucle
			&instructions := cm.instructions()
			ptr_debut_boucle := instructions.taille()

			// test de la variable

			// 1. compare avec fin
			cm.ajoute_instruction(CodeInst.FN_INEGALITE)
			cm.ajoute_instruction(enfant1.donnees_type)
			cm.ajoute_instruction(enfant1.pointeur_donnees)
			cm.ajoute_instruction(variable_fin)
			ptr_comp := cm.donnees().loge_donnees(taille_type(enfant1.donnees_type))
			cm.ajoute_instruction(ptr_comp)

			// 2. branche si vrai
			cm.ajoute_instruction(CodeInst.IN_BRANCHE_CONDITION)
			cm.ajoute_instruction(ptr_comp)
			decalage_branche_si_vrai := static_cast<int>(instructions.taille())
			cm.ajoute_instruction(0)
			decalage_branche_si_faux := static_cast<int>(instructions.taille())
			cm.ajoute_instruction(0)

			// si la condition est vraie, le bloc est normalement juste après, donc
			// cette instruction n'est pas nécessaire
			instructions.stocke(decalage_branche_si_vrai, static_cast<int>(instructions.taille()))

			// données pour cette boucle
			db := donnees_boucles{}
			contexte_generation.boucles.empile(&db)

			// génère le code du bloc
			genere_code(enfant3, contexte_generation, cm, expr_gauche)

			// on « continue » après le bloc, mais avant d'incrémenter la
			// variable bouclée
			ptr_inst_continue := static_cast<int>(instructions.taille())

			// incrémente la variable
			cm.ajoute_instruction(CodeInst.IN_INCREMENTE)
			cm.ajoute_instruction(enfant1.donnees_type)
			cm.ajoute_instruction(enfant1.pointeur_donnees)

			// branche vers l'entrée de la boucle
			cm.ajoute_instruction(CodeInst.IN_BRANCHE)
			cm.ajoute_instruction(static_cast<int>(ptr_debut_boucle))

			ptr_fin_boucle := static_cast<int>(instructions.taille())

			instructions.stocke(decalage_branche_si_faux, ptr_fin_boucle)

			contexte_generation.boucles.depile()

			for (ptr_arrete : db.arretes) {
				instructions.stocke(ptr_arrete, ptr_fin_boucle)
			}

			for (ptr_continue : db.continues) {
				instructions.stocke(ptr_continue, ptr_inst_continue)
			}
		}
		TypeNoeud.PLAGE {
			for (enfant : b.enfants) {
				genere_code(enfant, contexte_generation, cm, expr_gauche)
			}
		}
		TypeNoeud.ARRETE: {
			&instructions := cm.instructions()

			cm.ajoute_instruction(CodeInst.IN_BRANCHE)
			decalage_inst := static_cast<int>(instructions.taille())
			cm.ajoute_instruction(0)

			donnees_boucle := contexte_generation.boucles.haut()
			donnees_boucle.arretes.pousse(decalage_inst)
		}
		TypeNoeud.CONTINUE {
			&instructions := cm.instructions()
			cm.ajoute_instruction(CodeInst.IN_BRANCHE)
			decalage_inst := static_cast<int>(instructions.taille())
			cm.ajoute_instruction(0)

			donnees_boucle := contexte_generation.boucles.haut()
			donnees_boucle.continues.pousse(decalage_inst)
		}
		TypeNoeud.RETOURNE {
			cm.ajoute_instruction(CodeInst.TERMINE)
		}
	}

	retourne b.pointeur_donnees
}

// 1087
