charge "lexage"

importe Fondation

// À FAIRE : les énums dont les valeurs sont autres que z32 ne sont pas imprimées (introspection)
TypeNoeud :: énum z32 {
    RACINE
	PROPRIETE
	VARIABLE
	VALEUR
	FONCTION
	ATTRIBUT
	OPERATION_UNAIRE
	OPERATION_BINAIRE
	ASSIGNATION
	ACCES_MEMBRE_POINT
	SI
	BLOC
	POUR
	PLAGE
	RETOURNE
	ARRETE
	CONTINUE
    EXPRESSION_PARENTHESE
}

NoeudSyntaxique :: struct {
    type : TypeNoeud
    données : DonnéesLexème
    enfants : []*NoeudSyntaxique
}

détruit_noeud :: fonc(dyn noeud : *NoeudSyntaxique) -> rien
{
    déloge noeud.enfants
    déloge noeud
}

ajoute_noeud :: fonc(dyn noeud : *NoeudSyntaxique, enfant : *NoeudSyntaxique) -> rien
{
    tableau_ajoute(@noeud.enfants, enfant)
}

lexème :: fonc(noeud : *NoeudSyntaxique) -> TypeLexème
{
    retourne noeud.données.lexème
}

//##############################################################################

PileNoeud :: struct {
    données : []*NoeudSyntaxique
    curseur := 0
}

détruit :: fonc(dyn pile : &PileNoeud) -> rien
{
    déloge pile.données
}

empile :: fonc(dyn pile : &PileNoeud, noeud : *NoeudSyntaxique) -> rien
{
    si pile.curseur == pile.données.taille {
        taille := pile.données.taille
        reloge pile.données : [taille + 1]*NoeudSyntaxique
    }

    pile.données[pile.curseur] = noeud
    pile.curseur += 1
}

dépile :: fonc(dyn pile : &PileNoeud) -> *NoeudSyntaxique
{
    ret := pile.haut()
    pile.curseur -= 1
    retourne ret
}

haut :: fonc(pile : &PileNoeud) -> *NoeudSyntaxique
{
    retourne pile.données[pile.curseur - 1]
}

taille :: fonc(pile : &PileNoeud) -> z32
{
    retourne pile.curseur
}

est_vide :: fonc(pile : &PileNoeud) -> bool
{
    retourne pile.curseur == 0
}

//##############################################################################

AssembleuseArbre :: struct {
    noeuds : []*NoeudSyntaxique
    pile : PileNoeud
}

construit_assembleuse :: fonc() -> AssembleuseArbre
{
    données_lexème : DonnéesLexème

	dyn assembleuse : AssembleuseArbre
    assembleuse.empile_noeud(TypeNoeud.RACINE, données_lexème, vrai)

    retourne assembleuse
}

détruit_assembleuse :: fonc(dyn assembleuse : &AssembleuseArbre) -> rien
{
    pour noeud dans assembleuse.noeuds {
        détruit_noeud(noeud)
    }

    déloge assembleuse.noeuds

    détruit(assembleuse.pile)
}

empile_noeud :: fonc(
    dyn assembleuse : &AssembleuseArbre,
    type_noeud : TypeNoeud,
    données : &DonnéesLexème,
    ajoute : bool) -> *NoeudSyntaxique
{
	noeud := assembleuse.crée_noeud(type_noeud, données)

	si (!assembleuse.pile.est_vide() && ajoute) {
		assembleuse.ajoute_noeud(noeud)
	}

	assembleuse.pile.empile(noeud)

	retourne noeud
}

ajoute_noeud :: fonc(
    dyn assembleuse : &AssembleuseArbre,
    noeud : *NoeudSyntaxique) -> rien
{
	assembleuse.pile.haut().ajoute_noeud(noeud)
}

crée_noeud :: fonc(
    dyn assembleuse : &AssembleuseArbre,
    type_noeud : TypeNoeud,
    données : &DonnéesLexème) -> *NoeudSyntaxique
{
	dyn noeud := loge NoeudSyntaxique
    noeud.type = type_noeud
    noeud.données = données
    noeud.enfants.taille = 0
    noeud.enfants.pointeur = nul

    tableau_ajoute(@assembleuse.noeuds, noeud)

	retourne noeud
}

dépile_noeud :: fonc(dyn assembleuse : &AssembleuseArbre, type_noeud : TypeNoeud) -> rien
{
	// assert(assembleuse.pile.haut().type == type_noeud)
	assembleuse.pile.dépile()
}
