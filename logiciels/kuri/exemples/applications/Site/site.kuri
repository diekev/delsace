importe Fondation
importe GlibC
importe JSON
importe Réseau
importe SysFichier
importe Temps

charge "catalogue_fichier"
charge "entete_http"
charge "page_accueil"
charge "rendeuse_page"
charge "requête"
charge "serveuse"

chaine_jour_pour_tm :: fonc (tm_wday: z32) -> chaine
{
    discr tm_wday {
        0 { retourne "Sun" }
        1 { retourne "Mon" }
        2 { retourne "Tue" }
        3 { retourne "Wed" }
        4 { retourne "Thu" }
        5 { retourne "Fri" }
        6 { retourne "Sat" }
    }

    retourne ""
}

chaine_mois_pour_tm :: fonc (tm_mon: z32) -> chaine
{
    discr tm_mon {
         0 { retourne "Jan" }
         1 { retourne "Feb" }
         2 { retourne "Mar" }
         3 { retourne "Apr" }
         4 { retourne "May" }
         5 { retourne "Jun" }
         6 { retourne "Jul" }
         7 { retourne "Aug" }
         8 { retourne "Sep" }
         9 { retourne "Oct" }
        10 { retourne "Nov" }
        11 { retourne "Dec" }
    }

    retourne ""
}

chaine_pour_aujourdhui :: fonc (enchaineuse : *Enchaineuse) -> rien
{
    date := hui_système()

    ajoute_au_tampon(enchaineuse, chaine_jour_pour_tm(date.jour_semaine), ", ")

    si date.jour < 10 {
        ajoute_au_tampon(enchaineuse, '0')
    }

    ajoute_au_tampon(enchaineuse, date.jour, " ", chaine_mois_pour_tm(date.mois), " ", date.année)

    ajoute_au_tampon(enchaineuse, " ")

    heure := date.heure

    si heure < 10 {
        ajoute_au_tampon(enchaineuse, '0')
    }

    ajoute_au_tampon(enchaineuse, heure, ":")

    si date.minute < 10 {
        ajoute_au_tampon(enchaineuse, '0')
    }

    ajoute_au_tampon(enchaineuse, date.minute, ":")

    si date.seconde < 10 {
        ajoute_au_tampon(enchaineuse, '0')
    }

    ajoute_au_tampon(enchaineuse, date.seconde)

    ajoute_au_tampon(enchaineuse, " GMT")
}

// ----------------------------

crée_réponse_pour_requête_fichier :: fonc (chm: &CheminFichier) -> RéponseRequête
{
    contenu := contenu_fichier_texte(chm)

    retourne RéponseRequête(
        code = CodeÉtatHTTP.OK,
        type_contenu = TypeContenu.APPLICATION_JAVASCRIPT,
        contenu = contenu
    )
}

Cliente :: struct {
    fichier : Fichier
    adresse : sockaddr_in
}

procède_requête :: fonc (
    serveuse: *Serveuse,
    cliente: Cliente) -> rien
{
    mémoire_présente := mémoire_utilisée()
    temps_présent := compte_ticks_microsecondes()

    diffère {
        imprime_log("", "Mémoire utilisée (avant) : %o", mémoire_présente)
        imprime_log("", "Mémoire utilisée (après) : %o", mémoire_utilisée())
        imprime_log("", "Mémoire consommée        : %o", pic_de_mémoire())
        imprime_log("", "Durée réponse            : %us", compte_ticks_microsecondes() - temps_présent)

        ip := converti_chaine_c(inet_ntoa(cliente.adresse.sin_addr))
        imprime_log("", "IP                       : % ", ip)

        imprime_log("", "")
    }

    diffère {
        // À FAIRE : XXX que faire si erreur lors de la fermeture ?
        _ := ferme(@cliente.fichier)
    }

    requête := tente lis_tout(@cliente.fichier) piège err {
        // @erreur
        imprime("erreur lors de la lecture de la prise : %\n", err)
        retourne
    }

    diffère { déloge requête; }

    // ------------------------------

    //imprime("\nrequête :\n%\n", requête)

    analyseuse : AnalyseuseRequête
    analyseuse.requête = requête
    //analyse_requête(@analyseuse, requete)

    ligne_requête := analyse_ligne_requête(@analyseuse)

    entêtes := analyse_entêtes(@analyseuse)
    diffère { détruit_entêtes(@entêtes); }

    contenu_requête := analyse_contenu(@analyseuse)

/*
    pour entête dans entêtes.données {
        imprime("--- %: %\n", entête.clé, entête.valeur)
    }
*/

    uri := tente parse_uri_depuis_chemin_requête(ligne_requête.chemin) piège err {
        // @erreur
        retourne
    }

    données_requête : DonnéesRequête
    données_requête.uri = uri
    données_requête.entêtes = entêtes
    données_requête.contenu = contenu_requête

    réponse : RéponseRequête
    diffère { déloge réponse.contenu; }

    // À FAIRE : gère les chemin vers les fichiers
    chn_chemin := construit_chaine(uri.chemin.pointeur + 1, uri.chemin.taille - 1)
    chm := construit_chemin(chn_chemin)

    // À FAIRE : gère les permissions
    si fichier_existe(chm) {
        réponse = crée_réponse_pour_requête_fichier(chm)
    }
    sinon {
        trouvée := faux

        pour route dans serveuse.routes {
            si uri.chemin != route.url {
                continue
            }

            trouvée = vrai

            si ligne_requête.méthode == "GET" && route.méthode_get comme *rien != nul {
                rappel := route.méthode_get
                réponse = rappel(serveuse, @données_requête)
                arrête
            }

            si ligne_requête.méthode == "POST" && route.méthode_post comme *rien != nul {
                rappel := route.méthode_post
                réponse = rappel(serveuse, @données_requête)
                arrête
            }

            réponse = crée_réponse_méthode_non_autorisée()
            arrête
        }

        si !trouvée {
            réponse = crée_réponse_page_non_trouvée()
        }
    }

    // ------------------------------

    diffère {
        imprime_log("",
            "% % % - %",
            ligne_requête.méthode,
            ligne_requête.chemin,
            ligne_requête.protocole,
            chaine_code_état_http(réponse.code))
    }

    enchaineuse : Enchaineuse
    initialise_enchaineuse(@enchaineuse)
    diffère { détruit_tampons(@enchaineuse) }

    contenu := réponse.contenu

    ajoute_au_tampon(@enchaineuse, "HTTP/1.1 ", chaine_code_état_http(réponse.code), "\r\n")
    ajoute_au_tampon(@enchaineuse, "Server: delsace\r\n")
    ajoute_au_tampon(@enchaineuse, "Content-Length: ", contenu.taille, "\r\n")

    discr réponse.type_contenu {
        TEXT_HTML {
            ajoute_au_tampon(@enchaineuse, "Content-Type: text/html; charset=utf-8\r\n")
        }
        APPLICATION_JAVASCRIPT {
            ajoute_au_tampon(@enchaineuse, "Content-Type: application/javascript\r\n")
            ajoute_au_tampon(@enchaineuse, "Content-Disposition: attachment; filename='test.js'\r\n")
            ajoute_au_tampon(@enchaineuse, "Cache-Control: public, max-age=31556952, immutable\r\n")
        }
        APPLICATION_JSON {
            ajoute_au_tampon(@enchaineuse, "Content-Type: application/json; charset=utf-8\r\n")
        }
        sinon {
            // RÀF
        }
    }

    ajoute_au_tampon(@enchaineuse, "Date: ")
    chaine_pour_aujourdhui(@enchaineuse)
    ajoute_au_tampon(@enchaineuse, "\r\n")

    // À FAIRE: Content-Encoding, voir Accept-Encoding de la requête

    ajoute_au_tampon(@enchaineuse, "Set-Cookie: test=abcdefg; Domain=localhost; Max-Age=60; Path=/; HttpOnly\r\n")

    ajoute_au_tampon(@enchaineuse, "\r\n")
    ajoute_au_tampon(@enchaineuse, contenu)

    chaine_reponse := chaine_depuis_enchaineuse(@enchaineuse)
    diffère { déloge chaine_reponse; }

    si écris(@cliente.fichier, chaine_reponse) == -1 {
        perror("send".pointeur)
    }
}

INTERRUTION := faux
PRISE_SERVEUSE := -1

accepte :: fonc (serveuse: *Serveuse) -> Cliente
{
    adresse : sockaddr_in
	sin_size := taille_de(sockaddr_in) comme n32

    prise := accept(serveuse.prise, (@adresse) comme *sockaddr, @sin_size)

    cliente : Cliente
    cliente.adresse = adresse
    cliente.fichier.desc = prise

    si prise == -1 {
        retourne cliente
    }

    retourne cliente
}

démarre :: fonc(serveuse : &Serveuse) -> rien
{
    si serveuse.prise == -1 {
        retourne
    }

    nonsûr {
        PRISE_SERVEUSE = serveuse.prise
    }

    boucle {
        cliente := accepte(@serveuse)

        si INTERRUTION {
            arrête
        }

        // @Redondant
        si cliente.fichier.desc == -1 {
            perror("accept".pointeur)
            continue
        }

        procède_requête(@serveuse, cliente)
    }
}

// -------------------------------------------------

rappel_interruption :: fonc (numéro_signal: z32) -> rien #nulctx
{
    nonsûr {
        INTERRUTION = vrai
    }

    // débloque la prise pour pouvoir interrompre la boucle
    flags := fcntl(PRISE_SERVEUSE, F_GETFL, 0);
    // @erreur
    _ := fcntl(PRISE_SERVEUSE, F_SETFL, flags | O_NONBLOCK);
}

ConfigurationServeuse :: struct {
    port : n16
}

principale :: fonc () -> z32
{
    diffère { imprime("Fin du programme, mémoire utilisée %o\n", mémoire_utilisée()); }

    args := arguments_ligne_commande()

    si args.taille != 2 {
        imprime("La ligne de commande doit être : % CONFIGURATION\n", args[0])
        retourne 1
    }

    chemin := construit_chemin(args[1])
    script := contenu_fichier_texte(chemin)
    diffère { déloge script; }

    si script.taille == 0 {
        imprime("Le fichier de configuration est vide !\n")
        retourne 1
    }

    configuration : ConfigurationServeuse

    si !remplis_struct_depuis_chaine_json(script, configuration) {
        imprime("Impossible de lire le fichier de configuration !\n")
        retourne 1
    }

    si configuration.port == 0 {
        imprime("Le port est invalide !\n")
    }

    contexte.logueur = mon_impression_log

    signal(SIGINT, rappel_interruption);

    serveuse : Serveuse
    // @erreur
    _ := construit_serveuse(serveuse, configuration.port)

    // pour les gabarits
    ajoute_fichier(@serveuse.rendeuse_gabarit.catalogue, "accueil", "accueil.html")

    // pour les fichiers statiques
    ajoute_fichier(@serveuse.fichiers_statiques, "test", "test.js")

    ajoute_route(@serveuse, "/", répond_get_page_accueil, répond_post_page_accueil)

    démarre(serveuse)

    détruit_serveuse(@serveuse)

    retourne 0
}

mon_impression_log :: fonc (message: chaine, ident: chaine, mode: ModeLogage, données: *rien) -> rien
{
    imprime("%\n", message)
}

configure_compilation :: fonc () -> rien
{
    options := compilatrice_obtiens_options()
    options.niveau_optimisation = NiveauOptimisation.O3
    compilatrice_ajourne_options(options)
}

//#exécute configure_compilation()
