importe Fondation

// --------------------------------

PaireEntête :: struct {
    clé: chaine
    valeur: chaine
}

EntêtesHTTP :: struct {
    // on ne peut pas utiliser une entêtes de hachage car plusieurs entêtes peuvent avoir la même clé (p.e. Cookie)
    données: []PaireEntête
}

ajoute_paire_entête :: fonc (entêtes: *EntêtesHTTP, clé: chaine, valeur: chaine) -> rien
{
    paire := PaireEntête( clé = clé, valeur = valeur )
    tableau_ajoute(@entêtes.données, paire)
}

détruit_entêtes :: fonc (entêtes: *EntêtesHTTP) -> rien
{
    déloge entêtes.données
}

cherche_entête :: fonc (entêtes: *EntêtesHTTP, clé: chaine) -> *PaireEntête
{
    pour entête dans entêtes.données {
        si entête.clé == clé {
            retourne @entête
        }
    }

    retourne nul
}

// --------------------------------

ÉtatLigneRequête :: énum z32 {
    INVALIDE
    MÉTHODE
    CHEMIN
    PROTOCOLE
    FINI
}

LigneRequête :: struct {
    méthode: chaine
    chemin: chaine
    protocole: chaine
}

ajoute_chaine :: fonc(ligne: *LigneRequête, état: ÉtatLigneRequête, chn: chaine) -> ÉtatLigneRequête
{
    discr état {
        MÉTHODE   { ligne.méthode = chn; retourne ÉtatLigneRequête.CHEMIN; }
        CHEMIN    { ligne.chemin = chn; retourne ÉtatLigneRequête.PROTOCOLE; }
        PROTOCOLE { ligne.protocole = chn; retourne ÉtatLigneRequête.FINI; }
        INVALIDE, FINI { retourne état }
    }

    retourne ÉtatLigneRequête.INVALIDE
}

est_méthode_valide :: fonc(chn: chaine) -> bool
{
    méthodes_http := ["GET", "POST", "PUT", "DELETE", "HEAD", "CONNECT", "OPTIONS", "TRACE", "PATCH"]

    pour méthode dans méthodes_http {
        si méthode == chn {
            retourne vrai
        }
    }

    retourne faux
}

est_requête_valide :: fonc(ligne: *LigneRequête) -> bool
{
    si !est_méthode_valide(ligne.méthode) {
        retourne faux
    }

    retourne vrai
}

AnalyseuseRequête :: struct {
    requête: chaine
    position := 0
    pointeur := 0
    taille_mot := 0
}

analyse_finie :: fonc(analyseuse: *AnalyseuseRequête) -> bool
{
    retourne analyseuse.position >= analyseuse.requête.taille
}

caractère_courant :: fonc(analyseuse: *AnalyseuseRequête) -> z8
{
    retourne analyseuse.requête[analyseuse.position]
}

analyse_entêtes :: fonc(analyseuse: *AnalyseuseRequête) -> EntêtesHTTP
{
    //temps_présent := compte_ticks_microsecondes()
    //diffère { imprime_log("", "Durée analyse requête : %µs", compte_ticks_microsecondes() - temps_présent) }

    entêtes : EntêtesHTTP

    analyseuse.taille_mot = 0

    tantque !analyse_finie(analyseuse) {
        si analyseuse.caractère_courant() == '\r' {
            analyseuse.position += 1
            continue
        }

        si analyseuse.caractère_courant() == '\n' {
            analyseuse.position += 1
            arrête
        }

        tantque analyseuse.caractère_courant() == ' ' {
            analyseuse.position += 1
        }

        analyseuse.pointeur = analyseuse.position
        analyseuse.taille_mot = 0

        tantque !analyse_finie(analyseuse) {
            si analyseuse.caractère_courant() == ':' {
                arrête
            }

            analyseuse.taille_mot += 1
            analyseuse.position += 1
        }

        clé := analyseuse.mot_courant()

        analyseuse.position += 1

        tantque analyseuse.caractère_courant() == ' ' {
            analyseuse.position += 1
        }

        analyseuse.pointeur = analyseuse.position
        analyseuse.taille_mot = 0

        tantque !analyse_finie(analyseuse) {
            si analyseuse.caractère_courant() == '\r' {
                analyseuse.position += 1
                continue
            }

            si analyseuse.caractère_courant() == '\n' {
                analyseuse.position += 1
                arrête
            }

            analyseuse.taille_mot += 1
            analyseuse.position += 1
        }

        valeur := analyseuse.mot_courant()

        ajoute_paire_entête(@entêtes, clé, valeur)

        //imprime("--- ", clé, ": ", valeur, "\n")
    }

    retourne entêtes
}

analyse_requête :: fonc(analyseuse: *AnalyseuseRequête, requête: chaine) -> rien
{
    //imprime("requête :\n%\n", requête)

    analyseuse.requête = requête

    ligne_requête := analyse_ligne_requête(analyseuse)

    //imprime("Ligne requête : %\n", ligne_requête)


    // analyse_contenu (pour une réponse)
}

mot_courant :: fonc(analyseuse: *AnalyseuseRequête) -> chaine
{
    retourne construit_chaine(@analyseuse.requête[analyseuse.pointeur], analyseuse.taille_mot)
}

analyse_ligne_requête :: fonc(analyseuse: *AnalyseuseRequête) -> LigneRequête
{
    ligne_requête : LigneRequête
    état := ÉtatLigneRequête.MÉTHODE

    tantque !analyse_finie(analyseuse) {
        c := analyseuse.caractère_courant()

        si c == ' ' {
            si analyseuse.taille_mot != 0 {
                chn := analyseuse.mot_courant()
                état = ajoute_chaine(@ligne_requête, état, chn)
                analyseuse.taille_mot = 0
            }
        }
        sinon si c == '\r' {
            analyseuse.position += 1
            continue
        }
        sinon si c == '\n' {
            si analyseuse.taille_mot != 0 {
                chn := analyseuse.mot_courant()
                état = ajoute_chaine(@ligne_requête, état, chn)
                analyseuse.taille_mot = 0
            }

            analyseuse.position += 1
            arrête
        }
        sinon {
            si analyseuse.taille_mot == 0 {
                analyseuse.pointeur = analyseuse.position
            }

            analyseuse.taille_mot += 1
        }

        analyseuse.position += 1
    }

    retourne ligne_requête
}

analyse_contenu :: fonc (analyseuse: *AnalyseuseRequête) -> chaine
{
    si analyse_finie(analyseuse) {
        retourne ""
    }

    // le contenu est le reste de la requête
    analyseuse.pointeur = analyseuse.position
    analyseuse.taille_mot = (analyseuse.requête.taille - analyseuse.position) comme z32

    retourne analyseuse.mot_courant()
}

test_entete_http :: fonc() -> z32
{
    entête := "GET / HTTP/1.1
Host: localhost:5005
Connection: keep-alive
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.87 Safari/537.36
Sec-Fetch-Dest: document
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Sec-Fetch-Site: cross-site
Sec-Fetch-Mode: navigate
Accept-Encoding: gzip, deflate, br
Accept-Language: fr-FR,fr;q=0.9,en-US;q=0.8,en;q=0.7,ja;q=0.6
"

    analyseuse : AnalyseuseRequête
    analyse_requête(@analyseuse, entête)

    retourne 0
}
