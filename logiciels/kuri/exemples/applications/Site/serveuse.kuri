importe Fondation
importe GlibC
importe Réseau
importe SysFichier

charge "entete_http"

#inclus "time.h"

// @Interface : z64 ici est time_t (pour linux en tout cas)
time :: fonc externe (tloc: *z64) -> z64

/* ISO C `broken-down time' structure.  */
// @Interface : doit être synchronisée avec struct_tm.h
tm :: struct externe {
    tm_sec: z32      /* Seconds.      [0-60] (1 leap second) */
    tm_min: z32      /* Minutes.      [0-59] */
    tm_hour: z32     /* Hours.        [0-23] */
    tm_mday: z32     /* Day.          [1-31] */
    tm_mon: z32      /* Month.        [0-11] */
    tm_year: z32     /* Year - 1900. */
    tm_wday: z32     /* Day of week.  [0-6] */
    tm_yday: z32     /* Days in year. [0-365] */
    tm_isdst: z32    /* DST.          [-1/0/1] */
    tm_gmtoff : z64; /* Seconds east of UTC.  */
    tm_zone : *z8;   /* Timezone abbreviation.  */
}

localtime :: fonc externe (tloc: *z64) -> *tm

chaine_jour_pour_tm :: fonc (tm_wday: z32) -> chaine
{
    discr tm_wday {
        0 { retourne "Sun" }
        1 { retourne "Mon" }
        2 { retourne "Tue" }
        3 { retourne "Wed" }
        4 { retourne "Thu" }
        5 { retourne "Fri" }
        6 { retourne "Sat" }
    }

    retourne ""
}

chaine_mois_pour_tm :: fonc (tm_mon: z32) -> chaine
{
    discr tm_mon {
         0 { retourne "Jan" }
         1 { retourne "Feb" }
         2 { retourne "Mar" }
         3 { retourne "Apr" }
         4 { retourne "May" }
         5 { retourne "Jun" }
         6 { retourne "Jul" }
         7 { retourne "Aug" }
         8 { retourne "Sep" }
         9 { retourne "Oct" }
        10 { retourne "Nov" }
        11 { retourne "Dec" }
    }

    retourne ""
}

chaine_pour_aujourdhui :: fonc () -> chaine
{
    t := time(nul)
    tm_ := localtime(@t);

    // À FAIRE : ajoute d'options de formattage pour les nombres dans les fonctions "imprime..."
    dyn enchaineuse : Enchaineuse
    initialise_enchaineuse(@enchaineuse)

    diffère { détruit_tampons(@enchaineuse) }

    ajoute_au_tampon(@enchaineuse, chaine_jour_pour_tm(tm_.tm_wday), ", ")

    si tm_.tm_mday < 10 {
        ajoute_au_tampon(@enchaineuse, '0')
    }

    ajoute_au_tampon(@enchaineuse, tm_.tm_mday, " ", chaine_mois_pour_tm(tm_.tm_mon), " ", tm_.tm_year + 1900)

    ajoute_au_tampon(@enchaineuse, " ")

    // nous sommes en CET, HTTP doit être en GMT
    heure := tm_.tm_hour - 1

    si heure < 10 {
        ajoute_au_tampon(@enchaineuse, '0')
    }

    ajoute_au_tampon(@enchaineuse, heure, ":")

    si tm_.tm_min < 10 {
        ajoute_au_tampon(@enchaineuse, '0')
    }

    ajoute_au_tampon(@enchaineuse, tm_.tm_min, ":")

    si tm_.tm_sec < 10 {
        ajoute_au_tampon(@enchaineuse, '0')
    }

    ajoute_au_tampon(@enchaineuse, tm_.tm_sec)

    ajoute_au_tampon(@enchaineuse, " GMT")

    retourne chaine_depuis_enchaineuse(@enchaineuse)
}

// ----------------------------

// une liste complète des types de contenu peut se trouver ici :
// https://www.iana.org/assignments/media-types/media-types.xhtml
TypeContenu :: énum z32 {
    INVALIDE
    APPLICATION_JAVASCRIPT
    APPLICATION_JSON
    TEXT_HTML
}

RéponseRequête :: struct {
    code : CodeÉtatHTTP
    type_contenu : TypeContenu
    contenu : chaine
}

FichierTexte :: struct {
    nom_court : chaine
    chemin : chaine

    données : chaine

    succès := faux
}

// À FAIRE: rechargement des fichiers, s'ils ont changés
commence_fichier :: fonc (dyn fichier: *FichierTexte) -> rien
{
    chm := construit_chemin(fichier.chemin)
    fichier.données = contenu_fichier_texte(chm)
    fichier.succès = vrai
}

CatalogueFichier :: struct {
    fichiers : []FichierTexte
}

trouve_fichier :: fonc (catalogue: *CatalogueFichier, nom_court: chaine) -> *FichierTexte
{
    pour fichier dans catalogue.fichiers {
        si fichier.nom_court == nom_court {
            retourne @fichier
        }
    }

    retourne nul
}

ajoute_fichier :: fonc (catalogue: *CatalogueFichier, nom_court: chaine, chemin: chaine) -> rien
{
    fichier := trouve_fichier(catalogue, nom_court)

    si fichier != nul {
        retourne
    }

    dyn nouveau_fichier : FichierTexte
    nouveau_fichier.nom_court = nom_court
    nouveau_fichier.chemin = chemin

    tableau_ajoute(@catalogue.fichiers, nouveau_fichier)
}

détruit_catalogue :: fonc (catalogue: *CatalogueFichier) -> rien
{
    pour fichier dans catalogue.fichiers {
        déloge fichier.données
    }

    déloge catalogue.fichiers
}

RendeusePage :: struct {
    catalogue : CatalogueFichier
}

crée_réponse_fichier_gabarit_manquant :: fonc () -> RéponseRequête
{
    retourne RéponseRequête{
        code = CodeÉtatHTTP.INTERNAL_SERVER_ERROR,
        type_contenu = TypeContenu.TEXT_HTML,
        // À FAIRE : évite de copier la chaine
        contenu = copie_chaine("<p>La page du gabarit n'est pas trouvable !</p>")
    }
}

rends_page :: fonc (rendeuse_gabarit: *RendeusePage, nom_court: chaine) -> RéponseRequête
{
    fichier := trouve_fichier(@rendeuse_gabarit.catalogue, nom_court)

    si fichier == nul {
        retourne crée_réponse_fichier_gabarit_manquant()
    }

    si fichier.données.taille == 0 {
        commence_fichier(fichier)
    }

    si fichier.succès == faux {
        retourne crée_réponse_fichier_gabarit_manquant()
    }

    retourne RéponseRequête{
        code = CodeÉtatHTTP.OK,
        type_contenu = TypeContenu.TEXT_HTML,
        // À FAIRE : évite de copier la chaine
        contenu = copie_chaine(fichier.données)
    }
}

// ----------------------------

CONNEXIONS_MAX := 1000

Route :: struct {
    url : chaine
    méthode_get : fonc(*rien, *rien)(RéponseRequête) = nul
    méthode_post : fonc(*rien, *rien)(RéponseRequête) = nul
}

Serveuse :: struct {
    prise := -1
    rendeuse_gabarit : RendeusePage
    // pour les fichiers javascripts, css, ou encore les images
    fichiers_statiques : CatalogueFichier

    routes: []Route
}

construit_serveuse :: fonc(dyn serveuse : &Serveuse, port : n16) -> chaine
{
    serveuse.prise = socket(_AF_INET, _SOCK_STREAM, 0)

    si serveuse.prise == -1 {
        retourne "erreur lors de la création de la prise"
    }

    enable := 1
    si setsockopt(serveuse.prise, _SOL_SOCKET, _SO_REUSEADDR, @enable, taille_de(z32)) < 0 {
        close(serveuse.prise)
        retourne "setsockopt(SO_REUSEADDR) failed"
    }

    dyn adresse_du_connecté : sockaddr_in
	adresse_du_connecté.sin_family = transtype(_AF_INET : n16)
    adresse_du_connecté.sin_port = htons(port)
    // trouve notre propre adresse
	adresse_du_connecté.sin_addr.s_addr = transtype(0 : n32)
    adresse_du_connecté.sin_zero[0] = transtype(0 : n8)
    adresse_du_connecté.sin_zero[1] = transtype(0 : n8)
    adresse_du_connecté.sin_zero[2] = transtype(0 : n8)
    adresse_du_connecté.sin_zero[3] = transtype(0 : n8)
    adresse_du_connecté.sin_zero[4] = transtype(0 : n8)
    adresse_du_connecté.sin_zero[5] = transtype(0 : n8)
    adresse_du_connecté.sin_zero[6] = transtype(0 : n8)
    adresse_du_connecté.sin_zero[7] = transtype(0 : n8)

	dyn err := bind(serveuse.prise, transtype(@adresse_du_connecté : *sockaddr), transtype(taille_de(sockaddr): n64))

	si err == -1 {
		retourne "erreur lors de la liaison"
	}

	err = listen(serveuse.prise, CONNEXIONS_MAX)

	si err == -1 {
		retourne "erreur lors de l'écoute"
	}

    retourne ""
}

détruit_serveuse :: fonc (dyn serveuse: *Serveuse) -> rien
{
    si serveuse.prise != -1 {
        close(serveuse.prise)
    }

    déloge serveuse.routes

    détruit_catalogue(@serveuse.fichiers_statiques)
    détruit_catalogue(@serveuse.rendeuse_gabarit.catalogue)
}

charge_donnees_requete :: fonc(prise : z32, adresse_du_connecté : &sockaddr_in) -> chaine
{
    MAXDATASIZE : n64 = transtype(1024 : n64)

    dyn tampon : [1024]z8
    dyn requete : chaine

    boucle {
        taille_reçue := recv(prise, @tampon[0], MAXDATASIZE, 0)

        si taille_reçue > 0 {
            ancienne_taille := requete.taille
            reloge requete : chaine(requete.taille + taille_reçue)
            copie_mem_nonsur(src=@tampon[0], dst=@requete[ancienne_taille], taille=taille_reçue)

            si taille_reçue < transtype(MAXDATASIZE: z64) {
                arrête
            }
        }
        sinon si taille_reçue == 0 {
            arrête
        }
        sinon si taille_reçue == -1 {
            // À FAIRE : erreur
            arrête
        }
    }

    //imprime("requete :\n", requete, '\n')

    retourne requete
}

DonnéesRequête :: struct {
    uri : URI
    entêtes : EntêtesHTTP
    contenu : chaine
}

crée_réponse_page_non_trouvée :: fonc () -> RéponseRequête
{
    retourne RéponseRequête{
        code = CodeÉtatHTTP.NOT_FOUND,
        type_contenu = TypeContenu.TEXT_HTML,
        // À FAIRE : évite de copier la chaine
        contenu = copie_chaine("<p>La page n'existe pas</p>")
    }
}

crée_réponse_méthode_non_autorisée :: fonc () -> RéponseRequête
{
    retourne RéponseRequête{
        code = CodeÉtatHTTP.METHOD_NOT_ALLOWED,
        type_contenu = TypeContenu.TEXT_HTML,
        // À FAIRE : évite de copier la chaine
        contenu = copie_chaine("<p>La méthode n'est pas autorisée !</p>")
    }
}

crée_réponse_pour_requête_fichier :: fonc (chm: &CheminFichier) -> RéponseRequête
{
    contenu := contenu_fichier_texte(chm)

    retourne RéponseRequête{
        code = CodeÉtatHTTP.OK,
        type_contenu = TypeContenu.APPLICATION_JAVASCRIPT,
        contenu = contenu
    }
}

répond_get_page_accueil :: fonc (serveuse: *Serveuse, requête: *DonnéesRequête) -> RéponseRequête
{
    retourne rends_page(@serveuse.rendeuse_gabarit, "accueil")
}

répond_post_page_accueil :: fonc (serveuse: *Serveuse, requête: *DonnéesRequête) -> RéponseRequête
{
    enchaineuse : Enchaineuse
    diffère { détruit_tampons(@enchaineuse) }

    initialise_enchaineuse(@enchaineuse)

    entête := cherche_entête(@requête.entêtes, "Content-Type")

    // Le contenu est dans les paramètres de l'URL
    si entête.valeur == "application/x-www-form-urlencoded" {
        // À FAIRE: normalise les données
    }
    // nous avons une chaine json
    sinon si entête.valeur == "application/json" {

    }

    entête_longueur_contenu := cherche_entête(@requête.entêtes, "Content-Length")

    longueur_contenu := extrait_nombre_entier(entête_longueur_contenu.valeur)

    si longueur_contenu != requête.contenu.taille {
        ajoute_au_tampon(@enchaineuse, "<p>Les longueurs ne correspondent pas !</p>")
    }
    sinon {
        ajoute_au_tampon(@enchaineuse, "<p>Vous avez posté quelque chose !</p>")
        // À FAIRE : dépassement des limites de la chaine
        ajoute_au_tampon(@enchaineuse, "<p>Le contenu est de '", requête.contenu, "'</p>")
        //ajoute_au_tampon(@enchaineuse, "<p>Le contenu est de '")
        //ajoute_au_tampon(@enchaineuse, contenu_requête)
        //ajoute_au_tampon(@enchaineuse, "'</p>")
    }

    retourne RéponseRequête{
        code = CodeÉtatHTTP.OK,
        type_contenu = TypeContenu.TEXT_HTML,
        // À FAIRE
        contenu = chaine_depuis_enchaineuse(@enchaineuse)
    }
}

procède_requête :: fonc (
    serveuse: *Serveuse,
    prise: z32,
    adresse_du_connecté: sockaddr_in) -> rien
{
    mémoire_présente := mémoire_utilisée()
    temps_présent := compte_ticks_microsecondes()

    diffère {
        imprime_log(ModeLogage.AUCUN, "", "Mémoire utilisée (avant) : %o", mémoire_présente)
        imprime_log(ModeLogage.AUCUN, "", "Mémoire utilisée (après) : %o", mémoire_utilisée())
        imprime_log(ModeLogage.AUCUN, "", "Mémoire consommée        : %o", pic_de_mémoire())
        imprime_log(ModeLogage.AUCUN, "", "Durée réponse            : %us", compte_ticks_microsecondes() - temps_présent)

        ip := converti_chaine_c(inet_ntoa(adresse_du_connecté.sin_addr))
        imprime_log(ModeLogage.AUCUN, "", "IP                       : % ", ip)

        imprime_log(ModeLogage.AUCUN, "", "")
    }

    requête := charge_donnees_requete(prise, adresse_du_connecté)
    diffère { déloge requête; }

    // ------------------------------

    //imprime("\nrequête :\n%\n", requête)

    dyn analyseuse : AnalyseuseRequête
    analyseuse.requête = requête
    //analyse_requête(@analyseuse, requete)

    dyn ligne_requête := analyse_ligne_requête(@analyseuse)

    dyn entêtes := analyse_entêtes(@analyseuse)
    diffère { détruit_entêtes(@entêtes); }

    dyn contenu_requête := analyse_contenu(@analyseuse)

/*
    pour entête dans entêtes.données {
        imprime("--- %: %\n", entête.clé, entête.valeur)
    }
*/

    uri := construit_uri_depuis_chemin_requête(ligne_requête.chemin)

    dyn données_requête : DonnéesRequête
    données_requête.uri = uri
    données_requête.entêtes = entêtes
    données_requête.contenu = contenu_requête

    dyn réponse : RéponseRequête
    diffère { déloge réponse.contenu; }

    // À FAIRE : gère les chemin vers les fichiers
    chn_chemin := construit_chaine(uri.chemin.pointeur + 1, uri.chemin.taille - 1)
    chm := construit_chemin(chn_chemin)

    // À FAIRE : gère les permissions
    si fichier_existe(chm) {
        réponse = crée_réponse_pour_requête_fichier(chm)
    }
    sinon {
        dyn trouvée := faux

        pour route dans serveuse.routes {
            si uri.chemin != route.url {
                continue
            }

            trouvée = vrai

            si ligne_requête.méthode == "GET" && transtype(route.méthode_get: *rien) != nul {
                rappel := route.méthode_get
                réponse = rappel(serveuse, @données_requête)
                arrête
            }

            si ligne_requête.méthode == "POST" && transtype(route.méthode_post: *rien) != nul {
                rappel := route.méthode_post
                réponse = rappel(serveuse, @données_requête)
                arrête
            }

            réponse = crée_réponse_méthode_non_autorisée()
            arrête
        }

        si !trouvée {
            réponse = crée_réponse_page_non_trouvée()
        }
    }

    // ------------------------------

    diffère {
        imprime_log(ModeLogage.AUCUN, "",
            "% % % - %",
            ligne_requête.méthode,
            ligne_requête.chemin,
            ligne_requête.protocole,
            chaine_code_état_http(réponse.code))
    }

    enchaineuse : Enchaineuse
    initialise_enchaineuse(@enchaineuse)
    diffère { détruit_tampons(@enchaineuse) }

    contenu := réponse.contenu

    ajoute_au_tampon(@enchaineuse, "HTTP/1.1 ", chaine_code_état_http(réponse.code), "\r\n")
    ajoute_au_tampon(@enchaineuse, "Server: delsace\r\n")
    ajoute_au_tampon(@enchaineuse, "Content-Length: ", contenu.taille, "\r\n")

    discr réponse.type_contenu {
        TEXT_HTML {
            ajoute_au_tampon(@enchaineuse, "Content-Type: text/html; charset=utf-8\r\n")
        }
        APPLICATION_JAVASCRIPT {
            ajoute_au_tampon(@enchaineuse, "Content-Type: application/javascript\r\n")
            ajoute_au_tampon(@enchaineuse, "Content-Disposition: attachment; filename='test.js'\r\n")
            ajoute_au_tampon(@enchaineuse, "Cache-Control: public, max-age=31556952, immutable\r\n")
        }
        APPLICATION_JSON {
            ajoute_au_tampon(@enchaineuse, "Content-Type: application/json; charset=utf-8\r\n")
        }
        sinon {
            // RÀF
        }
    }

    date := chaine_pour_aujourdhui()
    diffère { déloge date; }
    ajoute_au_tampon(@enchaineuse, "Date: ", date, "\r\n")

    // À FAIRE: Content-Encoding, voir Accept-Encoding de la requête

    ajoute_au_tampon(@enchaineuse, "Set-Cookie: test=abcdefg; Domain=localhost; Max-Age=60; Path=/; HttpOnly\r\n")

    ajoute_au_tampon(@enchaineuse, "\r\n")
    ajoute_au_tampon(@enchaineuse, contenu)

    chaine_reponse := chaine_depuis_enchaineuse(@enchaineuse)
    diffère { déloge chaine_reponse; }

    si send(prise, chaine_reponse.pointeur, chaine_reponse.taille, 0) == -1 {
        perror("send".pointeur)
    }

    close(prise)
}

dyn INTERRUTION := faux
dyn PRISE_SERVEUSE := -1

démarre :: fonc(dyn serveuse : &Serveuse) -> rien
{
    si serveuse.prise == -1 {
        retourne
    }

    nonsûr {
        PRISE_SERVEUSE = serveuse.prise
    }

    dyn adresse_du_connecté : sockaddr_in
	sin_size := transtype(taille_de(sockaddr_in) : n32)

    boucle {
        prise := accept(serveuse.prise, transtype(@adresse_du_connecté : *sockaddr), @sin_size)

        si INTERRUTION {
            arrête
        }

        si prise == -1 {
            perror("accept".pointeur)
            continue
        }

        //si fork() == 0 {
        procède_requête(@serveuse, prise, adresse_du_connecté)
        //    exit(0)
       // }

        // le parent n'a pas besoin de cela
       // close(prise)

        // nettoyage des processus fils
        //tantque waitpid(-1, nul, _WNOHANG) > 0 {}
    }
}

// -------------------------------------------------

#nulctx rappel_interruption :: fonc (numéro_signal: z32) -> rien
{
    nonsûr {
        INTERRUTION = vrai
    }

    // débloque la prise pour pouvoir interrompre la boucle
    flags := fcntl(PRISE_SERVEUSE, _F_GETFL, 0);
    fcntl(PRISE_SERVEUSE, _F_SETFL, flags | _O_NONBLOCK);
}

ajoute_route :: fonc (
    serveuse: *Serveuse,
    url: chaine,
    méthode_get: fonc(*Serveuse, *DonnéesRequête)(RéponseRequête),
    méthode_post: fonc(*Serveuse, *DonnéesRequête)(RéponseRequête)) -> rien
{
    dyn route : Route
    route.url = url
    route.méthode_get = transtype(méthode_get: fonc(*rien, *rien)(RéponseRequête))
    route.méthode_post = transtype(méthode_post: fonc(*rien, *rien)(RéponseRequête))

    tableau_ajoute(@serveuse.routes, route)
}

principale :: fonc () -> z32
{
    diffère { imprime("Fin du programme, mémoire utilisée %o\n", mémoire_utilisée()); }

    contexte.logueur = mon_impression_log

    signal(_SIGINT, rappel_interruption);

    dyn serveuse : Serveuse
    construit_serveuse(serveuse, transtype(5001 : n16))

    // pour les gabarits
    ajoute_fichier(@serveuse.rendeuse_gabarit.catalogue, "accueil", "accueil.html")

    // pour les fichiers statiques
    ajoute_fichier(@serveuse.fichiers_statiques, "test", "test.js")

    ajoute_route(@serveuse, "/", répond_get_page_accueil, répond_post_page_accueil)

    démarre(serveuse)

    détruit_serveuse(@serveuse)

    retourne 0
}

mon_impression_log :: fonc (message: chaine, ident: chaine, mode: ModeLogage, données: *rien) -> rien
{
    imprime("%\n", message)
}
