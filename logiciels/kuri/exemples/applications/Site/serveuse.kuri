importe Fondation
importe GlibC
importe Réseau

charge "entete_http"

#inclus "time.h"

// @Interface : z64 ici est time_t (pour linux en tout cas)
time :: fonc externe (tloc: *z64) -> z64

/* ISO C `broken-down time' structure.  */
// @Interface : doit être synchronisée avec struct_tm.h
tm :: struct externe {
    tm_sec: z32      /* Seconds.      [0-60] (1 leap second) */
    tm_min: z32      /* Minutes.      [0-59] */
    tm_hour: z32     /* Hours.        [0-23] */
    tm_mday: z32     /* Day.          [1-31] */
    tm_mon: z32      /* Month.        [0-11] */
    tm_year: z32     /* Year - 1900. */
    tm_wday: z32     /* Day of week.  [0-6] */
    tm_yday: z32     /* Days in year. [0-365] */
    tm_isdst: z32    /* DST.          [-1/0/1] */
    tm_gmtoff : z64; /* Seconds east of UTC.  */
    tm_zone : *z8;   /* Timezone abbreviation.  */
}

localtime :: fonc externe (tloc: *z64) -> *tm

chaine_jour_pour_tm :: fonc (tm_wday: z32) -> chaine
{
    discr tm_wday {
        0 { retourne "Sun" }
        1 { retourne "Mon" }
        2 { retourne "Tue" }
        3 { retourne "Wed" }
        4 { retourne "Thu" }
        5 { retourne "Fri" }
        6 { retourne "Sat" }
    }

    retourne ""
}

chaine_mois_pour_tm :: fonc (tm_mon: z32) -> chaine
{
    discr tm_mon {
         0 { retourne "Jan" }
         1 { retourne "Feb" }
         2 { retourne "Mar" }
         3 { retourne "Apr" }
         4 { retourne "May" }
         5 { retourne "Jun" }
         6 { retourne "Jul" }
         7 { retourne "Aug" }
         8 { retourne "Sep" }
         9 { retourne "Oct" }
        10 { retourne "Nov" }
        11 { retourne "Dec" }
    }

    retourne ""
}

chaine_pour_aujourdhui :: fonc () -> chaine
{
    t := time(nul)
    tm_ := localtime(@t);

    // À FAIRE : ajoute d'options de formattage pour les nombres dans les fonctions "imprime..."
    dyn enchaineuse : Enchaineuse
    initialise_enchaineuse(@enchaineuse)

    diffère { détruit_tampons(@enchaineuse) }

    ajoute_au_tampon(@enchaineuse, chaine_jour_pour_tm(tm_.tm_wday), ", ")

    si tm_.tm_mday < 10 {
        ajoute_au_tampon(@enchaineuse, '0')
    }

    ajoute_au_tampon(@enchaineuse, tm_.tm_mday, " ", chaine_mois_pour_tm(tm_.tm_mon), " ", tm_.tm_year + 1900)

    ajoute_au_tampon(@enchaineuse, " ")

    // nous sommes en CET, HTTP doit être en GMT
    heure := tm_.tm_hour - 1

    si heure < 10 {
        ajoute_au_tampon(@enchaineuse, '0')
    }

    ajoute_au_tampon(@enchaineuse, heure, ":")

    si tm_.tm_min < 10 {
        ajoute_au_tampon(@enchaineuse, '0')
    }

    ajoute_au_tampon(@enchaineuse, tm_.tm_min, ":")

    si tm_.tm_sec < 10 {
        ajoute_au_tampon(@enchaineuse, '0')
    }

    ajoute_au_tampon(@enchaineuse, tm_.tm_sec)

    ajoute_au_tampon(@enchaineuse, " GMT")

    retourne chaine_depuis_enchaineuse(@enchaineuse)
}

// ----------------------------

CONNEXIONS_MAX := 1000

dyn PRISE_SERVEUSE := -1

Serveuse :: struct {
    prise := -1
}

setsockopt :: fonc externe (sockfd: z32, level: z32, optname: z32, optval: *rien, optlen: n64) -> z32

_SOL_SOCKET := 1
_SO_REUSEADDR := 2

construit_serveuse :: fonc(dyn serveuse : &Serveuse, port : n16) -> chaine
{
    serveuse.prise = socket(_AF_INET, _SOCK_STREAM, 0)

    si serveuse.prise == -1 {
        retourne "erreur lors de la création de la prise"
    }

    enable := 1
    si setsockopt(serveuse.prise, _SOL_SOCKET, _SO_REUSEADDR, @enable, taille_de(z32)) < 0 {
        close(serveuse.prise)
        retourne "setsockopt(SO_REUSEADDR) failed"
    }

    dyn adresse_du_connecté : sockaddr_in
	adresse_du_connecté.sin_family = transtype(_AF_INET : n16)
    adresse_du_connecté.sin_port = htons(port)
    // trouve notre propre adresse
	adresse_du_connecté.sin_addr.s_addr = transtype(0 : n32)
    adresse_du_connecté.sin_zero[0] = transtype(0 : n8)
    adresse_du_connecté.sin_zero[1] = transtype(0 : n8)
    adresse_du_connecté.sin_zero[2] = transtype(0 : n8)
    adresse_du_connecté.sin_zero[3] = transtype(0 : n8)
    adresse_du_connecté.sin_zero[4] = transtype(0 : n8)
    adresse_du_connecté.sin_zero[5] = transtype(0 : n8)
    adresse_du_connecté.sin_zero[6] = transtype(0 : n8)
    adresse_du_connecté.sin_zero[7] = transtype(0 : n8)

	dyn err := bind(serveuse.prise, transtype(@adresse_du_connecté : *sockaddr), transtype(taille_de(sockaddr): n64))

	si err == -1 {
		retourne "erreur lors de la liaison"
	}

	err = listen(serveuse.prise, CONNEXIONS_MAX)

	si err == -1 {
		retourne "erreur lors de l'écoute"
	}

    nonsûr {
        PRISE_SERVEUSE = serveuse.prise
    }

    retourne ""
}

détruit_serveuse :: fonc(dyn serveuse : &Serveuse) -> rien
{
    si serveuse.prise == -1 {
        retourne
    }

    close(serveuse.prise)
}

charge_donnees_requete :: fonc(prise : z32, adresse_du_connecté : &sockaddr_in) -> chaine
{
    MAXDATASIZE : n64 = transtype(1024 : n64)

    dyn tampon : [1024]z8
    dyn requete : chaine

    boucle {
        taille_reçue := recv(prise, @tampon[0], MAXDATASIZE, 0)

        si taille_reçue > 0 {
            ancienne_taille := requete.taille
            reloge requete : chaine(requete.taille + taille_reçue)
            copie_mem_nonsur(src=@tampon[0], dst=@requete[ancienne_taille], taille=taille_reçue)

            si taille_reçue < transtype(MAXDATASIZE: z64) {
                arrête
            }
        }
        sinon si taille_reçue == 0 {
            arrête
        }
        sinon si taille_reçue == -1 {
            // À FAIRE : erreur
            arrête
        }
    }

    //imprime("requete :\n", requete, '\n')

    retourne requete
}

DonnéesRequête :: struct {
    uri : URI
    entêtes : EntêtesHTTP
    contenu : chaine
}

// une liste complète des types de contenu peut se trouver ici :
// https://www.iana.org/assignments/media-types/media-types.xhtml
TypeContenu :: énum z32 {
    INVALIDE
    APPLICATION_JAVASCRIPT
    APPLICATION_JSON
    TEXT_HTML
}

RéponseRequête :: struct {
    code : CodeÉtatHTTP
    type_contenu : TypeContenu
    contenu : chaine
}

crée_réponse_page_non_trouvée :: fonc () -> RéponseRequête
{
    retourne RéponseRequête{
        code = CodeÉtatHTTP.NOT_FOUND,
        type_contenu = TypeContenu.TEXT_HTML,
        // À FAIRE : évite de copier la chaine
        contenu = copie_chaine("<p>La page n'existe pas</p>")
    }
}

crée_réponse_méthode_non_autorisée :: fonc () -> RéponseRequête
{
    retourne RéponseRequête{
        code = CodeÉtatHTTP.METHOD_NOT_ALLOWED,
        type_contenu = TypeContenu.TEXT_HTML,
        // À FAIRE : évite de copier la chaine
        contenu = copie_chaine("<p>La méthode n'est pas autorisée !</p>")
    }
}

importe SysFichier

crée_réponse_pour_requête_fichier :: fonc (chm: &CheminFichier) -> RéponseRequête
{
    contenu := contenu_fichier_texte(chm)

    retourne RéponseRequête{
        code = CodeÉtatHTTP.OK,
        type_contenu = TypeContenu.APPLICATION_JAVASCRIPT,
        contenu = contenu
    }
}

répond_get_page_accueil :: fonc (requête: *DonnéesRequête) -> RéponseRequête
{
    enchaineuse : Enchaineuse
    diffère { détruit_tampons(@enchaineuse) }

    initialise_enchaineuse(@enchaineuse)

    ajoute_au_tampon(@enchaineuse, "<!DOCTYPE html>")
    ajoute_au_tampon(@enchaineuse, "<html lang='fr'>")
    ajoute_au_tampon(@enchaineuse, "<head>")
    ajoute_au_tampon(@enchaineuse, "<meta charset='utf-8'/>")
    ajoute_au_tampon(@enchaineuse, "<meta name='viewport' content='width=device-width, initial-scale=1.0'/>")
    ajoute_au_tampon(@enchaineuse, "<link rel='shortlink icon' href='/static/favicon-16x16.png'>")
    ajoute_au_tampon(@enchaineuse, "<link rel='icon' type='image/png' sizes='32x32' href='/static/favicon-32x32.png'>")
    ajoute_au_tampon(@enchaineuse, "</head>")
    ajoute_au_tampon(@enchaineuse, "<body>")
    ajoute_au_tampon(@enchaineuse, "<script src='/test.js'></script>")
    ajoute_au_tampon(@enchaineuse, "<p>Vous avez utilisez la méthode GET</p>")

    si requête.uri.requête != "" {
        ajoute_au_tampon(@enchaineuse, "<p>Les paramètres sont : '", requête.uri.requête, "'\n")
    }

    ajoute_au_tampon(@enchaineuse, "<form>")
    ajoute_au_tampon(@enchaineuse, "<label for='POST-name'>Name:</label>")
    ajoute_au_tampon(@enchaineuse, "<input id='POST-name' type='text' name='name'>")
    ajoute_au_tampon(@enchaineuse, "<button type='submit' value='Save'>")
    ajoute_au_tampon(@enchaineuse, "</form>")
    ajoute_au_tampon(@enchaineuse, "</body>")
    ajoute_au_tampon(@enchaineuse, "</html>")

    retourne RéponseRequête{
        code = CodeÉtatHTTP.OK,
        type_contenu = TypeContenu.TEXT_HTML,
        contenu = chaine_depuis_enchaineuse(@enchaineuse)
    }
}

répond_post_page_accueil :: fonc (requête: *DonnéesRequête) -> RéponseRequête
{
    enchaineuse : Enchaineuse
    diffère { détruit_tampons(@enchaineuse) }

    initialise_enchaineuse(@enchaineuse)

    entête := cherche_entête(@requête.entêtes, "Content-Type")

    // Le contenu est dans les paramètres de l'URL
    si entête.valeur == "application/x-www-form-urlencoded" {
        // À FAIRE: normalise les données
    }
    // nous avons une chaine json
    sinon si entête.valeur == "application/json" {

    }

    entête_longueur_contenu := cherche_entête(@requête.entêtes, "Content-Length")

    longueur_contenu := extrait_nombre_entier(entête_longueur_contenu.valeur)

    si longueur_contenu != requête.contenu.taille {
        ajoute_au_tampon(@enchaineuse, "<p>Les longueurs ne correspondent pas !</p>")
    }
    sinon {
        ajoute_au_tampon(@enchaineuse, "<p>Vous avez posté quelque chose !</p>")
        // À FAIRE : dépassement des limites de la chaine
        ajoute_au_tampon(@enchaineuse, "<p>Le contenu est de '", requête.contenu, "'</p>")
        //ajoute_au_tampon(@enchaineuse, "<p>Le contenu est de '")
        //ajoute_au_tampon(@enchaineuse, contenu_requête)
        //ajoute_au_tampon(@enchaineuse, "'</p>")
    }

    retourne RéponseRequête{
        code = CodeÉtatHTTP.OK,
        type_contenu = TypeContenu.TEXT_HTML,
        // À FAIRE
        contenu = chaine_depuis_enchaineuse(@enchaineuse)
    }
}

procède_requête :: fonc (
    prise: z32,
    adresse_du_connecté: sockaddr_in) -> rien
{
    mémoire_présente := mémoire_utilisée()
    temps_présent := compte_ticks_microsecondes()

    diffère {
        imprime_log(ModeLogage.AUCUN, "", "Mémoire utilisée (avant) : %o", mémoire_présente)
        imprime_log(ModeLogage.AUCUN, "", "Mémoire utilisée (après) : %o", mémoire_utilisée())
        imprime_log(ModeLogage.AUCUN, "", "Mémoire consommée        : %o", mémoire_consommée())
        imprime_log(ModeLogage.AUCUN, "", "Durée réponse            : %us", compte_ticks_microsecondes() - temps_présent)

        ip := converti_chaine_c(inet_ntoa(adresse_du_connecté.sin_addr))
        imprime_log(ModeLogage.AUCUN, "", "IP                       : % ", ip)

        imprime_log(ModeLogage.AUCUN, "", "")
    }

    requête := charge_donnees_requete(prise, adresse_du_connecté)
    diffère { déloge requête; }

    // ------------------------------

    //imprime("\nrequête :\n%\n", requête)

    dyn analyseuse : AnalyseuseRequête
    analyseuse.requête = requête
    //analyse_requête(@analyseuse, requete)

    dyn ligne_requête := analyse_ligne_requête(@analyseuse)

    dyn entêtes := analyse_entêtes(@analyseuse)
    diffère { détruit_entêtes(@entêtes); }

    dyn contenu_requête := analyse_contenu(@analyseuse)

/*
    pour entête dans entêtes.données {
        imprime("--- %: %\n", entête.clé, entête.valeur)
    }
*/

    uri := construit_uri_depuis_chemin_requête(ligne_requête.chemin)

    dyn données_requête : DonnéesRequête
    données_requête.uri = uri
    données_requête.entêtes = entêtes
    données_requête.contenu = contenu_requête

    dyn réponse : RéponseRequête
    diffère { déloge réponse.contenu; }

    // À FAIRE : gère les chemin vers les fichiers
    chn_chemin := construit_chaine(uri.chemin.pointeur + 1, uri.chemin.taille - 1)
    chm := construit_chemin(chn_chemin)

    // À FAIRE : gère les permissions
    si fichier_existe(chm) {
        réponse = crée_réponse_pour_requête_fichier(chm)
    }
    sinon {
        si uri.chemin == "/" {
            discr ligne_requête.méthode {
                "GET" {
                    réponse = répond_get_page_accueil(@données_requête)
                }
                "POST" {
                    réponse = répond_post_page_accueil(@données_requête)
                }
                sinon {
                    réponse = crée_réponse_méthode_non_autorisée()
                }
            }
        }
        sinon {
            réponse = crée_réponse_page_non_trouvée()
        }
    }

    // ------------------------------

    diffère {
        imprime_log(ModeLogage.AUCUN, "",
            "% % % - %",
            ligne_requête.méthode,
            ligne_requête.chemin,
            ligne_requête.protocole,
            chaine_code_état_http(réponse.code))
    }

    enchaineuse : Enchaineuse
    initialise_enchaineuse(@enchaineuse)
    diffère { détruit_tampons(@enchaineuse) }

    contenu := réponse.contenu

    ajoute_au_tampon(@enchaineuse, "HTTP/1.1 ", chaine_code_état_http(réponse.code), "\r\n")
    ajoute_au_tampon(@enchaineuse, "Server: delsace\r\n")
    ajoute_au_tampon(@enchaineuse, "Content-Length: ", contenu.taille, "\r\n")

    discr réponse.type_contenu {
        TEXT_HTML {
            ajoute_au_tampon(@enchaineuse, "Content-Type: text/html; charset=utf-8\r\n")
        }
        APPLICATION_JAVASCRIPT {
            ajoute_au_tampon(@enchaineuse, "Content-Type: application/javascript\r\n")
            ajoute_au_tampon(@enchaineuse, "Content-Disposition: attachment; filename='test.js'\r\n")
        }
        APPLICATION_JSON {
            ajoute_au_tampon(@enchaineuse, "Content-Type: application/json; charset=utf-8\r\n")
        }
        sinon {
            // RÀF
        }
    }

    date := chaine_pour_aujourdhui()
    diffère { déloge date; }
    ajoute_au_tampon(@enchaineuse, "Date: ", date, "\r\n")

    // À FAIRE: Content-Encoding, voir Accept-Encoding de la requête

    ajoute_au_tampon(@enchaineuse, "Set-Cookie: test=abcdefg; Domain=localhost; Max-Age=60; Path=/; HttpOnly\r\n")

    ajoute_au_tampon(@enchaineuse, "\r\n")
    ajoute_au_tampon(@enchaineuse, contenu)

    chaine_reponse := chaine_depuis_enchaineuse(@enchaineuse)
    diffère { déloge chaine_reponse; }

    si send(prise, chaine_reponse.pointeur, chaine_reponse.taille, 0) == -1 {
        perror("send".pointeur)
    }

    close(prise)
}

démarre :: fonc(dyn serveuse : &Serveuse) -> rien
{
    si serveuse.prise == -1 {
        retourne
    }

    dyn adresse_du_connecté : sockaddr_in
	sin_size := transtype(taille_de(sockaddr_in) : n32)

    boucle {
        prise := accept(serveuse.prise, transtype(@adresse_du_connecté : *sockaddr), @sin_size)

        si prise == -1 {
            perror("accept".pointeur)
            continue
        }

        si fork() == 0 {
            procède_requête(prise, adresse_du_connecté)
            exit(0)
        }

        // le parent n'a pas besoin de cela
        close(prise)

        // nettoyage des processus fils
        tantque waitpid(-1, nul, _WNOHANG) > 0 {}
    }
}

//###############################################################################

#nulctx rappel_interruption :: fonc (numéro_signal: z32) -> rien
{
    close(PRISE_SERVEUSE)
    exit(numéro_signal)
}

signal :: fonc externe (numéro_signal: z32, rappel: #nulctx fonc(z32)(rien)) -> rien

_SIGINT := 2

// commentaire
principale :: fonc(args : []*z8) -> z32
{
    contexte.logueur = mon_impression_log

    signal(_SIGINT, rappel_interruption);

    dyn serveuse : Serveuse
    construit_serveuse(serveuse, transtype(5001 : n16))

    démarre(serveuse)

    close(serveuse.prise)

    retourne 0
}

mon_impression_log :: fonc (message: chaine, ident: chaine, mode: ModeLogage, données: *rien) -> rien
{
    imprime("%\n", message)
}
