charge "lexage"

importe Fondation

// À FAIRE : les énums dont les valeurs sont autres que z32 ne sont pas imprimées (introspection)
TypeNoeud :: énum : z32 {
	CHAINE_CARACTÈRE
	VARIABLE
	BLOC
	POUR
	SI
}

NoeudSyntaxique :: struct {
    type : TypeNoeud
    données : DonnéesLexème
    enfants : []*NoeudSyntaxique
}

détruit_noeud :: fonc(dyn noeud : *NoeudSyntaxique) -> rien
{
    déloge noeud.enfants
    déloge noeud
}

pousse :: fonc(dyn liste : &[]*NoeudSyntaxique, valeur : *NoeudSyntaxique) -> rien
{
    taille := liste.taille
    reloge liste : [taille + 1]*NoeudSyntaxique
    liste[taille] = valeur
}

ajoute_noeud :: fonc(dyn noeud : *NoeudSyntaxique, enfant : *NoeudSyntaxique) -> rien
{
    noeud.enfants.pousse(enfant)
}

lexème :: fonc(noeud : *NoeudSyntaxique) -> TypeLexème
{
    retourne noeud.données.type_lexème
}

//##############################################################################

PileNoeud :: struct {
    données : []*NoeudSyntaxique
    curseur := 0
}

détruit :: fonc(dyn pile : &PileNoeud) -> rien
{
    déloge pile.données
}

empile :: fonc(dyn pile : &PileNoeud, noeud : *NoeudSyntaxique) -> rien
{
    si pile.curseur == pile.données.taille {
        taille := pile.données.taille
        reloge pile.données : [taille + 1]*NoeudSyntaxique
    }

    pile.données[pile.curseur] = noeud
    pile.curseur += 1
}

dépile :: fonc(dyn pile : &PileNoeud) -> *NoeudSyntaxique
{
    ret := pile.haut()
    pile.curseur -= 1
    retourne ret
}

haut :: fonc(pile : &PileNoeud) -> *NoeudSyntaxique
{
    retourne pile.données[pile.curseur - 1]
}

taille :: fonc(pile : &PileNoeud) -> z32
{
    retourne pile.curseur
}

est_vide :: fonc(pile : &PileNoeud) -> bool
{
    retourne pile.curseur == 0
}

//##############################################################################

AssembleuseArbre :: struct {
    noeuds : []*NoeudSyntaxique
    pile : PileNoeud
}

construit_assembleuse :: fonc() -> AssembleuseArbre
{
	dyn assembleuse : AssembleuseArbre
    retourne assembleuse
}

détruit_assembleuse :: fonc(dyn assembleuse : &AssembleuseArbre) -> rien
{
    pour noeud dans assembleuse.noeuds {
        détruit_noeud(noeud)
    }

    déloge assembleuse.noeuds

    détruit(assembleuse.pile)
}

empile_noeud :: fonc(
    dyn assembleuse : &AssembleuseArbre,
    type_noeud : TypeNoeud,
    données : &DonnéesLexème) -> *NoeudSyntaxique
{
	noeud := assembleuse.crée_noeud(type_noeud, données)

	si (!assembleuse.pile.est_vide()) {
		assembleuse.pile.haut().ajoute_noeud(noeud)
	}

	assembleuse.pile.empile(noeud)

	retourne noeud
}

ajoute_noeud :: fonc(
    dyn assembleuse : &AssembleuseArbre,
    type_noeud : TypeNoeud,
    données : &DonnéesLexème) -> rien
{
	noeud := assembleuse.crée_noeud(type_noeud, données)
	assembleuse.pile.haut().ajoute_noeud(noeud)
}

crée_noeud :: fonc(
    dyn assembleuse : &AssembleuseArbre,
    type_noeud : TypeNoeud,
    données : &DonnéesLexème) -> *NoeudSyntaxique
{
	dyn noeud := loge NoeudSyntaxique
    noeud.type = type_noeud
    noeud.données = données
    noeud.enfants.taille = 0
    noeud.enfants.pointeur = nul

    assembleuse.noeuds.pousse(noeud)

	retourne noeud
}

dépile_noeud :: fonc(dyn assembleuse : &AssembleuseArbre, type_noeud : TypeNoeud) -> rien
{
	assembleuse.attend_type(type_noeud)
	assembleuse.pile.dépile()
}

attend_type :: fonc(dyn assembleuse : &AssembleuseArbre, type_noeud : TypeNoeud) -> rien
{
	// assert(assembleuse.pile.haut().type == type_noeud)
}
