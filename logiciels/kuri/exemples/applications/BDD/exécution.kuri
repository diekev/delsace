importe Fondation

charge "coulisse_mémoire"
charge "instructions"
charge "table"

crée_table :: fonc (cm: *CoulisseMémoire, inst: *InstructionCréationTable) -> rien
{
    colonnes : []Colonne
    décalage := 0

    pour définition dans inst.colonnes {
        colonne : Colonne
        colonne.nom = définition.nom.valeur

        discr définition.type_données.genre {
            MOT_CLÉ_ENTIER {
                colonne.genre = TypeColonne.ENTIER
                colonne.taille = 4
                colonne.décalage = décalage
            }
            MOT_CLÉ_TEXTE {
                colonne.genre = TypeColonne.CHAINE
                colonne.taille = 4 + 251 // 4 pour la taille, 251 pour les caractères
                colonne.décalage = décalage
            }
            sinon {
                imprime("Type de données inattendu\n")
            }
        }

        décalage += colonne.taille

        tableau_ajoute(@colonnes, colonne)
    }

    table := ouvre_base_de_données_mémoire(colonnes)

    tableau_ajoute(@cm.noms_tables, inst.nom.valeur)
    tableau_ajoute(@cm.tables, table)
}

trouve_table :: fonc (cm: *CoulisseMémoire, nom_table: chaine) -> *Table
{
    pour nom, idx dans cm.noms_tables {
        si nom == nom_table {
            retourne cm.tables[idx]
        }
    }

    retourne nul
}

insère :: fonc (cm: *CoulisseMémoire, inst: *InstructionInsère) -> rien
{
    table := trouve_table(cm, inst.table.valeur)

    si table == nul {
        imprime("La table % n'existe pas !\n", inst.table.valeur)
        retourne
    }

    // ---------------------

    si table.nombre_de_lignes >= LIGNES_MAX_TABLE {
        retourne // À FAIRE : RésultatExécution.TABLE_PLEINE
    }

    curseur := curseur_fin_de_table(table)
    diffère { déloge curseur; }

    ligne := valeur_curseur(curseur)

    // À FAIRE : validation des valeurs
    // À FAIRE : prepare un buffer pour l'insertion afin de ne pas polluer la base de données
    // À FAIRE : log de préécriture
    décalage := 0

    pour expr, idx_valeur dans inst.valeurs {
        colonne := table.desc_colonnes[idx_valeur]

        si expr.littérale.genre == GenreLexème.NUMÉRIQUE {
            entier := transtype(extrait_nombre_entier(expr.littérale.valeur) : z32)
            sérialise_entier(ligne, entier, décalage)
        }
        sinon {
            chn := expr.littérale.valeur

            si chn.taille > 251 {
                retourne // À FAIRE
            }

            sérialise_chaine(ligne, chn, décalage)
        }

        décalage += colonne.taille
    }

    table.nombre_de_lignes += 1

    retourne // À FAIRE : RésultatExécution.SUCCÈS
}

ErreurSélection :: erreur {
    TableInexistante
    ColonneInexistante
    ExpressionNonLittérale
}

RésultatSélection :: union {
    e : ErreurSélection
    t : *Table
}

sélectionne :: fonc (cm: *CoulisseMémoire, inst: *InstructionSélection) -> RésultatSélection
{
    table := trouve_table(cm, inst.depuis.valeur)

    si table == nul {
        imprime("Erreur : la table % n'existe pas !\n", inst.depuis.valeur)
        retourne ErreurSélection.TableInexistante
    }

    colonnes_résultat : []Colonne

    index_colonnes : []z64
    diffère { déloge index_colonnes; }

    // trouve les colonnes dans la table
    pour expr dans inst.items {
        si expr.genre != GenreExpression.LITTÉRALE {
            imprime("Erreur : expression non-littérale rencontrée !\n")
            déloge colonnes_résultat
            retourne ErreurSélection.ExpressionNonLittérale
        }

        lit := expr.littérale

        si lit.genre != GenreLexème.IDENTIFIANT {
            continue
        }

        trouvée := faux

        pour colonne, idx_colonne dans table.desc_colonnes {
            si colonne.nom != lit.valeur {
                continue
            }

            tableau_ajoute(@colonnes_résultat, colonne)
            tableau_ajoute(@index_colonnes, idx_colonne)

            trouvée = vrai
        }

        si !trouvée {
            imprime("Erreur : la colonne %.% n'existe pas !\n", inst.depuis.valeur, lit.valeur)
            déloge colonnes_résultat
            retourne ErreurSélection.ColonneInexistante
        }
    }

    curseur_source := curseur_début_de_table(table)

    table_résultat := ouvre_base_de_données_mémoire(colonnes_résultat)

    curseur_résultat := curseur_début_de_table(table_résultat)
    diffère { déloge curseur_résultat; }

    // recherche dans la table
    tantque !curseur_source.est_fin_de_table {
        ligne_source := valeur_curseur(curseur_source)
        ligne_résultat := valeur_curseur(curseur_résultat)

        décalage_source := 0
        décalage_résultat := 0

        pour index dans index_colonnes {
            colonne := table.desc_colonnes[index]
            décalage_source = colonne.décalage

            pointeur_src := ligne_source.pointeur + décalage_source
            pointeur_dst := ligne_résultat.pointeur + décalage_résultat

            copie_mem_nonsur(src = pointeur_src, dst = pointeur_dst, taille = colonne.taille)

            décalage_résultat += colonne.taille
        }

        avance_curseur(curseur_source)
        avance_curseur(curseur_résultat)

        table_résultat.nombre_de_lignes += 1
    }

    retourne table_résultat
}

// ------------------------------------------------------------

sélectionne_tables :: fonc (cm: *CoulisseMémoire) -> *Table
{
    colonne : Colonne
    colonne.nom = "Tables"
    colonne.genre = TypeColonne.CHAINE
    colonne.taille = 255 // À FAIRE

    colonnes_résultat : []Colonne
    tableau_ajoute(@colonnes_résultat, colonne)

    table_résultat := ouvre_base_de_données_mémoire(colonnes_résultat)

    curseur_résultat := curseur_début_de_table(table_résultat)
    diffère { déloge curseur_résultat; }

    pour nom dans cm.noms_tables {
        ligne := valeur_curseur(curseur_résultat)

        sérialise_chaine(ligne, nom, 0)

        avance_curseur(curseur_résultat)
        table_résultat.nombre_de_lignes += 1
    }

    retourne table_résultat
}
