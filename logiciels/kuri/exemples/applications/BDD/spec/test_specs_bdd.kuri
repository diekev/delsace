importe Fondation
importe Processus

importe SysFichier

lance_test :: fonc (commandes: ...chaine) -> []chaine
{
    résultat: []chaine

    discr ouvre_canal_de_communication("../a.out") {
        Quelque(canal) {
            pour commandes {
                canal.écris(it)
                canal.écris("\n")
            }

            canal.ferme_écriture()

            texte := canal.lis()

            résultat = divise(texte, '\n')
        }
        sinon {
            retourne résultat
        }
    }

    retourne résultat
}

CasÀTester :: struct {
    raison: chaine
    commandes: []chaine
    résultat: []chaine
}

ÉtatParsage :: énum {
    DANS_CAS
    DANS_COMMANDES
    DANS_RÉSULTAT
    INCONNU
}

ParseuseCasÀTester :: struct {
    cas: []CasÀTester

    cas_courant : *CasÀTester

    état : ÉtatParsage
}

rappel_pour_chaque_ligne :: fonc (ligne: chaine, parseuse: *ParseuseCasÀTester)
{
    si ligne.taille == 0 {
        retourne
    }

    /* Supprime la nouvelle ligne. */
    si ligne[ligne.taille - 1] == '\n' {
        ligne = recule(ligne, 1)
    }

    si ligne.taille == 0 {
        retourne
    }

    si ligne.commence_par("-------------") {
        parseuse.cas_courant = tableau_ajoute_élément(*parseuse.cas)
        parseuse.état = ÉtatParsage.INCONNU
        retourne
    }

    si ligne.commence_par("+ Cas") {
        parseuse.cas_courant.raison = avance(ligne, "+ Cas : ".taille)
        parseuse.état = ÉtatParsage.DANS_CAS
        retourne
    }

    si ligne.commence_par("+ Commandes") {
        parseuse.état = ÉtatParsage.DANS_COMMANDES
        retourne
    }

    si ligne.commence_par("+ Résultat") {
        parseuse.état = ÉtatParsage.DANS_RÉSULTAT
        retourne
    }

    discr parseuse.état {
        DANS_CAS {
            // erreur
        }
        DANS_COMMANDES {
            tableau_ajoute(*parseuse.cas_courant.commandes, ligne)
        }
        DANS_RÉSULTAT {
            tableau_ajoute(*parseuse.cas_courant.résultat, ligne)
        }
        INCONNU {
            // erreur
        }
    }
}

imprime_cas :: fonc (cas: []CasÀTester)
{
    imprime("nombre de cas : %\n", cas.taille)

    pour cas {
        imprime("-------------------------------\n")
        imprime("+ Cas : %\n", it.raison)
        imprime("\n")

        imprime("+ Commandes :\n")
        pour commande dans it.commandes {
            imprime("%\n", commande)
        }
        imprime("\n")

        imprime("+ Résultat :\n")
        pour résultat dans it.résultat {
            imprime("%\n", résultat)
        }
        imprime("\n")
    }
}

lance_test_cas :: fonc (cas: CasÀTester) -> bool 
{
    résultat := lance_test(...cas.commandes)

    si résultat.taille != cas.résultat.taille {
        imprime("Échec !\n")
        imprime("Requiers % résultats\n", résultat.taille)
        imprime("Obtenu % résultats\n", cas.résultat.taille)
        retourne faux
    }

    pour résultat {
        si it != cas.résultat[index_it] {
            imprime("Échec !\n")
            imprime("Requiers : %\n", it)
            imprime("Obtenu : %\n", cas.résultat[index_it])
            retourne faux
        }
    }

    retourne vrai
}

principale :: fonc () -> z32
{
    fichier := "specs_bdd"
    chemin := CheminFichier(chn = fichier)
    contenu := contenu_fichier_texte(chemin)
    diffère { déloge(contenu) }

    saufsi contenu {
        imprime("Le fichier de spécification est vide ou introuvable !\n")
        retourne 1
    }

    parseuse: ParseuseCasÀTester
    ptr_données := *parseuse

    pour_chaque_ligne(contenu, ptr_données, rappel_pour_chaque_ligne)

    saufsi parseuse.cas {
        imprime("Aucun cas trouvé dans le fichier de spécification !\n")
        retourne 1
    }

    pour parseuse.cas {
        si lance_test_cas(it) {
            continue
        }

        imprime("Erreur : le cas '%' a échoué !\n", it.raison)
        retourne 1
    }

    retourne 0
}