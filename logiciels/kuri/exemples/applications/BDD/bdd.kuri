importe Fondation
importe GlibC

// https://cstack.github.io/db_tutorial/
// continuation : https://cstack.github.io/db_tutorial/parts/part5.html

imprime_prompt :: fonc () -> rien
{
    imprime("db > ")
}

lis_entrée :: fonc () -> chaine
{
    dyn nouveau_contexte := contexte
    nouveau_contexte.allocatrice = __stockage_temporaire

    dyn chn : chaine

    pousse_contexte nouveau_contexte {
        dyn c : z8

        tantque read(0, @c, transtype(1: n64)) != 0 {
            si c == '\n' {
                arrête
            }

            pousse(@chn, c)
        }
    }

    retourne chn
}

TypeMétaCommande :: énum z32 {
    SUCCÈS
    NON_RECONNUE
}

méta_commande :: fonc (commande: chaine) -> TypeMétaCommande
{
    si commande == ".sors" {
        retourne TypeMétaCommande.SUCCÈS
    }

    retourne TypeMétaCommande.NON_RECONNUE
}

TypeInstruction :: énum z32 {
    SÉLECTIONNE
    INSÈRE
}

// À FAIRE
TAILLE_MAX_NOM := 32
TAILLE_MAX_COURRIEL := 255

// À FAIRE : la représentation d'une ligne est compacte en mémoire
TAILLE_ID := 4 // taille_de Ligne.id
TAILLE_NOM := 33 // taille_de Lige.nom + 1
TAILLE_COURRIEL := 256 // taille_de Ligne.courriel + 1
DÉCALAGE_ID := 0
DÉCALAGE_NOM := 4
DÉCALAGE_COURRIEL := 37
TAILLE_LIGNE := 293

TAILLE_PAGE := 4096
TABLE_MAX_PAGES := 100
LIGNES_PAR_PAGES := 14 // TAILLE_PAGE / TAILLE_LIGNE
LIGNES_MAX_TABLE := 1400 // LIGNES_PAR_PAGES * TABLE_MAX_PAGES

Ligne :: struct {
    id := 0
    // Ne pas oublier le caractère nul en fin des chaines
    nom : [32 + 1]z8
    courriel : [255 + 1]z8
}

Pager :: struct {
    pages : [100]*rien
    descripteur_fichier := -1
    taille_fichier : z64 = 0
}

ouvre_pager :: fonc (fichier: chaine) -> *Pager
{
    marque := obtiens_marque_stockage_temporaire()
    diffère { set_marque_stockage_temporaire(marque) }

    chemin_c := chaine_c_temp(fichier)

    fd := open(chemin_c, LECTURE_ÉCRITURE | CREATION, 0o400 | 0o200)

    si fd == -1 {
        imprime("Impossible d'ouvrir le fichier\n")
        exit(1)
    }

    taille_fichier := lseek(fd, 0, _SEEK_END)

    dyn pager := loge Pager
    pager.descripteur_fichier = fd
    pager.taille_fichier = taille_fichier

    pour page dans pager.pages {
        page = nul
    }

    retourne pager
}

trouve_page :: fonc (dyn pager: *Pager, index_page: z32) -> *rien
{
    si index_page > TABLE_MAX_PAGES {
        imprime("Tentative de prendre une page hors des limites : % > %\n", index_page, TABLE_MAX_PAGES)
        exit(1)
    }

    dyn page := pager.pages[index_page]

    si page == nul {
        // Cache miss
        page = malloc(TAILLE_PAGE)
        dyn nombre_de_pages := pager.taille_fichier / TAILLE_PAGE

        // nous avons peut-être une page incomplète à la fin du fichier
        si pager.taille_fichier % TAILLE_PAGE != 0 {
            nombre_de_pages += 1
        }

        si index_page <= nombre_de_pages {
            lseek(pager.descripteur_fichier, index_page * TAILLE_PAGE, _SEEK_SET)

            octets_lus := read(pager.descripteur_fichier, page, transtype(TAILLE_PAGE: n64))

            si octets_lus == -1 {
                imprime("Erreur lors de la lecture du fichier !\n")
                exit(1)
            }
        }

        pager.pages[index_page] = page
    }

    retourne page
}

// les pages ne sont pas flushées si le programme est interrompu (ctrl + C)
// nous pourrions également éviter d'écrire des pages qui n'ont pas changées
flush_pager :: fonc (dyn pager: *Pager, index_page: z32, taille: z32) -> rien
{
    si pager.pages[index_page] == nul {
        imprime("Tentativer de flusher une page nulle !\n")
        exit(1)
    }

    décalage := lseek(pager.descripteur_fichier, index_page * TAILLE_PAGE, _SEEK_SET)

    si décalage == -1 {
        imprime("Impossible de chercher le point dans le fichier !\n")
        exit(1)
    }

    octets_écris := write(pager.descripteur_fichier, pager.pages[index_page], taille)

    si octets_écris == -1 {
        imprime("Erreur lors de l'écriture !")
        exit(1)
    }
}

Table :: struct {
    nombre_de_lignes := 0
    pager : *Pager = nul
}

ouvre_base_de_données :: fonc (fichier: chaine) -> *Table
{
    pager := ouvre_pager(fichier)
    nombre_de_lignes := pager.taille_fichier / TAILLE_LIGNE

    dyn table := loge Table
    table.pager = pager
    table.nombre_de_lignes = transtype(nombre_de_lignes: z32)

    retourne table
}

ferme_base_de_données :: fonc (dyn table: *Table) -> rien
{
    dyn pager := table.pager
    nombre_de_pages_pleines := table.nombre_de_lignes / TAILLE_LIGNE

    pour i dans 0 ... nombre_de_pages_pleines - 1 {
        si pager.pages[i] == nul {
            continue
        }

        flush_pager(pager, i, TAILLE_PAGE)
        free(pager.pages[i])
        pager.pages[i] = nul
    }

    // Une page partielle peut toujours être à écrire à la fin du fichier
    // Ce ne sera plus nécessaire lorsque nous aurons un arbre-B
    nombre_de_lignes_additionnelles := table.nombre_de_lignes % LIGNES_PAR_PAGES

    si nombre_de_lignes_additionnelles > 0 {
        index_page := nombre_de_pages_pleines

        si pager.pages[index_page] != nul {
            flush_pager(pager, index_page, nombre_de_lignes_additionnelles * TAILLE_LIGNE)
            free(pager.pages[index_page])
            pager.pages[index_page] = nul
        }
    }

    résultat_fermeture := close(pager.descripteur_fichier)

    si résultat_fermeture == -1 {
        imprime("Échec lors de la fermeture du fichier\n")
        exit(1)
    }

    pour page dans pager.pages {
        si page != nul {
            free(page)
        }
    }

    déloge pager
    déloge table
}

Curseur :: struct {
    table : *Table
    index_ligne := 0
    est_fin_de_table := faux
}

curseur_début_de_table :: fonc (table: *Table) -> *Curseur
{
    dyn curseur := loge Curseur
    curseur.table = table
    curseur.index_ligne = 0
    curseur.est_fin_de_table = table.nombre_de_lignes == 0

    retourne curseur
}

curseur_fin_de_table :: fonc (table: *Table) -> *Curseur
{
    dyn curseur := loge Curseur
    curseur.table = table
    curseur.index_ligne = table.nombre_de_lignes
    curseur.est_fin_de_table = vrai

    retourne curseur
}

valeur_curseur :: fonc (dyn curseur: *Curseur) -> *rien
{
    index_ligne := curseur.index_ligne
    index_page := index_ligne / LIGNES_PAR_PAGES
    page := trouve_page(curseur.table.pager, index_page)

    décalage_ligne := index_ligne % LIGNES_PAR_PAGES
    décalage_octet := décalage_ligne * TAILLE_LIGNE

    retourne page + décalage_octet
}

avance_curseur :: fonc (dyn curseur: *Curseur) -> rien
{
    curseur.index_ligne += 1
    curseur.est_fin_de_table = curseur.index_ligne >= curseur.table.nombre_de_lignes
}

// @XXX
copie_chaine_vers_tableau :: fonc (dyn tabl: *z8, chn: chaine) -> rien
{
    pour c, idx dans chn {
        tabl[idx] = c
    }
}

sérialise_ligne :: fonc (ligne: *Ligne, dyn dest: *rien) -> rien
{
    copie_mem_nonsur(src = @ligne.id, dst = dest, taille = TAILLE_ID)
    copie_mem_nonsur(src = @ligne.nom[0], dst = dest + DÉCALAGE_NOM, taille = TAILLE_NOM)
    copie_mem_nonsur(src = @ligne.courriel[0], dst = dest + DÉCALAGE_COURRIEL, taille = TAILLE_COURRIEL)
}

désérialise_ligne :: fonc (src: *rien, dyn ligne: *Ligne) -> rien
{
    copie_mem_nonsur(dst = @ligne.id, src = src, taille = TAILLE_ID)
    copie_mem_nonsur(dst = @ligne.nom[0], src = src + DÉCALAGE_NOM, taille = TAILLE_NOM)
    copie_mem_nonsur(dst = @ligne.courriel[0], src = src + DÉCALAGE_COURRIEL, taille = TAILLE_COURRIEL)
}

Instruction :: struct {
    type : TypeInstruction
    ligne_à_insérer : Ligne
}

PrépareRésultat :: énum z32 {
    SUCCÈS
    INSTRUCTION_NON_RECONNUE
    ERREUR_SYNTAXE
    CHAINE_TROP_LONGUE
    ID_NÉGATIF
}

prépare_instruction :: fonc (commande: chaine, dyn inst: *Instruction) -> PrépareRésultat
{
    dyn nouveau_contexte := contexte
    nouveau_contexte.allocatrice = __stockage_temporaire

    dyn mots : []chaine

    pousse_contexte nouveau_contexte {
        mots = divise(commande, ' ')
    }

    si mots.taille == 0 {
        retourne PrépareRésultat.INSTRUCTION_NON_RECONNUE
    }

    si mots[0] == "insère" {
        si mots.taille != 4 {
            retourne PrépareRésultat.ERREUR_SYNTAXE
        }

        id := transtype(extrait_nombre_entier(mots[1]): z32)
        nom := mots[2]
        courriel := mots[3]

        si id < 0 {
            retourne PrépareRésultat.ID_NÉGATIF
        }

        // À FAIRE : vérifie que tout est dans le bon ordre
        inst.type = TypeInstruction.INSÈRE
        inst.ligne_à_insérer.id = id
        copie_chaine_vers_tableau(@inst.ligne_à_insérer.nom[0], nom)
        copie_chaine_vers_tableau(@inst.ligne_à_insérer.courriel[0], courriel)

        si nom.taille > TAILLE_MAX_NOM {
            retourne PrépareRésultat.CHAINE_TROP_LONGUE
        }

        si courriel.taille > TAILLE_MAX_COURRIEL {
            retourne PrépareRésultat.CHAINE_TROP_LONGUE
        }

        inst.ligne_à_insérer.nom[nom.taille] = '\0'
        inst.ligne_à_insérer.courriel[courriel.taille] = '\0'

        retourne PrépareRésultat.SUCCÈS
    }

    si mots[0] == "sélectionne" {
        inst.type = TypeInstruction.SÉLECTIONNE
        retourne PrépareRésultat.SUCCÈS
    }

    retourne PrépareRésultat.INSTRUCTION_NON_RECONNUE
}

RésultatExécution :: énum z32 {
    INVALIDE
    TABLE_PLEINE
    SUCCÈS
}

exécute_insertion :: fonc (inst: *Instruction, dyn table: *Table) -> RésultatExécution
{
    si table.nombre_de_lignes >= LIGNES_MAX_TABLE {
        retourne RésultatExécution.TABLE_PLEINE
    }

    ligne_à_insérer := @inst.ligne_à_insérer

    dyn curseur := curseur_fin_de_table(table)
    slot := valeur_curseur(curseur)

    sérialise_ligne(ligne_à_insérer, slot)

    table.nombre_de_lignes += 1

    déloge curseur

    retourne RésultatExécution.SUCCÈS
}

imprime_ligne :: fonc (ligne: *Ligne) -> rien
{
    dyn nouveau_contexte := contexte
    nouveau_contexte.allocatrice = __stockage_temporaire

    dyn chn_nom : chaine

    {
        pousse_contexte nouveau_contexte {
            pour c dans ligne.nom {
                si c == '\0' {
                    arrête
                }

                pousse(@chn_nom, c)
            }
        }
    }

    dyn chn_courriel : chaine

    {
        pousse_contexte nouveau_contexte {
            pour c dans ligne.courriel {
                si c == '\0' {
                    arrête
                }

                pousse(@chn_courriel, c)
            }
        }
    }

    imprime("(%, %, %)\n", ligne.id, chn_nom, chn_courriel)
}

exécute_sélection :: fonc (inst: *Instruction, dyn table: *Table) -> RésultatExécution
{
    dyn curseur := curseur_début_de_table(table)
    dyn ligne : Ligne

    tantque !curseur.est_fin_de_table {
        slot := valeur_curseur(curseur)
        désérialise_ligne(slot, @ligne)
        imprime_ligne(@ligne)

        avance_curseur(curseur)
    }

    déloge curseur

    retourne RésultatExécution.SUCCÈS
}

exécute_instruction :: fonc (inst: *Instruction, table: *Table) -> RésultatExécution
{
    discr inst.type {
        INSÈRE {
            retourne exécute_insertion(inst, table)
        }
        SÉLECTIONNE {
            retourne exécute_sélection(inst, table)
        }
    }

    retourne RésultatExécution.INVALIDE
}

principale :: fonc () -> z32
{
    args := arguments_ligne_commande()

    si args.taille < 2 {
        imprime("Un nom de fichier pour la base de données doit être spécifié !\n")
        retourne 1
    }

    //diffère { imprime("\nFin du programme, mémoire utilisée : %o\n", mémoire_utilisée()); }
    chemin_fichier := args[1]

    dyn table := ouvre_base_de_données(chemin_fichier)
    diffère { ferme_base_de_données(table) }

    dyn marque := obtiens_marque_stockage_temporaire()

    boucle {
        set_marque_stockage_temporaire(marque);
        marque = obtiens_marque_stockage_temporaire()

        imprime_prompt()
        entrée := lis_entrée()

        si entrée.taille == 0 {
            imprime("L'entrée est vide\n")
            continue
        }

        si entrée[0] == '.' {
            discr méta_commande(entrée) {
                SUCCÈS {
                    si entrée == ".sors" {
                        retourne 0
                    }

                    continue
                }
                NON_RECONNUE {
                    imprime("commande inconnue : %\n", entrée)
                    continue
                }
            }
        }

        dyn instruction : Instruction
        discr prépare_instruction(entrée, @instruction) {
            SUCCÈS {}
            ERREUR_SYNTAXE {
                imprime("Erreur de syntaxe pour '%'\n", entrée)
            }
            INSTRUCTION_NON_RECONNUE {
                imprime("Mot-clé inconnu au début de '%'\n", entrée)
                continue
            }
            CHAINE_TROP_LONGUE {
                imprime("La chaine est trop longue.\n")
                continue
            }
            ID_NÉGATIF {
                imprime("L'ID doit être positif.\n")
                continue
            }
        }

        discr exécute_instruction(@instruction, table) {
            INVALIDE {
                imprime("Exécution invalide.\n")
            }
            SUCCÈS {
                imprime("Exécution réussie.\n")
            }
            TABLE_PLEINE {
                imprime("Erreur: table pleine.\n")
            }
        }
    }

    retourne 0
}