importe Fondation

charge instruction
charge lexeuse

//###############################################################################

TypeObjet :: énum z32 {
	NOEUD
	RELATION
}

Propriété :: struct {
	nom : chaine
	valeur : chaine
}

Étiquette :: struct {
	valeur : chaine
}

Objet :: struct {
	type : TypeObjet
	nom : chaine
	propriétés : []Propriété
	étiquettes : []Étiquette
}

Expression :: struct {
	objets : []Objet
}

Bloc :: struct {
	inst : Instruction
	expression : Expression
}

Requête :: struct {
	blocs : []Bloc
}

détruit_requête :: fonc(requête : &Requête) -> rien
{
	pour bloc dans requête.blocs {
		expression := bloc.expression

		pour objet dans expression.objets {
			déloge objet.propriétés
			déloge objet.étiquettes
		}

		déloge expression.objets
	}

	déloge requête.blocs
}

imprime_requête :: fonc(requête : &Requête) -> rien
{
	imprime("Requête :\n")

	pour bloc dans requête.blocs {
		imprime("%\n", bloc.inst)

		pour objet dans bloc.expression.objets {
			imprime("Objet % :\n", objet.type)
			imprime("\tNom : %\n", objet.nom)

			imprime("\tÉtiquettes :\n")
			pour étiquette dans objet.étiquettes {
				imprime("\t\t%\n", étiquette.valeur)
			}

			imprime("\tPropriétés : {\n")
			pour propriété dans objet.propriétés {
				imprime("\t\t % : %,\n", propriété.nom, propriété.valeur)
			}
			imprime("\t}\n")
		}
	}
}

//###############################################################################

Syntaxeuse :: struct {
	lexèmes : *[]Lexème
	position : z64 = 0
	// L'instruction si le lexème courant est celui d'une instruction
	inst : Instruction
}

initialise :: fonc(syntaxeuse : &Syntaxeuse, lexèmes : *[]Lexème) -> rien
{
	syntaxeuse.position = 0
	syntaxeuse.lexèmes = lexèmes
}

a_fini :: fonc(syntaxeuse : &Syntaxeuse) -> bool
{
	retourne syntaxeuse.position >= syntaxeuse.lexèmes.taille
}

lexème_courant :: fonc(syntaxeuse : &Syntaxeuse) -> Lexème
{
	// À FAIRE(langage) : l'opérateur [] ne déréférence pas les pointeurs vers les tableaux ou chaines
	lexèmes := mémoire(syntaxeuse.lexèmes)
	retourne lexèmes[syntaxeuse.position]
}

est_lexème :: fonc(syntaxeuse : &Syntaxeuse, id : IdentifiantLexème) -> bool
{
	retourne syntaxeuse.lexème_courant().id == id
}

avance :: fonc(syntaxeuse : &Syntaxeuse) -> rien
{
	syntaxeuse.position += 1
}

recule :: fonc(syntaxeuse : &Syntaxeuse) -> rien
{
	syntaxeuse.position -= 1
}

requiers_lexème :: fonc(syntaxeuse : &Syntaxeuse, id : IdentifiantLexème) -> bool
{
	si syntaxeuse.position >= syntaxeuse.lexèmes.taille {
		retourne faux
	}

	est_bon := syntaxeuse.est_lexème(id)
	syntaxeuse.avance()
	retourne est_bon
}

//###############################################################################

analyse_propriétés :: fonc(syntaxeuse : &Syntaxeuse, objet : &Objet) -> rien
{
	//imprime("analyse_propriétés (", syntaxeuse.lexème_courant(), ")\n")
	// { chaine : chaine }
	boucle {
		//imprime("-- boucle analyse_propriétés\n")
		si syntaxeuse.est_lexème(IdentifiantLexème.ACCOLADE_FERMANTE) {
			syntaxeuse.avance()
			arrête
		}

		propriété : Propriété

		si !syntaxeuse.requiers_lexème(IdentifiantLexème.CHAINE_CARACTÈRE) {
			imprime("ERREUR : attendu une chaine de caractère après '{' ou ','\n")
			retourne
		}

		syntaxeuse.recule()
		propriété.nom = syntaxeuse.lexème_courant().chn
		syntaxeuse.avance()

		si !syntaxeuse.requiers_lexème(IdentifiantLexème.DOUBLE_POINTS) {
			imprime("ERREUR : attendu un double point\n")
			retourne
		}

		si syntaxeuse.est_lexème(IdentifiantLexème.CHAINE_CARACTÈRE) {
			propriété.valeur = syntaxeuse.lexème_courant().chn
			syntaxeuse.avance()
		}
		sinon si syntaxeuse.est_lexème(IdentifiantLexème.CHAINE_LITTÉRALE) {
			propriété.valeur = syntaxeuse.lexème_courant().chn
			syntaxeuse.avance()
		}
		sinon {
			imprime("ERREUR : attendu une chaine de caractère ou une littérale après ':'\n")
			retourne
		}

		tableau_ajoute(@objet.propriétés, propriété)

		si syntaxeuse.est_lexème(IdentifiantLexème.VIRGULE) {
			syntaxeuse.avance()
		}
	}
}

analyse_objet :: fonc(
	syntaxeuse : &Syntaxeuse,
	expression : &Expression,
	type_objet : TypeObjet,
	id_final : IdentifiantLexème) -> rien
{
	//imprime("analyse_objet ", id_final, '\n')
	// ( chaine : chaine : chaine propriétés )
	// [ chaine : chaine : chaine propriétés ]
	// <- -- ->

	objet : Objet
	objet.type = type_objet

	si syntaxeuse.est_lexème(id_final) {
		//imprime("Objet vide\n")
		// Nous avons un objet vide
		syntaxeuse.avance()
		retourne
	}

	si syntaxeuse.est_lexème(IdentifiantLexème.CHAINE_CARACTÈRE) {
		// nom_objet
		objet.nom = syntaxeuse.lexème_courant().chn
		syntaxeuse.avance()
	}

	tantque syntaxeuse.est_lexème(IdentifiantLexème.DOUBLE_POINTS) {
		syntaxeuse.avance()

		si !syntaxeuse.requiers_lexème(IdentifiantLexème.CHAINE_CARACTÈRE) {
			// nom_étiquette
			retourne
		}

		étiquette : Étiquette
		syntaxeuse.recule()
		étiquette.valeur = syntaxeuse.lexème_courant().chn
		syntaxeuse.avance()

		tableau_ajoute(@objet.étiquettes, étiquette)
	}

	si syntaxeuse.est_lexème(IdentifiantLexème.ACCOLADE_OUVRANTE) {
		syntaxeuse.avance()
		syntaxeuse.analyse_propriétés(objet)
	}

	tableau_ajoute(@expression.objets, objet)

	si !syntaxeuse.requiers_lexème(id_final) {
		//imprime("ERREUR : attendu l'identifiant final de l'objet\n")
		retourne
	}
}

analyse_expression :: fonc(syntaxeuse : &Syntaxeuse) -> Expression
{
	expression : Expression

	tantque !syntaxeuse.a_fini() {
		//imprime("-- boucle analyse_expression\n")

		si syntaxeuse.est_lexème(IdentifiantLexème.PARENTHÈSE_OUVRANTE) {
			syntaxeuse.avance()
			syntaxeuse.analyse_objet(expression, TypeObjet.NOEUD, IdentifiantLexème.PARENTHÈSE_FERMANTE)
		}
		sinon si syntaxeuse.est_lexème(IdentifiantLexème.RELATION_DÉBUT) {
			syntaxeuse.avance()
			syntaxeuse.analyse_objet(expression, TypeObjet.RELATION, IdentifiantLexème.RELATION_FIN)
		}
		sinon {
			//imprime("ignore lexème ", syntaxeuse.lexème_courant(), '\n')
			syntaxeuse.avance()
		}
	}

	retourne expression
}

instruction_pour_lexème :: fonc(id : IdentifiantLexème) -> Instruction
{
	discr id {
		IdentifiantLexème.CREE     { retourne Instruction.CREE; }
		IdentifiantLexème.SUPPRIME { retourne Instruction.SUPPRIME; }
		IdentifiantLexème.TROUVE   { retourne Instruction.TROUVE; }
		IdentifiantLexème.RETOURNE { retourne Instruction.RETOURNE; }
		sinon { retourne Instruction.INVALIDE; }
	}

    retourne Instruction.INVALIDE
}

est_instruction :: fonc(syntaxeuse : &Syntaxeuse) -> bool
{
	lexème := syntaxeuse.lexème_courant()
	inst := instruction_pour_lexème(lexème.id)
	syntaxeuse.inst = inst

	retourne inst != Instruction.INVALIDE
}

Erreur :: struct {
	message : chaine
}

Résultat :: union {
	requête : Requête
	erreur_ : Erreur
}

analyse_requête :: fonc(syntaxeuse : &Syntaxeuse) -> Résultat
{
	résultat : Résultat
	requête : Requête

	//imprime("analyse_requête ", '\n')
	tantque !syntaxeuse.a_fini() {
		//imprime("-- boucle analyse_requête\n")
		si syntaxeuse.est_instruction() {
			syntaxeuse.avance()

			si !syntaxeuse.est_lexème(IdentifiantLexème.PARENTHÈSE_OUVRANTE) {
				erreur_ : Erreur;
				erreur_.message = "ERREUR : l'instruction doit être suivie par un noeud !\n"

				résultat.erreur_ = erreur_
				retourne résultat
			}

			bloc : Bloc
			bloc.inst = syntaxeuse.inst
			bloc.expression = syntaxeuse.analyse_expression()

			tableau_ajoute(@requête.blocs, bloc)
		}
		sinon {
			erreur_ : Erreur;
			erreur_.message = "ERREUR : la requête doit commencer par une instruction !\n"

			résultat.erreur_ = erreur_
			retourne résultat
		}
	}

	résultat.requête = requête

	retourne résultat
}

principale :: fonc () -> z32
{
    expressions := [
        "(moi) -[:AMI]-> (mesAmis) -[:AMI]-> (amisDeMesAmis)",
        "( noeud : Personne :Acteur )-[ : LABEL { nom : \"bibi\" } ]->( noeud : LABEL { nom : 8, id : 56, voiture : 789 } )",
        // N'importe quel noeud
        "()",
        // Un noeud avec l'étiquette "Personne"
        "(:Personne)",
        // Un noeud identifié avec la variable "n" et avec l'étiquette "Personne"
        "(n:Personne)",
        // Un noeud identifié avec la variable "n" et avec les étiquettes "Personne" et "Acteur"
        "(n:Personne:Acteur)",
        // N'importe quelle relation entre "a" et "b", peu importe la direction
        "(a)--(b)",
        // relation de type "AMI" depuis le nœud "a" vers le nœud "b"
        "(a)-[:AMI]->(b)",
        // relation de type "AMI" ou "CONNAIT" depuis le nœud "a" vers le nœud "b"
        "(a)-[:AMI|CONNAIT]->(b)"
    ]

    //pour expression dans expressions {
    //    compileuse.analyse_expression(expression)
    //}

    // CREE (moi : { nom : "bibi" })
    // RETOURNE moi

    // TROUVE (moi : { nom : "bibi" })
    // CREE (moi) -[:AIME]-> (quelquechose)
    // RETOURNE moi, quelquechose

    requêtes := [
        "CREE (moi : LABEL { nom : \"bibi\" })\nRETOURNE moi\n",
        "TROUVE (:Type { index : 1 }) -[opérateur:Opérateur { nom : '+' }]-> (:Type { index : 5 })\nRETOURNE opérateur.id\n"
    ]

	diffère {
		imprime("Mémoire utilisée        : %o\n", mémoire_utilisée())
		imprime("Mémoire consommée       : %o\n", mémoire_consommée())
		imprime("Nombre d'allocations    : %\n", nombre_allocations())
		imprime("Nombre de réallocations : %\n", nombre_réallocations())
		imprime("Nombre de déallocations : %\n", nombre_déallocations())
	}

    chaine_requête := "TROUVE (profil : UTILISATEUR { nom: \"kévin\", âge : 28 })-[]->(profil : UTILISATEUR { nom: \"marie\", âge : 28 })"

    lexeuse : Lexeuse
    lexeuse.analyse_texte(chaine_requête)

    diffère { déloge lexeuse.lexèmes; }

	syntaxeuse : Syntaxeuse
	syntaxeuse.initialise(@lexeuse.lexèmes)
	résultat := syntaxeuse.analyse_requête()

	discr résultat {
		requête {
			imprime_requête(requête)
			détruit_requête(requête)
		}
		erreur_ {
			imprime("%\n", erreur_.message)
		}
	}

	requête := faux

	retourne 0
}
