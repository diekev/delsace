# écrire dans un fichier ou dans une page mémoire

struct PageMémoire {
	données : []octet
	position : z64
}

fonc pousse(dyn pages : &[]PageMémoire, page : PageMémoire) -> rien
{
    taille := pages.taille
    reloge pages : [taille + 1]PageMémoire
    pages[taille] = page
}

struct FichierMémoire {
	pages : []PageMémoire
	page_courante : z32
	taille_totale : z64
}

fonc ajoute_page(dyn fichier : &FichierMémoire) -> rien
{
	dyn page := PageMémoire
	page.données = loge [64 * 1024]octet

	pousse(fichier.pages, page)
}

fonc supprime_fichier(dyn fichier : &FichierMémoire) -> rien
{
	pour page dans fichier.pages {
		déloge page.données
	}

	déloge fichier.pages
}

fonc écris(dyn fichier : &FichierMémoire, données : []octet, position : z64) -> rien
{
	page_courante := fichier.pages[fichier.page_courante]

	si position + données.taille >= page_courante.données.taille {
		# À FAIRE : alloue une nouvelle page
		retourne
	}

	pour d, idx dans données {
		page_courante.données[idx + position] = d
	}
}

fonc écris(dyn fichier : &FichierMémoire, données : []octet) -> rien
{
	page_courante := @fichier.pages[fichier.page_courante]
	position := page_courante.position

	si position + données.taille >= page_courante.données.taille {
		# À FAIRE : alloue une nouvelle page
		retourne
	}

	pour d, idx dans données {
		page_courante.données[idx + position] = d
	}

	page_courante.position += données.taille
}

fonc lis(dyn fichier : &FichierMémoire, données : []octet) -> rien
{
	page_courante := @fichier.pages[fichier.page_courante]
	position := page_courante.position

	si position + données.taille >= page_courante.données.taille {
		# À FAIRE : lis jusqu'à la fin du fichier, et charge la page suivante
		# À FAIRE : si la page_courante est la dernière, que faire ?
		retourne
	}

	pour d, idx dans données {
		d = page_courante.données[idx + position]
	}

	page_courante.position += données.taille
}

struct Enregistrement {
	ptr : *octet
	position : z64
}

fonc duplique(chn : chaine) -> chaine
{
	dyn rés := loge chaine(chn.taille)
	copie_mem_nonsur(chn.pointeur, rés.pointeur, chn.taille)
	retourne rés
}

fonc pousse(dyn liste : &[]chaine, valeur : chaine) -> rien
{
    taille := liste.taille
    reloge liste : [taille + 1]chaine
    liste[taille] = valeur
}

fonc pousse(dyn liste : &[]*FichierMémoire, valeur : *FichierMémoire) -> rien
{
    taille := liste.taille
    reloge liste : [taille + 1]*FichierMémoire
    liste[taille] = valeur
}

struct SystèmeFichierMémoire {
	fichiers : []*FichierMémoire
	chemins : []chaine
}

fonc détruit(dyn système : &SystèmeFichierMémoire) -> rien
{
	pour chemin dans système.chemins {
		déloge FichierMémoire
		déloge chemin
	}
}

fonc trouve_fichier(
	dyn système : &SystèmeFichierMémoire,
	chemin : chaine) -> *FichierMémoire
{
	pour chn, idx dans système.chemin {
		si chn == chemin {
			retourne système.fichiers[idx]
		}
	}

	retourne nul
}

fonc ouvre_pour_écriture(
	dyn système : &SystèmeFichierMémoire,
	chemin : chaine) -> *FichierMémoire
{
	dyn fichier := système.trouve_fichier(chemin)

	# À FAIRE : note que le fichier est occupé
	si fichier == nul {
		# crée fichier
		copie_chemin := duplique(chemin)
		fichier := loge FichierMémoire

		système.fichiers.pousse(fichier)
		système.chemins.pousse(copie_chemin)
	}

	retourne fichier
}

fonc ouvre_pour_lecture(
	dyn système : &SystèmeFichierMémoire,
	chemin : chaine) -> *FichierMémoire
{
	dyn fichier := système.trouve_fichier(chemin)

	# À FAIRE : note que le fichier est occupé
	retourne fichier
}

fonc ferme_fichier(
	dyn système : &SystèmeFichierMémoire,
	fichier : *FichierMémoire) -> rien
{

}
