// écrire dans un fichier ou dans une page mémoire

PageMémoire :: struct {
	données : []octet
	position : z64
}

FichierMémoire :: struct {
	pages : []PageMémoire
	page_courante : z32
	taille_totale : z64
}

ajoute_page :: fonc(dyn fichier : &FichierMémoire) -> rien
{
	dyn page := PageMémoire
	page.données = loge [64 * 1024]octet

	tableau_ajoute(@fichier.pages, page)
}

supprime_fichier :: fonc(dyn fichier : &FichierMémoire) -> rien
{
	pour page dans fichier.pages {
		déloge page.données
	}

	déloge fichier.pages
}

écris :: fonc(dyn fichier : &FichierMémoire, données : []octet, position : z64) -> rien
{
	page_courante := fichier.pages[fichier.page_courante]

	si position + données.taille >= page_courante.données.taille {
		// À FAIRE : alloue une nouvelle page
		retourne
	}

	pour d, idx dans données {
		page_courante.données[idx + position] = d
	}
}

écris :: fonc(dyn fichier : &FichierMémoire, données : []octet) -> rien
{
	page_courante := @fichier.pages[fichier.page_courante]
	position := page_courante.position

	si position + données.taille >= page_courante.données.taille {
		// À FAIRE : alloue une nouvelle page
		retourne
	}

	pour d, idx dans données {
		page_courante.données[idx + position] = d
	}

	page_courante.position += données.taille
}

lis :: fonc(dyn fichier : &FichierMémoire, données : []octet) -> rien
{
	page_courante := @fichier.pages[fichier.page_courante]
	position := page_courante.position

	si position + données.taille >= page_courante.données.taille {
		// À FAIRE : lis jusqu'à la fin du fichier, et charge la page suivante
		// À FAIRE : si la page_courante est la dernière, que faire ?
		retourne
	}

	pour d, idx dans données {
		d = page_courante.données[idx + position]
	}

	page_courante.position += données.taille
}

Enregistrement :: struct {
	ptr : *octet
	position : z64
}

duplique :: fonc(chn : chaine) -> chaine
{
	dyn rés := loge chaine(chn.taille)
	copie_mem_nonsur(chn.pointeur, rés.pointeur, chn.taille)
	retourne rés
}

SystèmeFichierMémoire :: struct {
	fichiers : []*FichierMémoire
	chemins : []chaine
}

détruit :: fonc(dyn système : &SystèmeFichierMémoire) -> rien
{
	pour chemin dans système.chemins {
		déloge FichierMémoire
		déloge chemin
	}
}

trouve_fichier :: fonc(
	dyn système : &SystèmeFichierMémoire,
	chemin : chaine) -> *FichierMémoire
{
	pour chn, idx dans système.chemin {
		si chn == chemin {
			retourne système.fichiers[idx]
		}
	}

	retourne nul
}

ouvre_pour_écriture :: fonc(
	dyn système : &SystèmeFichierMémoire,
	chemin : chaine) -> *FichierMémoire
{
	dyn fichier := système.trouve_fichier(chemin)

	// À FAIRE : note que le fichier est occupé
	si fichier == nul {
		// crée fichier
		copie_chemin := duplique(chemin)
		fichier := loge FichierMémoire

		tableau_ajoute(@système.fichiers, fichier)
		tableau_ajoute(@système.chemins, copie_chemin)
	}

	retourne fichier
}

ouvre_pour_lecture :: fonc(
	dyn système : &SystèmeFichierMémoire,
	chemin : chaine) -> *FichierMémoire
{
	dyn fichier := système.trouve_fichier(chemin)

	// À FAIRE : note que le fichier est occupé
	retourne fichier
}

ferme_fichier :: fonc(
	dyn système : &SystèmeFichierMémoire,
	fichier : *FichierMémoire) -> rien
{

}
