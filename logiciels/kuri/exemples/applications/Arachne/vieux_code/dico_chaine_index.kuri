// Implémentation spécialisée de la table de hachage du module Fondation
// pour avoir une clé de type chaine et une valeur de type z64

importe Fondation

NoeudDicoChaineIndex :: struct {
    clé : chaine
    valeur : chaine
    suivant : *NoeudDicoChaineIndex
}

DicoChaineIndex :: struct {
    alvéoles : []*NoeudDicoChaineIndex
}

crée_table_hachage :: fonc() -> DicoChaineIndex
{
    table : DicoChaineIndex
    table.alvéoles = loge [10000]*NoeudDicoChaineIndex

    pour i dans 0 ... 9999 {
        table.alvéoles[i] = nul
    }

    retourne table
}

décrée_table_hachage :: fonc(table : &DicoChaineIndex) -> rien
{
    pour noeud dans table.alvéoles {
        n := noeud;

        tantque n != nul {
            ns := n.suivant
            déloge n
            n = ns
        }
    }

    déloge table.alvéoles
}

crée_noeud :: fonc(clé : chaine, valeur : chaine) -> *NoeudDicoChaineIndex
{
    n := loge NoeudDicoChaineIndex
    n.clé = clé
    n.valeur = valeur
    n.suivant = nul
    retourne n
}

insère :: fonc(table : &DicoChaineIndex, clé : chaine, valeur : z64) -> rien
{
    empreinte := calcule_empreinte(clé) % 10000

    alvéole := table.alvéoles[empreinte]

    si alvéole == nul {
        table.alvéoles[empreinte] = crée_noeud(clé, valeur)
        retourne
    }

    boucle {
        si alvéole.suivant == nul {
            alvéole.suivant = crée_noeud(clé, valeur)
            arrête
        }

        alvéole = alvéole.suivant
    }
}

trouve :: fonc(table : &DicoChaineIndex, clé : chaine) -> *NoeudDicoChaineIndex
{
    empreinte := calcule_empreinte(clé) % 10000

    alvéole := table.alvéoles[empreinte]

    si alvéole == nul {
        retourne nul
    }

    boucle {
        si alvéole.clé == clé {
            retourne alvéole
        }

        si alvéole.suivant == nul {
            arrête
        }

        alvéole = alvéole.suivant
    }

    retourne nul
}

RésultatRecherche :: union {
	valeur : z64
	erreur_ : bool
}

cherche_valeur :: fonc(table : &DicoChaineIndex, clé : chaine) -> RésultatRecherche
{
    n := trouve(table, clé)
    résultat : RésultatRecherche

    si n == nul {
        résultat.erreur_ = vrai
    }
    sinon {
        résultat.valeur = n.valeur
    }

    retourne résultat
}

chaque_noeud :: corout(table : &DicoChaineIndex) -> *NoeudDicoChaineIndex
{
    pour alvéole dans table.alvéoles {
        n := alvéole

        tantque n != nul {
            retiens n
            n = n.suivant
        }
    }
}
