charge dico_chaine_index
charge fichier_mémoire

struct MagasinChaine {
	dico : DicoChaineIndex
	nombre_chaines : z64 = 0
	taille_chaines : z64 = 0
}

fonc index_chaine(dyn magasin : &MagasinChaine, chn : chaine) -> z64
{
	résultat := magasin.dico.trouve(chn)

	discr résultat {
		valeur {
			retourne valeur
		}
		erreur {
			retourne 0
		}
	}

	// À FAIRE(langage) : permet de ne pas avoir un retour si la dernière
	// instruction est celle d'une discrimination qui retourne de toute
	// manière
	retourne 0
}

fonc insère_chn_index(
	dyn magasin : &MagasinChaine,
	chn : chaine,
	index : z64) -> z64
{
	magasin.dico.insère(chn, index)
	magasin.taille_chaines += chn.taille
	magasin.nombre_chaines += 1
}

fonc ajoute_chaine(dyn magasin : &MagasinChaine, chn : chaine) -> z64
{
	index := index_chaine(magasin, chn)

	si index == 0 {
		copie := duplique(chn)
		magasin.insère_chn_index(copie, magasin.nombre_chaines)
		retourne magasin.nombre_chaines
	}

	retourne index
}

fonc sous_tableau(tabl : []octet, index : z64, taille : z64) -> []octet
{
	dyn tmp : []octet
	tmp.pointeur = @tabl[index]
	tmp.taille = taille

	retourne tmp
}

fonc écris_magasin(
	dyn magasin : &Magasin,
	dyn système : &SystèmeFichierMémoire) -> rien
{
	dyn fichier := système.ouvre_pour_lecture(chemin)

	si fichier == nul {
		retourne
	}

	// on réserve 12 octets par chaine :
	// 4 pour l'index et 8 pour la taille
	taille := magasin.nombre_chaines * 12 + magasin.taille_chaines

	dyn tampon := loge [taille]octet
	diffère { déloge tampon; }

	dyn décalage := 0

	pour noeud dans chaque_noeud(magasin.dico) {
		index_chaine := transtype(noeud.valeur : z32)
		taille_chaine := noeud.chn.taille

		dyn sous_tampon := sous_tableau(tampon, décalage, taille_de(z32))
		copie_mem(sous_tampon, index_chaine)

		sous_tampon = sous_tableau(tampon, décalage + 4, taille_de(z64))
		copie_mem(sous_tampon, taille_chaine)

		sous_tampon = sous_tableau(tampon, décalage + 12, taille_chaine)
		copie_mem(sous_tampon, chn)

		décalage += (12 + taille_chaine)
	}

	fichier.écris(tampon)
}

fonc lis_magasin(
	dyn magasin : &Magasin,
	dyn système : &SystèmeFichierMémoire) -> rien
{
	// À FAIRE : réinitialise magasin

	dyn fichier : Fichier
	fichier := système.ouvre_pour_lecture(chemin)

	si fichier == nul {
		retourne
	}

	diffère { système.ferme_fichier(fichier); }

	taille := fichier.taille

	tantque taille != 0 {
		// lis l'index
		dyn index : z32
		fichier.lis(index)

		// lis la taille
		dyn taille_chaine : z64
		fichier.lis(taille_chaine)

		// lis la chaine
		chn := loge chaine(taille_chaine)
		fichier.lis(chn)

		magasin.insère_chn_index(chn, index)

		taille -= 12 + taille_chaine
	}
}

