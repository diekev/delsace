charge magasin_chaine

//################################################################################

NoeudListe :: struct {
	suivant : *NoeudListe = nul
	données : *rien = nul
}

crée_noeud_liste :: fonc(données : *rien) -> *NoeudListe
{
	noeud := loge NoeudListe
	noeud.suivant = nul
	noeud.données = données
	retourne noeud
}

BaseListe :: fonc {
	premier : *NoeudListe = nul
	dernier : *NoeudListe = nul
}

pousse :: fonc(dyn liste : &BaseListe, données : *rien) -> rien
{
	noeud := crée_noeud_liste(données)

	si liste.premier == nul {
		liste.premier = noeud
		liste.dernier = noeud
	}
	sinon {
		liste.dernier.suivant = noeud
		liste.dernier = noeud
	}
}

est_vide :: fonc(liste : &BaseListe) -> bool
{
	retourne liste.premier == nul
}

ListePropriété :: struct {
	base : BaseListe
}

ListeRelation :: struct {
	base : BaseListe
}

ListeNoeud :: struct {
	base : BaseListe
}

ListeÉtiquette :: struct {
	base : BaseListe
}

//################################################################################

Étiquette :: struct {
	suivante : *Étiquette = nul
	id : n32 = 0
	id_nom : n32 = 0
}

pousse :: fonc(dyn liste : &ListeÉtiquette, étq : *Étiquette) -> rien
{
	pousse(liste.base, prop)
}

est_vide :: fonc(liste : &ListeÉtiquette) -> bool
{
	retourne est_vide(liste.base)
}

chaque_étiquette :: corout(liste : &ListeÉtiquette) -> *Étiquette
{
	dyn n := liste.premier

	tantque n != nul {
		retiens transtype(n.données : *Étiquette)
		n = n.suivant
	}
}

//################################################################################

Noeud :: struct {
	proprietes : ListePropriété
	relations : ListeRelation
	etiquettes : ListeÉtiquette

	id : n32 = 0
	utilise : bool = faux
}

pousse :: fonc(dyn liste : &ListeNoeud, n : *Noeud) -> rien
{
	pousse(liste.base, prop)
}

est_vide :: fonc(liste : &ListeNoeud) -> bool
{
	retourne est_vide(liste.base)
}

chaque_noeud :: corout(liste : &ListeNoeud) -> *Noeud
{
	dyn n := liste.premier

	tantque n != nul {
		retiens transtype(n.données : *Noeud)
		n = n.suivant
	}
}

//################################################################################

Relation :: struct {
	début : *Noeud
	fin : *Noeud

	rel_prev_debut : *Relation
	rel_suiv_debut : *Relation
	rel_prev_fin : *Relation
	rel_suiv_fin : *Relation

	type_relation : n32 = 0

	proprietes : ListePropriété
	id : n32 = 0
}

pousse :: fonc(dyn liste : &ListeRelation, rel : *Relation) -> rien
{
	pousse(liste.base, prop)
}

est_vide :: fonc(liste : &ListeRelation) -> bool
{
	retourne est_vide(liste.base)
}

chaque_relation :: corout(liste : &ListeRelation) -> *Relation
{
	dyn n := liste.premier

	tantque n != nul {
		retiens transtype(n.données : *Relation)
		n = n.suivant
	}
}

//################################################################################

Propriété :: struct {
	suivante : *Propriété

	id : n32 = 0
	id_nom : n32 = 0
	valeur : z32
}

pousse :: fonc(dyn liste : &ListePropriété, prop : *Propriété) -> rien
{
	pousse(liste.base, prop)
}

est_vide :: fonc(liste : &ListePropriété) -> bool
{
	retourne est_vide(liste.base)
}

chaque_propriété :: corout(liste : &ListePropriété) -> *Propriété
{
	dyn n := liste.premier

	tantque n != nul {
		retiens transtype(n.données : *Propriété)
		n = n.suivant
	}
}

//################################################################################

Graphe :: struct {
	noeuds : ListeNoeud
	relations : ListeRelation
	proprietes : ListePropriété
	étiquettes : ListeÉtiquette

	noms_proprietes : MagasinChaine
	types_relations : MagasinChaine
	noms_étiquettes : MagasinChaine

	// À chaque fois qu'un noeud est ajouté, le compte est incrémenté, et la
	// valeur incrémentée est assigné au noeud comme identifiant, de sorte que
	// l'identifiant 0 est réservé pour vérifié les noeuds nuls.
	nombre_noeuds : n32 = 0

	// À chaque fois qu'une relation est ajoutée, le compte est incrémenté, et
	// la valeur incrémentée est assigné à la relation comme identifiant, de
	// sorte que l'identifiant 0 est réservé pour vérifié les relations nulles.
	nombre_relations : n32 = 0

	// À chaque fois qu'une propriété est ajoutée, le compte est incrémenté, et
	// la valeur incrémentée est assigné à la propriété comme identifiant, de
	// sorte que l'identifiant 0 est réservé pour vérifié les propriétés nulles.
	nombre_proprietes : n32 = 0

	// À chaque fois qu'une étiquette est ajoutée, le compte est incrémenté, et
	// la valeur incrémentée est assigné à l'étiquette comme identifiant, de
	// sorte que l'identifiant 0 est réservé pour vérifié les étiquettes nulles.
	nombre_etiquettes : n32 = 0
}

supprime_graphe :: fonc(dyn graphe : &Graphe)
{
	pour noeud dans chaque_noeud(graphe.noeuds) {
		déloge noeud
	}

	pour relation dans chaque_relation(graphe.relations) {
		déloge relation
	}

	pour propriete dans chaque_propriété(graphe.proprietes) {
		déloge propriete
	}

	pour étiquette dans chaque_étiquette(graphe.étiquettes) {
		déloge étiquette
	}
}

ajoute_noeud :: fonc(
	dyn graphe : &Graphe,
	nom : chaine,
	valeur : z32) -> *Noeud
{
	imprime_sans_format("Création d'un noeud...\n")

	si (nom.est_vide()) {
		// À FAIRE : erreur, une propriété doit avoir un nom pour pouvoir l'identifier
		retourne
	}

	dyn n := loge noeud sinon {
		// À FAIRE : erreur
		retourne
	}

	n.id = ++graphe.nombre_noeuds
	assert(n.id != 0)

	ajoute_propriete(n, nom, valeur)

	graphe.noeuds.pousse(n)

	retourne n
}

ajoute_propriete :: fonc(
	dyn graphe : &Graphe,
	dyn n : *Noeud,
	nom : chaine,
	valeur : z32) -> rien
{
	imprime_sans_format("Création d'une propriété <", nom, ", ", valeur, "> pour un noeud...\n")

	si (n == nul || n.id == 0) {
		// À FAIRE : erreur
		retourne
	}

	si nom.est_vide() {
		// À FAIRE : erreur, une propriété doit avoir un nom pour pouvoir l'identifier
		retourne
	}

	dyn p := loge propriete sinon {
		// À FAIRE : erreur
		retourne
	}

	p.suivante = nul
	p.id_nom = transtype(graphe.noms_proprietes.ajoute_chaine(nom) : n32)
	p.valeur = valeur
	p.id = ++graphe.nombre_proprietes
	assert(p.id != 0)

	graphe.proprietes.pousse(p)

	si !n.proprietes.est_vide() {
		n.proprietes.dernier.suivante = p
	}

	n.proprietes.pousse(p)
}

ajoute_etiquette :: fonc(
	dyn graphe : &Graphe,
	dyn n : *Noeud,
	nom : chaine) -> rien
{
	si (n == nul || n.id == 0) {
		// À FAIRE : erreur
		retourne
	}

	si (nom.est_vide()) {
		// À FAIRE : erreur, une propriété doit avoir un nom pour pouvoir l'identifier
		retourne
	}

	imprime("Création d'une étiquette <", nom,"> pour un noeud...\n")

	dyn e := loge etiquette sinon {
		// À FAIRE : erreur
		retourne
	}

	e.suivante = nul
	e.id = ++graphe.nombre_etiquettes
	e.id_nom = static_cast<unsigned>(graphe.nom_etiquettes.ajoute_chaine(nom))
	assert(e.id != 0)

	graphe.etiquettes.pousse(e)

	si (!n.etiquettes.est_vide()) {
		n.etiquettes.back().suivante = e
	}

	n.etiquettes.pousse(e)
}

ajoute_propriete :: fonc(
	dyn graphe : &Graphe,
	dyn r : *Relation,
	nom : chaine,
	valeur : z32) -> rien
{
	imprime_sans_format("Création d'une propriété pour une relation...\n")

	si r == nul || r.id == 0 {
		// À FAIRE : erreur
		retourne
	}

	si (nom.est_vide()) {
		// À FAIRE : erreur, une propriété doit avoir un nom pour pouvoir l'identifier
		retourne
	}

	dyn p := loge propriete sinon {
		// À FAIRE : erreur
		retourne
	}

	p.suivante = nul
	p.id_nom = transtype(graphe.noms_proprietes.ajoute_chaine(nom) : n32)
	p.valeur = valeur
	p.id = ++graphe.nombre_proprietes
	assert(p.id != 0)

	graphe.proprietes.pousse(p)

	si (!r.proprietes.est_vide()) {
		r.proprietes.dernier.suivante = p
	}

	r.proprietes.pousse(p)
}

ajoute_relation :: fonc(
	dyn graphe : &Graphe,
	debut : *Noeud,
	fin : *Noeud,
	nom : chaine) -> rien
{
	si (debut == nul || fin == nul) {
		// À FAIRE : erreur
		retourne
	}

	si (debut == fin || debut.id == fin.id) {
		// À FAIRE : erreur
		retourne
	}

	imprime("Création d'une relation entre les noeuds ", debut.id, " et ", fin.id, "...\n")

	dyn r := loge relation sinon {
		// À FAIRE : erreur
		retourne
	}

	r.debut = debut
	r.fin = fin
	r.id = ++graphe.nombre_relations
	r.type_relation = transtype(graphe.types_relations.ajoute_chaine(nom) : n32)
	r.rel_prev_debut = nul
	r.rel_suiv_debut = nul
	r.rel_prev_fin = nul
	r.rel_suiv_fin = nul
	assert(r.id != 0)

	si (!debut.relations.est_vide()) {
		r.rel_prev_debut = debut.relations.back()
		debut.relations.back().rel_suiv_debut = r
	}

	si !fin.relations.est_vide() {
		r.rel_prev_fin = fin.relations.dernier
		debut.relations.dernier.rel_suiv_fin = r
	}

	debut.relations.pousse(r)
	fin.relations.pousse(r)

	graphe.relations.pousse(r)
}

//################################################################################

principale :: fonc(args : []*z8) -> z32
{
	dyn graphe : Graphe
	diffère { supprime_graphe(graphe); }

	n1 := graphe.crée_noeud("nom", 1)
	n2 := graphe.crée_noeud("nom", 2)

	graphe.ajoute_relation(n1, n2, "CONNECTÉ")

	// "(n1:{nom:1})-[:CONNECTÉ_AMONT]->(n2:{nom:2})"
	// graphe.imprime_relation()

	//####

	// "(n1:{nom:1})-[:CONNECTÉ_AMONT]->(n2:{nom:2})"
	// graphe.cherche_noeud(recherche)

	// cherche_noeud
	// propriétés...
	// étiquettes...
	// cherche relation
	// cherche_noeud
	// propriétés...
	// étiquettes...

	// "(n1:{nom:1})-[label:CONVERTI { ratio : 1.34 }]->(n2:{nom:2})"
	// "(n1:{nom:1})<-[label:CONVERTI { ratio : 0.75 }]-(n2:{nom:2})"

	// Jorjala
	// crée un noeud
	// "(:OBJET {nom:"cube"})"
	// "(:COMPOSITE {nom:"composite"]})"
	// "(:OPÉRATRICE {nom:""})
	// crée un graphe
	// "(:OBJET {nom:"cube"})-[:EST_GRAPHE]->(noeud_graphe:GRAPHE)"
	// cherche le graphe d'un noeud
	// "(:OBJET {nom:"cube"})-[:EST_GRAPHE]->(noeud_graphe:GRAPHE)"
	// "(noeud_graphe)-[:DANS_GRAPHE]->(noeud)"

	retourne 0
}
