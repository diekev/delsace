importe Fondation

//##############################################################################

TypeRune :: énum z32 {
    // espaces
	ESPACE_INSECABLE             := 0x00A0
	ESPACE_D_OGAM                := 0x1680
	SEPARATEUR_VOYELLES_MONGOL   := 0x180E
	DEMI_CADRATIN                := 0x2000
	CADRATIN                     := 0x2001
	ESPACE_DEMI_CADRATIN         := 0x2002
	ESPACE_CADRATIN              := 0x2003
	TIERS_DE_CADRATIN            := 0x2004
	QUART_DE_CADRATIN            := 0x2005
	SIXIEME_DE_CADRATIN          := 0x2006
	ESPACE_TABULAIRE             := 0x2007
	ESPACE_PONCTUATION           := 0x2008
	ESPACE_FINE                  := 0x2009
	ESPACE_ULTRAFINE             := 0x200A
	ESPACE_SANS_CHASSE           := 0x200B
	ESPACE_INSECABLE_ETROITE     := 0x202F
	ESPACE_MOYENNE_MATHEMATIQUE  := 0x205F
	ESPACE_IDEOGRAPHIQUE         := 0x3000
	ESPACE_INSECABLE_SANS_CHASSE := 0xFEFF

    // guillemets
	GUILLEMET_OUVRANT := 0x00AB  // «
	GUILLEMET_FERMANT := 0x00BB  // »
}

//##############################################################################

TypeLexème :: énum n32 {
	INCONNU

	EXCLAMATION
	GUILLEMET
	DIESE
	DOLLAR
	POURCENT
	ESPERLUETTE
	APOSTROPHE
	PARENTHESE_OUVRANTE
	PARENTHESE_FERMANTE
	FOIS
	PLUS
	VIRGULE
	MOINS
	POINT
	DIVISE
	DOUBLE_POINTS
	POINT_VIRGULE
	INFERIEUR
	EGAL
	SUPERIEUR
	AROBASE
	CROCHET_OUVRANT
	CROCHET_FERMANT
	CHAPEAU
	ACCOLADE_OUVRANTE
	BARRE
	ACCOLADE_FERMANTE
	TILDE
	DIFFERENCE
	DIRECTIVE
	ESP_ESP
	FOIS_EGAL
	PLUS_EGAL
	MOINS_EGAL
	DIVISE_EGAL
	DECALAGE_GAUCHE
	INFERIEUR_EGAL
	EGALITE
	SUPERIEUR_EGAL
	DECALAGE_DROITE
	BARRE_BARRE
	ARRETE
	BOOL
	BOUCLE
	CONTINUE
	DANS
	DEC
	ENT
	FAUX
	MAT3
	MAT4
	NUL
	POUR
	RETOURNE
	SI
	SINON
	VEC2
	VEC3
	VEC4
	VRAI
	NOMBRE_REEL
	NOMBRE_ENTIER
	NOMBRE_HEXADECIMAL
	NOMBRE_OCTAL
	NOMBRE_BINAIRE
	PLUS_UNAIRE
	MOINS_UNAIRE
	TROIS_POINTS
	CHAINE_CARACTERE
	CHAINE_LITTERALE
	CARACTERE
	TABLEAU
}

DonnéesLexème :: struct {
	chn : chaine
	lexème : TypeLexème
}

//##############################################################################

est_caractère_spécial :: fonc(c : z8) -> bool, TypeLexème
{
	discr c {
		'!' { retourne vrai, TypeLexème.EXCLAMATION }
		'"' { retourne vrai, TypeLexème.GUILLEMET }
		'#' { retourne vrai, TypeLexème.DIESE }
		'$' { retourne vrai, TypeLexème.DOLLAR }
		'%' { retourne vrai, TypeLexème.POURCENT }
		'&' { retourne vrai, TypeLexème.ESPERLUETTE }
		'\'' { retourne vrai, TypeLexème.APOSTROPHE }
		'(' { retourne vrai, TypeLexème.PARENTHESE_OUVRANTE }
		')' { retourne vrai, TypeLexème.PARENTHESE_FERMANTE }
		'*' { retourne vrai, TypeLexème.FOIS }
		'+' { retourne vrai, TypeLexème.PLUS }
		',' { retourne vrai, TypeLexème.VIRGULE }
		'-' { retourne vrai, TypeLexème.MOINS }
		'.' { retourne vrai, TypeLexème.POINT }
		'/' { retourne vrai, TypeLexème.DIVISE }
		':' { retourne vrai, TypeLexème.DOUBLE_POINTS }
		';' { retourne vrai, TypeLexème.POINT_VIRGULE }
		'<' { retourne vrai, TypeLexème.INFERIEUR }
		'=' { retourne vrai, TypeLexème.EGAL }
		'>' { retourne vrai, TypeLexème.SUPERIEUR }
		'@' { retourne vrai, TypeLexème.AROBASE }
		'[' { retourne vrai, TypeLexème.CROCHET_OUVRANT }
		']' { retourne vrai, TypeLexème.CROCHET_FERMANT }
		'^' { retourne vrai, TypeLexème.CHAPEAU }
		'{' { retourne vrai, TypeLexème.ACCOLADE_OUVRANTE }
		'|' { retourne vrai, TypeLexème.BARRE }
		'}' { retourne vrai, TypeLexème.ACCOLADE_FERMANTE }
		'~' { retourne vrai, TypeLexème.TILDE }
	}

	retourne faux, TypeLexème.INCONNU
}

id_digraphe :: fonc(digraphe : chaine) -> TypeLexème
{
	si digraphe == "!=" { retourne TypeLexème.DIFFERENCE }
	si digraphe == "#!" { retourne TypeLexème.DIRECTIVE }
	si digraphe == "&&" { retourne TypeLexème.ESP_ESP }
	si digraphe == "*=" { retourne TypeLexème.FOIS_EGAL }
	si digraphe == "+=" { retourne TypeLexème.PLUS_EGAL }
	si digraphe == "-=" { retourne TypeLexème.MOINS_EGAL }
	si digraphe == "/=" { retourne TypeLexème.DIVISE_EGAL }
	si digraphe == "<<" { retourne TypeLexème.DECALAGE_GAUCHE }
	si digraphe == "<=" { retourne TypeLexème.INFERIEUR_EGAL }
	si digraphe == "==" { retourne TypeLexème.EGALITE }
	si digraphe == ">=" { retourne TypeLexème.SUPERIEUR_EGAL }
	si digraphe == ">>" { retourne TypeLexème.DECALAGE_DROITE }
	si digraphe == "||" { retourne TypeLexème.BARRE_BARRE }

    retourne TypeLexème.INCONNU
}

id_identifiant :: fonc(identifiant : chaine) -> TypeLexème
{
	si identifiant == "arrête" { retourne TypeLexème.ARRETE }
	si identifiant == "bool" { retourne TypeLexème.BOOL }
	si identifiant == "boucle" { retourne TypeLexème.BOUCLE }
	si identifiant == "continue" { retourne TypeLexème.CONTINUE }
	si identifiant == "dans" { retourne TypeLexème.DANS }
	si identifiant == "déc" { retourne TypeLexème.DEC }
	si identifiant == "ent" { retourne TypeLexème.ENT }
	si identifiant == "faux" { retourne TypeLexème.FAUX }
	si identifiant == "mat3" { retourne TypeLexème.MAT3 }
	si identifiant == "mat4" { retourne TypeLexème.MAT4 }
	si identifiant == "nul" { retourne TypeLexème.NUL }
	si identifiant == "pour" { retourne TypeLexème.POUR }
	si identifiant == "retourne" { retourne TypeLexème.RETOURNE }
	si identifiant == "si" { retourne TypeLexème.SI }
	si identifiant == "sinon" { retourne TypeLexème.SINON }
	si identifiant == "vec2" { retourne TypeLexème.VEC2 }
	si identifiant == "vec3" { retourne TypeLexème.VEC3 }
	si identifiant == "vec4" { retourne TypeLexème.VEC4 }
	si identifiant == "vrai" { retourne TypeLexème.VRAI }

	retourne TypeLexème.CHAINE_CARACTERE
}

//##############################################################################

Lexeuse :: struct {
    chn : chaine

    début : *z8
    début_mot : *z8
    fin : *z8

    lexèmes : []DonnéesLexème

    taille_mot_courant := 0
	compte_ligne := 0
	position_ligne := 0
	pos_mot := 0
}

construit_lexeuse :: fonc(chn : chaine) -> Lexeuse
{
    dyn lexeuse : Lexeuse
    lexeuse.chn = chn
    lexeuse.début = @chn[0]
    lexeuse.début_mot = lexeuse.début
    lexeuse.fin = lexeuse.début + chn.taille

    retourne lexeuse
}

détruit_lexeuse :: fonc(dyn lexeuse : &Lexeuse) -> rien
{
	déloge lexeuse.lexèmes
}

performe_lexage :: fonc(dyn lexeuse : &Lexeuse) -> rien
{
	lexeuse.taille_mot_courant := 0

	tantque (!lexeuse.fini()) {
		dyn nombre_octet := nombre_octets_utf8(lexeuse.début)

		discr (nombre_octet) {
			1 {
				lexeuse.analyse_caractère_simple()
			}
			2,
			3,
			4 {
				si (lexeuse.taille_mot_courant == 0) {
					lexeuse.enregistre_pos_mot()
				}

				dyn c := converti_utf8_utf32(lexeuse.début, nombre_octet)

				discr transtype(c : TypeRune) {
					ESPACE_INSECABLE,
					ESPACE_D_OGAM,
					SEPARATEUR_VOYELLES_MONGOL,
					DEMI_CADRATIN,
					CADRATIN,
					ESPACE_DEMI_CADRATIN,
					ESPACE_CADRATIN,
					TIERS_DE_CADRATIN,
					QUART_DE_CADRATIN,
					SIXIEME_DE_CADRATIN,
					ESPACE_TABULAIRE,
					ESPACE_PONCTUATION,
					ESPACE_FINE,
					ESPACE_ULTRAFINE,
					ESPACE_SANS_CHASSE,
					ESPACE_INSECABLE_ETROITE,
					ESPACE_MOYENNE_MATHEMATIQUE,
					ESPACE_IDEOGRAPHIQUE,
					ESPACE_INSECABLE_SANS_CHASSE {
						si (lexeuse.taille_mot_courant != 0) {
							lexeuse.pousse_mot(id_identifiant(lexeuse.mot_courant()))
						}

						lexeuse.avance(nombre_octet)
					}
					GUILLEMET_OUVRANT {
						si (lexeuse.taille_mot_courant != 0) {
							lexeuse.pousse_mot(id_identifiant(lexeuse.mot_courant()))
						}

						// Saute le premier guillemet.
						lexeuse.avance(nombre_octet)
						lexeuse.enregistre_pos_mot()

						tantque (!lexeuse.fini()) {
							nombre_octet = nombre_octets_utf8(lexeuse.début)
							c = converti_utf8_utf32(lexeuse.début, nombre_octet)

							si (transtype(c : TypeRune) == TypeRune.GUILLEMET_FERMANT) {
								arrête
							}

							lexeuse.taille_mot_courant += nombre_octet
							lexeuse.avance(nombre_octet)
						}

						// Saute le dernier guillemet.
						lexeuse.avance(nombre_octet)

						lexeuse.pousse_mot(TypeLexème.CHAINE_LITTERALE)
					}
					sinon {
						lexeuse.taille_mot_courant += nombre_octet
						lexeuse.avance(nombre_octet)
					}
				}
			}
			sinon {
				// Le caractère (octet) courant est invalide dans le codec unicode.
				//lance_erreur("Le codec Unicode ne peut comprendre le caractère !")
			}
		}
	}

	si (lexeuse.taille_mot_courant != 0) {
		//lance_erreur("Des caractères en trop se trouvent à la fin du texte !")
	}
}

fini :: fonc(lexeuse : &Lexeuse) -> bool
{
	retourne lexeuse.début >= lexeuse.fin
}

avance :: fonc(dyn lexeuse : &Lexeuse, n : z32) -> rien
{
	pour i dans 0 ... n - 1 {
		si (lexeuse.caractère_courant() == '\n') {
			lexeuse.compte_ligne += 1
			lexeuse.position_ligne = 0
		}
		sinon {
			lexeuse.position_ligne += 1
		}

		lexeuse.début += 1
	}
}

caractère_courant :: fonc(lexeuse : &Lexeuse) -> z8
{
	retourne mémoire(lexeuse.début)
}

caractère_voisin :: fonc(lexeuse : &Lexeuse, n : z32) -> z8
{
	retourne mémoire(lexeuse.début + n)
}

mot_courant :: fonc(lexeuse : &Lexeuse) -> chaine
{
	retourne construit_chaine(lexeuse.début_mot, lexeuse.taille_mot_courant)
}

analyse_caractère_simple :: fonc(dyn lexeuse : &Lexeuse) -> rien
{
	si (est_espace_blanc(lexeuse.caractère_courant())) {
		si (lexeuse.taille_mot_courant != 0) {
			lexeuse.pousse_mot(id_identifiant(lexeuse.mot_courant()))
		}

		lexeuse.avance(1)

        retourne
	}

    est_spécial, idc := est_caractère_spécial(lexeuse.caractère_courant())

	si (est_spécial) {
		si (lexeuse.taille_mot_courant != 0) {
			lexeuse.pousse_mot(id_identifiant(lexeuse.mot_courant()))
		}

		lexeuse.enregistre_pos_mot()

		dyn id := id_digraphe(construit_chaine(lexeuse.début, 2))

		si (id != TypeLexème.INCONNU) {
			lexeuse.pousse_caractère()
			lexeuse.pousse_caractère()
			lexeuse.pousse_mot(id)
			lexeuse.avance(2)
			retourne
		}

		discr (lexeuse.caractère_courant()) {
			'.' {
				si (lexeuse.caractère_voisin(1) != '.') {
					lexeuse.pousse_caractère()
					lexeuse.pousse_mot(TypeLexème.POINT)
					lexeuse.avance(1)
					retourne
				}

				si (lexeuse.caractère_voisin(2) != '.') {
					//lance_erreur("Un point est manquant ou un point est en trop !\n")
				}

				lexeuse.pousse_caractère()
				lexeuse.pousse_caractère()
				lexeuse.pousse_caractère()

				lexeuse.pousse_mot(TypeLexème.TROIS_POINTS)
				lexeuse.avance(3)
			}
			'"' {
				// Saute le premier guillemet.
				lexeuse.avance(1)
				lexeuse.enregistre_pos_mot()

				tantque (!lexeuse.fini()) {
					si (lexeuse.caractère_courant() == '"' && lexeuse.caractère_voisin(-1) != '\\') {
						arrête
					}

					lexeuse.pousse_caractère()
					lexeuse.avance(1)
				}

				// Saute le dernier guillemet.
				lexeuse.avance(1)

				lexeuse.pousse_mot(TypeLexème.CHAINE_LITTERALE)
			}
			'\'' {
				// Saute la première apostrophe.
				lexeuse.avance(1)

				lexeuse.enregistre_pos_mot()

				si (lexeuse.caractère_courant() == '\\') {
					lexeuse.pousse_caractère()
					lexeuse.avance(1)
				}

				lexeuse.pousse_caractère()
				lexeuse.pousse_mot(TypeLexème.CARACTERE)

				lexeuse.avance(1)

				// Saute la dernière apostrophe.
				si (lexeuse.caractère_courant() != '\'') {
					//lance_erreur("Plusieurs caractères détectés dans un caractère simple !\n")
				}

				lexeuse.avance(1)
			}
			'#' {
				// ignore commentaire
				tantque (lexeuse.caractère_courant() != '\n') {
					lexeuse.avance(1)
				}
			}
			sinon {
				lexeuse.pousse_caractère()
				lexeuse.pousse_mot(idc)
				lexeuse.avance(1)
			}
		}
	}
	sinon si (lexeuse.taille_mot_courant == 0 && est_nombre_décimal(lexeuse.caractère_courant())) {
		lexeuse.enregistre_pos_mot()

		// nous savons que nous avons un chiffre, pousse et avance
		lexeuse.pousse_caractère()
		lexeuse.avance(1)

		// À FAIRE : nombre à virgule, hexadécimal, octal, binaire....
		tantque est_nombre_décimal(lexeuse.caractère_courant()) {
			lexeuse.pousse_caractère()
			lexeuse.avance(1)
		}

		lexeuse.pousse_mot(TypeLexème.NOMBRE_ENTIER)
	}
	sinon {
		si (lexeuse.taille_mot_courant == 0) {
			lexeuse.enregistre_pos_mot()
		}

		lexeuse.pousse_caractère()
		lexeuse.avance(1)
	}
}

pousse_caractère :: fonc(dyn lexeuse : &Lexeuse) -> rien
{
	lexeuse.taille_mot_courant += 1
}

pousse_mot :: fonc(dyn lexeuse : &Lexeuse, type_lexème : TypeLexème) -> rien
{
    dyn données : DonnéesLexème
    données.lexème = type_lexème
    données.chn = lexeuse.mot_courant()

    tableau_ajoute(@lexeuse.lexèmes, données)

    lexeuse.taille_mot_courant = 0
}

enregistre_pos_mot :: fonc(dyn lexeuse : &Lexeuse) -> rien
{
	lexeuse.pos_mot = lexeuse.position_ligne
	lexeuse.début_mot = lexeuse.début
}
