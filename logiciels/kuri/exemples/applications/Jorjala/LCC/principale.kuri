importe Fondation
importe Math
importe SysFichier

//charge "lexage"

imprime_prompt :: fonc () -> rien
{
    imprime("> ")
}

GenreLexème :: énum {
    Invalide
    Plus
    Moins
    Fois
    Divise
    Reste
    NombreEntier
    NombreRéel
}

Lexème :: struct {
    genre: GenreLexème
    nombre_entier: z64
    nombre_réel: r64
}

Lexeuse :: struct {
    script: chaine

    position := 0

    ligne_courante := 0
    colonne := 0

    position_mot := 0
    taille_mot := 0

    lexèmes : []Lexème
}

fini :: fonc (lexeuse: *Lexeuse) -> bool
{
    retourne lexeuse.position >= lexeuse.script.taille
}

pousse_lexème :: fonc (lexeuse: *Lexeuse, lexème: Lexème) -> rien
{
    tableau_ajoute(@lexeuse.lexèmes, lexème)
}

enregistre_pos_mot :: fonc (lexeuse: *Lexeuse) -> rien
{
    lexeuse.position_mot = lexeuse.position
}

caractère_courant :: fonc (lexeuse: *Lexeuse) -> z8
{
    si lexeuse.fini() {
        retourne '\0'
    }

    retourne lexeuse.script[lexeuse.position]
}

avance :: fonc (lexeuse: *Lexeuse) -> rien
{
    lexeuse.colonne += 1
    lexeuse.position += 1
}

mot_courant :: fonc (lexeuse: *Lexeuse) -> chaine
{
    retourne construit_chaine(@lexeuse.script[lexeuse.position_mot], lexeuse.position - lexeuse.position_mot)
}

pousse_lexème_caractère :: fonc (lexeuse: *Lexeuse, genre: GenreLexème) -> rien
{
    lexème : Lexème
    lexème.genre = genre

    lexeuse.pousse_lexème(lexème)
    lexeuse.avance()
}

DonnéesNombre :: struct {
    unités : chaine
    fraction : chaine
    exposant : chaine
}

// nombres valides
// 0
// 123456789
// 123.456789
// 123.456e789
// 123.456E789
// 123.456e+789
// 123.456E+789
// 123.456e-789
// 123.456E-789
// 0.123
// 0.123e789
// 0e5
lèxe_nombre :: fonc (lexeuse: *Lexeuse) -> rien
{
    données_nombre : DonnéesNombre
    lexème_nombre := GenreLexème.NombreEntier

    lexeuse.enregistre_pos_mot()

    si lexeuse.caractère_courant() == '0' {
        lexeuse.avance()
    }
    sinon {
        // nous devons avoir au moins un chiffre
        si !lexeuse.lis_chiffre('1', '9') {
            retourne
        }

        // lis les autres, ignore le retour
        _ := lexeuse.lis_chiffre('0', '9')
    }

    données_nombre.unités = lexeuse.mot_courant()

    // lis fraction
    si lexeuse.caractère_courant() == '.' {
        lexème_nombre = GenreLexème.NombreRéel

        lexeuse.avance()

        lexeuse.enregistre_pos_mot()

        // nous devons avoir au moins un chiffre
        si !lexeuse.lis_chiffre('0', '9') {
            retourne
        }

        données_nombre.fraction = lexeuse.mot_courant()
    }

    e := lexeuse.caractère_courant()

    // lis exposant
    si e == 'e' || e == 'E' {
        lexème_nombre = GenreLexème.NombreRéel

        lexeuse.avance()

        lexeuse.enregistre_pos_mot()

        s := lexeuse.caractère_courant()

        si s == '+' || s == '-' {
            lexeuse.avance()
        }

        // nous devons avoir au moins un chiffre
        si !lexeuse.lis_chiffre('0', '9') {
            retourne
        }

        données_nombre.exposant = lexeuse.mot_courant()
    }

    // ------------------------

    nombre_final : r64

    unités := extrait_nombre_entier(données_nombre.unités)

    nombre_final = unités comme r64

    si données_nombre.fraction.taille != 0 {
        fraction := extrait_nombre_entier(données_nombre.fraction)

        nombre_final += fraction comme r64 * pow(0.1, données_nombre.fraction.taille comme r64)
    }

    si données_nombre.exposant.taille != 0 {
        exposant := extrait_nombre_entier(données_nombre.exposant)

        si exposant < 0 {
            nombre_final *= pow(0.1, -exposant comme r64)
        }
        sinon {
            nombre_final *= pow(10.0, exposant comme r64)
        }
    }

    // ------------------------

    lexème : Lexème
    lexème.genre = lexème_nombre

    si lexème_nombre == GenreLexème.NombreEntier {
        lexème.nombre_entier = nombre_final comme z64
    }
    sinon {
        lexème.nombre_réel = nombre_final
    }

    lexeuse.pousse_lexème(lexème)
}

lis_chiffre :: fonc (lexeuse: *Lexeuse, min: z8, max: z8) -> bool
{
    eu_un_chiffre := faux

    tantque !lexeuse.fini() {
        si min <= lexeuse.caractère_courant() <= max {
            eu_un_chiffre = vrai
            lexeuse.avance()
            continue
        }

        arrête
    }

    retourne eu_un_chiffre
}

performe_lexage :: fonc (lexeuse: *Lexeuse) -> rien
{
    tantque !lexeuse.fini() {
        c := lexeuse.caractère_courant()

        discr c {
            ' ', '\t' {
                lexeuse.avance()
            }
            '\n' {
                lexeuse.avance()
                lexeuse.ligne_courante += 1
                lexeuse.colonne = 0
            }
            '0',
            '1',
            '2',
            '3',
            '4',
            '5',
            '6',
            '7',
            '8',
            '9' {
                lexeuse.lèxe_nombre()
            }
            '+' {
                lexeuse.pousse_lexème_caractère(GenreLexème.Plus)
            }
            '-' {
                lexeuse.pousse_lexème_caractère(GenreLexème.Moins)
            }
            '*' {
                lexeuse.pousse_lexème_caractère(GenreLexème.Fois)
            }
            '/' {
                lexeuse.pousse_lexème_caractère(GenreLexème.Divise)
            }
            '%' {
                lexeuse.pousse_lexème_caractère(GenreLexème.Reste)
            }
            sinon {
                lexeuse.avance()
            }
        }
    }
}

lèxe :: fonc (entrée: chaine) -> []Lexème
{
    lexeuse : Lexeuse
    lexeuse.script = entrée

    performe_lexage(@lexeuse)

    retourne lexeuse.lexèmes
}

principale :: fonc () -> z32
{
    diffère { imprime("Fin du programme, mémoire utilisée : %o\n", mémoire_utilisée()) }

    marque := obtiens_marque_stockage_temporaire()

    nouveau_contexte := contexte
    nouveau_contexte.allocatrice = __stockage_temporaire

    boucle {
        set_marque_stockage_temporaire(marque);
        marque = obtiens_marque_stockage_temporaire()

        imprime_prompt()

        entrée : chaine
        pousse_contexte nouveau_contexte {
            entrée = entrée_standarde().lis_ligne()
        }

        si entrée == "\n" {
            arrête
        }

        lexèmes := lèxe(entrée)

        imprime("lexèmes :\n")
        pour lexème dans lexèmes {
            imprime("%\n", lexème)
        }

        déloge lexèmes
    }

    retourne 0
}
