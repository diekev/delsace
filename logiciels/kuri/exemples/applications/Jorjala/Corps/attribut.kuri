importe Fondation

TypeAttribut :: énum_drapeau n16 {
	Z8
	Z16
	Z32
	Z64
	N8
	N16
	N32
	N64
	R16
	R32
	R64
	CHAINE
    TABLEAU
}

PortéeAttribut :: énum z8 {
	// l'attribut varie pour chaque point
	POINT
	// l'attribut varie pour chaque primitive
	PRIMITIVE
	// l'attribut varie pour chaque vertex de chaque primitive
	VERTEX
	// l'attribut est unique pour le corps
	CORPS
	// l'attribut varie pour chaque groupe
	GROUPE
}

TamponPartagé :: struct {
    données : []octet
    référence : *z32
}

Attribut :: struct {
    tampon : TamponPartagé
    nom : chaine
    type : TypeAttribut
    portée : PortéeAttribut
	// À FAIRE : utilisation de la dimension
    dimensions := 1
	nombre_éléments : z64 = 0
}

est_type_attribut_valide :: fonc(type : TypeAttribut) -> bool
{
    // enlève le type tableau au cas où
    type &= ~TypeAttribut.TABLEAU

    si type == 0 comme TypeAttribut {
        retourne faux
    }

    info := info_de(type)

    nombre_bits := 0

    pour valeur dans info.valeurs {
		// À FAIRE : typage des valeurs des énums
		type_ := type comme z32
		nombre_bits += (type_ & valeur) != 0 comme z32
    }

    retourne nombre_bits == 1
}

principale :: fonc () -> z32
{
	diffère { imprime("\nMémoire utilisée : %o\n", mémoire_utilisée()) }

	imprime("Validation d'attributs...\n\n")

	type := TypeAttribut.Z16
	imprime("est_type_valide : % ===> %\n", type, est_type_attribut_valide(type))

	type = TypeAttribut.TABLEAU | TypeAttribut.Z16
	imprime("est_type_valide : % ===> %\n", type, est_type_attribut_valide(type))

	type = TypeAttribut.TABLEAU | TypeAttribut.TABLEAU
	imprime("est_type_valide : % ===> %\n", type, est_type_attribut_valide(type))

	type = TypeAttribut.Z32 | TypeAttribut.Z16
	imprime("est_type_valide : % ===> %\n", type, est_type_attribut_valide(type))

	imprime("\n")

	imprime("Création d'attributs...\n\n")

	type = TypeAttribut.R32 | TypeAttribut.TABLEAU
	attr := crée_attribut(type)
	réserve(@attr, 10)

	imprime("%\n", attr)
	imprime("\nIntialise valeurs...\n")

	pour i dans 0 ... attr.nombre_éléments - 1 {
		ptr := tableau_r32(@attr, i)
		ptr.taille = 0
		ptr.pointeur = nul
	}

	imprime("\nValeurs :\n")

	ptr_tableau := tableau_r32(@attr, 0)
	tableau_ajoute(ptr_tableau, 5.0))

	ptr_tableau = tableau_r32(@attr, 5)
	tableau_ajoute(ptr_tableau, 5.0)

	pour i dans 0 ... attr.nombre_éléments - 1 {
		ptr := tableau_r32(@attr, i)

		imprime("Valeur % = %\n", i, mémoire(ptr))
	}

	nattr := copie_attribut(@attr)

	détruit(@attr)

	imprime("\nValeurs (après copie) :\n")

	ptr_tableau = tableau_r32(@attr, 5)
	tableau_ajoute(ptr_tableau, 5.0)

	pour i dans 0 ... attr.nombre_éléments - 1 {
		ptr := tableau_r32(@attr, i)

		imprime("Valeur % = %\n", i, mémoire(ptr))
	}

	détruit(@nattr)

	retourne 0
}

crée_attribut :: fonc(type : TypeAttribut) -> Attribut
{
	attr : Attribut
	attr.type = type
	attr.nom = ""
	attr.tampon.référence = loge z32
	mémoire(attr.tampon.référence) = 0

	retourne attr
}

réserve :: fonc(attr : *Attribut, nombre_éléments : z64) -> rien
{
	// À FAIRE : copie le tampon si référencé
	taille := nombre_éléments * taille_octet_type_attribut(attr.type)
	reloge attr.tampon.données : [taille]octet

	attr.nombre_éléments = nombre_éléments
}

est_type_tableau :: fonc(type : TypeAttribut) -> bool
{
	retourne (type & TypeAttribut.TABLEAU) != 0 comme TypeAttribut
}

détruit :: fonc(attr : *Attribut) -> rien
{
	si mémoire(attr.tampon.référence) > 0 {
		mémoire(attr.tampon.référence) -= 1
		retourne
	}

	si est_type_tableau(attr.type) {
		pour i dans 0 ... attr.nombre_éléments - 1 {
			// À FAIRE : types des données
			ptr := mémoire(tableau_r32(attr, i))
			déloge ptr
		}
	}

	déloge attr.tampon.données
	déloge attr.tampon.référence
}

valeur_z32 :: fonc(attr : *Attribut, index : z64) -> *z32
{
	si attr.type != TypeAttribut.Z32 {
		retourne nul
	}

	décalage := index * taille_octet_type_attribut(attr.type)

	retourne @attr.tampon.données[décalage] comme *z32
}

valeur_r32 :: fonc(attr : *Attribut, index : z64) -> *r32
{
	si attr.type != TypeAttribut.R32 {
		retourne nul
	}

	décalage := index * taille_octet_type_attribut(attr.type)

	retourne @attr.tampon.données[décalage] comme *r32
}

tableau_r32 :: fonc(attr : *Attribut, index : z64) -> *[]r32
{
	si attr.type != (TypeAttribut.TABLEAU | TypeAttribut.R32) {
		retourne nul
	}

	décalage := index * taille_octet_type_attribut(attr.type)

	retourne @attr.tampon.données[décalage] comme *[]r32
}

taille_octet_type_attribut :: fonc(type : TypeAttribut) -> z64
{
	taille : n32

	discr type {
		N8,
		Z8 {
			taille = taille_de(z8)
        }
		N16,
		Z16 {
			taille = taille_de(z16)
        }
		N32,
		Z32 {
			taille = taille_de(z32)
        }
		N64,
		Z64 {
			taille = taille_de(z64)
        }
		R16 {
			taille = taille_de(r16)
        }
		R32 {
			taille = taille_de(r32)
        }
		R64 {
			taille = taille_de(r64)
        }
		CHAINE {
			taille = taille_de(chaine)
        }
		sinon {
            si est_type_tableau(type) {
                // Tous les types de tableaux ont la même taille.
                taille = taille_de([]octet)
            }
        }
	}

	retourne taille comme z64
}

//fonc crée_attribut_point(nom : chaine, type : TypeAttribut, dimensions : z32) : Attribut

//fonc crée_attribut_primitive(nom : chaine, type : TypeAttribut, dimensions : z32) : Attribut

//fonc crée_attribut_vertex(nom : chaine, type : TypeAttribut, dimensions : z32) : Attribut

//fonc crée_attribut_corps(nom : chaine, type : TypeAttribut, dimensions : z32) : Attribut

//fonc crée_attribut_groupe(nom : chaine, type : TypeAttribut, dimensions : z32) : Attribut

copie_attribut :: fonc(attr : *Attribut) -> Attribut
{
    nattr := mémoire(attr)
    mémoire(nattr.tampon.référence) += 1

    retourne nattr
}

// À FAIRE : définir une bonne interface pour accéder aux valeurs sans gabarits
//
// Idée tirée de JAI :
//
// déclaration d'un type gabarit    => x : $T
// déclaration d'une valeur gabarit => $x : T
// La valeur gabarit est l'équivalent des valeurs littérales des templates en C++
// template <int N>, mais en plus flexible
//
// Une instruction #bake sers à instantier les fonctions selon les valeurs gabarits
// par exemple (avec notre syntaxe)
//
// fonc nouveau_tableau_fixe($N : Type_de_N, x : $Type_du_tableau) : [N]$Type_du_tableau
// crée_tableau_dix_éléments = #cuis nouveau_tableau_fixe($N = 10)
//
// On peut alors appeler : crée_tableau_dix_éléments(z32) pour créer un [10]z32
//
// Pour les attributs nous pourrions avoir un système similaire
//
// fonc valeur(attr : *Attribut, index : z64, $Type_de_valeur : Type, $T : TypeAttribut)
//
// valeur_z32 = #cuis valeur(Type_de_valeur = z32, T = TypeAttribut.Z32)
// valeur_r32 = #cuis valeur(Type_de_valeur = r32, T = TypeAttribut.R32)
// ....
//
// Ceci pourrait aisément remplacer le combo template + macro utilisé en C++
