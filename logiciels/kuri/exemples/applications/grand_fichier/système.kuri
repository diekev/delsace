État :: énum z32 {
	DÉBUT
	INSTRUCTION
	CHEMIN
	PROTOCOL
}

éunm Instruction : z32 {
	CHERCHE,
	CRÉE,
	AJOURNE,
	DÉTRUIT,
	ÉCRIT,
	INVALIDE,
}

détermine_instruction :: fonc(chn : chaine) -> Instruction
{
	info_inst = info_de(Instruction)

	pour nom, idx dans info_inst.noms {
		si chn == nom {
			retourne transtype(info_inst.valeurs[idx] : Instruction)
		}
	}

	retourne Instruction.INVALIDE
}

// CHERCHE /arachne/noeuds.base PGF/1.0\r\n
// CRÉE /arachne/noeuds.base PGF/1.0\r\n
// AJOURNE /arachne/noeuds.base PGF/1.0\r\n
analyse_réponse :: fonc(réponse : chaine) -> rien
{
	dyn début_mot = 0
	dyn taille_mot = 0

	dyn inst : Instruction
	dyn chemin : chaine
	dyn protocole : chaine

	pour c, idx dans réponse {
		discr c {
			' ' {
				si état == État.DÉBUT {
					mot = construit_chaine(@c, taille_mot)
					taille_mot = 0
					inst = détermine_instruction(mot)

					si inst == Instruction.INVALIDE {
						retourne INSTRUCTION_INVALIDE
					}

					état = État.INSTRUCTION
				}
				sinon état == État.INSTRUCTION {
					chemin = construit_chaine(@c, taille_mot)
					taille_mot = 0

					état = État.CHEMIN
				}
			}
			'\n',
			'\r' {
				si état == État.CHEMIN {
					protocole = construit_chaine(@c, taille_mot)
					taille_mot = 0

					si protocole != "PGF/1.0" {
						retourne PROTOCOLE_INVALIDE
					}

					état = État.FINI
				}
				sinon si état == État.FINI {
					// OK
				}
			}
			sinon {
				si taille_mot == 0 {
					début_mot = idx
				}

				taille_mot += 1
			}
		}
	}
}

TypeNoeud :: énum z32 {
	DOSSIER
	FEUILLE
}

Noeud :: struct {
	enfants : []*Noeud
	nom : chaine
}

trouve :: fonc(noeud : *Noeud, nom : chaine) -> *Noeud
{
	pour enfant dans noeud.enfants {
		si compare_chaine(enfant.nom, nom) {
			retourne enfant
		}
	}

	retourne nul
}

Arbre :: struct {
	racine : *Noeud
	noeuds : []*Noeud
}

décrée_arbre :: fonc(arbre : &Arbre) -> rien
{
	pour noeud dans noeuds {
		déloge noeud
	}
}

cherche_fichier :: fonc(arbre : &Arbre, chemin : chaine) -> chaine
{
	dyn noeud = arbre.noeud_racine

	pour morceau dans morcelle(chemin) {
		noeud = noeud.trouve(morceau)

		si noeud == nul {
			retourne nul
		}
	}

	si noeud.type != TypeNoeud.FEUILLE {
		retourne nul
	}

	retourne noeud
}

Journal :: struct {
	requêtes : []Requête
}

pousse_requête :: fonc(dyn journal : &Journal, requête : Requête) -> rien
{
	taille = journal.requêtes.taille
	reloge journal.requêtes : [taille + 1]Requête
	journal.requête[taille] = requête
}

crée_journal :: fonc() -> Journal
{
	dyn journal : Journal

	requête = Requête {
		inst = Instruction.CRÉE,
		chemin = "/",
		protocole = "PGL/1.1"
	}

	journal.pousse_requête(requête)

	retourne journal
}

charge_journal :: fonc(chemin : chaine) -> Journal
{
	contenu = contenu_fichier_texte(chemin)
	diffère { déloge contenu; }

	analyse_requête(contenu)
}

Système :: struct {
	chemins : []chemin
	journal : Journal
}

crée_système :: fonc() -> Système
{
	dyn système : Système

	// charge le fichier journal ou crée le si inexistant
	dyn journal : Journal

	si fichier_existe("journal_requête") {
		journal = crée_journal()
	}
	sinon {
		journal = ouvre_journal("")
	}

	// rejoue chaque requête dans le journal
	pour requête dans rejoue(journal) {
		répond_requête(système, requête)
	}

	système
}

fichier_existe :: fonc(système : &Système, chn : chaine) -> bool
{
	pour chemin dans système.chemins {
		si chn == chemin {
			retourne vrai
		}
	}

	retourne faux
}

Requête :: struct {
	inst : Instruction
	chemin : chaine
	protocole : chaine
}

// ÉCRITURE_IMPOSSIBLE
// FICHIER_INTROUVABLE
// FICHIER_EXISTE
// FICHIER_CRÉE
// AJOURNEMENT_IMPOSSIBLE
// AJOURNEMENT_FAIT
// CRÉATION_IMPOSSIBLE
// FICHIER_ÉCRIS
// DESTRUCTION_IMPOSSIBLE
// FICHIER_DÉTRUIT
répond :: fonc(système : &Système, requête : &Requête) -> chaine
{
	dyn enchaineuse : Enchaineuse
	diffère { détruit_tampons(@enchaineuse) }

	discr requête.inst {
		Instruction.CHERCHE {
			si !fichier_existe(système, requête.chemin) {
				ajoute_au_tampon(@enchaineuse, "FICHIER_INTROUVABLE")
			}
		}
		Instruction.CRÉE {
			si fichier_existe(système, requête.chemin) {
				ajoute_au_tampon(@enchaineuse, "FICHIER_EXISTE")
			}

			si !crée_fichier(système, requête.chemin) {
				ajoute_au_tampon(@enchaineuse, "CRÉATION_IMPOSSIBLE")
			}
		}
		Instruction.AJOURNE {

		}
		Instruction.ÉCRIT {
		}
		Instruction.DÉTRUIT {
		}
	}
}
