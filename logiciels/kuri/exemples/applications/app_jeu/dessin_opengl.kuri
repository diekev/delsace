#!inclus "math.h"
#!bib "m"

charge "glew"

importe "Fondation"

dyn VertexArrayID = transtype(0 : n32)
dyn ProgramID = transtype(0 : n32)
dyn vertexbuffer = transtype(0 : n32)
dyn colorbuffer = transtype(0 : n32)
dyn tabl_sommets : *tableau = nul
dyn tabl_couleur : *tableau = nul

fonc charge_programme() : n32
{
    soit source_vertex = "
    #version 330 core
    layout(location = 0) in vec3 sommet;
    layout(location = 1) in vec4 couleurs;
    smooth out vec4 couleur;
    void main()
    {
        gl_Position.xyz = 2.0 * sommet - transtype(1.0 : r32);
        gl_Position.w = transtype(1.0 : r32);
        couleur = couleurs;
    }
    "

    soit source_fragment = "
    #version 330 core
    out vec4 couleur_fragment;
    smooth in vec4 couleur;
    void main()
    {
        couleur_fragment = couleur;
    }
    "

    # crée les nuanceurs
	soit VertexShaderID = glCreateShader(VERTEX_SHADER de OGL)
	soit FragmentShaderID = glCreateShader(FRAGMENT_SHADER de OGL)

    soit taille_src_vertex = transtype(taille de source_vertex : z32)
	glShaderSource(VertexShaderID, 1, @pointeur de source_vertex , @taille_src_vertex)
	glCompileShader(VertexShaderID)

    # verifie la compilation
    dyn Result : z32 = 0
    dyn InfoLogLength : z32 = 0
    glGetShaderiv(VertexShaderID, LINK_STATUS de OGL, @Result)
	glGetShaderiv(VertexShaderID, INFO_LOG_LENGTH de OGL, @InfoLogLength)

    si InfoLogLength > 0 {
		soit ProgramErrorMessage = loge chaine(InfoLogLength+1)
		glGetShaderInfoLog(VertexShaderID, InfoLogLength, nul, pointeur de ProgramErrorMessage)
		imprime("!!!!! Erreur compilation : VertexShaderID", ProgramErrorMessage, '\n')
        déloge ProgramErrorMessage
	}

    soit taille_src_fragment = transtype(taille de source_fragment : z32)
	glShaderSource(FragmentShaderID, 1, @pointeur de source_fragment , @taille_src_fragment)
	glCompileShader(FragmentShaderID)

    # verifie la compilation
    Result = 0
    InfoLogLength = 0
    glGetShaderiv(FragmentShaderID, LINK_STATUS de OGL, @Result)
	glGetShaderiv(FragmentShaderID, INFO_LOG_LENGTH de OGL, @InfoLogLength)

    si InfoLogLength > 0 {
		soit ProgramErrorMessage = loge chaine(InfoLogLength+1)
		glGetShaderInfoLog(FragmentShaderID, InfoLogLength, nul, pointeur de ProgramErrorMessage)
		imprime("!!!!! Erreur compilation : FragmentShaderID", ProgramErrorMessage, '\n')
        déloge ProgramErrorMessage
	}

    soit ProgramID_ = glCreateProgram()
	glAttachShader(ProgramID_, VertexShaderID)
	glAttachShader(ProgramID_, FragmentShaderID)
	glLinkProgram(ProgramID_)

    # verifie la liaison
    Result = 0
    InfoLogLength = 0
    glGetProgramiv(ProgramID_, COMPILE_STATUS de OGL, @Result)
	glGetProgramiv(ProgramID_, INFO_LOG_LENGTH de OGL, @InfoLogLength)

    si InfoLogLength > 0 {
		soit ProgramErrorMessage = loge chaine(InfoLogLength+1)
		glGetProgramInfoLog(ProgramID_, InfoLogLength, nul, pointeur de ProgramErrorMessage)
		imprime("!!!!! Erreur liaison : ProgramID", ProgramErrorMessage, '\n')
        déloge ProgramErrorMessage
	}

	glDetachShader(ProgramID_, VertexShaderID)
	glDetachShader(ProgramID_, FragmentShaderID)

	glDeleteShader(VertexShaderID)
	glDeleteShader(FragmentShaderID)

    retourne ProgramID_
}

fonc initialise_tampon_dessin() : rien
{
    nonsûr {
        tabl_sommets = crée_tableau(transtype(taille_de(z32) : z64))
        tabl_couleur = crée_tableau(transtype(taille_de(z32) : z64))
        ProgramID = charge_programme()
    }

    glGenVertexArrays(1, @VertexArrayID)
    glGenBuffers(1, @vertexbuffer)
    glGenBuffers(1, @colorbuffer)
}

fonc issitialise_tampon_dessin() : rien
{
    glDeleteVertexArrays(1, @VertexArrayID)
    glDeleteBuffers(1, @vertexbuffer)
    glDeleteBuffers(1, @colorbuffer)
    decrée_tableau(tabl_sommets)
    decrée_tableau(tabl_couleur)
    glDeleteProgram(ProgramID)
}

fonc débute_dessin() : rien
{
    glBindVertexArray(VertexArrayID)
}

fonc termine_dessin() : rien
{
    glUseProgram(ProgramID)

    glEnableVertexAttribArray(transtype(0 : n32))
    glBindBuffer(ARRAY_BUFFER de OGL, vertexbuffer)
    glBufferData(ARRAY_BUFFER de OGL, transtype(taille de tabl_sommets * taille_de(z32) : n64), pointeur de tampon de tabl_sommets, STATIC_DRAW de OGL)
    glVertexAttribPointer(transtype(0 : n32), 3, FLOAT de OGL, FALSE de OGL, 0, nul)

    glEnableVertexAttribArray(transtype(1 : n32))
    glBindBuffer(ARRAY_BUFFER de OGL, colorbuffer)
    glBufferData(ARRAY_BUFFER de OGL, transtype(taille de tabl_couleur * taille_de(z32) : n64), pointeur de tampon de tabl_couleur, STATIC_DRAW de OGL)
    glVertexAttribPointer(transtype(1 : n32), 4, FLOAT de OGL, FALSE de OGL, 0, nul)

    glDrawArrays(TRIANGLES de OGL, 0, taille de tabl_sommets / 3)
    glDisableVertexAttribArray(transtype(0 : n32))

    glUseProgram(transtype(0 : n32))

    nonsûr {
        taille de tabl_sommets = 0
        taille de tabl_couleur = 0
    }

    glBindVertexArray(transtype(0 : n32))
}

fonc ajoute_sommet(x : r32, y : r32, z : r32) : rien
{
    pousse_tableau(tabl_sommets, @x)
    pousse_tableau(tabl_sommets, @y)
    pousse_tableau(tabl_sommets, @z)
}

struct Couleur {
    r : r32 = transtype(0.0 : r32)
    v : r32 = transtype(0.0 : r32)
    b : r32 = transtype(0.0 : r32)
    a : r32 = transtype(0.0 : r32)
}

fonc ajoute_couleur(coul : Couleur) : rien
{
    pousse_tableau(tabl_couleur, @r de coul)
    pousse_tableau(tabl_couleur, @v de coul)
    pousse_tableau(tabl_couleur, @b de coul)
    pousse_tableau(tabl_couleur, @a de coul)
}

fonc dessine_triangle() : rien
{
    débute_dessin()

    ajoute_sommet(transtype(-transtype(1.0 : r32) : r32), transtype(-transtype(1.0 : r32) : r32), transtype(0.0 : r32))
    ajoute_sommet( transtype(1.0 : r32), transtype(-transtype(1.0 : r32) : r32), transtype(0.0 : r32))
    ajoute_sommet( transtype(0.0 : r32),  transtype(1.0 : r32), transtype(0.0 : r32))

    termine_dessin()
}

fonc dessine_carré_ex(px : r32, py : r32, tx : r32, ty : r32, coul : Couleur) : rien
{
    débute_dessin()

    soit min_x = px
    soit min_y = py
    soit max_x = px + tx
    soit max_y = py + ty

    ajoute_sommet(min_x, min_y, transtype(0.0 : r32))
    ajoute_couleur(coul)
    ajoute_sommet(max_x, min_y, transtype(0.0 : r32))
    ajoute_couleur(coul)
    ajoute_sommet(min_x, max_y, transtype(0.0 : r32))
    ajoute_couleur(coul)

    ajoute_sommet(max_x, min_y, transtype(0.0 : r32))
    ajoute_couleur(coul)
    ajoute_sommet(max_x, max_y, transtype(0.0 : r32))
    ajoute_couleur(coul)
    ajoute_sommet(min_x, max_y, transtype(0.0 : r32))
    ajoute_couleur(coul)

    termine_dessin()
}

fonc dessine_carré() : rien
{
    soit couleur = Couleur{r = transtype(1.0 : r32), v = transtype(1.0 : r32), b = transtype(0.0 : r32), a = transtype(1.0 : r32) }
    dessine_carré_ex(transtype(-0.5 : r32), transtype(-0.5 : r32), transtype(1.0 : r32), transtype(1.0 : r32), couleur)
}

fonc externe cos(a : r32) : r32
fonc externe sin(a : r32) : r32

fonc dessine_cercle(cx : r32, cy : r32, rx : r32, ry : r32) : rien
{
    débute_dessin()

    soit segs = 32
    dyn phi = transtype(0.0 : r32)
    dyn phi_delta = transtype(2.0 * 3.14159 / transtype(segs : r32) : r32)

    pour i dans 0...segs - 1 {
        soit ca0 = cx + cos(phi) * rx
        soit sa0 = cy + sin(phi) * ry

        soit ca1 = cx + cos(phi + phi_delta) * rx
        soit sa1 = cy + sin(phi + phi_delta) * ry

        ajoute_sommet(cx, cy, transtype(0.0 : r32))
        ajoute_sommet(ca0, sa0, transtype(0.0 : r32))
        ajoute_sommet(ca1, sa1, transtype(0.0 : r32))

        phi += phi_delta
    }

    termine_dessin()
}

fonc dessine_quart_cercle(cx : r32, cy : r32, rx : r32, ry : r32, quadrant : z32) : rien
{
    débute_dessin()

    soit segs = 8
    dyn phi = transtype(quadrant : r32) * transtype((3.14159 / 2.0) : r32)
    dyn phi_delta = transtype(2.0 * 3.14159 / transtype(segs * 4 : r32) : r32)

    pour i dans 0...segs - 1 {
        soit ca0 = cx + cos(phi) * rx
        soit sa0 = cy + sin(phi) * ry

        soit ca1 = cx + cos(phi + phi_delta) * rx
        soit sa1 = cy + sin(phi + phi_delta) * ry

        ajoute_sommet(cx, cy, transtype(0.0 : r32))
        ajoute_sommet(ca0, sa0, transtype(0.0 : r32))
        ajoute_sommet(ca1, sa1, transtype(0.0 : r32))

        phi += phi_delta
    }

    termine_dessin()
}

fonc dessine_rect_arrondi(largeur : r32, hauteur : r32, arrondis_pixel : r32) : rien
{
    soit rx = arrondis_pixel / largeur
    soit ry = arrondis_pixel / hauteur

    soit px : r32 = transtype(transtype(-transtype(1.0 : r32) : r32) + rx : r32)
    soit py : r32 = transtype(transtype(-transtype(1.0 : r32) : r32) + ry : r32)
    soit tx : r32 = transtype(2.0 - 2.0 * rx : r32)
    soit ty : r32 = transtype(2.0 - 2.0 * ry : r32)

    soit couleur = Couleur{r = transtype(1.0 : r32), v = transtype(1.0 : r32), b = 0.0, a = transtype(1.0 : r32) }

    # dessine centre
    dessine_carré_ex(px, py, tx, ty, couleur)

    # dessine rect gauche
    dessine_carré_ex(px - rx, py, rx, ty, couleur)

    # dessine rect droite
    dessine_carré_ex(px + tx, py, rx, ty, couleur)

    # dessine rect dessus
    dessine_carré_ex(px, py + ty, tx, ry, couleur)

    # dessine rect dessous
    dessine_carré_ex(px, py - ry, tx, ry, couleur)

    # dessine coin haut-gauche
    dessine_quart_cercle(px, py + ty, rx, ry, 1)

    # dessine coin haut-droite
    dessine_quart_cercle(px + tx, py + ty, rx, ry, 0)

    # dessine coin bas-gauche
    dessine_quart_cercle(px, py, rx, ry, 2)

    # dessine coin bas-droite
    dessine_quart_cercle(px + tx, py, rx, ry, 3)
}

fonc dessine_bouton() : rien
{

}

fonc dessine_image() : rien
{
    # crée texture

    # rempli UV
}
