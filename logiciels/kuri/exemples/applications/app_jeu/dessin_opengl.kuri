#inclus "math.h"
#bib "m"

charge "glew"

importe "Fondation"

dyn VertexArrayID := transtype(0 : n32)
dyn ProgramID := transtype(0 : n32)
dyn vertexbuffer := transtype(0 : n32)
dyn colorbuffer := transtype(0 : n32)
dyn tabl_sommets : *tableau = nul
dyn tabl_couleur : *tableau = nul

charge_programme :: fonc() -> n32
{
    source_vertex := "
    #version 330 core
    layout(location = 0) in vec3 sommet;
    layout(location = 1) in vec4 couleurs;
    smooth out vec4 couleur;
    void main()
    {
        gl_Position.xyz = 2.0 * sommet - transtype(1.0 : r32);
        gl_Position.w = transtype(1.0 : r32);
        couleur = couleurs;
    }
    "

    source_fragment := "
    #version 330 core
    out vec4 couleur_fragment;
    smooth in vec4 couleur;
    void main()
    {
        couleur_fragment = couleur;
    }
    "

    // crée les nuanceurs
	VertexShaderID := glCreateShader(OGL.VERTEX_SHADER)
	FragmentShaderID := glCreateShader(OGL.FRAGMENT_SHADER)

    taille_src_vertex := transtype(source_vertex.taille : z32)
	glShaderSource(VertexShaderID, 1, @source_vertex.pointeur , @taille_src_vertex)
	glCompileShader(VertexShaderID)

    // verifie la compilation
    dyn Result : z32 = 0
    dyn InfoLogLength : z32 = 0
    glGetShaderiv(VertexShaderID, OGL.LINK_STATUS, @Result)
	glGetShaderiv(VertexShaderID, OGL.INFO_LOG_LENGTH, @InfoLogLength)

    si InfoLogLength > 0 {
		ProgramErrorMessage := loge chaine(InfoLogLength+1)
		glGetShaderInfoLog(VertexShaderID, InfoLogLength, nul, ProgramErrorMessage.pointeur)
		imprime_sans_format("!!!!! Erreur compilation : VertexShaderID", ProgramErrorMessage, '\n')
        déloge ProgramErrorMessage
	}

    taille_src_fragment := transtype(source_fragment.taille : z32)
	glShaderSource(FragmentShaderID, 1, @source_fragment.pointeur , @taille_src_fragment)
	glCompileShader(FragmentShaderID)

    // verifie la compilation
    Result = 0
    InfoLogLength = 0
    glGetShaderiv(FragmentShaderID, OGL.LINK_STATUS, @Result)
	glGetShaderiv(FragmentShaderID, OGL.INFO_LOG_LENGTH, @InfoLogLength)

    si InfoLogLength > 0 {
		ProgramErrorMessage := loge chaine(InfoLogLength+1)
		glGetShaderInfoLog(FragmentShaderID, InfoLogLength, nul, ProgramErrorMessage.pointeur)
		imprime_sans_format("!!!!! Erreur compilation : FragmentShaderID", ProgramErrorMessage, '\n')
        déloge ProgramErrorMessage
	}

    ProgramID_ := glCreateProgram()
	glAttachShader(ProgramID_, VertexShaderID)
	glAttachShader(ProgramID_, FragmentShaderID)
	glLinkProgram(ProgramID_)

    // verifie la liaison
    Result = 0
    InfoLogLength = 0
    glGetProgramiv(ProgramID_, OGL.COMPILE_STATUS, @Result)
	glGetProgramiv(ProgramID_, OGL.INFO_LOG_LENGTH, @InfoLogLength)

    si InfoLogLength > 0 {
		ProgramErrorMessage := loge chaine(InfoLogLength+1)
		glGetProgramInfoLog(ProgramID_, InfoLogLength, nul, ProgramErrorMessage.pointeur)
		imprime_sans_format("!!!!! Erreur liaison : ProgramID", ProgramErrorMessage, '\n')
        déloge ProgramErrorMessage
	}

	glDetachShader(ProgramID_, VertexShaderID)
	glDetachShader(ProgramID_, FragmentShaderID)

	glDeleteShader(VertexShaderID)
	glDeleteShader(FragmentShaderID)

    retourne ProgramID_
}

initialise_tampon_dessin :: fonc() -> rien
{
    nonsûr {
		tabl_sommets = crée_tableau(transtype(taille_de(z32) : z64))
		tabl_couleur = crée_tableau(transtype(taille_de(z32) : z64))
        ProgramID = charge_programme()
    }

    glGenVertexArrays(1, @VertexArrayID)
    glGenBuffers(1, @vertexbuffer)
    glGenBuffers(1, @colorbuffer)
}

issitialise_tampon_dessin :: fonc() -> rien
{
    glDeleteVertexArrays(1, @VertexArrayID)
    glDeleteBuffers(1, @vertexbuffer)
    glDeleteBuffers(1, @colorbuffer)
    decrée_tableau(tabl_sommets)
    decrée_tableau(tabl_couleur)
    glDeleteProgram(ProgramID)
}

débute_dessin :: fonc() -> rien
{
    glBindVertexArray(VertexArrayID)
}

termine_dessin :: fonc() -> rien
{
    glUseProgram(ProgramID)

    glEnableVertexAttribArray(transtype(0 : n32))
    glBindBuffer(OGL.ARRAY_BUFFER, vertexbuffer)
	glBufferData(OGL.ARRAY_BUFFER, transtype(tabl_sommets.taille * taille_de(z32) : n64), tabl_sommets.tampon.pointeur, OGL.STATIC_DRAW)
    glVertexAttribPointer(transtype(0 : n32), 3, OGL.FLOAT, OGL.FALSE, 0, nul)

    glEnableVertexAttribArray(transtype(1 : n32))
    glBindBuffer(OGL.ARRAY_BUFFER, colorbuffer)
	glBufferData(OGL.ARRAY_BUFFER, transtype(tabl_couleur.taille * taille_de(z32) : n64), tabl_couleur.tampon.pointeur, OGL.STATIC_DRAW)
    glVertexAttribPointer(transtype(1 : n32), 4, OGL.FLOAT, OGL.FALSE, 0, nul)

    glDrawArrays(OGL.TRIANGLES, 0, tabl_sommets.taille / 3)
    glDisableVertexAttribArray(transtype(0 : n32))

    glUseProgram(transtype(0 : n32))

    nonsûr {
        tabl_sommets.taille = 0
        tabl_couleur.taille = 0
    }

    glBindVertexArray(transtype(0 : n32))
}

ajoute_sommet :: fonc(x : r32, y : r32, z : r32) -> rien
{
    pousse_tableau(tabl_sommets, @x)
    pousse_tableau(tabl_sommets, @y)
    pousse_tableau(tabl_sommets, @z)
}

Couleur :: struct {
    r : r32 = transtype(0.0 : r32)
    v : r32 = transtype(0.0 : r32)
    b : r32 = transtype(0.0 : r32)
    a : r32 = transtype(0.0 : r32)
}

ajoute_couleur :: fonc(coul : Couleur) -> rien
{
    pousse_tableau(tabl_couleur, @coul.r)
    pousse_tableau(tabl_couleur, @coul.v)
    pousse_tableau(tabl_couleur, @coul.b)
    pousse_tableau(tabl_couleur, @coul.a)
}

dessine_triangle :: fonc() -> rien
{
    débute_dessin()

	ajoute_sommet(transtype(-transtype(1.0 : r32) : r32), transtype(-transtype(1.0 : r32) : r32), transtype(0.0 : r32))
	ajoute_sommet( transtype(1.0 : r32), transtype(-transtype(1.0 : r32) : r32), transtype(0.0 : r32))
    ajoute_sommet( transtype(0.0 : r32),  transtype(1.0 : r32), transtype(0.0 : r32))

    termine_dessin()
}

dessine_carré_ex :: fonc(px : r32, py : r32, tx : r32, ty : r32, coul : Couleur) -> rien
{
    débute_dessin()

    min_x := px
    min_y := py
    max_x := px + tx
    max_y := py + ty

    ajoute_sommet(min_x, min_y, transtype(0.0 : r32))
    ajoute_couleur(coul)
    ajoute_sommet(max_x, min_y, transtype(0.0 : r32))
    ajoute_couleur(coul)
    ajoute_sommet(min_x, max_y, transtype(0.0 : r32))
    ajoute_couleur(coul)

    ajoute_sommet(max_x, min_y, transtype(0.0 : r32))
    ajoute_couleur(coul)
    ajoute_sommet(max_x, max_y, transtype(0.0 : r32))
    ajoute_couleur(coul)
    ajoute_sommet(min_x, max_y, transtype(0.0 : r32))
    ajoute_couleur(coul)

    termine_dessin()
}

dessine_carré :: fonc() -> rien
{
    couleur := Couleur{r = transtype(1.0 : r32), v = transtype(1.0 : r32), b = transtype(0.0 : r32), a = transtype(1.0 : r32) }
    dessine_carré_ex(transtype(-0.5 : r32), transtype(-0.5 : r32), transtype(1.0 : r32), transtype(1.0 : r32), couleur)
}

cos :: fonc externe (a : r32) -> r32
sin :: fonc externe (a : r32) -> r32

dessine_cercle :: fonc(cx : r32, cy : r32, rx : r32, ry : r32) -> rien
{
    débute_dessin()

    segs := 32
    dyn phi := transtype(0.0 : r32)
	dyn phi_delta := transtype(2.0 * 3.14159 / transtype(segs : r32) : r32)

    pour i dans 0...segs - 1 {
        ca0 := cx + cos(phi) * rx
        sa0 := cy + sin(phi) * ry

        ca1 := cx + cos(phi + phi_delta) * rx
        sa1 := cy + sin(phi + phi_delta) * ry

        ajoute_sommet(cx, cy, transtype(0.0 : r32))
        ajoute_sommet(ca0, sa0, transtype(0.0 : r32))
        ajoute_sommet(ca1, sa1, transtype(0.0 : r32))

        phi += phi_delta
    }

    termine_dessin()
}

dessine_quart_cercle :: fonc(cx : r32, cy : r32, rx : r32, ry : r32, quadrant : z32) -> rien
{
    débute_dessin()

    segs := 8
	dyn phi = transtype(quadrant : r32) * transtype((3.14159 / 2.0) : r32)
	dyn phi_delta = transtype(2.0 * 3.14159 / transtype(segs * 4 : r32) : r32)

    pour i dans 0...segs - 1 {
        ca0 := cx + cos(phi) * rx
        sa0 := cy + sin(phi) * ry

        ca1 := cx + cos(phi + phi_delta) * rx
        sa1 := cy + sin(phi + phi_delta) * ry

        ajoute_sommet(cx, cy, transtype(0.0 : r32))
        ajoute_sommet(ca0, sa0, transtype(0.0 : r32))
        ajoute_sommet(ca1, sa1, transtype(0.0 : r32))

        phi += phi_delta
    }

    termine_dessin()
}

dessine_rect_arrondi :: fonc(largeur : r32, hauteur : r32, arrondis_pixel : r32) -> rien
{
    rx := arrondis_pixel / largeur
    ry := arrondis_pixel / hauteur

	px : r32 = transtype(transtype(-transtype(1.0 : r32) : r32) + rx : r32)
	py : r32 = transtype(transtype(-transtype(1.0 : r32) : r32) + ry : r32)
    tx : r32 = transtype(2.0 - 2.0 * rx : r32)
    ty : r32 = transtype(2.0 - 2.0 * ry : r32)

    couleur := Couleur{r = transtype(1.0 : r32), v = transtype(1.0 : r32), b = 0.0, a = transtype(1.0 : r32) }

    // dessine centre
    dessine_carré_ex(px, py, tx, ty, couleur)

    // dessine rect gauche
    dessine_carré_ex(px - rx, py, rx, ty, couleur)

    // dessine rect droite
    dessine_carré_ex(px + tx, py, rx, ty, couleur)

    // dessine rect dessus
    dessine_carré_ex(px, py + ty, tx, ry, couleur)

    // dessine rect dessous
    dessine_carré_ex(px, py - ry, tx, ry, couleur)

    // dessine coin haut-gauche
    dessine_quart_cercle(px, py + ty, rx, ry, 1)

    // dessine coin haut-droite
    dessine_quart_cercle(px + tx, py + ty, rx, ry, 0)

    // dessine coin bas-gauche
    dessine_quart_cercle(px, py, rx, ry, 2)

    // dessine coin bas-droite
    dessine_quart_cercle(px + tx, py, rx, ry, 3)
}

dessine_bouton :: fonc() -> rien
{

}

dessine_image :: fonc() -> rien
{
    // crée texture

    // rempli UV
}
