#inclus "math.h"
#bib "m"

charge "glew"

importe "Fondation"

Couleur :: struct {
    r : r32 = 0.0
    v : r32 = 0.0
    b : r32 = 0.0
    a : r32 = 0.0
}

dyn VertexArrayID := transtype(0 : n32)
dyn ProgramID := transtype(0 : n32)
dyn vertexbuffer := transtype(0 : n32)
dyn colorbuffer := transtype(0 : n32)
dyn tabl_sommets : []r32
dyn tabl_couleur : []Couleur

charge_programme :: fonc() -> n32
{
    source_vertex := "
    #version 330 core
    layout(location = 0) in vec3 sommet;
    layout(location = 1) in vec4 couleurs;
    smooth out vec4 couleur;
    void main()
    {
        gl_Position.xyz = 2.0 * sommet - 1.0;
        gl_Position.w = 1.0;
        couleur = couleurs;
    }
    "

    source_fragment := "
    #version 330 core
    out vec4 couleur_fragment;
    smooth in vec4 couleur;
    void main()
    {
        couleur_fragment = couleur;
    }
    "

    // crée les nuanceurs
	VertexShaderID := glCreateShader(OGL.VERTEX_SHADER)
	FragmentShaderID := glCreateShader(OGL.FRAGMENT_SHADER)

    taille_src_vertex := transtype(source_vertex.taille : z32)
	glShaderSource(VertexShaderID, 1, @source_vertex.pointeur , @taille_src_vertex)
	glCompileShader(VertexShaderID)

    // verifie la compilation
    dyn Result : z32 = 0
    dyn InfoLogLength : z32 = 0
    glGetShaderiv(VertexShaderID, OGL.LINK_STATUS, @Result)
	glGetShaderiv(VertexShaderID, OGL.INFO_LOG_LENGTH, @InfoLogLength)

    si InfoLogLength > 0 {
		ProgramErrorMessage := loge chaine(InfoLogLength+1)
		glGetShaderInfoLog(VertexShaderID, InfoLogLength, nul, ProgramErrorMessage.pointeur)
		imprime_sans_format("!!!!! Erreur compilation : VertexShaderID", ProgramErrorMessage, '\n')
        déloge ProgramErrorMessage
	}

    taille_src_fragment := transtype(source_fragment.taille : z32)
	glShaderSource(FragmentShaderID, 1, @source_fragment.pointeur , @taille_src_fragment)
	glCompileShader(FragmentShaderID)

    // verifie la compilation
    Result = 0
    InfoLogLength = 0
    glGetShaderiv(FragmentShaderID, OGL.LINK_STATUS, @Result)
	glGetShaderiv(FragmentShaderID, OGL.INFO_LOG_LENGTH, @InfoLogLength)

    si InfoLogLength > 0 {
		ProgramErrorMessage := loge chaine(InfoLogLength+1)
		glGetShaderInfoLog(FragmentShaderID, InfoLogLength, nul, ProgramErrorMessage.pointeur)
		imprime_sans_format("!!!!! Erreur compilation : FragmentShaderID", ProgramErrorMessage, '\n')
        déloge ProgramErrorMessage
	}

    ProgramID_ := glCreateProgram()
	glAttachShader(ProgramID_, VertexShaderID)
	glAttachShader(ProgramID_, FragmentShaderID)
	glLinkProgram(ProgramID_)

    // verifie la liaison
    Result = 0
    InfoLogLength = 0
    glGetProgramiv(ProgramID_, OGL.COMPILE_STATUS, @Result)
	glGetProgramiv(ProgramID_, OGL.INFO_LOG_LENGTH, @InfoLogLength)

    si InfoLogLength > 0 {
		ProgramErrorMessage := loge chaine(InfoLogLength+1)
		glGetProgramInfoLog(ProgramID_, InfoLogLength, nul, ProgramErrorMessage.pointeur)
		imprime_sans_format("!!!!! Erreur liaison : ProgramID", ProgramErrorMessage, '\n')
        déloge ProgramErrorMessage
	}

	glDetachShader(ProgramID_, VertexShaderID)
	glDetachShader(ProgramID_, FragmentShaderID)

	glDeleteShader(VertexShaderID)
	glDeleteShader(FragmentShaderID)

    retourne ProgramID_
}

initialise_tampon_dessin :: fonc() -> rien
{
    nonsûr {
        ProgramID = charge_programme()
    }

    glGenVertexArrays(1, @VertexArrayID)
    glGenBuffers(1, @vertexbuffer)
    glGenBuffers(1, @colorbuffer)
}

issitialise_tampon_dessin :: fonc() -> rien
{
    glDeleteVertexArrays(1, @VertexArrayID)
    glDeleteBuffers(1, @vertexbuffer)
    glDeleteBuffers(1, @colorbuffer)
    déloge tabl_sommets
    déloge tabl_couleur
    glDeleteProgram(ProgramID)
}

débute_dessin :: fonc() -> rien
{
    glBindVertexArray(VertexArrayID)
}

_GL_INVALID_ENUM := transtype(0x0500: n32)
_GL_INVALID_VALUE := transtype(0x0501: n32)
_GL_INVALID_OPERATION := transtype(0x0502: n32)
_GL_INVALID_FRAMEBUFFER_OPERATION := transtype(0x0506: n32)

glGetError :: fonc externe () -> n32

vérifie_erreur :: fonc() -> rien
{
    erreur := glGetError()

	si erreur == transtype(0: n32) {
        retourne
	}

	imprime("erreur OpenGL !\n")

    discr erreur {
        _GL_INVALID_ENUM {
            imprime("-- énumération invalide\n")
        }
        _GL_INVALID_VALUE {
            imprime("-- valeur invalide\n")
        }
        _GL_INVALID_OPERATION {
            imprime("-- opération invalide\n")
        }
        _GL_INVALID_FRAMEBUFFER_OPERATION {
            imprime("-- opération invalide sur framebuffer\n")
        }
        sinon {
            imprime("-- erreur inconnue, code %\n", erreur)
        }
    }
}

termine_dessin :: fonc() -> rien
{
    glUseProgram(ProgramID)

    glEnableVertexAttribArray(transtype(0 : n32))
    glBindBuffer(OGL.ARRAY_BUFFER, vertexbuffer)
	glBufferData(OGL.ARRAY_BUFFER, transtype(tabl_sommets.taille : n64) * taille_de(z32), tabl_sommets.pointeur, OGL.STATIC_DRAW)
    glVertexAttribPointer(transtype(0 : n32), 3, OGL.FLOAT, OGL.FALSE, 0, nul)

    glEnableVertexAttribArray(transtype(1 : n32))
    glBindBuffer(OGL.ARRAY_BUFFER, colorbuffer)
	glBufferData(OGL.ARRAY_BUFFER, transtype(tabl_couleur.taille : n64) * taille_de(Couleur), tabl_couleur.pointeur, OGL.STATIC_DRAW)
    glVertexAttribPointer(transtype(1 : n32), 4, OGL.FLOAT, OGL.FALSE, 0, nul)

    glDrawArrays(OGL.TRIANGLES, 0, tabl_sommets.taille / 3)
    glDisableVertexAttribArray(transtype(0 : n32))

    glUseProgram(transtype(0 : n32))

    nonsûr {
        // À FAIRE : propriété « alloué »
        déloge tabl_sommets
        déloge tabl_couleur
    }

    glBindVertexArray(transtype(0 : n32))
}

ajoute_sommet :: fonc(x : r32, y : r32, z : r32) -> rien
{
    tableau_ajoute(@tabl_sommets, x)
    tableau_ajoute(@tabl_sommets, y)
    tableau_ajoute(@tabl_sommets, z)
}

ajoute_couleur :: fonc(coul : Couleur) -> rien
{
    tableau_ajoute(@tabl_couleur, coul)
}

dessine_triangle :: fonc() -> rien
{
    débute_dessin()

	ajoute_sommet(-1.0, -1.0, 0.0)
	ajoute_sommet( 1.0, -1.0, 0.0)
    ajoute_sommet( 0.0,  1.0, 0.0)

    termine_dessin()
}

dessine_carré_ex :: fonc(px : r32, py : r32, tx : r32, ty : r32, coul : Couleur) -> rien
{
    débute_dessin()

    min_x := px
    min_y := py
    max_x := px + tx
    max_y := py + ty

    ajoute_sommet(min_x, min_y, 0.0)
    ajoute_couleur(coul)
    ajoute_sommet(max_x, min_y, 0.0)
    ajoute_couleur(coul)
    ajoute_sommet(min_x, max_y, 0.0)
    ajoute_couleur(coul)

    ajoute_sommet(max_x, min_y, 0.0)
    ajoute_couleur(coul)
    ajoute_sommet(max_x, max_y, 0.0)
    ajoute_couleur(coul)
    ajoute_sommet(min_x, max_y, 0.0)
    ajoute_couleur(coul)

    termine_dessin()
}

dessine_carré :: fonc() -> rien
{
    couleur := Couleur{r = 1.0, v = 1.0, b = 0.0, a = 1.0 }
    dessine_carré_ex(-0.5, -0.5, 1.0, 1.0, couleur)
}

cos :: fonc externe (a : r32) -> r32
sin :: fonc externe (a : r32) -> r32

dessine_cercle :: fonc(cx : r32, cy : r32, rx : r32, ry : r32) -> rien
{
    débute_dessin()

    segs := 32
    dyn phi := 0.0
	dyn phi_delta := 2.0 * 3.14159 / transtype(segs : r32)

    pour i dans 0...segs - 1 {
        ca0 := cx + cos(phi) * rx
        sa0 := cy + sin(phi) * ry

        ca1 := cx + cos(phi + phi_delta) * rx
        sa1 := cy + sin(phi + phi_delta) * ry

        ajoute_sommet(cx, cy, 0.0)
        ajoute_sommet(ca0, sa0, 0.0)
        ajoute_sommet(ca1, sa1, 0.0)

        phi += phi_delta
    }

    termine_dessin()
}

dessine_quart_cercle :: fonc(cx : r32, cy : r32, rx : r32, ry : r32, quadrant : z32) -> rien
{
    débute_dessin()

    segs := 8
	dyn phi := transtype(quadrant : r32) * (3.14159 / 2.0)
	dyn phi_delta := 2.0 * 3.14159 / transtype(segs * 4 : r32)

    pour i dans 0...segs - 1 {
        ca0 := cx + cos(phi) * rx
        sa0 := cy + sin(phi) * ry

        ca1 := cx + cos(phi + phi_delta) * rx
        sa1 := cy + sin(phi + phi_delta) * ry

        ajoute_sommet(cx, cy, 0.0)
        ajoute_sommet(ca0, sa0, 0.0)
        ajoute_sommet(ca1, sa1, 0.0)

        phi += phi_delta
    }

    termine_dessin()
}

dessine_rect_arrondi :: fonc(largeur : r32, hauteur : r32, arrondis_pixel : r32) -> rien
{
    rx := arrondis_pixel / largeur
    ry := arrondis_pixel / hauteur

	px := -1.0 + rx
	py := -1.0 + ry
    tx := 2.0 - 2.0 * rx
    ty := 2.0 - 2.0 * ry

    couleur := Couleur{r = 1.0, v = 1.0, b = 0.0, a = 1.0 }

    // dessine centre
    dessine_carré_ex(px, py, tx, ty, couleur)

    // dessine rect gauche
    dessine_carré_ex(px - rx, py, rx, ty, couleur)

    // dessine rect droite
    dessine_carré_ex(px + tx, py, rx, ty, couleur)

    // dessine rect dessus
    dessine_carré_ex(px, py + ty, tx, ry, couleur)

    // dessine rect dessous
    dessine_carré_ex(px, py - ry, tx, ry, couleur)

    // dessine coin haut-gauche
    dessine_quart_cercle(px, py + ty, rx, ry, 1)

    // dessine coin haut-droite
    dessine_quart_cercle(px + tx, py + ty, rx, ry, 0)

    // dessine coin bas-gauche
    dessine_quart_cercle(px, py, rx, ry, 2)

    // dessine coin bas-droite
    dessine_quart_cercle(px + tx, py, rx, ry, 3)
}

dessine_bouton :: fonc() -> rien
{

}

dessine_image :: fonc() -> rien
{
    // crée texture

    // rempli UV
}
