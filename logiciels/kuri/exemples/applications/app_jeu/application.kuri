charge "evenements"
charge "glfw"
charge "glew"
charge "dessin_opengl"

importe Fondation

# À FAIRE : rendu texte, chargement image

################################################################################

# Puisqu'on ne peut pas passer de contexte aux méthodes de « file » via les
# fonctions de rappel, cette structure est spécialisée pour les file d'évènements.
struct FileÉvènement {
	tampon : []Évènement
	taille : z64
}

#!nulctx fonc crée_file() : *FileÉvènement
{
    dyn q = loge FileÉvènement
    retourne q
}

#!nulctx fonc decrée_file(dyn q : *FileÉvènement) : rien
{
	q.taille = 0
    déloge q.tampon
    déloge q
}

#!nulctx fonc enfile(dyn q : *FileÉvènement, évènement : Évènement) : rien
{
    si q.taille == q.tampon.taille {
		reloge q.tampon : [q.tampon.taille + 1]Évènement
    }

    index = q.taille
    q.tampon[index] = évènement
    q.taille += 1
}

#!nulctx fonc est_vide(q : *FileÉvènement) : bool
{
    retourne q.taille == 0
}

#!nulctx fonc défile(dyn q : *FileÉvènement) : Évènement
{
    dyn évènement : Évènement

    si est_vide(q) {
        retourne évènement
    }

    évènement = q.tampon[0]

    # réajuste la file en décalant les données

    si q.taille > 1 {
	    soit ptr_dst = @q.tampon[0]
		soit ptr_src = @q.tampon[1]
        copie_mem_nonsur(ptr_src, ptr_dst, transtype(taille_de(Évènement) : z64) * (q.taille - 1))
    }

    q.taille -= 1

    retourne évènement
}

################################################################################

dyn VG_file_évènements : *FileÉvènement = nul

#!nulctx fonc rappel_erreur(erreur : z32, desc : *z8) : rien
{
    # À FAIRE : imprime n'a pas de contexte.
    #soit chn = converti_chaine_c(desc);
    #imprime("Erreur ", erreur, " : ", chn, '\n');
}

#!nulctx fonc rappel_clavier(fenetre : *GLFWwindow, cle : type_cle, scancode : z32, action : z32, mods : type_mod) : rien
{
    #glfwSetWindowShouldClose(fenetre, 1);
    dyn évènement : Évènement

	si action == 1 {
		évènement.type = type_évènement.CLE_PRESSEE
	}
	sinon si action == 0 {
		évènement.type = type_évènement.CLE_RELACHEE
	}
	sinon si action == 2 {
		évènement.type = type_évènement.CLE_REPETEE
	}

    évènement.mods = mods
    évènement.cle = cle

    enfile(VG_file_évènements, évènement)
}

#!nulctx fonc rappel_bouton_souris(fenetre : *GLFWwindow, bouton : bouton_souris, action : z32, mods : type_mod) : rien
{
    dyn évènement : Évènement

    si action == 1 {
		évènement.type = type_évènement.SOURIS_PRESSEE
	}
	sinon si action == 0 {
		évènement.type = type_évènement.SOURIS_RELACHEE
	}

    évènement.mods = mods
    évènement.souris = bouton

    enfile(VG_file_évènements, évènement)
}

#!nulctx fonc rappel_position_souris(fenetre : *GLFWwindow, pos_x : r64, pos_y : r64) : rien
{
    dyn évènement : Évènement
    évènement.type = type_évènement.SOURIS_BOUGEE
    évènement.pos_x = pos_x
    évènement.pos_y = pos_y

    enfile(VG_file_évènements, évènement)
}

#!nulctx fonc rappel_roulette(fenetre : *GLFWwindow, delta_x : r64, delta_y : r64) : rien
{
    dyn évènement : Évènement
    évènement.type = type_évènement.SOURIS_ROULETTE
    évènement.delta_x = delta_x
    évènement.delta_y = delta_y

    enfile(VG_file_évènements, évènement)
}

#!nulctx fonc rappel_dimension(fenetre : *GLFWwindow, x : z32, y : z32) : rien
{
	glViewport(0, 0, x, y)

    dyn évènement : Évènement
    évènement.type = type_évènement.REDIMENSION
    évènement.delta_x = transtype(x : r64)
    évènement.delta_y = transtype(y : r64)

    enfile(VG_file_évènements, évènement)
}

################################################################################

soit TAILLE_TUILE = 32
soit TUILES_X = 20
soit TUILES_Y = 15

struct Entite {
    pos_x = TAILLE_TUILE * 10
    pos_y = TAILLE_TUILE * 7
}

################################################################################

struct Application {
    fenetre : *GLFWwindow = nul
    hauteur : z32 = 0
    largeur : z32 = 0
    souris_x = 0.0
    souris_y = 0.0
    dernier_évènement = type_évènement.NUL
    temps_double_clic : z64

    personnage : Entite
}

fonc initialise_opengl(app : &Application) : rien
{
    glfwMakeContextCurrent(app.fenetre)

    soit erreur = glewInit()

    si erreur != 0 {
        imprime("Erreur lors de l'initilisation de GLEW !\n")
    }

    initialise_tampon_dessin()

    glfwSwapInterval(1)
}

fonc dessine_fenetre(app : &Application) : rien
{
    glClear(0x00004000)

	glClearColor(transtype(0.5 : r32), transtype(0.5 : r32), transtype(1.0 : r32), transtype(1.0 : r32))

	soit l = transtype(app.largeur : r32)
	soit h = transtype(app.hauteur : r32)

    # dessine l'arrière plan

    # dessine les personnages
	soit taille_x = transtype(TAILLE_TUILE : r32) / transtype(TAILLE_TUILE * TUILES_X : r32)
	soit taille_y = transtype(TAILLE_TUILE : r32) / transtype(TAILLE_TUILE * TUILES_Y : r32)
	soit pos_x = transtype(app.personnage.pos_x : r32) / transtype(TAILLE_TUILE * TUILES_X : r32)
	soit pos_y = transtype(app.personnage.pos_y : r32) / transtype(TAILLE_TUILE * TUILES_Y : r32)

	soit couleur = Couleur{r = transtype(1.0 : r32), v = transtype(1.0 : r32), b = transtype(1.0 : r32), a = transtype(1.0 : r32) }

	dessine_carré_ex(pos_x, pos_y, taille_x, taille_y, couleur)

	glfwSwapBuffers(app.fenetre)
}

fonc traite_évènement(dyn app : &Application, évènement : Évènement) : rien
{
    #imprime(évènement, '\n');

    si évènement.type == type_évènement.REDIMENSION {
        app.largeur = transtype(évènement.delta_x : z32)
        app.hauteur = transtype(évènement.delta_y : z32)
    }

    si évènement.type == type_évènement.CLE_PRESSEE || évènement.type == type_évènement.CLE_REPETEE {
        si évènement.cle == type_cle.RIGHT {
            app.personnage.pos_x += TAILLE_TUILE

            # vérifie collision
            si app.personnage.pos_x >= app.largeur {
               app.personnage.pos_x = app.largeur - TAILLE_TUILE
            }
        }
        si évènement.cle == type_cle.UP {
            app.personnage.pos_y += TAILLE_TUILE

            # vérifie collision
            si app.personnage.pos_y >= app.hauteur {
               app.personnage.pos_y = app.hauteur - TAILLE_TUILE
            }
        }
        si évènement.cle == type_cle.LEFT {
            app.personnage.pos_x -= TAILLE_TUILE

            # vérifie collision
            si app.personnage.pos_x < 0 {
               app.personnage.pos_x = 0
            }
        }
        si évènement.cle == type_cle.DOWN {
            app.personnage.pos_y -= TAILLE_TUILE

            # vérifie collision
            si app.personnage.pos_y < 0 {
               app.personnage.pos_y = 0
            }
        }
    }
}

TEMPS_DOUBLE_CLIC_MS : z64 = 500

# Maximum, au cas où on laisse les utilisateurs renseigner le temps.
TEMPS_DOUBLE_CLIC_MS_MAX : z64 = 5000

fonc traite_évènements(dyn app : &Application) : rien
{
    tantque !est_vide(VG_file_évènements) {
        dyn évènement = défile(VG_file_évènements)

        # enregistrement de la position de la souris, car ceci n'est donnée
		# que pour les mouvements */
		si évènement.type == type_évènement.SOURIS_BOUGEE {
			app.souris_x = évènement.pos_x
			app.souris_y = évènement.pos_y
		}
		sinon si évènement.type != type_évènement.REDIMENSION {
			évènement.pos_x = app.souris_x
			évènement.pos_y = app.souris_y
		}

        # si souris relachée
		# -- si dernier évènement est souris pressée -> nous avons un clic, ignore
		# -- sinon -> nous avons une souris relachée
		# si souris cliquée
		# -- si dernier clic < TEMPS_DOUBLE_CLIC -> nous avons un double clic
		# Editrice::souris_clic() est toujours appelé quand la souris est cliquée
		# Editrice::double_clic() est appelé si un deuxième clic survient dans l'écart de temps défini
		# Editrice::souris_relachee() est appelé un autre évènement est survenu depuis le dernier clic
		#    par exemple : presse souris, tappe une lettre, relache souris

		si évènement.type == type_évènement.SOURIS_RELACHEE {
			si (app.dernier_évènement == type_évènement.SOURIS_PRESSEE) || (app.dernier_évènement == type_évènement.DOUBLE_CLIC) {
				continue
			}

			# traite l'évènement
		}
		sinon si évènement.type == type_évènement.SOURIS_PRESSEE {
			si (compte_ticks_ms() - app.temps_double_clic) <= TEMPS_DOUBLE_CLIC_MS {
				évènement.type = type_évènement.DOUBLE_CLIC
			}

			app.temps_double_clic = compte_ticks_ms()
		}

		traite_évènement(app, évènement)

		app.dernier_évènement = évènement.type
    }
}

fonc boucle_principale(app : &Application) : rien
{
    tantque glfwWindowShouldClose(app.fenetre) == 0 {
        # À FAIRE : l'impression de chaines contenant des caractères échappés
        # ont un déborderment de tampon car l'échappement est compté comme un
        # caractère en soi.
        imprime(app, '\n', '\n')
        imprime("Mémoire utilisée : ", mémoire_utilisée(), 'o', '\n', '\n')

	    glfwWaitEvents()

		traite_évènements(app)

        dessine_fenetre(app)
    }
}

fonc lance_application(dyn app : &Application) : z32
{
    si glfwInit() == 0 {
        imprime("Impossible d'initialiser GLFW !\n")
        retourne 1
    }

    # initialise la file d'évènements
    nonsûr {
        VG_file_évènements = crée_file()
    }

    dyn largeur : z32 = TAILLE_TUILE * TUILES_X
    dyn hauteur : z32 = TAILLE_TUILE * TUILES_Y

    #dyn donnees_moniteur = transtype(glfwGetVideoMode(glfwGetPrimaryMonitor()) : *DonneesMoniteur);

    #si donnees_moniteur != nul {
    #    largeur = donnees_moniteur.largeur;
    #    hauteur = donnees_moniteur.hauteur;
    #}

    #imprime(mémoire(donnees_moniteur), '\n');

    soit titre = "Créathèque"

    glfwWindowHint(CONTEXT_GLFW_VERSION_MAJOR, 4)
    glfwWindowHint(CONTEXT_GLFW_VERSION_MINOR, 0)
    soit fenetre = glfwCreateWindow(largeur, hauteur, titre.pointeur, nul, nul)

    si fenetre == nul {
        imprime("Impossible d'initialiser la fenêtre !\n")
        glfwTerminate()
        retourne 1
    }

    glfwSetKeyCallback(fenetre, rappel_clavier)
	glfwSetCursorPosCallback(fenetre, rappel_position_souris)
	glfwSetMouseButtonCallback(fenetre, rappel_bouton_souris)
	glfwSetScrollCallback(fenetre, rappel_roulette)
	# Décommente pour activer le redimensionnement
	#glfwSetWindowSizeCallback(fenetre, rappel_dimension);

    # initialise l'application
    app.fenetre = fenetre
    app.hauteur = hauteur
    app.largeur = largeur

    initialise_opengl(app)

    boucle_principale(app)

    issitialise_tampon_dessin()

    decrée_file(VG_file_évènements)

    glfwDestroyWindow(fenetre)

    glfwTerminate()

    retourne 0
}
