ivec3 :: struct {
    x : z32
    y : z32
    z : z32
}

ivec4 :: struct {
    x : z32
    y : z32
    z : z32
    w : z32
}

atlas_texture :: struct {
    noeuds : []ivec3
    utilise : z32
    largeur : z32
    hauteur : z32
    profondeur : z32
    id : z32
    donnees : []octet
}

pousse :: fonc(dyn tabl : *[]ivec3, val : ivec3) -> rien
{
    reloge tabl : []ivec3 (tabl.taille + 1)
    tabl[tabl.taille - 1] = val
}

crée_atlas_texture :: fonc(largeur : z32, hauteur : z32, profondeur : z32) -> *atlas_texture
{
    dyn atlas = loge atlas_texture

    // À FAIRE : assertion
    // assert((profondeur == 1) || (profondeur == 3) || (profondeur == 4));

    si atlas == nul {
        // À FAIRE : erreur
        retourne nul
    }

    atlas.utilise = 0
    atlas.largeur = largeur
    atlas.hauteur = hauteur
    atlas.profondeur = profondeur
    atlas.id = 0

    noeud := ivec3{ x = 1, y = 1, z = largeur - 2 }
    pousse(@atlas.noeuds, noeud)

    atlas.donnees = loge []octet (largeur * profondeur * hauteur)

    retourne atlas
}

décree_atlas_texture :: fonc(atlas : *atlas_texture) -> rien
{
    déloge atlas.noeuds
    déloge atlas.donnees
    déloge atlas
}

texture_atlas_set_region :: fonc(
    texture_atlas_t * atlas,
                          const size_t x,
                          const size_t y,
                          const size_t largeur,
                          const size_t hauteur,
                          const unsigned char * data,
                          const size_t stride ) -> rien
{
    // assert( atlas );
    // assert( x > 0);
    // assert( y > 0);
    // assert( x < (atlas->largeur-1));
    // assert( (x + largeur) <= (atlas->largeur-1));
    // assert( y < (atlas->hauteur-1));
    // assert( (y + hauteur) <= (atlas->hauteur-1));

    // prevent copying data from undefined position
    // and prevent memcpy's undefined behavior when count is zero
    // assert(hauteur == 0 || (data != NULL && largeur > 0));

    depth := atlas->depth
    charsize := sizeof(char)

    pour i dans 0 ... hauteur - 1 {
        memcpy( atlas->data+((y+i)*atlas->largeur + x ) * charsize * depth,
                data + (i*stride) * charsize, largeur * charsize * depth  )
    }
}

texture_atlas_fit :: fonc(
    atlas : *texture_atlas_t,
    index : z32,
    largeur : z32,
    hauteur : z32) -> z32
{
    // assert( atlas );

    dyn noeud = atlas.noeuds[index]
    dyn x = noeud.x
    dyn y = noeud.y
    dyn largeur_restante = largeur

    si ((x + largeur) > (atlas.largeur - 1)) {
        retourne -1
    }

    dyn y = noeud.y
    dyn i = index

    tantque largeur_restante > 0 {
        noeud = atlas.noeuds[i]

        si (noeud.y > y) {
            y = noeud.y
        }

        si ((y + hauteur) > (atlas.hauteur - 1)) {
            retourne -1
        }

        largeur_restante -= noeud.z
        i += 1
    }

    retourne y
}

texture_atlas_merge :: fonc(atlas : *atlas_texture) -> rien
{
	// assert(atlas);

	pour i dans 0 ... atlas.noeuds.taille - 2 {
		noeud := atlas.noeuds[i]
		suiv  := atlas.noeuds[i + 1]

		si noeud.y == suiv.y {
			noeud.z += suiv.z
			tableau_efface(atlas.noeuds, i + 1) // À FAIRE
			i -= 1
		}
	}
}

texture_atlas_get_region :: fonc(
    atlas : *atlas_texture,
    largeur : z32,
    hauteur : z32) -> ivec4
{
    // assert( atlas );

    dyn meilleur_hauteur := (1 << 31) // À FAIRE UINT_MAX
    dyn meilleur_largeur := (1 << 31) // À FAIRE UINT_MAX
    dyn meilleur_index   := -1

    pour noeud, i dans atlas.noeuds {
        y := texture_atlas_fit(atlas, i, largeur, hauteur)

        si y < 0 {
            continue
        }

        noeud = (ivec3 *) vector_get( atlas->noeuds, i )
        si( ( (y + hauteur) < meilleur_hauteur ) ||
            ( ((y + hauteur) == meilleur_hauteur) && (0 <= noeud.z && noeud.z < meilleur_largeur)) )
        {
            meilleur_hauteur = y + hauteur
            meilleur_index = i
            meilleur_largeur = noeud.z
            region.x = noeud.x
            region.y = y
        }
    }

    si meilleur_index == -1 {
        region.x = -1
        region.y = -1
        region.largeur = 0
        region.hauteur = 0
        retourne region
    }

    dyn noeud : ivec3
    noeud.x = region.x
    noeud.y = region.y + hauteur
    noeud.z = largeur
    vector_insert( atlas->noeuds, meilleur_index, noeud ) // À FAIRE

    pour i dans meilleur_index + 1 ... atlas.noeuds.taille  - 1 {
        noeud = atlas.noeuds[i]
        prev  = atlas.noeuds[i - 1]

        si noeud.x >= (prev.x + prev.z) {
            arrête
        }

        shrink := prev.x + prev.z - noeud.x
        noeud.x += shrink
        noeud.z -= shrink

        si noeud.z > 0 {
            arrête
        }

        vector_erase(atlas.noeuds, i)
        i -= 1
    }

    texture_atlas_merge(atlas)
    atlas.utilise += largeur * hauteur
    retourne region
}

texture_atlas_clear :: fonc(atlas : *atlas_texture) -> rien
{
    //assert(atlas);
    //assert(atlas.donnees);

    vector_clear(atlas->noeuds) // À FAIRE
    atlas.utilise = 0
    // We want a one pixel border around the whole atlas to avoid any artefact when
    // sampling texture
    noeud := ivec3{ x = 1, y = 1, z = atlas.largeur - 2 }

    pousse(atlas.noeuds, noeud)
    init_mem( atlas->data, 0, atlas->largeur*atlas->hauteur*atlas->depth )
}
