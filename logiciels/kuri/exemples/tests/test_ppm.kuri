importe Fondation
importe GlibC
importe Math
importe JPEG
importe SysFichier

Image :: struct {
    tampon : []octet
    chemin : chaine;
    hauteur : z32;
    largeur : z32;
    channels : z32;
}

génére_image_damier :: fonc() -> Image
{
    image : Image;
    image.largeur = 1024;
    image.hauteur = 1024;
    image.channels = 1;

    nombre_caracteres := image.largeur * image.hauteur;

    tampon := loge [nombre_caracteres]octet
    tampon.taille = nombre_caracteres

    taille_case := image.largeur / 8;

    image.tampon = tampon;

    idx := 0;

    pour i dans 0...image.largeur - 1 {
        pour j dans 0...image.hauteur - 1 {
            si (i / taille_case + j / taille_case) % 2 == 0 {
                tampon[idx] = 0;
            }
            sinon {
                tampon[idx] = 255;
            }

            idx += 1;
        }
    }

    retourne image;
}

génére_image_noire :: fonc() -> Image
{
    image : Image;
    image.largeur = 1024;
    image.hauteur = 1024;
    image.channels = 1;

    nombre_caracteres := image.largeur * image.hauteur;

    tampon := loge [nombre_caracteres]octet
    tampon.taille = nombre_caracteres

    taille_case := image.largeur / 8;

    image.tampon = tampon;

    pour v dans tampon {
        v = 0;
    }

    retourne image;
}

écris_ppm :: fonc(image : Image, chemin : chaine) -> rien
{
    fichier := tente ouvre_fichier_crée_si_non_existant(chemin, ÉCRITURE_SEULE) piège err {
        imprime("impossible d'ouvrir le fichier %\n", chemin)
        retourne
    }

    diffère { _ := ferme(*fichier) }

    entete := "P1";
    taille_x := image.largeur;
    taille_y := image.hauteur;

    enchaineuse : Enchaineuse
    initialise_enchaineuse(*enchaineuse)
    diffère { détruit_tampons(*enchaineuse) }

    imprime_dans_enchaineuse(*enchaineuse, "% % % ", entete, taille_x, taille_y)

    nombre_caracteres := taille_x * taille_y;

    tampon := loge chaine(nombre_caracteres);
    diffère { déloge tampon; }

    idx := 0;
    idx_image := 0;

    pour i dans 0...taille_x - 1 {
        pour j dans 0...taille_y - 1 {
            si image.tampon[idx_image] == 0 {
                tampon[idx] = '1'
            }
            sinon {
                tampon[idx] = '0'
            }

            idx_image += 1;
            idx += 1;
        }
    }

    imprime_dans_enchaineuse(*enchaineuse, "%", tampon);

    debut := maintenant_sec();
    __ := copie_enchaineuse_fichier(*enchaineuse, *fichier)
    delta := delta_sec(debut);
    imprime("Temps d'écriture = %s\n", delta);
}

écris_pnm :: fonc(image : Image, chemin : chaine) -> rien
{
    fichier := tente ouvre_fichier_crée_si_non_existant(chemin, ÉCRITURE_SEULE) piège err {
        imprime("impossible d'ouvrir le fichier %\n", chemin)
        retourne
    }

    diffère { _ := ferme(*fichier) }

    entete : chaine;

    discr image.channels {
        1 { entete = "P2"; }
        3 { entete = "P3"; }
        sinon {
            retourne
        }
    }

    taille_x := image.largeur;
    taille_y := image.hauteur;
    tampon_image := image.tampon;

    enchaineuse : Enchaineuse
    initialise_enchaineuse(*enchaineuse)
    diffère { détruit_tampons(*enchaineuse) }

    imprime_dans_enchaineuse(*enchaineuse, "% % % % ", entete, taille_x, taille_y, 255)

    nombre_caracteres := taille_x * taille_y * image.channels * 2;

    idx := 0;
    idx_image := 0;

    pour i dans 0...taille_x - 1 {
        pour j dans 0...taille_y - 1 {
            pour k dans 0 ... image.channels - 1 {
                ajoute_au_tampon(*enchaineuse, FormatEntier(valeur = tampon_image[idx_image + k], base = 10))
            }

            ajoute_au_tampon(*enchaineuse, " ")

            idx += image.channels + 1;
            idx_image += image.channels;
        }
    }

    debut := maintenant_sec();
    __ := copie_enchaineuse_fichier(*enchaineuse, *fichier)
    delta := delta_sec(debut);
    imprime("Temps d'écriture = %s\n", delta);
}

//####################

détruit_image :: fonc(image : *Image) -> rien
{
    déloge image.tampon;
}

lis_jpeg :: fonc(chemin : chaine) -> Image
{
    image : Image;
	ptr_tampon := chaine_c_temp(chemin);

    modes := "rb";

    file := fopen(ptr_tampon, modes.pointeur);
    diffère { fclose(file); }

    si file == nul {
        imprime("Ne peut ouvrir le fichier image...\n");
        retourne image;
    }

    erreur_jpeg : jpeg_error_mgr;
    info : jpeg_decompress_struct;

	jpeg_create_decompress(*info);
	info.err = jpeg_std_error(*erreur_jpeg);

	jpeg_stdio_src(*info, file);

	jpeg_save_markers(*info, 0xE1, 0xffff);

	jpeg_read_header(*info, 1);

	jpeg_start_decompress(*info);

    largeur := info.output_width comme z32;
	hauteur := info.output_height comme z32;
	channels := info.output_components comme z32;

	image.largeur = largeur;
	image.hauteur = hauteur;
	image.channels = channels;
	image.chemin = chemin;

	image.tampon = loge chaine(largeur * hauteur * channels);

	stride := largeur * channels;

    imprime("Hauteur = ", hauteur, '\n');
    imprime("Largeur = ", largeur, '\n');

	pour xi dans 0...hauteur - 1 {
        buffer := *image.tampon[xi * stride]
		jpeg_read_scanlines(*info, *buffer, 1);
	}

	jpeg_finish_decompress(*info);
	jpeg_destroy_decompress(*info);

    retourne image;
}

écris_jpeg :: fonc(image : Image, chemin : chaine) -> rien
{
	ptr_tampon := chaine_c_temp(chemin);

    modes := "wb";

    file := fopen(ptr_tampon, modes.pointeur);
    diffère { fclose(file); }

	//fseek(file, 0L, SEEK_SET);

	info : jpeg_compress_struct;
	jerr : jpeg_error_mgr;

	jpeg_create_compress(*info);
	info.err = jpeg_std_error(*jerr);

	jpeg_stdio_dest(*info, file);
	info.image_width = image.largeur comme n32;
	info.image_height = image.hauteur comme n32;
	info.input_components = image.channels;

	discr (info.input_components) {
		1 { info.in_color_space = _JCS_GRAYSCALE; }
		3 { info.in_color_space = _JCS_RGB; }
	}

	jpeg_set_defaults(*info);

    info.comp_info[0].h_samp_factor = 2;
    info.comp_info[0].v_samp_factor = 2;

	jpeg_set_quality(*info, 95, 0);
    jpeg_start_compress(*info, 1);

	stride := image.largeur * image.channels;

	pour x dans 0...image.hauteur - 1 {
        buffer := *image.tampon[x * stride]
		jpeg_write_scanlines(*info, *buffer, 1);
	}

	jpeg_finish_compress(*info);
	jpeg_destroy_compress(*info);
}

test_jpeg :: fonc() -> rien
{
    imprime("Entrée jpeg : mémoire utilisée : %o\n", mémoire_utilisée());

    image := lis_jpeg("/home/kevin/Images/59446046_185101052475540_1803696242081923072_n.jpg");

    chemin := "/home/kevin/test.pnm";
    écris_pnm(image, chemin);

    //imprime(image, '\n');

    imprime("Mémoire utilisée : %o\n", mémoire_utilisée());

    détruit_image(*image);
}

//####################

principale :: fonc () -> z32
{
    image := génére_image_damier();
    //ratisse_triangle(image, 0.25, 0.5, 0.5, 0.25, 0.5, 0.75);
 //  dessine_triangle(image, 0.25, 0.5, 0.5, 0.25, 0.5, 0.75);

    écris_ppm(image, "/home/kevin/test_p1.ppm");
    écris_pnm(image, "/home/kevin/test_p2.pgm");

    détruit_image(*image);

    //test_jpeg();

    diffère { imprime("Mémoire utilisée : %o\n", mémoire_utilisée()); }

    retourne 0;
}
