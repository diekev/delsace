importe Fondation
importe GlibC
importe Math
importe JPEG

Image :: struct {
    tampon : chaine; // À FAIRE : []octet
    chemin : chaine;
    hauteur : z32;
    largeur : z32;
    channels : z32;
}

ecris_fichier :: fonc(df : z32, chn : chaine) -> rien
{
    write(df, chn.pointeur, chn.taille);
}

imprime_fichier :: fonc(df : z32, args : ...eini) -> rien
{
    pour arg dans args {
	    imprime_valeur(df, arg.pointeur, arg.info, faux);
	}
}

génére_image_damier :: fonc() -> Image
{
    dyn image : Image;
    image.largeur = 1024;
    image.hauteur = 1024;
    image.channels = 1;

    nombre_caracteres = image.largeur * image.hauteur;

    dyn tampon := loge chaine(nombre_caracteres);

    taille_case := image.largeur / 8;

    image.tampon = tampon;

    dyn idx := 0;

    pour i dans 0...image.largeur - 1 {
        pour j dans 0...image.hauteur - 1 {
            si (i / taille_case + j / taille_case) % 2 == 0 {
                tampon[idx] = '0';
            }
            sinon {
                tampon[idx] = '1';
            }

            idx += 1;
        }
    }

    retourne image;
}

génére_image_noire :: fonc() -> Image
{
    dyn image : Image;
    image.largeur = 1024;
    image.hauteur = 1024;
    image.channels = 1;

    nombre_caracteres := image.largeur * image.hauteur;

    dyn tampon := loge chaine(nombre_caracteres);

    taille_case := image.largeur / 8;

    image.tampon = tampon;

    pour v dans tampon {
        v = 0;
    }

    retourne image;
}

dessine_ligne :: fonc(dyn image : &Image, x1 : z32, y1 : z32, x2 : z32, y2 : z32) -> rien
{
    dyn tampon := image.tampon;

    dyn dx := transtype(x2 - x1 : r32);
    dyn dy := transtype(y2 - y1 : r32);
    dyn pas : r32;

    si abs(dx) >= abs(dy) {
        pas = abs(dx);
    }
    sinon {
        pas = abs(dy);
    }

    dx /= pas;
    dy /= pas;
    dyn x := transtype(x1 : r32);
    dyn y := transtype(y1 : r32);
    dyn i : r32 = 1.0;

    tantque i <= pas {
        xi := transtype(x : z32);
        yi := transtype(y : z32);
        index = xi + yi * image.largeur;
        tampon[index] = 1;

        x += dx;
        y += dy;
        i += 1.0;
    }
}

dessine_triangle :: fonc(
    dyn image : &Image,
    x1 : r64,
    y1 : r64,
    x2 : r64,
    y2 : r64,
    x3 : r64,
    y3 : r64) -> rien
{
    ld := transtype(image.largeur - 1 : r64);
    hd := transtype(image.hauteur - 1 : r64);

    x1i := transtype(ld * x1 : z32);
    x2i := transtype(ld * x2 : z32);
    x3i := transtype(ld * x3 : z32);

    y1i := transtype(hd * y1 : z32);
    y2i := transtype(hd * y2 : z32);
    y3i := transtype(hd * y3 : z32);

    dessine_ligne(image, x1i, y1i, x2i, y2i);
    dessine_ligne(image, x2i, y2i, x3i, y3i);
    dessine_ligne(image, x3i, y3i, x1i, y1i);
}

// http://www.sunshine2k.de/coding/java/TriangleRasterization/TriangleRasterization.html

// Remplis un triangle qui pointe vers le haut avec une base horizontale :
//      /\
//     /  \
//     ----
remplis_triangle_bas_plat :: fonc(
    dyn image : &Image,
    v1 : Vec2r,
    v2 : Vec2r,
    v3 : Vec2r) -> rien
{
    ld := transtype(image.largeur - 1 : r64);
    hd := transtype(image.hauteur - 1 : r64);

    taille_pixel := 1.0 / min(ld, hd);

    cd1_inv := (v2.x - v1.x) / (v2.y - v1.y) * taille_pixel;
    cd2_inv := (v3.x - v1.x) / (v3.y - v1.y) * taille_pixel;

    dyn cur_x1 := v1.x;
    dyn cur_x2 := v1.x;

    y1 := transtype(v1.y * hd : z32);
    y2 := transtype(v2.y * hd : z32);

    restreint(y1, 0, image.hauteur - 1);
    restreint(y2, 0, image.hauteur - 1);

    dyn scanlineY := y1;

    tantque scanlineY <= y2 {
        x1i := transtype(cur_x1 * ld : z32);
        x2i := transtype(cur_x2 * ld : z32);

        restreint(x1i, 0, image.largeur - 1);
        restreint(x2i, 0, image.largeur - 1);

        dessine_ligne(image, x1i, scanlineY, x2i, scanlineY);

        cur_x1 += cd1_inv;
        cur_x2 += cd2_inv;

        scanlineY += 1;
    }
}

// Remplis un triangle qui pointe vers le bas avec une base horizontale :
//     ----
//     \  /
//      \/
remplis_triangle_haut_plat :: fonc(
    dyn image : &Image,
    v1 : Vec2r,
    v2 : Vec2r,
    v3 : Vec2r) -> rien
{
    ld := transtype(image.largeur - 1 : r64);
    hd := transtype(image.hauteur - 1 : r64);

    taille_pixel := 1.0 / ld;

    cd1_inv := (v3.x - v1.x) / (v3.y - v1.y) * taille_pixel;
    cd2_inv := (v3.x - v2.x) / (v3.y - v2.y) * taille_pixel;

    dyn cur_x1 := v3.x;
    dyn cur_x2 := v3.x;

    y1 := transtype(v1.y * hd : z32);
    y3 := transtype(v3.y * hd : z32);

    restreint(y1, 0, image.hauteur - 1);
    restreint(y3, 0, image.hauteur - 1);

    dyn scanlineY := y3;

    tantque scanlineY > y1 {
        x1i := transtype(cur_x1 * ld : z32);
        x2i := transtype(cur_x2 * ld : z32);

        restreint(x1i, 0, image.largeur - 1);
        restreint(x2i, 0, image.largeur - 1);

        dessine_ligne(image, x1i, scanlineY, x2i, scanlineY);

        cur_x1 -= cd1_inv;
        cur_x2 -= cd2_inv;
        scanlineY -= 1;
    }
}

échange :: fonc(dyn v1 : &Vec2r, dyn v2 : &Vec2r) -> rien
{
    échange(@v1.x, @v2.x);
    échange(@v1.y, @v2.y);
}

// Pour dessiner par ratissage un triangle quelconque, nous le divisons au besoin
// en deux triangles avec bases horizontales dont un pointe vers le haut et
// l'autre le bas :
//
//   /|
//  / |
// /__|
// \  |
//  \ |
//   \|
//
ratisse_triangle :: fonc(
    dyn image : &Image,
    x1 : r64,
    y1 : r64,
    x2 : r64,
    y2 : r64,
    x3 : r64,
    y3 : r64) -> rien
{
    v1 := Vec2r{ x = x1, y = y1 };
    v2 := Vec2r{ x = x2, y = y2 };
    v3 := Vec2r{ x = x3, y = y3 };

    boucle {
        si (v1.y) <= (v2.y) <= (v3.y) {
            arrête;
        }

        si v2.y < v1.y {
            échange(v1, v2);
        }

        si v3.y < v2.y {
            échange(v2, v3);
        }
    }

    si v2.y == v3.y {
        remplis_triangle_bas_plat(image, v1, v2, v3);
    }
    sinon si v1.y == v2.y {
        remplis_triangle_haut_plat(image, v1, v2, v3);
    }
    sinon {
        x4 := v1.x + ((v2.y - v1.y) / (v3.y - v1.y)) * (v3.x - v1.x);
        y4 := v2.y;

        v4 := Vec2r{ x = x4, y = y4 };

        remplis_triangle_bas_plat(image, v1, v2, v4);
        remplis_triangle_haut_plat(image, v2, v4, v3);
    }
}

écris_ppm :: fonc(image : Image, chemin : chaine) -> rien
{
    df := ouvre_fichier_ecriture(chemin);
    diffère { ferme_fichier(df); }

    si df == -1 {
        imprime_sans_format("Le fichier '", chemin, "' ne peut être ouvert", '\n');
        retourne;
    }

    imprime("Descripteur fichier : ", df, '\n');

    entete := "P1";
    taille_x := image.largeur;
    taille_y := image.hauteur;
    taille_case := taille_x / 8;

    imprime_fichier(df, entete, ' ', taille_x, ' ', taille_y, ' ');

    nombre_caracteres := taille_x * taille_y * 2;

    dyn tampon := loge chaine(nombre_caracteres);
    diffère { déloge tampon; }

    dyn idx := 0;
    dyn idx_image := 0;

    pour i dans 0...taille_x - 1 {
        pour j dans 0...taille_y - 1 {
            tampon[idx] = '0' + image.tampon[idx_image]
            tampon[idx + 1] = ' ';
            idx_image += 1;
            idx += 2;
        }
    }

    debut := maintenant_sec();

    imprime_fichier(df, tampon);

    delta := delta_sec(debut);

    imprime("Temps d'écriture = ", delta, "s", '\n');
}

écris_pnm :: fonc(image : Image, chemin : chaine) -> rien
{
    df := ouvre_fichier_ecriture(chemin);
    diffère { ferme_fichier(df); }

    si df == -1 {
        imprime_sans_format("Le fichier '", chemin,"' ne peut être ouvert", '\n');
        retourne;
    }

    imprime("Descripteur fichier PNM : ", df, '\n');

    dyn entete : chaine;

    discr image.channels {
        1 { entete = "P5"; }
        3 { entete = "P6"; }
    }

    taille_x := image.largeur;
    taille_y := image.hauteur;
    tampon_image := image.tampon;

    imprime_fichier(df, entete, ' ', taille_x, ' ', taille_y, ' ', 255, ' ');

    nombre_caracteres := taille_x * taille_y * image.channels;

    dyn tampon := loge chaine(nombre_caracteres);
    diffère { déloge tampon; }

    dyn idx := 0;
    dyn idx_image := 0;

    pour i dans 0...taille_x - 1 {
        pour j dans 0...taille_y - 1 {
            pour k dans 0 ... image.channels - 1 {
                tampon[idx + k] = tampon_image[idx_image + k];
            }

            idx += image.channels;
            idx_image += image.channels;
        }
    }

    debut := maintenant_sec();

    imprime_fichier(df, tampon);

    delta := delta_sec(debut);

    imprime("Temps d'écriture PNM = ", delta, "s", '\n');
}

//####################

détruit_image :: fonc(image : *Image) -> rien
{
    déloge image.tampon;
}

lis_jpeg :: fonc(chemin : chaine) -> Image
{
    dyn image : Image;
	ptr_tampon := chaine_c_temp(chemin);

    modes := "rb";

    file := fopen(ptr_tampon, modes.pointeur);
    diffère { fclose(file); }

    si file == nul {
        imprime_sans_format("Ne peut ouvrir le fichier image...", '\n');
        retourne image;
    }

    dyn erreur_jpeg : jpeg_error_mgr;
    dyn info : jpeg_decompress_struct;

	jpeg_create_decompress(@info);
	info.err = jpeg_std_error(@erreur_jpeg);

	jpeg_stdio_src(@info, file);

	jpeg_save_markers(@info, 0xE1, 0xffff);

	jpeg_read_header(@info, 1);

	jpeg_start_decompress(@info);

    largeur := transtype(info.output_width : z32);
	hauteur := transtype(info.output_height : z32);
	channels := transtype(info.output_components : z32);

	image.largeur = largeur;
	image.hauteur = hauteur;
	image.channels = channels;
	image.chemin = chemin;

	image.tampon = loge chaine(largeur * hauteur * channels);

	stride := largeur * channels;

    imprime("Hauteur = ", hauteur, '\n');
    imprime("Largeur = ", largeur, '\n');

	pour xi dans 0...hauteur - 1 {
        buffer := @image.tampon[xi * stride]
		jpeg_read_scanlines(@info, @buffer, 1);
	}

	jpeg_finish_decompress(@info);
	jpeg_destroy_decompress(@info);

    retourne image;
}

écris_jpeg :: fonc(image : Image, chemin : chaine) -> rien
{
	ptr_tampon := chaine_c_temp(chemin);

    modes := "wb";

    file := fopen(ptr_tampon, modes.pointeur);
    diffère { fclose(file); }

	//fseek(file, 0L, SEEK_SET);

	dyn info : jpeg_compress_struct;
	dyn jerr : jpeg_error_mgr;

	jpeg_create_compress(@info);
	info.err = jpeg_std_error(@jerr);

	jpeg_stdio_dest(@info, file);
	info.image_width = transtype(image.largeur : n32);
	info.image_height = transtype(image.hauteur : n32);
	info.input_components = image.channels;

	discr (info.input_components) {
		1 { info.in_color_space = _JCS_GRAYSCALE; }
		3 { info.in_color_space = _JCS_RGB; }
	}

	jpeg_set_defaults(@info);

    info.comp_info[0].h_samp_factor = 2;
    info.comp_info[0].v_samp_factor = 2;

	jpeg_set_quality(@info, 95, 0);
    jpeg_start_compress(@info, 1);

	stride := image.largeur * image.channels;

	pour x dans 0...image.hauteur - 1 {
        buffer := @image.tampon[x * stride]
		jpeg_write_scanlines(@info, @buffer, 1);
	}

	jpeg_finish_compress(@info);
	jpeg_destroy_compress(@info);
}

test_jpeg :: fonc() -> rien
{
    imprime_sans_format("Entrée jpeg : mémoire utilisée : ", mémoire_utilisée(), '\n');

    image := lis_jpeg("/home/kevin/Images/59446046_185101052475540_1803696242081923072_n.jpg");

    chemin := "/home/kevin/test.pnm";
    écris_pnm(image, chemin);

    //imprime(image, '\n');

    imprime_sans_format("Mémoire utilisée : ", mémoire_utilisée(), '\n');

    détruit_image(@image);
}

//####################

principale :: fonc(args : []*z8) -> z32
{
    image := génére_image_noire();
    ratisse_triangle(image, 0.25, 0.5, 0.5, 0.25, 0.5, 0.75);
 //  dessine_triangle(image, 0.25, 0.5, 0.5, 0.25, 0.5, 0.75);

    écris_ppm(image, "/home/kevin/test.ppm");

    détruit_image(@image);

    //test_jpeg();

    diffère { imprime_sans_format("Mémoire utilisée : ", mémoire_utilisée(), '\n'); }

    retourne 0;
}
