importe Compilatrice
importe Fondation

// les différentes instructions à implémenter
// -- constantes des tableaux
// -- tableaux globaux
// -- chaines globales

// À FAIRE : pas d'erreur de compilation quand nous avons plusieurs fonctions principales
// À FAIRE : bug dans la génération de code binaire pour les PositionCodeSource
// À FAIRE : trouve une bonne manière de sauvegarder et restaurer l'état des fonctions courante dans la ConstructriceRI pour éviter les bugs
lance_compilation :: fonc ()
{
    //ajoute_fichier_à_la_compilation("assertions.kuri")

    //options := compilatrice_obtiens_options()
    //options.crée_exécutable = faux

    boucle {
        message := compilatrice_attend_message()

        si !message {
            imprime("Arrêt de la boucle car message est nul !\n")
            arrête
        }

        discr message.genre {
            INVALIDE {
                imprime("Le message est invalide !\n")
            }
            FICHIER_OUVERT {
                // message_fichier := message comme *MessageFichier
                // imprime("Ouverture du fichier : %\n", message_fichier.chemin)
            }
            FICHIER_FERMÉ {
                // message_fichier := message comme *MessageFichier
                // imprime("Fermeture du fichier : %\n", message_fichier.chemin)
            }
            MODULE_OUVERT {
                // message_fichier := message comme *MessageFichier
                // imprime("Ouverture du module : %\n", message_fichier.chemin)
            }
            MODULE_FERMÉ {
                // message_fichier := message comme *MessageFichier
                // imprime("Fermeture du module : %\n", message_fichier.chemin)
            }
            FONCTION_TYPÉE {
                // message_fonction := message comme *MessageTypageFonctionTerminé
                // imprime("Une fonction fut typée : % !\n", message_fonction.nom)
            }
            STRUCTURE_TYPÉE {
                // message_type := message comme *MessageTypageTypeTerminé
                // imprime("Une structure fut typée : % !\n", message_type.nom)
            }
            COMPILATION_TERMINÉE {
                imprime("Compilation terminée !\n")
                arrête
            }
        }
    }

    enchaineuse : Enchaineuse
    initialise_enchaineuse(@enchaineuse)

    ajoute_au_tampon(@enchaineuse, "principale :: fonc () -> z32\n")
    ajoute_au_tampon(@enchaineuse, "{\n")
    ajoute_au_tampon(@enchaineuse, "    retourne 32\n")
    ajoute_au_tampon(@enchaineuse, "}\n")

    chn_principale := chaine_depuis_enchaineuse(@enchaineuse)

    ajoute_chaine_à_la_compilation(chn_principale)

    déloge chn_principale
}

#exécute lance_compilation()

test_transtype :: fonc ()
{
}

test_eini :: fonc ()
{
}

test_références :: fonc ()
{
}

// principale :: fonc () -> z32
// {
//     retourne 0
// }

/*

MessageFonctionTypée :: struct {
    empl base : Message

    nom : chaine
}

MessageStructureTypée :: struct {
    empl base : Message

    nom: chaine
}

compilatrice_attend_message :: fonc (espace: *EspaceDeTravail) -> *Message #nulctx
{
    retourne _RC.rappel_compilatrice_attent_message(espace)
}

EspaceDeTravail :: struct {
    nom : chaine
    id : z32
}

compilatrice_démarre_un_espace_de_travail :: fonc (nom: chaine) -> *EspaceDeTravail

*/
