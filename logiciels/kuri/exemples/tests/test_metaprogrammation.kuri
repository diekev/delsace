importe Compilatrice
importe Fondation

// les différentes instructions à implémenter
// -- constantes des tableaux
// -- tableaux globaux
// -- chaines globales

// À CONSIDÉRER : ajout d'une interface pour requerir l'arbre syntaxique au lieu de toujours le générer

converti_type_c :: fonc (info: *InfoType) -> chaine
{
    si info.id == id_info.ENTIER {
        si info.taille_en_octet == 1 {
            retourne "char"
        }
        sinon si info.taille_en_octet == 2 {
            retourne "short"
        }
        sinon si info.taille_en_octet == 4 {
            retourne "int"
        }
        sinon si info.taille_en_octet == 8 {
            retourne "long"
        }
    }

    retourne "type_inconnu"
}

converti_fonction_C :: fonc (code_fonction: *NoeudCodeCorpsFonction) -> chaine
{
    enchaineuse : Enchaineuse
    initialise_enchaineuse(@enchaineuse)

    imprime_dans_enchaineuse(@enchaineuse, "\nlong %", code_fonction.entête.nom)

    virgule := "("

    pour code_fonction.entête.params_entrée {
        imprime_dans_enchaineuse(@enchaineuse, "%long %", virgule, it.nom)
        virgule = ", "
    }

    ajoute_au_tampon(@enchaineuse, ")\n{\n")

    pour code_fonction.bloc.membres {
        imprime("-- membre : % %\n", converti_type_c(it.type), it.nom)
    }

    converti_code_c(@enchaineuse, code_fonction.bloc)

    ajoute_au_tampon(@enchaineuse, "}\n\n")

    retourne chaine_depuis_enchaineuse(@enchaineuse)
}

converti_code_c :: fonc (enchaineuse: *Enchaineuse, code: *NoeudCode)
{
    si code == nul {
        retourne
    }

    discr code.genre {
        DECLARATION_VARIABLE {
            code_déclaration := code comme *NoeudCodeDéclaration
            imprime_dans_enchaineuse(enchaineuse, "\tlong %;\n", code_déclaration.nom)
        }
        INSTRUCTION_SI {
            code_si := code comme *NoeudCodeSi

            ajoute_au_tampon(enchaineuse, "\tif condition {\n")
            converti_code_c(enchaineuse, code_si.bloc_si_vrai)
            ajoute_au_tampon(enchaineuse, "\t}\n")

            si code_si.bloc_si_faux {
                ajoute_au_tampon(enchaineuse, "\telse {\n")
                converti_code_c(enchaineuse, code_si.bloc_si_faux)
                ajoute_au_tampon(enchaineuse, "\t}\n")
            }

            ajoute_au_tampon(enchaineuse, "\n")
        }
        INSTRUCTION_COMPOSEE {
            bloc := code comme *NoeudCodeBloc

            pour bloc.expressions {
                converti_code_c(enchaineuse, it)
            }
        }
        INSTRUCTION_RETOUR {
            ajoute_au_tampon(enchaineuse, "return;")
        }
        INSTRUCTION_RETOUR_SIMPLE {
            code_retour := code comme *NoeudCodeOpérationUnaire
            ajoute_au_tampon(enchaineuse, "\t\treturn ")
            converti_code_c(enchaineuse, code_retour.opérande)
            ajoute_au_tampon(enchaineuse, ";\n")
        }
        INSTRUCTION_BOUCLE {
            code_boucle := code comme *NoeudCodeBoucle
            ajoute_au_tampon(enchaineuse, "\twhile (1) {\n")
            converti_code_c(enchaineuse, code_boucle.bloc)
            ajoute_au_tampon(enchaineuse, "\t}\n\n")
        }
        INSTRUCTION_TANTQUE {
            code_boucle := code comme *NoeudCodeBoucle
            ajoute_au_tampon(enchaineuse, "\twhile condition {\n")
            converti_code_c(enchaineuse, code_boucle.bloc)
            ajoute_au_tampon(enchaineuse, "\t}\n\n")
        }
        INSTRUCTION_REPETE {
            code_boucle := code comme *NoeudCodeBoucle
            ajoute_au_tampon(enchaineuse, "\tdo {\n")
            converti_code_c(enchaineuse, code_boucle.bloc)
            ajoute_au_tampon(enchaineuse, "\t} while condition;\n\n")
        }
        sinon {

        }
    }
}

lance_compilation :: fonc ()
{
    //espace := espace_défaut_compilation()
    //ajoute_fichier_à_la_compilation(espace, "assertions.kuri")

    //options := compilatrice_obtiens_options()
    //options.crée_exécutable = faux

    boucle {
        message := compilatrice_attend_message()

        si !message {
            imprime("Arrêt de la boucle car message est nul !\n")
            arrête
        }

        discr message.genre {
            INVALIDE {
                imprime("Le message est invalide !\n")
            }
            FICHIER_OUVERT {
                // message_fichier := message comme *MessageFichier
                // imprime("Ouverture du fichier : %\n", message_fichier.chemin)
            }
            FICHIER_FERMÉ {
                // message_fichier := message comme *MessageFichier
                // imprime("Fermeture du fichier : %\n", message_fichier.chemin)
            }
            MODULE_OUVERT {
                // message_fichier := message comme *MessageFichier
                // imprime("Ouverture du module : %\n", message_fichier.chemin)
            }
            MODULE_FERMÉ {
                // message_fichier := message comme *MessageFichier
                // imprime("Fermeture du module : %\n", message_fichier.chemin)
            }
            TYPAGE_CODE_TERMINÉ {
                message_fonction := message comme *MessageTypageCodeTerminé
                //imprime("Une fonction fut typée : % !\n", message_fonction.code.nom)

                code := message_fonction.code

                si code.genre == GenreNoeudCode.DECLARATION_CORPS_FONCTION {
                    code_fonction := code comme *NoeudCodeCorpsFonction
                    entête := code_fonction.entête
                    si entête.nom == "pgdc" {
                        code_c := converti_fonction_C(code_fonction)
                        imprime("%\n", code_c)
                        déloge code_c
                    }
                }
                sinon si code.genre == GenreNoeudCode.DECLARATION_STRUCTURE {
                    // type := code.type comme *InfoTypeStructure

                    // imprime("structure.nom = %\n", type.nom)

                    // pour type.membres {
                    //     imprime("membre structure : %\n", it.nom)
                    // }
                }
                sinon si code.genre == GenreNoeudCode.DECLARATION_ENUM {
                    // type := code.type comme *InfoTypeÉnum

                    // imprime("énum.nom = %\n", type.nom)

                    // pour type.noms {
                    //     imprime("-- %\n", it)
                    // }
                }
            }
            PHASE_COMPILATION {

            }
        }
    }

    génère_fonction_principale()
}

génère_fonction_principale :: fonc ()
{
    enchaineuse : Enchaineuse
    initialise_enchaineuse(@enchaineuse)

    ajoute_au_tampon(@enchaineuse, "principale :: fonc () -> z32\n")
    ajoute_au_tampon(@enchaineuse, "{\n")
    ajoute_au_tampon(@enchaineuse, "    retourne 32\n")
    ajoute_au_tampon(@enchaineuse, "}\n")

    chn_principale := chaine_depuis_enchaineuse(@enchaineuse)

    espace := espace_défaut_compilation()

    ajoute_chaine_à_la_compilation(espace, chn_principale)

    déloge chn_principale
}

#exécute lance_compilation()

test_transtype :: fonc ()
{
}

test_eini :: fonc ()
{
}

test_références :: fonc ()
{
}

// principale :: fonc () -> z32
// {
//     retourne 0
// }
