importe Compilatrice
importe Fondation

// À CONSIDÉRER : ajout d'une interface pour requerir l'arbre syntaxique au lieu de toujours le générer

converti_type_c :: fonc (info: *InfoType) -> chaine
{
    discr info.id {
        ENTIER {
            si info.taille_en_octet == 1 {
                retourne "char"
            }
            sinon si info.taille_en_octet == 2 {
                retourne "short"
            }
            sinon si info.taille_en_octet == 4 {
                retourne "int"
            }
            sinon si info.taille_en_octet == 8 {
                retourne "long"
            }
        }
        RÉEL {
            si info.taille_en_octet == 2 {
                retourne "half"
            }
            sinon si info.taille_en_octet == 4 {
                retourne "float"
            }
            sinon si info.taille_en_octet == 8 {
                retourne "double"
            }
        }
        BOOLÉEN {
            retourne "bool"
        }
        sinon {
            retourne "type_inconnu"
        }
    }

    retourne "type_inconnu"
}

converti_fonction_C :: fonc (code_fonction: *NoeudCodeCorpsFonction) -> chaine
{
    enchaineuse : Enchaineuse
    initialise_enchaineuse(*enchaineuse)

    imprime_dans_enchaineuse(*enchaineuse, "\nlong %", code_fonction.entête.nom)

    virgule := "("

    pour code_fonction.entête.params_entrée {
        imprime_dans_enchaineuse(*enchaineuse, "%long %", virgule, it.nom)
        virgule = ", "
    }

    ajoute_au_tampon(*enchaineuse, ")\n{\n")

    pour code_fonction.bloc.membres {
        imprime("-- membre : % %\n", converti_type_c(it.type), it.nom)
    }

    converti_code_c(*enchaineuse, code_fonction.bloc)

    ajoute_au_tampon(*enchaineuse, "}\n\n")

    retourne chaine_depuis_enchaineuse(*enchaineuse)
}

converti_code_c :: fonc (enchaineuse: *Enchaineuse, code: *NoeudCode)
{
    si code == nul {
        retourne
    }

    discr code.genre {
        DECLARATION_VARIABLE {
            code_déclaration := code comme *NoeudCodeDéclaration
            imprime_dans_enchaineuse(enchaineuse, "\tlong %;\n", code_déclaration.nom)
        }
        INSTRUCTION_SI {
            code_si := code comme *NoeudCodeSi

            ajoute_au_tampon(enchaineuse, "\tif condition {\n")
            converti_code_c(enchaineuse, code_si.bloc_si_vrai)
            ajoute_au_tampon(enchaineuse, "\t}\n")

            si code_si.bloc_si_faux {
                ajoute_au_tampon(enchaineuse, "\telse {\n")
                converti_code_c(enchaineuse, code_si.bloc_si_faux)
                ajoute_au_tampon(enchaineuse, "\t}\n")
            }

            ajoute_au_tampon(enchaineuse, "\n")
        }
        INSTRUCTION_COMPOSEE {
            bloc := code comme *NoeudCodeBloc

            pour bloc.expressions {
                converti_code_c(enchaineuse, it)
            }
        }
        INSTRUCTION_RETOUR {
            ajoute_au_tampon(enchaineuse, "return;")
        }
        INSTRUCTION_RETOUR_SIMPLE {
            code_retour := code comme *NoeudCodeOpérationUnaire
            ajoute_au_tampon(enchaineuse, "\t\treturn ")
            converti_code_c(enchaineuse, code_retour.opérande)
            ajoute_au_tampon(enchaineuse, ";\n")
        }
        INSTRUCTION_BOUCLE {
            code_boucle := code comme *NoeudCodeBoucle
            ajoute_au_tampon(enchaineuse, "\twhile (1) {\n")
            converti_code_c(enchaineuse, code_boucle.bloc)
            ajoute_au_tampon(enchaineuse, "\t}\n\n")
        }
        INSTRUCTION_TANTQUE {
            code_boucle := code comme *NoeudCodeBoucle
            ajoute_au_tampon(enchaineuse, "\twhile condition {\n")
            converti_code_c(enchaineuse, code_boucle.bloc)
            ajoute_au_tampon(enchaineuse, "\t}\n\n")
        }
        INSTRUCTION_REPETE {
            code_boucle := code comme *NoeudCodeBoucle
            ajoute_au_tampon(enchaineuse, "\tdo {\n")
            converti_code_c(enchaineuse, code_boucle.bloc)
            ajoute_au_tampon(enchaineuse, "\t} while condition;\n\n")
        }
        sinon {

        }
    }
}

// À FAIRE(langage) : compilation infinie si nous n'avons pas de message

fais_conversion_code :: fonc ()
{
    désactive_compilation_espace_défaut()

    options : OptionsCompilation
    espace := démarre_un_espace_de_travail("test_conversion", *options)

    compilatrice_commence_interception(espace)

    boucle {
        message := compilatrice_attend_message()

        discr message.genre {
            TYPAGE_CODE_TERMINÉ {
                message_fonction := message comme *MessageTypageCodeTerminé
                //imprime("Une fonction fut typée : % !\n", message_fonction.code.nom)

                code := message_fonction.code

                si code.genre == GenreNoeudCode.DECLARATION_CORPS_FONCTION {
                    code_fonction := code comme *NoeudCodeCorpsFonction
                    entête := code_fonction.entête
                    si entête.nom == "pgdc" {
                        code_c := converti_fonction_C(code_fonction)
                        imprime("%\n", code_c)
                        déloge code_c
                    }
                }
                sinon si code.genre == GenreNoeudCode.DECLARATION_STRUCTURE {
                    // type := code.type comme *InfoTypeStructure

                    // imprime("structure.nom = %\n", type.nom)

                    // pour type.membres {
                    //     imprime("membre structure : %\n", it.nom)
                    // }
                }
                sinon si code.genre == GenreNoeudCode.DECLARATION_ENUM {
                    // type := code.type comme *InfoTypeÉnum

                    // imprime("énum.nom = %\n", type.nom)

                    // pour type.noms {
                    //     imprime("-- %\n", it)
                    // }
                }
            }
            PHASE_COMPILATION {
                message_phase := message comme *MessagePhaseCompilation

                si message_phase.phase == PhaseCompilation.COMPILATION_TERMINÉE {
                    arrête
                }
            }
            sinon {
                continue
            }
        }
    }

    compilatrice_termine_interception(espace)
}

#exécute fais_conversion_code()
