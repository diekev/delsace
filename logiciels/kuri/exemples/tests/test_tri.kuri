
fonc partition(tableau : []z32, premier : z32, dernier : z32, pivot : z32) -> z32
{
	échange(@tableau[premier], @tableau[dernier]);

	variable j := premier;

	pour i dans premier...dernier - 1 {
		si tableau[i] <= tableau[dernier] {
			échange(@tableau[i], @tableau[j]);
		}
	}

	échange(@tableau[dernier], @tableau[j]);

	retourne j;
}

fonc tri_rapide(tableau : []z32, premier : z32, dernier : z32) -> rien
{
	si premier < dernier {
		dyn pivot := choix_pivot(tableau, premier, dernier);
		pivot = partition(tableau, premier, dernier, pivot);

		tri_rapide(tableau, premier, pivot - 1);
		tri_rapide(tableau, pivot + 1, dernier);
	}
}

struct Plage {
	premier : *z32;
	dernier : *z32;
}

fonc choix_pivot(plage : *Plage) -> *z32
{
	retourne avance(plage.premier, distance(plage) / 2);
}

fonc tri_rapide(plage : *Plage) -> rien
{
	si plage.premier < plage.dernier {
		dyn pivot := choix_pivot(plage);
		pivot = partition(plage, pivot);

		dyn plage1;
		plage1.premier = plage.premier;
		plage1.dernier = pivot - taille_de(z32);

		dyn plage2;
		plage2.premier = pivot + taille_de(z32);
		plage2.dernier = plage.dernier;

		tri_rapide(plage1);
		tri_rapide(plage2);
	}
}

struct GNASimple {
	z : z32;
	w : z32;
}

fonc construit_gna(graine : z32) -> GNASimple
{
	dyn gna_simple : GNASimple;
	gna_simple.z = graine;
	gna_simple.w = graine + 1;
	retourne gna_simple;
}

fonc nombre_aléatoire(variable gna_simple : *GNASimple) -> z32
{
	gna_simple.z = 36969 * (gna_simple.z & 655535) + (gna_simple.z >> 16);
	gna_simple.w = 36969 * (gna_simple.w & 655535) + (gna_simple.w >> 16);
	retourne (gna_simple.z << 16) + gna_simple.w;
}

fonc principale(compte : z32, arguments : **z8) -> z32
{
	dyn tableau : [1024]z32;

	gna_simple := construit_gna(5);

	pour i dans 0...1023 {
		tableau[i] = nombre_aléatoire(@gna_simple);
	}

	dyn plage : Plage;
	plage.premier = @tableau[0];
	plage.dernier = @tableau[1023];

	tri_rapide(@plage);

	retourne 0;
}
