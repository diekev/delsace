// À FAIRE : permet de préciser le ctx pour les fonctions avec contexte appelée dans des fonctions sans

// https://franckh.developpez.com/tutoriels/posix/pthreads/

importe Fondation
importe GlibC
importe PThread

//#####################################################################################

rand :: fonc externe () -> r64

sleep :: fonc externe (temps : z32) -> rien

strerror :: fonc externe (args : z32) -> *z8

//#####################################################################################

// Structure stockant les informations des threads clients et du magasin.
store_t :: struct {
   stock := 20

   thread_store : n64
   thread_clients : [5]n64

   mutex : pthread_mutex_t
   cond_clients : pthread_cond_t
   cond_store : pthread_cond_t
}

// Fonction pour tirer un nombre au sort entre 0 et max.
#nulctx get_random :: fonc(max : z32) -> z32
{
	dyn val : r64
	val = transtype(max : r64) * rand()
	val = val / (2147483647.0 + 1.0)

	retourne (transtype(val : z32))
}

// Fonction pour le thread du magasin.
#nulctx fn_store :: fonc(p_data : *rien) -> *rien
{
    dyn store := transtype(p_data : *store_t)

	boucle {
        pthread_mutex_lock(@store.mutex)
        pthread_cond_wait(@store.cond_store, @store.mutex)

		store.stock = 20
		printf("Remplissage du stock de %d articles !\n".pointeur, store.stock)

        pthread_cond_signal(@store.cond_clients)
        pthread_mutex_unlock(@store.mutex)
	}

	retourne nul
}

donnée_client_t :: struct {
    store : *store_t
    index : z32
}

// Fonction pour les threads des clients.
#nulctx fn_clients :: fonc(p_data : *rien) -> *rien
{
    donnée_client := transtype(p_data : *donnée_client_t)
    dyn store := donnée_client.store
	nb : z32 = donnée_client.index

	boucle {
		val : z32 = get_random(6)
		sleep((get_random(3)))

        pthread_mutex_lock(@store.mutex)

        si val > store.stock {
            pthread_cond_signal(@store.cond_store)
            pthread_cond_wait(@store.cond_clients, @store.mutex)
        }

		store.stock = store.stock - val

		printf("Client %d prend %d du stock, reste %d en stock !\n".pointeur, nb, val, store.stock)
        //printf("-- pthread_self() : %d\n".pointeur, pthread_getthreadid_np())

        pthread_mutex_unlock(@store.mutex)
	}

	retourne nul
}

ValeurSysConf :: énum z32 {
    _SC_NPROCESSORS_ONLN := 84
}

sysconf :: fonc externe (nom: ValeurSysConf) -> z64

nombre_threads_système :: fonc () -> z64
{
    retourne sysconf(ValeurSysConf._SC_NPROCESSORS_ONLN)
}

principale :: fonc () -> z32
{
    imprime("Il y a sur le système % threads\n", nombre_threads_système());

    //retourne 0

    dyn store := store_t{ stock = 20 }
	dyn ret : z32 = 0

	printf("Creation du thread du magasin !\n".pointeur)
	ret = pthread_create(@store.thread_store, nul, fn_store, @store)

	si ret == 0 {
        printf("Creation des threads clients !\n".pointeur)

        pour fil_client, idx dans store.thread_clients {
            dyn donnée_client : donnée_client_t
            donnée_client.store = @store
            donnée_client.index = idx
            ret = pthread_create(@fil_client, nul, fn_clients, @donnée_client)

            si ret != 0 {
                printf("erreur : %s".pointeur, strerror(ret))
            }
        }
	}
	sinon {
		printf("erreur : %s".pointeur, strerror(ret))
	}

    pour fil_client dans store.thread_clients {
		pthread_join(fil_client, nul)
	}

	pthread_join(store.thread_store, nul)

	retourne 0
}

