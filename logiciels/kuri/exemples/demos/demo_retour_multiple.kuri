importe "flux"

importe "structures"

// Problème : les fonctions chainées via '.' vont colésées avec les multiples types retours.

fonc externe ext_indirection1() -> z32

//##############################################################################

fonc ret_simple() -> z32
{
    si vrai {
        retourne 12987
    }
    sinon {
        retourne 129
    }
}

fonc indirection_simple() -> z32
{
    retourne ret_simple()
}

fonc test_fonction_ret_simple() -> rien
{
    imprime("---------------------------", '\n')
    imprime("fonc ret simple", '\n')

    a := indirection_simple()

    imprime("a = ", a, '\n')
}

fonc test_ptr_fonction_ret_simple() -> rien
{
    imprime("---------------------------", '\n')
    imprime("pointeur ret fonc simple", '\n')

    ptr := indirection_simple

    a := ptr()

    imprime("a = ", a, '\n')
}

corout coro_simple() -> z32
{
    pour i dans 0...10 {
        retiens i
    }
}

fonc test_coro_simple() -> rien
{
    imprime("---------------------------", '\n')
    imprime("coro simple", '\n')

    pour a dans coro_simple() {

     imprime("a = ", a, '\n')

    }
}

//##############################################################################

fonc ret_multiple() -> z32, bool
{
    retourne 1237, faux
}

fonc indirection() -> z32, bool
{
    retourne ret_multiple()
}

fonc test_fonction_ret_moult() -> rien
{
    imprime("---------------------------", '\n')
    imprime("fonc ret multiple", '\n')

    a, b := indirection()

    imprime("a = ", a, ", b = ", b, '\n')

    // ignore un paramètre

    // c = indirection();

    // imprime("c = ", c, '\n');
}

fonc appel_ptr_moult_ret() -> z32, bool
{
    ptr = indirection

    retourne ptr()
}

fonc test___(x : fonc(z32)z32, y : fonc(z32)(z32),z : fonc(z32)(z32,z32), w : z32) -> rien
{
}

fonc test_ptr_fonction_ret_moult() -> rien
{
    imprime("---------------------------", '\n')
    imprime("pointeur fonc ret multiple", '\n')

    x : fonc(z32)z32 = nul
    y : fonc(z32)(z32) = nul
    z : fonc(z32)(z32,z32) = nul

    test___(x, y, z, 90)

    a, b := appel_ptr_moult_ret()

    imprime("a = ", a, ", b = ", b, '\n')
}

//##############################################################################

corout coro_multiple() -> z32, bool
{
    pour i dans 0 ... 10 {
        retiens i * 3, (i % 3) == 0
    }
}

// À FAIRE : possibilité de retourner une coroutine
//corout coro_indirection() : z32, bool
//{
//    retourne coro_multiple();
//}

fonc test_coro_ret_moult() -> rien
{
    imprime("---------------------------", '\n')
    imprime("coro ret multiple", '\n')

    pour a, b, i dans coro_multiple() {
        imprime("a = ", a, ", b = ", b, ", i = ", i, '\n')
    }

    // ignore un paramètre

    // c = indirection();

    // imprime("c = ", c, '\n');
}

//##############################################################################

fonc principale(args : []*z8) -> z32
{
    test_fonction_ret_simple()
    test_ptr_fonction_ret_simple()
    test_coro_simple()

    test_fonction_ret_moult()
    test_ptr_fonction_ret_moult()
    test_coro_ret_moult()

    retourne 0
}
