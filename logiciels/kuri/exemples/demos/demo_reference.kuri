importe Fondation

FOO :: struct {
    a := 123
}

bar :: fonc(f : &FOO) -> rien
{
    f.a = 987
}

foo :: fonc(a : &z32) -> rien
{
    a = 7
}

échange :: fonc(a : &z32, b : &z32) -> rien
{
    tmp := a
    a = b
    b = tmp
}

principale :: fonc () -> z32
{
    a := 5
    imprime("a = %\n", a)

    foo(a)

    imprime("a = %\n", a)

    //#####################

    foo : FOO

    imprime("%\n", foo)

    bar(foo)

    imprime("%\n", foo)

    //#####################

    x := 123
    y := 456
    imprime("x = %, y = %\n", x, y)

    échange(x, y)
    imprime("x = %, y = %\n", x, y)

    //#####################

    z := 5
    w : &z32 = z

    imprime("z = %\n", z)

    w := 10

    imprime("z = %\n", z)

    //#####################

    retourne 0
}


// références :
// si assignation :
//    si dest est référence et src est référence -> assigne
//    si dest est référence et src n'est pas référence -> prend référence
//    si dest n'est pas référence et src est référence -> déréférence source
// si déclaration :
//    si dest est référence -> force la présence d'une expression
//    si dest est référence et src est référence -> assigne
//    si dest est référence et src n'est pas référence -> prend référence
//    si dest n'est pas référence et src est référence -> déréférence source
//    si dest n'a pas de type -> le type devient le type déréférencé
// si argument :
//    si dest est référence et src est référence -> assigne
//    si dest est référence et src n'est pas référence -> prend référence
//    si dest n'est pas référence et src est référence -> déréférence source
