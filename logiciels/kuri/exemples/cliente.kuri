importe "chaine"
importe "flux"
importe "memoire"
importe "uri"

################################################################################

#!inclus "netdb.h"
#!inclus "unistd.h"

soit _AF_INET = 2;
soit _SOCK_STREAM = 1;

struct externe hostent {
    h_name : *z8;
    h_aliases : **z8;
    h_addrtype : z32;
    h_length : z32;
    h_addr_list : **z8;
}

struct externe in_addr {
    s_addr : n32;
}

struct externe sockaddr {
    sa_family : n16;
    sa_data : [14]z8;
}

struct externe sockaddr_in {
    sin_family : n16;
    sin_port : n16;
    sin_addr : in_addr;
    sin_zero : [8]n8;
}

fonc externe gethostbyname(arg : *z8) : *hostent;

fonc externe socket(a : z32, b : z32, c : z32) : z32;

fonc externe htons(a : n16) : n16;

fonc externe close(a : z32) : z32;

fonc externe connect(prise : z32, addr : *sockaddr, taille : z64) : z32;

fonc externe recv(prise : z32, tampon : *z8, taille : n64, flags : z32) : z64;
fonc externe send(prise : z32, tampon : *rien, taille : n64, flags : z32) : z64;

################################################################################

fonc port_pour_uri(uri_ : &URI) : n16
{
    si uri_.port.taille == 0 {
        retourne 80
    }

    dyn résultat : n16 = 0

    pour c dans uri_.port {
        résultat = résultat * 10 + transtype(c - '0' : n16)
    }

    retourne résultat
}

fonc lance_requête(uri : &URI, requête : chaine) : chaine, z32
{
    dyn réponse : chaine;

    si !est_valide(uri) {
        imprime("L'uri est invalide !", '\n');
        retourne réponse, 1;
    }

    dyn tampon : [1024]z8;
    ptr_tampon = copie_chaine_c_tampon(tampon, hôte de uri);

    he = gethostbyname(ptr_tampon);

    si he == nul {
        imprime("Ne peut pas trouver les informations de l'hôte !", '\n');
        retourne réponse, 1;
    }

    prise = socket(_AF_INET, _SOCK_STREAM, 0);

    si prise == -1 {
        imprime("Ne peut pas créer la prise !", '\n');
        retourne réponse, 1;
    }

    diffère { close(prise); }

    port : n16 = port_pour_uri(uri);

    dyn their_addr : sockaddr_in;
    sin_family de their_addr = transtype(_AF_INET : n16);
    sin_port de their_addr = htons(port);
    their_addr.sin_zero[0]= 0;
    their_addr.sin_zero[1]= 0;
    their_addr.sin_zero[2]= 0;
    their_addr.sin_zero[3]= 0;
    their_addr.sin_zero[4]= 0;
    their_addr.sin_zero[5]= 0;
    their_addr.sin_zero[6]= 0;
    their_addr.sin_zero[7]= 0;

    x = he.h_addr_list[0];
    sin_addr de their_addr = mémoire(transtype(x : *in_addr));

    #imprime(their_addr, '\n');

    si connect(prise, transtype(@their_addr : *sockaddr), transtype(taille_de(sockaddr) : z64)) == -1 {
        imprime("Impossible de se connecter à la prise !", '\n');
        retourne réponse, 1;
    }

    #imprime("Connexion active", '\n');

    # envoie la requête

    si send(prise, pointeur de requête, transtype(taille de requête : n64), 0) == -1 {
		imprime("Ne peut pas envoyer la reqûete !", '\n');
        retourne réponse, 1;
    }

    # obtiens les données

    taille_max_données = 1024;

    boucle {
        taille_reçue = recv(prise, @tampon[0], transtype(taille_max_données : n64), 0);
        #imprime("Reçu paquet de taille ", taille_reçue, '\n');

        si taille_reçue > 0 {
            ancienne_taille = taille de réponse;
            reloge réponse : chaine(taille de réponse + taille_reçue);
            copie_mem_nonsur(src=@tampon[0], dst=@réponse[ancienne_taille], taille=taille_reçue);
        }
        sinon si taille_reçue == 0 {
            arrête;
        }
        sinon si taille_reçue == -1 {
            arrête;
        }
    }

    retourne réponse, 0
}

fonc principale(args : []*z8) : z32
{
    si args.taille != 2 {
        chn = converti_chaine_c(args[0])
        imprime_err("Utilisation : ", chn, " URL\n")
        retourne 1
    }

    # connecte vers la page
    chn = converti_chaine_c(args[1])
    uri = construit_uri(chn);

    si !est_valide(uri) {
        imprime("L'uri est invalide !", '\n');
        retourne 1;
    }

    #imprime(uri, '\n', '\n');

    constructrice = crée_constructrice_chaine()
    diffère { déloge constructrice.résultat; }

    pousse(constructrice, "GET ")
    pousse(constructrice, chemin de uri)
    pousse(constructrice, requête de uri)
    pousse(constructrice, " HTTP/1.1\r\n")
    pousse(constructrice, "Host:")
    pousse(constructrice, hôte de uri)
    pousse(constructrice, "\r\n")
    pousse(constructrice, "Accept-Encoding: identity\r\n")
    pousse(constructrice, "Accept-Charset: utf-8, iso-8859-1;q=0.5\r\n")
    pousse(constructrice, "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/ *;q=0.8\r\n")
    pousse(constructrice, "User-Agent: delsace\r\n")
    pousse(constructrice, "Connection: close\r\n")
    pousse(constructrice, "\r\n")

    requête = constructrice.résultat

    imprime("Reqûete envoyée :\n", requête, '\n');

    réponse, erreur = lance_requête(uri, requête)
    diffère { déloge réponse; }

    si erreur == 0 {
        imprime("Réponse :", '\n', réponse, '\n');
    }

    retourne 0;
}
