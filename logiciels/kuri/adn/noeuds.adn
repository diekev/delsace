// À FAIRE : des drapeaux en lieu et place des booléens (avec générations des opérateurs)
// À FAIRE : (opportunité) une parseuse pour lire et créer des arbres syntaxiques

énum GenreNoeud {
    // définis le type sous-jacent de l'énumération
    @type uint8_t
    // définis le type qui sera discriminé
    @discr NoeudExpression
    // les membre de l'énumération sont enlignés dans le type discriminé
    // c'est une erreur que de déclarer des membres ici
    @horslignée
}

struct Annotation {
    @code AnnotationCode

    chaine_statique nom [code]
    chaine_statique valeur [code]
}

struct NoeudExpression {
    @code NoeudCode
    // définis l'énumération qui devra être utilisée pour discriminé le noeud
    @discr GenreNoeud

    GenreNoeud genre [code]
    GenreValeur genre_valeur
    char aide_generation_code
    char _rembourrage
    DrapeauxNoeud drapeaux
    Lexeme const * lexème [code]
    IdentifiantCode * ident [code]
    Type * type [code]

    NoeudBloc * bloc_parent [copie]

    NoeudCode * noeud_code

    /* Pour la simplification de l'arbre syntaxique. */
    NoeudExpression * substitution
}

struct NoeudExpressionRéférenceType : NoeudExpression {
    @genre EXPRESSION_RÉFÉRENCE_TYPE
    @comme référence_type
    @code  NoeudCodeRéférenceType
    @genre_valeur DROITE
}

struct NoeudExpressionInfoDe : NoeudExpression {
    @genre EXPRESSION_INFO_DE
    @comme info_de
    @code  NoeudCodeInfoDe
    @genre_valeur DROITE

    NoeudExpression * expression [code enfant]
}

struct NoeudExpressionInitDe : NoeudExpression {
    @genre EXPRESSION_INIT_DE
    @comme init_de
    @code  NoeudCodeInitDe
    @genre_valeur DROITE

    NoeudExpression * expression [code enfant]
}

struct NoeudExpressionTailleDe : NoeudExpression {
    @genre EXPRESSION_TAILLE_DE
    @comme taille_de
    @code  NoeudCodeTailleDe
    @genre_valeur DROITE

    NoeudExpression * expression [code enfant]
}

struct NoeudExpressionTypeDe : NoeudExpression {
    @genre EXPRESSION_TYPE_DE
    @comme type_de
    @code  NoeudCodeTypeDe
    @genre_valeur DROITE

    NoeudExpression * expression [code enfant]
}

struct NoeudExpressionConstructionTableau : NoeudExpression {
    @genre EXPRESSION_CONSTRUCTION_TABLEAU
    @comme construction_tableau
    @code  NoeudCodeConstructionTableau
    @genre_valeur DROITE

    NoeudExpression * expression [code enfant]
}

struct NoeudExpressionExpansionVariadique : NoeudExpression {
    @genre EXPANSION_VARIADIQUE
    @comme expansion_variadique
    @code  NoeudCodeExpansionVariadique
    @genre_valeur DROITE

    NoeudExpression * expression [code enfant]
}

struct NoeudExpressionMémoire : NoeudExpression {
    @genre EXPRESSION_MÉMOIRE
    @comme mémoire
    @code  NoeudCodeMémoire
    @genre_valeur TRANSCENDANTALE

    NoeudExpression * expression [code enfant]
}

struct NoeudInstructionCharge : NoeudExpression {
    @genre INSTRUCTION_CHARGE
    @comme charge
    @code  NoeudCodeCharge
    @genre_valeur INVALIDE

    UniteCompilation * unité [préserve_accents]
    NoeudExpression * expression [code enfant]
}

struct NoeudInstructionArrête : NoeudExpression {
    @genre INSTRUCTION_ARRÊTE
    @comme arrête
    @code  NoeudCodeInstructionArrête
    @genre_valeur INVALIDE

    NoeudExpression *expression [code enfant]

    /* La boucle qui est controlée par cette instruction. */
    NoeudExpression *boucle_controlée [code]
}

struct NoeudInstructionContinue : NoeudExpression {
    @genre INSTRUCTION_CONTINUE
    @comme continue
    @code  NoeudCodeInstructionContinue
    @genre_valeur INVALIDE

    NoeudExpression *expression [code enfant]

    /* La boucle qui est controlée par cette instruction. */
    NoeudExpression *boucle_controlée [code]
}

struct NoeudInstructionReprends : NoeudExpression {
    @genre INSTRUCTION_REPRENDS
    @comme reprends
    @code  NoeudCodeInstructionReprends
    @genre_valeur INVALIDE

    NoeudExpression *expression [code enfant]

    /* La boucle qui est controlée par cette instruction. */
    NoeudExpression *boucle_controlée [code]
}

struct NoeudInstructionEmpl : NoeudExpression {
    @genre INSTRUCTION_EMPL
    @comme empl
    @code  NoeudCodeEmpl
    @genre_valeur INVALIDE

    NoeudExpression * expression [code enfant]
}

struct NoeudInstructionImporte : NoeudExpression {
    @genre INSTRUCTION_IMPORTE
    @comme importe
    @code  NoeudCodeImporte
    @genre_valeur INVALIDE

    UniteCompilation * unité [préserve_accents]
    NoeudExpression * expression [code enfant]
}

struct NoeudExpressionNonIntialisation : NoeudExpression {
    @genre INSTRUCTION_NON_INITIALISATION
    @comme non_initialisation
    @code  NoeudCodeNonInitialisation
    @genre_valeur DROITE
}

struct NoeudExpressionLittéraleNul : NoeudExpression {
    @genre EXPRESSION_LITTÉRALE_NUL
    @comme littérale_nul
    @code  NoeudCodeLittéraleNul
    @genre_valeur DROITE
}

struct NoeudExpressionLittéraleBool : NoeudExpression {
    @genre EXPRESSION_LITTÉRALE_BOOLÉEN
    @comme littérale_bool
    @code  NoeudCodeLittéraleBool
    @genre_valeur DROITE

    bool valeur [code copie]
}

struct NoeudExpressionLittéraleEntier : NoeudExpression {
    @genre EXPRESSION_LITTÉRALE_NOMBRE_ENTIER
    @comme littérale_entier
    @code  NoeudCodeLittéraleEntier
    @genre_valeur DROITE

    uint64_t valeur [code copie]
}

struct NoeudExpressionLittéraleRéel : NoeudExpression {
    @genre EXPRESSION_LITTÉRALE_NOMBRE_RÉEL
    @comme littérale_réel
    @code  NoeudCodeLittéraleRéel
    @genre_valeur DROITE

    double valeur [code copie]
}

struct NoeudExpressionLittéraleChaine : NoeudExpression {
    @genre EXPRESSION_LITTÉRALE_CHAINE
    @comme littérale_chaine
    @code  NoeudCodeLittéraleChaine
    @genre_valeur DROITE

    int64_t valeur [code copie]
}

struct NoeudExpressionLittéraleCaractère : NoeudExpression {
    @genre EXPRESSION_LITTÉRALE_CARACTÈRE
    @comme littérale_caractère
    @code  NoeudCodeLittéraleCaractère
    @genre_valeur DROITE

    uint32_t valeur [code copie]
}

struct NoeudDéclaration : NoeudExpression {
    @comme déclaration
    @code  NoeudCodeDéclaration
    @genre_valeur INVALIDE
}

struct NoeudModule : NoeudDéclaration {
    @genre DÉCLARATION_MODULE
    @comme déclaration_module
    @code  NoeudCodeModule
    @genre_valeur INVALIDE

    Module *module [code copie]
}

struct NoeudDéclarationSymbole : NoeudDéclaration {
    @comme déclaration_symbole
    @code  NoeudCodeDéclarationSymbole
    @genre_valeur INVALIDE

    NoeudDependance *noeud_dependance
    Atome *atome

    /* Pour les fonctions et globales externes :
     * - nom du symbole dans la bibliothèque
     * - la bibliothèque où se trouve le Symbole
     * - le symbole lui-même */
    chaine_statique nom_symbole
    IdentifiantCode *ident_bibliothèque
    Symbole *symbole

    VisibilitéSymbole visibilité_symbole [préserve_accents]
}

struct NoeudDéclarationBibliothèque : NoeudDéclarationSymbole {
    @comme déclaration_bibliothèque
    @code  NoeudCodeDéclarationBibliothèque
    @genre DÉCLARATION_BIBLIOTHÈQUE
    @genre_valeur INVALIDE

    UniteCompilation * unité [préserve_accents]
    Bibliothèque *bibliothèque
}

struct NoeudDéclarationVariable : NoeudDéclarationSymbole {
    @genre DÉCLARATION_VARIABLE
    @comme déclaration_variable
    @code  NoeudCodeDéclarationVariable
    @genre_valeur INVALIDE

    UniteCompilation * unité [préserve_accents]

    // pour une expression de style a := 5, a est la valeur, et 5 l'expression
    // pour une expression de style a, b := foo(7) , « a, b » est la valeur, et foo(7) l'expression
    NoeudExpression *valeur [code enfant]
    NoeudExpression *expression [code enfant]

    NoeudExpression *expression_type [code enfant]

    ValeurExpression valeur_expression

    NoeudDéclarationSymbole *declaration_vient_d_un_emploi
    int index_membre_employe

    // pour les variables globales
    NoeudExpression * [] arbre_aplatis

    DonneesAssignations [compressé] donnees_decl

    Annotation [] annotations [code copie]
}

struct NoeudAssignation : NoeudExpression {
    @genre EXPRESSION_ASSIGNATION_VARIABLE
    @comme assignation_variable
    @code  NoeudCodeAssignation
    @genre_valeur INVALIDE

    NoeudExpression *variable [code enfant]
    NoeudExpression *expression [code enfant]

    DonneesAssignations [compressé] donnees_exprs
}

struct NoeudRetour : NoeudExpression {
    @genre INSTRUCTION_RETOUR
    @comme retourne
    @code  NoeudCodeRetour
    @genre_valeur INVALIDE

    NoeudExpression *expression [code enfant]
    DonneesAssignations [compressé] donnees_exprs
}

struct NoeudRetiens : NoeudExpression {
    @genre INSTRUCTION_RETIENS
    @comme retiens
    @code  NoeudCodeRetiens
    @genre_valeur INVALIDE

    NoeudExpression *expression [code enfant]
    DonneesAssignations [compressé] donnees_exprs
}

struct NoeudExpressionReference : NoeudExpression {
    @genre EXPRESSION_RÉFÉRENCE_DÉCLARATION
    @comme référence_déclaration
    @code  NoeudCodeRéférenceDéclaration
    @genre_valeur INVALIDE

    NoeudDéclaration *déclaration_référée [copie]
}

struct NoeudExpressionUnaire : NoeudExpression {
    @genre OPÉRATEUR_UNAIRE
    @comme expression_unaire
    @code  NoeudCodeExpressionUnaire
    @genre_valeur DROITE

    NoeudExpression *opérande [code enfant]
    OpérateurUnaire const *op
}

struct NoeudExpressionBinaire : NoeudExpression {
    @genre OPÉRATEUR_BINAIRE
    @comme expression_binaire
    @code  NoeudCodeExpressionBinaire
    @genre_valeur DROITE

    NoeudExpression *opérande_gauche [code enfant]
    NoeudExpression *opérande_droite [code enfant]
    OpérateurBinaire const *op
    bool permute_operandes
}

struct NoeudExpressionComparaisonChainée : NoeudExpressionBinaire {
    @genre OPÉRATEUR_COMPARAISON_CHAINÉE
    @comme comparaison_chainée
    @code  NoeudCodeExpressionComparaisonChainée
    @genre_valeur DROITE
}

struct NoeudExpressionIndexage : NoeudExpressionBinaire {
    @genre EXPRESSION_INDEXAGE
    @comme indexage
    @code  NoeudCodeExpressionIndexage
    @genre_valeur TRANSCENDANTALE
}

struct NoeudExpressionParenthèse : NoeudExpression {
    @genre EXPRESSION_PARENTHÈSE
    @comme parenthèse
    @code  NoeudCodeParenthèse
    @genre_valeur TRANSCENDANTALE

    NoeudExpression *expression [code enfant]
}

struct NoeudExpressionPlage : NoeudExpression {
    @genre EXPRESSION_PLAGE
    @comme plage
    @code  NoeudCodeExpressionPlage
    @genre_valeur INVALIDE

    NoeudExpression *début [code enfant]
    NoeudExpression *fin [code enfant]
}

struct NoeudExpressionMembre : NoeudExpression {
    @genre EXPRESSION_RÉFÉRENCE_MEMBRE
    @comme référence_membre
    @code  NoeudCodeRéférenceMembre
    @genre_valeur TRANSCENDANTALE

    NoeudExpression *accédée [code enfant]

    /* Pour l'accès à des modules. */
    NoeudDéclaration *déclaration_référée [préserve_accents]
    /* Pour l'accès à des structures. */
    int index_membre
}

struct NoeudExpressionMembreUnion : NoeudExpressionMembre {
    @genre EXPRESSION_RÉFÉRENCE_MEMBRE_UNION
    @comme référence_membre_union
    @code  NoeudCodeRéférenceMembreUnion
    @genre_valeur INVALIDE
}

// À FAIRE(poly) : opérateurs polymorphiques
struct NoeudDéclarationEnteteFonction : NoeudDéclarationSymbole {
    @genre DÉCLARATION_ENTÊTE_FONCTION
    @comme entête_fonction
    @code  NoeudCodeEntêteFonction
    @genre_valeur DROITE

    UniteCompilation * unité [préserve_accents]
    NoeudDéclarationCorpsFonction *corps [code enfant]
    NoeudExpression * [] arbre_aplatis

    // Ceux-ci ne peuvent pas être des NoeudDéclarationVariables car la structure est partagée avec les types
    // qui utilisent des expressions simples comme paramètres
    NoeudExpression * [] params [code enfant]
    NoeudExpression * [] params_sorties [code enfant]

    /* La hiérarchie des blocs pour les fonctions est la suivante :
     * - bloc_constantes (qui contient les constantes déclarées pour les polymorphes)
     * -- bloc_parametres (qui contient la déclaration des paramètres d'entrées et de sorties)
     * --- bloc_corps (qui se trouve dans NoeudDéclarationCorpsFonction)
     */
    NoeudBloc *bloc_constantes [copie]
    NoeudBloc *bloc_parametres [copie]

    chaine_statique nom_broye_

    Monomorphisations *monomorphisations
    /* Le site où la première monomorphisation eu lieu, afin de pouvoir chercher les fonctions
     * dans le contexte du site. */
    NoeudExpression *site_monomorphisation

    Annotation [] annotations [code copie]

    DrapeauxNoeudFonction drapeaux_fonction;

    bool est_opérateur [code copie]
    bool est_coroutine [code copie]
    bool est_déclaration_type [copie]

    /* Le paramètre de sortie :
     * soit le paramètre déclaré pour les fonctions ne retournant qu'une seule valeur
     * soit une variable créée par la compilatrice pour les fonctions en retournant plusieurs; */
    NoeudDéclarationVariable *param_sortie [copie]

    /* Tous les symboles dans le bloc parent de celui-ci qui ont le même
     * identifiant. Ceci n'est mis en place que pour le premier symbole
     * du bloc à y être ajoutée comme membre, ce qui est dans l'ordre
     * lexical si ajoutée lors du syntaxage. */
    NoeudDéclarationSymbole * [synchrone] ensemble_de_surchages
}

struct NoeudDéclarationCorpsFonction : NoeudDéclarationSymbole {
    @genre DÉCLARATION_CORPS_FONCTION
    @comme corps_fonction
    @code  NoeudCodeCorpsFonction
    @genre_valeur INVALIDE

    UniteCompilation * unité [préserve_accents]
    NoeudDéclarationEnteteFonction *entête [code]
    NoeudBloc *bloc [code enfant]
    NoeudExpression * [] arbre_aplatis
    bool est_corps_texte [copie]

    /* Si le corps est un opérateur surchargé (macro) pour une boucle « pour »,
     * ceci pointe vers la boucle en question. */
    NoeudPour *est_macro_boucle_pour;
}

struct NoeudDéclarationOpérateurPour : NoeudDéclarationEnteteFonction {
    @genre DÉCLARATION_OPÉRATEUR_POUR
    @comme opérateur_pour
    @code  NoeudCodeOpérateurPour
    @genre_valeur INVALIDE
}

struct NoeudExpressionAppel : NoeudExpression {
    @genre EXPRESSION_APPEL
    @comme appel
    @code  NoeudCodeAppel
    @genre_valeur DROITE

    NoeudExpression * expression [code enfant]
    NoeudExpression * [] paramètres [code enfant]
    NoeudExpression * [] paramètres_résolus
    NoeudExpression const * noeud_fonction_appelée
    ÉtatRésolutionAppel * état_résolution_appel [préserve_accents]
}

struct NoeudExpressionConstructionStructure : NoeudExpressionAppel {
    @genre EXPRESSION_CONSTRUCTION_STRUCTURE
    @comme construction_structure
    @code  NoeudCodeConstructionStructure
    @genre_valeur DROITE
}

struct NoeudDéclarationType : NoeudDéclarationSymbole {
    @comme déclaration_type
    @code  NoeudCodeDéclarationType
    @genre_valeur DROITE

    UniteCompilation * unité [préserve_accents]

    /* Tous les symboles dans le bloc parent de celui-ci qui ont le même
     * identifiant. Ceci n'est mis en place que pour le premier symbole
     * du bloc à y être ajoutée comme membre, ce qui est dans l'ordre
     * lexical si ajoutée lors du syntaxage. */
    NoeudDéclarationSymbole * [synchrone] ensemble_de_surchages
}

struct NoeudStruct : NoeudDéclarationType {
    @genre DÉCLARATION_STRUCTURE
    @comme type_structure
    @code  NoeudCodeStructure
    @genre_valeur DROITE

    NoeudBloc *bloc [code enfant]
    NoeudExpression * [] arbre_aplatis

    bool est_union [copie]
    bool est_nonsure [copie]
    bool est_externe [copie]
    bool est_polymorphe [copie]
    bool est_monomorphisation
    bool est_corps_texte [copie]
    bool est_compacte [copie]

    uint32_t alignement_desire

    NoeudBloc *bloc_constantes [copie]
    NoeudExpression * [] arbre_aplatis_params

    /* Le polymorphe d'où vient cette structure, non-nul si monomorphe. */
    NoeudStruct *polymorphe_de_base

    Monomorphisations *monomorphisations

    MetaProgramme *metaprogramme_corps_texte

    Annotation [] annotations [code copie]
}

struct NoeudEnum : NoeudDéclarationType {
    @genre DÉCLARATION_ÉNUM
    @comme type_énum
    @code  NoeudCodeÉnum
    @genre_valeur DROITE

    NoeudExpression *expression_type [code enfant]
    NoeudBloc *bloc [code enfant]

    Annotation [] annotations [code copie]

    bool est_erreur [copie]
    bool est_énum_drapeau [copie préserve_accents]
}

struct NoeudDéclarationTypeOpaque : NoeudDéclarationType {
    @genre DÉCLARATION_OPAQUE
    @comme type_opaque
    @code  NoeudCodeTypeOpaque
    @genre_valeur DROITE

    NoeudExpression * [] arbre_aplatis
    NoeudExpression *expression_type [code enfant]
}

struct NoeudSi : NoeudExpression {
    @genre INSTRUCTION_SI
    @comme si
    @code NoeudCodeSi
    @genre_valeur INVALIDE

    NoeudExpression *condition [code enfant]
    NoeudExpression *bloc_si_vrai [code enfant]
    NoeudExpression *bloc_si_faux [code enfant]
}

struct NoeudSaufsi : NoeudSi {
    @genre INSTRUCTION_SAUFSI
    @comme saufsi
    @code NoeudCodeSaufsi
    @genre_valeur INVALIDE
}

struct NoeudSiStatique : NoeudExpression {
    @genre INSTRUCTION_SI_STATIQUE
    @comme si_statique
    @code  NoeudCodeSiStatique
    @genre_valeur INVALIDE

    NoeudExpression *condition [code enfant]
    NoeudBloc *bloc_si_vrai [code enfant]
    NoeudExpression *bloc_si_faux [code enfant]

    int index_bloc_si_faux
    int index_apres
    bool condition_est_vraie
    bool visite
}

struct NoeudSaufsiStatique : NoeudSiStatique {
    @genre INSTRUCTION_SAUFSI_STATIQUE
    @comme saufsi_statique
    @code NoeudCodeSaufsiStatique
    @genre_valeur INVALIDE
}

struct NoeudPour : NoeudExpression {
    @genre INSTRUCTION_POUR
    @comme pour
    @code  NoeudCodePour
    @genre_valeur INVALIDE

    NoeudExpression *variable [code enfant]
    NoeudExpression *expression [code enfant]
    NoeudBloc *bloc [code enfant]
    NoeudBloc *bloc_sansarret [code enfant]
    NoeudBloc *bloc_sinon [code enfant]

    bool prend_référence [copie]
    bool prend_pointeur [copie]
    GenreLexeme lexeme_op = .INFERIEUR [copie]

    /* Sauvegarde des déclarations pour « it » et « index_it », afin de ne pas
     * se soucier si ces variables sont implicites, et donc nommées
     * « it/index_it », ou non. */
    NoeudDéclarationVariable *decl_it;
    NoeudDéclarationVariable *decl_index_it;

    /* Le code du corps de l'opérateur surchargé « pour », utilisé lors de la
     * simplification de l'arbre. */
    NoeudDéclarationCorpsFonction *corps_opérateur_pour;
}

struct NoeudBoucle : NoeudExpression {
    @genre INSTRUCTION_BOUCLE
    @comme boucle
    @code  NoeudCodeBoucle
    @genre_valeur INVALIDE

    NoeudExpression *condition [code enfant]
    NoeudBloc *bloc [code enfant]

    /* pour la simplification du [code] des boucles pour */

    /* bloc utilisé pour définir les varibles d'itérations */
    NoeudBloc *bloc_pre

    /* bloc utilisé pour définir l'incrémentation des variables d'itérations,
    * cible de l'instruction « continue » des « pour » */
    NoeudBloc *bloc_inc

    /* blocs venant directement du bloc pour */
    NoeudBloc *bloc_sansarret
    NoeudBloc *bloc_sinon

    /* Pour le ciblage des instructions de controle. */
    InstructionLabel *label_pour_arrete
    InstructionLabel *label_pour_arrete_implicite
    InstructionLabel *label_pour_continue
    InstructionLabel *label_pour_reprends
}

struct NoeudRépète : NoeudBoucle {
    @genre INSTRUCTION_RÉPÈTE
    @comme répète
    @code  NoeudCodeRépète
    @genre_valeur INVALIDE
}

struct NoeudTantque : NoeudBoucle {
    @genre INSTRUCTION_TANTQUE
    @comme tantque
    @code  NoeudCodeTantque
    @genre_valeur INVALIDE
}

struct NoeudBloc : NoeudExpression {
    @genre INSTRUCTION_COMPOSÉE
    @comme bloc
    @code  NoeudCodeBloc
    @genre_valeur INVALIDE

    // NoeudExpression car NoeudPour ne dérive pas de NoeudBoucle
    NoeudExpression *appartiens_a_boucle [copie]
    // À FAIRE: utilisation de variant
    NoeudExpression *appartiens_a_differe [copie]
    NoeudDiscr *appartiens_à_discr [préserve_accents copie]
    /* Si le bloc est un bloc appartenant à une fonction (bloc constantes, paramètres, etc.). */
    NoeudDéclarationEnteteFonction *appartiens_à_fonction [préserve_accents copie]
    NoeudDéclaration * [synchrone] membres [code]
    NoeudExpression * [synchrone]  expressions [code enfant]
    NoeudInstructionDiffère * [] instructions_différées
    bool est_nonsur
    /* Pour le #GestionnaireCode afin de savoir si nous devons vérifier les
     * membres du bloc pour savoir s'il en reste à valider. */
    bool membres_sont_sales
    bool expressions_sont_sales
}

struct NoeudPaireDiscr : NoeudExpression {
    @genre EXPRESSION_PAIRE_DISCRIMINATION
    @comme paire_discr
    @code  NoeudCodePaireDiscr
    @genre_valeur INVALIDE

    NoeudExpression * expression [code enfant]
    NoeudBloc * bloc [code enfant]
    NoeudExpression * variable_capturée
}

struct NoeudDiscr : NoeudExpression {
    @genre INSTRUCTION_DISCR
    @comme discr
    @code  NoeudCodeDiscr
    @genre_valeur INVALIDE

    NoeudExpression *expression_discriminée [code enfant]
    NoeudPaireDiscr * [] paires_discr [code enfant]
    NoeudBloc *bloc [copie code enfant]
    NoeudBloc *bloc_sinon [code enfant]
    OpérateurBinaire const *op
}

struct NoeudDiscrÉnum : NoeudDiscr {
    @genre INSTRUCTION_DISCR_ÉNUM
    @comme discr_énum
    @code  NoeudCodeDiscrÉnum
    @genre_valeur INVALIDE
}

struct NoeudDiscrUnion : NoeudDiscr {
    @genre INSTRUCTION_DISCR_UNION
    @comme discr_union
    @code  NoeudCodeDiscrUnion
    @genre_valeur INVALIDE
}

struct NoeudPousseContexte : NoeudExpression {
    @genre INSTRUCTION_POUSSE_CONTEXTE
    @comme pousse_contexte
    @code  NoeudCodePousseContexte
    @genre_valeur INVALIDE

    NoeudExpression *expression [code enfant]
    NoeudBloc *bloc [code enfant]
}

struct NoeudTableauArgsVariadiques : NoeudExpression {
    @genre EXPRESSION_TABLEAU_ARGS_VARIADIQUES
    @comme args_variadiques
    @code  NoeudCodeArgsVariadiques
    @genre_valeur DROITE

    NoeudExpression * [] expressions [code enfant]
}

struct NoeudInstructionTente : NoeudExpression {
    @genre INSTRUCTION_TENTE
    @comme tente
    @code  NoeudIntructionTente
    @genre_valeur DROITE

    NoeudExpression *expression_appelée [code enfant]
    NoeudExpression *expression_piégée [code enfant]
    NoeudBloc *bloc [code enfant]
}

struct NoeudDirectiveExécute : NoeudExpression {
    @genre DIRECTIVE_EXÉCUTE
    @comme exécute
    @code  NoeudCodeDirectiveExécute
    @genre_valeur DROITE

    UniteCompilation * unité [préserve_accents]
    NoeudExpression *expression [code enfant]

    NoeudExpression * [] arbre_aplatis

    MetaProgramme *métaprogramme
}

struct NoeudDirectiveCuisine : NoeudDirectiveExécute {
    @genre DIRECTIVE_CUISINE
    @comme cuisine
    @code  NoeudCodeDirectiveCuisine
    @genre_valeur DROITE
}

/* Directive #corps_boucle. */
struct NoeudDirectiveCorpsBoucle : NoeudExpression {
    @genre DIRECTIVE_CORPS_BOUCLE
    @comme directive_corps_boucle
    @code  NoeudCodeDirectiveCorpsBoucle
    @genre_valeur INVALIDE
}

struct NoeudExpressionVirgule : NoeudExpression {
    @genre EXPRESSION_VIRGULE
    @comme virgule
    @code  NoeudCodeExpressionVirgule
    @genre_valeur TRANSCENDANTALE

    NoeudExpression * [] expressions [code enfant]
}

struct NoeudComme : NoeudExpression {
    @genre EXPRESSION_COMME
    @comme comme
    @code  NoeudCodeComme
    @genre_valeur DROITE

    NoeudExpression *expression [code enfant]
    NoeudExpression *expression_type [code enfant]
    TransformationType transformation
}

struct NoeudInstructionDiffère : NoeudExpression {
    @genre INSTRUCTION_DIFFÈRE
    @comme diffère
    @code  NoeudCodeDiffère
    @genre_valeur INVALIDE

    NoeudExpression *expression [code enfant]
}

struct NoeudDirectiveDépendanceBibliothèque : NoeudExpression {
    @genre DIRECTIVE_DÉPENDANCE_BIBLIOTHÈQUE
    @comme dépendance_bibliothèque
    @code  NoeudCodeDépendanceBibliothèque
    @genre_valeur INVALIDE

    UniteCompilation * unité [préserve_accents]
    NoeudExpressionReference *bibliothèque_dépendante [code enfant préserve_accents]
    NoeudExpressionReference *bibliothèque_dépendue [code enfant préserve_accents]
}

struct NoeudDirectiveAjouteInit : NoeudExpression {
    @genre DIRECTIVE_AJOUTE_INIT
    @comme ajoute_init
    @code NoeudCodeAjouteInit
    @genre_valeur INVALIDE

    UniteCompilation * unité [préserve_accents]
    NoeudExpression *expression [code enfant]
    NoeudExpression * [] arbre_aplatis
}

struct NoeudDirectiveAjouteFini : NoeudExpression {
    @genre DIRECTIVE_AJOUTE_FINI
    @comme ajoute_fini
    @code NoeudCodeAjouteFini
    @genre_valeur INVALIDE

    UniteCompilation * unité [préserve_accents]
    NoeudExpression *expression [code enfant]
    NoeudExpression * [] arbre_aplatis
}

struct NoeudDirectivePréExécutable : NoeudDirectiveExécute {
    @genre DIRECTIVE_PRÉ_EXÉCUTABLE
    @comme pré_exécutable
    @code NoeudCodePréExécutable
    @genre_valeur INVALIDE
}

/* Noeuds syntaxiques pour les directives #chemin_de_ce_fichier,
 * #chemin_de_ce_module, et #nom_de_cette_fonction. */
struct NoeudDirectiveIntrospection : NoeudExpression {
    @genre DIRECTIVE_INTROSPECTION
    @comme directive_instrospection
    @code NoeudCodeDirectiveIntrospection
    @genre_valeur DROITE
}
