/* ADN pour les fonctions intrinsèques. */

énum GenreIntrinsèque {
    // définis le type sous-jacent de l'énumération
    @type uint8_t
    // les membre de l'énumération sont enlignés dans le type discriminé
    // c'est une erreur que de déclarer des membres ici
    @horslignée
}

/* ------------------------------------------------------------------------- */
/** \name Controle du processeur.
* \{ */

/* Cette fonction est utilisée pour réinitialiser/vider le tampon d'instruction
 * du processeur dans la région entre début et fin exclusive. Certaines cibles
 * requierent que le tampon d'instructions soit vidé, après avoir modifié une
 * région de la mémoire contenant du code, afin d'obtenir une exécution
 * déterministe.
 * Si la cible de compilation ne requiers pas de réinitialisatoin du tampon
 * d'instruction, intrinsèque_réinitialise_tampon_instruction n'a aucun effet.
 * Sinon, soit des instructions sont émises en-ligne pour réinitialiser le
 * tampon, ou un appel à la fonction __clear_cache de GCC est performé.
 */
fonction intrinsèque_réinitialise_tampon_instruction(void *début, void *fin) -> void
@intrinsèque RÉINITIALISE_TAMPON_INSTRUCTION
@gcc __builtin___clear_cache


/* Valeur de temporalité pour intrinsèque_précharge. Détermine la durée de vie
 * de la mémoire chargé au sein du tampon. */
énum TemporalitéPréchargement {
    @type uint32_t

    /* La mémoire préchargée peut être évincée du tampon directement après
     * l'accès. */
    AUCUNE
    FAIBLE
    MODÉRÉE
    /* La mémoire préchargée doit être tenue dans tous les niveaux du tampon
     * possibles. */
    HAUTE
}

/* Raison pour laquelle une demande de préchargement de mémoire est faite. */
énum RaisonPréchargement {
    @type uint32_t

    /* Le préchargement est pour une lecture. */
    POUR_LECTURE
    /* Le préchargement est pour une écriture. */
    POUR_ÉCRITURE
}

/* Cette fonction est utilisée pour limiter les latences dues à des manquements
 * de tampon. Ceci précharge la mémoire se situant à l'adresse donnée, et peut
 * être utilisée si nous avons connaissance de l'adresse d'un bloc de mémoire
 * qui sera prochainement accédé. Si l'appel est fait suffisamment tôt, la
 * mémoire sera présent lors du prochain accès.
 *
 * Si une cible de compilation ne supporte pas des instructions de préchargement,
 * un appel à cette fonction ne fait rien.
 *
 * Les deuxièmes et troisièmes arguments doivent être des valeurs constantes,
 * c'est-à-dire des références directes aux membres de leur type d'énumération.
 *
 * À FAIRE : valeurs défaut.
 */
fonction intrinsèque_précharge(void *adresse, RaisonPréchargement raison, TemporalitéPréchargement temporalité) -> void
@intrinsèque PRÉCHARGE
@gcc __builtin_prefetch


/* Cette fonction est utilisée pour signifier au prédicteur de branches que nous
 * pensons que le résultat de `expression` aura la valeur `c`.
 *
 * La valeur de retour est celle de `expression`.
 *
 * Généralement, cette fonction ne devrait pas être utilisée, un profilage du
 * code devrait être préféré pour évaluer la performance du programme car les
 * programmeurs ne sont pas doués pour prédire l'exécution de leur code. Par
 * contre, il y a des cas où il est difficile d'obtenir cette information.
 *
 * À FAIRE : controle la probabilité avec l'option de compilation GCC builtin-expect-probability
 */
fonction intrinsèque_prédit(int64_t expression, int64_t c) -> int64_t
@intrinsèque PRÉDIT
@gcc __builtin_expect


/* Cette fonction est similaire à `intrinsèque_prédit` mais permet de donner
 * explicitement la probabilité que l'expression est vraie.
 *
 * Si l'intrinsèque est utilisée dans une boucle, la probabilité fourni
 * influencera le nombre escompté d'itérations faites par les optimisations de
 * boucles.
 *
 * L'argument `probabilité` doit être entre 0.0 et 1.0 inclusif et doit être
 * une constante.
 */
fonction intrinsèque_prédit_avec_probabilité(int64_t expression, int64_t c, double probabilité) -> int64_t
@intrinsèque PRÉDIT_AVEC_PROBABILITÉ
@gcc __builtin_expect_with_probability

/** \} */

/* ------------------------------------------------------------------------- */
/** \name Controle de flux.
* \{ */

/* Cette fonction provoque un arrêt abnormal du programme.
 *
 * Cette fonction est implémentée en utilisant un méchanisme dépendant de la
 * cible (par exemple en exécutant intentionnellemnt une instruction illégale)
 * ou en appelant `avorte`.
 *
 * Le méchanisme utilisé peut varier entre différentes versions et les
 * programmes ne devrait pas présumer ou dépendre d'un comportement particulier.
 */
fonction intrinsèque_piège() -> void
@intrinsèque PIÈGE
@gcc __builtin_trap


/* Si le controle de flux atteint le point de `intrinsèque_nonatteignable`, le
 * programme est indéfini.
 * C'est utile dans les cas où le compilateur ne peut déduire l'atteignabilité
 * du code.
 */
fonction intrinsèque_nonatteignable() -> void
@intrinsèque NONATTEIGNABLE
@gcc __builtin_unreachable

/** \} */

/* ------------------------------------------------------------------------- */
/** \name Enquête sur les bits.
* \{ */

/* Retourne un plus l'index du bit actif (1) le mois significatif de x, ou zéro
 * si x est égal à zéro.
 */
fonction intrinsèque_trouve_premier_actif(int32_t x) -> int32_t
@intrinsèque TROUVE_PREMIER_ACTIF_32
@gcc __builtin_ffs

fonction intrinsèque_trouve_premier_actif(int64_t x) -> int32_t
@intrinsèque TROUVE_PREMIER_ACTIF_64
@gcc __builtin_ffsl


/* Retourne le nombre de bits inactifs (0) en tête de x, en commençant par la
 * position du bit le plus significatif. Si x est 0, la résultat est indéfini.
 */
fonction intrinsèque_compte_zéros_en_tête(uint32_t x) -> int32_t
@intrinsèque COMPTE_ZÉROS_EN_TÊTE_32
@gcc __builtin_clz

fonction intrinsèque_compte_zéros_en_tête(uint64_t x) -> int32_t
@intrinsèque COMPTE_ZÉROS_EN_TÊTE_64
@gcc __builtin_clzl


/* Retourne le nombre de bits inactifs (0) en fin de x, en commençant par la
 * position du bit le moins significatif. Si x est 0, la résultat est indéfini.
 */
fonction intrinsèque_compte_zéros_en_fin(uint32_t x) -> int32_t
@intrinsèque COMPTE_ZÉROS_EN_FIN_32
@gcc __builtin_ctz

fonction intrinsèque_compte_zéros_en_fin(uint64_t x) -> int32_t
@intrinsèque COMPTE_ZÉROS_EN_FIN_64
@gcc __builtin_ctzl


/* Retourne le nombre de bits identiques au bit de signe, c-à-d le bit le plus
 * significatif, jusqu'au premier bit différent.
 * Il n'y a aucun cas spécial pour 0 ou d'autres valeurs.
 */
fonction intrinsèque_compte_redondance_bit_signe(int32_t x) -> int32_t
@intrinsèque COMPTE_REDONDANCE_BIT_SIGNE_32
@gcc __builtin_clrsb

fonction intrinsèque_compte_redondance_bit_signe(int64_t x) -> int32_t
@intrinsèque COMPTE_REDONDANCE_BIT_SIGNE_64
@gcc __builtin_clrsbl


/* Retourne le nombre de bits actifs de x. */
fonction intrinsèque_compte_bits_actifs(uint32_t x) -> int32_t
@intrinsèque COMPTE_BITS_ACTIFS_32
@gcc __builtin_popcount

fonction intrinsèque_compte_bits_actifs(uint64_t x) -> int32_t
@intrinsèque COMPTE_BITS_ACTIFS_64
@gcc __builtin_popcountl


/* Retourne la parité (paire ou impaire) du nombre de bits actifs de x. */
fonction intrinsèque_parité_bits(uint32_t x) -> int32_t
@intrinsèque PARITÉ_BITS_32
@gcc __builtin_parity

fonction intrinsèque_parité_bits(uint64_t x) -> int32_t
@intrinsèque PARITÉ_BITS_64
@gcc __builtin_parityl

/** \} */

/* ------------------------------------------------------------------------- */
/** \name Commutation boutisme.
* \{ */

/* Retourne x avec l'ordre de ses octets inversé; par exemple, 0xaabb devient
 * 0xbbaa. Un octet ici est égal à 8-bit. */
fonction intrinsèque_commute_octets(uint16_t x) -> uint16_t
@intrinsèque COMMUTE_OCTETS_16
@gcc __builtin_bswap16

fonction intrinsèque_commute_octets(uint32_t x) -> uint32_t
@intrinsèque COMMUTE_OCTETS_32
@gcc __builtin_bswap32

fonction intrinsèque_commute_octets(uint64_t x) -> uint64_t
@intrinsèque COMMUTE_OCTETS_64
@gcc __builtin_bswap64

/** \} */

/* ------------------------------------------------------------------------- */
/** \name Fonctions Kuri.
* \{ */

fonction intrinsèque_est_adresse_données_constantes(void *adresse) -> bool
@intrinsèque EST_ADRESSE_DONNÉES_CONSTANTES

/** \} */

/* ------------------------------------------------------------------------- */
/** \name Atomiques.
* \{ */

énum OrdreMémoire {
    @type int32_t

    /* Implies no inter-thread ordering constraints. */
    RELAXÉ

    /* This is currently implemented using the stronger __ATOMIC_ACQUIRE memory order because of a deficiency in C++11’s semantics for memory_order_consume. */
    CONSOMME

    /* Creates an inter-thread happens-before constraint from the release (or stronger) semantic store to this acquire load. Can prevent hoisting of code to before the operation. */
    ACQUIÈRE

    /* Creates an inter-thread happens-before constraint to acquire (or stronger) semantic loads that read from this release store. Can prevent sinking of code to after the operation. */
    RELÂCHE

    /* Combines the effects of both __ATOMIC_ACQUIRE and __ATOMIC_RELEASE. */
    ACQUIÈRE_RELÂCHE

    /* Enforces total ordering with all other __ATOMIC_SEQ_CST operations. */
    SEQ_CST
}

fonction atomique_barrière_fil(OrdreMémoire ordre_mémoire)
@intrinsèque ATOMIQUE_BARRIÈRE_FIL
@gcc __atomic_thread_fence

fonction atomique_donne_puis_ajoute(uint32_t *ptr, uint32_t val, OrdreMémoire ordre_mémoire) -> uint32_t
@intrinsèque ATOMIQUE_DONNE_PUIS_AJOUTE
@gcc __atomic_fetch_add

/** \} */
