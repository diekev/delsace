// ------------------------------
// Cas : On ne peut appeler une variable qui n'est pas un pointeur fonction.

bar :: fonc () -> rien
{
	x := 5;
	y := x();
}

// ------------------------------
// Cas : On ne peut pas nommer les arguments d'un pointeur vers une fonction.

bar :: fonc (a : fonc(r32, r64)r32) -> r32
{
	retourne a(x=0.2, z=0.4);
}

// ------------------------------
// Cas : Les pointeurs fonction ont un typage strict (échec).

ajoute_cb :: fonc (x : r64, z : r64, cb : fonc(r64, r64) r64) -> r64
{
	retourne cb(x, z);
}

ajoute_trois :: fonc (x : r64, y : r64, z : r64) -> r64
{
	retourne x + y + z;
}

bar :: fonc () -> r64
{
	retourne ajoute_cb(1.0, 2.0, ajoute_trois);
}

// ------------------------------
// Cas : Les arguments des pointeurs fonction ont un typage strict.

ajoute_cb :: fonc (x : z32, z : z32, cb : fonc(r32, r32) r32) -> r32
{
	retourne cb(x, z);
}

// ------------------------------
// Cas : Une fonction variadique dont l'argument variadic est typé ne peut prendre n'importe quel type.

printf :: fonc externe (arguments : ...z32) -> rien;

foo :: fonc () -> rien
{
	nonsûr {
		printf(0, 'z', 2.5, "chaine");
	}
}

// ------------------------------
// Cas : Un argument nommé ne peut avoir le nom d'un argument déjà nommé.

ajouter :: fonc (a : z32, b : z32) -> z32
{
	retourne a + b;
}

principale :: fonc (compte : z32, arguments : z8) -> z32
{
	x := ajouter(a=5, a=6);
	retourne x != 5;
}

// ------------------------------
// Cas : Un argument nommé ne peut avoir le nom d'un argument inconnu.

ajouter :: fonc (a : z32, b : z32) -> z32
{
	retourne a + b;
}

principale :: fonc (compte : z32, arguments : z8) -> z32
{
	x := ajouter(a=5, c=6);
	retourne x != 5;
}

// ------------------------------
// Cas : Si un argument d'une fonction appelée est nommé, tous les arguments doivent l'être (premier).

ajouter :: fonc (a : z32, b : z32) -> z32
{
	retourne a + b;
}

principale :: fonc (compte : z32, arguments : z8) -> z32
{
	x := ajouter(a=5, 6);
	retourne x != 5;
}

// ------------------------------
// Cas : Si un argument d'une fonction appelée est nommé, il ne peut pas prendre le nom d'un argument précédent anonyme.

ajouter :: fonc (a : z32, b : z32) -> z32
{
	retourne a + b;
}

principale :: fonc (compte : z32, arguments : z8) -> z32
{
	x := ajouter(5, a=6);
	retourne 0;
}

// ------------------------------
// Cas : Les types des arguments passés à une fonction ne peuvent être différents de ceux de sa définition.

ajouter :: fonc (a : z32, b : z32) -> z32
{
	retourne a + b;
}

principale :: fonc (compte : z32, arguments : z8) -> z32
{
	x := ajouter(a=5.0, b=6.0);
	retourne 0;
}

// ------------------------------
// Cas : Le nombre d'arguments (nommés) passé à une fonction lors de son appel doit être le même que le nombre d'arguments de sa définition.

ajouter :: fonc (a : z32, b : z32) -> z32
{
	retourne a + b;
}

principale :: fonc (compte : z32, arguments : z8) -> z32
{
	x := ajouter(a=5);
	retourne x != 5;
}

// ------------------------------
// Cas : Le nombre d'arguments (anonymes) passé à une fonction lors de son appel doit être le même que le nombre d'arguments de sa définition.

ajouter :: fonc (a : z32, b : z32) -> z32
{
	retourne a + b;
}

principale :: fonc (compte : z32, arguments : z8) -> z32
{
	x := ajouter(5, 6, 7);
	retourne x != 5;
}

// ------------------------------
// Cas : On ne peut appeler une fonction en utilisant un autre argument que le premier comme objet.

foo :: fonc (a : z32, b : r64) -> rien
{
	retourne;
}

bar :: fonc () -> rien
{
	a := 0.0;
	b := 5;
	a.foo(5);

	retourne;
}

